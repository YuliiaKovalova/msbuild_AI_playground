diff --git a/.github/CODEOWNERS b/.github/CODEOWNERS
index e6e7f272b6d..95d4f719323 100644
--- a/.github/CODEOWNERS
+++ b/.github/CODEOWNERS
@@ -1,7 +1,8 @@
 # Users referenced in this file will automatically be requested as reviewers for PRs that modify the given paths.
 # See https://help.github.com/articles/about-code-owners/
 
-/eng/SourceBuild*       @dotnet/source-build-internal
+/eng/DotNetBuild.props  @dotnet/product-construction
+/eng/SourceBuild*       @dotnet/source-build
 /eng/                   @dotnet/kitten
 /.github/               @dotnet/kitten
 /global.json            @dotnet/kitten
diff --git a/.github/ISSUE_TEMPLATE/01_bugreport.yml b/.github/ISSUE_TEMPLATE/01_bugreport.yml
index 35d55437a5a..d38fe76e2e6 100644
--- a/.github/ISSUE_TEMPLATE/01_bugreport.yml
+++ b/.github/ISSUE_TEMPLATE/01_bugreport.yml
@@ -1,7 +1,6 @@
 name: üêû Bug Report
 description: Report a bug to help us improve MSBuild.
-title: "[Bug]: "
-labels: ["bug"]
+type: 'Bug'
 body:
   - type: textarea
     attributes:
@@ -12,17 +11,17 @@ body:
   - type: textarea
     attributes:
       label: Steps to Reproduce
-      description:  | 
-        Include as much of the following as possible: 
-          * a minimal sample project that reproduces the issue, 
-          * your zipped project, 
-          * IDE / CLI steps to create the project and reproduce the behaviour, 
+      description:  |
+        Include as much of the following as possible:
+          * a minimal sample project that reproduces the issue,
+          * your zipped project,
+          * IDE / CLI steps to create the project and reproduce the behaviour,
           * your command line invocation.
-          
+
           If providing steps to reproduce the issue proves difficult, consider attaching a binlog:
           * [Details on sharing binary logs](https://aka.ms/msbuild/binlog)
           * [More information on binary logs](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Binary-Log.md)
-          
+
           NOTE: Binary logs capture environment information. Ensure it does not include any information you don't want to be public before you attach one.
           If you want to share one just with Microsoft, you can [report a problem through Visual Studio](https://developercommunity.visualstudio.com/report) and share it privately with Microsoft.
     validations:
@@ -49,4 +48,4 @@ body:
       description: |
         In a Visual Studio developer command prompt, run `msbuild -version` and paste the output here.
         If applicable, include the version of the tool that invokes MSBuild (Visual Studio, dotnet CLI, etc).
-        Post any other relevant configuration settings here: OS, architecture, etc.
\ No newline at end of file
+        Post any other relevant configuration settings here: OS, architecture, etc.
diff --git a/.github/ISSUE_TEMPLATE/02_performanceissue.yml b/.github/ISSUE_TEMPLATE/02_performanceissue.yml
index 7cca706981f..b9dc50d4b42 100644
--- a/.github/ISSUE_TEMPLATE/02_performanceissue.yml
+++ b/.github/ISSUE_TEMPLATE/02_performanceissue.yml
@@ -2,6 +2,7 @@ name: üìâ Performance Issue
 description: Report a performance issue or regression.
 title: "[Performance]: "
 labels: ["performance"]
+type: 'Bug'
 body:
   - type: textarea
     attributes:
@@ -12,17 +13,17 @@ body:
   - type: textarea
     attributes:
       label: Steps to Reproduce
-      description:  | 
-        Include as much of the following as possible: 
-        * a minimal sample project that reproduces the issue, 
-        * your zipped project, 
-        * IDE / CLI steps to create the project and reproduce the behaviour, 
+      description:  |
+        Include as much of the following as possible:
+        * a minimal sample project that reproduces the issue,
+        * your zipped project,
+        * IDE / CLI steps to create the project and reproduce the behaviour,
         * your command line invocation.
-        
+
         If providing steps to reproduce the issue proves difficult, consider attaching a binlog:
         * [Details on sharing binary logs](https://aka.ms/msbuild/binlog)
         * [More information on binary logs](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Binary-Log.md)
-        
+
         NOTE: Binary logs capture environment information. Ensure it does not include any information you don't want to be public before you attach one.
         If you want to share one just with Microsoft, you can [report a problem through Visual Studio](https://developercommunity.visualstudio.com/report) and share it privately with Microsoft.
     validations:
@@ -64,4 +65,4 @@ body:
     attributes:
       label: Regression Details
       description: |
-        Please provide details on regression: what version of MSBuild or VS were you using before the regression?
\ No newline at end of file
+        Please provide details on regression: what version of MSBuild or VS were you using before the regression?
diff --git a/.github/ISSUE_TEMPLATE/05_unhandledexception.yml b/.github/ISSUE_TEMPLATE/05_unhandledexception.yml
index 12388e79503..a55d4336d14 100644
--- a/.github/ISSUE_TEMPLATE/05_unhandledexception.yml
+++ b/.github/ISSUE_TEMPLATE/05_unhandledexception.yml
@@ -1,7 +1,7 @@
 name: üò± Unhandled Exception
 description: Reporting holes in our bug reporting system
 title: "[Unhandled Exception]: "
-labels: ["bug"]
+type: 'Bug'
 body:
   - type: textarea
     attributes:
@@ -12,17 +12,17 @@ body:
   - type: textarea
     attributes:
       label: Steps to Reproduce
-      description:  | 
-        Include as much of the following as possible: 
-        * a minimal sample project that reproduces the issue, 
-        * your zipped project, 
-        * IDE / CLI steps to create the project and reproduce the behaviour, 
+      description:  |
+        Include as much of the following as possible:
+        * a minimal sample project that reproduces the issue,
+        * your zipped project,
+        * IDE / CLI steps to create the project and reproduce the behaviour,
         * your command line invocation.
-        
+
         If providing steps to reproduce the issue proves difficult, consider attaching a binlog:
         * [Details on sharing binary logs](https://aka.ms/msbuild/binlog)
         * [More information on binary logs](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Binary-Log.md)
-        
+
         NOTE: Binary logs capture environment information. Ensure it does not include any information you don't want to be public before you attach one.
         If you want to share one just with Microsoft, you can [report a problem through Visual Studio](https://developercommunity.visualstudio.com/report) and share it privately with Microsoft.
     validations:
@@ -44,4 +44,4 @@ body:
       description: |
         In a Visual Studio developer command prompt, run `msbuild -version` and paste the output here.
         If applicable, include the version of the tool that invokes MSBuild (Visual Studio, dotnet CLI, etc).
-        Post any other relevant configuration settings here: OS, architecture, etc.
\ No newline at end of file
+        Post any other relevant configuration settings here: OS, architecture, etc.
diff --git a/.github/ISSUE_TEMPLATE/06_feature_request.yml b/.github/ISSUE_TEMPLATE/06_feature_request.yml
index 15a628ffe1b..5ca2069f1ad 100644
--- a/.github/ISSUE_TEMPLATE/06_feature_request.yml
+++ b/.github/ISSUE_TEMPLATE/06_feature_request.yml
@@ -1,7 +1,6 @@
 name: üí° Feature  Request
 description: Suggest an idea for this project.
-title: "[Feature Request]: "
-labels: ["Feature Request"]
+type: 'Feature'
 body:
   - type: textarea
     attributes:
diff --git a/.github/ISSUE_TEMPLATE/07_buildchecksuggestion.yml b/.github/ISSUE_TEMPLATE/07_buildchecksuggestion.yml
index 7af03649c5e..c728e10acba 100644
--- a/.github/ISSUE_TEMPLATE/07_buildchecksuggestion.yml
+++ b/.github/ISSUE_TEMPLATE/07_buildchecksuggestion.yml
@@ -2,6 +2,7 @@ name: üí° BuildCheck Suggestion
 description: Suggesting a diagnostic check (AKA [BuildCheck](https://github.com/dotnet/msbuild/blob/main/documentation/specs/BuildCheck/BuildCheck.md)) that MSBuild could provide.
 title: "[BuildCheck Suggestion]: "
 labels: ["BuildCheck Suggestion", "Area: BuildCheck"]
+type: 'Feature'
 body:
   - type: textarea
     attributes:
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 1cb66face7d..1444313d595 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -37,7 +37,6 @@ variables:
     value: true # Enable loc for vs17.13
   - name: Codeql.Enabled
     value: true
-  - group: DotNet-MSBuild-SDLValidation-Params
 
 resources:
   repositories:
@@ -56,6 +55,7 @@ extends:
     sdl:
       policheck:
         enabled: true
+        exclusionsFile: $(Build.SourcesDirectory)\eng\policheck_exclusions.xml
       tsa:
         enabled: true
       # We generate SBOM ourselves, so don't need steps injected by 1ES.
@@ -310,18 +310,3 @@ extends:
         enableSymbolValidation: true
         enableSourceLinkValidation: false
         enableNugetValidation: false
-        SDLValidationParameters:
-          enable: true
-          continueOnError: false
-          params: ' -SourceToolsList @("policheck","credscan")
-          -TsaInstanceURL "$(_TsaInstanceURL)"
-          -TsaProjectName "$(_TsaProjectName)"
-          -TsaNotificationEmail "$(_TsaNotificationEmail)"
-          -TsaCodebaseAdmin "$(_TsaCodebaseAdmin)"
-          -TsaBugAreaPath "$(_TsaBugAreaPath)"
-          -TsaIterationPath "$(_TsaIterationPath)"
-          -TsaRepositoryName "dotnet-msbuild"
-          -TsaCodebaseName "dotnet-msbuild"
-          -TsaPublish $True
-          -CrScanAdditionalRunConfigParams @("SuppressionsPath < $(Build.SourcesDirectory)\eng\CredScanSuppressions.json")
-          -PoliCheckAdditionalRunConfigParams @("UserExclusionPath < $(Build.SourcesDirectory)\eng\policheck_exclusions.xml")'
diff --git a/NuGet.config b/NuGet.config
index 659ab421680..fdddc30ece5 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -4,11 +4,7 @@
     <clear />
     <!--Begin: Package sources managed by Dependency Flow automation. Do not edit the sources below.-->
     <!--  Begin: Package sources from dotnet-runtime -->
-    <add key="darc-int-dotnet-runtime-2aade6b" value="https://pkgs.dev.azure.com/dnceng/internal/_packaging/darc-int-dotnet-runtime-2aade6be/nuget/v3/index.json" />
-    <add key="darc-int-dotnet-runtime-2aade6b-5" value="https://pkgs.dev.azure.com/dnceng/internal/_packaging/darc-int-dotnet-runtime-2aade6be-5/nuget/v3/index.json" />
-    <add key="darc-int-dotnet-runtime-2aade6b-3" value="https://pkgs.dev.azure.com/dnceng/internal/_packaging/darc-int-dotnet-runtime-2aade6be-3/nuget/v3/index.json" />
-    <add key="darc-int-dotnet-runtime-2aade6b-2" value="https://pkgs.dev.azure.com/dnceng/internal/_packaging/darc-int-dotnet-runtime-2aade6be-2/nuget/v3/index.json" />
-    <add key="darc-int-dotnet-runtime-2aade6b-1" value="https://pkgs.dev.azure.com/dnceng/internal/_packaging/darc-int-dotnet-runtime-2aade6be-1/nuget/v3/index.json" />
+    <add key="darc-int-dotnet-runtime-81cabf2-3" value="https://pkgs.dev.azure.com/dnceng/internal/_packaging/darc-int-dotnet-runtime-81cabf28-3/nuget/v3/index.json" />
     <!--  End: Package sources from dotnet-runtime -->
     <!--End: Package sources managed by Dependency Flow automation. Do not edit the sources above.-->
     <add key="arcade" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json" />
@@ -23,11 +19,7 @@
   <disabledPackageSources>
     <!--Begin: Package sources managed by Dependency Flow automation. Do not edit the sources below.-->
     <!--  Begin: Package sources from dotnet-runtime -->
-    <add key="darc-int-dotnet-runtime-2aade6b-1" value="true" />
-    <add key="darc-int-dotnet-runtime-2aade6b-2" value="true" />
-    <add key="darc-int-dotnet-runtime-2aade6b-3" value="true" />
-    <add key="darc-int-dotnet-runtime-2aade6b-5" value="true" />
-    <add key="darc-int-dotnet-runtime-2aade6b" value="true" />
+    <add key="darc-int-dotnet-runtime-81cabf2-3" value="true" />
     <!--  End: Package sources from dotnet-runtime -->
     <!--End: Package sources managed by Dependency Flow automation. Do not edit the sources above.-->
   </disabledPackageSources>
diff --git a/documentation/specs/BuildCheck/BuildCheck-Architecture.md b/documentation/specs/BuildCheck/BuildCheck-Architecture.md
index 2d111ac77fa..6c24d76b502 100644
--- a/documentation/specs/BuildCheck/BuildCheck-Architecture.md
+++ b/documentation/specs/BuildCheck/BuildCheck-Architecture.md
@@ -67,19 +67,19 @@ The BuildCheck infrastructure will be prepared to be available concurrently with
 
 Prerequisites: [MSBuild Replaying a Binary Log](../../wiki/Binary-Log.md#replaying-a-binary-log)
 
-When replaying a binary log, we can apply BuildCheck with help of `-check` switch:
+When replaying a binary log, we can apply BuildChecks with help of `-check` switch:
 ```
-> msbuild.exe msbuild.binlog -check
+> msbuild msbuild.binlog -check
 ```
 
 If BuildCheck is enabled, then the events from `BinaryLogReplayEventSource` and new events from BuildCheck are merged into the `IEventSource`, from which the loggers get events.
 
 ```mermaid
 flowchart TD
-    replayEventSource[BinaryLogReplayEventSource\nreplayEventSource] --> mergedEventSource[IEventSource\nmergedEventSource]
-    replayEventSource[BinaryLogReplayEventSource\nreplayEventSource] --> BuildCheckBuildEventHandler[BuildCheckBuildEventHandler]
-    BuildCheckBuildEventHandler[BuildCheckBuildEventHandler] --> mergedEventSource[IEventSource\nmergedEventSource]
-    mergedEventSource[IEventSource\nmergedEventSource] --> loggers
+    replayEventSource[BinaryLogReplayEventSource replayEventSource] --> mergedEventSource[IEventSource mergedEventSource]
+    replayEventSource[BinaryLogReplayEventSource replayEventSource] --> BuildCheckBuildEventHandler[BuildCheckBuildEventHandler]
+    BuildCheckBuildEventHandler[BuildCheckBuildEventHandler] --> mergedEventSource[IEventSource mergedEventSource]
+    mergedEventSource[IEventSource mergedEventSource] --> loggers
 ```
 1. The events from `BinaryLogReplayEventSource replayEventSource` are passed to the `IEventSource mergedEventSource` unchanged.
 2. The events from `BinaryLogReplayEventSource replayEventSource` are passed to `BuildCheckBuildEventHandler` in order to produce new events from BuildCheck.
diff --git a/documentation/wiki/CollectedTelemetry.md b/documentation/wiki/CollectedTelemetry.md
new file mode 100644
index 00000000000..de290b12f15
--- /dev/null
+++ b/documentation/wiki/CollectedTelemetry.md
@@ -0,0 +1,96 @@
+# MSBuild Telemetry
+
+MSBuild emits and collects telemetry to guide decisions on modernization and optimization investments. Currently the MSBuild collects telemetry only when run from SDK host (mostly the `dotnet build` and `dotnet msbuild` commands). For more details please refer to [the official SDK telemetry documentation](https://learn.microsoft.com/dotnet/core/tools/telemetry).
+
+Visual Studio collects some build related telemetry - but that is not leveraging any MSBuild instrumentation, but rather information about count and duration of MSBuild API invocations from the caller point of view. For general information about telemetry being collected by Visual Studio Family of products and regulations compliance please refer to [the official documentation](https://learn.microsoft.com/compliance/regulatory/gdpr-dsr-visual-studio-family).
+
+## Type of data collected
+
+To tailor modernization and performance optimization investments we need to contain *anonymized* **Usage Data**. Those reflect type of features being used and execution time being spent in them.
+
+## Opting out
+
+MSBuild telemetry collection (that is turned on by default), can be opted out - same as .NET SDK telemetry in general - via setting `DOTNET_CLI_TELEMETRY_OPTOUT` environment variable to `1` or `true`.
+
+## Datapoints overview
+
+### Logging Configuration
+
+Expressed and collected via [LoggingConfigurationTelemetry type](https://github.com/dotnet/msbuild/blob/94941d9cb26bb86045452b4a174a357b65a30c99/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs)
+
+| SDK versions | Data |
+|--------------|------|
+| >= 8.0.100   | Indication if terminal logger was used. |
+| >= 8.0.100   | User choice on terminal logger enablement. |
+| >= 8.0.100   | Source of user choice on terminal logger enablement. |
+| >= 8.0.100   | Default choice on terminal logger enablement. |
+| >= 8.0.100   | Source of default choice on terminal logger enablement. |
+| >= 8.0.100   | Indication if Console logger was used. |
+| >= 8.0.100   | Console logger type (serial, parallel). |
+| >= 8.0.100   | Console logger verbosity. |
+| >= 8.0.100   | Indication if File logger was used. |
+| >= 8.0.100   | File logger type (serial, parallel). |
+| >= 8.0.100   | Number of file loggers. |
+| >= 8.0.100   | File logger verbosity. |
+| >= 8.0.100   | Indication if Binary logger was used. |
+| >= 8.0.100   | Indication if Binary logger used with default log name. |
+
+### BuildCheck
+
+Expressed and collected via [BuildCheckTelemetry type](https://github.com/dotnet/msbuild/blob/94941d9cb26bb86045452b4a174a357b65a30c99/src/Framework/Telemetry/BuildCheckTelemetry.cs)
+
+#### BuildCheck Run
+
+| SDK versions | Data |
+|--------------|------|
+| >= 9.0.100   | Corelation guid for the run |
+| >= 9.0.100   | Count of enabled rules for the run |
+| >= 9.0.100   | Count of enabled custom rules for the run |
+| >= 9.0.100   | Count of violations encountered for the run |
+| >= 9.0.100   | Execution time spent by BuildCheck infrastructure and rules |
+
+#### BuildCheck Rule in a run
+
+| SDK versions | Data |
+|--------------|------|
+| >= 9.0.100   | Corelation guid for the run. |
+| >= 9.0.100   | Id of the rule. |
+| >= 9.0.100   | Hashed Check Friendly name. |
+| >= 9.0.100   | Indication if this is a built-in Check. |
+| >= 9.0.100   | Default severity of a Check. |
+| >= 9.0.100   | Number of projects that had this rule enabled. |
+| >= 9.0.100   | List of explicit severities set for this rule (those can vary per project - hence list). |
+| >= 9.0.100   | Count of diagnostics with Message severity emitted by this rule. |
+| >= 9.0.100   | Count of diagnostics with Warning severity emitted by this rule. |
+| >= 9.0.100   | Count of diagnostics with Error severity emitted by this rule. |
+| >= 9.0.100   | Indication whether the rule was throttled. |
+| >= 9.0.100   | Execution time spent by executing the Check defining this rule |
+
+#### BuildCheck Extensibility issues
+
+| SDK versions | Data |
+|--------------|------|
+| >= 9.0.100   | Corelation guid for the run. |
+| >= 9.0.100   | Hashed name of assembly that was referenced as a custom Check. |
+| >= 9.0.100   | Hashed exception type thrown when attempting to load the custom check. |
+| >= 9.0.100   | Hashed exception message thrown when attempting to load the custom check. |
+
+### General Build
+
+Expressed and collected via [BuildTelemetry type](https://github.com/dotnet/msbuild/blob/94941d9cb26bb86045452b4a174a357b65a30c99/src/Framework/Telemetry/BuildTelemetry.cs)
+
+| SDK versions | Data |
+|--------------|------|
+| All          | Display version of the Engine suitable for display to a user. |
+| All          | Duration of the build - from when it was requested (via API or CLI). |
+| All          | Duration of the build - from when it was started by internal BuildManager. |
+| All          | Build engine runtime name. |
+| All          | Host in which MSBuild build was executed (e.g. "VS", "VSCode", "Azure DevOps", "GitHub Action", "CLI"). |
+| All          | State of MSBuild server process before this build (one of 'cold', 'hot', null (if not run as server)). |
+| All          | Path to project file. |
+| All          | MSBuild server fallback reason (either "ServerBusy", "ConnectionError" or null (no fallback)). |
+| All          | Overall build success (true, false). |
+| All          | Build target. |
+| All          | Version of MSBuild. |
+| >= 9.0.100   | Indication of enablement of BuildCheck feature. |
+| >= 9.0.100   | Indication of Smart App Control being in evaluation mode on machine executing the build. |
diff --git a/documentation/wiki/UnGAC.md b/documentation/wiki/UnGAC.md
index 992088a8d7e..8af02ccbd3d 100644
--- a/documentation/wiki/UnGAC.md
+++ b/documentation/wiki/UnGAC.md
@@ -24,6 +24,7 @@ Run the [EnumerateMSBuild powershell script](https://github.com/dotnet/msbuild/b
     gacutil /u "BuildXL.Processes, Version=1.0.0.0"
     gacutil /u "BuildXL.Utilities.Core, Version=1.0.0.0"
     gacutil /u "BuildXL.Native, Version=1.0.0.0"
+    gacutil /u "Microsoft.VisualStudio.SolutionPersistence, Version=1.0.0.0"
     ```
 3. If you want to do this 'safely', move the folder out of the GAC and return it if it doesn't resolve the issue.
 
diff --git a/eng/BootStrapMsBuild.targets b/eng/BootStrapMsBuild.targets
index dcff8617638..e8a3ce58dd4 100644
--- a/eng/BootStrapMsBuild.targets
+++ b/eng/BootStrapMsBuild.targets
@@ -238,4 +238,6 @@
 
   </Target>
 
+  <Import Project=".\TestAssets.targets" />
+
 </Project>
diff --git a/eng/DotNetBuild.props b/eng/DotNetBuild.props
index 6959f68f31f..778419d070a 100644
--- a/eng/DotNetBuild.props
+++ b/eng/DotNetBuild.props
@@ -1,4 +1,4 @@
-<!-- Whenever altering this or other Source Build files, please include @dotnet/source-build-internal as a reviewer. -->
+<!-- When altering this file, include @dotnet/product-construction as a reviewer. -->
 
 <Project>
 
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index 41e59576f29..6693866df16 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -1,4 +1,4 @@
-<!-- Whenever altering this or other Source Build files, please include @dotnet/source-build-internal as a reviewer. -->
+<!-- When altering this file or making other Source Build related changes, include @dotnet/source-build as a reviewer. -->
 <!-- See aka.ms/dotnet/prebuilts for guidance on what pre-builts are and how to eliminate them. -->
 
 <UsageData>
@@ -17,6 +17,8 @@
     <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Text.Json/*8.0.5*" />
     <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Formats.Asn1/*8.0.1*" />
+	  <UsagePattern IdentityGlob="Microsoft.VisualStudio.SolutionPersistence/*1.0.9*" />
   </IgnorePatterns>
   <Usages>
   </Usages>
diff --git a/eng/TestAssets.targets b/eng/TestAssets.targets
new file mode 100644
index 00000000000..5b0f86cf1d7
--- /dev/null
+++ b/eng/TestAssets.targets
@@ -0,0 +1,28 @@
+<Project>
+  <!-- This target creates packages needed for e2e testing. Inputs and outputs are defined to enable incremental builds.
+    It must be run after getting bootstrapped msbuild versions because copy operation blocks the dlls.-->
+  <PropertyGroup Label="TestAssests">
+    <ArtifactsNonShippingPackagesDir>$(ArtifactsBinDir)Microsoft.Build.BuildCheck.UnitTests\CustomChecks</ArtifactsNonShippingPackagesDir>
+  </PropertyGroup>
+
+  <ItemGroup Label="TestAssets">
+    <ProjectsToPack Include="..\Build\Microsoft.Build.csproj" />
+    <ProjectsToPack Include="..\Framework\Microsoft.Build.Framework.csproj" />
+    <ProjectsToPack Include="..\StringTools\StringTools.csproj" />
+  </ItemGroup>
+
+  <Target Name="GetSourceFilesForPacking">
+    <ItemGroup>
+      <SourceFilesForPacking Include="%(ProjectsToPack.RootDir)%(ProjectsToPack.Directory)**\*.cs" />
+    </ItemGroup>
+  </Target>
+
+  <Target Name="MSBuildPackagesForTests"
+          AfterTargets="BootstrapFull;BootstrapCore"
+          DependsOnTargets="GetSourceFilesForPacking"
+          Inputs="@(ProjectsToPack);@(SourceFilesForPacking)"
+          Outputs="$(ArtifactsNonShippingPackagesDir)\Microsoft.Build.$(Version).nupkg;$(ArtifactsNonShippingPackagesDir)\Microsoft.Build.Framework.$(Version).nupkg;$(ArtifactsNonShippingPackagesDir)\Microsoft.NET.StringTools.$(Version).nupkg">
+    <Exec Command="dotnet pack &quot;%(ProjectsToPack.Identity)&quot; -o &quot;$(ArtifactsNonShippingPackagesDir)&quot; -p:PackageVersion=$(PackageVersion)" />
+  </Target>
+
+</Project>
\ No newline at end of file
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index c195807e00b..ee325a6a2c7 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -53,9 +53,9 @@
       <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
       <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
-    <Dependency Name="System.Text.Json" Version="8.0.4">
+    <Dependency Name="System.Text.Json" Version="8.0.5">
       <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>2aade6beb02ea367fd97c4070a4198802fe61c03</Sha>
+      <Sha>81cabf2857a01351e5ab578947c7403a5b128ad1</Sha>
     </Dependency>
     <Dependency Name="System.Threading.Tasks.Dataflow" Version="8.0.0">
       <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
@@ -71,36 +71,36 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.24503.2">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.24516.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>beb827ded6acdff8c7333dfc6583cc984a8f2620</Sha>
+      <Sha>3c393bbd85ae16ddddba20d0b75035b0c6f1a52d</Sha>
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.24503.2">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.24516.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>beb827ded6acdff8c7333dfc6583cc984a8f2620</Sha>
+      <Sha>3c393bbd85ae16ddddba20d0b75035b0c6f1a52d</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.24503.2">
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.24516.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>beb827ded6acdff8c7333dfc6583cc984a8f2620</Sha>
+      <Sha>3c393bbd85ae16ddddba20d0b75035b0c6f1a52d</Sha>
     </Dependency>
     <Dependency Name="NuGet.Build.Tasks" Version="6.12.0-rc.127">
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>19756345139c45de23bd196e9b4be01d48e84fdd</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.12.0-3.24504.7">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.13.0-1.24522.11">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>6a9d2b077973e31b213517579f674b461053ac1c</Sha>
+      <Sha>048a23fcea1ef7346d2a59d4e4345dbb1fb780b9</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.12.0-3.24504.7">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.13.0-1.24522.11">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>6a9d2b077973e31b213517579f674b461053ac1c</Sha>
+      <Sha>048a23fcea1ef7346d2a59d4e4345dbb1fb780b9</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.24503.2">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.24516.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>beb827ded6acdff8c7333dfc6583cc984a8f2620</Sha>
+      <Sha>3c393bbd85ae16ddddba20d0b75035b0c6f1a52d</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 7df9b218345..b74aa6db071 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -50,15 +50,15 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.24503.2</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.24516.2</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.1</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.12.0-3.24504.7</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.13.0-1.24522.11</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.12.0-rc.127</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
-    <BootstrapSdkVersion>9.0.100-rc.1.24452.12</BootstrapSdkVersion>
+    <BootstrapSdkVersion>9.0.100-rc.2.24474.11</BootstrapSdkVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
@@ -76,4 +76,8 @@
       <FileVersion>$(VersionPrefix).$(FileVersion.Split('.')[3])</FileVersion>
     </PropertyGroup>
   </Target>
+  <!-- SolutionPersistence -->
+  <PropertyGroup>
+    <MicrosoftVisualStudioSolutionPersistenceVersion>1.0.9</MicrosoftVisualStudioSolutionPersistenceVersion>
+  </PropertyGroup>
 </Project>
diff --git a/eng/cibuild_bootstrapped_msbuild.ps1 b/eng/cibuild_bootstrapped_msbuild.ps1
index 16f71befe5c..6175fbc44f6 100644
--- a/eng/cibuild_bootstrapped_msbuild.ps1
+++ b/eng/cibuild_bootstrapped_msbuild.ps1
@@ -86,7 +86,7 @@ try {
   {
     $buildToolPath = Join-Path $bootstrapRoot "core\dotnet.exe"
     # The version must be consistent with BootstrapSdkVersion
-    $buildToolCommand = Join-Path $bootstrapRoot "core\sdk\9.0.100-rc.1.24452.12\MSBuild.dll"
+    $buildToolCommand = Join-Path $bootstrapRoot "core\sdk\9.0.100-rc.2.24474.11\MSBuild.dll"
     $buildToolFramework = "net9.0"
   }
 
diff --git a/eng/cibuild_bootstrapped_msbuild.sh b/eng/cibuild_bootstrapped_msbuild.sh
index 60c09cf8873..2926b7e75be 100755
--- a/eng/cibuild_bootstrapped_msbuild.sh
+++ b/eng/cibuild_bootstrapped_msbuild.sh
@@ -60,7 +60,7 @@ if [ $host_type = "core" ]
 then
   _InitializeBuildTool="$bootstrapRoot/core/dotnet"
   # The version must be consistent with BootstrapSdkVersion
-  _InitializeBuildToolCommand="$bootstrapRoot/core/sdk/9.0.100-rc.1.24452.12/MSBuild.dll"
+  _InitializeBuildToolCommand="$bootstrapRoot/core/sdk/9.0.100-rc.2.24474.11/MSBuild.dll"
   _InitializeBuildToolFramework="net9.0"
 else
   echo "Unsupported hostType ($host_type)"
diff --git a/eng/common/core-templates/steps/get-delegation-sas.yml b/eng/common/core-templates/steps/get-delegation-sas.yml
index d2901470a7f..9db5617ea7d 100644
--- a/eng/common/core-templates/steps/get-delegation-sas.yml
+++ b/eng/common/core-templates/steps/get-delegation-sas.yml
@@ -31,7 +31,16 @@ steps:
       # Calculate the expiration of the SAS token and convert to UTC
       $expiry = (Get-Date).AddHours(${{ parameters.expiryInHours }}).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
 
-      $sas = az storage container generate-sas --account-name ${{ parameters.storageAccount }} --name ${{ parameters.container }} --permissions ${{ parameters.permissions }} --expiry $expiry --auth-mode login --as-user -o tsv
+      # Temporarily work around a helix issue where SAS tokens with / in them will cause incorrect downloads
+      # of correlation payloads. https://github.com/dotnet/dnceng/issues/3484
+      $sas = ""
+      do {
+        $sas = az storage container generate-sas --account-name ${{ parameters.storageAccount }} --name ${{ parameters.container }} --permissions ${{ parameters.permissions }} --expiry $expiry --auth-mode login --as-user -o tsv
+        if ($LASTEXITCODE -ne 0) {
+          Write-Error "Failed to generate SAS token."
+          exit 1
+        }
+      } while($sas.IndexOf('/') -ne -1)
 
       if ($LASTEXITCODE -ne 0) {
         Write-Error "Failed to generate SAS token."
diff --git a/eng/common/sdl/NuGet.config b/eng/common/sdl/NuGet.config
index 3849bdb3cf5..5bfbb02ef04 100644
--- a/eng/common/sdl/NuGet.config
+++ b/eng/common/sdl/NuGet.config
@@ -5,11 +5,11 @@
   </solution>
   <packageSources>
     <clear />
-    <add key="guardian" value="https://securitytools.pkgs.visualstudio.com/_packaging/Guardian/nuget/v3/index.json" />
+    <add key="guardian" value="https://pkgs.dev.azure.com/dnceng/_packaging/Guardian1ESPTUpstreamOrgFeed/nuget/v3/index.json" />
   </packageSources>
   <packageSourceMapping>
     <packageSource key="guardian">
-      <package pattern="microsoft.guardian.cli" />
+      <package pattern="Microsoft.Guardian.Cli.win-x64" />
     </packageSource>
   </packageSourceMapping>
   <disabledPackageSources>
diff --git a/eng/common/sdl/execute-all-sdl-tools.ps1 b/eng/common/sdl/execute-all-sdl-tools.ps1
index 4715d75e974..81ded5b7f47 100644
--- a/eng/common/sdl/execute-all-sdl-tools.ps1
+++ b/eng/common/sdl/execute-all-sdl-tools.ps1
@@ -6,7 +6,6 @@ Param(
   [string] $BranchName=$env:BUILD_SOURCEBRANCH,                                                  # Optional: name of branch or version of gdn settings; defaults to master
   [string] $SourceDirectory=$env:BUILD_SOURCESDIRECTORY,                                         # Required: the directory where source files are located
   [string] $ArtifactsDirectory = (Join-Path $env:BUILD_ARTIFACTSTAGINGDIRECTORY ('artifacts')),  # Required: the directory where build artifacts are located
-  [string] $AzureDevOpsAccessToken,                                                              # Required: access token for dnceng; should be provided via KeyVault
 
   # Optional: list of SDL tools to run on source code. See 'configure-sdl-tool.ps1' for tools list
   # format.
@@ -75,7 +74,7 @@ try {
   }
 
   Exec-BlockVerbosely {
-    & $(Join-Path $PSScriptRoot 'init-sdl.ps1') -GuardianCliLocation $guardianCliLocation -Repository $RepoName -BranchName $BranchName -WorkingDirectory $workingDirectory -AzureDevOpsAccessToken $AzureDevOpsAccessToken -GuardianLoggerLevel $GuardianLoggerLevel
+    & $(Join-Path $PSScriptRoot 'init-sdl.ps1') -GuardianCliLocation $guardianCliLocation -Repository $RepoName -BranchName $BranchName -WorkingDirectory $workingDirectory -GuardianLoggerLevel $GuardianLoggerLevel
   }
   $gdnFolder = Join-Path $workingDirectory '.gdn'
 
@@ -104,7 +103,6 @@ try {
           -TargetDirectory $targetDirectory `
           -GdnFolder $gdnFolder `
           -ToolsList $tools `
-          -AzureDevOpsAccessToken $AzureDevOpsAccessToken `
           -GuardianLoggerLevel $GuardianLoggerLevel `
           -CrScanAdditionalRunConfigParams $CrScanAdditionalRunConfigParams `
           -PoliCheckAdditionalRunConfigParams $PoliCheckAdditionalRunConfigParams `
diff --git a/eng/common/sdl/init-sdl.ps1 b/eng/common/sdl/init-sdl.ps1
index 3ac1d92b370..588ff8e22fb 100644
--- a/eng/common/sdl/init-sdl.ps1
+++ b/eng/common/sdl/init-sdl.ps1
@@ -3,7 +3,6 @@ Param(
   [string] $Repository,
   [string] $BranchName='master',
   [string] $WorkingDirectory,
-  [string] $AzureDevOpsAccessToken,
   [string] $GuardianLoggerLevel='Standard'
 )
 
@@ -21,14 +20,7 @@ $ci = $true
 # Don't display the console progress UI - it's a huge perf hit
 $ProgressPreference = 'SilentlyContinue'
 
-# Construct basic auth from AzDO access token; construct URI to the repository's gdn folder stored in that repository; construct location of zip file
-$encodedPat = [Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes(":$AzureDevOpsAccessToken"))
-$escapedRepository = [Uri]::EscapeDataString("/$Repository/$BranchName/.gdn")
-$uri = "https://dev.azure.com/dnceng/internal/_apis/git/repositories/sdl-tool-cfg/Items?path=$escapedRepository&versionDescriptor[versionOptions]=0&`$format=zip&api-version=5.0"
-$zipFile = "$WorkingDirectory/gdn.zip"
-
 Add-Type -AssemblyName System.IO.Compression.FileSystem
-$gdnFolder = (Join-Path $WorkingDirectory '.gdn')
 
 try {
   # if the folder does not exist, we'll do a guardian init and push it to the remote repository
diff --git a/eng/common/sdl/sdl.ps1 b/eng/common/sdl/sdl.ps1
index 648c5068d7d..7fe603fe995 100644
--- a/eng/common/sdl/sdl.ps1
+++ b/eng/common/sdl/sdl.ps1
@@ -4,6 +4,8 @@ function Install-Gdn {
         [Parameter(Mandatory=$true)]
         [string]$Path,
 
+        [string]$Source = "https://pkgs.dev.azure.com/dnceng/_packaging/Guardian1ESPTUpstreamOrgFeed/nuget/v3/index.json",
+
         # If omitted, install the latest version of Guardian, otherwise install that specific version.
         [string]$Version
     )
@@ -19,7 +21,7 @@ function Install-Gdn {
     $ci = $true
     . $PSScriptRoot\..\tools.ps1
 
-    $argumentList = @("install", "Microsoft.Guardian.Cli", "-Source https://securitytools.pkgs.visualstudio.com/_packaging/Guardian/nuget/v3/index.json", "-OutputDirectory $Path", "-NonInteractive", "-NoCache")
+    $argumentList = @("install", "Microsoft.Guardian.Cli.win-x64", "-Source $Source", "-OutputDirectory $Path", "-NonInteractive", "-NoCache")
 
     if ($Version) {
         $argumentList += "-Version $Version"
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index 9574f4eb9df..22954477a57 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -900,7 +900,7 @@ function IsWindowsPlatform() {
 }
 
 function Get-Darc($version) {
-  $darcPath  = "$TempDir\darc\$(New-Guid)"
+  $darcPath  = "$TempDir\darc\$([guid]::NewGuid())"
   if ($version -ne $null) {
     & $PSScriptRoot\darc-init.ps1 -toolpath $darcPath -darcVersion $version | Out-Host
   } else {
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 1672382b7c3..4aab28833bb 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -60,6 +60,8 @@
 
     <PackageVersion Include="Verify.Xunit" Version="19.14.1" />
     <PackageVersion Update="Verify.XUnit" Condition="'$(VerifyXUnitVersion)' != ''" Version="$(VerifyXUnitVersion)" />
+	
+	<PackageVersion Include="Microsoft.VisualStudio.SolutionPersistence" Version="$(MicrosoftVisualStudioSolutionPersistenceVersion)" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildSourceOnly)' != 'true' AND $(ProjectIsDeprecated) != 'true'">
diff --git a/global.json b/global.json
index 055227f031e..03cd1994123 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "9.0.100-rc.1.24452.12",
+    "dotnet": "9.0.100-rc.2.24474.11",
     "vs": {
       "version": "17.10.0"
     },
     "xcopy-msbuild": "17.10.0-pre.4.0"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.24503.2"
+    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.24516.2"
   }
 }
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index 84d703d22e8..d6abd900521 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -4,10 +4,15 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using System.Linq;
 using System.Text;
+using System.Threading;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Shared;
+using Microsoft.VisualStudio.SolutionPersistence;
+using Microsoft.VisualStudio.SolutionPersistence.Model;
+using Microsoft.VisualStudio.SolutionPersistence.Serializer;
 using Shouldly;
 using Xunit;
 
@@ -59,11 +64,13 @@ public void ParseSolution_VC()
         /// Test that a project with the C++ project guid and an arbitrary extension is seen as valid --
         /// we assume that all C++ projects except .vcproj are MSBuild format.
         /// </summary>
-        [Fact]
-        public void ParseSolution_VC2()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseSolution_VC2(bool convertToSlnx)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}') = 'Project name.myvctype', 'Relative path\to\Project name.myvctype', '{0ABED153-9451-483C-8140-9E8D7306B216}'
@@ -83,13 +90,18 @@ public void ParseSolution_VC2()
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
 
-            Assert.Equal("Project name.myvctype", solution.ProjectsInOrder[0].ProjectName);
-            Assert.Equal("Relative path\\to\\Project name.myvctype", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
+            string expectedProjectName = convertToSlnx ? "Project name" : "Project name.myvctype";
+            Assert.Equal(expectedProjectName, solution.ProjectsInOrder[0].ProjectName);
+            Assert.Equal(ConvertToUnixPathIfNeeded("Relative path\\to\\Project name.myvctype", convertToSlnx), solution.ProjectsInOrder[0].RelativePath);
+            if (!convertToSlnx)
+            {
+                // When converting to SLNX, the project GUID is not preserved.
+                Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
+            }
         }
 
         /// <summary>
@@ -280,11 +292,13 @@ public void ParseSolutionFileWithDescriptionInformation()
         /// <summary>
         /// Tests the parsing of a very basic .SLN file with three independent projects.
         /// </summary>
-        [Fact]
-        public void BasicSolution()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void BasicSolution(bool convertToSlnx)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{F184B08F-C81C-45F6-A57F-5ABD9991F28F}') = 'ConsoleApplication1', 'ConsoleApplication1\ConsoleApplication1.vbproj', '{AB3413A6-D689-486D-B7F0-A095371B3F13}'
@@ -316,34 +330,40 @@ public void BasicSolution()
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
 
             Assert.Equal(3, solution.ProjectsInOrder.Count);
 
-            Assert.Equal("ConsoleApplication1", solution.ProjectsInOrder[0].ProjectName);
-            Assert.Equal(@"ConsoleApplication1\ConsoleApplication1.vbproj", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{AB3413A6-D689-486D-B7F0-A095371B3F13}", solution.ProjectsInOrder[0].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[0].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
+            // When converting to slnx, the order of the projects is not preserved.
+            ProjectInSolution consoleApplication1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ConsoleApplication1");
+            Assert.Equal(ConvertToUnixPathIfNeeded("ConsoleApplication1\\ConsoleApplication1.vbproj", convertToSlnx), consoleApplication1.RelativePath);
+            Assert.Empty(consoleApplication1.Dependencies);
+            Assert.Null(consoleApplication1.ParentProjectGuid);
 
-            Assert.Equal("vbClassLibrary", solution.ProjectsInOrder[1].ProjectName);
-            Assert.Equal(@"vbClassLibrary\vbClassLibrary.vbproj", solution.ProjectsInOrder[1].RelativePath);
-            Assert.Equal("{BA333A76-4511-47B8-8DF4-CA51C303AD0B}", solution.ProjectsInOrder[1].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[1].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
+            ProjectInSolution vbClassLibrary = solution.ProjectsInOrder.First(p => p.ProjectName == "vbClassLibrary");
+            Assert.Equal(ConvertToUnixPathIfNeeded("vbClassLibrary\\vbClassLibrary.vbproj", convertToSlnx), vbClassLibrary.RelativePath);
+            Assert.Empty(vbClassLibrary.Dependencies);
+            Assert.Null(vbClassLibrary.ParentProjectGuid);
 
-            Assert.Equal("ClassLibrary1", solution.ProjectsInOrder[2].ProjectName);
-            Assert.Equal(@"ClassLibrary1\ClassLibrary1.csproj", solution.ProjectsInOrder[2].RelativePath);
-            Assert.Equal("{DEBCE986-61B9-435E-8018-44B9EF751655}", solution.ProjectsInOrder[2].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[2].ParentProjectGuid);
+            ProjectInSolution classLibrary1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", convertToSlnx), classLibrary1.RelativePath);
+            Assert.Empty(classLibrary1.Dependencies);
+            Assert.Null(classLibrary1.ParentProjectGuid);
+
+            if (!convertToSlnx)
+            {
+                Assert.Equal("{AB3413A6-D689-486D-B7F0-A095371B3F13}", consoleApplication1.ProjectGuid);
+                Assert.Equal("{BA333A76-4511-47B8-8DF4-CA51C303AD0B}", vbClassLibrary.ProjectGuid);
+                Assert.Equal("{DEBCE986-61B9-435E-8018-44B9EF751655}", classLibrary1.ProjectGuid);
+            }
         }
 
         /// <summary>
         /// Exercises solution folders, and makes sure that samely named projects in different
         /// solution folders will get correctly uniquified.
+        /// For the new parser, solution folders are not included to ProjectsInOrder or ProjectsByGuid.
         /// </summary>
         [Fact]
         public void SolutionFolders()
@@ -396,7 +416,7 @@ public void SolutionFolders()
 
             Assert.Equal(5, solution.ProjectsInOrder.Count);
 
-            Assert.Equal(@"ClassLibrary1\ClassLibrary1.csproj", solution.ProjectsInOrder[0].RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", false), solution.ProjectsInOrder[0].RelativePath);
             Assert.Equal("{34E0D07D-CF8F-459D-9449-C4188D8C5564}", solution.ProjectsInOrder[0].ProjectGuid);
             Assert.Empty(solution.ProjectsInOrder[0].Dependencies);
             Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
@@ -405,7 +425,7 @@ public void SolutionFolders()
             Assert.Empty(solution.ProjectsInOrder[1].Dependencies);
             Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
 
-            Assert.Equal(@"MyPhysicalFolder\ClassLibrary1\ClassLibrary1.csproj", solution.ProjectsInOrder[2].RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("MyPhysicalFolder\\ClassLibrary1\\ClassLibrary1.csproj", false), solution.ProjectsInOrder[2].RelativePath);
             Assert.Equal("{A5EE8128-B08E-4533-86C5-E46714981680}", solution.ProjectsInOrder[2].ProjectGuid);
             Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
             Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", solution.ProjectsInOrder[2].ParentProjectGuid);
@@ -414,12 +434,90 @@ public void SolutionFolders()
             Assert.Empty(solution.ProjectsInOrder[3].Dependencies);
             Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", solution.ProjectsInOrder[3].ParentProjectGuid);
 
-            Assert.Equal(@"ClassLibrary2\ClassLibrary2.csproj", solution.ProjectsInOrder[4].RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", false), solution.ProjectsInOrder[4].RelativePath);
             Assert.Equal("{6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}", solution.ProjectsInOrder[4].ProjectGuid);
             Assert.Empty(solution.ProjectsInOrder[4].Dependencies);
             Assert.Equal("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}", solution.ProjectsInOrder[4].ParentProjectGuid);
         }
 
+        /// <summary>
+        /// Exercises solution folders, and makes sure that samely named projects in different
+        /// solution folders will get correctly uniquified.
+        /// For the new parser, solution folders are not included to ProjectsInOrder or ProjectsByGuid.
+        /// </summary>
+        [Fact]
+        public void SolutionFoldersSlnx()
+        {
+            string solutionFileContents =
+                """
+                Microsoft Visual Studio Solution File, Format Version 9.00
+                # Visual Studio 2005
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{34E0D07D-CF8F-459D-9449-C4188D8C5564}'
+                EndProject
+                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'MySlnFolder', 'MySlnFolder', '{E0F97730-25D2-418A-A7BD-02CAFDC6E470}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'MyPhysicalFolder\ClassLibrary1\ClassLibrary1.csproj', '{A5EE8128-B08E-4533-86C5-E46714981680}'
+                EndProject
+                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'MySubSlnFolder', 'MySubSlnFolder', '{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary2', 'ClassLibrary2\ClassLibrary2.csproj', '{6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}'
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.Build.0 = Release|Any CPU
+                        {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {A5EE8128-B08E-4533-86C5-E46714981680}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {A5EE8128-B08E-4533-86C5-E46714981680}.Release|Any CPU.Build.0 = Release|Any CPU
+                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.Build.0 = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                    GlobalSection(NestedProjects) = preSolution
+                        {A5EE8128-B08E-4533-86C5-E46714981680} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
+                        {2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
+                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4} = {2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}
+                    EndGlobalSection
+                EndGlobal
+                """;
+
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, true);
+
+            Assert.Equal(3, solution.ProjectsInOrder.Count);
+
+            var classLibrary1 = solution.ProjectsInOrder
+                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", true));
+            Assert.NotNull(classLibrary1);
+            Assert.Empty(classLibrary1.Dependencies);
+            Assert.Null(classLibrary1.ParentProjectGuid);
+
+            var myPhysicalFolderClassLibrary1 = solution.ProjectsInOrder
+                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("MyPhysicalFolder\\ClassLibrary1\\ClassLibrary1.csproj", true));
+            Assert.NotNull(myPhysicalFolderClassLibrary1);
+            Assert.Empty(myPhysicalFolderClassLibrary1.Dependencies);
+
+            var classLibrary2 = solution.ProjectsInOrder
+                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", true));
+            Assert.NotNull(classLibrary2);
+            Assert.Empty(classLibrary2.Dependencies);
+
+            // When converting to slnx, the guids are not preserved.
+            // try at list assert not null
+            Assert.NotNull(myPhysicalFolderClassLibrary1.ParentProjectGuid);
+            Assert.NotNull(classLibrary2.ParentProjectGuid);
+        }
+
         /// <summary>
         /// Exercises shared projects.
         /// </summary>
@@ -556,13 +654,15 @@ public void MissingNestedProject()
 
         /// <summary>
         /// Verifies that hand-coded project-to-project dependencies listed in the .SLN file
-        /// are correctly recognized by our solution parser.
+        /// are correctly recognized by the solution parser.
         /// </summary>
-        [Fact]
-        public void SolutionDependencies()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SolutionDependencies(bool convertToSlnx)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{05A5AD00-71B5-4612-AF2F-9EA9121C4111}'
@@ -601,27 +701,29 @@ public void SolutionDependencies()
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
 
             Assert.Equal(3, solution.ProjectsInOrder.Count);
 
-            Assert.Equal(@"ClassLibrary1\ClassLibrary1.csproj", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{05A5AD00-71B5-4612-AF2F-9EA9121C4111}", solution.ProjectsInOrder[0].ProjectGuid);
-            Assert.Single(solution.ProjectsInOrder[0].Dependencies);
-            Assert.Equal("{FAB4EE06-6E01-495A-8926-5514599E3DD9}", (string)solution.ProjectsInOrder[0].Dependencies[0]);
+            var classLibrary1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
+            var classLibrary2 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary2");
+            var classLibrary3 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary3");
+
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", convertToSlnx), classLibrary1.RelativePath);
+            Assert.Single(classLibrary1.Dependencies);
+            Assert.Equal(classLibrary3.ProjectGuid, classLibrary1.Dependencies[0]);
             Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
 
-            Assert.Equal(@"ClassLibrary2\ClassLibrary2.csproj", solution.ProjectsInOrder[1].RelativePath);
-            Assert.Equal("{7F316407-AE3E-4F26-BE61-2C50D30DA158}", solution.ProjectsInOrder[1].ProjectGuid);
-            Assert.Equal(2, solution.ProjectsInOrder[1].Dependencies.Count);
-            Assert.Equal("{FAB4EE06-6E01-495A-8926-5514599E3DD9}", (string)solution.ProjectsInOrder[1].Dependencies[0]);
-            Assert.Equal("{05A5AD00-71B5-4612-AF2F-9EA9121C4111}", (string)solution.ProjectsInOrder[1].Dependencies[1]);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", convertToSlnx), classLibrary2.RelativePath);
+            Assert.Equal(2, classLibrary2.Dependencies.Count);
+            // When converting to SLNX, the projects dependencies order is not preserved.
+            Assert.Contains(classLibrary3.ProjectGuid, classLibrary2.Dependencies);
+            Assert.Contains(classLibrary1.ProjectGuid, classLibrary2.Dependencies);
             Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
 
-            Assert.Equal(@"ClassLibrary3\ClassLibrary3.csproj", solution.ProjectsInOrder[2].RelativePath);
-            Assert.Equal("{FAB4EE06-6E01-495A-8926-5514599E3DD9}", solution.ProjectsInOrder[2].ProjectGuid);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary3\\ClassLibrary3.csproj", convertToSlnx), solution.ProjectsInOrder[2].RelativePath);
             Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
             Assert.Null(solution.ProjectsInOrder[2].ParentProjectGuid);
         }
@@ -629,11 +731,13 @@ public void SolutionDependencies()
         /// <summary>
         /// Make sure the solution configurations get parsed correctly for a simple mixed C#/VC solution
         /// </summary>
-        [Fact]
-        public void ParseSolutionConfigurations()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseSolutionConfigurations(bool convertToSlnx)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -678,9 +782,9 @@ public void ParseSolutionConfigurations()
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
 
             Assert.Equal(7, solution.SolutionConfigurations.Count);
 
@@ -704,11 +808,13 @@ public void ParseSolutionConfigurations()
         /// <summary>
         /// Make sure the solution configurations get parsed correctly for a simple C# application
         /// </summary>
-        [Fact]
-        public void ParseSolutionConfigurationsNoMixedPlatform()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseSolutionConfigurationsNoMixedPlatform(bool convertToSlnx)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -733,14 +839,14 @@ public void ParseSolutionConfigurationsNoMixedPlatform()
                         {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|ARM.ActiveCfg = Release|Any CPU
                         {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|ARM.Build.0 = Release|Any CPU
                         {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|x86.ActiveCfg = Release|Any CPU
-                   EndGlobalSection
+                    EndGlobalSection
                     GlobalSection(SolutionProperties) = preSolution
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
 
             Assert.Equal(6, solution.SolutionConfigurations.Count);
 
@@ -839,15 +945,18 @@ public void ParseInvalidSolutionConfigurations3()
                 ParseSolutionHelper(solutionFileContents);
             });
         }
+
         /// <summary>
         /// Make sure the project configurations in solution configurations get parsed correctly
         /// for a simple mixed C#/VC solution
         /// </summary>
-        [Fact]
-        public void ParseProjectConfigurationsInSolutionConfigurations1()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseProjectConfigurationsInSolutionConfigurations1(bool convertToSlnx)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -889,12 +998,12 @@ public void ParseProjectConfigurationsInSolutionConfigurations1()
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
 
-            ProjectInSolution csharpProject = (ProjectInSolution)solution.ProjectsByGuid["{6185CC21-BE89-448A-B3C0-D1C27112E595}"];
-            ProjectInSolution vcProject = (ProjectInSolution)solution.ProjectsByGuid["{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}"];
+            ProjectInSolution csharpProject = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
+            ProjectInSolution vcProject = solution.ProjectsInOrder.First(p => p.ProjectName == "MainApp");
 
             Assert.Equal(6, csharpProject.ProjectConfigurations.Count);
 
@@ -998,6 +1107,65 @@ public void ParseProjectConfigurationsInSolutionConfigurations2()
             Assert.Equal(".NET", solution.GetDefaultPlatformName()); // "Default solution platform"
         }
 
+        [Fact]
+        public void ParseProjectConfigurationsInSolutionConfigurationsSlnx()
+        {
+            string solutionFileContents =
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio Version 17
+                VisualStudioVersion = 17.11.35111.106
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""WinFormsApp1"", ""WinFormsApp1\WinFormsApp1.csproj"", ""{3B592A6A-6215-4675-9237-7FEB36BDB4F1}""
+                EndProject
+                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""ClassLibrary1"", ""ClassLibrary1\ClassLibrary1.csproj"", ""{C25056E0-405C-4476-9B22-839264A8530C}""
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Win32 = Debug|Win32
+                        Release|Win32 = Release|Win32
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {3B592A6A-6215-4675-9237-7FEB36BDB4F1}.Debug|Win32.ActiveCfg = Debug|x86
+                        {3B592A6A-6215-4675-9237-7FEB36BDB4F1}.Debug|Win32.Build.0 = Debug|x86
+                        {3B592A6A-6215-4675-9237-7FEB36BDB4F1}.Release|Win32.ActiveCfg = Release|x86
+                        {3B592A6A-6215-4675-9237-7FEB36BDB4F1}.Release|Win32.Build.0 = Release|x86
+                        {C25056E0-405C-4476-9B22-839264A8530C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {C25056E0-405C-4476-9B22-839264A8530C}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                    GlobalSection(ExtensibilityGlobals) = postSolution
+                        SolutionGuid = {AA62B7C4-C703-4DBC-A7AD-D183666ECC20}
+                    EndGlobalSection
+                EndGlobal
+                """;
+
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, true);
+
+            ProjectInSolution winFormsApp1 = solution.ProjectsInOrder.First(p => p.ProjectName == "WinFormsApp1");
+            ProjectInSolution classLibrary1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
+
+            Assert.Equal(2, winFormsApp1.ProjectConfigurations.Count);
+
+            Assert.Equal("Debug|x86", winFormsApp1.ProjectConfigurations["Debug|Win32"].FullName);
+            Assert.True(winFormsApp1.ProjectConfigurations["Debug|Win32"].IncludeInBuild);
+
+            Assert.Equal("Release|x86", winFormsApp1.ProjectConfigurations["Release|Win32"].FullName);
+            Assert.True(winFormsApp1.ProjectConfigurations["Debug|Win32"].IncludeInBuild);
+
+            Assert.Equal(2, classLibrary1.ProjectConfigurations.Count);
+
+            Assert.Equal("Debug|AnyCPU", classLibrary1.ProjectConfigurations["Debug|Any CPU"].FullName);
+            Assert.False(classLibrary1.ProjectConfigurations["Debug|Any CPU"].IncludeInBuild);
+
+            Assert.Equal("Release|AnyCPU", classLibrary1.ProjectConfigurations["Release|Any CPU"].FullName);
+            Assert.False(classLibrary1.ProjectConfigurations["Release|Any CPU"].IncludeInBuild);
+        }
+
         /// <summary>
         /// Parse solution file with comments
         /// </summary>
@@ -1053,23 +1221,36 @@ public void ParseSolutionWithComments()
 
         /// <summary>
         /// Helper method to create a SolutionFile object, and call it to parse the SLN file
-        /// represented by the string contents passed in.
+        /// represented by the string contents passed in. Optionally can convert the SLN to SLNX and then parse the solution.
         /// </summary>
-        private static SolutionFile ParseSolutionHelper(string solutionFileContents)
+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool convertToSlnx = false)
         {
             solutionFileContents = solutionFileContents.Replace('\'', '"');
-            string solutionPath = FileUtilities.GetTemporaryFileName(".sln");
 
-            try
-            {
-                File.WriteAllText(solutionPath, solutionFileContents);
-                SolutionFile sp = SolutionFile.Parse(solutionPath);
-                return sp;
-            }
-            finally
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
             {
-                File.Delete(solutionPath);
+                TransientTestFile sln = testEnvironment.CreateFile(FileUtilities.GetTemporaryFileName(".sln"), solutionFileContents);
+
+                string solutionPath = convertToSlnx ? ConvertToSlnx(sln.Path) : sln.Path;
+
+                return SolutionFile.Parse(solutionPath);
             }
         }
+
+        private static string ConvertToSlnx(string slnPath)
+        {
+            string slnxPath = slnPath + "x";
+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(slnPath).ShouldNotBeNull();
+            SolutionModel solutionModel = serializer.OpenAsync(slnPath, CancellationToken.None).Result;
+            SolutionSerializers.SlnXml.SaveAsync(slnxPath, solutionModel, CancellationToken.None).Wait();
+            return slnxPath;
+        }
+
+        private static string ConvertToUnixPathIfNeeded(string path, bool isConvertedToSlnx)
+        {
+            // In the new parser, ProjectModel.FilePath is converted to Unix-style.
+            // we are using the new parser only for slnx files.
+            return !NativeMethodsShared.IsWindows && isConvertedToSlnx ? path.Replace('\\', '/') : path;
+        }
     }
 }
diff --git a/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs
new file mode 100644
index 00000000000..7f56b600dca
--- /dev/null
+++ b/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs
@@ -0,0 +1,163 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.IO;
+using System.Threading;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Shared;
+using Microsoft.VisualStudio.SolutionPersistence;
+using Microsoft.VisualStudio.SolutionPersistence.Model;
+using Microsoft.VisualStudio.SolutionPersistence.Serializer;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+#nullable disable
+
+namespace Microsoft.Build.UnitTests.Construction
+{
+    public class SolutionFile_NewParser_Tests
+    {
+        public ITestOutputHelper TestOutputHelper { get; }
+
+        public SolutionFile_NewParser_Tests(ITestOutputHelper testOutputHelper)
+        {
+            TestOutputHelper = testOutputHelper;
+        }
+
+        /// <summary>
+        /// Tests to see that all the data/properties are correctly parsed out of a Venus
+        /// project in a .SLN. This can be checked only here because of AspNetConfigurations protection level.
+        /// </summary>
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ProjectWithWebsiteProperties(bool convertToSlnx)
+        {
+            string solutionFileContents =
+                """
+                Microsoft Visual Studio Solution File, Format Version 9.00
+                # Visual Studio 2005
+                Project(`{E24C65DC-7377-472B-9ABA-BC803B73C61A}`) = `C:\WebSites\WebApplication3\`, `C:\WebSites\WebApplication3\`, `{464FD0B9-E335-4677-BE1E-6B2F982F4D86}`
+                    ProjectSection(WebsiteProperties) = preProject
+                        ProjectReferences = `{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSCla;ssLibra;ry1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;`
+                        Frontpage = false
+                            Debug.AspNetCompiler.VirtualPath = `/publishfirst`
+                            Debug.AspNetCompiler.PhysicalPath = `..\rajeev\temp\websites\myfirstwebsite\`
+                            Debug.AspNetCompiler.TargetPath = `..\rajeev\temp\publishfirst\`
+                            Debug.AspNetCompiler.ForceOverwrite = `true`
+                            Debug.AspNetCompiler.Updateable = `false`
+                            Debug.AspNetCompiler.Debug = `true`
+                            Debug.AspNetCompiler.KeyFile = `debugkeyfile.snk`
+                            Debug.AspNetCompiler.KeyContainer = `12345.container`
+                            Debug.AspNetCompiler.DelaySign = `true`
+                            Debug.AspNetCompiler.AllowPartiallyTrustedCallers = `false`
+                            Debug.AspNetCompiler.FixedNames = `debugfixednames`
+                            Release.AspNetCompiler.VirtualPath = `/publishfirst_release`
+                            Release.AspNetCompiler.PhysicalPath = `..\rajeev\temp\websites\myfirstwebsite_release\`
+                            Release.AspNetCompiler.TargetPath = `..\rajeev\temp\publishfirst_release\`
+                            Release.AspNetCompiler.ForceOverwrite = `true`
+                            Release.AspNetCompiler.Updateable = `true`
+                            Release.AspNetCompiler.Debug = `false`
+                        VWDPort = 63496
+                    EndProjectSection
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|.NET = Debug|.NET
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {464FD0B9-E335-4677-BE1E-6B2F982F4D86}.Debug|.NET.ActiveCfg = Debug|.NET
+                        {464FD0B9-E335-4677-BE1E-6B2F982F4D86}.Debug|.NET.Build.0 = Debug|.NET
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                """;
+
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents.Replace('`', '"'), convertToSlnx);
+
+            solution.ProjectsInOrder.ShouldHaveSingleItem();
+
+            solution.ProjectsInOrder[0].ProjectType.ShouldBe(SolutionProjectType.WebProject);
+            solution.ProjectsInOrder[0].ProjectName.ShouldBe(@"C:\WebSites\WebApplication3\");
+            solution.ProjectsInOrder[0].RelativePath.ShouldBe(ConvertToUnixPathIfNeeded(@"C:\WebSites\WebApplication3\"));
+            solution.ProjectsInOrder[0].Dependencies.Count.ShouldBe(2);
+            solution.ProjectsInOrder[0].ParentProjectGuid.ShouldBeNull();
+            solution.ProjectsInOrder[0].GetUniqueProjectName().ShouldBe(@"C:\WebSites\WebApplication3\");
+
+            Hashtable aspNetCompilerParameters = solution.ProjectsInOrder[0].AspNetConfigurations;
+            AspNetCompilerParameters debugAspNetCompilerParameters = (AspNetCompilerParameters)aspNetCompilerParameters["Debug"];
+            AspNetCompilerParameters releaseAspNetCompilerParameters = (AspNetCompilerParameters)aspNetCompilerParameters["Release"];
+
+            debugAspNetCompilerParameters.aspNetVirtualPath.ShouldBe(@"/publishfirst");
+            debugAspNetCompilerParameters.aspNetPhysicalPath.ShouldBe(@"..\rajeev\temp\websites\myfirstwebsite\");
+            debugAspNetCompilerParameters.aspNetTargetPath.ShouldBe(@"..\rajeev\temp\publishfirst\");
+            debugAspNetCompilerParameters.aspNetForce.ShouldBe(@"true");
+            debugAspNetCompilerParameters.aspNetUpdateable.ShouldBe(@"false");
+            debugAspNetCompilerParameters.aspNetDebug.ShouldBe(@"true");
+            debugAspNetCompilerParameters.aspNetKeyFile.ShouldBe(@"debugkeyfile.snk");
+            debugAspNetCompilerParameters.aspNetKeyContainer.ShouldBe(@"12345.container");
+            debugAspNetCompilerParameters.aspNetDelaySign.ShouldBe(@"true");
+            debugAspNetCompilerParameters.aspNetAPTCA.ShouldBe(@"false");
+            debugAspNetCompilerParameters.aspNetFixedNames.ShouldBe(@"debugfixednames");
+
+            releaseAspNetCompilerParameters.aspNetVirtualPath.ShouldBe(@"/publishfirst_release");
+            releaseAspNetCompilerParameters.aspNetPhysicalPath.ShouldBe(@"..\rajeev\temp\websites\myfirstwebsite_release\");
+            releaseAspNetCompilerParameters.aspNetTargetPath.ShouldBe(@"..\rajeev\temp\publishfirst_release\");
+            releaseAspNetCompilerParameters.aspNetForce.ShouldBe(@"true");
+            releaseAspNetCompilerParameters.aspNetUpdateable.ShouldBe(@"true");
+            releaseAspNetCompilerParameters.aspNetDebug.ShouldBe(@"false");
+            releaseAspNetCompilerParameters.aspNetKeyFile.ShouldBe("");
+            releaseAspNetCompilerParameters.aspNetKeyContainer.ShouldBe("");
+            releaseAspNetCompilerParameters.aspNetDelaySign.ShouldBe("");
+            releaseAspNetCompilerParameters.aspNetAPTCA.ShouldBe("");
+            releaseAspNetCompilerParameters.aspNetFixedNames.ShouldBe("");
+
+            List<string> aspNetProjectReferences = solution.ProjectsInOrder[0].ProjectReferences;
+            aspNetProjectReferences.Count.ShouldBe(2);
+            aspNetProjectReferences[0].ShouldBe("{FD705688-88D1-4C22-9BFF-86235D89C2FC}");
+            aspNetProjectReferences[1].ShouldBe("{F0726D09-042B-4A7A-8A01-6BED2422BD5D}");
+        }
+
+        /// <summary>
+        /// Helper method to create a SolutionFile object, and call it to parse the SLN file
+        /// represented by the string contents passed in. Optionally can convert the SLN to SLNX and then parse the solution.
+        /// </summary>
+        internal static SolutionFile ParseSolutionHelper(string solutionFileContents, bool convertToSlnx = false)
+        {
+            solutionFileContents = solutionFileContents.Replace('\'', '"');
+
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFile sln = testEnvironment.CreateFile(FileUtilities.GetTemporaryFileName(".sln"), solutionFileContents);
+
+                string solutionPath = convertToSlnx ? ConvertToSlnx(sln.Path) : sln.Path;
+
+                SolutionFile solutionFile = new SolutionFile { FullPath = solutionPath };
+                solutionFile.ParseUsingNewParser();
+                return solutionFile;
+            }
+        }
+
+        private static string ConvertToSlnx(string slnPath)
+        {
+            string slnxPath = slnPath + "x";
+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(slnPath).ShouldNotBeNull();
+            SolutionModel solutionModel = serializer.OpenAsync(slnPath, CancellationToken.None).Result;
+            SolutionSerializers.SlnXml.SaveAsync(slnxPath, solutionModel, CancellationToken.None).Wait();
+            return slnxPath;
+        }
+
+        private static string ConvertToUnixPathIfNeeded(string path)
+        {
+            // In the new parser, ProjectModel.FilePath is converted to Unix-style.
+            return !NativeMethodsShared.IsWindows ? path.Replace('\\', '/') : path;
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
index 400c3f6af52..e173c47c640 100644
--- a/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using System.Threading;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
@@ -13,6 +14,9 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
 using Microsoft.Build.UnitTests;
+using Microsoft.VisualStudio.SolutionPersistence.Model;
+using Microsoft.VisualStudio.SolutionPersistence.Serializer;
+using Microsoft.VisualStudio.SolutionPersistence;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -215,8 +219,10 @@ public void InvalidSolutionFilters(string slnfValue, string exceptionReason)
         /// <summary>
         /// Test that a solution filter file is parsed correctly, and it can accurately respond as to whether a project should be filtered out.
         /// </summary>
-        [Fact]
-        public void ParseSolutionFilter()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseSolutionFilter(bool convertToSlnx)
         {
             using (TestEnvironment testEnvironment = TestEnvironment.Create())
             {
@@ -229,35 +235,35 @@ public void ParseSolutionFilter()
                 // The important part of this .sln is that it has references to each of the four projects we just created.
                 TransientTestFile sln = testEnvironment.CreateFile(folder, "Microsoft.Build.Dev.sln",
                     @"
-                    Microsoft Visual Studio Solution File, Format Version 12.00
-                    # Visual Studio 15
-                    VisualStudioVersion = 15.0.27004.2009
-                    MinimumVisualStudioVersion = 10.0.40219.1
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build"", """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)) + @""", ""{69BE05E2-CBDA-4D27-9733-44E12B0F5627}""
-                    EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""MSBuild"", """ + Path.Combine("src", Path.GetFileName(msbuild.Path)) + @""", ""{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}""
-                    EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.CommandLine.UnitTests"", """ + Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path)) + @""", ""{0ADDBC02-0076-4159-B351-2BF33FAA46B2}""
-                    EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.Tasks.UnitTests"", """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)) + @""", ""{CF999BDE-02B3-431B-95E6-E88D621D9CBF}""
-                    EndProject
-                    Global
-                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        EndGlobalSection
-                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                    GlobalSection(ExtensibilityGlobals) = postSolution
-                    EndGlobalSection
-                    EndGlobal
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 15
+VisualStudioVersion = 15.0.27004.2009
+MinimumVisualStudioVersion = 10.0.40219.1
+Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build"", """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)) + @""", ""{69BE05E2-CBDA-4D27-9733-44E12B0F5627}""
+EndProject
+Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""MSBuild"", """ + Path.Combine("src", Path.GetFileName(msbuild.Path)) + @""", ""{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}""
+EndProject
+Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.CommandLine.UnitTests"", """ + Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path)) + @""", ""{0ADDBC02-0076-4159-B351-2BF33FAA46B2}""
+EndProject
+Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.Tasks.UnitTests"", """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)) + @""", ""{CF999BDE-02B3-431B-95E6-E88D621D9CBF}""
+EndProject
+Global
+    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+    EndGlobalSection
+    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+EndGlobalSection
+GlobalSection(SolutionProperties) = preSolution
+    HideSolutionNode = FALSE
+EndGlobalSection
+GlobalSection(ExtensibilityGlobals) = postSolution
+EndGlobalSection
+EndGlobal
                     ");
                 TransientTestFile slnf = testEnvironment.CreateFile(folder, "Dev.slnf",
                     @"
                     {
                       ""solution"": {
-                        ""path"": """ + sln.Path.Replace("\\", "\\\\") + @""",
+                        ""path"": """ + (convertToSlnx ? ConvertToSlnx(sln.Path) : sln.Path).Replace("\\", "\\\\") + @""",
                         ""projects"": [
                           """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)!).Replace("\\", "\\\\") + @""",
                           """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)!).Replace("\\", "\\\\") + @"""
@@ -276,6 +282,15 @@ public void ParseSolutionFilter()
             }
         }
 
+        private static string ConvertToSlnx(string slnPath)
+        {
+            string slnxPath = slnPath + "x";
+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(slnPath).ShouldNotBeNull();
+            SolutionModel solutionModel = serializer.OpenAsync(slnPath, CancellationToken.None).Result;
+            SolutionSerializers.SlnXml.SaveAsync(slnxPath, solutionModel, CancellationToken.None).Wait();
+            return slnxPath;
+        }
+
         private ILoggingService CreateMockLoggingService()
         {
             ILoggingService loggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 0);
diff --git a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
index 4e164d177c3..7bf44e40de2 100644
--- a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
+++ b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
@@ -16,4 +16,6 @@ public interface IBuildCheckRegistrationContext
     void RegisterEnvironmentVariableReadAction(Action<BuildCheckDataContext<EnvironmentVariableCheckData>> environmentVariableAction);
 
     void RegisterBuildFinishedAction(Action<BuildCheckDataContext<BuildFinishedCheckData>> buildFinishedAction);
+
+    void RegisterProjectImportedAction(Action<BuildCheckDataContext<ProjectImportedCheckData>> projectImportedAction);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
index 6e011090046..e14d7849f4f 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
@@ -4,11 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Experimental.BuildCheck.Acquisition;
-using Microsoft.Build.Experimental.BuildCheck.Utilities;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -44,6 +40,7 @@ internal BuildCheckBuildEventHandler(
             { typeof(TaskFinishedEventArgs), (BuildEventArgs e) => HandleTaskFinishedEvent((TaskFinishedEventArgs)e) },
             { typeof(TaskParameterEventArgs), (BuildEventArgs e) => HandleTaskParameterEvent((TaskParameterEventArgs)e) },
             { typeof(BuildFinishedEventArgs), (BuildEventArgs e) => HandleBuildFinishedEvent((BuildFinishedEventArgs)e) },
+            { typeof(ProjectImportedEventArgs), (BuildEventArgs e) => HandleProjectImportedEvent((ProjectImportedEventArgs)e) },
         };
 
         // During restore we'll wait only for restore to be done.
@@ -92,6 +89,7 @@ private void HandleProjectEvaluationStartedEvent(ProjectEvaluationStartedEventAr
                 BuildCheckDataSource.EventArgs,
                 checkContext,
                 eventArgs.ProjectFile!);
+
             _buildCheckManager.ProcessProjectEvaluationStarted(
                 checkContext,
                 eventArgs.ProjectFile!);
@@ -141,6 +139,11 @@ private void HandleEnvironmentVariableReadEvent(EnvironmentVariableReadEventArgs
                 _checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)),
                 eventArgs);
 
+    private void HandleProjectImportedEvent(ProjectImportedEventArgs eventArgs)
+        => _buildCheckManager.ProcessProjectImportedEventArgs(
+                _checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)),
+                eventArgs);
+
     private bool IsMetaProjFile(string? projectFile) => projectFile?.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase) == true;
 
     private readonly BuildCheckTracingData _tracingData = new BuildCheckTracingData();
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index 5e25c3e0a48..d9ca747fc60 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -29,10 +29,11 @@ private record CallbackRegistry(
         List<(CheckWrapper, Action<BuildCheckDataContext<PropertyWriteData>>)> PropertyWriteActions,
         List<(CheckWrapper, Action<BuildCheckDataContext<ProjectRequestProcessingDoneData>>)> ProjectRequestProcessingDoneActions,
         List<(CheckWrapper, Action<BuildCheckDataContext<BuildFinishedCheckData>>)> BuildFinishedActions,
-        List<(CheckWrapper, Action<BuildCheckDataContext<EnvironmentVariableCheckData>>)> EnvironmentVariableCheckDataActions)
+        List<(CheckWrapper, Action<BuildCheckDataContext<EnvironmentVariableCheckData>>)> EnvironmentVariableCheckDataActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<ProjectImportedCheckData>>)> ProjectImportedCheckDataActions)
     {
         public CallbackRegistry()
-            : this([], [], [], [], [], [], [], [])
+            : this([], [], [], [], [], [], [], [], [])
         {
         }
 
@@ -62,6 +63,7 @@ internal void DeregisterCheck(CheckWrapper check)
     internal bool HasPropertyReadActions => _globalCallbacks.PropertyReadActions.Count > 0;
 
     internal bool HasPropertyWriteActions => _globalCallbacks.PropertyWriteActions.Count > 0;
+
     internal bool HasBuildFinishedActions => _globalCallbacks.BuildFinishedActions.Count > 0;
 
     internal void RegisterEnvironmentVariableReadAction(CheckWrapper check, Action<BuildCheckDataContext<EnvironmentVariableCheckData>> environmentVariableAction)
@@ -90,6 +92,9 @@ internal void RegisterProjectRequestProcessingDoneAction(CheckWrapper check, Act
     internal void RegisterBuildFinishedAction(CheckWrapper check, Action<BuildCheckDataContext<BuildFinishedCheckData>> buildFinishedAction)
         => RegisterAction(check, buildFinishedAction, _globalCallbacks.BuildFinishedActions);
 
+    internal void RegisterProjectImportedAction(CheckWrapper check, Action<BuildCheckDataContext<ProjectImportedCheckData>> projectImportedAction)
+        => RegisterAction(check, projectImportedAction, _globalCallbacks.ProjectImportedCheckDataActions);
+
     private void RegisterAction<T>(
         CheckWrapper wrappedCheck,
         Action<BuildCheckDataContext<T>> handler,
@@ -167,10 +172,14 @@ internal void RunProjectProcessingDoneActions(
     internal void RunBuildFinishedActions(
         BuildFinishedCheckData buildFinishedCheckData,
         ICheckContext checkContext,
-        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
-            resultHandler)
-        => RunRegisteredActions(_globalCallbacks.BuildFinishedActions, buildFinishedCheckData,
-            checkContext, resultHandler);
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult> resultHandler)
+        => RunRegisteredActions(_globalCallbacks.BuildFinishedActions, buildFinishedCheckData, checkContext, resultHandler);
+
+    internal void RunProjectImportedActions(
+        ProjectImportedCheckData projectImportedCheckData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult> resultHandler)
+        => RunRegisteredActions(_globalCallbacks.ProjectImportedCheckDataActions, projectImportedCheckData, checkContext, resultHandler);
 
     private void RunRegisteredActions<T>(
         List<(CheckWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
index 491fe92d700..c9b8d0219e9 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
@@ -3,13 +3,7 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Experimental.BuildCheck.Acquisition;
 using Microsoft.Build.Framework;
-using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.BuildCheckManagerProvider;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
@@ -20,7 +14,7 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 /// In the future we may need more specific behavior.
 /// </summary>
 /// <remarks>
-/// Ensure that events filtering is in sync with <see cref="BuildCheckConnectorLogger"/>
+/// Ensure that events filtering is in sync with <see cref="BuildCheckConnectorLogger"/>.
 /// </remarks>
 internal class BuildCheckForwardingLogger : IForwardingLogger
 {
@@ -33,10 +27,10 @@ internal class BuildCheckForwardingLogger : IForwardingLogger
     public string? Parameters { get; set; }
 
     /// <summary>
-    /// Set of events to be forwarded to  <see cref="BuildCheckConnectorLogger"/>
+    /// Set of events to be forwarded to  <see cref="BuildCheckConnectorLogger"/>.
     /// </summary>
-    private HashSet<Type> _eventsToForward = new HashSet<Type>
-    {
+    private HashSet<Type> _eventsToForward =
+    [
         typeof(EnvironmentVariableReadEventArgs),
         typeof(BuildSubmissionStartedEventArgs),
         typeof(ProjectEvaluationFinishedEventArgs),
@@ -47,15 +41,13 @@ internal class BuildCheckForwardingLogger : IForwardingLogger
         typeof(BuildCheckAcquisitionEventArgs),
         typeof(TaskStartedEventArgs),
         typeof(TaskFinishedEventArgs),
-        typeof(TaskParameterEventArgs)
-    };
+        typeof(TaskParameterEventArgs),
+        typeof(ProjectImportedEventArgs),
+    ];
 
     public void Initialize(IEventSource eventSource, int nodeCount) => Initialize(eventSource);
 
-    public void Initialize(IEventSource eventSource)
-    {
-        eventSource.AnyEventRaised += EventSource_AnyEventRaised;
-    }
+    public void Initialize(IEventSource eventSource) => eventSource.AnyEventRaised += EventSource_AnyEventRaised;
 
     public void EventSource_AnyEventRaised(object sender, BuildEventArgs buildEvent)
     {
@@ -65,5 +57,7 @@ public void EventSource_AnyEventRaised(object sender, BuildEventArgs buildEvent)
         }
     }
 
-    public void Shutdown() { }
+    public void Shutdown()
+    {
+    }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 13925ad6d5f..bf2c5fda3a5 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -6,7 +6,6 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Linq;
-using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BuildCheck.Infrastructure;
@@ -59,7 +58,7 @@ public void ShutdownComponent()
     {
         _instance?.Shutdown();
         _instance = null;
-    } 
+    }
 
     internal sealed class BuildCheckManager : IBuildCheckManager, IBuildEngineDataRouter, IResultReporter
     {
@@ -94,7 +93,7 @@ public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
             {
                 _enabledDataSources[(int)buildCheckDataSource] = true;
                 RegisterBuiltInChecks(buildCheckDataSource);
-            } 
+            }
             stopwatch.Stop();
             _tracingReporter.AddSetDataSourceStats(stopwatch.Elapsed);
         }
@@ -344,11 +343,11 @@ public void RemoveThrottledChecks(ICheckContext checkContext)
         private void RemoveCheck(CheckFactoryContext checkToRemove)
         {
             _checkRegistry.Remove(checkToRemove);
-            
+
             if (checkToRemove.MaterializedCheck is not null)
             {
                 _buildCheckCentralContext.DeregisterCheck(checkToRemove.MaterializedCheck);
-				_ruleTelemetryData.AddRange(checkToRemove.MaterializedCheck.GetRuleTelemetryData());
+                _ruleTelemetryData.AddRange(checkToRemove.MaterializedCheck.GetRuleTelemetryData());
                 checkToRemove.MaterializedCheck.Check.Dispose();
             }
         }
@@ -372,6 +371,18 @@ public void ProcessEvaluationFinishedEventArgs(
                 FileClassifier.Shared.RegisterKnownImmutableLocations(getPropertyValue);
             }
 
+            // run it here to avoid the missed imports that can be reported before the checks registration
+            if (_deferredProjectEvalIdToImportedProjects.TryGetValue(checkContext.BuildEventContext.EvaluationId, out HashSet<string>? importedProjects))
+            {
+                if (importedProjects != null && TryGetProjectFullPath(checkContext.BuildEventContext, out string projectPath))
+                {
+                    foreach (string importedProject in importedProjects)
+                    {
+                        _buildEventsProcessor.ProcessProjectImportedEventArgs(checkContext, projectPath, importedProject);
+                    }
+                }
+            }
+
             _buildEventsProcessor
                 .ProcessEvaluationFinishedEventArgs(checkContext, evaluationFinishedEventArgs, propertiesLookup);
         }
@@ -392,6 +403,16 @@ public void ProcessEnvironmentVariableReadEventArgs(ICheckContext checkContext,
             }
         }
 
+        public void ProcessProjectImportedEventArgs(ICheckContext checkContext, ProjectImportedEventArgs projectImportedEventArgs)
+        {
+            if (string.IsNullOrEmpty(projectImportedEventArgs.ImportedProjectFile))
+            {
+                return;
+            }
+
+            PropagateImport(checkContext.BuildEventContext.EvaluationId, projectImportedEventArgs.ProjectFile, projectImportedEventArgs.ImportedProjectFile);
+        }
+
         public void ProcessTaskStartedEventArgs(
             ICheckContext checkContext,
             TaskStartedEventArgs taskStartedEventArgs)
@@ -414,6 +435,7 @@ public void ProcessTaskParameterEventArgs(
                 .ProcessTaskParameterEventArgs(checkContext, taskParameterEventArgs);
 
         private readonly List<BuildCheckRuleTelemetryData> _ruleTelemetryData = [];
+
         public BuildCheckTracingData CreateCheckTracingStats()
         {
             foreach (CheckFactoryContext checkFactoryContext in _checkRegistry)
@@ -445,6 +467,8 @@ public void FinalizeProcessing(LoggingContext loggingContext)
         private readonly ConcurrentDictionary<int, string> _projectsByInstanceId = new();
         private readonly ConcurrentDictionary<int, string> _projectsByEvaluationId = new();
 
+        private readonly Dictionary<int, HashSet<string>> _deferredProjectEvalIdToImportedProjects = new();
+
         /// <summary>
         /// This method fetches the project full path from the context id.
         /// This is needed because the full path is needed for configuration and later for fetching configured checks
@@ -515,6 +539,10 @@ public void ProcessProjectEvaluationStarted(
             string projectFullPath)
         {
             _projectsByEvaluationId[checkContext.BuildEventContext.EvaluationId] = projectFullPath;
+            if (!_deferredProjectEvalIdToImportedProjects.ContainsKey(checkContext.BuildEventContext.EvaluationId))
+            {
+                _deferredProjectEvalIdToImportedProjects.Add(checkContext.BuildEventContext.EvaluationId, [projectFullPath]);
+            }
         }
 
         /*
@@ -523,7 +551,6 @@ public void ProcessProjectEvaluationStarted(
          *
          */
 
-
         public void EndProjectEvaluation(BuildEventContext buildEventContext)
         {
         }
@@ -548,6 +575,24 @@ public void StartProjectRequest(ICheckContext checkContext, string projectFullPa
         }
 
         private readonly Dictionary<int, List<BuildEventArgs>> _deferredEvalDiagnostics = new();
+
+        /// <summary>
+        /// Propagates a newly imported project file to all projects that import the original project file.
+        /// This method ensures that if Project A imports Project B, and Project B now imports Project C,
+        /// then Project A will also show Project C as an import.
+        /// </summary>
+        /// <param name="evaluationId">The evaluation id is associated with the root project path.</param>
+        /// <param name="originalProjectFile">The path of the project file that is importing a new project.</param>
+        /// <param name="newImportedProjectFile">The path of the newly imported project file.</param>
+        private void PropagateImport(int evaluationId, string originalProjectFile, string newImportedProjectFile)
+        {
+            if (_deferredProjectEvalIdToImportedProjects.TryGetValue(evaluationId, out HashSet<string>? importedProjects)
+                && importedProjects.Contains(originalProjectFile))
+            {
+                importedProjects.Add(newImportedProjectFile);
+            }
+        }
+
         void IResultReporter.ReportResult(BuildEventArgs eventArgs, ICheckContext checkContext)
         {
             // If we do not need to decide on promotability/demotability of warnings or we are ready to decide on those
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
index 7a932c671f9..3ab917a4850 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -96,6 +96,16 @@ internal void ProcessEnvironmentVariableReadEventArgs(ICheckContext checkContext
         _buildCheckCentralContext.RunEnvironmentVariableActions(checkData, checkContext, ReportResult);
     }
 
+    /// <summary>
+    /// The method handles events associated with the ProjectImportedEventArgs.
+    /// </summary>
+    internal void ProcessProjectImportedEventArgs(ICheckContext checkContext, string projectPath, string importedProjectPath)
+    {
+        ProjectImportedCheckData checkData = new(importedProjectPath, projectPath, checkContext.BuildEventContext?.ProjectInstanceId);
+
+        _buildCheckCentralContext.RunProjectImportedActions(checkData, checkContext, ReportResult);
+    }
+
     internal void ProcessBuildDone(ICheckContext checkContext)
     {
         if (!_buildCheckCentralContext.HasBuildFinishedActions)
diff --git a/src/Build/BuildCheck/Infrastructure/CheckRegistrationContext.cs b/src/Build/BuildCheck/Infrastructure/CheckRegistrationContext.cs
index 1a0565a50fb..4ec9cd0a3a5 100644
--- a/src/Build/BuildCheck/Infrastructure/CheckRegistrationContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckRegistrationContext.cs
@@ -2,13 +2,12 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Threading;
-using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Experimental.BuildCheck.Checks;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-internal sealed class CheckRegistrationContext(CheckWrapper checkWrapper, BuildCheckCentralContext buildCheckCentralContext) : IInternalCheckRegistrationContext
+internal sealed class CheckRegistrationContext(CheckWrapper checkWrapper, BuildCheckCentralContext buildCheckCentralContext)
+    : IInternalCheckRegistrationContext
 {
     public void RegisterEnvironmentVariableReadAction(Action<BuildCheckDataContext<EnvironmentVariableCheckData>> environmentVariableAction) =>
         buildCheckCentralContext.RegisterEnvironmentVariableReadAction(checkWrapper, environmentVariableAction);
@@ -33,4 +32,7 @@ public void RegisterProjectRequestProcessingDoneAction(Action<BuildCheckDataCont
 
     public void RegisterBuildFinishedAction(Action<BuildCheckDataContext<BuildFinishedCheckData>> buildFinishedAction)
         => buildCheckCentralContext.RegisterBuildFinishedAction(checkWrapper, buildFinishedAction);
+
+    public void RegisterProjectImportedAction(Action<BuildCheckDataContext<ProjectImportedCheckData>> projectImportedAction) =>
+        buildCheckCentralContext.RegisterProjectImportedAction(checkWrapper, projectImportedAction);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs b/src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs
index 2185f509a26..2dc126665e5 100644
--- a/src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs
@@ -8,12 +8,9 @@
 
 namespace Microsoft.Build.BuildCheck.Infrastructure;
 
-internal static class CheckScopeClassifier
+public static class CheckScopeClassifier
 {
-    static CheckScopeClassifier()
-    {
-        FileClassifier.Shared.OnImmutablePathsInitialized += SubscribeImmutablePathsInitialized;
-    }
+    static CheckScopeClassifier() => FileClassifier.Shared.OnImmutablePathsInitialized += SubscribeImmutablePathsInitialized;
 
     internal static event Action? NotifyOnScopingReadiness;
 
@@ -22,7 +19,7 @@ static CheckScopeClassifier()
     /// <summary>
     /// Notifies the subscribers that the scoping is ready.
     /// </summary>
-    internal static Func<EvaluationCheckScope, bool> IsScopingReady => (scope) => (scope is EvaluationCheckScope.ProjectFileOnly or EvaluationCheckScope.All) || IsScopingInitialized;
+    public static Func<EvaluationCheckScope, bool> IsScopingReady => (scope) => (scope is EvaluationCheckScope.ProjectFileOnly or EvaluationCheckScope.All) || IsScopingInitialized;
 
     /// <summary>
     /// Indicates whether given location is in the observed scope, based on currently built project path.
@@ -32,7 +29,7 @@ static CheckScopeClassifier()
     /// <param name="projectFileFullPath"></param>
     /// <returns></returns>
     /// <exception cref="ArgumentOutOfRangeException"></exception>
-    internal static bool IsActionInObservedScope(
+    public static bool IsActionInObservedScope(
         EvaluationCheckScope scope,
         IMSBuildElementLocation? location,
         string projectFileFullPath)
@@ -46,26 +43,18 @@ internal static bool IsActionInObservedScope(
     /// <param name="projectFileFullPath"></param>
     /// <returns></returns>
     /// <exception cref="ArgumentOutOfRangeException"></exception>
-    internal static bool IsActionInObservedScope(
+    public static bool IsActionInObservedScope(
         EvaluationCheckScope scope,
         string? filePathOfEvent,
-        string projectFileFullPath)
-    {
-        switch (scope)
+        string projectFileFullPath) => scope switch
         {
-            case EvaluationCheckScope.ProjectFileOnly:
-                return filePathOfEvent == projectFileFullPath;
-            case EvaluationCheckScope.WorkTreeImports:
-                return
-                    filePathOfEvent != null &&
-                    !FileClassifier.Shared.IsNonModifiable(filePathOfEvent) &&
-                    !IsGeneratedNugetImport(filePathOfEvent);
-            case EvaluationCheckScope.All:
-                return true;
-            default:
-                throw new ArgumentOutOfRangeException(nameof(scope), scope, null);
-        }
-    }
+            EvaluationCheckScope.ProjectFileOnly => filePathOfEvent == projectFileFullPath,
+            EvaluationCheckScope.WorkTreeImports => filePathOfEvent != null
+                                && !FileClassifier.Shared.IsNonModifiable(filePathOfEvent)
+                                && !IsGeneratedNugetImport(filePathOfEvent),
+            EvaluationCheckScope.All => true,
+            _ => throw new ArgumentOutOfRangeException(nameof(scope), scope, null),
+        };
 
     private static bool IsGeneratedNugetImport(string file) =>
         file.EndsWith("nuget.g.props", StringComparison.OrdinalIgnoreCase)
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
index a811b61d973..8dfbf7aa944 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
@@ -177,7 +177,7 @@ public Section(string name, ImmutableDictionary<string, string> properties)
 
         /// <summary>
         /// Keys and values for this section. All keys are lower-cased according to the
-        /// EditorConfig specification and keys are compared case-insensitively. 
+        /// EditorConfig specification and keys are compared case-insensitively.
         /// </summary>
         public ImmutableDictionary<string, string> Properties { get; }
     }
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
index 552c49dac83..8971403ed22 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -1,8 +1,6 @@
 Ôªø// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck.Acquisition;
 using Microsoft.Build.Framework;
@@ -61,6 +59,8 @@ void ProcessTaskParameterEventArgs(
 
     void ProcessCheckAcquisition(CheckAcquisitionData acquisitionData, ICheckContext checksContext);
 
+    void ProcessProjectImportedEventArgs(ICheckContext checkContext, ProjectImportedEventArgs projectImportedEventArgs);
+
     BuildCheckTracingData CreateCheckTracingStats();
 
     void FinalizeProcessing(LoggingContext loggingContext);
@@ -69,8 +69,7 @@ void ProcessTaskParameterEventArgs(
     //  but as well from the ConnectorLogger - as even if interleaved, it gives the info
     //  to manager about what checks need to be materialized and configuration fetched.
     // No unloading of checks is yet considered - once loaded it stays for whole build.
-    
-	
+
     // Project might be encountered first time in some node, but be already evaluated in another - so StartProjectEvaluation won't happen
     //  - but we still need to know about it, hence the dedicated event.
     void ProjectFirstEncountered(BuildCheckDataSource buildCheckDataSource, ICheckContext analysisContext, string projectFullPath);
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
index 294700ef5fc..bcbe2075e84 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -1,11 +1,8 @@
 Ôªø// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck.Acquisition;
-using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
@@ -82,11 +79,18 @@ public void EndProjectRequest(ICheckContext checkContext, string projectFullPath
     public BuildCheckTracingData CreateCheckTracingStats() => new BuildCheckTracingData();
 
     public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext buildEventContext)
-    { }
+    {
+    }
 
     public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext buildEventContext)
-    { }
+    {
+    }
 
     public void ProcessEnvironmentVariableReadEventArgs(ICheckContext checkContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
-    { }
+    {
+    }
+
+    public void ProcessProjectImportedEventArgs(ICheckContext checkContext, ProjectImportedEventArgs projectImportedEventArgs)
+    {
+    }
 }
diff --git a/src/Build/BuildCheck/OM/ProjectImportedCheckData.cs b/src/Build/BuildCheck/OM/ProjectImportedCheckData.cs
new file mode 100644
index 00000000000..e4172f52215
--- /dev/null
+++ b/src/Build/BuildCheck/OM/ProjectImportedCheckData.cs
@@ -0,0 +1,24 @@
+Ôªø// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Represents data for a check related to an imported project in MSBuild.
+/// </summary>
+/// <remarks>
+/// This class extends the base <see cref="CheckData"/> class to include
+/// information specific to imported projects.
+/// </remarks>
+public class ProjectImportedCheckData : CheckData
+{
+    internal ProjectImportedCheckData(string importedProjectFile, string projectFilePath, int? projectConfigurationId)
+        : base(projectFilePath, projectConfigurationId) => ImportedProjectFileFullPath = importedProjectFile;
+
+    /// <summary>
+    /// Gets the file path of the imported project.
+    /// </summary>
+    public string ImportedProjectFileFullPath { get; }
+}
diff --git a/src/Build/CompatibilitySuppressions.xml b/src/Build/CompatibilitySuppressions.xml
index 05317adadab..9335aedb11f 100644
--- a/src/Build/CompatibilitySuppressions.xml
+++ b/src/Build/CompatibilitySuppressions.xml
@@ -1,4 +1,25 @@
 Ôªø<?xml version="1.0" encoding="utf-8"?>
-<!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
+<!-- https://learn.microsoft.com/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-</Suppressions>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterProjectImportedAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ProjectImportedCheckData}})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterProjectImportedAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ProjectImportedCheckData}})</Target>
+    <Left>lib/net9.0/Microsoft.Build.dll</Left>
+    <Right>lib/net9.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterProjectImportedAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ProjectImportedCheckData}})</Target>
+    <Left>ref/net9.0/Microsoft.Build.dll</Left>
+    <Right>ref/net9.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+</Suppressions>
\ No newline at end of file
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index a73df401565..1343cf51914 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -406,13 +406,18 @@ internal string GetUniqueProjectName()
 
                     if (ParentProjectGuid != null)
                     {
-                        if (!ParentSolution.ProjectsByGuid.TryGetValue(ParentProjectGuid, out ProjectInSolution proj))
+                        ProjectInSolution proj = null;
+                        ProjectInSolution solutionFolder = null;
+
+                        // For the new parser, solution folders are not saved in ProjectsByGuid but in the SolutionFoldersByGuid.
+                        if (!ParentSolution.ProjectsByGuid.TryGetValue(ParentProjectGuid, out proj) &&
+                            !ParentSolution.SolutionFoldersByGuid.TryGetValue(ParentProjectGuid, out solutionFolder))
                         {
-                            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(proj != null, "SubCategoryForSolutionParsingErrors",
+                            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(proj != null || solutionFolder != null, "SubCategoryForSolutionParsingErrors",
                                 new BuildEventFileInfo(ParentSolution.FullPath), "SolutionParseNestedProjectErrorWithNameAndGuid", ProjectName, ProjectGuid, ParentProjectGuid);
                         }
 
-                        uniqueName = proj.GetUniqueProjectName() + "\\";
+                        uniqueName = (proj != null ? proj.GetUniqueProjectName() : solutionFolder.GetUniqueProjectName()) + "\\";
                     }
 
                     // Now tack on our own project name, and cache it in the ProjectInSolution object for future quick access.
@@ -442,16 +447,19 @@ internal string GetOriginalProjectName()
                     // If this project has a parent SLN folder, first get the full project name for the SLN folder,
                     // and tack on trailing backslash.
                     string projectName = String.Empty;
+                    ProjectInSolution proj = null;
+                    ProjectInSolution solutionFolder = null;
 
                     if (ParentProjectGuid != null)
                     {
-                        if (!ParentSolution.ProjectsByGuid.TryGetValue(ParentProjectGuid, out ProjectInSolution parent))
+                        if (!ParentSolution.ProjectsByGuid.TryGetValue(ParentProjectGuid, out proj) &&
+                            !ParentSolution.SolutionFoldersByGuid.TryGetValue(ParentProjectGuid, out solutionFolder))
                         {
-                            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(parent != null, "SubCategoryForSolutionParsingErrors",
+                            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(proj != null || solutionFolder != null, "SubCategoryForSolutionParsingErrors",
                                 new BuildEventFileInfo(ParentSolution.FullPath), "SolutionParseNestedProjectErrorWithNameAndGuid", ProjectName, ProjectGuid, ParentProjectGuid);
                         }
 
-                        projectName = parent.GetOriginalProjectName() + "\\";
+                        projectName = (proj != null ? proj.GetOriginalProjectName() : solutionFolder.GetOriginalProjectName()) + "\\";
                     }
 
                     // Now tack on our own project name, and cache it in the ProjectInSolution object for future quick access.
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 4676638ed9f..983cd691d0d 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -6,14 +6,20 @@
 using System.Collections.ObjectModel;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Runtime.InteropServices;
 using System.Security;
 using System.Text;
 using System.Text.Json;
 using System.Text.RegularExpressions;
+using System.Threading;
 using System.Xml;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.VisualStudio.SolutionPersistence;
+using Microsoft.VisualStudio.SolutionPersistence.Model;
+using Microsoft.VisualStudio.SolutionPersistence.Serializer;
 using BuildEventFileInfo = Microsoft.Build.Shared.BuildEventFileInfo;
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
 using ExceptionUtilities = Microsoft.Build.Shared.ExceptionHandling;
@@ -92,13 +98,16 @@ public sealed class SolutionFile
                                                      // conversion, or in preparation for actually building the solution?
 
         // The list of projects in this SLN, keyed by the project GUID.
-        private Dictionary<string, ProjectInSolution> _projects;
+        private Dictionary<string, ProjectInSolution> _projectsByGuid;
+
+        // The list of solution folders in this SLN, keyed by the folder's GUID.
+        private Dictionary<string, ProjectInSolution> _solutionFoldersByGuid;
 
         // The list of projects in the SLN, in order of their appearance in the SLN.
         private List<ProjectInSolution> _projectsInOrder;
 
         // The list of solution configurations in the solution
-        private List<SolutionConfigurationInSolution> _solutionConfigurations;
+        private Dictionary<string, SolutionConfigurationInSolution> _solutionConfigurationsByFullName;
 
         // cached default configuration name for GetDefaultConfigurationName
         private string _defaultConfigurationName;
@@ -147,13 +156,15 @@ internal SolutionFile()
         internal List<string> SolutionParserErrorCodes { get; } = new List<string>();
 
         /// <summary>
-        /// Returns the actual major version of the parsed solution file
+        /// Returns the actual major version of the parsed solution file.
         /// </summary>
+        /// <remarks>This will return 0 for the new parser because Version is not available.</remarks>
         internal int Version { get; private set; }
 
         /// <summary>
-        /// Returns Visual Studio major version
+        /// Returns Visual Studio major version.
         /// </summary>
+        /// <remarks>This might not be available for the new parser and returns -1.</remarks>
         internal int VisualStudioVersion
         {
             get
@@ -180,16 +191,24 @@ internal int VisualStudioVersion
         /// </summary>
         internal bool ContainsWebDeploymentProjects { get; private set; }
 
+        internal bool UseNewParser => ShouldUseNewParser(_solutionFile);
+
+        internal static bool ShouldUseNewParser(string solutionFile) => FileUtilities.IsSolutionXFilename(solutionFile);
+
         /// <summary>
         /// All projects in this solution, in the order they appeared in the solution file
         /// </summary>
+        /// <remarks>For the new parser, solution folders are no longer included.</remarks>
         public IReadOnlyList<ProjectInSolution> ProjectsInOrder => _projectsInOrder.AsReadOnly();
 
         /// <summary>
         /// The collection of projects in this solution, accessible by their guids as a
         /// string in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form
         /// </summary>
-        public IReadOnlyDictionary<string, ProjectInSolution> ProjectsByGuid => new ReadOnlyDictionary<string, ProjectInSolution>(_projects);
+        /// <remarks>For the new parser, solution folders are no longer included.</remarks>
+        public IReadOnlyDictionary<string, ProjectInSolution> ProjectsByGuid => new ReadOnlyDictionary<string, ProjectInSolution>(_projectsByGuid);
+
+        internal IReadOnlyDictionary<string, ProjectInSolution> SolutionFoldersByGuid => new ReadOnlyDictionary<string, ProjectInSolution>(_solutionFoldersByGuid);
 
         /// <summary>
         /// This is the read/write accessor for the solution file which we will parse.  This
@@ -239,7 +258,7 @@ internal string SolutionFileDirectory
         /// <summary>
         /// The list of all full solution configurations (configuration + platform) in this solution
         /// </summary>
-        public IReadOnlyList<SolutionConfigurationInSolution> SolutionConfigurations => _solutionConfigurations.AsReadOnly();
+        public IReadOnlyList<SolutionConfigurationInSolution> SolutionConfigurations => _solutionConfigurationsByFullName.Values.ToList().AsReadOnly();
 
         #endregion
 
@@ -257,11 +276,227 @@ internal bool ProjectShouldBuild(string projectFile)
         /// </summary>
         public static SolutionFile Parse(string solutionFile)
         {
-            var parser = new SolutionFile { FullPath = solutionFile };
-            parser.ParseSolutionFile();
-            return parser;
+            var solution = new SolutionFile { FullPath = solutionFile };
+
+            if (solution.UseNewParser)
+            {
+                solution.ParseUsingNewParser();
+            }
+            else
+            {
+                // Parse the solution file using the old parser
+                solution.ParseSolutionFile();
+            }
+
+            return solution;
+        }
+
+        /// <summary>
+        /// Parses .sln, .slnx and .slnf files using Microsoft.VisualStudio.SolutionPersistence.
+        /// </summary>
+        internal void ParseUsingNewParser()
+        {
+            ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(FullPath);
+
+            if (serializer != null)
+            {
+                try
+                {
+                    SolutionModel solutionModel = serializer.OpenAsync(FullPath, CancellationToken.None).Result;
+                    ReadSolutionModel(solutionModel);
+                }
+                catch (Exception ex)
+                {
+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(
+                            new BuildEventFileInfo(FullPath),
+                            $"InvalidProjectFile",
+                            ex.ToString());
+                }
+            }
+            else if (serializer == null)
+            {
+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(
+                    new BuildEventFileInfo(FullPath),
+                    $"InvalidProjectFile",
+                    $"No solution serializer was found for {FullPath}");
+            }
+        }
+
+        /// <summary>
+        /// Maps <see cref="SolutionModel"/> to <see cref="SolutionFile" />.
+        /// <see cref="SolutionModel"/> is a result of parsing solution using the new parser.
+        /// </summary>
+        /// <param name="solutionModel"></param>
+        private void ReadSolutionModel(SolutionModel solutionModel)
+        {
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(_solutionFile), "ReadSolutionModel() got a null or empty solution file.");
+            ErrorUtilities.VerifyThrowInternalRooted(_solutionFile);
+
+            _projectsByGuid = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);
+            _solutionFoldersByGuid = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);
+            _projectsInOrder = new List<ProjectInSolution>();
+            ContainsWebProjects = false;
+            Version = 0;
+            _currentLineNumber = 0;
+            _solutionConfigurationsByFullName = new Dictionary<string, SolutionConfigurationInSolution>();
+            _defaultConfigurationName = null;
+            _defaultPlatformName = null;
+
+            _currentVisualStudioVersion = solutionModel.VisualStudioProperties.Version;
+
+            ReadProjects(solutionModel);
+
+            // We need to save the solution folders in order to cache the unique project names and check for duplicates.
+            ReadSolutionFolders(solutionModel);
+
+            if (_solutionFilter != null)
+            {
+                ValidateProjectsInSolutionFilter();
+            }
+
+            CacheUniqueProjectNamesAndCheckForDuplicates();
+        }
+
+        private void ReadProjects(SolutionModel solutionModel)
+        {
+            foreach (SolutionProjectModel projectModel in solutionModel.SolutionProjects)
+            {
+                var proj = new ProjectInSolution(this)
+                {
+                    ProjectName = GetProjectName(projectModel),
+                    RelativePath = projectModel.FilePath,
+                    ProjectGuid = ToProjectGuidFormat(projectModel.Id),
+                };
+
+                // If the project name is empty the new parser throws an error.
+
+                // Validate project relative path
+                ValidateProjectRelativePath(proj);
+
+                SetProjectType(proj, ToProjectGuidFormat(projectModel.TypeId));
+
+                SetProjectDependencies(proj, projectModel);
+
+                SetWebsiteProperties(proj, projectModel);
+
+                // Note: This is corresponds to GlobalSection(NestedProjects) section in sln files.
+                if (projectModel.Parent != null)
+                {
+                    proj.ParentProjectGuid = ToProjectGuidFormat(projectModel.Parent.Id);
+                }
+
+                SetProjectConfigurations(proj, projectModel, solutionModel.BuildTypes, solutionModel.Platforms);
+
+                // Add the project to the collection
+                AddProjectToSolution(proj);
+
+                // If the project is an etp project then parse the etp project file
+                // to get the projects contained in it.
+                if (IsEtpProjectFile(proj.RelativePath))
+                {
+                    ParseEtpProject(proj);
+                }
+            }
+        }
+
+        private string GetProjectName(SolutionProjectModel projectModel)
+            => !string.IsNullOrEmpty(projectModel.DisplayName) ? projectModel.DisplayName : projectModel.ActualDisplayName;
+
+        /// <summary>
+        /// Returns a string from Guid in the format that the old MSBuild solution parser returned.
+        /// </summary>
+        private static string ToProjectGuidFormat(Guid id) => id.ToString("B").ToUpper();
+
+        private void SetProjectDependencies(ProjectInSolution proj, SolutionProjectModel projectModel)
+        {
+            if (projectModel.Dependencies == null)
+            {
+                return;
+            }
+
+            foreach (var dependency in projectModel.Dependencies)
+            {
+                proj.AddDependency(ToProjectGuidFormat(dependency.Id));
+            }
+        }
+
+        private void SetWebsiteProperties(ProjectInSolution proj, SolutionProjectModel projectModel)
+        {
+            SolutionPropertyBag websiteProperties = projectModel?.Properties.FirstOrDefault(p => p.Id == "WebsiteProperties");
+
+            if (websiteProperties is null)
+            {
+                return;
+            }
+
+            foreach (var property in websiteProperties)
+            {
+                ParseAspNetCompilerProperty(proj, property.Key, property.Value);
+            }
+        }
+
+        private void SetProjectConfigurations(
+            ProjectInSolution proj,
+            SolutionProjectModel projectModel,
+            IReadOnlyList<string> buildTypes,
+            IReadOnlyList<string> platforms)
+        {
+            foreach (string solutionBuildType in buildTypes)
+            {
+                foreach (string solutionPlatform in platforms)
+                {
+                    // isBuild represents Build.0. The "Build.0" entry tells us whether to build the project configuration in the given solution configuration
+                    // _ argument represents Deploy.0 which we do not use in the old parser
+                    (string projectBuildType, string projectPlatform, bool isBuild, bool _) = projectModel.GetProjectConfiguration(solutionBuildType, solutionPlatform);
+
+                    if (projectBuildType == null || projectPlatform == null)
+                    {
+                        continue;
+                    }
+
+                    var projectConfiguration = new ProjectConfigurationInSolution(
+                                projectBuildType,
+                                projectPlatform,
+                                isBuild);
+
+                    string configurationName = SolutionConfigurationInSolution.ComputeFullName(solutionBuildType, solutionPlatform);
+
+                    proj.SetProjectConfiguration(configurationName, projectConfiguration);
+
+                    // There are no solution configurations in the new parser. Instead we collect them from each project's configurations.
+                    AddSolutionConfiguration(solutionBuildType, solutionPlatform);
+                }
+            }
         }
 
+        private void ReadSolutionFolders(SolutionModel solutionModel)
+        {
+            foreach (SolutionFolderModel solutionFolderModel in solutionModel.SolutionFolders)
+            {
+                var proj = new ProjectInSolution(this)
+                {
+                    ProjectName = GetSolutionFolderName(solutionFolderModel),
+                    ProjectGuid = ToProjectGuidFormat(solutionFolderModel.Id),
+                    ProjectType = SolutionProjectType.SolutionFolder,
+                };
+
+                // If the project name is empty the new parser throws an error. 
+
+                if (solutionFolderModel.Parent != null)
+                {
+                    proj.ParentProjectGuid = ToProjectGuidFormat(solutionFolderModel.Parent.Id);
+                }
+
+                if (!string.IsNullOrEmpty(proj.ProjectGuid))
+                {
+                    _solutionFoldersByGuid[proj.ProjectGuid] = proj;
+                }
+            }
+        }
+
+        private string GetSolutionFolderName(SolutionFolderModel solutionFolderModel)
+            => !string.IsNullOrEmpty(solutionFolderModel.Name) ? solutionFolderModel.Name : solutionFolderModel.ActualDisplayName;
+
         /// <summary>
         /// Returns "true" if it's a project that's expected to be buildable, or false if it's
         /// not (e.g. a solution folder)
@@ -432,7 +667,12 @@ internal static string ParseSolutionFromSolutionFilter(string solutionFilterFile
         /// </summary>
         internal void AddSolutionConfiguration(string configurationName, string platformName)
         {
-            _solutionConfigurations.Add(new SolutionConfigurationInSolution(configurationName, platformName));
+            var solutionConfiguration = new SolutionConfigurationInSolution(configurationName, platformName);
+
+            if (!_solutionConfigurationsByFullName.ContainsKey(solutionConfiguration.FullName))
+            {
+                _solutionConfigurationsByFullName[solutionConfiguration.FullName] = solutionConfiguration;
+            }
         }
 
         /// <summary>
@@ -497,12 +737,13 @@ internal void ParseSolutionFile()
         /// </summary>
         internal void ParseSolution()
         {
-            _projects = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);
+            _projectsByGuid = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);
+            _solutionFoldersByGuid = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);
             _projectsInOrder = new List<ProjectInSolution>();
             ContainsWebProjects = false;
             Version = 0;
             _currentLineNumber = 0;
-            _solutionConfigurations = new List<SolutionConfigurationInSolution>();
+            _solutionConfigurationsByFullName = new Dictionary<string, SolutionConfigurationInSolution>();
             _defaultConfigurationName = null;
             _defaultPlatformName = null;
 
@@ -543,24 +784,7 @@ internal void ParseSolution()
 
             if (_solutionFilter != null)
             {
-                HashSet<string> projectPaths = new HashSet<string>(_projectsInOrder.Count, _pathComparer);
-                foreach (ProjectInSolution project in _projectsInOrder)
-                {
-                    projectPaths.Add(FileUtilities.FixFilePath(project.RelativePath));
-                }
-                foreach (string project in _solutionFilter)
-                {
-                    if (!projectPaths.Contains(project))
-                    {
-                        ProjectFileErrorUtilities.ThrowInvalidProjectFile(
-                            "SubCategoryForSolutionParsingErrors",
-                            new BuildEventFileInfo(FileUtilities.GetFullPath(project, Path.GetDirectoryName(_solutionFile))),
-                            "SolutionFilterFilterContainsProjectNotInSolution",
-                            _solutionFilterFile,
-                            project,
-                            _solutionFile);
-                    }
-                }
+                ValidateProjectsInSolutionFilter();
             }
 
             if (rawProjectConfigurationsEntries != null)
@@ -568,13 +792,18 @@ internal void ParseSolution()
                 ProcessProjectConfigurationSection(rawProjectConfigurationsEntries);
             }
 
+            CacheUniqueProjectNamesAndCheckForDuplicates();
+        }
+
+        private void CacheUniqueProjectNamesAndCheckForDuplicates()
+        {
             // Cache the unique name of each project, and check that we don't have any duplicates.
             var projectsByUniqueName = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);
             var projectsByOriginalName = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             foreach (ProjectInSolution proj in _projectsInOrder)
             {
-                // Find the unique name for the project.  This method also caches the unique name,
+                // Find the unique name for the project. This method also caches the unique name,
                 // so it doesn't have to be recomputed later.
                 string uniqueName = proj.GetUniqueProjectName();
 
@@ -645,7 +874,31 @@ internal void ParseSolution()
                     "SolutionParseDuplicateProject",
                     uniqueNameExists ? uniqueName : proj.ProjectName);
             }
-        } // ParseSolutionFile()
+        }
+
+        private void ValidateProjectsInSolutionFilter()
+        {
+            HashSet<string> projectPaths = new HashSet<string>(_projectsInOrder.Count, _pathComparer);
+
+            foreach (ProjectInSolution project in _projectsInOrder)
+            {
+                projectPaths.Add(FileUtilities.FixFilePath(project.RelativePath));
+            }
+
+            foreach (string project in _solutionFilter)
+            {
+                if (!projectPaths.Contains(project))
+                {
+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(
+                        "SubCategoryForSolutionParsingErrors",
+                        new BuildEventFileInfo(FileUtilities.GetFullPath(project, Path.GetDirectoryName(_solutionFile))),
+                        "SolutionFilterFilterContainsProjectNotInSolution",
+                        _solutionFilterFile,
+                        project,
+                        _solutionFile);
+                }
+            }
+        }
 
         /// <summary>
         /// This method searches the first two lines of the solution file opened by the specified
@@ -1000,7 +1253,7 @@ private void AddProjectToSolution(ProjectInSolution proj)
         {
             if (!String.IsNullOrEmpty(proj.ProjectGuid))
             {
-                _projects[proj.ProjectGuid] = proj;
+                _projectsByGuid[proj.ProjectGuid] = proj;
             }
             _projectsInOrder.Add(proj);
         }
@@ -1264,6 +1517,11 @@ internal void ParseFirstProjectLine(
             // Validate project relative path
             ValidateProjectRelativePath(proj);
 
+            SetProjectType(proj, projectTypeGuid);
+        }
+
+        private void SetProjectType(ProjectInSolution proj, string projectTypeGuid)
+        {
             // Figure out what type of project this is.
             if ((String.Equals(projectTypeGuid, vbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
                 (String.Equals(projectTypeGuid, csProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
@@ -1347,7 +1605,7 @@ internal void ParseNestedProjects()
                 string projectGuid = match.Groups["PROPERTYNAME"].Value.Trim();
                 string parentProjectGuid = match.Groups["PROPERTYVALUE"].Value.Trim();
 
-                if (!_projects.TryGetValue(projectGuid, out ProjectInSolution proj))
+                if (!_projectsByGuid.TryGetValue(projectGuid, out ProjectInSolution proj))
                 {
                     ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(proj != null, "SubCategoryForSolutionParsingErrors",
                        new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseNestedProjectUndefinedError", projectGuid, parentProjectGuid);
@@ -1407,7 +1665,7 @@ internal void ParseSolutionConfigurations()
 
                 var (configuration, platform) = ParseConfigurationName(fullConfigurationName, FullPath, _currentLineNumber, str);
 
-                _solutionConfigurations.Add(new SolutionConfigurationInSolution(configuration, platform));
+                AddSolutionConfiguration(configuration, platform);
             } while (true);
         }
 
@@ -1495,7 +1753,7 @@ internal void ProcessProjectConfigurationSection(Dictionary<string, string> rawP
                 // Solution folders don't have configurations
                 if (project.ProjectType != SolutionProjectType.SolutionFolder)
                 {
-                    foreach (SolutionConfigurationInSolution solutionConfiguration in _solutionConfigurations)
+                    foreach (SolutionConfigurationInSolution solutionConfiguration in _solutionConfigurationsByFullName.Values)
                     {
                         // The "ActiveCfg" entry defines the active project configuration in the given solution configuration
                         // This entry must be present for every possible solution configuration/project combination.
@@ -1610,7 +1868,7 @@ public string GetDefaultPlatformName()
         /// <returns></returns>
         internal string GetProjectUniqueNameByGuid(string projectGuid)
         {
-            if (_projects.TryGetValue(projectGuid, out ProjectInSolution proj))
+            if (_projectsByGuid.TryGetValue(projectGuid, out ProjectInSolution proj))
             {
                 return proj.GetUniqueProjectName();
             }
@@ -1626,7 +1884,7 @@ internal string GetProjectUniqueNameByGuid(string projectGuid)
         /// <returns></returns>
         internal string GetProjectRelativePathByGuid(string projectGuid)
         {
-            if (_projects.TryGetValue(projectGuid, out ProjectInSolution proj))
+            if (_projectsByGuid.TryGetValue(projectGuid, out ProjectInSolution proj))
             {
                 return proj.RelativePath;
             }
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 1cbb076827b..760fcb390f3 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -691,12 +691,16 @@ internal static bool WouldProjectBuild(SolutionFile solutionFile, string selecte
         /// </summary>
         private ProjectInstance[] Generate()
         {
-            // Validate against our minimum for upgradable projects
-            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
-                _solutionFile.Version >= SolutionFile.slnFileMinVersion,
-                "SubCategoryForSolutionParsingErrors",
-                new BuildEventFileInfo(_solutionFile.FullPath),
-                "SolutionParseUpgradeNeeded");
+            // The Version is not available in the new parser.
+            if (!_solutionFile.UseNewParser)
+            {
+                // Validate against our minimum for upgradable projects
+                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
+                    _solutionFile.Version >= SolutionFile.slnFileMinVersion,
+                    "SubCategoryForSolutionParsingErrors",
+                    new BuildEventFileInfo(_solutionFile.FullPath),
+                    "SolutionParseUpgradeNeeded");
+            }
 
             // This is needed in order to make decisions about tools versions such as whether to put a
             // ToolsVersion parameter on <MSBuild> task tags and what MSBuildToolsPath to use when
diff --git a/src/Build/Definition/ToolsetRegistryReader.cs b/src/Build/Definition/ToolsetRegistryReader.cs
index 19bd5141017..d81133f3a58 100644
--- a/src/Build/Definition/ToolsetRegistryReader.cs
+++ b/src/Build/Definition/ToolsetRegistryReader.cs
@@ -11,7 +11,6 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Constants = Microsoft.Build.Internal.Constants;
-using error = Microsoft.Build.Shared.ErrorUtilities;
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
 using RegistryException = Microsoft.Build.Exceptions.RegistryException;
 using RegistryKeyWrapper = Microsoft.Build.Internal.RegistryKeyWrapper;
@@ -63,7 +62,7 @@ internal ToolsetRegistryReader(PropertyDictionary<ProjectPropertyInstance> envir
         internal ToolsetRegistryReader(PropertyDictionary<ProjectPropertyInstance> environmentProperties, PropertyDictionary<ProjectPropertyInstance> globalProperties, RegistryKeyWrapper msbuildRegistryWrapper)
             : base(environmentProperties, globalProperties)
         {
-            error.VerifyThrowArgumentNull(msbuildRegistryWrapper, nameof(msbuildRegistryWrapper));
+            ErrorUtilities.VerifyThrowArgumentNull(msbuildRegistryWrapper, nameof(msbuildRegistryWrapper));
 
             _msbuildRegistryWrapper = msbuildRegistryWrapper;
         }
diff --git a/src/Build/ElementLocation/ElementLocation.cs b/src/Build/ElementLocation/ElementLocation.cs
index c9bf42b48b2..8ca5594c946 100644
--- a/src/Build/ElementLocation/ElementLocation.cs
+++ b/src/Build/ElementLocation/ElementLocation.cs
@@ -185,19 +185,16 @@ internal static ElementLocation Create(string file)
         /// In AG there are 600 locations that have a file but zero line and column.
         /// In theory yet another derived class could be made for these to save 4 bytes each.
         /// </remarks>
-        internal static ElementLocation Create(string file, int line, int column)
+        public static ElementLocation Create(string file, int line, int column)
         {
             if (string.IsNullOrEmpty(file) && line == 0 && column == 0)
             {
                 return EmptyLocation;
             }
 
-            if (line <= 65535 && column <= 65535)
-            {
-                return new ElementLocation.SmallElementLocation(file, line, column);
-            }
-
-            return new ElementLocation.RegularElementLocation(file, line, column);
+            return line <= 65535 && column <= 65535
+                ? new ElementLocation.SmallElementLocation(file, line, column)
+                : new ElementLocation.RegularElementLocation(file, line, column);
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs b/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
index 35faaad48df..a1e8dc7f30d 100644
--- a/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
+++ b/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
@@ -75,8 +75,8 @@ protected static string GetElementOrConditionText(string description, Evaluation
         protected void AppendDefaultHeaderWithSeparator(StringBuilder stringBuilder, string separator)
         {
             stringBuilder.AppendLine(
-                string.Join(separator, ["Id", "ParentId", "Pass", "File", "Line #", "Expression", "Inc (ms)", "Inc (%)", "Exc (ms)",
-                        "Exc (%)", "#", "Kind", "Bug"]));
+                string.Join(separator, "Id", "ParentId", "Pass", "File", "Line #", "Expression", "Inc (ms)", "Inc (%)", "Exc (ms)",
+                        "Exc (%)", "#", "Kind", "Bug"));
         }
 
         /// <summary>
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 1419a53c6db..1eacb69a5d0 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -2574,45 +2574,82 @@ internal static ProjectInstance[] LoadSolutionForBuild(
             // we should be generating a 4.0+ or a 3.5-style wrapper project based on the version of the solution.
             else
             {
-                string solutionFile = projectFile;
-                if (FileUtilities.IsSolutionFilterFilename(projectFile))
-                {
-                    solutionFile = SolutionFile.ParseSolutionFromSolutionFilter(projectFile, out _);
-                }
-                SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(solutionFile, out int solutionVersion, out int visualStudioVersion);
+                projectInstances = CalculateToolsVersionAndGenerateSolutionWrapper(
+                    projectFile,
+                    buildParameters,
+                    loggingService,
+                    projectBuildEventContext,
+                    globalProperties,
+                    isExplicitlyLoaded,
+                    targetNames,
+                    sdkResolverService,
+                    submissionId);
+            }
+
+            return projectInstances;
+        }
+
+        private static ProjectInstance[] CalculateToolsVersionAndGenerateSolutionWrapper(
+            string projectFile,
+            BuildParameters buildParameters,
+            ILoggingService loggingService,
+            BuildEventContext projectBuildEventContext,
+            Dictionary<string, string> globalProperties,
+            bool isExplicitlyLoaded,
+            IReadOnlyCollection<string> targetNames,
+            ISdkResolverService sdkResolverService,
+            int submissionId)
+        {
+            string solutionFileName = projectFile;
+
+            if (FileUtilities.IsSolutionFilterFilename(projectFile))
+            {
+                solutionFileName = SolutionFile.ParseSolutionFromSolutionFilter(projectFile, out _);
+            }
 
-                // If we get to this point, it's because it's a valid version.  Map the solution version
-                // to the equivalent MSBuild ToolsVersion, and unless it's Dev10 or newer, spawn the old
-                // engine to generate the solution wrapper.
-                if (solutionVersion <= 9) /* Whidbey or before */
+            if (SolutionFile.ShouldUseNewParser(solutionFileName))
+            {
+                // For the new parser we use Current tools version.
+                return GenerateSolutionWrapper(projectFile, globalProperties, "Current", loggingService, projectBuildEventContext, targetNames, sdkResolverService, submissionId);
+            }
+
+            // For the old parser we try to make a best-effort guess based on the version of the solution.
+            string toolsVersion = null;
+            ProjectInstance[] projectInstances = null;
+
+            SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(solutionFileName, out int solutionVersion, out int visualStudioVersion);
+
+            // If we get to this point, it's because it's a valid version.  Map the solution version
+            // to the equivalent MSBuild ToolsVersion, and unless it's Dev10 or newer, spawn the old
+            // engine to generate the solution wrapper.
+            if (solutionVersion <= 9) /* Whidbey or before */
+            {
+                loggingService.LogComment(projectBuildEventContext, MessageImportance.Low, "OldWrapperGeneratedOldSolutionVersion", "2.0", solutionVersion);
+                projectInstances = GenerateSolutionWrapperUsingOldOM(projectFile, globalProperties, "2.0", buildParameters.ProjectRootElementCache, buildParameters, loggingService, projectBuildEventContext, isExplicitlyLoaded, sdkResolverService, submissionId);
+            }
+            else if (solutionVersion == 10) /* Orcas */
+            {
+                loggingService.LogComment(projectBuildEventContext, MessageImportance.Low, "OldWrapperGeneratedOldSolutionVersion", "3.5", solutionVersion);
+                projectInstances = GenerateSolutionWrapperUsingOldOM(projectFile, globalProperties, "3.5", buildParameters.ProjectRootElementCache, buildParameters, loggingService, projectBuildEventContext, isExplicitlyLoaded, sdkResolverService, submissionId);
+            }
+            else
+            {
+                if ((solutionVersion == 11) || (solutionVersion == 12 && visualStudioVersion == 0)) /* Dev 10 and Dev 11 */
                 {
-                    loggingService.LogComment(projectBuildEventContext, MessageImportance.Low, "OldWrapperGeneratedOldSolutionVersion", "2.0", solutionVersion);
-                    projectInstances = GenerateSolutionWrapperUsingOldOM(projectFile, globalProperties, "2.0", buildParameters.ProjectRootElementCache, buildParameters, loggingService, projectBuildEventContext, isExplicitlyLoaded, sdkResolverService, submissionId);
+                    toolsVersion = "4.0";
                 }
-                else if (solutionVersion == 10) /* Orcas */
+                else /* Dev 12 and above */
                 {
-                    loggingService.LogComment(projectBuildEventContext, MessageImportance.Low, "OldWrapperGeneratedOldSolutionVersion", "3.5", solutionVersion);
-                    projectInstances = GenerateSolutionWrapperUsingOldOM(projectFile, globalProperties, "3.5", buildParameters.ProjectRootElementCache, buildParameters, loggingService, projectBuildEventContext, isExplicitlyLoaded, sdkResolverService, submissionId);
+                    toolsVersion = visualStudioVersion.ToString(CultureInfo.InvariantCulture) + ".0";
                 }
-                else
-                {
-                    if ((solutionVersion == 11) || (solutionVersion == 12 && visualStudioVersion == 0)) /* Dev 10 and Dev 11 */
-                    {
-                        toolsVersion = "4.0";
-                    }
-                    else /* Dev 12 and above */
-                    {
-                        toolsVersion = visualStudioVersion.ToString(CultureInfo.InvariantCulture) + ".0";
-                    }
 
-                    string toolsVersionToUse = Utilities.GenerateToolsVersionToUse(
-                        explicitToolsVersion: null,
-                        toolsVersionFromProject: FileUtilities.IsSolutionFilterFilename(projectFile) ? "Current" : toolsVersion,
-                        getToolset: buildParameters.GetToolset,
-                        defaultToolsVersion: Constants.defaultSolutionWrapperProjectToolsVersion,
-                        usingDifferentToolsVersionFromProjectFile: out _);
-                    projectInstances = GenerateSolutionWrapper(projectFile, globalProperties, toolsVersionToUse, loggingService, projectBuildEventContext, targetNames, sdkResolverService, submissionId);
-                }
+                string toolsVersionToUse = Utilities.GenerateToolsVersionToUse(
+                    explicitToolsVersion: null,
+                    toolsVersionFromProject: FileUtilities.IsSolutionFilterFilename(projectFile) ? "Current" : toolsVersion,
+                    getToolset: buildParameters.GetToolset,
+                    defaultToolsVersion: Constants.defaultSolutionWrapperProjectToolsVersion,
+                    usingDifferentToolsVersionFromProjectFile: out _);
+                projectInstances = GenerateSolutionWrapper(projectFile, globalProperties, toolsVersionToUse, loggingService, projectBuildEventContext, targetNames, sdkResolverService, submissionId);
             }
 
             return projectInstances;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 395263d6a53..9fd2cd14812 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -243,10 +243,11 @@ e is FormatException ||
                     (e is EndOfStreamException && _readStream.BytesCountAllowedToReadRemaining <= 0))
                 {
                     hasError = true;
-
+                    int localSerializedEventLength = serializedEventLength;
+                    Exception localException = e;
                     string ErrorFactory() =>
                         ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Binlog_ReaderMismatchedRead",
-                            _recordNumber, serializedEventLength, e.GetType(), e.Message) + (_skipUnknownEvents
+                            _recordNumber, localSerializedEventLength, localException.GetType(), localException.Message) + (_skipUnknownEvents
                             ? " " + ResourceUtilities.GetResourceString("Binlog_ReaderSkippingRecord")
                             : string.Empty);
 
@@ -255,9 +256,11 @@ string ErrorFactory() =>
 
                 if (result == null && !hasError)
                 {
+                    int localSerializedEventLength = serializedEventLength;
+                    BinaryLogRecordKind localRecordKind = recordKind;
                     string ErrorFactory() =>
                         ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Binlog_ReaderUnknownType",
-                            _recordNumber, serializedEventLength, recordKind) + (_skipUnknownEvents
+                            _recordNumber, localSerializedEventLength, localRecordKind) + (_skipUnknownEvents
                             ? " " + ResourceUtilities.GetResourceString("Binlog_ReaderSkippingRecord")
                             : string.Empty);
 
@@ -266,9 +269,10 @@ string ErrorFactory() =>
 
                 if (_readStream.BytesCountAllowedToReadRemaining > 0)
                 {
+                    int localSerializedEventLength = serializedEventLength;
                     string ErrorFactory() => ResourceUtilities.FormatResourceStringStripCodeAndKeyword(
-                        "Binlog_ReaderUnderRead", _recordNumber, serializedEventLength,
-                        serializedEventLength - _readStream.BytesCountAllowedToReadRemaining);
+                        "Binlog_ReaderUnderRead", _recordNumber, localSerializedEventLength,
+                        localSerializedEventLength - _readStream.BytesCountAllowedToReadRemaining);
 
                     HandleError(ErrorFactory, _skipUnknownEventParts, ReaderErrorType.UnknownEventData, recordKind);
                 }
@@ -1437,9 +1441,9 @@ private void SetCommonFields(BuildEventArgs buildEventArgs, BuildEventArgsFields
             }
         }
 
-        private IEnumerable? ReadPropertyList()
+        private IList<DictionaryEntry>? ReadPropertyList()
         {
-            var properties = ReadStringDictionary();
+            IDictionary<string, string>? properties = ReadStringDictionary();
             if (properties == null || properties.Count == 0)
             {
                 return null;
@@ -1530,7 +1534,7 @@ private ITaskItem ReadTaskItem()
             return taskItem;
         }
 
-        private IEnumerable? ReadProjectItems()
+        private IList<DictionaryEntry>? ReadProjectItems()
         {
             IList<DictionaryEntry>? list;
 
@@ -1612,7 +1616,7 @@ private ITaskItem ReadTaskItem()
             return list;
         }
 
-        private IEnumerable? ReadTaskItemList()
+        private IList<ITaskItem>? ReadTaskItemList()
         {
             int count = ReadInt32();
             if (count == 0)
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
index d8eca6c3848..8a0cc2ed489 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
@@ -59,30 +59,28 @@ public static long SkipBytes(this Stream stream, long bytesCount, byte[] buffer)
 
         public static byte[] ReadToEnd(this Stream stream)
         {
-            if (stream.TryGetLength(out long length))
-            {
-                using BinaryReader reader = new(stream, Encoding.UTF8, leaveOpen: true);
-
-                return reader.ReadBytes((int)length);
-            }
-
-            using var ms = new MemoryStream();
+            MemoryStream ms = stream.TryGetLength(out long length) && length <= int.MaxValue ? new((int)length) : new();
             stream.CopyTo(ms);
-            return ms.ToArray();
+            byte[] buffer = ms.GetBuffer();
+            return buffer.Length == ms.Length ? buffer : ms.ToArray();
         }
 
         public static bool TryGetLength(this Stream stream, out long length)
         {
             try
             {
-                length = stream.Length;
-                return true;
+                if (stream.CanSeek)
+                {
+                    length = stream.Length;
+                    return true;
+                }
             }
             catch (NotSupportedException)
             {
-                length = 0;
-                return false;
             }
+
+            length = 0;
+            return false;
         }
 
         public static Stream ToReadableSeekableStream(this Stream stream)
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs b/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
index ff5caf9bfdf..8c6e0c6e2b8 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
@@ -3,6 +3,8 @@
 
 using System;
 using System.IO;
+using System.Threading;
+using System.Threading.Tasks;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
@@ -40,7 +42,8 @@ public SubStream(Stream stream, long length)
 
         public override long Position { get => _position; set => throw new NotImplementedException(); }
 
-        public override void Flush() { }
+        public override void Flush() => _stream.Flush();
+        public override Task FlushAsync(CancellationToken cancellationToken) => _stream.FlushAsync(cancellationToken);
         public override int Read(byte[] buffer, int offset, int count)
         {
             count = Math.Min((int)Math.Max(Length - _position, 0), count);
@@ -48,6 +51,50 @@ public override int Read(byte[] buffer, int offset, int count)
             _position += read;
             return read;
         }
+
+        public override int ReadByte()
+        {
+            if (Length - _position > 0)
+            {
+                int value = _stream.ReadByte();
+                if (value >= 0)
+                {
+                    _position++;
+                    return value;
+                }
+            }
+
+            return -1;
+        }
+
+        public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
+        {
+            count = Math.Min((int)Math.Max(Length - _position, 0), count);
+#pragma warning disable CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+            int read = await _stream.ReadAsync(buffer, offset, count, cancellationToken).ConfigureAwait(false);
+#pragma warning restore CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+            _position += read;
+            return read;
+        }
+
+#if NET
+        public override int Read(Span<byte> buffer)
+        {
+            buffer = buffer.Slice(0, Math.Min((int)Math.Max(Length - _position, 0), buffer.Length));
+            int read = _stream.Read(buffer);
+            _position += read;
+            return read;
+        }
+
+        public override async ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default)
+        {
+            buffer = buffer.Slice(0, Math.Min((int)Math.Max(Length - _position, 0), buffer.Length));
+            int read = await _stream.ReadAsync(buffer, cancellationToken).ConfigureAwait(false);
+            _position += read;
+            return read;
+        }
+#endif
+
         public override long Seek(long offset, SeekOrigin origin) => throw new NotImplementedException();
         public override void SetLength(long value) => throw new NotImplementedException();
         public override void Write(byte[] buffer, int offset, int count) => throw new NotImplementedException();
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs b/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
index 4dd9afa0300..ea3fcb3c9c7 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
@@ -3,6 +3,8 @@
 
 using System;
 using System.IO;
+using System.Threading;
+using System.Threading.Tasks;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
@@ -75,6 +77,11 @@ public override void Flush()
             _stream.Flush();
         }
 
+        public override Task FlushAsync(CancellationToken cancellationToken)
+        {
+            return _stream.FlushAsync(cancellationToken);
+        }
+
         public override int Read(byte[] buffer, int offset, int count)
         {
             if (_position + count > _maxAllowedPosition)
@@ -87,6 +94,61 @@ public override int Read(byte[] buffer, int offset, int count)
             return cnt;
         }
 
+        public override int ReadByte()
+        {
+            if (_position + 1 <= _maxAllowedPosition)
+            {
+                int value = _stream.ReadByte();
+                if (value >= 0)
+                {
+                    _position++;
+                    return value;
+                }
+            }
+
+            return -1;
+        }
+
+        public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
+        {
+            if (_position + count > _maxAllowedPosition)
+            {
+                count = (int)(_maxAllowedPosition - _position);
+            }
+
+#pragma warning disable CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+            int cnt = await _stream.ReadAsync(buffer, offset, count, cancellationToken).ConfigureAwait(false);
+#pragma warning restore CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+            _position += cnt;
+            return cnt;
+        }
+
+#if NET
+        public override int Read(Span<byte> buffer)
+        {
+            if (_position + buffer.Length > _maxAllowedPosition)
+            {
+                buffer = buffer.Slice(0, (int)(_maxAllowedPosition - _position));
+            }
+
+            int cnt = _stream.Read(buffer);
+            _position += cnt;
+            return cnt;
+        }
+
+        public override async ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default)
+        {
+            if (_position + buffer.Length > _maxAllowedPosition)
+            {
+                buffer = buffer.Slice(0, (int)(_maxAllowedPosition - _position));
+            }
+
+            int cnt = await _stream.ReadAsync(buffer, cancellationToken).ConfigureAwait(false);
+            _position += cnt;
+            return cnt;
+        }
+#endif
+
         public override long Seek(long offset, SeekOrigin origin)
         {
             if (origin != SeekOrigin.Current)
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 24471d364ba..9a39ec6bad7 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -30,6 +30,7 @@
   <ItemGroup>
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
+    <PackageReference Include="Microsoft.VisualStudio.SolutionPersistence" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
 
     <PackageReference Include="System.Reflection.MetadataLoadContext" />
@@ -38,7 +39,7 @@
 
     <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
   </ItemGroup>
-
+  
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildSourceOnly)' != 'true'">
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" PrivateAssets="all" />
   </ItemGroup>
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 5829ce6fad9..54661e23651 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -850,7 +850,7 @@
     <value>Task name cannot be empty.</value>
   </data>
   <data name="ProjectUpgradeNeeded" xml:space="preserve">
-    <value>MSB4075: The project file "{0}" must be opened in the Visual Studio IDE and converted to the latest version before it can be built by MSBuild.</value>
+    <value>MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</value>
     <comment>{StrBegin="MSB4075: "}</comment>
   </data>
   <data name="ProjectUpgradeNeededToVcxProj" xml:space="preserve">
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 6f83bd2e035..d9e3b9bf648 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -1579,8 +1579,8 @@ Chyby: {3}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeeded">
-        <source>MSB4075: The project file "{0}" must be opened in the Visual Studio IDE and converted to the latest version before it can be built by MSBuild.</source>
-        <target state="translated">MSB4075: P≈ôed sestaven√≠m pomoc√≠ n√°stroje MSBuild mus√≠ b√Ωt soubor projektu {0} otev≈ôen v prost≈ôed√≠ Visual Studio IDE a p≈ôeveden na nejnovƒõj≈°√≠ verzi.</target>
+        <source>MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</source>
+        <target state="new">MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</target>
         <note>{StrBegin="MSB4075: "}</note>
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeededToVcxProj">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 91ed701c9fd..7dbd182f202 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -1579,8 +1579,8 @@ Fehler: {3}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeeded">
-        <source>MSB4075: The project file "{0}" must be opened in the Visual Studio IDE and converted to the latest version before it can be built by MSBuild.</source>
-        <target state="translated">MSB4075: Die Projektdatei "{0}" muss in der Visual Studio IDE ge√∂ffnet und in die neuste Version konvertiert werden, bevor sie von MSBuild erstellt werden kann.</target>
+        <source>MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</source>
+        <target state="new">MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</target>
         <note>{StrBegin="MSB4075: "}</note>
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeededToVcxProj">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 74b791c90f7..c3053a65018 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -1579,8 +1579,8 @@ Errores: {3}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeeded">
-        <source>MSB4075: The project file "{0}" must be opened in the Visual Studio IDE and converted to the latest version before it can be built by MSBuild.</source>
-        <target state="translated">MSB4075: El archivo del proyecto "{0}" debe abrirse en el IDE de Visual Studio y convertirse a la versi√≥n m√°s reciente para que MSBuild lo pueda compilar.</target>
+        <source>MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</source>
+        <target state="new">MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</target>
         <note>{StrBegin="MSB4075: "}</note>
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeededToVcxProj">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index a2a7f46f41d..6c7fde83709 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -1579,8 +1579,8 @@ Erreurs¬†: {3}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeeded">
-        <source>MSB4075: The project file "{0}" must be opened in the Visual Studio IDE and converted to the latest version before it can be built by MSBuild.</source>
-        <target state="translated">MSB4075: Le fichier projet "{0}" doit √™tre ouvert dans Visual Studio IDE et converti dans la derni√®re version avant de pouvoir √™tre g√©n√©r√© par MSBuild.</target>
+        <source>MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</source>
+        <target state="new">MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</target>
         <note>{StrBegin="MSB4075: "}</note>
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeededToVcxProj">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 04ba91d7a23..a130647123d 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -1579,8 +1579,8 @@ Errori: {3}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeeded">
-        <source>MSB4075: The project file "{0}" must be opened in the Visual Studio IDE and converted to the latest version before it can be built by MSBuild.</source>
-        <target state="translated">MSB4075: prima di compilare il file di progetto "{0}" con MSBuild, √® necessario aprirlo in Visual Studio IDE e convertirlo alla versione pi√π recente.</target>
+        <source>MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</source>
+        <target state="new">MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</target>
         <note>{StrBegin="MSB4075: "}</note>
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeededToVcxProj">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 5e040372f98..3da37451847 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -1579,8 +1579,8 @@ Errors: {3}</source>
         <note />
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeeded">
-        <source>MSB4075: The project file "{0}" must be opened in the Visual Studio IDE and converted to the latest version before it can be built by MSBuild.</source>
-        <target state="translated">MSB4075: „Éó„É≠„Ç∏„Çß„ÇØ„Éà „Éï„Ç°„Ç§„É´ "{0}" „Çí MSBuild „Åß„Éì„É´„Éâ„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åô„Çã„Å´„ÅØ„ÄÅVisual Studio IDE „Åß„Éó„É≠„Ç∏„Çß„ÇØ„Éà „Éï„Ç°„Ç§„É´„ÇíÈñã„Åç„ÄÅÊúÄÊñ∞„Éê„Éº„Ç∏„Éß„É≥„Å´Â§âÊèõ„Åó„Å™„Åë„Çå„Å∞„Å™„Çä„Åæ„Åõ„Çì„ÄÇ</target>
+        <source>MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</source>
+        <target state="new">MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</target>
         <note>{StrBegin="MSB4075: "}</note>
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeededToVcxProj">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 58ce075c959..01e049e6138 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -1579,8 +1579,8 @@ Errors: {3}</source>
         <note />
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeeded">
-        <source>MSB4075: The project file "{0}" must be opened in the Visual Studio IDE and converted to the latest version before it can be built by MSBuild.</source>
-        <target state="translated">MSB4075: ÌîÑÎ°úÏ†ùÌä∏ ÌååÏùº "{0}"ÏùÑ(Î•º) MSBuildÎ°ú ÎπåÎìúÌïòÎ†§Î©¥ ÌååÏùºÏùÑ Visual Studio IDEÏóêÏÑú Ïó¥Ïñ¥ ÏµúÏã† Î≤ÑÏ†ÑÏúºÎ°ú Î≥ÄÌôòÌï¥Ïïº Ìï©ÎãàÎã§.</target>
+        <source>MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</source>
+        <target state="new">MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</target>
         <note>{StrBegin="MSB4075: "}</note>
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeededToVcxProj">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 5298a7ddf4c..d8c0fc15400 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -1579,8 +1579,8 @@ B≈Çƒôdy: {3}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeeded">
-        <source>MSB4075: The project file "{0}" must be opened in the Visual Studio IDE and converted to the latest version before it can be built by MSBuild.</source>
-        <target state="translated">MSB4075: Plik projektu ‚Äû{0}‚Äù musi zostaƒá otwarty w programie Visual Studio IDE i przekszta≈Çcony do najnowszej wersji, zanim bƒôdzie m√≥g≈Ç byƒá skompilowany w programie MSBuild.</target>
+        <source>MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</source>
+        <target state="new">MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</target>
         <note>{StrBegin="MSB4075: "}</note>
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeededToVcxProj">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 69b4337e10f..a0c709ac4ec 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -1579,8 +1579,8 @@ Erros: {3}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeeded">
-        <source>MSB4075: The project file "{0}" must be opened in the Visual Studio IDE and converted to the latest version before it can be built by MSBuild.</source>
-        <target state="translated">MSB4075: O arquivo de projeto "{0}" must deve ser aberto no IDE do Visual Studio e convertido na vers√£o mais recente, para que possa ser compilado pelo MSBuild.</target>
+        <source>MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</source>
+        <target state="new">MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</target>
         <note>{StrBegin="MSB4075: "}</note>
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeededToVcxProj">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 4a51ab49b0f..0b9705cde75 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -1579,8 +1579,8 @@ Errors: {3}</source>
         <note />
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeeded">
-        <source>MSB4075: The project file "{0}" must be opened in the Visual Studio IDE and converted to the latest version before it can be built by MSBuild.</source>
-        <target state="translated">MSB4075: —Ñ–∞–π–ª –ø—Ä–æ–µ–∫—Ç–∞ "{0}" –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç–∫—Ä—ã—Ç –≤ —Å—Ä–µ–¥–µ Visual Studio –∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω –≤ –ø–æ—Å–ª–µ–¥–Ω—é—é –≤–µ—Ä—Å–∏—é, –ø—Ä–µ–∂–¥–µ —á–µ–º –ø—Ä–æ–≥—Ä–∞–º–º–∞ MSBuild —Å–º–æ–∂–µ—Ç –ø–æ—Å—Ç—Ä–æ–∏—Ç—å —ç—Ç–æ—Ç –ø—Ä–æ–µ–∫—Ç.</target>
+        <source>MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</source>
+        <target state="new">MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</target>
         <note>{StrBegin="MSB4075: "}</note>
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeededToVcxProj">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 08bb0299385..ad9e918736b 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -1579,8 +1579,8 @@ Hatalar: {3}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeeded">
-        <source>MSB4075: The project file "{0}" must be opened in the Visual Studio IDE and converted to the latest version before it can be built by MSBuild.</source>
-        <target state="translated">MSB4075: MSBuild tarafƒ±ndan derlenebilmesi i√ßin, "{0}" proje dosyasƒ±nƒ±n Visual Studio IDE i√ßinde a√ßƒ±lmasƒ± ve en son s√ºr√ºme d√∂n√º≈üt√ºr√ºlmesi gerekir.</target>
+        <source>MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</source>
+        <target state="new">MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</target>
         <note>{StrBegin="MSB4075: "}</note>
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeededToVcxProj">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index abb22957391..8bf8ef922eb 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -1579,8 +1579,8 @@ Errors: {3}</source>
         <note />
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeeded">
-        <source>MSB4075: The project file "{0}" must be opened in the Visual Studio IDE and converted to the latest version before it can be built by MSBuild.</source>
-        <target state="translated">MSB4075: ÂøÖÈ°ªÂú® Visual Studio IDE ‰∏≠ÊâìÂºÄÈ°πÁõÆÊñá‰ª∂‚Äú{0}‚ÄùÔºåÂπ∂Â∞ÜÂÖ∂ËΩ¨Êç¢‰∏∫ÊúÄÊñ∞ÁâàÊú¨ÔºåÁÑ∂ÂêéÊâçËÉΩ‰ΩøÁî® MSBuild ÁîüÊàêËØ•È°πÁõÆÊñá‰ª∂„ÄÇ</target>
+        <source>MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</source>
+        <target state="new">MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</target>
         <note>{StrBegin="MSB4075: "}</note>
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeededToVcxProj">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 50b9a761cdf..5ff0e681ec4 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -1579,8 +1579,8 @@ Errors: {3}</source>
         <note />
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeeded">
-        <source>MSB4075: The project file "{0}" must be opened in the Visual Studio IDE and converted to the latest version before it can be built by MSBuild.</source>
-        <target state="translated">MSB4075: Â∞àÊ°àÊ™î "{0}" ÂøÖÈ†àÂú® Visual Studio IDE ‰∏≠ÈñãÂïüÔºå‰∏¶ËΩâÊèõÊàêÊúÄÊñ∞ÁâàÊú¨ÔºåÁÑ∂ÂæåÊâçËÉΩÁî± MSBuild Âª∫ÁΩÆ„ÄÇ</target>
+        <source>MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</source>
+        <target state="new">MSB4075: The project file "{0}" must be opened in a version of Visual Studio IDE that supports it and converted to the latest version before it can be built by MSBuild. More info: https://aka.ms/DeprecatedProjectConversion</target>
         <note>{StrBegin="MSB4075: "}</note>
       </trans-unit>
       <trans-unit id="ProjectUpgradeNeededToVcxProj">
diff --git a/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs b/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs
index 954f69ed050..ced7415118d 100644
--- a/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs
+++ b/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs
@@ -55,5 +55,7 @@ private void ResultHandler(CheckWrapper wrapper, ICheckContext context, CheckCon
             => Results.Add(result);
 
         public void RegisterEnvironmentVariableReadAction(Action<BuildCheckDataContext<EnvironmentVariableCheckData>> environmentVariableAction) => throw new NotImplementedException();
+
+        public void RegisterProjectImportedAction(Action<BuildCheckDataContext<ProjectImportedCheckData>> projectImportedAction) => throw new NotImplementedException();
     }
 }
diff --git a/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
index d79475be5f0..989cfa9c609 100644
--- a/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
+++ b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
@@ -11,7 +11,7 @@
 
   <!-- In the real world scenario, the dependencies are added as Nuget PackageReference, modified for test purposes only. -->
   <ItemGroup>
-    <ProjectReference Include="..\..\..\Build\Microsoft.Build.csproj" IncludeInPackage="true" />
+    <ProjectReference Include="..\..\..\Build\Microsoft.Build.csproj" />
   </ItemGroup>
 
 </Project>
diff --git a/src/Framework/NullableAttributes.cs b/src/Framework/Polyfills/NullableAttributes.cs
similarity index 100%
rename from src/Framework/NullableAttributes.cs
rename to src/Framework/Polyfills/NullableAttributes.cs
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index ee6eb6219fb..fb588b1615b 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -1577,8 +1577,10 @@ private void RunPriorityBuildTest(ProcessPriorityClass expectedPrority, params s
         /// </summary>
         [Theory]
         [InlineData(new[] { "my.proj", "my.sln", "my.slnf" }, "my.sln")]
+        [InlineData(new[] { "my.proj", "my.slnx", "my.slnf" }, "my.slnx")]
         [InlineData(new[] { "abc.proj", "bcd.csproj", "slnf.slnf", "other.slnf" }, "abc.proj")]
         [InlineData(new[] { "abc.sln", "slnf.slnf", "abc.slnf" }, "abc.sln")]
+        [InlineData(new[] { "abc.slnx", "slnf.slnf", "abc.slnf" }, "abc.slnx")]
         [InlineData(new[] { "abc.csproj", "abc.slnf", "not.slnf" }, "abc.csproj")]
         [InlineData(new[] { "abc.slnf" }, "abc.slnf")]
         public void TestDefaultBuildWithSolutionFilter(string[] projects, string answer)
@@ -1724,11 +1726,21 @@ public void TestProcessProjectSwitch()
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
             MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
+            projects = new[] { "test.proj", "test.slnx" };
+            extensionsToIgnore = new[] { ".vcproj" };
+            projectHelper = new IgnoreProjectExtensionsHelper(projects);
+            MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.slnx", StringCompareShould.IgnoreCase); // "Expected test.slnx to be only solution found"
+
             projects = new[] { "test.proj", "test.sln", "test.proj~", "test.sln~" };
             extensionsToIgnore = Array.Empty<string>();
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
             MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
+            projects = new[] { "test.proj", "test.slnx", "test.proj~", "test.sln~" };
+            extensionsToIgnore = Array.Empty<string>();
+            projectHelper = new IgnoreProjectExtensionsHelper(projects);
+            MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.slnx", StringCompareShould.IgnoreCase); // "Expected test.slnx to be only solution found"
+
             projects = new[] { "test.proj" };
             extensionsToIgnore = Array.Empty<string>();
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
@@ -1744,6 +1756,12 @@ public void TestProcessProjectSwitch()
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
             MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
+            projects = new[] { "test.slnx" };
+            extensionsToIgnore = Array.Empty<string>();
+            projectHelper = new IgnoreProjectExtensionsHelper(projects);
+            MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.slnx", StringCompareShould.IgnoreCase); // "Expected test.slnx to be only solution found"
+
+
             projects = new[] { "test.sln", "test.sln~" };
             extensionsToIgnore = Array.Empty<string>();
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
@@ -1796,6 +1814,21 @@ public void TestProcessProjectSwitchSlnProjDifferentNames()
             });
         }
         /// <summary>
+        /// Test the case where there is a .slnx and a project in the same directory but they have different names
+        /// </summary>
+        [Fact]
+        public void TestProcessProjectSwitchSlnxProjDifferentNames()
+        {
+            string[] projects = ["test.proj", "Different.slnx"];
+            string[] extensionsToIgnore = null;
+
+            Should.Throw<InitializationException>(() =>
+            {
+                IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
+                MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles);
+            });
+        }
+        /// <summary>
         /// Test the case where we have two proj files in the same directory
         /// </summary>
         [Fact]
@@ -1838,6 +1871,33 @@ public void TestProcessProjectSwitchTwoSolutions()
             });
         }
         /// <summary>
+        /// Test when there are two solutions in the same directory - .sln and .slnx
+        /// </summary>
+        [Fact]
+        public void TestProcessProjectSwitchSlnAndSlnx()
+        {
+            string[] projects = ["test.slnx", "Different.sln"];
+            string[] extensionsToIgnore = null;
+
+            Should.Throw<InitializationException>(() =>
+            {            
+                IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
+                MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles);
+            });
+        }
+        [Fact]
+        public void TestProcessProjectSwitchTwoSlnx()
+        {
+            string[] projects = ["test.slnx", "Different.slnx"];
+            string[] extensionsToIgnore = null;
+
+            Should.Throw<InitializationException>(() =>
+            {
+                IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
+                MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles);
+            });
+        }
+        /// <summary>
         /// Check the case where there are more than two projects in the directory and one is a proj file
         /// </summary>
         [Fact]
@@ -1897,7 +1957,7 @@ internal string[] GetFiles(string path, string searchPattern)
                 List<string> fileNamesToReturn = new List<string>();
                 foreach (string file in _directoryFileNameList)
                 {
-                    if (string.Equals(searchPattern, "*.sln", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(searchPattern, "*.sln?", StringComparison.OrdinalIgnoreCase))
                     {
                         if (FileUtilities.IsSolutionFilename(file))
                         {
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index d850697a06f..6ced0b3e006 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -3552,8 +3552,8 @@ internal static string ProcessProjectSwitch(
                     }
                 }
 
-                // Get all files in the current directory that have a sln extension
-                string[] potentialSolutionFiles = getFiles(projectDirectory ?? ".", "*.sln");
+                // Get all files in the current directory that have a sln-like extension
+                string[] potentialSolutionFiles = getFiles(projectDirectory ?? ".", "*.sln?");
                 List<string> actualSolutionFiles = new List<string>();
                 List<string> solutionFilterFiles = new List<string>();
                 if (potentialSolutionFiles != null)
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index c6a4d25d365..339dfe620bf 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -56,6 +56,10 @@
           <assemblyIdentity name="BuildXL.Utilities.Core" publicKeyToken="6212d9137135ce5d" culture="neutral" />
           <codeBase version="1.0.0.0" href="..\BuildXL.Utilities.Core.dll"/>
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.VisualStudio.SolutionPersistence" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\Microsoft.VisualStudio.SolutionPersistence.dll"/>
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index bca1b949230..da3dae7bf0f 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -62,7 +62,7 @@
       <Link>IExtendedBuildEventArgs.cs</Link>
     </Compile>
     <Compile Include="..\Framework\AssemblyUtilities.cs" />
-    <Compile Include="..\Framework\NullableAttributes.cs" />
+    <Compile Include="..\Framework\Polyfills\*.cs" />
     <Compile Include="..\Framework\ResponseFileUsedEventArgs.cs" />
     <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\CollectionHelpers.cs" />
diff --git a/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec b/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec
index 5067430dfd4..6c24f9d1820 100644
--- a/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec
+++ b/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec
@@ -19,7 +19,6 @@
     <file src="Microsoft.Build.Tasks.Core.dll" target="lib\net472" />
     <file src="Microsoft.Build.Utilities.Core.dll" target="lib\net472" />
     <file src="Microsoft.NET.StringTools.dll" target="lib\net472" />
-
     <file src="Microsoft.Build.tlb" target="lib\net472" />
     <file src="Microsoft.Build.Framework.tlb" target="lib\net472" />
     <file src="Microsoft.Build.Tasks.Core.tlb" target="lib\net472" />
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 88b173585d5..fcd8630dbd6 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -39,6 +39,7 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)BuildXL.Native.dll
   file source=$(X86BinPath)BuildXL.Processes.dll
   file source=$(X86BinPath)BuildXL.Utilities.Core.dll
+  file source=$(X86BinPath)Microsoft.VisualStudio.SolutionPersistence.dll
   file source=$(X86BinPath)RuntimeContracts.dll
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
diff --git a/src/Package/Microsoft.Build.UnGAC/Program.cs b/src/Package/Microsoft.Build.UnGAC/Program.cs
index 31e381dc049..d686da3dc75 100644
--- a/src/Package/Microsoft.Build.UnGAC/Program.cs
+++ b/src/Package/Microsoft.Build.UnGAC/Program.cs
@@ -30,7 +30,8 @@ private static void Main(string[] args)
                     "Microsoft.NET.StringTools, Version=1.0.0.0",
                     "BuildXL.Processes, Version=1.0.0.0",
                     "BuildXL.Utilities.Core, Version=1.0.0.0",
-                    "BuildXL.Native, Version=1.0.0.0"
+                    "BuildXL.Native, Version=1.0.0.0",
+                    "Microsoft.VisualStudio.SolutionPersistence, Version=1.0.0.0",
                 };
 
                 uint hresult = NativeMethods.CreateAssemblyCache(out IAssemblyCache assemblyCache, 0);
diff --git a/src/Samples/Directory.Build.props b/src/Samples/Directory.Build.props
index f04411fb004..be310dc5e89 100644
--- a/src/Samples/Directory.Build.props
+++ b/src/Samples/Directory.Build.props
@@ -15,7 +15,7 @@
     <ImportDirectoryPackagesProps>false</ImportDirectoryPackagesProps>
 
     <IsShipping>false</IsShipping>
-    <ExcludeFromSourceBuild>true</ExcludeFromSourceBuild>
+    <ExcludeFromSourceOnlyBuild>true</ExcludeFromSourceOnlyBuild>
   </PropertyGroup>
 
 </Project>
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index d2d6108add8..76dd5ee1f2d 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -1065,7 +1065,9 @@ internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem f
         /// </remarks>
         internal static bool IsSolutionFilename(string filename)
         {
-            return HasExtension(filename, ".sln") || HasExtension(filename, ".slnf");
+            return HasExtension(filename, ".sln") ||
+                   HasExtension(filename, ".slnf") ||
+                   HasExtension(filename, ".slnx");
         }
 
         internal static bool IsSolutionFilterFilename(string filename)
@@ -1073,6 +1075,11 @@ internal static bool IsSolutionFilterFilename(string filename)
             return HasExtension(filename, ".slnf");
         }
 
+        internal static bool IsSolutionXFilename(string filename)
+        {
+            return HasExtension(filename, ".slnx");
+        }
+
         /// <summary>
         /// Returns true if the specified filename is a VC++ project file, otherwise returns false
         /// </summary>
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index deaf884e4d5..58e02e85616 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -135,9 +135,7 @@ internal static string ExtractMessageCode(bool msbuildCodeOnly, string message,
         /// <param name="resourceName">Resource string to get the MSBuild F1-keyword for.</param>
         /// <returns>The MSBuild F1-help keyword string.</returns>
         private static string GetHelpKeyword(string resourceName)
-        {
-            return "MSBuild." + resourceName;
-        }
+            => "MSBuild." + resourceName;
 
 #if !BUILDINGAPPXTASKS
         /// <summary>
@@ -146,17 +144,14 @@ private static string GetHelpKeyword(string resourceName)
         /// <param name="resourceName">Resource string name.</param>
         /// <returns>Resource string contents.</returns>
         internal static string GetResourceString(string resourceName)
-        {
-            string result = AssemblyResources.GetString(resourceName);
-            return result;
-        }
+            => AssemblyResources.GetString(resourceName);
 
         /// <summary>
         /// Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
         /// message code and help keyword associated with it, they too are returned.
         ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
-        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
+        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios.
         /// </summary>
         /// <remarks>This method is thread-safe.</remarks>
         /// <param name="code">[out] The MSBuild message code, or null.</param>
@@ -172,6 +167,68 @@ internal static string FormatResourceStringStripCodeAndKeyword(out string code,
             return ExtractMessageCode(true /* msbuildCodeOnly */, FormatString(GetResourceString(resourceName), args), out code);
         }
 
+        // Overloads with 0-3 arguments to avoid array allocations.
+
+        /// <summary>
+        /// Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they too are returned.
+        /// </summary>
+        /// <remarks>This method is thread-safe.</remarks>
+        /// <param name="code">[out] The MSBuild message code, or null.</param>
+        /// <param name="helpKeyword">[out] The MSBuild F1-help keyword for the host IDE, or null.</param>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringStripCodeAndKeyword(out string code, out string helpKeyword, string resourceName)
+        {
+            helpKeyword = GetHelpKeyword(resourceName);
+            return ExtractMessageCode(true, GetResourceString(resourceName), out code);
+        }
+
+        /// <summary>
+        /// Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they too are returned.
+        /// </summary>
+        /// <param name="code">[out] The MSBuild message code, or null.</param>
+        /// <param name="helpKeyword">[out] The MSBuild F1-help keyword for the host IDE, or null.</param>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">Argument for formatting the resource string.</param>
+        internal static string FormatResourceStringStripCodeAndKeyword(out string code, out string helpKeyword, string resourceName, object arg1)
+        {
+            helpKeyword = GetHelpKeyword(resourceName);
+            return ExtractMessageCode(true, FormatString(GetResourceString(resourceName), arg1), out code);
+        }
+
+        /// <summary>
+        /// Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they too are returned.
+        /// </summary>
+        /// <param name="code">[out] The MSBuild message code, or null.</param>
+        /// <param name="helpKeyword">[out] The MSBuild F1-help keyword for the host IDE, or null.</param>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">First argument for formatting the resource string.</param>
+        /// <param name="arg2">Second argument for formatting the resource string.</param>
+        internal static string FormatResourceStringStripCodeAndKeyword(out string code, out string helpKeyword, string resourceName, object arg1, object arg2)
+        {
+            helpKeyword = GetHelpKeyword(resourceName);
+            return ExtractMessageCode(true, FormatString(GetResourceString(resourceName), arg1, arg2), out code);
+        }
+
+        /// <summary>
+        /// Loads the specified string resource and formats it with the arguments passed in. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they too are returned.
+        /// </summary>
+        /// <param name="code">[out] The MSBuild message code, or null.</param>
+        /// <param name="helpKeyword">[out] The MSBuild F1-help keyword for the host IDE, or null.</param>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">First argument for formatting the resource string.</param>
+        /// <param name="arg2">Second argument for formatting the resource string.</param>
+        /// <param name="arg3">Third argument for formatting the resource string.</param>
+        internal static string FormatResourceStringStripCodeAndKeyword(out string code, out string helpKeyword, string resourceName, object arg1, object arg2, object arg3)
+        {
+            helpKeyword = GetHelpKeyword(resourceName);
+            return ExtractMessageCode(true, FormatString(GetResourceString(resourceName), arg1, arg2, arg3), out code);
+        }
+
         [Obsolete("Use GetResourceString instead.", true)]
         [EditorBrowsable(EditorBrowsableState.Never)]
         internal static string FormatResourceString(string resourceName)
@@ -184,32 +241,117 @@ internal static string FormatResourceString(string resourceName)
         /// message code and help keyword associated with it, they are discarded.
         ///
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
-        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
+        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios.
         /// </summary>
         /// <remarks>This method is thread-safe.</remarks>
         /// <param name="resourceName">Resource string to load.</param>
         /// <param name="args">Optional arguments for formatting the resource string.</param>
         /// <returns>The formatted resource string.</returns>
         internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, params object[] args)
-        {
-            string code;
-            string helpKeyword;
+            => FormatResourceStringStripCodeAndKeyword(out _, out _, resourceName, args);
 
-            return FormatResourceStringStripCodeAndKeyword(out code, out helpKeyword, resourceName, args);
-        }
+        // Overloads with 0-3 arguments to avoid array allocations.
+
+        /// <summary>
+        /// Looks up a string in the resources. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they are discarded.
+        /// </summary>
+        /// <remarks>This method is thread-safe.</remarks>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName)
+           => FormatResourceStringStripCodeAndKeyword(out _, out _, resourceName);
+
+        /// <summary>
+        /// Looks up a string in the resources, and formats it with the argument passed in. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they are discarded.
+        /// </summary>
+        /// <remarks>This method is thread-safe.</remarks>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">Argument for formatting the resource string.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, object arg1)
+           => FormatResourceStringStripCodeAndKeyword(out _, out _, resourceName, arg1);
+
+        /// <summary>
+        /// Looks up a string in the resources, and formats it with the arguments passed in. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they are discarded.
+        /// </summary>
+        /// <remarks>This method is thread-safe.</remarks>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">First argument for formatting the resource string.</param>
+        /// <param name="arg2">Second argument for formatting the resource string.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, object arg1, object arg2)
+            => FormatResourceStringStripCodeAndKeyword(out _, out _, resourceName, arg1, arg2);
+
+        /// <summary>
+        /// Looks up a string in the resources, and formats it with the arguments passed in. If the string resource has an MSBuild
+        /// message code and help keyword associated with it, they are discarded.
+        /// </summary>
+        /// <remarks>This method is thread-safe.</remarks>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">First argument for formatting the resource string.</param>
+        /// <param name="arg2">Second argument for formatting the resource string.</param>
+        /// <param name="arg3">Third argument for formatting the resource string.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, object arg1, object arg2, object arg3)
+            => FormatResourceStringStripCodeAndKeyword(out _, out _, resourceName, arg1, arg2, arg3);
 
         /// <summary>
         /// Formats the resource string with the given arguments.
-        /// Ignores error codes and keywords
+        /// Ignores error codes and keywords.
         /// </summary>
-        /// <param name="resourceName"></param>
-        /// <param name="args"></param>
-        /// <returns></returns>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="args">Optional arguments for formatting the resource string.</param>
+        /// <returns>The formatted resource string.</returns>
+        /// <remarks>the AssemblyResources.GetString() method is thread-safe.</remarks>
         internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, params object[] args)
-        {
-            // NOTE: the AssemblyResources.GetString() method is thread-safe
-            return FormatString(GetResourceString(resourceName), args);
-        }
+            => FormatString(GetResourceString(resourceName), args);
+
+        // Overloads with 0-3 arguments to avoid array allocations.
+
+        /// <summary>
+        /// Formats the resource string.
+        /// Ignores error codes and keywords.
+        /// </summary>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName)
+            => GetResourceString(resourceName);
+
+        /// <summary>
+        /// Formats the resource string with the given argument.
+        /// Ignores error codes and keywords.
+        /// </summary>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">Argument for formatting the resource string.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, object arg1)
+            => FormatString(GetResourceString(resourceName), arg1);
+
+        /// <summary>
+        /// Formats the resource string with the given arguments.
+        /// Ignores error codes and keywords.
+        /// </summary>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">First argument for formatting the resource string.</param>
+        /// <param name="arg2">Second argument for formatting the resource string.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, object arg1, object arg2)
+            => FormatString(GetResourceString(resourceName), arg1, arg2);
+
+        /// <summary>
+        /// Formats the resource string with the given arguments.
+        /// Ignores error codes and keywords.
+        /// </summary>
+        /// <param name="resourceName">Resource string to load.</param>
+        /// <param name="arg1">First argument for formatting the resource string.</param>
+        /// <param name="arg2">Second argument for formatting the resource string.</param>
+        /// <param name="arg3">Third argument for formatting the resource string.</param>
+        /// <returns>The formatted resource string.</returns>
+        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, object arg1, object arg2, object arg3)
+            => FormatString(GetResourceString(resourceName), arg1, arg2, arg3);
 
         /// <summary>
         /// Formats the given string using the variable arguments passed in.
@@ -227,33 +369,80 @@ internal static string FormatString(string unformatted, params object[] args)
             string formatted = unformatted;
 
             // NOTE: String.Format() does not allow a null arguments array
-            if ((args?.Length > 0))
+            if (args?.Length > 0)
             {
-#if DEBUG
-                // If you accidentally pass some random type in that can't be converted to a string,
-                // FormatResourceString calls ToString() which returns the full name of the type!
-                foreach (object param in args)
-                {
-                    // Check it has a real implementation of ToString() and the type is not actually System.String
-                    if (param != null)
-                    {
-                        if (string.Equals(param.GetType().ToString(), param.ToString(), StringComparison.Ordinal) &&
-                            param.GetType() != typeof(string))
-                        {
-                            ErrorUtilities.ThrowInternalError("Invalid resource parameter type, was {0}",
-                                param.GetType().FullName);
-                        }
-                    }
-                }
-#endif
+                ValidateArgsIfDebug(args);
+
                 // Format the string, using the variable arguments passed in.
                 // NOTE: all String methods are thread-safe
-                formatted = String.Format(CultureInfo.CurrentCulture, unformatted, args);
+                formatted = string.Format(CultureInfo.CurrentCulture, unformatted, args);
             }
 
             return formatted;
         }
 
+        // Overloads with 1-3 arguments to avoid array allocations.
+
+        /// <summary>
+        /// Formats the given string using the variable arguments passed in.
+        /// </summary>
+        /// <param name="unformatted">The string to format.</param>
+        /// <param name="arg1">Argument for formatting the given string.</param>
+        /// <returns>The formatted string.</returns>
+        internal static string FormatString(string unformatted, object arg1)
+        {
+            ValidateArgsIfDebug([arg1]);
+            return string.Format(CultureInfo.CurrentCulture, unformatted, arg1);
+        }
+
+        /// <summary>
+        /// Formats the given string using the variable arguments passed in.
+        /// </summary>
+        /// <param name="unformatted">The string to format.</param>
+        /// <param name="arg1">First argument for formatting the given string.</param>
+        /// <param name="arg2">Second argument for formatting the given string.</param>
+        /// <returns>The formatted string.</returns>
+        internal static string FormatString(string unformatted, object arg1, object arg2)
+        {
+            ValidateArgsIfDebug([arg1, arg2]);
+            return string.Format(CultureInfo.CurrentCulture, unformatted, arg1, arg2);
+        }
+
+        /// <summary>
+        /// Formats the given string using the variable arguments passed in.
+        /// </summary>
+        /// <param name="unformatted">The string to format.</param>
+        /// <param name="arg1">First argument for formatting the given string.</param>
+        /// <param name="arg2">Second argument for formatting the given string.</param>
+        /// <param name="arg3">Third argument for formatting the given string.</param>
+        /// <returns>The formatted string.</returns>
+        internal static string FormatString(string unformatted, object arg1, object arg2, object arg3)
+        {
+            ValidateArgsIfDebug([arg1, arg2, arg3]);
+            return string.Format(CultureInfo.CurrentCulture, unformatted, arg1, arg2, arg3);
+        }
+
+        [Conditional("DEBUG")]
+        private static void ValidateArgsIfDebug(object[] args)
+        {
+            // If you accidentally pass some random type in that can't be converted to a string,
+            // FormatResourceString calls ToString() which returns the full name of the type!
+            foreach (object param in args)
+            {
+                // Check it has a real implementation of ToString() and the type is not actually System.String
+                if (param != null)
+                {
+                    if (string.Equals(param.GetType().ToString(), param.ToString(), StringComparison.Ordinal) &&
+                        param.GetType() != typeof(string))
+                    {
+                        ErrorUtilities.ThrowInternalError(
+                            "Invalid resource parameter type, was {0}",
+                            param.GetType().FullName);
+                    }
+                }
+            }
+        }
+
         /// <summary>
         /// Verifies that a particular resource string actually exists in the string table. This will only be called in debug
         /// builds. It helps catch situations where a dev calls VerifyThrowXXX with a new resource string, but forgets to add the
diff --git a/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.csproj b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.csproj
index 009b2ad1fe0..fd1808174d6 100644
--- a/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.csproj
+++ b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.csproj
@@ -20,26 +20,24 @@
   </ItemGroup>
 
   <Target Name="AddNuGetDlls" BeforeTargets="_GetPackageFiles">
-    <!-- Merge the collection of PackageReference and Assemblies using the NuGetPackageId key.
-       This produces a new list containing the DLL path and the "IncludeInPackage" metadata-->
+    <!-- Merge the collection of PackageReference and Assemblies using the NuGetPackageId key. This produces a new list containing the DLL path and the "IncludeInPackage" metadata-->
     <JoinItems Left="@(ResolvedCompileFileDefinitions)" LeftKey="NuGetPackageId" LeftMetadata="*" Right="@(PackageReference)" RightKey="" RightMetadata="*" ItemSpecToUse="Left">
-    <Output TaskParameter="JoinResult" ItemName="_PackagesToPack" />
+      <Output TaskParameter="JoinResult" ItemName="_PackagesToPack" />
     </JoinItems>
 
     <ItemGroup>
-    <!-- Remove NETStandard DLLs -->
-    <_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(NuGetPackageId) == 'NETStandard.Library'" />
-    <_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(_PackagesToPack.IncludeInPackage) != 'true'" />
+      <!-- Remove packages, except those with IncludeInPackage=true -->
+      <_PackagesToPack Remove="@(_PackagesToPack)" Condition="'%(_PackagesToPack.IncludeInPackage)' != 'true'" />
     </ItemGroup>
 
     <Message Importance="High" Text="Adding DLLs from the following packages: @(_PackagesToPack->'%(NuGetPackageId)')" />
 
     <ItemGroup>
-    <!-- Update the collection of items to pack with the DLLs from the NuGet packages -->
-    <None Include="@(_PackagesToPack)" Pack="true" PackagePath="build" Visible="false" />
+      <!-- Update the collection of items to pack with the DLLs from the NuGet packages -->
+      <None Include="@(_PackagesToPack)" Pack="true" PackagePath="build" Visible="false" />
 
-    <!-- Add the DLL produced by the current project to the NuGet package -->
-    <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="build" Visible="false" />
+      <!-- Add the DLL produced by the current project to the NuGet package -->
+      <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="build" Visible="false" />
     </ItemGroup>
   </Target>
 </Project>
