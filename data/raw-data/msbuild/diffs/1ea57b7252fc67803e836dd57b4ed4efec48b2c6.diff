diff --git a/.config/1espt/PipelineAutobaseliningConfig.yml b/.config/1espt/PipelineAutobaseliningConfig.yml
index 1901db1b137..e2d487e929a 100644
--- a/.config/1espt/PipelineAutobaseliningConfig.yml
+++ b/.config/1espt/PipelineAutobaseliningConfig.yml
@@ -12,6 +12,8 @@ pipelines:
           lastModifiedDate: 2024-03-14
         armory:
           lastModifiedDate: 2024-03-14
+        policheck:
+          lastModifiedDate: 2024-10-09
       binary:
         credscan:
           lastModifiedDate: 2024-03-14
diff --git a/.config/git-merge-flow-config.jsonc b/.config/git-merge-flow-config.jsonc
index a58d3e867ea..a6c94f2ea83 100644
--- a/.config/git-merge-flow-config.jsonc
+++ b/.config/git-merge-flow-config.jsonc
@@ -26,8 +26,12 @@
         "vs17.10": {
             "MergeToBranch": "vs17.11"
         },
-        // MSBuild latest release to main
+        // Automate opening PRs to merge msbuild's vs17.11 (SDK 8.0.4xx) into vs17.12 (SDK 9.0.1xx)
         "vs17.11": {
+            "MergeToBranch": "vs17.12"
+        },
+        // MSBuild latest release to main
+        "vs17.12": {
             "MergeToBranch": "main"
         }
     }
diff --git a/.config/tsaoptions.json b/.config/tsaoptions.json
new file mode 100644
index 00000000000..4069463a23e
--- /dev/null
+++ b/.config/tsaoptions.json
@@ -0,0 +1,10 @@
+{
+    "instanceUrl": "https://devdiv.visualstudio.com/",
+    "template": "TFSDEVDIV",
+    "projectName": "DEVDIV",
+    "areaPath": "DevDiv\\NET Tools\\MSBuild",
+    "iterationPath": "DevDiv",
+    "notificationAliases": [ "msbtm@microsoft.com" ],
+    "repositoryName": "MSBuild",
+    "codebaseName": "MSBuild"
+}
\ No newline at end of file
diff --git a/.editorconfig b/.editorconfig
index 76f52d190e5..1ff2a060cb0 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -426,11 +426,23 @@ dotnet_diagnostic.IDE0073.severity = error
 # Use 'System.Threading.Lock'
 dotnet_diagnostic.IDE0330.severity = suggestion
 
+# Value types are incompatible with null values. https://xunit.net/xunit.analyzers/rules/xUnit1012
+dotnet_diagnostic.xUnit1012.severity = warning
 
-# xunit to supress temp
-dotnet_diagnostic.xUnit2020.severity = none
+# Use Assert.Fail() instead of Assert.True(false) or Assert.False(true)
+dotnet_diagnostic.xUnit2020.severity = warning
+
+# Use Assert.DoesNotContain instead of Assert.Empty on filtered collections
+dotnet_diagnostic.xUnit2029.severity = warning
+
+# Do not use blocking task operations in test method. https://xunit.net/xunit.analyzers/rules/xUnit1031
+# The parallelization is disabled in https://github.com/dotnet/msbuild/blob/371d00f5c10a15b0858c411aafa11aac74596b06/src/Shared/UnitTests/xunit.runner.json#L6-L7
+# Issue to consider enabling parallelization: https://github.com/dotnet/msbuild/issues/10640
 dotnet_diagnostic.xUnit1031.severity = none
-dotnet_diagnostic.xUnit1012.severity = none
-dotnet_diagnostic.xUnit2029.severity = none
-# Do not use equality check to check for collection size.
+
+# Do not use equality check to check for collection size. https://xunit.net/xunit.analyzers/rules/xUnit2013
+# To fix the warning for empty collection we can use Assert.Empty() instead of Assert.Equal(0, collection.Count)
+# However to fix the warning for collections with 1 elements we should use Assert.Single() instead of Assert.Equal(1, collection.Count)
+# The latter brings incosistency in the codebase and some times in one test case.
+# So we are disabling this rule with respect to the above mentioned reasons.
 dotnet_diagnostic.xUnit2013.severity = none
\ No newline at end of file
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 568f2af4ae9..1cb66face7d 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -34,7 +34,7 @@ variables:
     - name: SourceBranch
       value: ''
   - name: EnableReleaseOneLocBuild
-    value: true # Enable loc for vs17.12
+    value: true # Enable loc for vs17.13
   - name: Codeql.Enabled
     value: true
   - group: DotNet-MSBuild-SDLValidation-Params
@@ -54,6 +54,10 @@ extends:
       name: VSEngSS-MicroBuild2022-1ES
       os: windows
     sdl:
+      policheck:
+        enabled: true
+      tsa:
+        enabled: true
       # We generate SBOM ourselves, so don't need steps injected by 1ES.
       sbom:
         enabled: false
diff --git a/Directory.Build.props b/Directory.Build.props
index f27847923f1..b0454aa3564 100644
--- a/Directory.Build.props
+++ b/Directory.Build.props
@@ -28,7 +28,7 @@
      <!-- When building in source-only modes, let the TFM float based on what arcade is in use.
           When building in normal modes (independent build or a dotnet product build), set explicitly. -->
     <LatestDotNetCoreForMSBuild>net9.0</LatestDotNetCoreForMSBuild>
-    <LatestDotNetCoreForMSBuild Condition="'$(DotNetBuildFromSource)' == 'true' or '$(DotNetBuildSourceOnly)' == 'true'">$(NetCurrent)</LatestDotNetCoreForMSBuild>
+    <LatestDotNetCoreForMSBuild Condition="'$(DotNetBuildSourceOnly)' == 'true'">$(NetCurrent)</LatestDotNetCoreForMSBuild>
   </PropertyGroup>
 
   <PropertyGroup>
diff --git a/Directory.Build.targets b/Directory.Build.targets
index b57a232300f..ff75cf4ad68 100644
--- a/Directory.Build.targets
+++ b/Directory.Build.targets
@@ -37,4 +37,30 @@
     <RemoveDir Directories="$(_PackageFolderInGlobalPackages)"
                Condition="Exists('$(_PackageFolderInGlobalPackages)')" />
   </Target>
+
+  <!-- BEGIN workaround for https://github.com/dotnet/sdk/issues/43339; remove after updated to VS 17.12 or a future 17.11 patch -->
+  <Target Name="WorkaroundDotnetSdk43339" BeforeTargets="ResolvePackageAssets" Condition=" '$(MSBuildRuntimeType)' == 'Full' and $([MSBuild]::VersionLessThan($(MSBuildVersion), 17.12.0))">
+    <PrimeSystemTextJson804 />
+  </Target>
+  <UsingTask
+    TaskName="PrimeSystemTextJson804"
+    TaskFactory="RoslynCodeTaskFactory"
+    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll" >
+    <Task>
+      <Code Type="Fragment" Language="cs">
+<![CDATA[
+try
+{
+    System.Reflection.Assembly.LoadFrom(@"$(MicrosoftNETBuildTasksDirectoryRoot)\..\..\..\DotnetTools\dotnet-format\BuildHost-net472\System.Text.Json.dll");
+}
+catch
+{
+    // Best effort: if something moves in the SDK don't break the build.
+}
+]]>
+      </Code>
+    </Task>
+  </UsingTask>
+  <!-- END workaround for https://github.com/dotnet/sdk/issues/43339 -->
+
 </Project>
diff --git a/NuGet.config b/NuGet.config
index bd10a6979cf..659ab421680 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -18,7 +18,7 @@
     <add key="dotnet8" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json" />
     <add key="dotnet8-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json" />
     <add key="dotnet9" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet9/nuget/v3/index.json" />
-    <add key="BuildXL" value="https://pkgs.dev.azure.com/ms/BuildXL/_packaging/BuildXL/nuget/v3/index.json" />
+    <add key="msbuild17.12" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/darc-pub-DotNet-msbuild-Trusted-95c7bf01-1/nuget/v3/index.json" />
   </packageSources>
   <disabledPackageSources>
     <!--Begin: Package sources managed by Dependency Flow automation. Do not edit the sources below.-->
@@ -31,4 +31,8 @@
     <!--  End: Package sources from dotnet-runtime -->
     <!--End: Package sources managed by Dependency Flow automation. Do not edit the sources above.-->
   </disabledPackageSources>
+  <auditSources>
+    <clear />
+    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
+  </auditSources>
 </configuration>
diff --git a/branding/MSBuild-Icon.png b/branding/MSBuild-Icon.png
index cafd831d2ad..d769a8aa1d4 100644
Binary files a/branding/MSBuild-Icon.png and b/branding/MSBuild-Icon.png differ
diff --git a/branding/MSBuild-Logo.png b/branding/MSBuild-Logo.png
index 7309f7bcabf..db9a1a45003 100644
Binary files a/branding/MSBuild-Logo.png and b/branding/MSBuild-Logo.png differ
diff --git a/branding/MSBuild-NuGet-Icon.png b/branding/MSBuild-NuGet-Icon.png
index d51ddc13cd8..b502fda8f5d 100644
Binary files a/branding/MSBuild-NuGet-Icon.png and b/branding/MSBuild-NuGet-Icon.png differ
diff --git a/branding/README.md b/branding/README.md
index 0758e104c37..0f63eb314e4 100644
--- a/branding/README.md
+++ b/branding/README.md
@@ -9,8 +9,8 @@ This image is the original graphic used for creating the MSBuild icon.  It was p
 This image is an original graphic created by Immo Landwerth.  It can be used for images where the size is required to be larger than the MSBuild-Icon.png.
 
 ## MSBuild-NuGet-Icon.png ![MSBuild-NuGet-Icon.png](MSBuild-NuGet-Icon.png?raw=true)
-This image is used by the NuGet packages as the ``<iconUrl />``.  Its raw location in this repo is used by the forwarding link [https://go.microsoft.com/fwlink/?linkid=825694](https://go.microsoft.com/fwlink/?linkid=825694).  If it is moved, please update the link.
+This image is used by the NuGet packages as the ``<iconUrl />``.  Its raw location in this repo is used by the forwarding link [https://aka.ms/msbuildicon](https://aka.ms/msbuildicon).  If it is moved, please update the link.
 
 If the below image loads, then the forwarding link is working.
 
-![MSBuild-NuGet-Icon from the forwarding link](https://go.microsoft.com/fwlink/?linkid=825694)
\ No newline at end of file
+![MSBuild-NuGet-Icon from the forwarding link](https://aka.ms/msbuildicon)
\ No newline at end of file
diff --git a/documentation/Deploy-MSBuild.md b/documentation/Deploy-MSBuild.md
index db8d3b53f65..541a87c11c8 100644
--- a/documentation/Deploy-MSBuild.md
+++ b/documentation/Deploy-MSBuild.md
@@ -5,7 +5,7 @@
 [Deploy-MSBuild](https://github.com/dotnet/msbuild/blob/deploy-msbuild/scripts/Deploy-MSBuild.ps1) is a way to conveniently take private bits and install them into Visual Studio (VS) for testing. To use it:
 
 - If you haven't already, clone [MSBuild](https://github.com/dotnet/msbuild) and make the changes you want.
-- Build MSBuild with the changes you want using `build.cmd /p:CreateBootstrap=true`.
+- Build MSBuild with the changes you want using `build.cmd`.
 - In an administrator powershell window, navigate to the msbuild folder.
 - Run `scripts\Deploy-MSBuild.ps1 -destination {destination} -configuration {configuration}`.
   - Specify the Bin folder of MSBuild in your VS install as the destination. This is somewhere like `"C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin"`.
diff --git a/documentation/release-checklist.md b/documentation/release-checklist.md
index 9d86581f0b5..1e5ab0b3f87 100644
--- a/documentation/release-checklist.md
+++ b/documentation/release-checklist.md
@@ -12,11 +12,23 @@
 - [ ]  Ping internal "First Responders" Teams channel to get the new channel made available as a promotion target (e.g. dotnet/arcade#12150): {{URL_OF_CHANNEL_PROMOTION_PR}}
 
 ## At release time
-
+Before starting the process:
 - [ ] If the release is being cut more than a few days before the VS-side snap, do these two steps. Otherwise check them off.
   - [ ]  Modify the VS insertion so that it flows from MSBuild `vs{{THIS_RELEASE_VERSION}}` to VS `main` [in the MSBuild-release-branch release definition](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=1319&view=mine&_a=releases). Alternatively, if the release being cut no more than couple of weeks, disable the scheduled releases and create releases from `vs{{THIS_RELEASE_VERSION}}` manually until the VS-side snap: Edit -> Schedule set under Artifacts -> disable toggle
 AND
   - [ ]  Disable automated run of [the MSBuild-main-branch release definition](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=2153&view=mine&_a=releases) (because our {{NEXT_VERSION}} builds don't have a place to go in VS yet)
+
+### Branching from main
+- [ ]  If the new version's branch was created before the Visual Studio fork: fast-forward merge the correct commit (the one that is currently inserted to VS main) to the `vs{{THIS_RELEASE_VERSION}}` branch \
+e.g.: `git push upstream 2e6f2ff7ea311214255b6b2ca5cc0554fba1b345:refs/heads/vs17.10` \
+_(This is for the case where we create the branch too early and want it to be based actually on a different commit. If you waited until a good point in time with `main` in a clean state, just branch off and you are done. The branch should point to a good, recent spot, so the final-branding PR goes in on top of the right set of commits.)_
+- [ ]  Update the branch merge flow in `.config/git-merge-flow-config.jsonc` file to have the currently-in-servicing branches.
+- [ ]  Create {{NEXT_VERSION}} branding PR (in main) including public API baseline package version change: {{URL_OF_NEXT_VERSION_BRANDING_PR}}. 
+  - In the file `eng/Versions.props` Update the `VersionPrefix` to `{{NEXT_VERSION}}` and `PackageValidationBaselineVersion` set to a latest internally available {{THIS_RELEASE_VERSION}} preview version in the [internal dnceng dotnet-tools feed](https://dev.azure.com/dnceng/internal/_artifacts/feed/dotnet-tools-internal). It might be needed to update `CompatibilitySuppressions.xml` files. See [this documentation](https://learn.microsoft.com/en-us/dotnet/fundamentals/apicompat/overview) for more details. You can update `CompatibilitySuppressions.xml` files by running
+`dotnet pack MSBuild.Dev.slnf /p:ApiCompatGenerateSuppressionFile=true`. 
+- [ ]  Merge {{NEXT_VERSION}} branding PR
+
+### Adjust DARC channels and subscriptions
 - [ ]  Remove the `main` to old release channel ({{THIS_RELEASE_VERSION}}) default channel \
 `darc delete-default-channel --repo https://github.com/dotnet/msbuild --branch main --channel "VS {{THIS_RELEASE_VERSION}}"`
 - [ ]  Associate the `main` branch with the next release channel \
@@ -28,24 +40,36 @@ AND
 - [ ]  Ensure that the current release channel `VS {{THIS_RELEASE_VERSION}}` is associated with the correct release branch\
 `darc get-default-channels --source-repo https://github.com/dotnet/msbuild --branch vs{{THIS_RELEASE_VERSION}}` \
 if it is not, `darc add-default-channel  --channel "VS {{THIS_RELEASE_VERSION}}" --branch vs{{THIS_RELEASE_VERSION}} --repo https://github.com/dotnet/msbuild`
-- [ ]  If the branch was created before the fork: fast-forward merge the correct commit (the one that is currently inserted to VS main) to the `vs{{THIS_RELEASE_VERSION}}` branch \
-e.g.: `git push upstream 2e6f2ff7ea311214255b6b2ca5cc0554fba1b345:refs/heads/vs17.10` \
-_(This is for the case where we create the branch too early and want it to be based actually on a different commit. If you waited until a good point in time with `main` in a clean state, just branch off and you are done. The branch should point to a good, recent spot, so the final-branding PR goes in on top of the right set of commits.)_
-- [ ]  Update the branch merge flow in `.config/git-merge-flow-config.jsonc` file to have the currently-in-servicing branches.
+- [ ] Double check subscriptions from our repo `darc get-subscriptions --target-repo dotnet/msbuild` and update subscriptions to `VS{{THIS_RELEASE_VERSION}}` and `main` branches according to [supported versions of VS and SDK](https://learn.microsoft.com/en-us/dotnet/core/porting/versioning-sdk-msbuild-vs#supported-net-versions):
+  - [ ] NuGet client
+    - Based on VS version channel
+    - `darc get-subscriptions --exact --target-repo https://github.com/dotnet/msbuild --source-repo https://github.com/nuget/nuget.client`
+  - [ ] Source Build Packages
+    - Based on .NET version channel
+    - `darc get-subscriptions --exact --target-repo https://github.com/dotnet/msbuild --source-repo https://github.com/dotnet/source-build-reference-packages`
+  - [ ] Roslyn:
+    - Based on VS version channel
+    - `darc get-subscriptions --exact --target-repo https://github.com/dotnet/msbuild --source-repo https://github.com/dotnet/roslyn`
+  - [ ] Arcade:
+    - Based on .NET version channel--does not change every MSBuild release
+    - `darc get-subscriptions --exact --target-repo https://github.com/dotnet/msbuild --source-repo https://github.com/dotnet/arcade`
+
+### Adjust pipelines / releases
 - [ ]  Fix OptProf data flow for the new vs{{THIS_RELEASE_VERSION}} branch
   - [ ] Run the [official build](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434) for vs{{THIS_RELEASE_VERSION}} without OptProf (set `SkipApplyOptimizationData` variable in 'Advanced options' section of the 'Run pipeline' menu to `true`) or alternatively with the latest Opt-Prof collected for the main branch (set `Optional OptProfDrop Override` to the drop path of the collected data, which could be found in the logs of the pipeline: Windows_NT -> Build -> search for `OptimizationData`). 
   - [ ] Check that the [OptProf data collection](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=17389) pipeline run is triggered for vs{{THIS_RELEASE_VERSION}}. If not, run manually ('Run pipeline' in upper right)
   - [ ] Run the [official build](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434) for vs{{THIS_RELEASE_VERSION}} with no extra customization - OptProf should succeed now
-- [ ]  Create {{NEXT_VERSION}} branding PR (in main) including public API baseline package version change: {{URL_OF_NEXT_VERSION_BRANDING_PR}}. In the file `eng/Versions.props` Update the `VersionPrefix` to `{{NEXT_VERSION}}` and `PackageValidationBaselineVersion` set to a latest internally available {{THIS_RELEASE_VERSION}} preview version in the internal dnceng dotnet-tools feed. It might be needed to update `CompatibilitySuppressions.xml` files. See [this documentation](https://learn.microsoft.com/en-us/dotnet/fundamentals/apicompat/overview) for more details. You can update `CompatibilitySuppressions.xml` files by running
-`dotnet pack MSBuild.Dev.slnf /p:ApiCompatGenerateSuppressionFile=true`. 
+- [ ]  When VS main snaps to {{THIS_RELEASE_VERSION}} and updates its version to {{NEXT_VERSION}}, turn on / modify the VS insertion so that it flows from MSBuild main to VS main.
+  - [ ]  Update the [release-branch insertion release definition](https://dev.azure.com/devdiv/DevDiv/_releaseDefinition?definitionId=2153&_a=definition-variables) to have `InsertTargetBranch` `rel/d{{THIS_RELEASE_VERSION}}`.
+- [ ]  Turn [the release pipeline](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=2153&view=mine&_a=releases) back on.
+
+### Configure localization
 - [ ]  Create {{THIS_RELEASE_VERSION}} localization ticket: https://aka.ms/ceChangeLocConfig (requesting to switch localization from {{PREVIOUS_RELEASE_VERSION}} to {{THIS_RELEASE_VERSION}}): {{URL_OF_LOCALIZATION_TICKET}}
 - [ ]  Enable {{THIS_RELEASE_VERSION}} localization - by setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/vs{{THIS_RELEASE_VERSION}}/.vsts-dotnet.yml) to `true`
 - [ ]  Disable {{PREVIOUS_RELEASE_VERSION}} localization -  by setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/vs{{PREVIOUS_RELEASE_VERSION}}/.vsts-dotnet.yml) to `false`. Update the comment on the same line.
-- [ ]  Merge {{NEXT_VERSION}} branding PR
 - [ ]  Create and merge a PR in main to update a localization version comment in setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/main/.vsts-dotnet.yml) to set up the merge conflict when this line will be updated in the release branch.
-- [ ]  When VS main snaps to {{THIS_RELEASE_VERSION}} and updates its version to {{NEXT_VERSION}}, turn on / modify the VS insertion so that it flows from MSBuild main to VS main.
-- [ ]  Update the [release-branch insertion release definition](https://dev.azure.com/devdiv/DevDiv/_releaseDefinition?definitionId=2153&_a=definition-variables) to have `InsertTargetBranch` `rel/d{{THIS_RELEASE_VERSION}}`.
-- [ ]  Turn [the release pipeline](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=2153&view=mine&_a=releases) back on.
+
+### Final branding
 - [ ]  Prepare final branding PR for `vs{{THIS_RELEASE_VERSION}}`: {{URL_OF_FINAL_BRANDING_PR}}
 - [ ]  Merge final branding to `vs{{THIS_RELEASE_VERSION}}` branch
 - [ ]  Update perfstar MSBuild insertions configuration: [example PR](https://dev.azure.com/devdiv/DevDiv/_git/dotnet-perfstar/pullrequest/522843): {{URL_OF_PERFSTAR_PR}}
@@ -60,6 +84,18 @@ _(This is for the case where we create the branch too early and want it to be ba
 Timing based on the [(Microsoft-internal) release schedule](https://dev.azure.com/devdiv/DevDiv/_wiki/wikis/DevDiv.wiki/10097/Dev17-Release).
 
 - [ ]  Push packages to nuget.org (not currently automated, contact dnceng - search "Publish MSBuild 17.6 to NuGet.org" email subject for template).
+
+  Following packages should be published (`THIS_RELEASE_EXACT_VERSION` is equal to `VersionPrefix` that comes form the eng\Version.props, that were part of the build we are trying to get published):
+    - Microsoft.Build.Utilities.Core.{{THIS_RELEASE_EXACT_VERSION}}.nupkg
+    - Microsoft.Build.{{THIS_RELEASE_EXACT_VERSION}}.nupkg
+    - Microsoft.Build.Framework.{{THIS_RELEASE_EXACT_VERSION}}.nupkg
+    - Microsoft.Build.Runtime.{{THIS_RELEASE_EXACT_VERSION}}.nupkg
+    - Microsoft.Build.Tasks.Core.{{THIS_RELEASE_EXACT_VERSION}}.nupkg
+    - Microsoft.NET.StringTools.{{THIS_RELEASE_EXACT_VERSION}}.nupkg
+    - Microsoft.Build.Templates.{{THIS_RELEASE_EXACT_VERSION}}.nupkg
+     
+  **Note:** Microsoft.Build.Conversion.Core and Microsoft.Build.Engine are **not** part of the list. Microsoft.Build.Templates **is** part of the list. Those 3 packages are a difference to the historic publishing list.
+
 - [ ]  Publish docs: submit reference request at https://aka.ms/publishondocs
   - Click on the link labeled *Request – Reference Publishing*
   - You can use existing [ticket](https://dev.azure.com/msft-skilling/Content/_workitems/edit/183613) as a reference
diff --git a/documentation/specs/BuildCheck/BuildCheck-Architecture.md b/documentation/specs/BuildCheck/BuildCheck-Architecture.md
index 87c6a30b30e..2d111ac77fa 100644
--- a/documentation/specs/BuildCheck/BuildCheck-Architecture.md
+++ b/documentation/specs/BuildCheck/BuildCheck-Architecture.md
@@ -106,7 +106,7 @@ How we'll internally handle the distributed model:
 Planned model:
 * Checks factories get registered with the BuildCheck infrastructure (`BuildCheckManager`)
     * For inbox checks - this happens on startup.
-    * For custom checks - this happens on connecting `ILogger` instance in scheduler node receives acquistion event (`BuildCheckAcquisitionEventArgs`). This event is being sent by worker node as soon as it hits a special marker (a magic property function call) during early evaluation. Loading is not processed by worker node as currently we want custom checks only in the main node (as they will be only given data proxied from BuildEventArgs).
+    * For custom checks - this happens on connecting `ILogger` instance in scheduler node receives acquistion event (`BuildCheckAcquisitionEventArgs`). This event is being sent by worker node as soon as it hits a special marker (a magic property function call) during early evaluation. Loading is not processed by worker node as currently we want custom checks only in the main node (as they will be only given data proxied from BuildEventArgs). Loading in worker node in Evaluation context would result in double work as the custom Check needs to be loaded in the main node anyways.
     The `BuildCheckAcquisitionEventArgs` should be sent prior `ProjectEvaluationStartedEventArgs` (buffering will need to take place), or main node will need to replay some initial data after custom check is registered.
 * `BuildCheckManager` receives info about new project starting to be build
     * On scheduler node the information is sourced from `ProjectEvaluationStartedEventArgs`
@@ -136,6 +136,8 @@ Since we are unlikely to enable any checks by default in .NET 9, the focus in th
 
 # Acquisition
 
+(For details on internals of processing acquisition by the infrastructure see [Check Lifecycle](#check-lifecycle))
+
 BuildCheck employs two distinct types of checks: inbox and custom. As a result, the acquisition and distribution processes vary.
 Inbox rules are integrated into the MSBuild repository, while custom checks can be packaged as NuGet packages and detected by MSBuild provided they adhere to a specific structure. 
 
diff --git a/documentation/specs/BuildCheck/BuildCheck.md b/documentation/specs/BuildCheck/BuildCheck.md
index c2f6e0e8864..58442360521 100644
--- a/documentation/specs/BuildCheck/BuildCheck.md
+++ b/documentation/specs/BuildCheck/BuildCheck.md
@@ -166,7 +166,7 @@ For the `.editorconfig` file configuration, following will apply:
 build_check.BC0101.severity=warning
 
 build_check.COND0543.severity=none
-build_check.COND0543.scope=project
+build_check.COND0543.scope=project_file
 build_check.COND0543.custom_switch=QWERTY
 ```
 
diff --git a/documentation/specs/BuildCheck/Codes.md b/documentation/specs/BuildCheck/Codes.md
index 1af3e371ae1..f52c4f47317 100644
--- a/documentation/specs/BuildCheck/Codes.md
+++ b/documentation/specs/BuildCheck/Codes.md
@@ -9,7 +9,7 @@ Report codes are chosen to conform to suggested guidelines. Those guidelines are
 | [BC0103](#bc0103---used-environment-variable) | Suggestion | Used environment variable. |
 | [BC0201](#bc0201---usage-of-undefined-property) | Warning | Usage of undefined property. |
 | [BC0202](#bc0202---property-first-declared-after-it-was-used) | Warning | Property first declared after it was used. |
-| [BC0203](#bc0203----property-declared-but-never-used) | None | Property declared but never used. |
+| [BC0203](#bc0203----property-declared-but-never-used) | Suggestion | Property declared but never used. |
 
 
 To enable verbose logging in order to troubleshoot issue(s), enable [binary logging](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Binary-Log.md#msbuild-binary-log-overview)
@@ -91,7 +91,12 @@ If `BC0202` and [BC0201](#BC0201) are both enabled - then `BC0201` reports only
 
 This check indicates that a property was defined in the observed scope (by default it's the project file only) and it was then not used anywhere in the build.
 
-This is a runtime check, not a static analysis check - so it can have false positives (as property not used in particular build might be needed in a build with different conditions). For this reasons it's currently only suggestion.
+This is a runtime check, not a static analysis check - so it can have false positives - for this reasons it's currently only suggestion.
+
+Common cases of false positives:
+ * Property not used in a particular build might be needed in a build with different conditions or a build of a different target (e.g. `dotnet pack /check` or `dotnet build /t:pack /check` accesses some additional properties as compared to ordinary `dotnet build /check`).
+ * Property accessing is tracked for each project build request. There might be multiple distinct build requests for a project in a single build. Specific case of this is a call to the [MSBuild task](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) or [CallTarget task](https://learn.microsoft.com/en-us/visualstudio/msbuild/calltarget-task) that can request a result from a project build, while passing additional or different global properties and/or calling specific target. This happens often as part of common targets - e.g. for [multi-targeted project build parallelization](../../High-level-overview.md#parallelism)
+ * Incremental build might skip execution of some targets, that might have been accessing properties of interest.
 
 <BR/>
 <BR/>
diff --git a/documentation/specs/BuildCheck/interactive-package-references.md b/documentation/specs/proposed/interactive-package-references.md
similarity index 100%
rename from documentation/specs/BuildCheck/interactive-package-references.md
rename to documentation/specs/proposed/interactive-package-references.md
diff --git a/documentation/specs/BuildCheck/packagessourcing-control-flow.jpg b/documentation/specs/proposed/packagessourcing-control-flow.jpg
similarity index 100%
rename from documentation/specs/BuildCheck/packagessourcing-control-flow.jpg
rename to documentation/specs/proposed/packagessourcing-control-flow.jpg
diff --git a/documentation/specs/BuildCheck/security-metadata.md b/documentation/specs/proposed/security-metadata.md
similarity index 100%
rename from documentation/specs/BuildCheck/security-metadata.md
rename to documentation/specs/proposed/security-metadata.md
diff --git a/documentation/specs/BuildCheck/sourcing-vs-context.png b/documentation/specs/proposed/sourcing-vs-context.png
similarity index 100%
rename from documentation/specs/BuildCheck/sourcing-vs-context.png
rename to documentation/specs/proposed/sourcing-vs-context.png
diff --git a/documentation/wiki/Adding-Events.md b/documentation/wiki/Adding-Events.md
new file mode 100644
index 00000000000..708c0ba101d
--- /dev/null
+++ b/documentation/wiki/Adding-Events.md
@@ -0,0 +1,54 @@
+# Adding Custom Events to MSBuild
+
+MSBuild has many built-in event types, but often you may need to add a new custom one. 
+
+## Steps for Binary Logger Compatibility
+This guide outlines the steps to ensure the BinaryLogger can work with your new event.
+
+### Changes in MSBuild
+
+1. **Add the `NewEventArgs` to `src/Framework` folder**
+2. **Update [BinaryLogRecordKind.cs](../../src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs)**
+   - Append the new event to the enum
+3. **Modify [BinaryLogger.cs](../../src/Build/Logging/BinaryLogger/BinaryLogger.cs)**
+   - Update `FileFormatVersion`
+4. **Update [BuildEventArgsReader.cs](../../src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs)**
+   - Add a new case in the `ReadBuildEventArgs` switch
+   - Implement a method for the added event (imitate other `ReadXYZEventArgs` methods)
+5. **Modify [BuildEventArgsWriter.cs](../../src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs)**
+   - Add a new case in `WriteCore`
+   - Document the change above the method
+6. **Update [LogMessagePacketBase.cs](../../src/Shared/LogMessagePacketBase.cs)**
+   - Add to `LoggingEventType`
+   - Add case in `GetBuildEventArgFromId` and `GetLoggingEventId`
+7. **Create a new test file**
+   - Add `Framework.UnitTests/NewEventArgs_Tests.cs`
+   - Use [BuildSubmissionStartedEventArgs_Tests.cs](../../src/Framework.UnitTests/BuildSubmissionStartedEventArgs_Tests.cs) as a reference
+8. **Update [NodePackets_Tests.cs](../../src/Build.UnitTests/BackEnd/NodePackets_Tests.cs)**
+   - Add relevant test cases
+
+### Changes in [MSBuildStructuredLog](https://github.com/KirillOsenkov/MSBuildStructuredLog)
+
+1. **Update [BinaryLogRecordKind.cs](https://github.com/KirillOsenkov/MSBuildStructuredLog/blob/master/src/StructuredLogger/BinaryLogger/BinaryLogRecordKind.cs)**
+   - Append the new event to the enum
+
+2. **Modify [BinaryLogger.cs](https://github.com/KirillOsenkov/MSBuildStructuredLog/blob/master/src/StructuredLogger/BinaryLogger/BinaryLogger.cs)**
+   - Increment version
+   - Document the change
+
+3. **Create `src/StructuredLogger/BinaryLogger/XXXEventArgs.cs`**
+   - Implement the class for the new event (copy from MSBuild)
+
+4. **Update [BuildEventArgsReader.cs](https://github.com/KirillOsenkov/MSBuildStructuredLog/blob/master/src/StructuredLogger/BinaryLogger/BuildEventArgsReader.cs)**
+   - Add a new case in `ReadBuildEventArgs`
+
+5. **Modify [BuildEventArgsWriter.cs](https://github.com/KirillOsenkov/MSBuildStructuredLog/blob/master/src/StructuredLogger/BinaryLogger/BuildEventArgsWriter.cs)**
+   - Add a new case in `WriteCore`
+
+### Example Pull Requests adding and serializing events
+
+1. [Add Buildcheck events support + BuildSubmissionStarted](https://github.com/KirillOsenkov/MSBuildStructuredLog/pull/797) (MSBuildStructuredLog)
+   - Corresponding [MSBuild PR](https://github.com/dotnet/msbuild/pull/10424)
+
+2. [Add Binary Logger Support for BuildCanceled](https://github.com/dotnet/msbuild/pull/10755) (MSBuild)
+   - Corresponding [MSBuildStructuredLog PR](https://github.com/KirillOsenkov/MSBuildStructuredLog/pull/824)
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
index 6410b01cb11..bb95bf7dcc7 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
@@ -44,10 +44,8 @@ Set the environment variable `MSBUILDDEBUGONSTART` to `2`, then attach a debugge
 
 ## Using the repository binaries to perform builds
 
-To build projects using the MSBuild binaries from the repository, you first need to do a build (command: `build.cmd`) which produces a bootstrap directory mimicking a Visual Studio (full framework flavor) or dotnet CLI (.net core flavor) installation.
+To build projects using the MSBuild binaries from the repository, you first need to execute the build command (`build.cmd`). This generates a bootstrap directory that emulates either a Visual Studio environment (full framework version) in the `net472` folder or a .NET Core environment in the `core` folder.
 
-Now, just point `dotnet ./artifacts/bin/bootstrap/<TARGET_FRAMEWORK>/MSBuild/MSBuild.dll` at a project file. (Change <TARGET_FRAMEWORK> to current target framework, for example net7.0, net8.0) 
-
-Alternatively, if you want to test the msbuild binaries in a more realistic environment, you can overwrite the dotnet CLI msbuild binaries (found under a path like `~/dotnet/sdk/3.0.100-alpha1-009428/`) with the just-built MSBuild . You might have to kill existing `dotnet` processes before doing this. You can use [`Deploy-MSBuild.ps1 -runtime Core`](../Deploy-MSBuild.md#.NET-(Core)-SDK) to do the copy. Then, (using the previous dotnet example directory) just point `~/dotnet/dotnet build` at a project file.
+Next, navigate to the `core` folder and run the dotnet executable from this location using the following syntax: `artifacts/bin/bootstrap/core/dotnet.exe <Command> <Project File>`. Replace `<Command>` with any valid dotnet command (such as `build`, `restore`, `test`, etc.) and `<Project File>` with the path to your project file.
 
 See other debugging options [here](./Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md#Debugging-MSBuild).
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 5a3d6067090..09e7ca1394c 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -29,6 +29,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Fix oversharing of build results in ResultsCache](https://github.com/dotnet/msbuild/pull/9987)
 - [Add ParameterName and PropertyName to TaskParameterEventArgs](https://github.com/dotnet/msbuild/pull/10130)
 - [Emit eval props if requested by any sink](https://github.com/dotnet/msbuild/pull/10243)
+- [Load Microsoft.DotNet.MSBuildSdkResolver into default load context (MSBuild.exe only)](https://github.com/dotnet/msbuild/pull/10603)
 
 ### 17.10
 - [AppDomain configuration is serialized without using BinFmt](https://github.com/dotnet/msbuild/pull/9320) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`. **Please note that [any usage of BinaryFormatter is insecure](https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide).**
diff --git a/documentation/wiki/Tasks.md b/documentation/wiki/Tasks.md
index 14b09953225..76bd3f9bb14 100644
--- a/documentation/wiki/Tasks.md
+++ b/documentation/wiki/Tasks.md
@@ -27,7 +27,7 @@ This uses the AssemblyTaskFactory to load the task from the .dll and create an i
 ```mermaid
 graph 
 
-I["Implement:\n extend ITask interface in .dll"] --> R["Register:\n &lt; UsingTask/&gt;"] --> U["Use in XML:\n &lt Target&gt &lt MyTask/&gt &lt Target/&gt"] --> In["Initialize:\n compile inline or load from assembly \n(TaskFactory)"] --> S["Setup:\n Set input properties\n (TaskExecutionHost)"] --> E["ITask.Execute()"] --> O["Gather outputs: \n (TaskExecutionHost)"]
+I["Implement:<br/>extend ITask interface in .dll"] --> R["Register:<br/>&lt;UsingTask /&gt;"] --> U["Use in XML:<br/>&lt;Target&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;MyTask /&gt;<br/>&lt;/Target&gt;"] --> In["Initialize:<br/> compile inline or load from assembly <br/>(TaskFactory)"] --> S["Setup:<br/> Set input properties<br/> (TaskExecutionHost)"] --> E["ITask.Execute()"] --> O["Gather outputs: <br/> (TaskExecutionHost)"]
 ```
 
 ## Task Factories
@@ -54,4 +54,4 @@ Then they can use in project file:
 - [MSBuild task](https://learn.microsoft.com/visualstudio/msbuild/msbuild-task)
 - [Task reference](https://learn.microsoft.com/visualstudio/msbuild/msbuild-task-reference)
 - [Task Writing](https://learn.microsoft.com/visualstudio/msbuild/task-writing)
-- [Creating custom task tutorial](https://learn.microsoft.com/visualstudio/msbuild/tutorial-custom-task-code-generation)
\ No newline at end of file
+- [Creating custom task tutorial](https://learn.microsoft.com/visualstudio/msbuild/tutorial-custom-task-code-generation)
diff --git a/eng/Build.props b/eng/Build.props
index 18c7defa0ce..591a4d41340 100644
--- a/eng/Build.props
+++ b/eng/Build.props
@@ -2,7 +2,7 @@
 
   <PropertyGroup>
     <!-- Static graph restores projects from the parent sln file that are excluded by the slnf file: https://github.com/NuGet/Home/issues/13097. -->
-    <RestoreUseStaticGraphEvaluation Condition="'$(DotNetBuildFromSource)' != 'true'">true</RestoreUseStaticGraphEvaluation>
+    <RestoreUseStaticGraphEvaluation Condition="'$(DotNetBuildSourceOnly)' != 'true'">true</RestoreUseStaticGraphEvaluation>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/eng/SourceBuild.props b/eng/DotNetBuild.props
similarity index 89%
rename from eng/SourceBuild.props
rename to eng/DotNetBuild.props
index 6dde09dcde4..6959f68f31f 100644
--- a/eng/SourceBuild.props
+++ b/eng/DotNetBuild.props
@@ -8,7 +8,7 @@
   </PropertyGroup>
 
   <Target Name="ConfigureInnerBuildArgs" BeforeTargets="GetSourceBuildCommandConfiguration"
-          Condition="'$(ArcadeBuildFromSource)' == 'true' or '$(DotNetBuildSourceOnly)' == 'true'">
+          Condition="'$(DotNetBuildSourceOnly)' == 'true'">
     <PropertyGroup>
       <!-- Filter down projects aggressively in source-only modes. -->
       <InnerBuildArgs>$(InnerBuildArgs) /p:Projects="$(InnerSourceBuildRepoRoot)MSBuild.SourceBuild.slnf"</InnerBuildArgs>
diff --git a/eng/Packages.props b/eng/Packages.props
index e9c77ff48f9..87cf3b78909 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -29,6 +29,7 @@
     <PackageVersion Include="System.Security.Principal.Windows" Version="$(SystemSecurityPrincipalWindowsVersion)" />
     <PackageVersion Include="System.Text.Encoding.CodePages" Version="$(SystemTextEncodingCodePagesVersion)" />
     <PackageVersion Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
+    <PackageVersion Include="System.Text.RegularExpressions" Version="$(SystemTextRegularExpressionsVersion)" />
     <PackageVersion Include="System.Threading.Channels" Version="$(SystemThreadingChannelsVersion)" />
     <PackageVersion Include="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
     <PackageVersion Include="xunit.console" Version="$(XUnitVersion)" />
diff --git a/eng/Signing.props b/eng/Signing.props
index e542c633f4a..b3d45b6fcf3 100644
--- a/eng/Signing.props
+++ b/eng/Signing.props
@@ -1,6 +1,8 @@
 <Project>
   <ItemGroup>
-    <ItemsToSign Include="$(VisualStudioSetupInsertionPath)Microsoft.Build.UnGAC.exe" />
+    <!-- Do not include VS setup insertion files when not building on desktop. The Vsix generation targets do not get imported,
+         and thus this file is not populated to VisualStudioSetupInsertionPath -->
+    <ItemsToSign Include="$(VisualStudioSetupInsertionPath)Microsoft.Build.UnGAC.exe" Condition="'$(MSBuildRuntimeType)' != 'Core'" />
 
     <ItemsToSign Include="$(ArtifactsDir)\xsd\Update-MSBuildXsds.ps1" />
 
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index 765f504dee0..41e59576f29 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -15,7 +15,7 @@
     <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Text.Json/*8.0.4*" />
+    <UsagePattern IdentityGlob="System.Text.Json/*8.0.5*" />
     <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*8.0.0*" />
   </IgnorePatterns>
   <Usages>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 19e0965071d..c195807e00b 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -71,42 +71,36 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.24426.3">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.24503.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e3bdd9a0f2a65fe037ba1adb2261eea48a840fa4</Sha>
+      <Sha>beb827ded6acdff8c7333dfc6583cc984a8f2620</Sha>
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.24426.3">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.24503.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e3bdd9a0f2a65fe037ba1adb2261eea48a840fa4</Sha>
+      <Sha>beb827ded6acdff8c7333dfc6583cc984a8f2620</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23475.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
-      <Uri>https://github.com/dotnet/xliff-tasks</Uri>
-      <Sha>73f0850939d96131c28cf6ea6ee5aacb4da0083a</Sha>
-    </Dependency>
-    <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.xliff-tasks" Version="1.0.0-beta.23475.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
-      <Uri>https://github.com/dotnet/xliff-tasks</Uri>
-      <Sha>73f0850939d96131c28cf6ea6ee5aacb4da0083a</Sha>
-      <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.24503.2">
+      <Uri>https://github.com/dotnet/arcade</Uri>
+      <Sha>beb827ded6acdff8c7333dfc6583cc984a8f2620</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.12.0-preview.1.83">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.12.0-rc.127">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>c8d14f3c28e3af3bdc3dcd38b23a212a91d13234</Sha>
+      <Sha>19756345139c45de23bd196e9b4be01d48e84fdd</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.12.0-2.24425.4">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.12.0-3.24504.7">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>13b65d3b5638457d94c83b545235f47f0d11e483</Sha>
+      <Sha>6a9d2b077973e31b213517579f674b461053ac1c</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.12.0-2.24425.4">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.12.0-3.24504.7">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>13b65d3b5638457d94c83b545235f47f0d11e483</Sha>
+      <Sha>6a9d2b077973e31b213517579f674b461053ac1c</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.24426.3">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.24503.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e3bdd9a0f2a65fe037ba1adb2261eea48a840fa4</Sha>
+      <Sha>beb827ded6acdff8c7333dfc6583cc984a8f2620</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 8a94461df7a..7df9b218345 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,8 +2,8 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.12.0</VersionPrefix>
-    <PackageValidationBaselineVersion>17.11.4</PackageValidationBaselineVersion>
+    <VersionPrefix>17.13.0</VersionPrefix>
+    <PackageValidationBaselineVersion>17.12.0</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -39,7 +39,8 @@
     <SystemResourcesExtensionsVersion>8.0.0</SystemResourcesExtensionsVersion>
     <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
     <SystemTextEncodingCodePagesVersion>7.0.0</SystemTextEncodingCodePagesVersion>
-    <SystemTextJsonVersion>8.0.4</SystemTextJsonVersion>
+    <SystemTextRegularExpressionsVersion>4.3.1</SystemTextRegularExpressionsVersion>
+    <SystemTextJsonVersion>8.0.5</SystemTextJsonVersion>
     <SystemThreadingChannelsVersion>8.0.0</SystemThreadingChannelsVersion>
     <SystemThreadingTasksDataflowVersion>8.0.0</SystemThreadingTasksDataflowVersion>
   </PropertyGroup>
@@ -49,15 +50,15 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.24426.3</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.24503.2</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.1</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.12.0-2.24425.4</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.12.0-preview.1.83</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.12.0-3.24504.7</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.12.0-rc.127</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
-    <BootstrapSdkVersion>9.0.100-preview.7.24407.12</BootstrapSdkVersion>
+    <BootstrapSdkVersion>9.0.100-rc.1.24452.12</BootstrapSdkVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/cibuild_bootstrapped_msbuild.ps1 b/eng/cibuild_bootstrapped_msbuild.ps1
index ec618778ff6..890a99ebb74 100644
--- a/eng/cibuild_bootstrapped_msbuild.ps1
+++ b/eng/cibuild_bootstrapped_msbuild.ps1
@@ -120,7 +120,7 @@ try {
     & $PSScriptRoot\Common\Build.ps1 -restore -build -ci /p:CreateBootstrap=false /nr:false @properties
   }
   else {
-    & $PSScriptRoot\Common\Build.ps1 -restore -build -test -ci /p:CreateBootstrap=true /nr:false @properties
+    & $PSScriptRoot\Common\Build.ps1 -restore -build -test -ci /nr:false @properties
   }
 
   exit $lastExitCode
diff --git a/eng/cibuild_bootstrapped_msbuild.sh b/eng/cibuild_bootstrapped_msbuild.sh
index 71086b55061..c3e3742531c 100644
--- a/eng/cibuild_bootstrapped_msbuild.sh
+++ b/eng/cibuild_bootstrapped_msbuild.sh
@@ -51,7 +51,7 @@ InitializeDotNetCli true
 
 if [[ $build_stage1 == true ]];
 then
-	/bin/bash "$ScriptRoot/common/build.sh" --restore --build --ci --configuration $configuration /p:CreateBootstrap=true $properties $extra_properties || exit $?
+	/bin/bash "$ScriptRoot/common/build.sh" --restore --build --ci --configuration $configuration $properties $extra_properties || exit $?
 fi
 
 bootstrapRoot="$Stage1Dir/bin/bootstrap"
@@ -83,7 +83,7 @@ export DOTNET_HOST_PATH="$_InitializeDotNetCli/dotnet"
 # - Create bootstrap environment as it's required when also running tests
 if [ $onlyDocChanged = 0 ]
 then
-    . "$ScriptRoot/common/build.sh" --restore --build --test --ci --nodereuse false --configuration $configuration /p:CreateBootstrap=true $properties $extra_properties
+    . "$ScriptRoot/common/build.sh" --restore --build --test --ci --nodereuse false --configuration $configuration $properties $extra_properties
 
 else
     . "$ScriptRoot/common/build.sh" --restore --build --ci --nodereuse false --configuration $configuration /p:CreateBootstrap=false $properties $extra_properties
diff --git a/eng/common/templates-official/job/job.yml b/eng/common/templates-official/job/job.yml
index 3d16b41c78c..605692d2fb7 100644
--- a/eng/common/templates-official/job/job.yml
+++ b/eng/common/templates-official/job/job.yml
@@ -1,6 +1,7 @@
 parameters:
 # Sbom related params
   enableSbom: true
+  runAsPublic: false
   PackageVersion: 9.0.0
   BuildDropPath: '$(Build.SourcesDirectory)/artifacts'
 
diff --git a/eng/common/templates/job/job.yml b/eng/common/templates/job/job.yml
index 07d317bf8f9..d1aeb92fcea 100644
--- a/eng/common/templates/job/job.yml
+++ b/eng/common/templates/job/job.yml
@@ -4,6 +4,7 @@ parameters:
   componentGovernanceIgnoreDirectories: ''
 # Sbom related params
   enableSbom: true
+  runAsPublic: false
   PackageVersion: 9.0.0
   BuildDropPath: '$(Build.SourcesDirectory)/artifacts'
 
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index fe9f94a2a72..1672382b7c3 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -62,7 +62,7 @@
     <PackageVersion Update="Verify.XUnit" Condition="'$(VerifyXUnitVersion)' != ''" Version="$(VerifyXUnitVersion)" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true' AND $(ProjectIsDeprecated) != 'true'">
+  <ItemGroup Condition="'$(DotNetBuildSourceOnly)' != 'true' AND $(ProjectIsDeprecated) != 'true'">
     <GlobalPackageReference Include="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="3.3.4" />
     <GlobalPackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.507" PrivateAssets="all"/>
     <GlobalPackageReference Include="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.36" PrivateAssets="All" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
diff --git a/global.json b/global.json
index 82f0811d4c9..9aed49e2701 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "9.0.100-preview.7.24407.12",
+    "dotnet": "9.0.100-rc.2.24474.11",
     "vs": {
-      "version": "17.8.0"
+      "version": "17.10.0"
     },
-    "xcopy-msbuild": "17.8.5"
+    "xcopy-msbuild": "17.10.0-pre.4.0"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.24426.3"
+    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.24503.2"
   }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
index 06827f116b9..6cd24d2c366 100644
--- a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
@@ -3137,6 +3137,44 @@ public void AddMetadataAsAttributeAndAsElement()
             Helpers.VerifyAssertProjectContent(expected, project);
         }
 
+        [Fact]
+        public void SetMetadataName()
+        {
+            var project = ProjectRootElement.Create();
+            var itemGroup = project.AddItemGroup();
+
+            var item = itemGroup.AddItem("i1", "i");
+            var attributeMetadata = item.AddMetadata("A", "value_a", expressAsAttribute: true);
+            var elementMetadata = item.AddMetadata("B", "value_b", expressAsAttribute: false);
+
+            string expected = """
+                <Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+                  <ItemGroup>
+                    <i1 Include="i" A="value_a">
+                      <B>value_b</B>
+                    </i1>
+                  </ItemGroup>
+                </Project>
+                """;
+
+            Helpers.VerifyAssertProjectContent(expected, project);
+
+            attributeMetadata.Name = "A2";
+            elementMetadata.Name = "B2";
+
+            expected = """
+                <Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+                  <ItemGroup>
+                    <i1 Include="i" A2="value_a">
+                      <B2>value_b</B2>
+                    </i1>
+                  </ItemGroup>
+                </Project>
+                """;
+
+            Helpers.VerifyAssertProjectContent(expected, project);
+        }
+
         /// <summary>
         /// Legally modify a child whose parent is not parented (should not throw)
         /// </summary>
diff --git a/src/Build.OM.UnitTests/Construction/ProjectUsingTaskElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectUsingTaskElement_Tests.cs
index 64c23a0262a..a0338804b63 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectUsingTaskElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectUsingTaskElement_Tests.cs
@@ -356,7 +356,7 @@ public void DuplicateParameterGroup()
                     </Project>
                 ";
                 ProjectRootElement.Create(XmlReader.Create(new StringReader(content)));
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
@@ -376,7 +376,7 @@ public void DuplicateTaskGroup()
                     </Project>
                 ";
                 ProjectRootElement.Create(XmlReader.Create(new StringReader(content)));
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
@@ -395,7 +395,7 @@ public void UnknownChild()
                     </Project>
                 ";
                 ProjectRootElement.Create(XmlReader.Create(new StringReader(content)));
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
@@ -444,7 +444,7 @@ public void ExceptionWhenNoTaskFactoryAndHavePG()
 
                 ProjectRootElement project = ProjectRootElement.Create(XmlReader.Create(new StringReader(content)));
                 Helpers.GetFirst(project.Children);
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
@@ -465,7 +465,7 @@ public void ExceptionWhenNoTaskFactoryAndHaveTask()
 
                 ProjectRootElement project = ProjectRootElement.Create(XmlReader.Create(new StringReader(content)));
                 Helpers.GetFirst(project.Children);
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index 7c4ea152dea..84d703d22e8 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -52,7 +52,7 @@ public void ParseSolution_VC()
                 ";
 
                 ParseSolutionHelper(solutionFileContents);
-                Assert.True(false, "Should not get here");
+                Assert.Fail("Should not get here");
             });
         }
         /// <summary>
@@ -273,7 +273,7 @@ public void ParseSolutionFileWithDescriptionInformation()
             }
             catch (Exception ex)
             {
-                Assert.True(false, "Failed to parse solution containing description information. Error: " + ex.Message);
+                Assert.Fail("Failed to parse solution containing description information. Error: " + ex.Message);
             }
         }
 
@@ -551,7 +551,7 @@ public void MissingNestedProject()
             }
 
             // Should not get here
-            Assert.True(false);
+            Assert.Fail();
         }
 
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Construction/UsingTaskBodyElement_Tests.cs b/src/Build.OM.UnitTests/Construction/UsingTaskBodyElement_Tests.cs
index 5a0d09d39e3..7e72706e7a9 100644
--- a/src/Build.OM.UnitTests/Construction/UsingTaskBodyElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/UsingTaskBodyElement_Tests.cs
@@ -46,7 +46,7 @@ public void ReadInvalidAttribute()
                 ";
 
                 ProjectRootElement.Create(XmlReader.Create(new StringReader(content)));
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
@@ -106,7 +106,7 @@ public void SetInvalidNullValue()
             {
                 ProjectUsingTaskBodyElement body = GetBodyXml();
                 body.TaskBody = null;
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Construction/UsingTaskParameterElement_Tests.cs b/src/Build.OM.UnitTests/Construction/UsingTaskParameterElement_Tests.cs
index c1c02d3311e..389bd7d62d1 100644
--- a/src/Build.OM.UnitTests/Construction/UsingTaskParameterElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/UsingTaskParameterElement_Tests.cs
@@ -90,7 +90,7 @@ public void ReadInvalidAttribute()
                 ";
 
                 ProjectRootElement.Create(XmlReader.Create(new StringReader(content)));
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Construction/UsingTaskParameterGroup_Tests.cs b/src/Build.OM.UnitTests/Construction/UsingTaskParameterGroup_Tests.cs
index 90a30355d35..c046b7ce98c 100644
--- a/src/Build.OM.UnitTests/Construction/UsingTaskParameterGroup_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/UsingTaskParameterGroup_Tests.cs
@@ -107,7 +107,7 @@ public void ReadDuplicateChildParameters()
             Assert.Throws<InvalidProjectFileException>(() =>
             {
                 GetParameterGroupXml(s_contentDuplicateParameters);
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
@@ -127,7 +127,7 @@ public void ReadInvalidAttribute()
                 ";
 
                 ProjectRootElement.Create(XmlReader.Create(new StringReader(content)));
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
diff --git a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
index ef18089513e..168cb67c58e 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
@@ -724,7 +724,7 @@ public void UnloadProjectXml()
                 // an attempt to load it by the pretend filename should fail,
                 // so it makes a good test to see that the UnloadProject method worked.
                 ProjectCollection.GlobalProjectCollection.LoadProject(xml.FullPath);
-                Assert.True(false, "An InvalidProjectFileException was expected.");
+                Assert.Fail("An InvalidProjectFileException was expected.");
             }
             catch (InvalidProjectFileException)
             {
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index 00ee719f8d6..2111a5ee369 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -1657,13 +1657,14 @@ public void CancelledBuildWithDelay40()
             string contents = CleanupFileContents(@"
 <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
  <Target Name='test'>
-    <Exec Command='" + Helpers.GetSleepCommand(TimeSpan.FromSeconds(10)) + @"'/>
+    <Exec Command='" + Helpers.GetSleepCommand(TimeSpan.FromSeconds(20)) + @"'/>
     <Message Text='[errormessage]'/>
  </Target>
 </Project>
 ");
             BuildRequestData data = GetBuildRequestData(contents, Array.Empty<string>(), MSBuildDefaultToolsVersion);
             _buildManager.BeginBuild(_parameters);
+            Stopwatch sw = Stopwatch.StartNew();
             BuildSubmission asyncResult = _buildManager.PendBuildRequest(data);
             asyncResult.ExecuteAsync(null, null);
 
@@ -1675,6 +1676,50 @@ public void CancelledBuildWithDelay40()
 
             Assert.Equal(BuildResultCode.Failure, result.OverallResult); // "Build should have failed."
             _logger.AssertLogDoesntContain("[errormessage]");
+            // The build should bail out immediately after executing CancelAllSubmissions, build stalling for a longer time
+            //  is very unexpected.
+            sw.Elapsed.ShouldBeLessThan(TimeSpan.FromSeconds(10));
+        }
+
+        /// <summary>
+        /// A canceled build which waits for the task to get started before canceling.  Because it is a 12.. task, we should
+        /// cancel the task and exit out after a short period wherein we wait for the task to exit cleanly.
+        ///
+        /// This test also exercises the possibility of CancelAllSubmissions being executed after EndBuild -
+        /// which can happen even if they are synchronously executed in expected order - the CancelAllSubmissions is internally
+        /// asynchronous and hence part of the execution can happen after EndBuild.
+        /// </summary>
+        [Fact]
+        public void CancelledBuildWithDelay40_WithThreatSwap()
+        {
+            string contents = CleanupFileContents(@"
+<Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
+ <Target Name='test'>
+    <Exec Command='" + Helpers.GetSleepCommand(TimeSpan.FromSeconds(20)) + @"'/>
+    <Message Text='[errormessage]'/>
+ </Target>
+</Project>
+");
+            BuildRequestData data = GetBuildRequestData(contents, Array.Empty<string>(), MSBuildDefaultToolsVersion);
+            _buildManager.BeginBuild(_parameters);
+            Stopwatch sw = Stopwatch.StartNew();
+            BuildSubmission asyncResult = _buildManager.PendBuildRequest(data);
+            asyncResult.ExecuteAsync(null, null);
+
+            Thread.Sleep(500);
+            // Simulate the case where CancelAllSubmissions is called after EndBuild or its internal queued task is swapped
+            //  and executed after EndBuild starts execution.
+            System.Threading.Tasks.Task.Delay(500).ContinueWith(t => _buildManager.CancelAllSubmissions());
+            _buildManager.EndBuild();
+
+            asyncResult.WaitHandle.WaitOne();
+            BuildResult result = asyncResult.BuildResult;
+
+            Assert.Equal(BuildResultCode.Failure, result.OverallResult); // "Build should have failed."
+            _logger.AssertLogDoesntContain("[errormessage]");
+            // The build should bail out immediately after executing CancelAllSubmissions, build stalling for a longer time
+            //  is very unexpected.
+            sw.Elapsed.ShouldBeLessThan(TimeSpan.FromSeconds(10));
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
index 9ad9bacf084..b4efa7ea860 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
@@ -212,7 +212,7 @@ public void WaitForCancelCompletion()
             {
                 if (!_builderThread.Join(5000))
                 {
-                    Assert.True(false, "Builder thread did not terminate on cancel.");
+                    Assert.Fail("Builder thread did not terminate on cancel.");
 #if FEATURE_THREAD_ABORT
                     _builderThread.Abort();
 #endif
@@ -535,11 +535,11 @@ private void WaitForEvent(WaitHandle evt, string eventName)
             int index = WaitHandle.WaitAny(events, 5000);
             if (WaitHandle.WaitTimeout == index)
             {
-                Assert.True(false, "Did not receive " + eventName + " callback before the timeout expired.");
+                Assert.Fail("Did not receive " + eventName + " callback before the timeout expired.");
             }
             else if (index == 0)
             {
-                Assert.True(false, "Received engine exception " + _engineException_Exception);
+                Assert.Fail("Received engine exception " + _engineException_Exception);
             }
         }
 
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index 5dfb489f483..eea8d075466 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -1123,13 +1123,13 @@ private void VerifyShutdownExceptions(ILogger logger, string className, Type exp
             try
             {
                 _initializedService.ShutdownComponent();
-                Assert.True(false, "No Exceptions Generated");
+                Assert.Fail("No Exceptions Generated");
             }
             catch (Exception e)
             {
                 if (e.GetType() != expectedExceptionType)
                 {
-                    Assert.True(false, "Expected a " + expectedExceptionType + " but got a " + e.GetType() + " Stack:" + e.ToString());
+                    Assert.Fail("Expected a " + expectedExceptionType + " but got a " + e.GetType() + " Stack:" + e.ToString());
                 }
             }
         }
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index fd1ffbcae34..1922000b7c7 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -37,7 +37,6 @@ public void Dispose()
         /// throw a path too long exception
         /// </summary>
         [Fact]
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/4247")]
         public void ProjectItemSpecTooLong()
         {
             string currentDirectory = Directory.GetCurrentDirectory();
@@ -45,8 +44,6 @@ public void ProjectItemSpecTooLong()
             {
                 Directory.SetCurrentDirectory(Path.GetTempPath());
 
-                string tempPath = Path.GetTempPath();
-
                 string tempProject = ObjectModelHelpers.CreateTempFileOnDisk(@"
                 <Project DefaultTargets=`TargetA; TargetB; TargetC` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
@@ -68,16 +65,16 @@ public void ProjectItemSpecTooLong()
                     projectFile1 += "..\\";
                 }
 
-                int rootLength = Path.GetPathRoot(tempPath).Length;
-                string tempPathNoRoot = tempPath.Substring(rootLength);
+                int rootLength = Path.GetPathRoot(tempProject).Length;
+                string tempPathNoRoot = tempProject.Substring(rootLength);
 
-                projectFile1 += Path.Combine(tempPathNoRoot, fileName);
+                projectFile1 += tempPathNoRoot;
 
                 string parentProjectContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <Target Name=`Build`>
-                        <MSBuild Projects=`" + projectFile1 + @"` />
+                        <MSBuild Projects=`" + projectFile1 + @"`/>
                     </Target>
                 </Project>";
                 try
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index e19d7fbec5b..23d3cf093e8 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -550,6 +550,32 @@ public BuildEventContext LogProjectStarted(
             return new BuildEventContext(0, 0, 0, 0);
         }
 
+        public void LogProjectStarted(ProjectStartedEventArgs args)
+        { }
+
+        public ProjectStartedEventArgs CreateProjectStarted(
+            BuildEventContext nodeBuildEventContext,
+            int submissionId,
+            int configurationId,
+            BuildEventContext parentBuildEventContext,
+            string projectFile,
+            string targetNames,
+            IEnumerable<DictionaryEntry> properties,
+            IEnumerable<DictionaryEntry> items,
+            int evaluationId = BuildEventContext.InvalidEvaluationId,
+            int projectContextId = BuildEventContext.InvalidProjectContextId)
+        {
+            return new ProjectStartedEventArgs(
+                configurationId,
+                message: null,
+                helpKeyword: null,
+                projectFile,
+                targetNames,
+                properties,
+                items,
+                parentBuildEventContext);
+        }
+
         /// <summary>
         /// Logs a project finished event
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
index aeddc3281eb..bb0c19a4415 100644
--- a/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
@@ -24,7 +24,7 @@ public class NodeConfiguration_Tests
         [Theory]
         [InlineData(new byte[] { 1, 2, 3 })]
         [InlineData(null)]
-        public void TestTranslationWithAppDomainSetup(byte[] configBytes)
+        public void TestTranslationWithAppDomainSetup(byte[]? configBytes)
         {
             AppDomainSetup setup = new AppDomainSetup();
 
diff --git a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
index 32f6b0e3093..5a1eb10715b 100644
--- a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
@@ -332,7 +332,7 @@ public void AsynchronousData()
             endpoints.ManagerEndpoint.SendData(managerPacket);
             if (!_host.DataReceivedEvent.WaitOne(1000))
             {
-                Assert.True(false, "Data not received before timeout expired.");
+                Assert.Fail("Data not received before timeout expired.");
             }
             Assert.Equal(_host.DataReceivedContext.packet, managerPacket);
             Assert.NotEqual(_host.DataReceivedContext.thread.ManagedThreadId, Thread.CurrentThread.ManagedThreadId);
@@ -342,7 +342,7 @@ public void AsynchronousData()
             endpoints.NodeEndpoint.SendData(nodePacket);
             if (!_host.DataReceivedEvent.WaitOne(1000))
             {
-                Assert.True(false, "Data not received before timeout expired.");
+                Assert.Fail("Data not received before timeout expired.");
             }
             Assert.Equal(_host.DataReceivedContext.packet, nodePacket);
             Assert.NotEqual(_host.DataReceivedContext.thread.ManagedThreadId, Thread.CurrentThread.ManagedThreadId);
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index c63606144c8..c249a953174 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -8,6 +8,7 @@
 using FluentAssertions;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
@@ -77,6 +78,8 @@ public void VerifyEventType()
             EnvironmentVariableReadEventArgs environmentVariableRead = new("env", "message", "file", 0, 0);
             GeneratedFileUsedEventArgs generatedFileUsed = new GeneratedFileUsedEventArgs("path", "some content");
             BuildSubmissionStartedEventArgs buildSubmissionStarted = new(new Dictionary<string, string> { { "Value1", "Value2" } }, ["Path1"], ["TargetName"], BuildRequestDataFlags.ReplaceExistingProjectInstance, 123);
+            BuildCheckTracingEventArgs buildCheckTracing = new();
+            BuildCanceledEventArgs buildCanceled = new("message", DateTime.UtcNow);
 
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
             VerifyLoggingPacket(buildStarted, LoggingEventType.BuildStartedEvent);
@@ -111,6 +114,8 @@ public void VerifyEventType()
             VerifyLoggingPacket(environmentVariableRead, LoggingEventType.EnvironmentVariableReadEvent);
             VerifyLoggingPacket(generatedFileUsed, LoggingEventType.GeneratedFileUsedEvent);
             VerifyLoggingPacket(buildSubmissionStarted, LoggingEventType.BuildSubmissionStartedEvent);
+            VerifyLoggingPacket(buildCheckTracing, LoggingEventType.BuildCheckTracingEvent);
+            VerifyLoggingPacket(buildCanceled, LoggingEventType.BuildCanceledEvent);
         }
 
         private static BuildEventContext CreateBuildEventContext()
diff --git a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
index 99aad984e34..61ac9f125d4 100644
--- a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
@@ -327,7 +327,7 @@ private void WaitForEvent(WaitHandle evt, string eventName)
         {
             if (!evt.WaitOne(5000))
             {
-                Assert.True(false, "Did not receive " + eventName + " callback before the timeout expired.");
+                Assert.Fail("Did not receive " + eventName + " callback before the timeout expired.");
             }
         }
 
diff --git a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
index b956eaa4c6e..dcf1f45727d 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
@@ -739,12 +739,12 @@ internal static void AreEqual(ITaskItem[] x, ITaskItem[] y)
 
                 if (x == null || y == null)
                 {
-                    Assert.True(false, "The two item lists are not equal -- one of them is null");
+                    Assert.Fail("The two item lists are not equal -- one of them is null");
                 }
 
                 if (x.Length != y.Length)
                 {
-                    Assert.True(false, "The two item lists have different lengths, so they cannot be equal");
+                    Assert.Fail("The two item lists have different lengths, so they cannot be equal");
                 }
 
                 for (int i = 0; i < x.Length; i++)
@@ -765,7 +765,7 @@ internal static void AreEqual(ITaskItem x, ITaskItem y)
 
                 if (x == null || y == null)
                 {
-                    Assert.True(false, "The two items are not equal -- one of them is null");
+                    Assert.Fail("The two items are not equal -- one of them is null");
                 }
 
                 Assert.Equal(x.ItemSpec, y.ItemSpec);
@@ -779,7 +779,7 @@ internal static void AreEqual(ITaskItem x, ITaskItem y)
                 {
                     if (!metadataFromY.Contains(metadataName))
                     {
-                        Assert.True(false, string.Format("Only one item contains the '{0}' metadata", metadataName));
+                        Assert.Fail(string.Format("Only one item contains the '{0}' metadata", metadataName));
                     }
                     else
                     {
diff --git a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
index 91d8bec792d..6a652802962 100644
--- a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
@@ -1380,7 +1380,7 @@ public void RandomTypeOnParameter()
 
                 List<ProjectUsingTaskElement> elementList = CreateParameterElementWithAttributes(output, required, type);
                 CreateTaskRegistryAndRegisterTasks(elementList);
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
@@ -1423,7 +1423,7 @@ public void BadArrayInputOnInputParameter()
 
                 List<ProjectUsingTaskElement> elementList = CreateParameterElementWithAttributes(output, required, type);
                 TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
@@ -1469,7 +1469,7 @@ public void BadScalarInputOnInputParameterDerivedFromITask()
 
                 List<ProjectUsingTaskElement> elementList = CreateParameterElementWithAttributes(output, required, type);
                 TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
@@ -1487,7 +1487,7 @@ public void BadScalarInputOnInputParameter()
 
                 List<ProjectUsingTaskElement> elementList = CreateParameterElementWithAttributes(output, required, type);
                 TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
@@ -1558,7 +1558,7 @@ public void BadOutputParameter()
 
                 List<ProjectUsingTaskElement> elementList = CreateParameterElementWithAttributes(output, required, type);
                 TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
@@ -1605,7 +1605,7 @@ public void RandomOutput()
 
                 List<ProjectUsingTaskElement> elementList = CreateParameterElementWithAttributes(output, required, type);
                 CreateTaskRegistryAndRegisterTasks(elementList);
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
@@ -1652,7 +1652,7 @@ public void RandomRequired()
 
                 List<ProjectUsingTaskElement> elementList = CreateParameterElementWithAttributes(output, required, type);
                 CreateTaskRegistryAndRegisterTasks(elementList);
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
@@ -1809,7 +1809,7 @@ public void RandomEvaluate()
                 string evaluate = "RandomStuff";
                 List<ProjectUsingTaskElement> elementList = CreateTaskBodyElementWithAttributes(evaluate, "");
                 CreateTaskRegistryAndRegisterTasks(elementList);
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 9df91a2a936..c45baa49e1e 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -4,11 +4,13 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Globalization;
 using System.IO;
 using System.Linq;
 using System.Text;
 using FluentAssertions;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Logging;
@@ -95,6 +97,18 @@ public void RoundtripBuildFinishedEventArgs()
                 e => e.Succeeded.ToString());
         }
 
+        [Fact]
+        public void RoundtripBuildCanceledEventArgs()
+        {
+            var args = new BuildCanceledEventArgs(
+                "Message",
+                eventTimestamp: DateTime.Parse("12/12/2015 06:11:56 PM"));
+
+            Roundtrip(args,
+                e => e.Message,
+                e => e.Timestamp.ToString());
+        }
+
         [Fact]
         public void RoundtripBuildSubmissionStartedEventArgs()
         {
@@ -530,6 +544,27 @@ public void RoundtripAssemblyLoadBuild()
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
+        [Fact]
+        public void RoundtripBuildCheckTracingEventArgs()
+        {
+            string key1 = "AA";
+            TimeSpan span1 = TimeSpan.FromSeconds(5);
+            string key2 = "b";
+            TimeSpan span2 = TimeSpan.FromSeconds(15);
+            string key3 = "cCc";
+            TimeSpan span3 = TimeSpan.FromSeconds(50);
+
+            Dictionary<string, TimeSpan> stats = new() { { key1, span1 }, { key2, span2 }, { key3, span3 } };
+
+            BuildCheckTracingEventArgs args = new BuildCheckTracingEventArgs(stats);
+
+            Roundtrip(args,
+                e => e.TracingData.InfrastructureTracingData.Keys.Count.ToString(),
+                e => e.TracingData.InfrastructureTracingData.Keys.ToCsvString(false),
+                e => e.TracingData.InfrastructureTracingData.Values
+                    .Select(v => v.TotalSeconds.ToString(CultureInfo.InvariantCulture)).ToCsvString(false));
+        }
+
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
diff --git a/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs b/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs
index eabc4ee8b91..0a9116c81d5 100644
--- a/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs
+++ b/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs
@@ -30,7 +30,7 @@ public void Empty()
 
             foreach (string value in dictionary["x"])
             {
-                Assert.True(false);
+                Assert.Fail();
             }
         }
 
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 3c269b66680..8e28604557b 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -1264,7 +1264,7 @@ public void Regress751742_SkipNonexistentProjects()
                 }
                 else
                 {
-                    Assert.True(false, "Unexpected project seen:" + item.ItemSpec);
+                    Assert.Fail("Unexpected project seen:" + item.ItemSpec);
                 }
             }
         }
@@ -1910,7 +1910,7 @@ public void SolutionGeneratorCanEmitSolutions()
                 }
                 else
                 {
-                    Assert.True(false, "Something went really wrong!  The SolutionFile wasn't even created!");
+                    Assert.Fail("Something went really wrong!  The SolutionFile wasn't even created!");
                 }
             }
         }
@@ -2762,7 +2762,7 @@ private void AssertProjectContainsItem(ProjectInstance msbuildProject, string it
                 }
             }
 
-            Assert.True(false);
+            Assert.Fail();
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Definition/Toolset_Tests.cs b/src/Build.UnitTests/Definition/Toolset_Tests.cs
index da358f88033..9c76a26954e 100644
--- a/src/Build.UnitTests/Definition/Toolset_Tests.cs
+++ b/src/Build.UnitTests/Definition/Toolset_Tests.cs
@@ -145,7 +145,7 @@ public void ValidateToolsetTranslation()
                 }
                 else
                 {
-                    Assert.True(false, $"Sub-toolset {key} was lost in translation.");
+                    Assert.Fail($"Sub-toolset {key} was lost in translation.");
                 }
             }
 
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 8bdb4b5a1a4..4f9b2b14f92 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -1937,11 +1937,11 @@ public void AllEvaluatedProperties()
 
                 if (!allEvaluatedPropertiesWithNoBackingXmlAndNoDuplicates.TryGetValue(property.Name, out propertyFromAllEvaluated))
                 {
-                    Assert.True(false, String.Format("project.Properties contained property {0}, but AllEvaluatedProperties did not.", property.Name));
+                    Assert.Fail(String.Format("project.Properties contained property {0}, but AllEvaluatedProperties did not.", property.Name));
                 }
                 else if (!property.Equals(propertyFromAllEvaluated))
                 {
-                    Assert.True(false, String.Format("The properties in project.Properties and AllEvaluatedProperties for property {0} were different.", property.Name));
+                    Assert.Fail(String.Format("The properties in project.Properties and AllEvaluatedProperties for property {0} were different.", property.Name));
                 }
             }
 
@@ -2101,11 +2101,11 @@ public void AllEvaluatedPropertiesAndImports()
 
                     if (!allEvaluatedPropertiesWithNoBackingXmlAndNoDuplicates.TryGetValue(property.Name, out propertyFromAllEvaluated))
                     {
-                        Assert.True(false, String.Format("project.Properties contained property {0}, but AllEvaluatedProperties did not.", property.Name));
+                        Assert.Fail(String.Format("project.Properties contained property {0}, but AllEvaluatedProperties did not.", property.Name));
                     }
                     else if (!property.Equals(propertyFromAllEvaluated))
                     {
-                        Assert.True(false, String.Format("The properties in project.Properties and AllEvaluatedProperties for property {0} were different.", property.Name));
+                        Assert.Fail(String.Format("The properties in project.Properties and AllEvaluatedProperties for property {0} were different.", property.Name));
                     }
                 }
 
@@ -3142,7 +3142,7 @@ public void VerifyInvalidTreatAsLocalProperty()
                 project.Build(logger);
 
                 // Should not reach this point.
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         /// <summary>
@@ -4385,7 +4385,7 @@ public void VerifyDTDProcessingIsDisabled()
             catch (XmlException)
             {
                 // XmlException thrown when invalid DTD statement is parsed: it means DTD processing was enabled
-                Assert.True(false);
+                Assert.Fail();
             }
         }
 
@@ -4475,7 +4475,7 @@ public void VerifyConditionEvaluatorResetStateOnFailure()
                     MockElementLocation.Instance,
                     FileSystems.Default,
                     new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
-                Assert.True(false, "Expect exception due to the value of property \"TargetOSFamily\" is not a number.");
+                Assert.Fail("Expect exception due to the value of property \"TargetOSFamily\" is not a number.");
             }
             catch (InvalidProjectFileException e)
             {
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index b29a857dc69..1da44037bef 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -1263,7 +1263,7 @@ public void StaticMethodErrorMessageHaveMethodName()
                 return;
             }
 
-            Assert.True(false);
+            Assert.Fail();
         }
 
         /// <summary>
@@ -1290,8 +1290,57 @@ public void StaticMethodErrorMessageHaveMethodName1()
                 return;
             }
 
-            Assert.True(false);
+            Assert.Fail();
         }
+
+        [Fact]
+        public void StaticMethodWithThrowawayParameterSupported()
+        {
+            MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
+<Project>
+  <PropertyGroup>
+    <MyProperty>Value is $([System.Int32]::TryParse(""3"", out _))</MyProperty>
+  </PropertyGroup>
+  <Target Name='Build'>
+    <Message Text='$(MyProperty)' />
+  </Target>
+</Project>");
+
+            logger.FullLog.ShouldContain("Value is True");
+        }
+
+        [Fact]
+        public void StaticMethodWithThrowawayParameterSupported2()
+        {
+            MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
+<Project>
+  <PropertyGroup>
+    <MyProperty>Value is $([System.Int32]::TryParse(""notANumber"", out _))</MyProperty>
+  </PropertyGroup>
+  <Target Name='Build'>
+    <Message Text='$(MyProperty)' />
+  </Target>
+</Project>");
+
+            logger.FullLog.ShouldContain("Value is False");
+        }
+
+        [Fact]
+        public void StaticMethodWithUnderscoreNotConfusedWithThrowaway()
+        {
+            MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
+<Project>
+  <PropertyGroup>
+    <MyProperty>Value is $([System.String]::Join('_', 'asdf', 'jkl'))</MyProperty>
+  </PropertyGroup>
+  <Target Name='Build'>
+    <Message Text='$(MyProperty)' />
+  </Target>
+</Project>");
+
+            logger.FullLog.ShouldContain("Value is asdf_jkl");
+        }
+
         /// <summary>
         /// Creates a set of complicated item metadata and properties, and items to exercise
         /// the Expander class.  The data here contains escaped characters, metadata that
@@ -3586,7 +3635,7 @@ public void PropertyFunctionDoesTaskHostExist_Error()
                 expander.ExpandIntoStringLeaveEscaped(@"$([MSBuild]::DoesTaskHostExist('ASDF', 'CurrentArchitecture'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
                 // We should have failed before now
-                Assert.True(false);
+                Assert.Fail();
             });
         }
 
@@ -4088,7 +4137,10 @@ public void Medley()
                 new string[] {"A$(Reg:AA)", "A"},
                 new string[] {"$(Reg:AA)", ""},
                 new string[] {"$(Reg:AAAA)", ""},
-                new string[] {"$(Reg:AAA)", ""}
+                new string[] {"$(Reg:AAA)", ""},
+                // Following two are comparison between non-numeric and numeric properties. More details: #10583
+                new string[] {"$(a.Equals($(c)))","False"},
+                new string[] {"$(a.CompareTo($(c)))","1"},
                                    };
 
             var errorTests = new List<string> {
@@ -4250,7 +4302,7 @@ public void Medley()
                 {
                     string message = "FAILURE: " + validTests[i][0] + " expanded to '" + result + "' instead of '" + validTests[i][1] + "'";
                     Console.WriteLine(message);
-                    Assert.True(false, message);
+                    Assert.Fail(message);
                 }
                 else
                 {
@@ -5074,7 +5126,7 @@ public void FastPathValidationTest(string methodInvocationMetadata)
         {
             using (var env = TestEnvironment.Create())
             {
-                // Setting this env variable allows to track if expander was using reflection for a function invocation. 
+                // Setting this env variable allows to track if expander was using reflection for a function invocation.
                 env.SetEnvironmentVariable("MSBuildLogPropertyFunctionsRequiringReflection", "1");
 
                 var logger = new MockLogger();
diff --git a/src/Build.UnitTests/FileLogger_Tests.cs b/src/Build.UnitTests/FileLogger_Tests.cs
index 279859f2058..92fe3050728 100644
--- a/src/Build.UnitTests/FileLogger_Tests.cs
+++ b/src/Build.UnitTests/FileLogger_Tests.cs
@@ -537,7 +537,7 @@ public void DistributedLoggerNullEmpty()
                 fileLogger.NodeId = 1;
                 fileLogger.Parameters = "logfile=";
                 fileLogger.Initialize(new EventSourceSink());
-                Assert.True(false);
+                Assert.Fail();
             });
         }
         #endregion
diff --git a/src/Build.UnitTests/InvalidProjectFileException_Tests.cs b/src/Build.UnitTests/InvalidProjectFileException_Tests.cs
index 8e1d50c18d6..0987c3e9d6a 100644
--- a/src/Build.UnitTests/InvalidProjectFileException_Tests.cs
+++ b/src/Build.UnitTests/InvalidProjectFileException_Tests.cs
@@ -72,7 +72,7 @@ public void LogErrorShouldHavePathAndLocation()
                 MockLogger logger = new MockLogger(_testOutput);
                 ObjectModelHelpers.BuildTempProjectFileExpectFailure(file, logger);
 
-                Assert.True(false, "Loading an invalid project should have thrown an InvalidProjectFileException.");
+                Assert.Fail("Loading an invalid project should have thrown an InvalidProjectFileException.");
             }
             catch (InvalidProjectFileException e)
             {
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index ffd2b33a2ed..3d8ccf424fb 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -668,7 +668,7 @@ IEnumerable<ILogger> AppendDebuggingLoggers(IEnumerable<ILogger> loggers)
 
                 var logger = new BinaryLogger { Parameters = binlogPath };
 
-                return (loggers ?? Enumerable.Empty<ILogger>()).Concat(new[] { logger });
+                return (loggers ?? [logger]);
             }
 
             void InitializeCaches()
@@ -789,15 +789,10 @@ void Callback(object? state)
             {
                 lock (_syncLock)
                 {
-                    if (_shuttingDown)
-                    {
-                        return;
-                    }
-
-                    // If we are Idle, obviously there is nothing to cancel.  If we are waiting for the build to end, then presumably all requests have already completed
-                    // and there is nothing left to cancel.  Putting this here eliminates the possibility of us racing with EndBuild to access the nodeManager before
-                    // EndBuild sets it to null.
-                    if (_buildManagerState != BuildManagerState.Building)
+                    // If the state is Idle - then there is yet or already nothing to cancel
+                    // If state is WaitingForBuildToComplete - we might be already waiting gracefully - but CancelAllSubmissions
+                    //  is a request for quick abort - so it's fine to resubmit the request
+                    if (_buildManagerState == BuildManagerState.Idle)
                     {
                         return;
                     }
@@ -1070,6 +1065,11 @@ public void EndBuild()
                             }
                             _buildTelemetry.Host = host;
 
+                            _buildTelemetry.BuildCheckEnabled = _buildParameters!.IsBuildCheckEnabled;
+                            var sacState = NativeMethodsShared.GetSACState();
+                            // The Enforcement would lead to build crash - but let's have the check for completeness sake.
+                            _buildTelemetry.SACEnabled = sacState == NativeMethodsShared.SAC_State.Evaluation || sacState == NativeMethodsShared.SAC_State.Enforcement;
+
                             loggingService.LogTelemetry(buildEventContext: null, _buildTelemetry.EventName, _buildTelemetry.GetProperties());
                             // Clean telemetry to make it ready for next build submission.
                             _buildTelemetry = null;
@@ -1522,7 +1522,7 @@ private BuildRequestConfiguration CreateConfiguration(Project project, BuildRequ
 
             if (existingConfiguration == null)
             {
-                existingConfiguration = new BuildRequestConfiguration(GetNewConfigurationId(), new BuildRequestData(newInstance, Array.Empty<string>()), null /* use the instance's tools version */);
+                existingConfiguration = new BuildRequestConfiguration(GetNewConfigurationId(), new BuildRequestData(newInstance, []), null /* use the instance's tools version */);
             }
             else
             {
@@ -1830,7 +1830,7 @@ void IssueBuildSubmissionToSchedulerImpl(BuildSubmission submission, bool allowM
                             }
                         }
 
-                        BuildRequestBlocker blocker = new BuildRequestBlocker(-1, Array.Empty<string>(), new[] { submission.BuildRequest });
+                        BuildRequestBlocker blocker = new BuildRequestBlocker(-1, [], [submission.BuildRequest]);
 
                         HandleNewRequest(Scheduler.VirtualNode, blocker);
                     }
@@ -2073,17 +2073,17 @@ private void ShutdownConnectedNodes(bool abort)
             lock (_syncLock)
             {
                 _shuttingDown = true;
-                _executionCancellationTokenSource!.Cancel();
+                _executionCancellationTokenSource?.Cancel();
 
                 // If we are aborting, we will NOT reuse the nodes because their state may be compromised by attempts to shut down while the build is in-progress.
-                _nodeManager!.ShutdownConnectedNodes(!abort && _buildParameters!.EnableNodeReuse);
+                _nodeManager?.ShutdownConnectedNodes(!abort && _buildParameters!.EnableNodeReuse);
 
                 // if we are aborting, the task host will hear about it in time through the task building infrastructure;
                 // so only shut down the task host nodes if we're shutting down tidily (in which case, it is assumed that all
                 // tasks are finished building and thus that there's no risk of a race between the two shutdown pathways).
                 if (!abort)
                 {
-                    _taskHostNodeManager!.ShutdownConnectedNodes(_buildParameters!.EnableNodeReuse);
+                    _taskHostNodeManager?.ShutdownConnectedNodes(_buildParameters!.EnableNodeReuse);
                 }
             }
         }
@@ -3110,48 +3110,51 @@ private void ShutdownLoggingService(ILoggingService? loggingService)
         /// </summary>
         private void Dispose(bool disposing)
         {
-            if (!_disposed)
+            if (disposing && !_disposed)
             {
-                if (disposing)
+                lock (_syncLock)
                 {
-                    lock (_syncLock)
+                    if (_disposed)
                     {
-                        // We should always have finished cleaning up before calling Dispose.
-                        RequireState(BuildManagerState.Idle, "ShouldNotDisposeWhenBuildManagerActive");
+                        // Multiple caller raced for enter into the lock
+                        return;
+                    }
 
-                        _componentFactories?.ShutdownComponents();
+                    // We should always have finished cleaning up before calling Dispose.
+                    RequireState(BuildManagerState.Idle, "ShouldNotDisposeWhenBuildManagerActive");
 
-                        if (_workQueue != null)
-                        {
-                            _workQueue.Complete();
-                            _workQueue = null;
-                        }
+                    _componentFactories?.ShutdownComponents();
 
-                        if (_executionCancellationTokenSource != null)
-                        {
-                            _executionCancellationTokenSource.Cancel();
-                            _executionCancellationTokenSource = null;
-                        }
+                    if (_workQueue != null)
+                    {
+                        _workQueue.Complete();
+                        _workQueue = null;
+                    }
 
-                        if (_noActiveSubmissionsEvent != null)
-                        {
-                            _noActiveSubmissionsEvent.Dispose();
-                            _noActiveSubmissionsEvent = null;
-                        }
+                    if (_executionCancellationTokenSource != null)
+                    {
+                        _executionCancellationTokenSource.Cancel();
+                        _executionCancellationTokenSource = null;
+                    }
 
-                        if (_noNodesActiveEvent != null)
-                        {
-                            _noNodesActiveEvent.Dispose();
-                            _noNodesActiveEvent = null;
-                        }
+                    if (_noActiveSubmissionsEvent != null)
+                    {
+                        _noActiveSubmissionsEvent.Dispose();
+                        _noActiveSubmissionsEvent = null;
+                    }
 
-                        if (ReferenceEquals(this, s_singletonInstance))
-                        {
-                            s_singletonInstance = null;
-                        }
+                    if (_noNodesActiveEvent != null)
+                    {
+                        _noNodesActiveEvent.Dispose();
+                        _noNodesActiveEvent = null;
+                    }
 
-                        _disposed = true;
+                    if (ReferenceEquals(this, s_singletonInstance))
+                    {
+                        s_singletonInstance = null;
                     }
+
+                    _disposed = true;
                 }
             }
         }
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmission.cs b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
index 1dba5f10f78..7ef719402d2 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmission.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
@@ -187,7 +187,7 @@ public override BuildResult Execute()
             ExecuteAsync(null, null, _legacyThreadingSemantics);
             if (_legacyThreadingSemantics)
             {
-                RequestBuilder.WaitWithBuilderThreadStart(new[] { WaitHandle }, false, legacyThreadingData, SubmissionId);
+                RequestBuilder.WaitWithBuilderThreadStart([WaitHandle], false, legacyThreadingData, SubmissionId);
             }
             else
             {
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index 642f1b1b024..c23b5134407 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -467,10 +467,11 @@ private bool TryLaunchServer()
 
             try
             {
-                string[] msBuildServerOptions = new string[] {
+                string[] msBuildServerOptions =
+                [
                     "/nologo",
                     "/nodemode:8"
-                };
+                ];
                 NodeLauncher nodeLauncher = new NodeLauncher();
                 CommunicationsUtilities.Trace("Starting Server...");
                 Process msbuildProcess = nodeLauncher.Start(_msbuildLocation, string.Join(" ", msBuildServerOptions), nodeId: 0);
diff --git a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
index 4c2be1f5a97..9e9ee1d0bf8 100644
--- a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
+++ b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
@@ -205,14 +205,15 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
                     // will be returned by WaitAny if multiple wait handles are signalled. We prefer to have the
                     // terminate event triggered so that we cannot get into a situation where packets are being
                     // spammed to the client and it never gets an opportunity to shutdown.
-                    WaitHandle[] handles = new WaitHandle[] {
-                    localPacketPumpShutdownEvent,
+                    WaitHandle[] handles =
+                    [
+                        localPacketPumpShutdownEvent,
 #if FEATURE_APM
-                    result.AsyncWaitHandle
+                        result.AsyncWaitHandle
 #else
-                    ((IAsyncResult)readTask).AsyncWaitHandle
+                        ((IAsyncResult)readTask).AsyncWaitHandle
 #endif
-                    };
+                    ];
                     int waitId = WaitHandle.WaitAny(handles);
                     switch (waitId)
                     {
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 4fc3f6db70a..ed79f9d09d6 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -283,8 +283,11 @@ public void CleanupForBuild()
                         throw new AggregateException(deactivateExceptions);
                     }
 
-                    var buildCheckManager = (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)!.Instance;
+                    IBuildCheckManagerProvider buildCheckProvider = (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider);
+                    var buildCheckManager = buildCheckProvider!.Instance;
                     buildCheckManager.FinalizeProcessing(_nodeLoggingContext);
+                    // Clears the instance so that next call (on node reuse) to 'GetComponent' leads to reinitialization.
+                    buildCheckProvider.ShutdownComponent();
                 },
                 isLastTask: true);
 
diff --git a/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
index 8bfb43b1ecb..3defd87986c 100644
--- a/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
+++ b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
@@ -107,14 +107,14 @@ public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)
                 FileAccessPolicy.AllowAll | FileAccessPolicy.ReportAccess);
 
             // Support shared compilation
-            info.FileAccessManifest.ChildProcessesToBreakawayFromSandbox = new BreakawayChildProcess[]
-            {
+            info.FileAccessManifest.ChildProcessesToBreakawayFromSandbox =
+            [
 #if RUNTIME_TYPE_NETCORE
                 new BreakawayChildProcess(NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet", "vbcscompiler.dll", CommandLineArgsSubstringContainmentIgnoreCase: true)
 #else
                 new BreakawayChildProcess(NativeMethodsShared.IsWindows ? "VBCSCompiler.exe" : "VBCSCompiler")
 #endif
-            };
+            ];
             info.FileAccessManifest.MonitorChildProcesses = true;
             info.FileAccessManifest.IgnoreReparsePoints = true;
             info.FileAccessManifest.UseExtraThreadToDrainNtClose = false;
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
index 68843247305..70ec3d41487 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
@@ -420,7 +420,7 @@ private void PacketPumpProc()
                 // will be returned by WaitAny if multiple wait handles are signalled.  We prefer to have the
                 // terminate event triggered so that we cannot get into a situation where packets are being
                 // spammed to the endpoint and it never gets an opportunity to shutdown.
-                WaitHandle[] handles = new WaitHandle[] { _terminatePacketPump, _packetAvailable };
+                WaitHandle[] handles = [_terminatePacketPump, _packetAvailable];
 
                 bool exitLoop = false;
                 do
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 8804918dbc0..1d42c48cd14 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -9,8 +9,6 @@
 
 using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;
 
-#nullable disable
-
 namespace Microsoft.Build.BackEnd.Logging
 {
     /// <summary>
@@ -27,84 +25,84 @@ internal sealed class EventSourceSink :
         /// <summary>
         /// This event is raised to log a message.
         /// </summary>
-        public event BuildMessageEventHandler MessageRaised;
+        public event BuildMessageEventHandler? MessageRaised;
 
         /// <summary>
         /// This event is raised to log an error.
         /// </summary>
-        public event BuildErrorEventHandler ErrorRaised;
+        public event BuildErrorEventHandler? ErrorRaised;
 
         /// <summary>
         /// This event is raised to log a warning.
         /// </summary>
-        public event BuildWarningEventHandler WarningRaised;
+        public event BuildWarningEventHandler? WarningRaised;
 
         /// <summary>
         /// this event is raised to log the start of a build
         /// </summary>
-        public event BuildStartedEventHandler BuildStarted;
+        public event BuildStartedEventHandler? BuildStarted;
 
         /// <summary>
         /// this event is raised to log the end of a build
         /// </summary>
-        public event BuildFinishedEventHandler BuildFinished;
+        public event BuildFinishedEventHandler? BuildFinished;
 
         /// <summary>
         /// this event is raised to log the start of a project build
         /// </summary>
-        public event ProjectStartedEventHandler ProjectStarted;
+        public event ProjectStartedEventHandler? ProjectStarted;
 
         /// <summary>
         /// this event is raised to log the end of a project build
         /// </summary>
-        public event ProjectFinishedEventHandler ProjectFinished;
+        public event ProjectFinishedEventHandler? ProjectFinished;
 
         /// <summary>
         /// this event is raised to log the start of a target build
         /// </summary>
-        public event TargetStartedEventHandler TargetStarted;
+        public event TargetStartedEventHandler? TargetStarted;
 
         /// <summary>
         /// this event is raised to log the end of a target build
         /// </summary>
-        public event TargetFinishedEventHandler TargetFinished;
+        public event TargetFinishedEventHandler? TargetFinished;
 
         /// <summary>
         /// this event is raised to log the start of task execution
         /// </summary>
-        public event TaskStartedEventHandler TaskStarted;
+        public event TaskStartedEventHandler? TaskStarted;
 
         /// <summary>
         /// this event is raised to log the end of task execution
         /// </summary>
-        public event TaskFinishedEventHandler TaskFinished;
+        public event TaskFinishedEventHandler? TaskFinished;
 
         /// <summary>
         /// this event is raised to log a custom event
         /// </summary>
-        public event CustomBuildEventHandler CustomEventRaised;
+        public event CustomBuildEventHandler? CustomEventRaised;
 
         /// <summary>
         /// this event is raised to log build status events, such as
         /// build/project/target/task started/stopped
         /// </summary>
-        public event BuildStatusEventHandler StatusEventRaised;
+        public event BuildStatusEventHandler? StatusEventRaised;
 
         /// <summary>
         /// This event is raised to log that some event has
         /// occurred.  It is raised on every event.
         /// </summary>
-        public event AnyEventHandler AnyEventRaised;
+        public event AnyEventHandler? AnyEventRaised;
 
         /// <summary>
         /// This event is raised to log telemetry.
         /// </summary>
-        public event TelemetryEventHandler TelemetryLogged;
+        public event TelemetryEventHandler? TelemetryLogged;
 
         /// <summary>
         /// This event is raised to log BuildCheck events.
         /// </summary>
-        internal event BuildCheckEventHandler BuildCheckEventRaised;
+        internal event BuildCheckEventHandler? BuildCheckEventRaised;
         #endregion
 
         #region Properties
@@ -112,7 +110,7 @@ internal sealed class EventSourceSink :
         /// Provide a friendly name for the sink to make it easier to differentiate during
         /// debugging and display
         /// </summary>
-        public string Name
+        public string? Name
         {
             get;
             set;
@@ -224,57 +222,67 @@ public void Consume(BuildEventArgs buildEvent, int sinkId)
         /// </summary>
         public void Consume(BuildEventArgs buildEvent)
         {
+
             switch (buildEvent)
             {
                 case BuildMessageEventArgs buildMessageEvent:
-                    RaiseMessageEvent(null, buildMessageEvent);
+                    RaiseEvent(buildMessageEvent, args => MessageRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
                 case TaskStartedEventArgs taskStartedEvent:
-                    RaiseTaskStartedEvent(null, taskStartedEvent);
+                    ArgsHandler<TaskStartedEventArgs> taskStartedFollowUp = args => RaiseEvent(args, args=> StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(taskStartedEvent, args => TaskStarted?.Invoke(null, args), taskStartedFollowUp);
                     break;
                 case TaskFinishedEventArgs taskFinishedEvent:
-                    RaiseTaskFinishedEvent(null, taskFinishedEvent);
+                    ArgsHandler<TaskFinishedEventArgs> taskFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(taskFinishedEvent, args => TaskFinished?.Invoke(null, args), taskFinishedFollowUp);
                     break;
                 case TargetStartedEventArgs targetStartedEvent:
-                    RaiseTargetStartedEvent(null, targetStartedEvent);
+                    ArgsHandler<TargetStartedEventArgs> targetStartedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(targetStartedEvent, args => TargetStarted?.Invoke(null, args), targetStartedFollowUp);
                     break;
                 case TargetFinishedEventArgs targetFinishedEvent:
-                    RaiseTargetFinishedEvent(null, targetFinishedEvent);
+                    ArgsHandler<TargetFinishedEventArgs> targetFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(targetFinishedEvent, args => TargetFinished?.Invoke(null, args), targetFinishedFollowUp);
                     break;
                 case ProjectStartedEventArgs projectStartedEvent:
-                    RaiseProjectStartedEvent(null, projectStartedEvent);
+                    ArgsHandler<ProjectStartedEventArgs> projectStartedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(projectStartedEvent, args => ProjectStarted?.Invoke(null, args), projectStartedFollowUp);
                     break;
                 case ProjectFinishedEventArgs projectFinishedEvent:
-                    RaiseProjectFinishedEvent(null, projectFinishedEvent);
+                    ArgsHandler<ProjectFinishedEventArgs> projectFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(projectFinishedEvent, args => ProjectFinished?.Invoke(null, args), projectFinishedFollowUp);
                     break;
                 case BuildStartedEventArgs buildStartedEvent:
                     HaveLoggedBuildStartedEvent = true;
-                    RaiseBuildStartedEvent(null, buildStartedEvent);
+                    ArgsHandler<BuildStartedEventArgs> BuildStartedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(buildStartedEvent, args => BuildStarted?.Invoke(null, args), BuildStartedFollowUp);
                     break;
                 case BuildFinishedEventArgs buildFinishedEvent:
                     HaveLoggedBuildFinishedEvent = true;
-                    RaiseBuildFinishedEvent(null, buildFinishedEvent);
+                    ArgsHandler<BuildFinishedEventArgs> BuildFinishedFollowUp = args => RaiseEvent(args, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
+                    RaiseEvent(buildFinishedEvent, args => BuildFinished?.Invoke(null, args), BuildFinishedFollowUp);
                     break;
                 case BuildCanceledEventArgs buildCanceledEvent:
-                    RaiseStatusEvent(null, buildCanceledEvent);
+
+                    RaiseEvent(buildCanceledEvent, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
                 case CustomBuildEventArgs customBuildEvent:
-                    RaiseCustomEvent(null, customBuildEvent);
+                    RaiseEvent(customBuildEvent, args => CustomEventRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
                 case BuildStatusEventArgs buildStatusEvent:
-                    RaiseStatusEvent(null, buildStatusEvent);
+                    RaiseEvent(buildStatusEvent, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
                 case BuildWarningEventArgs buildWarningEvent:
-                    RaiseWarningEvent(null, buildWarningEvent);
+                    RaiseEvent(buildWarningEvent, args => WarningRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
                 case BuildErrorEventArgs buildErrorEvent:
-                    RaiseErrorEvent(null, buildErrorEvent);
+                    RaiseEvent(buildErrorEvent, args => ErrorRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
                 case TelemetryEventArgs telemetryEvent:
-                    RaiseTelemetryEvent(null, telemetryEvent);
+                    RaiseEvent(telemetryEvent, args => TelemetryLogged?.Invoke(null, args), null);
                     break;
                 case BuildCheckEventArgs buildCheckEvent:
-                    RaiseBuildCheckEvent(null, buildCheckEvent);
+                    RaiseEvent(buildCheckEvent, args => BuildCheckEventRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
 
                 default:
@@ -288,7 +296,7 @@ public void Consume(BuildEventArgs buildEvent)
         /// </summary>
         public void ShutDown()
         {
-            this.UnregisterAllEventHandlers();
+            UnregisterAllEventHandlers();
         }
         #endregion
 
@@ -321,611 +329,80 @@ internal void UnregisterAllEventHandlers()
 
         #region Private Methods
 
-        /// <summary>
-        /// Raises a message event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">BuildMessageEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseMessageEvent(object sender, BuildMessageEventArgs buildEvent)
-        {
-            if (MessageRaised != null)
-            {
-                try
-                {
-                    MessageRaised(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseAnyEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises an error event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">BuildErrorEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseErrorEvent(object sender, BuildErrorEventArgs buildEvent)
-        {
-            if (ErrorRaised != null)
-            {
-                try
-                {
-                    ErrorRaised(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseAnyEvent(sender, buildEvent);
-        }
+        public delegate void ArgsHandler<in TArgs>(TArgs e) where TArgs : BuildEventArgs;
 
         /// <summary>
-        /// Raises a warning event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">BuildWarningEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseWarningEvent(object sender, BuildWarningEventArgs buildEvent)
-        {
-            if (WarningRaised != null)
-            {
-                try
-                {
-                    WarningRaised(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseAnyEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "build started" event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">BuildStartedEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseBuildStartedEvent(object sender, BuildStartedEventArgs buildEvent)
-        {
-            if (BuildStarted != null)
-            {
-                try
-                {
-                    BuildStarted(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "build finished" event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">BuildFinishedEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseBuildFinishedEvent(object sender, BuildFinishedEventArgs buildEvent)
-        {
-            if (BuildFinished != null)
-            {
-                try
-                {
-                    BuildFinished(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "project build started" event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">ProjectStartedEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseProjectStartedEvent(object sender, ProjectStartedEventArgs buildEvent)
-        {
-            if (ProjectStarted != null)
-            {
-                try
-                {
-                    ProjectStarted(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "project build finished" event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">ProjectFinishedEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseProjectFinishedEvent(object sender, ProjectFinishedEventArgs buildEvent)
-        {
-            if (ProjectFinished != null)
-            {
-                try
-                {
-                    ProjectFinished(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "target build started" event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">TargetStartedEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseTargetStartedEvent(object sender, TargetStartedEventArgs buildEvent)
-        {
-            if (TargetStarted != null)
-            {
-                try
-                {
-                    TargetStarted(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "target build finished" event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">TargetFinishedEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseTargetFinishedEvent(object sender, TargetFinishedEventArgs buildEvent)
-        {
-            if (TargetFinished != null)
-            {
-                try
-                {
-                    TargetFinished(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "task execution started" event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">TaskStartedEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseTaskStartedEvent(object sender, TaskStartedEventArgs buildEvent)
-        {
-            if (TaskStarted != null)
-            {
-                try
-                {
-                    TaskStarted(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a "task finished executing" event to all registered loggers.
+        /// Raises a message event to all registered loggers.
         /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">TaskFinishedEventArgs</param>
+        /// <param name="buildEvent">event args</param>
+        /// <param name="handler">argument handler that invokes the respective event</param>
+        /// <param name="followUpHandler"> either anyEvent or statusEvent, it is invoked after the Event has been processed</param>
         /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
         /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
         /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseTaskFinishedEvent(object sender, TaskFinishedEventArgs buildEvent)
+        private void RaiseEvent<TArgs>(TArgs buildEvent, ArgsHandler<TArgs> handler, ArgsHandler<TArgs>? followUpHandler)
+            where TArgs : BuildEventArgs
         {
-            if (TaskFinished != null)
+            try
             {
-                try
-                {
-                    TaskFinished(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
+                handler(buildEvent);
             }
-
-            RaiseStatusEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a custom event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">CustomBuildEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseCustomEvent(object sender, CustomBuildEventArgs buildEvent)
-        {
-            if (CustomEventRaised != null)
+            catch (LoggerException)
             {
-                try
-                {
-                    CustomEventRaised(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
+                // if a logger has failed politely, abort immediately
+                // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
+                // if a fellow logger is throwing in an event handler.
+                UnregisterAllEventHandlers();
+                throw;
             }
-
-            RaiseAnyEvent(sender, buildEvent);
-        }
-
-        /// <summary>
-        /// Raises a catch-all build status event to all registered loggers.
-        /// </summary>
-        /// <param name="sender">sender of the event</param>
-        /// <param name="buildEvent">BuildStatusEventArgs</param>
-        /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
-        /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
-        /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseStatusEvent(object sender, BuildStatusEventArgs buildEvent)
-        {
-            if (StatusEventRaised != null)
+            catch (Exception exception)
             {
-                try
-                {
-                    StatusEventRaised(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
+                // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
+                // if a fellow logger is throwing in an event handler.
+                UnregisterAllEventHandlers();
 
-            RaiseAnyEvent(sender, buildEvent);
-        }
-
-        private void RaiseBuildCheckEvent(object sender, BuildCheckEventArgs buildEvent)
-        {
-            if (BuildCheckEventRaised != null)
-            {
-                try
-                {
-                    BuildCheckEventRaised(sender, buildEvent);
-                }
-                catch (LoggerException)
+                if (ExceptionHandling.IsCriticalException(exception))
                 {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
                     throw;
                 }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
 
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
+                InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
             }
-
-            RaiseAnyEvent(sender, buildEvent);
+            followUpHandler?.Invoke(buildEvent);
         }
 
         /// <summary>
         /// Raises a catch-all build event to all registered loggers.
+        /// Keeping it separate since it also dumps the Exception to file as opposed to all other events.
         /// </summary>
-        /// <param name="sender">sender of the event</param>
         /// <param name="buildEvent">Build EventArgs</param>
         /// <exception cref="LoggerException">When EventHandler raises an logger exception the LoggerException is rethrown</exception>
         /// <exception cref="InternalLoggerException">Any exceptions which are not LoggerExceptions are wrapped in an InternalLoggerException</exception>
         /// <exception cref="Exception">ExceptionHandling.IsCriticalException exceptions will not be wrapped</exception>
-        private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent)
+        private void RaiseAnyEvent(BuildEventArgs buildEvent)
         {
             if (AnyEventRaised != null)
             {
                 try
                 {
-                    AnyEventRaised(sender, buildEvent);
+                    AnyEventRaised(null, buildEvent);
                 }
                 catch (LoggerException exception)
                 {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    UnregisterAllEventHandlers();
+                    if (ExceptionHandling.IsCriticalException(exception))
+                    {
+                        // if a logger has failed politely, abort immediately
+                        // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
+                        // if a fellow logger is throwing in an event handler.
+                        UnregisterAllEventHandlers();
 
-                    // We ought to dump this further up the stack, but if for example a task is logging an event within a
-                    // catch(Exception) block and not rethrowing it, there's the possibility that this exception could
-                    // just get silently eaten.  So better to have duplicates than to not log the problem at all. :)
-                    ExceptionHandling.DumpExceptionToFile(exception);
+                        // We ought to dump this further up the stack, but if for example a task is logging an event within a
+                        // catch(Exception) block and not rethrowing it, there's the possibility that this exception could
+                        // just get silently eaten.  So better to have duplicates than to not log the problem at all. :)
+                        ExceptionHandling.DumpExceptionToFile(exception);
 
-                    throw;
+                        throw;
+                    }
                 }
                 catch (Exception exception)
                 {
@@ -944,41 +421,6 @@ private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent)
             }
         }
 
-        /// <summary>
-        /// Raises the a telemetry event to all registered loggers.
-        /// </summary>
-        private void RaiseTelemetryEvent(object sender, TelemetryEventArgs buildEvent)
-        {
-            if (TelemetryLogged != null)
-            {
-                try
-                {
-                    TelemetryLogged(sender, buildEvent);
-                }
-                catch (LoggerException)
-                {
-                    // if a logger has failed politely, abort immediately
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-                    throw;
-                }
-                catch (Exception exception)
-                {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    if (ExceptionHandling.IsCriticalException(exception))
-                    {
-                        throw;
-                    }
-
-                    InternalLoggerException.Throw(exception, buildEvent, "FatalErrorWhileLogging", false);
-                }
-            }
-        }
-
         #endregion
         #endregion
     }
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 104dac56f6f..b57ab84ae82 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -555,6 +555,20 @@ BuildEventContext LogProjectStarted(
             int evaluationId = BuildEventContext.InvalidEvaluationId,
             int projectContextId = BuildEventContext.InvalidProjectContextId);
 
+        void LogProjectStarted(ProjectStartedEventArgs args);
+
+        ProjectStartedEventArgs CreateProjectStarted(
+            BuildEventContext nodeBuildEventContext,
+            int submissionId,
+            int configurationId,
+            BuildEventContext parentBuildEventContext,
+            string projectFile,
+            string targetNames,
+            IEnumerable<DictionaryEntry> properties,
+            IEnumerable<DictionaryEntry> items,
+            int evaluationId = BuildEventContext.InvalidEvaluationId,
+            int projectContextId = BuildEventContext.InvalidProjectContextId);
+
         /// <summary>
         /// Log that the project has finished
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index df990251a96..b5ed777d161 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -211,6 +211,11 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler
         /// </summary>
         private readonly ISet<int> _buildSubmissionIdsThatHaveLoggedErrors = new HashSet<int>();
 
+        /// <summary>
+        /// A list of build submission IDs that have logged errors through buildcheck.  If an error is logged outside of a submission, the submission ID is <see cref="BuildEventContext.InvalidSubmissionId"/>.
+        /// </summary>
+        private readonly ISet<int> _buildSubmissionIdsThatHaveLoggedBuildcheckErrors = new HashSet<int>();
+
         /// <summary>
         /// A list of warnings to treat as errors for an associated <see cref="BuildEventContext"/>.  If an empty set, all warnings are treated as errors.
         /// </summary>
@@ -620,6 +625,11 @@ public bool IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent
         /// <returns><code>true</code> if the build submission logged an errors, otherwise <code>false</code>.</returns>
         public bool HasBuildSubmissionLoggedErrors(int submissionId)
         {
+            if (_buildSubmissionIdsThatHaveLoggedBuildcheckErrors.Contains(submissionId))
+            {
+                return true;
+            }
+
             // Warnings as errors are not tracked if the user did not specify to do so
             if (WarningsAsErrors == null && _warningsAsErrorsByProject == null)
             {
@@ -730,6 +740,11 @@ public void AddWarningsAsMessages(BuildEventContext buildEventContext, ISet<stri
         /// <param name="codes">Codes to add</param>
         private void AddWarningsAsMessagesOrErrors(ref IDictionary<WarningsConfigKey, ISet<string>> warningsByProject, BuildEventContext buildEventContext, ISet<string> codes)
         {
+            if (codes == null)
+            {
+                return;
+            }
+
             lock (_lockObject)
             {
                 WarningsConfigKey key = GetWarningsConfigKey(buildEventContext);
@@ -854,6 +869,8 @@ public void InitializeComponent(IBuildComponentHost buildComponentHost)
                 _onlyLogCriticalEvents = buildComponentHost.BuildParameters.OnlyLogCriticalEvents;
 
                 _serviceState = LoggingServiceState.Initialized;
+
+                _buildEngineDataRouter = (buildComponentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)?.BuildEngineDataRouter;
             }
         }
 
@@ -1636,14 +1653,25 @@ private void RouteBuildEvent(object loggingEvent)
 
             if (buildEventArgs is BuildErrorEventArgs errorEvent)
             {
-                // Keep track of build submissions that have logged errors.  If there is no build context, add BuildEventContext.InvalidSubmissionId.
-                _buildSubmissionIdsThatHaveLoggedErrors.Add(errorEvent.BuildEventContext?.SubmissionId ?? BuildEventContext.InvalidSubmissionId);
+                int submissionId = errorEvent.BuildEventContext?.SubmissionId ?? BuildEventContext.InvalidSubmissionId;
+
+                if (buildEventArgs is BuildCheckResultError)
+                {
+                    _buildSubmissionIdsThatHaveLoggedBuildcheckErrors.Add(submissionId);
+                }
+                else
+                {
+                    // Keep track of build submissions that have logged errors.  If there is no build context, add BuildEventContext.InvalidSubmissionId.
+                    _buildSubmissionIdsThatHaveLoggedErrors.Add(submissionId);
+                }
             }
 
-            if (buildEventArgs is BuildCheckResultError checkResultError)
+            // If this is BuildCheck-ed build - add the warnings promotability/demotability to the service
+            if (buildEventArgs is ProjectStartedEventArgs projectStartedEvent && this._componentHost.BuildParameters.IsBuildCheckEnabled)
             {
-                // If the specified BuildCheckResultError was issued, an empty ISet<string> signifies that the specified build check warnings should be treated as errors.
-                AddWarningsAsErrors(checkResultError.BuildEventContext, new HashSet<string>());
+                AddWarningsAsErrors(projectStartedEvent.BuildEventContext, projectStartedEvent.WarningsAsErrors);
+                AddWarningsAsMessages(projectStartedEvent.BuildEventContext, projectStartedEvent.WarningsAsMessages);
+                AddWarningsNotAsErrors(projectStartedEvent.BuildEventContext, projectStartedEvent.WarningsNotAsErrors);
             }
 
             if (buildEventArgs is ProjectFinishedEventArgs projectFinishedEvent && projectFinishedEvent.BuildEventContext != null)
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 40762761917..c6f711eb8c6 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -497,6 +497,39 @@ public BuildEventContext LogProjectStarted(
             IEnumerable<DictionaryEntry> items,
             int evaluationId = BuildEventContext.InvalidEvaluationId,
             int projectContextId = BuildEventContext.InvalidProjectContextId)
+        {
+            var args = CreateProjectStarted(nodeBuildEventContext,
+                submissionId,
+                configurationId,
+                parentBuildEventContext,
+                projectFile,
+                targetNames,
+                properties,
+                items,
+                evaluationId,
+                projectContextId);
+
+            this.LogProjectStarted(args);
+
+            return args.BuildEventContext;
+        }
+
+        public void LogProjectStarted(ProjectStartedEventArgs buildEvent)
+        {
+            ProcessLoggingEvent(buildEvent);
+        }
+
+        public ProjectStartedEventArgs CreateProjectStarted(
+            BuildEventContext nodeBuildEventContext,
+            int submissionId,
+            int configurationId,
+            BuildEventContext parentBuildEventContext,
+            string projectFile,
+            string targetNames,
+            IEnumerable<DictionaryEntry> properties,
+            IEnumerable<DictionaryEntry> items,
+            int evaluationId = BuildEventContext.InvalidEvaluationId,
+            int projectContextId = BuildEventContext.InvalidProjectContextId)
         {
             ErrorUtilities.VerifyThrow(nodeBuildEventContext != null, "Need a nodeBuildEventContext");
 
@@ -560,9 +593,7 @@ public BuildEventContext LogProjectStarted(
                     buildRequestConfiguration.ToolsVersion);
             buildEvent.BuildEventContext = projectBuildEventContext;
 
-            ProcessLoggingEvent(buildEvent);
-
-            return projectBuildEventContext;
+            return buildEvent;
         }
 
         /// <summary>
@@ -798,13 +829,17 @@ public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)
 
         #endregion
 
+#nullable enable
+        private IBuildEngineDataRouter? _buildEngineDataRouter;
+
         public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext checkContext)
-            => BuildCheckManagerProvider.GlobalBuildEngineDataRouter?.ProcessPropertyRead(propertyReadInfo, checkContext);
+            => _buildEngineDataRouter?.ProcessPropertyRead(propertyReadInfo, checkContext);
 
         public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext checkContext)
-            => BuildCheckManagerProvider.GlobalBuildEngineDataRouter?.ProcessPropertyWrite(propertyWriteInfo, checkContext);
+            => _buildEngineDataRouter?.ProcessPropertyWrite(propertyWriteInfo, checkContext);
 
         public void ProcessProjectEvaluationStarted(ICheckContext checkContext, string projectFullPath)
-            => BuildCheckManagerProvider.GlobalBuildEngineDataRouter?.ProcessProjectEvaluationStarted(checkContext, projectFullPath);
+            => _buildEngineDataRouter?.ProcessProjectEvaluationStarted(checkContext, projectFullPath);
+#nullable disable
     }
 }
diff --git a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
index 5676d9fecf1..e03c8ed13e7 100644
--- a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
@@ -57,9 +57,16 @@ internal void LogBuildFinished(bool success)
         /// <param name="requestEntry">The build request entry for this project.</param>
         /// <returns>The BuildEventContext to use for this project.</returns>
         internal ProjectLoggingContext LogProjectStarted(BuildRequestEntry requestEntry)
+        {
+            (ProjectStartedEventArgs arg, ProjectLoggingContext ctx) = CreateProjectLoggingContext(requestEntry);
+            LoggingService.LogProjectStarted(arg);
+            return ctx;
+        }
+
+        internal (ProjectStartedEventArgs, ProjectLoggingContext) CreateProjectLoggingContext(BuildRequestEntry requestEntry)
         {
             ErrorUtilities.VerifyThrow(this.IsValid, "Build not started.");
-            return new ProjectLoggingContext(this, requestEntry);
+            return ProjectLoggingContext.CreateLoggingContext(this, requestEntry);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 06614c42125..22687557135 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -71,6 +71,45 @@ internal ProjectLoggingContext(
         {
         }
 
+        /// <summary>
+        /// Creates ProjectLoggingContext, without logging ProjectStartedEventArgs as a side effect.
+        /// The ProjectStartedEventArgs is returned as well - so that it can be later logged explicitly
+        /// </summary>
+        public static (ProjectStartedEventArgs, ProjectLoggingContext) CreateLoggingContext(
+            NodeLoggingContext nodeLoggingContext, BuildRequestEntry requestEntry)
+        {
+            ProjectStartedEventArgs args = CreateProjectStarted(
+                nodeLoggingContext,
+                requestEntry.Request.SubmissionId,
+                requestEntry.Request.ConfigurationId,
+                requestEntry.RequestConfiguration.ProjectFullPath,
+                requestEntry.Request.Targets,
+                requestEntry.RequestConfiguration.ToolsVersion,
+                requestEntry.RequestConfiguration.Project.PropertiesToBuildWith,
+                requestEntry.RequestConfiguration.Project.ItemsToBuildWith,
+                requestEntry.Request.ParentBuildEventContext,
+                requestEntry.RequestConfiguration.Project.EvaluationId,
+                requestEntry.Request.ProjectContextId);
+
+            return (args, new ProjectLoggingContext(nodeLoggingContext, args));
+        }
+
+        private ProjectLoggingContext(
+            NodeLoggingContext nodeLoggingContext,
+            ProjectStartedEventArgs projectStarted)
+        : base(nodeLoggingContext, projectStarted.BuildEventContext)
+        {
+            _projectFullPath = projectStarted.ProjectFile;
+
+            // No need to log a redundant message in the common case
+            if (projectStarted.ToolsVersion != "Current")
+            {
+                LoggingService.LogComment(this.BuildEventContext, MessageImportance.Low, "ToolsVersionInEffectForBuild", projectStarted.ToolsVersion);
+            }
+
+            this.IsValid = true;
+        }
+
         /// <summary>
         /// Constructs a project logging contexts.
         /// </summary>
@@ -122,6 +161,37 @@ private static BuildEventContext CreateInitialContext(
             BuildEventContext parentBuildEventContext,
             int evaluationId,
             int projectContextId)
+        {
+            ProjectStartedEventArgs args = CreateProjectStarted(
+                nodeLoggingContext,
+                submissionId,
+                configurationId,
+                projectFullPath,
+                targets,
+                toolsVersion,
+                projectProperties,
+                projectItems,
+                parentBuildEventContext,
+                evaluationId,
+                projectContextId);
+
+            nodeLoggingContext.LoggingService.LogProjectStarted(args);
+
+            return args.BuildEventContext;
+        }
+
+        private static ProjectStartedEventArgs CreateProjectStarted(
+            NodeLoggingContext nodeLoggingContext,
+            int submissionId,
+            int configurationId,
+            string projectFullPath,
+            List<string> targets,
+            string toolsVersion,
+            PropertyDictionary<ProjectPropertyInstance> projectProperties,
+            IItemDictionary<ProjectItemInstance> projectItems,
+            BuildEventContext parentBuildEventContext,
+            int evaluationId,
+            int projectContextId)
         {
             IEnumerable<DictionaryEntry> properties = null;
             IEnumerable<DictionaryEntry> items = null;
@@ -137,7 +207,7 @@ private static BuildEventContext CreateInitialContext(
             {
                 if (projectProperties is null)
                 {
-                    properties = Enumerable.Empty<DictionaryEntry>();
+                    properties = [];
                 }
                 else if (Traits.LogAllEnvironmentVariables)
                 {
@@ -148,7 +218,7 @@ private static BuildEventContext CreateInitialContext(
                     properties = projectProperties.Filter(p => p is not EnvironmentDerivedProjectPropertyInstance || EnvironmentUtilities.IsWellKnownEnvironmentDerivedProperty(p.Name), p => new DictionaryEntry(p.Name, p.EvaluatedValue));
                 }
 
-                items = projectItems?.GetCopyOnReadEnumerable(item => new DictionaryEntry(item.ItemType, new TaskItem(item))) ?? Enumerable.Empty<DictionaryEntry>();
+                items = projectItems?.GetCopyOnReadEnumerable(item => new DictionaryEntry(item.ItemType, new TaskItem(item))) ?? [];
             }
 
             if (projectProperties != null &&
@@ -171,7 +241,7 @@ private static BuildEventContext CreateInitialContext(
                 properties = projectPropertiesToSerialize.Select((ProjectPropertyInstance property) => new DictionaryEntry(property.Name, property.EvaluatedValue));
             }
 
-            return loggingService.LogProjectStarted(
+            return loggingService.CreateProjectStarted(
                 nodeLoggingContext.BuildEventContext,
                 submissionId,
                 configurationId,
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
index d7b5ea98cca..5f3ff599c99 100644
--- a/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
@@ -30,7 +30,7 @@ public CacheContext(
             MSBuildFileSystemBase fileSystem,
             ProjectGraph? graph = null,
             IReadOnlyCollection<ProjectGraphEntryPoint>? graphEntryPoints = null)
-            : this(pluginSettings, fileSystem, requestedTargets: Array.Empty<string>(), graph, graphEntryPoints)
+            : this(pluginSettings, fileSystem, requestedTargets: [], graph, graphEntryPoints)
         {
         }
 
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index d573f4bdc74..43192499a9e 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -454,7 +454,7 @@ public void PostCacheRequest(CacheRequest cacheRequest, CancellationToken cancel
 
                 BuildRequestData buildRequest = new BuildRequestData(
                     cacheRequest.Configuration.Project,
-                    cacheRequest.Submission.BuildRequestData?.TargetNames.ToArray() ?? Array.Empty<string>());
+                    cacheRequest.Submission.BuildRequestData?.TargetNames.ToArray() ?? []);
                 BuildEventContext buildEventContext = _loggingService.CreateProjectCacheBuildEventContext(
                     cacheRequest.Submission.SubmissionId,
                     evaluationId: cacheRequest.Configuration.Project.EvaluationId,
@@ -650,7 +650,7 @@ private IReadOnlyCollection<ProjectGraphEntryPoint> GetGraphEntryPoints(BuildReq
             }
             else
             {
-                return new[] { new ProjectGraphEntryPoint(configuration.ProjectFullPath, globalProperties) };
+                return [new ProjectGraphEntryPoint(configuration.ProjectFullPath, globalProperties)];
             }
 
             static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromSolutionConfigurationXml(
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index b072bdbe462..73f84dd94a0 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -504,7 +504,7 @@ internal static List<string[]> CreateTargetLists(
                 // Separate target invocations for each individual target.
                 foreach (string targetName in targets)
                 {
-                    targetLists.Add(new[] { targetName });
+                    targetLists.Add([targetName]);
                 }
             }
             else
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 27bc3fa75be..0d9b660b451 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Globalization;
 using System.IO;
 using System.Linq;
@@ -401,7 +402,7 @@ public async Task BlockOnTargetInProgress(int blockingGlobalRequestId, string bl
 
             RaiseOnBlockedRequest(blockingGlobalRequestId, blockingTarget, partialBuildResult);
 
-            WaitHandle[] handles = new WaitHandle[] { _terminateEvent, _continueEvent };
+            WaitHandle[] handles = [_terminateEvent, _continueEvent];
 
             int handle;
             if (IsBuilderUsingLegacyThreadingSemantics(_componentHost, _requestEntry))
@@ -447,7 +448,7 @@ public void Reacquire()
             VerifyIsNotZombie();
             RaiseOnBlockedRequest(_requestEntry.Request.GlobalRequestId, String.Empty);
 
-            WaitHandle[] handles = new WaitHandle[] { _terminateEvent, _continueEvent };
+            WaitHandle[] handles = [_terminateEvent, _continueEvent];
 
             int handle = WaitHandle.WaitAny(handles);
 
@@ -505,7 +506,7 @@ public int RequestCores(object monitorLockObject, int requestedCores, bool waitF
             RaiseResourceRequest(ResourceRequest.CreateAcquireRequest(_requestEntry.Request.GlobalRequestId, requestedCores, waitForCores));
 
             // Wait for one of two events to be signaled: 1) The build was canceled, 2) The response to our request was received.
-            WaitHandle[] waitHandles = new WaitHandle[] { _terminateEvent, responseEvent };
+            WaitHandle[] waitHandles = [_terminateEvent, responseEvent];
             int waitResult;
 
             // Drop the lock so that the same task can call ReleaseCores from other threads to unblock itself.
@@ -956,7 +957,7 @@ private async Task<BuildResult[]> StartNewBuildRequests(FullyQualifiedBuildReque
             BuildResult[] results;
             if (waitForResults)
             {
-                WaitHandle[] handles = new WaitHandle[] { _terminateEvent, _continueEvent };
+                WaitHandle[] handles = [_terminateEvent, _continueEvent];
 
                 int handle;
                 if (IsBuilderUsingLegacyThreadingSemantics(_componentHost, _requestEntry))
@@ -1105,11 +1106,11 @@ private async Task<BuildResult> BuildProject()
             ErrorUtilities.VerifyThrow(_targetBuilder != null, "Target builder is null");
 
             // We consider this the entrypoint for the project build for purposes of BuildCheck processing 
-            bool isRestoring = _requestEntry.RequestConfiguration.GlobalProperties[MSBuildConstants.MSBuildIsRestoring] is null;
+            bool isRestoring = _requestEntry.RequestConfiguration.GlobalProperties[MSBuildConstants.MSBuildIsRestoring] is not null;
 
             var buildCheckManager = isRestoring
-                ? (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)!.Instance
-                : null;
+                ? null
+                : (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)!.Instance;
 
             buildCheckManager?.SetDataSource(BuildCheckDataSource.BuildExecution);
 
@@ -1154,15 +1155,10 @@ private async Task<BuildResult> BuildProject()
                     _requestEntry.Request.BuildEventContext);
             }
 
-            _projectLoggingContext = _nodeLoggingContext.LogProjectStarted(_requestEntry);
-            buildCheckManager?.StartProjectRequest(
-                _projectLoggingContext.BuildEventContext,
-                _requestEntry.RequestConfiguration.ProjectFullPath);
-
+            
             try
             {
-                // Now that the project has started, parse a few known properties which indicate warning codes to treat as errors or messages
-                ConfigureWarningsAsErrorsAndMessages();
+                HandleProjectStarted(buildCheckManager);
 
                 // Make sure to extract known immutable folders from properties and register them for fast up-to-date check
                 ConfigureKnownImmutableFolders();
@@ -1273,6 +1269,31 @@ private void SaveOperatingEnvironment()
             }
         }
 
+        private void HandleProjectStarted(IBuildCheckManager buildCheckManager)
+        {
+            (ProjectStartedEventArgs args, ProjectLoggingContext ctx) = _nodeLoggingContext.CreateProjectLoggingContext(_requestEntry);
+
+            _projectLoggingContext = ctx;
+            ConfigureWarningsAsErrorsAndMessages();
+            ILoggingService loggingService = _projectLoggingContext?.LoggingService;
+            BuildEventContext projectBuildEventContext = _projectLoggingContext?.BuildEventContext;
+
+            // We can set the warning as errors and messages only after the project logging context has been created (as it creates the new ProjectContextId)
+            if (buildCheckManager != null && loggingService != null && projectBuildEventContext != null)
+            {
+                args.WarningsAsErrors = loggingService.GetWarningsAsErrors(projectBuildEventContext).ToHashSet(StringComparer.OrdinalIgnoreCase);
+                args.WarningsAsMessages = loggingService.GetWarningsAsMessages(projectBuildEventContext).ToHashSet(StringComparer.OrdinalIgnoreCase);
+                args.WarningsNotAsErrors = loggingService.GetWarningsNotAsErrors(projectBuildEventContext).ToHashSet(StringComparer.OrdinalIgnoreCase);
+            }
+
+            // We can log the event only after the warning as errors and messages have been set and added
+            loggingService?.LogProjectStarted(args);
+
+            buildCheckManager?.StartProjectRequest(
+                new CheckLoggingContext(_nodeLoggingContext.LoggingService, _projectLoggingContext!.BuildEventContext),
+                _requestEntry.RequestConfiguration.ProjectFullPath);
+        }
+
         /// <summary>
         /// Sets the operationg environment to the initial build environment.
         /// </summary>
@@ -1369,14 +1390,14 @@ private void ConfigureWarningsAsErrorsAndMessages()
             // Ensure everything that is required is available at this time
             if (project != null && buildEventContext != null && loggingService != null && buildEventContext.ProjectInstanceId != BuildEventContext.InvalidProjectInstanceId)
             {
-                if (String.Equals(project.GetPropertyValue(MSBuildConstants.TreatWarningsAsErrors)?.Trim(), "true", StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(project.GetEngineRequiredPropertyValue(MSBuildConstants.TreatWarningsAsErrors)?.Trim(), "true", StringComparison.OrdinalIgnoreCase))
                 {
                     // If <MSBuildTreatWarningsAsErrors was specified then an empty ISet<string> signals the IEventSourceSink to treat all warnings as errors
                     loggingService.AddWarningsAsErrors(buildEventContext, new HashSet<string>());
                 }
                 else
                 {
-                    ISet<string> warningsAsErrors = ParseWarningCodes(project.GetPropertyValue(MSBuildConstants.WarningsAsErrors));
+                    ISet<string> warningsAsErrors = ParseWarningCodes(project.GetEngineRequiredPropertyValue(MSBuildConstants.WarningsAsErrors));
 
                     if (warningsAsErrors?.Count > 0)
                     {
@@ -1384,14 +1405,14 @@ private void ConfigureWarningsAsErrorsAndMessages()
                     }
                 }
 
-                ISet<string> warningsNotAsErrors = ParseWarningCodes(project.GetPropertyValue(MSBuildConstants.WarningsNotAsErrors));
+                ISet<string> warningsNotAsErrors = ParseWarningCodes(project.GetEngineRequiredPropertyValue(MSBuildConstants.WarningsNotAsErrors));
 
                 if (warningsNotAsErrors?.Count > 0)
                 {
                     loggingService.AddWarningsNotAsErrors(buildEventContext, warningsNotAsErrors);
                 }
 
-                ISet<string> warningsAsMessages = ParseWarningCodes(project.GetPropertyValue(MSBuildConstants.WarningsAsMessages));
+                ISet<string> warningsAsMessages = ParseWarningCodes(project.GetEngineRequiredPropertyValue(MSBuildConstants.WarningsAsMessages));
 
                 if (warningsAsMessages?.Count > 0)
                 {
@@ -1409,7 +1430,7 @@ private void ConfigureKnownImmutableFolders()
             }
         }
 
-        private ISet<string> ParseWarningCodes(string warnings)
+        private static ISet<string> ParseWarningCodes(string warnings)
         {
             if (String.IsNullOrWhiteSpace(warnings))
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index e9e1bf575a2..09567c2370f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -261,11 +261,11 @@ public bool BuildProjectFile(string projectFileName, string[] targetNames, Syste
         {
             VerifyActiveProxy();
             return BuildProjectFilesInParallel(
-                new string[] { projectFileName },
+                [projectFileName],
                 targetNames,
-                new IDictionary[] { globalProperties },
-                new IDictionary[] { targetOutputs },
-                new string[] { toolsVersion },
+                [globalProperties],
+                [targetOutputs],
+                [toolsVersion],
                 true,
                 false);
         }
@@ -1205,8 +1205,8 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
                     BuildResult[] results = await builderCallback.BuildProjects(
                         projectFileNames,
                         propertyDictionaries,
-                        toolsVersion ?? Array.Empty<string>(),
-                        targetNames ?? Array.Empty<string>(),
+                        toolsVersion ?? [],
+                        targetNames ?? [],
                         waitForResults: true,
                         skipNonexistentTargets: skipNonexistentTargets);
 
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
index 4d7abb22231..246f6b591b6 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
@@ -187,7 +187,7 @@ public IEnumerable<string> ActiveTargets
         {
             get
             {
-                VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Yielding, SchedulableRequestState.Blocked, SchedulableRequestState.Executing });
+                VerifyOneOfStates([SchedulableRequestState.Yielding, SchedulableRequestState.Blocked, SchedulableRequestState.Executing]);
                 return _activeTargetsWhenBlocked;
             }
         }
@@ -334,7 +334,7 @@ public void Reacquire()
         /// <param name="blockingTarget">Target that we are blocked on which is being built by <paramref name="blockingRequest"/></param>
         public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTargets, string blockingTarget = null)
         {
-            VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Executing });
+            VerifyOneOfStates([SchedulableRequestState.Blocked, SchedulableRequestState.Executing]);
             ErrorUtilities.VerifyThrowArgumentNull(blockingRequest, nameof(blockingRequest));
             ErrorUtilities.VerifyThrowArgumentNull(activeTargets, nameof(activeTargets));
             ErrorUtilities.VerifyThrow(BlockingTarget == null, "Cannot block again if we're already blocked on a target");
@@ -350,7 +350,7 @@ public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTa
             // to also execute, then that request is not unscheduled (because it was running on the node) and it is not executing (because this condition
             // can only occur against requests which are executing on the same node and since the request which called this method is the one currently
             // executing on that node, that means the request it is blocked by must either be itself blocked or ready.)
-            blockingRequest.VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Yielding, SchedulableRequestState.Blocked, SchedulableRequestState.Ready, SchedulableRequestState.Unscheduled });
+            blockingRequest.VerifyOneOfStates([SchedulableRequestState.Yielding, SchedulableRequestState.Blocked, SchedulableRequestState.Ready, SchedulableRequestState.Unscheduled]);
 
             // Update our list of active targets.  This has to be done before we detect circular dependencies because we use this information to detect
             // re-entrancy circular dependencies.
@@ -371,7 +371,7 @@ public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTa
         /// </summary>
         public void UnblockWithPartialResultForBlockingTarget(BuildResult result)
         {
-            VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled });
+            VerifyOneOfStates([SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled]);
             ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
 
             BlockingRequestKey key = new BlockingRequestKey(result);
@@ -384,7 +384,7 @@ public void UnblockWithPartialResultForBlockingTarget(BuildResult result)
         /// </summary>
         public void UnblockWithResult(BuildResult result)
         {
-            VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled });
+            VerifyOneOfStates([SchedulableRequestState.Blocked, SchedulableRequestState.Unscheduled]);
             ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
 
             BlockingRequestKey key = new BlockingRequestKey(result);
@@ -400,7 +400,7 @@ public void ResumeExecution(int nodeId)
         {
             ErrorUtilities.VerifyThrow(_assignedNodeId == Scheduler.InvalidNodeId || _assignedNodeId == nodeId, "Request must always resume on the same node on which it was started.");
 
-            VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Ready, SchedulableRequestState.Unscheduled });
+            VerifyOneOfStates([SchedulableRequestState.Ready, SchedulableRequestState.Unscheduled]);
             ErrorUtilities.VerifyThrow((_state == SchedulableRequestState.Ready) || !_schedulingData.IsRequestScheduled(this), "Another instance of request {0} is already scheduled.", _request.GlobalRequestId);
             ErrorUtilities.VerifyThrow(!_schedulingData.IsNodeWorking(nodeId), "Cannot resume execution of request {0} because node {1} is already working.", _request.GlobalRequestId, nodeId);
 
@@ -416,7 +416,7 @@ public void ResumeExecution(int nodeId)
         /// </summary>
         public void Complete(BuildResult result)
         {
-            VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Ready, SchedulableRequestState.Executing, SchedulableRequestState.Unscheduled });
+            VerifyOneOfStates([SchedulableRequestState.Ready, SchedulableRequestState.Executing, SchedulableRequestState.Unscheduled]);
             ErrorUtilities.VerifyThrow(_state != SchedulableRequestState.Ready || result.CircularDependency, "Request can only be Completed from the Ready state if the result indicates a circular dependency occurred.");
             ErrorUtilities.VerifyThrow(_requestsWeAreBlockedBy.Count == 0, "We can't be complete if we are still blocked on requests.");
 
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 2bae4049ae1..5fedb8c7ac9 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -1627,7 +1627,7 @@ private void HandleRequestBlockedOnInProgressTarget(SchedulableRequest blockedRe
 
             // The request we blocked on couldn't have been executing (because we are) so it must either be yielding (which is ok because
             // it isn't modifying its own state, just running a background process), ready, or still blocked.
-            blockingRequest.VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Yielding, SchedulableRequestState.Ready, SchedulableRequestState.Blocked });
+            blockingRequest.VerifyOneOfStates([SchedulableRequestState.Yielding, SchedulableRequestState.Ready, SchedulableRequestState.Blocked]);
 
             // detect the case for https://github.com/dotnet/msbuild/issues/3047
             // if we have partial results AND blocked and blocking share the same configuration AND are blocked on each other
@@ -1651,7 +1651,7 @@ private void HandleRequestBlockedOnInProgressTarget(SchedulableRequest blockedRe
         private void HandleRequestBlockedOnResultsTransfer(SchedulableRequest parentRequest, List<ScheduleResponse> responses)
         {
             // Create the new request which will go to the configuration's results node.
-            BuildRequest newRequest = new BuildRequest(parentRequest.BuildRequest.SubmissionId, BuildRequest.ResultsTransferNodeRequestId, parentRequest.BuildRequest.ConfigurationId, Array.Empty<string>(), null, parentRequest.BuildRequest.BuildEventContext, parentRequest.BuildRequest, parentRequest.BuildRequest.BuildRequestDataFlags);
+            BuildRequest newRequest = new BuildRequest(parentRequest.BuildRequest.SubmissionId, BuildRequest.ResultsTransferNodeRequestId, parentRequest.BuildRequest.ConfigurationId, [], null, parentRequest.BuildRequest.BuildEventContext, parentRequest.BuildRequest, parentRequest.BuildRequest.BuildRequestDataFlags);
 
             // Assign a new global request id - always different from any other.
             newRequest.GlobalRequestId = _nextGlobalRequestId;
@@ -2565,13 +2565,19 @@ private void TraceScheduler(string format, params object[] stuff)
         {
             if (_debugDumpState)
             {
-                FileUtilities.EnsureDirectoryExists(_debugDumpPath);
+                try
+                {
+                    FileUtilities.EnsureDirectoryExists(_debugDumpPath);
 
-                StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerTrace_{0}.txt"), Process.GetCurrentProcess().Id), append: true);
-                file.Write("{0}({1})-{2}: ", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, _schedulingData.EventTime.Ticks);
-                file.WriteLine(format, stuff);
-                file.Flush();
-                file.Dispose();
+                    using StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerTrace_{0}.txt"), Process.GetCurrentProcess().Id), append: true);
+                    file.Write("{0}({1})-{2}: ", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, _schedulingData.EventTime.Ticks);
+                    file.WriteLine(format, stuff);
+                    file.Flush();
+                }
+                catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
+                {
+                    // Ignore exceptions
+                }
             }
         }
 
@@ -2584,9 +2590,11 @@ private void DumpSchedulerState()
             {
                 if (_schedulingData != null)
                 {
-                    FileUtilities.EnsureDirectoryExists(_debugDumpPath);
-                    using (StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerState_{0}.txt"), Process.GetCurrentProcess().Id), append: true))
+                    try
                     {
+                        FileUtilities.EnsureDirectoryExists(_debugDumpPath);
+                        using StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerState_{0}.txt"), Process.GetCurrentProcess().Id), append: true);
+
                         file.WriteLine("Scheduler state at timestamp {0}:", _schedulingData.EventTime.Ticks);
                         file.WriteLine("------------------------------------------------");
 
@@ -2680,6 +2688,10 @@ private void DumpSchedulerState()
 
                         file.WriteLine();
                     }
+                    catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
+                    {
+                        // Ignore exceptions
+                    }
                 }
             }
         }
@@ -2693,8 +2705,10 @@ private void DumpConfigurations()
             {
                 if (_schedulingData != null)
                 {
-                    using (StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerState_{0}.txt"), Process.GetCurrentProcess().Id), append: true))
+                    try
                     {
+                        using StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerState_{0}.txt"), Process.GetCurrentProcess().Id), append: true);
+
                         file.WriteLine("Configurations used during this build");
                         file.WriteLine("-------------------------------------");
 
@@ -2714,6 +2728,10 @@ private void DumpConfigurations()
 
                         file.Flush();
                     }
+                    catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
+                    {
+                        // Ignore exceptions
+                    }
                 }
             }
         }
@@ -2727,14 +2745,20 @@ private void DumpRequests()
             {
                 if (_schedulingData != null)
                 {
-                    using (StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerState_{0}.txt"), Process.GetCurrentProcess().Id), append: true))
+                    try
                     {
+                        using StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerState_{0}.txt"), Process.GetCurrentProcess().Id), append: true);
+
                         file.WriteLine("Requests used during the build:");
                         file.WriteLine("-------------------------------");
                         file.WriteLine("Format: GlobalRequestId: [NodeId] FinalState (ConfigId) Path (Targets)");
                         DumpRequestHierarchy(file, null, 0);
                         file.Flush();
                     }
+                    catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
+                    {
+                        // Ignore exceptions
+                    }
                 }
             }
         }
diff --git a/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs b/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs
index 8ce9065b9d0..6e49ea9d18d 100644
--- a/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs
@@ -34,7 +34,7 @@ public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase c
 
             return FileUtilities.DirectoryExistsNoThrow(sdkPath)
                 ? factory.IndicateSuccess(sdkPath, string.Empty)
-                : factory.IndicateFailure(new string[] { ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("DefaultSDKResolverError", sdk.Name, sdkPath) }, null);
+                : factory.IndicateFailure([ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("DefaultSDKResolverError", sdk.Name, sdkPath)], null);
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
index 5241e228c2f..fbd4a2ba24a 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
@@ -126,7 +126,7 @@ private SdkResult RequestSdkPathFromMainNode(int submissionId, SdkReference sdk,
             SendPacket(packet);
 
             // Wait for either the response or a shutdown event.  Either event means this thread should return
-            WaitHandle.WaitAny(new WaitHandle[] { _responseReceivedEvent, ShutdownEvent });
+            WaitHandle.WaitAny([_responseReceivedEvent, ShutdownEvent]);
 
             // Keep track of the element location of the reference
             _lastResponse.ElementLocation = sdkReferenceLocation;
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index 9de6967036e..4417a7e8a1d 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -232,6 +232,20 @@ protected virtual IEnumerable<Type> GetResolverTypes(Assembly assembly)
         protected virtual Assembly LoadResolverAssembly(string resolverPath)
         {
 #if !FEATURE_ASSEMBLYLOADCONTEXT
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12))
+            {
+                string resolverFileName = Path.GetFileNameWithoutExtension(resolverPath);
+                if (resolverFileName.Equals("Microsoft.DotNet.MSBuildSdkResolver", StringComparison.OrdinalIgnoreCase))
+                {
+                    // This will load the resolver assembly into the default load context if possible, and fall back to LoadFrom context.
+                    // We very much prefer the default load context because it allows native images to be used by the CLR, improving startup perf.
+                    AssemblyName assemblyName = new AssemblyName(resolverFileName)
+                    {
+                        CodeBase = resolverPath,
+                    };
+                    return Assembly.Load(assemblyName);
+                }
+            }
             return Assembly.LoadFrom(resolverPath);
 #else
             return s_loader.LoadFromPath(resolverPath);
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 252bf62ab14..cf2f12b58a2 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -349,7 +349,7 @@ private bool TryResolveSdkUsingSpecifiedResolvers(
 
                 SetResolverState(submissionId, sdkResolver, context.State);
 
-                result ??= (SdkResult)resultFactory.IndicateFailure(new string[] { ResourceUtilities.FormatResourceStringStripCodeAndKeyword("SDKResolverReturnedNull", sdkResolver.Name) }, Array.Empty<string>());
+                result ??= (SdkResult)resultFactory.IndicateFailure([ResourceUtilities.FormatResourceStringStripCodeAndKeyword("SDKResolverReturnedNull", sdkResolver.Name)], []);
 
                 if (result.Success)
                 {
@@ -380,8 +380,8 @@ private bool TryResolveSdkUsingSpecifiedResolvers(
                 results.Add(result);
             }
 
-            warnings = results.SelectMany(r => r.Warnings ?? Array.Empty<string>());
-            errors = results.SelectMany(r => r.Errors ?? Array.Empty<string>());
+            warnings = results.SelectMany(r => r.Warnings ?? []);
+            errors = results.SelectMany(r => r.Errors ?? []);
 
             sdkResult = new SdkResult(sdk, null, null);
             return false;
diff --git a/src/Build/BackEnd/Node/InProcNode.cs b/src/Build/BackEnd/Node/InProcNode.cs
index 927d696f2e9..7b4049f8905 100644
--- a/src/Build/BackEnd/Node/InProcNode.cs
+++ b/src/Build/BackEnd/Node/InProcNode.cs
@@ -137,7 +137,7 @@ public NodeEngineShutdownReason Run(out Exception shutdownException)
                 _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
                 _nodeEndpoint.Listen(this);
 
-                var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };
+                WaitHandle[] waitHandles = [_shutdownEvent, _packetReceivedEvent];
 
                 // Get the current directory before doing work. We need this so we can restore the directory when the node shuts down.
                 _savedCurrentDirectory = NativeMethodsShared.GetCurrentDirectory();
diff --git a/src/Build/BackEnd/Node/NodeConfiguration.cs b/src/Build/BackEnd/Node/NodeConfiguration.cs
index 2caec69b11d..99ab53e2e70 100644
--- a/src/Build/BackEnd/Node/NodeConfiguration.cs
+++ b/src/Build/BackEnd/Node/NodeConfiguration.cs
@@ -162,27 +162,20 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _buildParameters, BuildParameters.FactoryForDeserialization);
             translator.TranslateArray(ref _forwardingLoggers, LoggerDescription.FactoryForTranslation);
 #if FEATURE_APPDOMAIN
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
-            {
-                byte[] appDomainConfigBytes = null;
+            byte[] appDomainConfigBytes = null;
 
-                // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
-                if (translator.Mode == TranslationDirection.WriteToStream)
-                {
-                    appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
-                }
+            // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
+            }
 
-                translator.Translate(ref appDomainConfigBytes);
+            translator.Translate(ref appDomainConfigBytes);
 
-                if (translator.Mode == TranslationDirection.ReadFromStream)
-                {
-                    _appDomainSetup = new AppDomainSetup();
-                    _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
-                }
-            }
-            else
+            if (translator.Mode == TranslationDirection.ReadFromStream)
             {
-                translator.TranslateDotNet(ref _appDomainSetup);
+                _appDomainSetup = new AppDomainSetup();
+                _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
             }
 #endif
             translator.Translate(ref _loggingNodeConfiguration);
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index af13beb079d..5148f89be9f 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -250,7 +250,7 @@ public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exce
             _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
             _nodeEndpoint.Listen(this);
 
-            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };
+            WaitHandle[] waitHandles = [_shutdownEvent, _packetReceivedEvent];
 
             // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.
             while (true)
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index d409d52d057..ab17e3b7ce1 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -139,7 +139,7 @@ private NodeEngineShutdownReason RunInternal(out Exception? shutdownException, S
             _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
             _nodeEndpoint.Listen(this);
 
-            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };
+            WaitHandle[] waitHandles = [_shutdownEvent, _packetReceivedEvent];
 
             // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.
             while (true)
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 537998947d3..b3ce3e8eafd 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -380,7 +380,7 @@ public override BuildResultCode OverallResult
                     return BuildResultCode.Failure;
                 }
 
-                foreach (KeyValuePair<string, TargetResult> result in _resultsByTarget ?? Enumerable.Empty<KeyValuePair<string, TargetResult>>())
+                foreach (KeyValuePair<string, TargetResult> result in _resultsByTarget ?? [])
                 {
                     if ((result.Value.ResultCode == TargetResultCode.Failure && !result.Value.TargetFailureDoesntCauseBuildFailure)
                         || result.Value.AfterTargetsHaveFailed)
@@ -549,7 +549,7 @@ internal void KeepSpecificTargetResults(IReadOnlyCollection<string> targetsToKee
                 targetsToKeep.Count > 0,
                 $"{nameof(targetsToKeep)} should contain at least one target.");
 
-            foreach (string target in _resultsByTarget?.Keys ?? Enumerable.Empty<string>())
+            foreach (string target in _resultsByTarget?.Keys ?? [])
             {
                 if (!targetsToKeep.Contains(target))
                 {
@@ -574,7 +574,7 @@ public void MergeResults(BuildResult results)
             }
 
             // Merge in the results
-            foreach (KeyValuePair<string, TargetResult> targetResult in results._resultsByTarget ?? Enumerable.Empty<KeyValuePair<string, TargetResult>>())
+            foreach (KeyValuePair<string, TargetResult> targetResult in results._resultsByTarget ?? [])
             {
                 // NOTE: I believe that because we only allow results for a given target to be produced and cached once for a given configuration,
                 // we can never receive conflicting results for that target, since the cache and build request manager would always return the
@@ -696,7 +696,7 @@ internal static BuildResult FactoryForDeserialization(ITranslator translator)
         /// </summary>
         internal void CacheIfPossible()
         {
-            foreach (KeyValuePair<string, TargetResult> targetResultPair in _resultsByTarget ?? Enumerable.Empty<KeyValuePair<string, TargetResult>>())
+            foreach (KeyValuePair<string, TargetResult> targetResultPair in _resultsByTarget ?? [])
             {
                 targetResultPair.Value.CacheItems(ConfigurationId, targetResultPair.Key);
             }
diff --git a/src/Build/BackEnd/Shared/EventsCreatorHelper.cs b/src/Build/BackEnd/Shared/EventsCreatorHelper.cs
index ead0c205d27..c097861214a 100644
--- a/src/Build/BackEnd/Shared/EventsCreatorHelper.cs
+++ b/src/Build/BackEnd/Shared/EventsCreatorHelper.cs
@@ -60,4 +60,35 @@ public static BuildErrorEventArgs CreateErrorEventFromText(BuildEventContext bui
 
         return buildEvent;
     }
+
+    public static BuildWarningEventArgs CreateWarningEventFromText(BuildEventContext buildEventContext, string? subcategoryResourceName, string? errorCode, string? helpKeyword, BuildEventFileInfo file, string message)
+    {
+        ErrorUtilities.VerifyThrowInternalNull(buildEventContext, nameof(buildEventContext));
+        ErrorUtilities.VerifyThrowInternalNull(file, nameof(file));
+        ErrorUtilities.VerifyThrowInternalNull(message, nameof(message));
+
+        string? subcategory = null;
+
+        if (subcategoryResourceName != null)
+        {
+            subcategory = AssemblyResources.GetString(subcategoryResourceName);
+        }
+
+        BuildWarningEventArgs buildEvent =
+        new BuildWarningEventArgs(
+            subcategory,
+            errorCode,
+            file!.File,
+            file.Line,
+            file.Column,
+            file.EndLine,
+            file.EndColumn,
+            message,
+            helpKeyword,
+            "MSBuild");
+
+        buildEvent.BuildEventContext = buildEventContext;
+
+        return buildEvent;
+    }
 }
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 1a2ba345658..e3a33a5e641 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -804,7 +804,7 @@ private ITaskItem[] GetItemOutputs(TaskPropertyInfo parameter)
 
             if (!(outputs is ITaskItem[] taskItemOutputs))
             {
-                taskItemOutputs = new[] { (ITaskItem)outputs };
+                taskItemOutputs = [(ITaskItem)outputs];
             }
 
             return taskItemOutputs;
@@ -1325,7 +1325,7 @@ private bool InternalSetTaskParameter(
                             parameterName: parameter.Name,
                             propertyName: null,
                             itemType: parameter.Name,
-                            parameterValueAsList ?? new object[] { parameterValue },
+                            parameterValueAsList ?? (object[])[parameterValue],
                             parameter.LogItemMetadata);
                     }
                 }
@@ -1486,7 +1486,7 @@ static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(IDictionary c
                                     parameterName: parameter.Name,
                                     propertyName: outputTargetName,
                                     itemType: outputTargetName,
-                                    new object[] { outputString },
+                                    (object[])[outputString],
                                     parameter.LogItemMetadata);
                             }
                             else
@@ -1573,7 +1573,7 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                                     parameterName: parameter.Name,
                                     propertyName: outputTargetName,
                                     itemType: outputTargetName,
-                                    new object[] { outputString },
+                                    (object[])[outputString],
                                     parameter.LogItemMetadata);
                             }
                             else
diff --git a/src/Build/BuildCheck/API/BuildCheckResult.cs b/src/Build/BuildCheck/API/BuildCheckResult.cs
index fe8a234e12d..6471d717056 100644
--- a/src/Build/BuildCheck/API/BuildCheckResult.cs
+++ b/src/Build/BuildCheck/API/BuildCheckResult.cs
@@ -49,7 +49,7 @@ internal BuildEventArgs ToEventArgs(CheckResultSeverity severity)
 
     // Here we will provide different link for built-in rules and custom rules - once we have the base classes differentiated.
     public string FormatMessage() =>
-        _message ??= $"{(Equals(Location ?? ElementLocation.EmptyLocation, ElementLocation.EmptyLocation) ? string.Empty : (Location!.LocationString + ": "))}https://aka.ms/buildcheck/codes#{CheckRule.Id} - {string.Format(CheckRule.MessageFormat, MessageArgs)}";
+        _message ??= $"https://aka.ms/buildcheck/codes#{CheckRule.Id} - {string.Format(CheckRule.MessageFormat, MessageArgs)}";
 
     private string? _message;
 }
diff --git a/src/Build/BuildCheck/API/Check.cs b/src/Build/BuildCheck/API/Check.cs
index 4eeeb8599f1..55c1d87a950 100644
--- a/src/Build/BuildCheck/API/Check.cs
+++ b/src/Build/BuildCheck/API/Check.cs
@@ -43,6 +43,8 @@ public abstract class Check : IDisposable
     /// </param>
     public abstract void RegisterActions(IBuildCheckRegistrationContext registrationContext);
 
+    internal virtual bool IsBuiltIn => false;
+
     public virtual void Dispose()
     { }
 }
diff --git a/src/Build/BuildCheck/API/CheckConfiguration.cs b/src/Build/BuildCheck/API/CheckConfiguration.cs
index 33950a40edc..f89feaec506 100644
--- a/src/Build/BuildCheck/API/CheckConfiguration.cs
+++ b/src/Build/BuildCheck/API/CheckConfiguration.cs
@@ -35,12 +35,12 @@ public class CheckConfiguration
     ///
     /// If not supported by the data source - then the setting is ignored
     /// </summary>
-    public EvaluationCheckScope? EvaluationCheckScope { get; internal init; }
+    public EvaluationCheckScope? EvaluationCheckScope { get; init; }
 
     /// <summary>
     /// The severity of the result for the rule.
     /// </summary>
-    public CheckResultSeverity? Severity { get; internal init; }
+    public CheckResultSeverity? Severity { get; init; }
 
     /// <summary>
     /// Whether the check rule is enabled.
diff --git a/src/Build/BuildCheck/API/InternalCheck.cs b/src/Build/BuildCheck/API/InternalCheck.cs
index 728a01c053d..242c513e655 100644
--- a/src/Build/BuildCheck/API/InternalCheck.cs
+++ b/src/Build/BuildCheck/API/InternalCheck.cs
@@ -28,4 +28,6 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
 
         this.RegisterInternalActions(internalRegistrationContext);
     }
+
+    internal override bool IsBuiltIn => true;
 }
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index b0899f22134..7083d50aa8d 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -7,6 +7,7 @@
 using System.Reflection;
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Acquisition;
@@ -53,21 +54,24 @@ public List<CheckFactory> CreateCheckFactories(
                     .ForEach(t => checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckBaseTypeNotAssignable", t.Name, t.Assembly));
             }
         }
-        catch (ReflectionTypeLoadException ex)
+        catch (ReflectionTypeLoadException ex) when (ex.LoaderExceptions.Length != 0)
         {
-            if (ex.LoaderExceptions.Length != 0)
+            foreach (Exception? unrolledEx in ex.LoaderExceptions.Where(e => e != null).Prepend(ex))
             {
-                foreach (Exception? loaderException in ex.LoaderExceptions)
-                {
-                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedRuleLoading", loaderException?.Message);
-                }
+                ReportLoadingError(unrolledEx!);
             }
         }
         catch (Exception ex)
         {
-            checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedRuleLoading", ex?.Message);
+            ReportLoadingError(ex);
         }
 
         return checksFactories;
+
+        void ReportLoadingError(Exception ex)
+        {
+            checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedRuleLoading", ex.Message);
+            checkContext.DispatchFailedAcquisitionTelemetry(System.IO.Path.GetFileName(checkAcquisitionData.AssemblyPath), ex);
+        }
     }
 }
diff --git a/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
index df2cbd61145..25d99b2bb91 100644
--- a/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
+++ b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Shared;
 using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationCheckData;
 
 #if FEATURE_MSIOREDIST
@@ -23,8 +24,8 @@ internal sealed class DoubleWritesCheck : Check
     public static CheckRule SupportedRule = new CheckRule(
         "BC0102",
         "DoubleWrites",
-        "Two tasks should not write the same file",
-        "Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.",
+        ResourceUtilities.GetResourceString("BuildCheck_BC0102_Title")!,
+        ResourceUtilities.GetResourceString("BuildCheck_BC0102_MessageFmt")!,
         new CheckConfiguration() { Severity = CheckResultSeverity.Warning });
 
     public override string FriendlyName => "MSBuild.DoubleWritesCheck";
@@ -41,6 +42,8 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
         registrationContext.RegisterTaskInvocationAction(TaskInvocationAction);
     }
 
+    internal override bool IsBuiltIn => true;
+
     /// <summary>
     /// Contains the first project file + task that wrote the given file during the build.
     /// </summary>
@@ -125,5 +128,5 @@ private void CheckWrite(BuildCheckDataContext<TaskInvocationCheckData> context,
                 _filesWritten.Add(fileBeingWritten, (context.Data.ProjectFilePath, context.Data.TaskName));
             }
         }
-   }
+    }
 }
diff --git a/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
index 51411b9502f..30049c3f7ca 100644
--- a/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
+++ b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
@@ -13,8 +13,8 @@ internal sealed class NoEnvironmentVariablePropertyCheck : Check
     public static CheckRule SupportedRule = new CheckRule(
         "BC0103",
         "NoEnvironmentVariablePropertyCheck",
-        "No implicit property derived from an environment variable should be used during the build",
-        "Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.",
+        ResourceUtilities.GetResourceString("BuildCheck_BC0103_Title")!,
+        ResourceUtilities.GetResourceString("BuildCheck_BC0103_MessageFmt")!,
         new CheckConfiguration() { Severity = CheckResultSeverity.Suggestion });
 
     private const string RuleId = "BC0103";
@@ -49,6 +49,8 @@ public override void Initialize(ConfigurationContext configurationContext)
 
     public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEnvironmentVariableReadAction(ProcessEnvironmentVariableReadAction);
 
+    internal override bool IsBuiltIn => true;
+
     private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EnvironmentVariableCheckData> context)
     {
         EnvironmentVariableIdentityKey identityKey = new(context.Data.EnvironmentVariableName, context.Data.EnvironmentVariableLocation);
@@ -95,7 +97,7 @@ private void HandleScopeReadiness()
         CheckScopeClassifier.NotifyOnScopingReadiness -= HandleScopeReadiness;
     }
 
-    private string GetFormattedMessage(string envVariableName, string envVariableValue) => _isVerboseEnvVarOutput? $"'{envVariableName}' with value: '{envVariableValue}'" : $"'{envVariableName}'";
+    private string GetFormattedMessage(string envVariableName, string envVariableValue) => _isVerboseEnvVarOutput ? string.Format(ResourceUtilities.GetResourceString("BuildCheck_BC0103_MessageAddendum")!, envVariableName, envVariableValue) : $"'{envVariableName}'";
 
     internal class EnvironmentVariableIdentityKey(string environmentVariableName, IMSBuildElementLocation location) : IEquatable<EnvironmentVariableIdentityKey>
     {
diff --git a/src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs b/src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs
index f2e7d2fc37a..e2e01caf5e7 100644
--- a/src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs
+++ b/src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs
@@ -17,18 +17,18 @@ namespace Microsoft.Build.Experimental.BuildCheck.Checks;
 internal class PropertiesUsageCheck : InternalCheck
 {
     private static readonly CheckRule _usedBeforeInitializedRule = new CheckRule("BC0201", "PropertyUsedBeforeDeclared",
-        "A property that is accessed should be declared first.",
-        "Property: [{0}] was accessed, but it was never initialized.",
+        ResourceUtilities.GetResourceString("BuildCheck_BC0201_Title")!,
+        ResourceUtilities.GetResourceString("BuildCheck_BC0201_MessageFmt")!,
         new CheckConfiguration() { Severity = CheckResultSeverity.Warning, EvaluationCheckScope = EvaluationCheckScope.ProjectFileOnly });
 
     private static readonly CheckRule _initializedAfterUsedRule = new CheckRule("BC0202", "PropertyDeclaredAfterUsed",
-        "A property should be declared before it is first used.",
-        "Property: [{0}] first declared/initialized at [{1}] used before it was initialized.",
+        ResourceUtilities.GetResourceString("BuildCheck_BC0202_Title")!,
+        ResourceUtilities.GetResourceString("BuildCheck_BC0202_MessageFmt")!,
         new CheckConfiguration() { Severity = CheckResultSeverity.Warning, EvaluationCheckScope = EvaluationCheckScope.ProjectFileOnly });
 
     private static readonly CheckRule _unusedPropertyRule = new CheckRule("BC0203", "UnusedPropertyDeclared",
-        "A property that is not used should not be declared.",
-        "Property: [{0}] was declared/initialized, but it was never used.",
+        ResourceUtilities.GetResourceString("BuildCheck_BC0203_Title")!,
+        ResourceUtilities.GetResourceString("BuildCheck_BC0203_MessageFmt")!,
         new CheckConfiguration() { Severity = CheckResultSeverity.Suggestion, EvaluationCheckScope = EvaluationCheckScope.ProjectFileOnly });
 
     internal static readonly IReadOnlyList<CheckRule> SupportedRulesList = [_usedBeforeInitializedRule, _initializedAfterUsedRule, _unusedPropertyRule];
@@ -118,6 +118,8 @@ public override void RegisterInternalActions(IInternalCheckRegistrationContext r
         }
     }
 
+    internal override bool IsBuiltIn => true;
+
     private Dictionary<string, IMSBuildElementLocation?> _writenProperties = new(MSBuildNameIgnoreCaseComparer.Default);
     private HashSet<string> _readProperties = new(MSBuildNameIgnoreCaseComparer.Default);
     // For the 'Property Initialized after used' check - we are interested in cases where:
diff --git a/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
index 1ec84093e3a..e01f62ab787 100644
--- a/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
+++ b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
@@ -17,8 +17,8 @@ internal sealed class SharedOutputPathCheck : Check
 {
     private const string RuleId = "BC0101";
     public static CheckRule SupportedRule = new CheckRule(RuleId, "ConflictingOutputPath",
-        "Two projects should not share their OutputPath nor IntermediateOutputPath locations",
-        "Projects {0} and {1} have conflicting output paths: {2}.",
+        ResourceUtilities.GetResourceString("BuildCheck_BC0101_Title")!,
+        ResourceUtilities.GetResourceString("BuildCheck_BC0101_MessageFmt")!,
         new CheckConfiguration() { RuleId = RuleId, Severity = CheckResultSeverity.Warning });
 
     public override string FriendlyName => "MSBuild.SharedOutputPathCheck";
@@ -35,6 +35,8 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
         registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
     }
 
+    internal override bool IsBuiltIn => true;
+
     private readonly Dictionary<string, string> _projectsPerOutputPath = new(StringComparer.CurrentCultureIgnoreCase);
     private readonly HashSet<string> _projects = new(StringComparer.CurrentCultureIgnoreCase);
 
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
index 419ca2c9f26..6e011090046 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
@@ -36,7 +36,7 @@ internal BuildCheckBuildEventHandler(
             { typeof(ProjectEvaluationFinishedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationFinishedEvent((ProjectEvaluationFinishedEventArgs)e) },
             { typeof(ProjectEvaluationStartedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs)e) },
             { typeof(EnvironmentVariableReadEventArgs), (BuildEventArgs e) => HandleEnvironmentVariableReadEvent((EnvironmentVariableReadEventArgs)e) },
-            { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => _buildCheckManager.StartProjectRequest(e.BuildEventContext!, ((ProjectStartedEventArgs)e).ProjectFile!) },
+            { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => HandleProjectStartedRequest((ProjectStartedEventArgs)e) },
             { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => HandleProjectFinishedRequest((ProjectFinishedEventArgs)e) },
             { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => HandleBuildCheckTracingEvent((BuildCheckTracingEventArgs)e) },
             { typeof(BuildCheckAcquisitionEventArgs), (BuildEventArgs e) => HandleBuildCheckAcquisitionEvent((BuildCheckAcquisitionEventArgs)e) },
@@ -98,6 +98,11 @@ private void HandleProjectEvaluationStartedEvent(ProjectEvaluationStartedEventAr
         }
     }
 
+    private void HandleProjectStartedRequest(ProjectStartedEventArgs eventArgs)
+        => _buildCheckManager.StartProjectRequest(
+            _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
+            eventArgs!.ProjectFile!);
+
     private void HandleProjectFinishedRequest(ProjectFinishedEventArgs eventArgs)
         => _buildCheckManager.EndProjectRequest(
                 _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
@@ -107,7 +112,7 @@ private void HandleBuildCheckTracingEvent(BuildCheckTracingEventArgs eventArgs)
     {
         if (!eventArgs.IsAggregatedGlobalReport)
         {
-            _stats.Merge(eventArgs.TracingData, (span1, span2) => span1 + span2);
+            _tracingData.MergeIn(eventArgs.TracingData);
         }
     }
 
@@ -138,36 +143,25 @@ private void HandleEnvironmentVariableReadEvent(EnvironmentVariableReadEventArgs
 
     private bool IsMetaProjFile(string? projectFile) => projectFile?.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase) == true;
 
-    private readonly Dictionary<string, TimeSpan> _stats = new Dictionary<string, TimeSpan>();
+    private readonly BuildCheckTracingData _tracingData = new BuildCheckTracingData();
 
     private void HandleBuildFinishedEvent(BuildFinishedEventArgs eventArgs)
     {
         _buildCheckManager.ProcessBuildFinished(_checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!));
 
-        _stats.Merge(_buildCheckManager.CreateCheckTracingStats(), (span1, span2) => span1 + span2);
+        _tracingData.MergeIn(_buildCheckManager.CreateCheckTracingStats());
 
         LogCheckStats(_checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)));
     }
 
     private void LogCheckStats(ICheckContext checkContext)
     {
-        Dictionary<string, TimeSpan> infraStats = new Dictionary<string, TimeSpan>();
-        Dictionary<string, TimeSpan> checkStats = new Dictionary<string, TimeSpan>();
-
-        foreach (var stat in _stats)
-        {
-            if (stat.Key.StartsWith(BuildCheckConstants.infraStatPrefix))
-            {
-                string newKey = stat.Key.Substring(BuildCheckConstants.infraStatPrefix.Length);
-                infraStats[newKey] = stat.Value;
-            }
-            else
-            {
-                checkStats[stat.Key] = stat.Value;
-            }
-        }
+        Dictionary<string, TimeSpan>  infraStats = _tracingData.InfrastructureTracingData;
+        // Stats are per rule, while runtime is per check - and check can have multiple rules.
+        // In case of multi-rule check, the runtime stats are duplicated for each rule.
+        Dictionary<string, TimeSpan> checkStats = _tracingData.ExtractCheckStats();
 
-        BuildCheckTracingEventArgs statEvent = new BuildCheckTracingEventArgs(_stats, true)
+        BuildCheckTracingEventArgs statEvent = new BuildCheckTracingEventArgs(_tracingData, true)
         { BuildEventContext = checkContext.BuildEventContext };
 
         checkContext.DispatchBuildEvent(statEvent);
@@ -177,6 +171,7 @@ private void LogCheckStats(ICheckContext checkContext)
         checkContext.DispatchAsCommentFromText(MessageImportance.Low, infraData);
         string checkData = BuildCsvString("Checks run times", checkStats);
         checkContext.DispatchAsCommentFromText(MessageImportance.Low, checkData);
+        checkContext.DispatchTelemetry(_tracingData);
     }
 
     private string BuildCsvString(string title, Dictionary<string, TimeSpan> rowData)
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index 310dc29b0f6..5e25c3e0a48 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -15,8 +15,11 @@ internal sealed class BuildCheckCentralContext
 {
     private readonly IConfigurationProvider _configurationProvider;
 
-    internal BuildCheckCentralContext(IConfigurationProvider configurationProvider)
-        => _configurationProvider = configurationProvider;
+    public BuildCheckCentralContext(IConfigurationProvider configurationProvider, Action<ICheckContext> removeThrottledChecks)
+    {
+        _configurationProvider = configurationProvider;
+        _removeThrottledChecks = removeThrottledChecks;
+    }
 
     private record CallbackRegistry(
         List<(CheckWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>>)> EvaluatedPropertiesActions,
@@ -46,6 +49,7 @@ internal void DeregisterCheck(CheckWrapper check)
 
     // In a future we can have callbacks per project as well
     private readonly CallbackRegistry _globalCallbacks = new();
+    private readonly Action<ICheckContext> _removeThrottledChecks;
 
     // This we can potentially use to subscribe for receiving evaluated props in the
     //  build event args. However - this needs to be done early on, when checks might not be known yet
@@ -192,7 +196,7 @@ private void RunRegisteredActions<T>(
                     return;
                 }
 
-                configPerRule = new[] { commonConfig };
+                configPerRule = [commonConfig];
             }
             else
             {
@@ -216,5 +220,7 @@ private void RunRegisteredActions<T>(
 
             checkCallback.Item2(context);
         }
+
+        _removeThrottledChecks(checkContext);
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 96a57e974ef..13925ad6d5f 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -26,15 +26,11 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 /// </summary>
 internal sealed class BuildCheckManagerProvider : IBuildCheckManagerProvider
 {
-    private static IBuildCheckManager? s_globalInstance;
+    private IBuildCheckManager? _instance;
 
-    internal static IBuildCheckManager GlobalInstance => s_globalInstance ?? throw new InvalidOperationException("BuildCheckManagerProvider not initialized");
+    public IBuildCheckManager Instance => _instance ?? new NullBuildCheckManager();
 
-    public IBuildCheckManager Instance => GlobalInstance;
-
-    public IBuildEngineDataRouter BuildEngineDataRouter => (IBuildEngineDataRouter)GlobalInstance;
-
-    public static IBuildEngineDataRouter? GlobalBuildEngineDataRouter => (IBuildEngineDataRouter?)s_globalInstance;
+    public IBuildEngineDataRouter BuildEngineDataRouter => (IBuildEngineDataRouter)Instance;
 
     internal static IBuildComponent CreateComponent(BuildComponentType type)
     {
@@ -46,27 +42,26 @@ public void InitializeComponent(IBuildComponentHost host)
     {
         ErrorUtilities.VerifyThrow(host != null, "BuildComponentHost was null");
 
-        if (s_globalInstance == null)
+        if (_instance == null)
         {
-            IBuildCheckManager instance;
             if (host!.BuildParameters.IsBuildCheckEnabled)
             {
-                instance = new BuildCheckManager();
+                _instance = new BuildCheckManager();
             }
             else
             {
-                instance = new NullBuildCheckManager();
+                _instance = new NullBuildCheckManager();
             }
-
-            // We are fine with the possibility of double creation here - as the construction is cheap
-            //  and without side effects and the actual backing field is effectively immutable after the first assignment.
-            Interlocked.CompareExchange(ref s_globalInstance, instance, null);
         }
     }
 
-    public void ShutdownComponent() => GlobalInstance.Shutdown();
+    public void ShutdownComponent()
+    {
+        _instance?.Shutdown();
+        _instance = null;
+    } 
 
-    internal sealed class BuildCheckManager : IBuildCheckManager, IBuildEngineDataRouter
+    internal sealed class BuildCheckManager : IBuildCheckManager, IBuildEngineDataRouter, IResultReporter
     {
         private readonly TracingReporter _tracingReporter = new TracingReporter();
         private readonly IConfigurationProvider _configurationProvider = new ConfigurationProvider();
@@ -80,7 +75,7 @@ internal BuildCheckManager()
         {
             _checkRegistry = new List<CheckFactoryContext>();
             _acquisitionModule = new BuildCheckAcquisitionModule();
-            _buildCheckCentralContext = new(_configurationProvider);
+            _buildCheckCentralContext = new(_configurationProvider, RemoveThrottledChecks);
             _buildEventsProcessor = new(_buildCheckCentralContext);
         }
 
@@ -188,6 +183,7 @@ internal void RegisterCustomCheck(
         {
             if (_enabledDataSources[(int)buildCheckDataSource])
             {
+                List<CheckFactoryContext> invalidChecksToRemove = new();
                 foreach (var factory in factories)
                 {
                     var instance = factory();
@@ -201,10 +197,24 @@ internal void RegisterCustomCheck(
                         if (checkFactoryContext != null)
                         {
                             _checkRegistry.Add(checkFactoryContext);
-                            SetupSingleCheck(checkFactoryContext, projectPath);
-                            checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckSuccessfulAcquisition", instance.FriendlyName);
+                            try
+                            {
+                                SetupSingleCheck(checkFactoryContext, projectPath);
+                                checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckSuccessfulAcquisition", instance.FriendlyName);
+                            }
+                            catch (BuildCheckConfigurationException e)
+                            {
+                                checkContext.DispatchAsWarningFromText(
+                                    null,
+                                    null,
+                                    null,
+                                    new BuildEventFileInfo(projectPath),
+                                    e.Message);
+                                invalidChecksToRemove.Add(checkFactoryContext);
+                            }
                         }
                     }
+                    RemoveInvalidChecks(invalidChecksToRemove, checkContext);
                 }
             }
         }
@@ -219,10 +229,10 @@ private void SetupSingleCheck(CheckFactoryContext checkFactoryContext, string pr
             CheckConfigurationEffective[] configurations;
             if (checkFactoryContext.MaterializedCheck == null)
             {
-                CheckConfiguration[] userConfigs =
+                CheckConfiguration[] userEditorConfigs =
                     _configurationProvider.GetUserConfigurations(projectFullPath, checkFactoryContext.RuleIds);
 
-                if (userConfigs.All(c => !(c.IsEnabled ?? checkFactoryContext.IsEnabledByDefault)))
+                if (userEditorConfigs.All(c => !(c.IsEnabled ?? checkFactoryContext.IsEnabledByDefault)))
                 {
                     // the check was not yet instantiated nor mounted - so nothing to do here now.
                     return;
@@ -232,11 +242,11 @@ private void SetupSingleCheck(CheckFactoryContext checkFactoryContext, string pr
                     _configurationProvider.GetCustomConfigurations(projectFullPath, checkFactoryContext.RuleIds);
 
                 Check uninitializedCheck = checkFactoryContext.Factory();
-                configurations = _configurationProvider.GetMergedConfigurations(userConfigs, uninitializedCheck);
+                configurations = _configurationProvider.GetMergedConfigurations(userEditorConfigs, uninitializedCheck);
 
                 ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData, configurations);
 
-                wrapper = checkFactoryContext.Initialize(uninitializedCheck, configurationContext);
+                wrapper = checkFactoryContext.Initialize(uninitializedCheck, this, configurationContext);
                 checkFactoryContext.MaterializedCheck = wrapper;
                 Check check = wrapper.Check;
 
@@ -261,7 +271,7 @@ private void SetupSingleCheck(CheckFactoryContext checkFactoryContext, string pr
                 // price to be paid in that case is slight performance cost.
 
                 // Create the wrapper and register to central context
-                wrapper.StartNewProject(projectFullPath, configurations);
+                wrapper.StartNewProject(projectFullPath, configurations, userEditorConfigs);
                 var wrappedContext = new CheckRegistrationContext(wrapper, _buildCheckCentralContext);
                 check.RegisterActions(wrappedContext);
             }
@@ -269,13 +279,15 @@ private void SetupSingleCheck(CheckFactoryContext checkFactoryContext, string pr
             {
                 wrapper = checkFactoryContext.MaterializedCheck;
 
-                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.Check);
+                CheckConfiguration[] userEditorConfigs =
+                    _configurationProvider.GetUserConfigurations(projectFullPath, checkFactoryContext.RuleIds);
+                configurations = _configurationProvider.GetMergedConfigurations(userEditorConfigs, wrapper.Check);
 
                 _configurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
                     checkFactoryContext.RuleIds[0]);
 
                 // Update the wrapper
-                wrapper.StartNewProject(projectFullPath, configurations);
+                wrapper.StartNewProject(projectFullPath, configurations, userEditorConfigs);
             }
         }
 
@@ -286,7 +298,7 @@ private void SetupChecksForNewProject(string projectFullPath, ICheckContext chec
 
             // If it's already constructed - just control the custom settings do not differ
             Stopwatch stopwatch = Stopwatch.StartNew();
-            List<CheckFactoryContext> checksToRemove = new();
+            List<CheckFactoryContext> invalidChecksToRemove = new();
             foreach (CheckFactoryContext checkFactoryContext in _checkRegistry)
             {
                 try
@@ -295,30 +307,50 @@ private void SetupChecksForNewProject(string projectFullPath, ICheckContext chec
                 }
                 catch (BuildCheckConfigurationException e)
                 {
-                    checkContext.DispatchAsErrorFromText(
+                    checkContext.DispatchAsWarningFromText(
                         null,
                         null,
                         null,
                         new BuildEventFileInfo(projectFullPath),
                         e.Message);
-                    checksToRemove.Add(checkFactoryContext);
+                    invalidChecksToRemove.Add(checkFactoryContext);
                 }
             }
 
-            checksToRemove.ForEach(c =>
+            RemoveInvalidChecks(invalidChecksToRemove, checkContext);
+
+            stopwatch.Stop();
+            _tracingReporter.AddNewProjectStats(stopwatch.Elapsed);
+        }
+
+        private void RemoveInvalidChecks(List<CheckFactoryContext> checksToRemove, ICheckContext checkContext)
+        {
+            foreach (var checkToRemove in checksToRemove)
             {
-                _checkRegistry.Remove(c);
-                checkContext.DispatchAsCommentFromText(MessageImportance.High, $"Dismounting check '{c.FriendlyName}'");
-            });
-            foreach (var checkToRemove in checksToRemove.Select(a => a.MaterializedCheck).Where(a => a != null))
+                checkContext.DispatchAsCommentFromText(MessageImportance.High, $"Dismounting check '{checkToRemove.FriendlyName}'");
+                RemoveCheck(checkToRemove);
+            }
+        }
+
+        public void RemoveThrottledChecks(ICheckContext checkContext)
+        {
+            foreach (var checkToRemove in _checkRegistry.FindAll(c => c.MaterializedCheck?.IsThrottled ?? false))
             {
-                _buildCheckCentralContext.DeregisterCheck(checkToRemove!);
-                _tracingReporter.AddCheckStats(checkToRemove!.Check.FriendlyName, checkToRemove.Elapsed);
-                checkToRemove.Check.Dispose();
+                checkContext.DispatchAsCommentFromText(MessageImportance.Normal, $"Dismounting check '{checkToRemove.FriendlyName}'. The check has exceeded the maximum number of results allowed. Any additional results will not be displayed.");
+                RemoveCheck(checkToRemove);
             }
+        }
 
-            stopwatch.Stop();
-            _tracingReporter.AddNewProjectStats(stopwatch.Elapsed);
+        private void RemoveCheck(CheckFactoryContext checkToRemove)
+        {
+            _checkRegistry.Remove(checkToRemove);
+            
+            if (checkToRemove.MaterializedCheck is not null)
+            {
+                _buildCheckCentralContext.DeregisterCheck(checkToRemove.MaterializedCheck);
+				_ruleTelemetryData.AddRange(checkToRemove.MaterializedCheck.GetRuleTelemetryData());
+                checkToRemove.MaterializedCheck.Check.Dispose();
+            }
         }
 
         public void ProcessEvaluationFinishedEventArgs(
@@ -381,19 +413,18 @@ public void ProcessTaskParameterEventArgs(
             => _buildEventsProcessor
                 .ProcessTaskParameterEventArgs(checkContext, taskParameterEventArgs);
 
-        public Dictionary<string, TimeSpan> CreateCheckTracingStats()
+        private readonly List<BuildCheckRuleTelemetryData> _ruleTelemetryData = [];
+        public BuildCheckTracingData CreateCheckTracingStats()
         {
             foreach (CheckFactoryContext checkFactoryContext in _checkRegistry)
             {
                 if (checkFactoryContext.MaterializedCheck != null)
                 {
-                    _tracingReporter.AddCheckStats(checkFactoryContext.FriendlyName, checkFactoryContext.MaterializedCheck.Elapsed);
-                    checkFactoryContext.MaterializedCheck.ClearStats();
+                    _ruleTelemetryData.AddRange(checkFactoryContext.MaterializedCheck.GetRuleTelemetryData());
                 }
             }
 
-            _tracingReporter.AddCheckInfraStats();
-            return _tracingReporter.TracingStats;
+            return new BuildCheckTracingData(_ruleTelemetryData, _tracingReporter.GetInfrastructureTracingStats());
         }
 
         public void FinalizeProcessing(LoggingContext loggingContext)
@@ -497,10 +528,53 @@ public void EndProjectEvaluation(BuildEventContext buildEventContext)
         {
         }
 
-        public void StartProjectRequest(BuildEventContext buildEventContext, string projectFullPath)
+        public void StartProjectRequest(ICheckContext checkContext, string projectFullPath)
         {
+            BuildEventContext buildEventContext = checkContext.BuildEventContext;
+
             // There can be multiple ProjectStarted-ProjectFinished per single configuration project build (each request for different target)
             _projectsByInstanceId[buildEventContext.ProjectInstanceId] = projectFullPath;
+
+            if (_deferredEvalDiagnostics.TryGetValue(buildEventContext.EvaluationId, out var list))
+            {
+                foreach (BuildEventArgs deferredArgs in list)
+                {
+                    deferredArgs.BuildEventContext = deferredArgs.BuildEventContext!.WithInstanceIdAndContextId(buildEventContext);
+                    checkContext.DispatchBuildEvent(deferredArgs);
+                }
+                list.Clear();
+                _deferredEvalDiagnostics.Remove(buildEventContext.EvaluationId);
+            }
+        }
+
+        private readonly Dictionary<int, List<BuildEventArgs>> _deferredEvalDiagnostics = new();
+        void IResultReporter.ReportResult(BuildEventArgs eventArgs, ICheckContext checkContext)
+        {
+            // If we do not need to decide on promotability/demotability of warnings or we are ready to decide on those
+            //  - we can just dispatch the event.
+            if (
+                // no context - we cannot defer as we'd need eval id to queue it
+                eventArgs.BuildEventContext == null ||
+                // no eval id - we cannot defer as we'd need eval id to queue it
+                eventArgs.BuildEventContext.EvaluationId == BuildEventContext.InvalidEvaluationId ||
+                // instance id known - no need to defer
+                eventArgs.BuildEventContext.ProjectInstanceId != BuildEventContext.InvalidProjectInstanceId ||
+                // it's not a warning - no need to defer
+                eventArgs is not BuildWarningEventArgs)
+            {
+                checkContext.DispatchBuildEvent(eventArgs);
+                return;
+            }
+
+            // This is evaluation - so we need to defer it until we know the instance id and context id
+
+            if (!_deferredEvalDiagnostics.TryGetValue(eventArgs.BuildEventContext.EvaluationId, out var list))
+            {
+                list = [];
+                _deferredEvalDiagnostics[eventArgs.BuildEventContext.EvaluationId] = list;
+            }
+
+            list.Add(eventArgs);
         }
 
         public void EndProjectRequest(
@@ -558,7 +632,7 @@ public Check Factory()
                 return ba;
             }
 
-            public CheckWrapper Initialize(Check ba, ConfigurationContext configContext)
+            public CheckWrapper Initialize(Check ba, IResultReporter resultReporter, ConfigurationContext configContext)
             {
                 try
                 {
@@ -573,7 +647,7 @@ public CheckWrapper Initialize(Check ba, ConfigurationContext configContext)
                     throw new BuildCheckConfigurationException(
                         $"The Check '{ba.FriendlyName}' failed to initialize: {e.Message}", e);
                 }
-                return new CheckWrapper(ba);
+                return new CheckWrapper(ba, resultReporter);
             }
 
             public CheckWrapper? MaterializedCheck { get; set; }
@@ -586,3 +660,8 @@ public CheckWrapper Initialize(Check ba, ConfigurationContext configContext)
         }
     }
 }
+
+internal interface IResultReporter
+{
+    void ReportResult(BuildEventArgs result, ICheckContext checkContext);
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
index f2925ff1556..7a932c671f9 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -242,10 +242,6 @@ private static void ReportResult(
             return;
         }
 
-        BuildEventArgs eventArgs = result.ToEventArgs(config.Severity);
-
-        eventArgs.BuildEventContext = checkContext.BuildEventContext;
-
-        checkContext.DispatchBuildEvent(eventArgs);
+        checkWrapper.ReportResult(result, checkContext, config);
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs
index 71befe7991b..06b7d5ccec1 100644
--- a/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs
@@ -62,4 +62,19 @@ public void DispatchAsErrorFromText(string? subcategoryResourceName, string? err
 
         _eventDispatcher.Dispatch(buildEvent);
     }
+
+    public void DispatchAsWarningFromText(string? subcategoryResourceName, string? errorCode, string? helpKeyword, BuildEventFileInfo file, string message)
+    {
+        BuildWarningEventArgs buildEvent = EventsCreatorHelper.CreateWarningEventFromText(_eventContext, subcategoryResourceName, errorCode, helpKeyword, file, message);
+
+        _eventDispatcher.Dispatch(buildEvent);
+    }
+
+    public void DispatchFailedAcquisitionTelemetry(string assemblyName, Exception exception)
+    // This is it - no action for replay mode.
+    { }
+
+    public void DispatchTelemetry(BuildCheckTracingData data)
+    // This is it - no action for replay mode.
+    { }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs
index c295b254f49..13f308d2283 100644
--- a/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs
@@ -8,6 +8,7 @@
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
@@ -39,4 +40,22 @@ public void DispatchAsCommentFromText(MessageImportance importance, string messa
     public void DispatchAsErrorFromText(string? subcategoryResourceName, string? errorCode, string? helpKeyword, BuildEventFileInfo file, string message)
         => loggingService
             .LogErrorFromText(eventContext, subcategoryResourceName, errorCode, helpKeyword, file, message);
+
+    public void DispatchAsWarningFromText(string? subcategoryResourceName, string? errorCode, string? helpKeyword, BuildEventFileInfo file, string message)
+        => loggingService
+            .LogWarningFromText(eventContext, subcategoryResourceName, errorCode, helpKeyword, file, message);
+
+    public void DispatchFailedAcquisitionTelemetry(string assemblyName, Exception exception)
+    {
+        var telemetryTransportData = KnownTelemetry.BuildCheckTelemetry.ProcessCustomCheckLoadingFailure(assemblyName, exception);
+        loggingService.LogTelemetry(eventContext, telemetryTransportData.Item1, telemetryTransportData.Item2);
+    }
+
+    public void DispatchTelemetry(BuildCheckTracingData data)
+    {
+        foreach ((string, IDictionary<string, string>) telemetryTransportData in KnownTelemetry.BuildCheckTelemetry.ProcessBuildCheckTracingData(data))
+        {
+            loggingService.LogTelemetry(eventContext, telemetryTransportData.Item1, telemetryTransportData.Item2);
+        }
+    }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContext.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContext.cs
index 7c4e82861ea..8cfa8b5b820 100644
--- a/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContext.cs
@@ -40,4 +40,19 @@ internal interface ICheckContext
     /// Dispatch the instance of <see cref="BuildEventContext"/> as a comment with provided text for the message.
     /// </summary>
     void DispatchAsCommentFromText(MessageImportance importance, string message);
+
+    /// <summary>
+    /// Dispatch the instance of <see cref="BuildEventContext"/> as a warning message.
+    /// </summary>
+    void DispatchAsWarningFromText(string? subcategoryResourceName, string? errorCode, string? helpKeyword, BuildEventFileInfo file, string message);
+
+    /// <summary>
+    /// Dispatch the telemetry data for a failed acquisition.
+    /// </summary>
+    void DispatchFailedAcquisitionTelemetry(string assemblyName, Exception exception);
+
+    /// <summary>
+    /// If supported - dispatches the telemetry data.
+    /// </summary>
+    void DispatchTelemetry(BuildCheckTracingData data);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/CheckWrapper.cs b/src/Build/BuildCheck/Infrastructure/CheckWrapper.cs
index 62011296cb5..6d2fc868d95 100644
--- a/src/Build/BuildCheck/Infrastructure/CheckWrapper.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckWrapper.cs
@@ -7,6 +7,7 @@
 using System.Linq;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
@@ -16,51 +17,182 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 internal sealed class CheckWrapper
 {
     private readonly Stopwatch _stopwatch = new Stopwatch();
+    private readonly BuildCheckRuleTelemetryData[] _ruleTelemetryData;
 
-    public CheckWrapper(Check check)
+    /// <summary>
+    /// Maximum amount of messages that could be sent per check rule.
+    /// </summary>
+    public const int MaxReportsNumberPerRule = 20;
+
+    /// <summary>
+    /// Keeps track of number of reports sent per rule.
+    /// </summary>
+    private int _reportsCount = 0;
+
+    /// <summary>
+    /// Flags that this check should no more used and be deregistered.
+    /// </summary>
+    public bool IsThrottled { get; private set; } = false;
+
+    /// <summary>
+    /// Whether to limit number of reports for the Check.
+    /// </summary>
+    private readonly bool _limitReportsNumber = !Traits.Instance.EscapeHatches.DoNotLimitBuildCheckResultsNumber;
+
+    private readonly IResultReporter _resultReporter;
+
+    public CheckWrapper(Check check, IResultReporter resultReporter)
     {
         Check = check;
+        _resultReporter = resultReporter;
+        _ruleTelemetryData = new BuildCheckRuleTelemetryData[check.SupportedRules.Count];
+
+        InitializeTelemetryData(_ruleTelemetryData, check);
+    }
+
+    private static void InitializeTelemetryData(BuildCheckRuleTelemetryData[] ruleTelemetryData, Check check)
+    {
+        int idx = 0;
+        foreach (CheckRule checkRule in check.SupportedRules)
+        {
+            ruleTelemetryData[idx++] = new BuildCheckRuleTelemetryData(
+                ruleId: checkRule.Id,
+                checkFriendlyName: check.FriendlyName,
+                isBuiltIn: check.IsBuiltIn,
+                defaultSeverity: (checkRule.DefaultConfiguration.Severity ??
+                                  CheckConfigurationEffective.Default.Severity).ToDiagnosticSeverity());
+        }
     }
 
     internal Check Check { get; }
-    private bool _isInitialized = false;
+
+    private bool _areStatsInitialized = false;
 
     // Let's optimize for the scenario where users have a single .editorconfig file that applies to the whole solution.
     // In such case - configuration will be same for all projects. So we do not need to store it per project in a collection.
     internal CheckConfigurationEffective? CommonConfig { get; private set; }
 
-    // start new project
+    /// <summary>
+    /// Ensures the check being configured for a new project (as each project can have different settings)
+    /// </summary>
+    /// <param name="fullProjectPath"></param>
+    /// <param name="effectiveConfigs">Resulting merged configurations per rule (merged from check default and explicit user editorconfig).</param>
+    /// <param name="editorConfigs">Configurations from editorconfig per rule.</param>
     internal void StartNewProject(
         string fullProjectPath,
-        IReadOnlyList<CheckConfigurationEffective> userConfigs)
+        IReadOnlyList<CheckConfigurationEffective> effectiveConfigs,
+        IReadOnlyList<CheckConfiguration> editorConfigs)
     {
-        if (!_isInitialized)
+        // Let's first update the telemetry data for the rules.
+        int idx = 0;
+        foreach (BuildCheckRuleTelemetryData ruleTelemetryData in _ruleTelemetryData)
         {
-            _isInitialized = true;
-            CommonConfig = userConfigs[0];
+            CheckConfigurationEffective effectiveConfig = effectiveConfigs[Math.Max(idx, effectiveConfigs.Count - 1)];
+            if (editorConfigs[idx].Severity != null)
+            {
+                ruleTelemetryData.ExplicitSeverities.Add(editorConfigs[idx].Severity!.Value.ToDiagnosticSeverity());
+            }
 
-            if (userConfigs.Count == 1)
+            if (effectiveConfig.IsEnabled)
+            {
+                ruleTelemetryData.ProjectNamesWhereEnabled.Add(fullProjectPath);
+            }
+
+            idx++;
+        }
+
+        if (!_areStatsInitialized)
+        {
+            _areStatsInitialized = true;
+            CommonConfig = effectiveConfigs[0];
+
+            if (effectiveConfigs.Count == 1)
             {
                 return;
             }
         }
 
         // The Common configuration is not common anymore - let's nullify it and we will need to fetch configuration per project.
-        if (CommonConfig == null || !userConfigs.All(t => t.IsSameConfigurationAs(CommonConfig)))
+        if (CommonConfig == null || !effectiveConfigs.All(t => t.IsSameConfigurationAs(CommonConfig)))
         {
             CommonConfig = null;
         }
     }
 
+    private void AddDiagnostic(CheckConfigurationEffective configurationEffective)
+    {
+        BuildCheckRuleTelemetryData? telemetryData =
+            _ruleTelemetryData.FirstOrDefault(td => td.RuleId.Equals(configurationEffective.RuleId));
+
+        if (telemetryData == null)
+        {
+            return;
+        }
+
+        switch (configurationEffective.Severity)
+        {
+            
+            case CheckResultSeverity.Suggestion:
+                telemetryData.IncrementMessagesCount();
+                break;
+            case CheckResultSeverity.Warning:
+                telemetryData.IncrementWarningsCount();
+                break;
+            case CheckResultSeverity.Error:
+                telemetryData.IncrementErrorsCount();
+                break;
+            case CheckResultSeverity.Default:
+            case CheckResultSeverity.None:
+            default:
+                break;
+        }
+
+        if (IsThrottled)
+        {
+            telemetryData.SetThrottled();
+        }
+    }
+
+    internal void ReportResult(BuildCheckResult result, ICheckContext checkContext, CheckConfigurationEffective config)
+    {
+        if (!IsThrottled)
+        {
+            _reportsCount++;
+            BuildEventArgs eventArgs = result.ToEventArgs(config.Severity);
+            eventArgs.BuildEventContext = checkContext.BuildEventContext;
+            _resultReporter.ReportResult(eventArgs, checkContext);
+
+            // Big amount of build check messages may lead to build hang.
+            // See issue https://github.com/dotnet/msbuild/issues/10414
+            // As a temporary fix, we will limit the number of messages that could be reported by the check.
+            if (_limitReportsNumber)
+            {
+                if (_reportsCount >= MaxReportsNumberPerRule)
+                {
+                    IsThrottled = true;
+                }
+            }
+
+            // Add the diagnostic to the check wrapper for telemetry purposes.
+            AddDiagnostic(config);
+        }
+    }
+
     // to be used on eval node (BuildCheckDataSource.check)
-    internal void Uninitialize()
+    internal void UninitializeStats()
     {
-        _isInitialized = false;
+        _areStatsInitialized = false;
     }
 
-    internal TimeSpan Elapsed => _stopwatch.Elapsed;
+    internal IReadOnlyList<BuildCheckRuleTelemetryData> GetRuleTelemetryData()
+    {
+        foreach (BuildCheckRuleTelemetryData ruleTelemetryData in _ruleTelemetryData)
+        {
+            ruleTelemetryData.TotalRuntime = _stopwatch.Elapsed;
+        }
 
-    internal void ClearStats() => _stopwatch.Reset();
+        return _ruleTelemetryData;
+    }
 
     internal CleanupScope StartSpan()
     {
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
index d2f93664369..a811b61d973 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
@@ -81,7 +81,7 @@ internal static EditorConfigFile Parse(string text)
         // dictionary, but we also use a case-insensitive key comparer when doing lookups
         var activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>(StringComparer.OrdinalIgnoreCase);
         string activeSectionName = "";
-        var lines = string.IsNullOrEmpty(text) ? Array.Empty<string>() : text.Split(new string[] { Environment.NewLine }, StringSplitOptions.None);
+        var lines = string.IsNullOrEmpty(text) ? [] : text.Split(["\r\n", "\n"], StringSplitOptions.None);
 
         foreach(var line in lines)
         {
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
index 88c644954e7..552c49dac83 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -61,7 +61,7 @@ void ProcessTaskParameterEventArgs(
 
     void ProcessCheckAcquisition(CheckAcquisitionData acquisitionData, ICheckContext checksContext);
 
-    Dictionary<string, TimeSpan> CreateCheckTracingStats();
+    BuildCheckTracingData CreateCheckTracingStats();
 
     void FinalizeProcessing(LoggingContext loggingContext);
 
@@ -79,7 +79,7 @@ void ProcessTaskParameterEventArgs(
 
     void EndProjectEvaluation(BuildEventContext buildEventContext);
 
-    void StartProjectRequest(BuildEventContext buildEventContext, string projectFullPath);
+    void StartProjectRequest(ICheckContext checksContext, string projectFullPath);
 
     void EndProjectRequest(ICheckContext checksContext, string projectFullPath);
 
diff --git a/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyReadInfo.cs b/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyReadInfo.cs
index 9fa2029535a..ae1b62e7c66 100644
--- a/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyReadInfo.cs
+++ b/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyReadInfo.cs
@@ -21,4 +21,13 @@ internal readonly record struct PropertyReadInfo(
     int EndIndex,
     IMSBuildElementLocation ElementLocation,
     bool IsUninitialized,
-    PropertyReadContext PropertyReadContext);
+    PropertyReadContext PropertyReadContext)
+{
+    internal PropertyReadInfo(
+        string PropertyName,
+        IMSBuildElementLocation ElementLocation,
+        bool IsUninitialized,
+        PropertyReadContext PropertyReadContext)
+        : this(PropertyName, 0, PropertyName.Length - 1, ElementLocation, IsUninitialized, PropertyReadContext)
+    { }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
index a5bf0b968a8..294700ef5fc 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -71,7 +71,7 @@ public void EndProjectEvaluation(BuildEventContext buildEventContext)
     {
     }
 
-    public void StartProjectRequest(BuildEventContext buildEventContext, string projectFullPath)
+    public void StartProjectRequest(ICheckContext checksContext, string projectFullPath)
     {
     }
 
@@ -79,7 +79,7 @@ public void EndProjectRequest(ICheckContext checkContext, string projectFullPath
     {
     }
 
-    public Dictionary<string, TimeSpan> CreateCheckTracingStats() => new Dictionary<string, TimeSpan>();
+    public BuildCheckTracingData CreateCheckTracingStats() => new BuildCheckTracingData();
 
     public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext buildEventContext)
     { }
diff --git a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
index d7f75922966..05bb2f33cdc 100644
--- a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
+++ b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
@@ -13,26 +13,10 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal class TracingReporter
 {
-    internal Dictionary<string, TimeSpan> TracingStats { get; } = new();
-
-    // Infrastructure time keepers
-    // TODO: add more timers throughout BuildCheck run
     private TimeSpan checkAcquisitionTime;
     private TimeSpan checkSetDataSourceTime;
     private TimeSpan newProjectChecksTime;
 
-    public void AddCheckStats(string name, TimeSpan subtotal)
-    {
-        if (TracingStats.TryGetValue(name, out TimeSpan existing))
-        {
-            TracingStats[name] = existing + subtotal;
-        }
-        else
-        {
-            TracingStats[name] = subtotal;
-        }
-    }
-
     public void AddAcquisitionStats(TimeSpan subtotal)
     {
         checkAcquisitionTime += subtotal;
@@ -48,14 +32,11 @@ public void AddNewProjectStats(TimeSpan subtotal)
         newProjectChecksTime += subtotal;
     }
 
-    public void AddCheckInfraStats()
-    {
-        var infraStats = new Dictionary<string, TimeSpan>() {
-                { $"{BuildCheckConstants.infraStatPrefix}checkAcquisitionTime", checkAcquisitionTime },
-                { $"{BuildCheckConstants.infraStatPrefix}checkSetDataSourceTime", checkSetDataSourceTime },
-                { $"{BuildCheckConstants.infraStatPrefix}newProjectChecksTime", newProjectChecksTime }
-            };
-
-        TracingStats.Merge(infraStats, (span1, span2) => span1 + span2);
-    }
+    public Dictionary<string, TimeSpan> GetInfrastructureTracingStats()
+        => new Dictionary<string, TimeSpan>()
+        {
+            { $"{BuildCheckConstants.infraStatPrefix}checkAcquisitionTime", checkAcquisitionTime },
+            { $"{BuildCheckConstants.infraStatPrefix}checkSetDataSourceTime", checkSetDataSourceTime },
+            { $"{BuildCheckConstants.infraStatPrefix}newProjectChecksTime", newProjectChecksTime }
+        };
 }
diff --git a/src/Build/BuildCheck/Utilities/CheckResultSeverityExtensions.cs b/src/Build/BuildCheck/Utilities/CheckResultSeverityExtensions.cs
new file mode 100644
index 00000000000..04d6077fc24
--- /dev/null
+++ b/src/Build/BuildCheck/Utilities/CheckResultSeverityExtensions.cs
@@ -0,0 +1,31 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+internal static class CheckResultSeverityExtensions
+{
+    public static DiagnosticSeverity? ToDiagnosticSeverity(this CheckResultSeverity? severity)
+    {
+        if (severity == null)
+        {
+            return null;
+        }
+
+        return ToDiagnosticSeverity(severity.Value);
+    }
+
+    public static DiagnosticSeverity ToDiagnosticSeverity(this CheckResultSeverity severity)
+    {
+        return severity switch
+        {
+            CheckResultSeverity.Default => DiagnosticSeverity.Default,
+            CheckResultSeverity.None => DiagnosticSeverity.None,
+            CheckResultSeverity.Suggestion => DiagnosticSeverity.Suggestion,
+            CheckResultSeverity.Warning => DiagnosticSeverity.Warning,
+            CheckResultSeverity.Error => DiagnosticSeverity.Error,
+            _ => throw new ArgumentOutOfRangeException(nameof(severity), severity, null)
+        };
+    }
+}
diff --git a/src/Build/CompatibilitySuppressions.xml b/src/Build/CompatibilitySuppressions.xml
index 0979a70a8c1..05317adadab 100644
--- a/src/Build/CompatibilitySuppressions.xml
+++ b/src/Build/CompatibilitySuppressions.xml
@@ -1,300 +1,4 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <!-- Many many suppressions related to renaming Analyzers to BuildChecks
-      in https://github.com/dotnet/msbuild/pull/10491. -->
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerConfiguration</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerConfiguration</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.#ctor(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.Create(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_BuildAnalyzerRule</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_Location</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData}})</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData}})</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData}})</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.#ctor(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.Create(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_BuildAnalyzerRule</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_Location</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData}})</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData}})</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData}})</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0006</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterBuildFinishedAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.BuildFinishedCheckData}})</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0006</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEnvironmentVariableReadAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EnvironmentVariableCheckData}})</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0006</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesCheckData}})</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0006</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsCheckData}})</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0006</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationCheckData}})</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0021</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext`1``0:T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0021</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext`1``0:T:Microsoft.Build.Experimental.BuildCheck.CheckData</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0021</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext`1``0:T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0021</DiagnosticId>
-    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext`1``0:T:Microsoft.Build.Experimental.BuildCheck.CheckData</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <!--
-    https://learn.microsoft.com/en-us/dotnet/fundamentals/apicompat/diagnostic-ids
-    Suppress PKV006 for net8.0 (The target framework is dropped in the latest version.)  -->
-  <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net8.0</Target>
-  </Suppression>
 </Suppressions>
diff --git a/src/Build/Construction/ProjectChooseElement.cs b/src/Build/Construction/ProjectChooseElement.cs
index 0ef3acca430..5977dde4d30 100644
--- a/src/Build/Construction/ProjectChooseElement.cs
+++ b/src/Build/Construction/ProjectChooseElement.cs
@@ -92,7 +92,7 @@ public override ElementLocation ConditionLocation
         /// </summary>
         internal static ProjectChooseElement CreateDisconnected(ProjectRootElement containingProject)
         {
-            ErrorUtilities.VerifyThrow(containingProject.Link == null, "External project");
+            ErrorUtilities.VerifyThrow(containingProject.Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
             XmlElementWithLocation element = containingProject.CreateElement(XMakeElements.choose);
             return new ProjectChooseElement(element, containingProject);
diff --git a/src/Build/Construction/ProjectElement.cs b/src/Build/Construction/ProjectElement.cs
index a8619b746fc..a21992f0caa 100644
--- a/src/Build/Construction/ProjectElement.cs
+++ b/src/Build/Construction/ProjectElement.cs
@@ -164,7 +164,7 @@ public ProjectElementContainer Parent
 
             internal set
             {
-                ErrorUtilities.VerifyThrow(Link == null, "External project");
+                ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
                 if (value == null)
                 {
                     // We're about to lose the parent. Hijack the field to store the owning PRE.
@@ -261,7 +261,7 @@ public ProjectRootElement ContainingProject
             // ContainingProject is set ONLY when an element is first constructed.
             internal set
             {
-                ErrorUtilities.VerifyThrow(Link == null, "External project");
+                ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
                 ErrorUtilities.VerifyThrowArgumentNull(value, "ContainingProject");
 
                 if (_parent == null)
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index d2386dc8028..5cf6937f14d 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -388,7 +388,7 @@ internal void AppendParentedChildNoChecks(ProjectElement child)
         {
             ErrorUtilities.VerifyThrow(child.Parent == this, "Expected parent already set");
             ErrorUtilities.VerifyThrow(child.PreviousSibling == null && child.NextSibling == null, "Invalid structure");
-            ErrorUtilities.VerifyThrow(Link == null, "External project");
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
             if (LastChild == null)
             {
@@ -438,7 +438,7 @@ internal static ProjectElementContainer DeepClone(ProjectElementContainer xml, P
 
         private void SetElementAsAttributeValue(ProjectElement child)
         {
-            ErrorUtilities.VerifyThrow(Link == null, "External project");
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
             // Assumes that child.ExpressedAsAttribute is true
             Debug.Assert(child.ExpressedAsAttribute, nameof(SetElementAsAttributeValue) + " method requires that " +
@@ -448,13 +448,30 @@ private void SetElementAsAttributeValue(ProjectElement child)
             ProjectXmlUtilities.SetOrRemoveAttribute(XmlElement, child.XmlElement.Name, value);
         }
 
+        /// <summary>
+        /// If child "element" is actually represented as an attribute, update the name in the corresponding Xml attribute
+        /// </summary>
+        /// <param name="child">A child element which might be represented as an attribute</param>
+        /// <param name="oldName">The old name for the child element</param>
+        internal void UpdateElementName(ProjectElement child, string oldName)
+        {
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
+
+            if (child.ExpressedAsAttribute)
+            {
+                // To rename an attribute, we have to fully remove the old one and add a new one.
+                XmlElement.RemoveAttribute(oldName);
+                SetElementAsAttributeValue(child);
+            }
+        }
+
         /// <summary>
         /// If child "element" is actually represented as an attribute, update the value in the corresponding Xml attribute
         /// </summary>
         /// <param name="child">A child element which might be represented as an attribute</param>
         internal void UpdateElementValue(ProjectElement child)
         {
-            ErrorUtilities.VerifyThrow(Link == null, "External project");
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
             if (child.ExpressedAsAttribute)
             {
@@ -474,7 +491,7 @@ internal void UpdateElementValue(ProjectElement child)
         /// </remarks>
         internal void AddToXml(ProjectElement child)
         {
-            ErrorUtilities.VerifyThrow(Link == null, "External project");
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
             if (child.ExpressedAsAttribute)
             {
@@ -580,7 +597,7 @@ private static string GetElementIndentation(XmlElementWithLocation xmlElement)
 
         internal void RemoveFromXml(ProjectElement child)
         {
-            ErrorUtilities.VerifyThrow(Link == null, "External project");
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
             if (child.ExpressedAsAttribute)
             {
diff --git a/src/Build/Construction/ProjectMetadataElement.cs b/src/Build/Construction/ProjectMetadataElement.cs
index 0d6b355e117..ce79f79ba40 100644
--- a/src/Build/Construction/ProjectMetadataElement.cs
+++ b/src/Build/Construction/ProjectMetadataElement.cs
@@ -134,11 +134,14 @@ internal void ChangeName(string newName)
                 ValidateValidMetadataAsAttributeName(newName, Parent.ElementName, Parent.Location);
             }
 
+            string oldName = XmlElement.Name;
+
             // Because the element was created from our special XmlDocument, we know it's
             // an XmlElementWithLocation.
             XmlElementWithLocation newElement = XmlUtilities.RenameXmlElement(XmlElement, newName, XmlElement.NamespaceURI);
 
             ReplaceElement(newElement);
+            Parent.UpdateElementName(this, oldName);
         }
 
         internal static void ValidateValidMetadataAsAttributeName(string name, string parentName, IElementLocation parentLocation)
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 2ab9a1a53d4..0dfb5c1e3fa 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -1791,7 +1791,7 @@ internal ProjectMetadataElement CreateMetadataElement(XmlAttributeWithLocation a
         /// </summary>
         internal XmlElementWithLocation CreateElement(string name, ElementLocation location = null)
         {
-            ErrorUtilities.VerifyThrow(Link == null, "External project");
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
             return (XmlElementWithLocation)XmlDocument.CreateElement(name, XmlNamespace, location);
         }
 
@@ -1848,7 +1848,7 @@ internal sealed override void MarkDirty(string reason, string param)
         internal void MarkProjectDirty(Project project)
         {
             ErrorUtilities.VerifyThrowArgumentNull(project, nameof(project));
-            ErrorUtilities.VerifyThrow(Link == null, "External project");
+            ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
             // Only bubble this event up if the cache knows about this PRE, which is equivalent to
             // whether this PRE has a path.
diff --git a/src/Build/Construction/ProjectTaskElement.cs b/src/Build/Construction/ProjectTaskElement.cs
index 984ffe33b31..24118a3ae03 100644
--- a/src/Build/Construction/ProjectTaskElement.cs
+++ b/src/Build/Construction/ProjectTaskElement.cs
@@ -212,7 +212,7 @@ public IEnumerable<KeyValuePair<string, ElementLocation>> ParameterLocations
         {
             get
             {
-                ErrorUtilities.VerifyThrow(Link == null, "External project");
+                ErrorUtilities.VerifyThrow(Link == null, "Attempt to edit a document that is not backed by a local xml is disallowed.");
 
                 lock (_locker)
                 {
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 97c8e269da4..a73df401565 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -469,7 +469,7 @@ internal string GetProjectGuidWithoutCurlyBrackets()
                 return null;
             }
 
-            return ProjectGuid.Trim(new char[] { '{', '}' });
+            return ProjectGuid.Trim(['{', '}']);
         }
 
         /// <summary>
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 7c8a7dcc867..4676638ed9f 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -1179,7 +1179,7 @@ private static void ParseAspNetCompilerProperty(
                 // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;"
                 if (string.Equals(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase))
                 {
-                    string[] projectReferenceEntries = propertyValue.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
+                    string[] projectReferenceEntries = propertyValue.Split([';'], StringSplitOptions.RemoveEmptyEntries);
 
                     foreach (string projectReferenceEntry in projectReferenceEntries)
                     {
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 33e382771f6..1cbb076827b 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -189,7 +189,7 @@ private SolutionProjectGenerator(
 
             if (targetNames != null)
             {
-                _targetNames = targetNames.Select(i => i.Split(new char[] { ':' }, 2, StringSplitOptions.RemoveEmptyEntries).Last()).ToList();
+                _targetNames = targetNames.Select(i => i.Split([':'], 2, StringSplitOptions.RemoveEmptyEntries).Last()).ToList();
             }
         }
 
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 031ce7a01a9..3998a51002f 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -1574,7 +1574,7 @@ public bool Build(string target, IEnumerable<ILogger> loggers)
         public bool Build(string target, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
             // targets may be null, but not an entry within it
-            string[] targets = (target == null) ? null : new[] { target };
+            string[] targets = (target == null) ? null : [target];
 
             return Build(targets, loggers, remoteLoggers);
         }
@@ -2627,7 +2627,7 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
                 ImmutableArray<string> includeGlobStrings = includeGlobFragments.Select(f => f.TextFragment).ToImmutableArray();
                 var includeGlob = CompositeGlob.Create(includeGlobFragments.Select(f => f.ToMSBuildGlob()));
 
-                IEnumerable<string> excludeFragmentStrings = Enumerable.Empty<string>();
+                IEnumerable<string> excludeFragmentStrings = [];
                 IMSBuildGlob excludeGlob = null;
 
                 if (!string.IsNullOrEmpty(itemElement.Exclude))
@@ -2638,7 +2638,7 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
                     excludeGlob = excludeItemspec.ToMSBuildGlob();
                 }
 
-                IEnumerable<string> removeFragmentStrings = Enumerable.Empty<string>();
+                IEnumerable<string> removeFragmentStrings = [];
                 IMSBuildGlob removeGlob = null;
 
                 if (removeElementCache.TryGetValue(itemElement.ItemType, out CumulativeRemoveElementData removeItemElement))
@@ -2763,7 +2763,7 @@ private static IEnumerable<ProjectItemElement> GetItemElementsThatMightAffectIte
                         itemElement.RemoveLocation == null);
 
                 // add the include operation that created the project item element
-                return new[] { item.Xml }.Concat(relevantElementsAfterInclude);
+                return [item.Xml, ..relevantElementsAfterInclude];
             }
 
             private static List<ProjectItemElement> GetItemElementsByType(IEnumerable<ProjectItemElement> itemElements, string itemType)
diff --git a/src/Build/Definition/ProjectItemDefinition.cs b/src/Build/Definition/ProjectItemDefinition.cs
index d3d70ef98de..8aabe516dc8 100644
--- a/src/Build/Definition/ProjectItemDefinition.cs
+++ b/src/Build/Definition/ProjectItemDefinition.cs
@@ -94,7 +94,7 @@ public string ItemType
         /// This is a read-only collection.
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Justification = "This is a reasonable choice. API review approved")]
-        public IEnumerable<ProjectMetadata> Metadata => Link != null ? Link.Metadata : _metadata ?? Enumerable.Empty<ProjectMetadata>();
+        public IEnumerable<ProjectMetadata> Metadata => Link != null ? Link.Metadata : _metadata ?? [];
 
         /// <summary>
         /// Count of metadata on the item definition.
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index eee61cb02f5..cd1c1317069 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -730,7 +730,7 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, LoggingContext
                 Array.Sort<string>(defaultTasksFiles, StringComparer.OrdinalIgnoreCase);
                 return defaultTasksFiles;
             }
-            return Array.Empty<string>();
+            return [];
         }
 
         /// <summary>
diff --git a/src/Build/Definition/ToolsetLocalReader.cs b/src/Build/Definition/ToolsetLocalReader.cs
index 33feee94720..dacbbb6e8b0 100644
--- a/src/Build/Definition/ToolsetLocalReader.cs
+++ b/src/Build/Definition/ToolsetLocalReader.cs
@@ -46,7 +46,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetPropertyDefinitions
 
         protected override IEnumerable<ToolsetPropertyDefinition> GetSubToolsetPropertyDefinitions(string toolsVersion, string subToolsetVersion)
         {
-            return Enumerable.Empty<ToolsetPropertyDefinition>();
+            return [];
         }
 
         protected override Dictionary<string, ProjectImportPathMatch> GetProjectImportSearchPathsTable(string toolsVersion, string os)
@@ -56,7 +56,7 @@ protected override Dictionary<string, ProjectImportPathMatch> GetProjectImportSe
 
         protected override IEnumerable<string> GetSubToolsetVersions(string toolsVersion)
         {
-            return Enumerable.Empty<string>();
+            return [];
         }
     }
 }
diff --git a/src/Build/Definition/ToolsetRegistryReader.cs b/src/Build/Definition/ToolsetRegistryReader.cs
index 0cc16709f31..19bd5141017 100644
--- a/src/Build/Definition/ToolsetRegistryReader.cs
+++ b/src/Build/Definition/ToolsetRegistryReader.cs
@@ -75,7 +75,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> ToolsVersions
         {
             get
             {
-                string[] toolsVersionNames = Array.Empty<string>();
+                string[] toolsVersionNames = [];
                 try
                 {
                     RegistryKeyWrapper subKey = null;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index ac58b5a67a2..b1d25946256 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -2152,7 +2152,7 @@ private static Stack<TransformFunction<S>> PrepareTransformStackFromMatch<S>(IEl
                     if (functionName == null)
                     {
                         functionName = "ExpandQuotedExpressionFunction";
-                        arguments = new string[] { function };
+                        arguments = [function];
                     }
                     else if (argumentsExpression != null)
                     {
@@ -3283,7 +3283,7 @@ internal Function(
                 _methodMethodName = methodName;
                 if (arguments == null)
                 {
-                    _arguments = Array.Empty<string>();
+                    _arguments = [];
                 }
                 else
                 {
@@ -3525,10 +3525,13 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                     if (objectInstance != null && args.Length == 1 && (String.Equals("Equals", _methodMethodName, StringComparison.OrdinalIgnoreCase) || String.Equals("CompareTo", _methodMethodName, StringComparison.OrdinalIgnoreCase)))
                     {
                         // Support comparison when the lhs is an integer
-                        if (IsFloatingPointRepresentation(args[0]) && !IsFloatingPointRepresentation(objectInstance))
+                        if (IsFloatingPointRepresentation(args[0]))
                         {
-                            objectInstance = Convert.ChangeType(objectInstance, typeof(double), CultureInfo.InvariantCulture);
-                            _receiverType = objectInstance.GetType();
+                            if (double.TryParse(objectInstance.ToString(), NumberStyles.Number | NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out double result))
+                            {
+                                objectInstance = result;
+                                _receiverType = objectInstance.GetType();
+                            }
                         }
 
                         // change the type of the final unescaped string into the destination
@@ -3545,11 +3548,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                             // include $(MSBuildThisFileDirectory) as a parameter.
                             string startingDirectory = String.IsNullOrWhiteSpace(elementLocation.File) ? String.Empty : Path.GetDirectoryName(elementLocation.File);
 
-                            args = new[]
-                            {
-                                args[0],
-                                startingDirectory,
-                            };
+                            args = [args[0], startingDirectory];
                         }
                     }
 
@@ -3597,8 +3596,17 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                             // otherwise there is the potential of running a function twice!
                             try
                             {
-                                // First use InvokeMember using the standard binder - this will match and coerce as needed
-                                functionResult = _receiverType.InvokeMember(_methodMethodName, _bindingFlags, Type.DefaultBinder, objectInstance, args, CultureInfo.InvariantCulture);
+                                // If there are any out parameters, try to figure out their type and create defaults for them as appropriate before calling the method.
+                                if (args.Any(a => "out _".Equals(a)))
+                                {
+                                    IEnumerable<MethodInfo> methods = _receiverType.GetMethods(_bindingFlags).Where(m => m.Name.Equals(_methodMethodName) && m.GetParameters().Length == args.Length);
+                                    functionResult = GetMethodResult(objectInstance, methods, args, 0);
+                                }
+                                else
+                                {
+                                    // If there are no out parameters, use InvokeMember using the standard binder - this will match and coerce as needed
+                                    functionResult = _receiverType.InvokeMember(_methodMethodName, _bindingFlags, Type.DefaultBinder, objectInstance, args, CultureInfo.InvariantCulture);
+                                }
                             }
                             // If we're invoking a method, then there are deeper attempts that can be made to invoke the method.
                             // If not, we were asked to get a property or field but found that we cannot locate it. No further argument coercion is possible, so throw.
@@ -3694,6 +3702,48 @@ private bool TryExecuteWellKnownFunctionWithPropertiesParam(IPropertyProvider<T>
                 return false;
             }
 
+            private object GetMethodResult(object objectInstance, IEnumerable<MethodInfo> methods, object[] args, int index)
+            {
+                for (int i = index; i < args.Length; i++)
+                {
+                    if (args[i].Equals("out _"))
+                    {
+                        object toReturn = null;
+                        foreach (MethodInfo method in methods)
+                        {
+                            Type t = method.GetParameters()[i].ParameterType;
+                            args[i] = t.IsValueType ? Activator.CreateInstance(t) : null;
+                            object currentReturnValue = GetMethodResult(objectInstance, methods, args, i + 1);
+                            if (currentReturnValue is not null)
+                            {
+                                if (toReturn is null)
+                                {
+                                    toReturn = currentReturnValue;
+                                }
+                                else if (!toReturn.Equals(currentReturnValue))
+                                {
+                                    // There were multiple methods that seemed viable and gave different results. We can't differentiate between them so throw.
+                                    ErrorUtilities.ThrowArgument("CouldNotDifferentiateBetweenCompatibleMethods", _methodMethodName, args.Length);
+                                    return null;
+                                }
+                            }
+                        }
+
+                        return toReturn;
+                    }
+                }
+
+                try
+                {
+                    return _receiverType.InvokeMember(_methodMethodName, _bindingFlags, Type.DefaultBinder, objectInstance, args, CultureInfo.InvariantCulture) ?? "null";
+                }
+                catch (Exception)
+                {
+                    // This isn't a viable option, but perhaps another set of parameters will work.
+                    return null;
+                }
+            }
+
             /// <summary>
             /// Shortcut to avoid calling into binding if we recognize some most common functions.
             /// Binding is expensive and throws first-chance MissingMethodExceptions, which is
@@ -5154,7 +5204,7 @@ private static void ConstructIndexerFunction(string expressionFunction, IElement
                 // If there are no arguments, then just create an empty array
                 if (String.IsNullOrEmpty(argumentsContent))
                 {
-                    functionArguments = Array.Empty<string>();
+                    functionArguments = [];
                 }
                 else
                 {
@@ -5228,7 +5278,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                     // It may be that there are '()' but no actual arguments content
                     if (argumentStartIndex == expressionFunction.Length - 1)
                     {
-                        functionArguments = Array.Empty<string>();
+                        functionArguments = [];
                     }
                     else
                     {
@@ -5238,7 +5288,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                         // If there are no arguments, then just create an empty array
                         if (string.IsNullOrEmpty(argumentsContent))
                         {
-                            functionArguments = Array.Empty<string>();
+                            functionArguments = [];
                         }
                         else
                         {
@@ -5261,7 +5311,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                         nextMethodIndex = indexerIndex;
                     }
 
-                    functionArguments = Array.Empty<string>();
+                    functionArguments = [];
 
                     if (nextMethodIndex > 0)
                     {
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 4a4a183d24f..da988bfdeaf 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -34,7 +34,7 @@ namespace Microsoft.Build.Evaluation
     internal static class IntrinsicFunctions
     {
 #pragma warning disable CA1416 // Platform compatibility: we'll only use this on Windows
-        private static readonly object[] DefaultRegistryViews = new object[] { RegistryView.Default };
+        private static readonly object[] DefaultRegistryViews = [RegistryView.Default];
 #pragma warning restore CA1416
 
         private static readonly Lazy<Regex> RegistrySdkRegex = new Lazy<Regex>(() => new Regex(@"^HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Microsoft SDKs\\Windows\\v(\d+\.\d+)$", RegexOptions.IgnoreCase));
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index ce2c28494ff..30400c410f6 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -369,7 +369,7 @@ public IList<string> IntersectsWith(IReadOnlyDictionary<string, ItemDataCollecti
                 }
             }
 
-            return matches ?? Array.Empty<string>();
+            return matches ?? [];
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs b/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
index cdca2c31156..35faaad48df 100644
--- a/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
+++ b/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
@@ -65,7 +65,7 @@ protected static string GetElementOrConditionText(string description, Evaluation
             var outerXml = description;
             outerXml = outerXml.Replace(@"xmlns=""http://schemas.microsoft.com/developer/msbuild/2003""", "");
 
-            var newLineIndex = outerXml.IndexOfAny(new[] { '\r', '\n' });
+            var newLineIndex = outerXml.IndexOfAny(['\r', '\n']);
             return newLineIndex == -1 ? outerXml : outerXml.Remove(newLineIndex);
         }
 
@@ -75,12 +75,8 @@ protected static string GetElementOrConditionText(string description, Evaluation
         protected void AppendDefaultHeaderWithSeparator(StringBuilder stringBuilder, string separator)
         {
             stringBuilder.AppendLine(
-                string.Join(separator,
-                    new[]
-                    {
-                        "Id", "ParentId", "Pass", "File", "Line #", "Expression", "Inc (ms)", "Inc (%)", "Exc (ms)",
-                        "Exc (%)", "#", "Kind", "Bug"
-                    }));
+                string.Join(separator, ["Id", "ParentId", "Pass", "File", "Line #", "Expression", "Inc (ms)", "Inc (%)", "Exc (ms)",
+                        "Exc (%)", "#", "Kind", "Bug"]));
         }
 
         /// <summary>
diff --git a/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
index d4b6a316964..9d259bda8c6 100644
--- a/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
+++ b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
@@ -95,10 +95,10 @@ private IEnumerable<string> EnumerateFullFileSystemPaths(string path, string sea
 #endif
             IEnumerable<string> directories = includeDirectories
                 ? _directoryCache.EnumerateDirectories(path, searchPattern, predicate, transform)
-                : Enumerable.Empty<string>();
+                : [];
             IEnumerable<string> files = includeFiles
                 ? _directoryCache.EnumerateFiles(path, searchPattern, predicate, transform)
-                : Enumerable.Empty<string>();
+                : [];
 
             return Enumerable.Concat(directories, files);
         }
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index 93aebf6c1af..e1173e46681 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -44,11 +44,7 @@ internal sealed class ProjectInterpretation
 
         public static ProjectInterpretation Instance = new ProjectInterpretation();
 
-        private ProjectInterpretation()
-        {
-        }
-
-        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = new[] { (GlobalPropertiesModifier)ProjectReferenceGlobalPropertiesModifier }.ToImmutableList();
+        private static readonly ImmutableList<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes = [(GlobalPropertiesModifier)ProjectReferenceGlobalPropertiesModifier];
 
         internal enum ProjectType
         {
@@ -103,7 +99,7 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectGraphNode projectGraphNod
             }
 
             SolutionConfiguration solutionConfiguration = null;
-            string solutionConfigurationXml = requesterInstance.GetPropertyValue(SolutionProjectGenerator.CurrentSolutionConfigurationContents);
+            string solutionConfigurationXml = requesterInstance.GetEngineRequiredPropertyValue(SolutionProjectGenerator.CurrentSolutionConfigurationContents);
             if (!string.IsNullOrWhiteSpace(solutionConfigurationXml))
             {
                 solutionConfiguration = new SolutionConfiguration(solutionConfigurationXml);
@@ -123,7 +119,7 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectGraphNode projectGraphNod
                 }
 
                 string projectReferenceFullPath = projectReferenceItem.GetMetadataValue(FullPathMetadataName);
-                bool enableDynamicPlatformResolution = ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionPropertyName));
+                bool enableDynamicPlatformResolution = ConversionUtilities.ValidBooleanTrue(requesterInstance.GetEngineRequiredPropertyValue(EnableDynamicPlatformResolutionPropertyName));
 
                 PropertyDictionary<ProjectPropertyInstance> referenceGlobalProperties = GetGlobalPropertiesForItem(
                     projectReferenceItem,
@@ -161,7 +157,7 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectGraphNode projectGraphNod
                     else
                     {
                         // Note: ShouldUnsetParentConfigurationAndPlatform defaults to true in the AssignProjectConfiguration target when building a solution, so check that it's not false instead of checking that it's true.
-                        bool shouldUnsetParentConfigurationAndPlatform = !ConversionUtilities.ValidBooleanFalse(requesterInstance.GetPropertyValue(ShouldUnsetParentConfigurationAndPlatformPropertyName));
+                        bool shouldUnsetParentConfigurationAndPlatform = !ConversionUtilities.ValidBooleanFalse(requesterInstance.GetEngineRequiredPropertyValue(ShouldUnsetParentConfigurationAndPlatformPropertyName));
                         if (shouldUnsetParentConfigurationAndPlatform)
                         {
                             referenceGlobalProperties.Remove(ConfigurationMetadataName);
@@ -178,8 +174,8 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectGraphNode projectGraphNod
                 // unless the project isn't known to the solution.
                 if (enableDynamicPlatformResolution && !configurationDefined && !projectReferenceItem.HasMetadata(SetPlatformMetadataName))
                 {
-                    string requesterPlatform = requesterInstance.GetPropertyValue("Platform");
-                    string requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
+                    string requesterPlatform = requesterInstance.GetEngineRequiredPropertyValue("Platform");
+                    string requesterPlatformLookupTable = requesterInstance.GetEngineRequiredPropertyValue("PlatformLookupTable");
 
                     var projectInstance = projectInstanceFactory(
                         projectReferenceFullPath,
@@ -188,7 +184,7 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectGraphNode projectGraphNod
 
                     string overridePlatformNegotiationMetadataValue = projectReferenceItem.GetMetadataValue(OverridePlatformNegotiationValue);
 
-                    var selectedPlatform = PlatformNegotiation.GetNearestPlatform(overridePlatformNegotiationMetadataValue, projectInstance.GetPropertyValue(PlatformMetadataName), projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), requesterInstance.GetPropertyValue(PlatformLookupTableMetadataName), projectInstance.FullPath, requesterInstance.GetPropertyValue(PlatformMetadataName));
+                    var selectedPlatform = PlatformNegotiation.GetNearestPlatform(overridePlatformNegotiationMetadataValue, projectInstance.GetEngineRequiredPropertyValue(PlatformMetadataName), projectInstance.GetEngineRequiredPropertyValue(PlatformsMetadataName), projectInstance.GetEngineRequiredPropertyValue(PlatformLookupTableMetadataName), requesterInstance.GetEngineRequiredPropertyValue(PlatformLookupTableMetadataName), projectInstance.FullPath, requesterInstance.GetEngineRequiredPropertyValue(PlatformMetadataName));
 
                     if (selectedPlatform.Equals(String.Empty))
                     {
@@ -298,7 +294,7 @@ private static IEnumerable<ProjectItemInstance> ConstructInnerBuildReferences(Pr
                     project: outerBuild,
                     itemType: InnerBuildReferenceItemName,
                     includeEscaped: outerBuild.FullPath,
-                    directMetadata: new[] { new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}") },
+                    directMetadata: [new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}")],
                     definingFileEscaped: outerBuild.FullPath);
             }
         }
@@ -559,15 +555,15 @@ public bool RequiresTransitiveProjectReferences(ProjectGraphNode projectGraphNod
 
             // special case for Quickbuild which updates msbuild binaries independent of props/targets. Remove this when all QB repos will have
             // migrated to new enough Visual Studio versions whose Microsoft.Managed.After.Targets enable transitive references.
-            if (string.IsNullOrWhiteSpace(projectInstance.GetPropertyValue(AddTransitiveProjectReferencesInStaticGraphPropertyName)) &&
-                MSBuildStringIsTrue(projectInstance.GetPropertyValue("UsingMicrosoftNETSdk")) &&
-                MSBuildStringIsFalse(projectInstance.GetPropertyValue("DisableTransitiveProjectReferences")))
+            if (string.IsNullOrWhiteSpace(projectInstance.GetEngineRequiredPropertyValue(AddTransitiveProjectReferencesInStaticGraphPropertyName)) &&
+                MSBuildStringIsTrue(projectInstance.GetEngineRequiredPropertyValue("UsingMicrosoftNETSdk")) &&
+                MSBuildStringIsFalse(projectInstance.GetEngineRequiredPropertyValue("DisableTransitiveProjectReferences")))
             {
                 return true;
             }
 
             return MSBuildStringIsTrue(
-                projectInstance.GetPropertyValue(AddTransitiveProjectReferencesInStaticGraphPropertyName));
+                projectInstance.GetEngineRequiredPropertyValue(AddTransitiveProjectReferencesInStaticGraphPropertyName));
         }
 
         private static bool MSBuildStringIsTrue(string msbuildString) =>
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 001761c4707..1419a53c6db 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -19,6 +19,7 @@
 using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Evaluation.Context;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Instance;
@@ -1898,6 +1899,21 @@ public string GetPropertyValue(string name)
             return unescapedValue;
         }
 
+        internal string GetEngineRequiredPropertyValue(string name)
+        {
+            if (!_properties.TryGetPropertyUnescapedValue(name, out string unescapedValue))
+            {
+                unescapedValue = String.Empty;
+            }
+            else
+            {
+                _loggingContext?.ProcessPropertyRead(
+                    new PropertyReadInfo(name, ElementLocation.EmptyLocation, false, PropertyReadContext.Other));
+            }
+
+            return unescapedValue;
+        }
+
         /// <summary>
         /// Add a property with the specified name and value.
         /// Overwrites any property with the same name already in the collection.
@@ -1913,6 +1929,8 @@ public ProjectPropertyInstance SetProperty(string name, string evaluatedValue)
             ProjectPropertyInstance property = ProjectPropertyInstance.Create(name, evaluatedValue, false /* may not be reserved */, _isImmutable);
             _properties.Set(property);
 
+            _loggingContext?.ProcessPropertyWrite(new PropertyWriteInfo(name, false, ElementLocation.EmptyLocation));
+
             return property;
         }
 
@@ -2133,7 +2151,7 @@ public bool Build(string target, IEnumerable<ILogger> loggers)
         /// </remarks>
         public bool Build(string target, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
-            string[] targets = (target == null) ? Array.Empty<string>() : new string[] { target };
+            string[] targets = (target == null) ? [] : [target];
 
             return Build(targets, loggers, remoteLoggers);
         }
@@ -2629,7 +2647,7 @@ internal bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<
 
             if (targets == null)
             {
-                targets = Array.Empty<string>();
+                targets = [];
             }
 
             BuildResult results;
@@ -2944,7 +2962,7 @@ private static ProjectInstance[] GenerateSolutionWrapperUsingOldOM(
                 };
                 ProjectInstance instance = new(projectRootElement, globalProperties, toolsVersion, buildParameters, loggingService, projectBuildEventContext, sdkResolverService, submissionId);
 
-                return new[] { instance };
+                return [instance];
             }
         }
 
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index 2051107c8bd..d1d7ac3c678 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -122,7 +122,7 @@ public int MetadataCount
         /// <summary>
         /// Names of all metadata on this item definition
         /// </summary>
-        public IEnumerable<string> MetadataNames => _metadata == null ? Enumerable.Empty<string>() : _metadata.Keys;
+        public IEnumerable<string> MetadataNames => _metadata == null ? [] : _metadata.Keys;
 
         /// <summary>
         /// Implementation of IKeyed exposing the item type, so these
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index ce19ec7872f..ec5c67f344e 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -1063,7 +1063,7 @@ public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()
                 }
                 else
                 {
-                    return Enumerable.Empty<KeyValuePair<string, string>>();
+                    return [];
                 }
             }
 
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 20f381dda93..6130bc25264 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -483,9 +483,9 @@ private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplet
                 }
                 else
                 {
-                    exceptionMessageArgs = new string[] { _taskType.Type.Name,
+                    exceptionMessageArgs = [_taskType.Type.Name,
                         AssemblyUtilities.GetAssemblyLocation(_taskType.Type.GetTypeInfo().Assembly),
-                        string.Empty };
+                        string.Empty];
                 }
 
                 _taskLoggingContext.LogFatalError(taskHostTaskComplete.TaskException, new BuildEventFileInfo(_taskLocation), taskHostTaskComplete.TaskExceptionMessage, taskHostTaskComplete.TaskExceptionMessageArgs);
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 598819b3cd4..3618f4c1b14 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -664,7 +664,7 @@ private IEnumerable<RegisteredTaskRecord> GetRelevantOrderedRegistrations(Regist
 
             if (exactMatchRequired)
             {
-                return Enumerable.Empty<RegisteredTaskRecord>();
+                return [];
             }
 
             // look through all task declarations for partial matches
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index afda13dd6e5..59a7a4ef914 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -46,5 +46,6 @@ public enum BinaryLogRecordKind
         BuildCheckTracing,
         BuildCheckAcquisition,
         BuildSubmissionStarted,
+        BuildCanceled,
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 56efb97f9a2..be4eaa2288d 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -78,6 +78,11 @@ public sealed class BinaryLogger : ILogger
         // version 23:
         //    - new record kinds: BuildCheckMessageEvent, BuildCheckWarningEvent, BuildCheckErrorEvent,
         //    BuildCheckTracingEvent, BuildCheckAcquisitionEvent, BuildSubmissionStartedEvent
+        // version 24:
+        //    - new record kind: BuildCanceledEventArgs
+
+        // MAKE SURE YOU KEEP BuildEventArgsWriter AND StructuredLogViewer.BuildEventArgsWriter IN SYNC WITH THE CHANGES ABOVE.
+        // Both components must stay in sync to avoid issues with logging or event handling in the products.
 
         // This should be never changed.
         // The minimum version of the binary log reader that can read log of above version.
@@ -85,7 +90,7 @@ public sealed class BinaryLogger : ILogger
 
         // The current version of the binary log representation.
         // Changes with each update of the binary log format.
-        internal const int FileFormatVersion = 23;
+        internal const int FileFormatVersion = 24;
 
         // The minimum version of the binary log reader that can read log of above version.
         // This should be changed only when the binary log format is changed in a way that would prevent it from being
@@ -308,7 +313,7 @@ private void LogMessage(string text)
         public void Shutdown()
         {
             Environment.SetEnvironmentVariable("MSBUILDTARGETOUTPUTLOGGING", _initialTargetOutputLogging);
-            Environment.SetEnvironmentVariable("MSBUILDLOGIMPORTS", _initialLogImports ? "1" : "");
+            Environment.SetEnvironmentVariable("MSBUILDLOGIMPORTS", _initialLogImports ? "1" : null);
             Environment.SetEnvironmentVariable("MSBUILDBINARYLOGGERENABLED", _initialIsBinaryLoggerEnabled);
 
             Traits.Instance.EscapeHatches.LogProjectImports = _initialLogImports;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index dc7b097be1a..395263d6a53 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -325,6 +325,7 @@ void HandleError(FormatErrorMessage msgFactory, bool noThrow, ReaderErrorType re
                 BinaryLogRecordKind.BuildCheckError => ReadBuildErrorEventArgs(),
                 BinaryLogRecordKind.BuildCheckTracing => ReadBuildCheckTracingEventArgs(),
                 BinaryLogRecordKind.BuildCheckAcquisition => ReadBuildCheckAcquisitionEventArgs(),
+                BinaryLogRecordKind.BuildCanceled => ReadBuildCanceledEventArgs(),
                 _ => null
             };
 
@@ -634,8 +635,8 @@ private BuildEventArgs ReadBuildSubmissionStartedEventArgs()
             IDictionary<string, string>? globalProperties = null;
             globalProperties = ReadStringDictionary() ?? new Dictionary<string, string>();
 
-            var entryProjectsFullPath = ReadStringIEnumerable() ?? Enumerable.Empty<string>();
-            var targetNames = ReadStringIEnumerable() ?? Enumerable.Empty<string>();
+            var entryProjectsFullPath = ReadStringIEnumerable() ?? [];
+            var targetNames = ReadStringIEnumerable() ?? [];
             var flags = (BuildRequestDataFlags)ReadInt32();
             var submissionId = ReadInt32();
 
@@ -1275,6 +1276,15 @@ private BuildEventArgs ReadBuildCheckAcquisitionEventArgs()
             return e;
         }
 
+        private BuildEventArgs ReadBuildCanceledEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+            var e = new BuildCanceledEventArgs(fields.Message);
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
         /// <summary>
         /// For errors and warnings these 8 fields are written out explicitly
         /// (their presence is not marked as a bit in the flags). So we have to
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 294d96bae2c..77121b29b21 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -187,6 +187,7 @@ Base types and inheritance ("EventArgs" suffix omitted):
                     BuildSubmissionStarted
                     BuildStarted
                     BuildFinished
+                    BuildCanceled
                     ProjectEvaluationStarted
                     ProjectEvaluationFinished
                 BuildError
@@ -215,6 +216,7 @@ private BinaryLogRecordKind WriteCore(BuildEventArgs e)
                 case BuildSubmissionStartedEventArgs buildSubmissionStarted: return Write(buildSubmissionStarted);
                 case BuildStartedEventArgs buildStarted: return Write(buildStarted);
                 case BuildFinishedEventArgs buildFinished: return Write(buildFinished);
+                case BuildCanceledEventArgs buildCanceled: return Write(buildCanceled);
                 case ProjectEvaluationStartedEventArgs projectEvaluationStarted: return Write(projectEvaluationStarted);
                 case ProjectEvaluationFinishedEventArgs projectEvaluationFinished: return Write(projectEvaluationFinished);
                 case BuildCheckTracingEventArgs buildCheckTracing: return Write(buildCheckTracing);
@@ -307,6 +309,13 @@ private BinaryLogRecordKind Write(BuildFinishedEventArgs e)
             return BinaryLogRecordKind.BuildFinished;
         }
 
+        private BinaryLogRecordKind Write(BuildCanceledEventArgs e)
+        {
+            WriteBuildEventArgsFields(e);
+
+            return BinaryLogRecordKind.BuildCanceled;
+        }
+
         private BinaryLogRecordKind Write(ProjectEvaluationStartedEventArgs e)
         {
             WriteBuildEventArgsFields(e, writeMessage: false);
@@ -338,7 +347,11 @@ private BinaryLogRecordKind Write(BuildCheckResultError e)
         private BinaryLogRecordKind Write(BuildCheckTracingEventArgs e)
         {
             WriteBuildEventArgsFields(e, writeMessage: false);
-            WriteProperties(e.TracingData);
+
+            Dictionary<string, TimeSpan> stats = e.TracingData.ExtractCheckStats();
+            stats.Merge(e.TracingData.InfrastructureTracingData, (span1, span2) => span1 + span2);
+
+            WriteProperties(stats);
 
             return BinaryLogRecordKind.BuildCheckTracing;
         }
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index de9c04f2c57..dd73599bec2 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -146,7 +146,7 @@ internal string[] ProjectCallStackFromProject(BuildEventContext e)
             // or the event is raised before the project started event
             if (startedEvent == null)
             {
-                return Array.Empty<string>();
+                return [];
             }
 
             List<ProjectStartedEventMinimumFields> projectStackTrace = GetProjectCallStack(e);
diff --git a/src/Build/Logging/ProfilerLogger.cs b/src/Build/Logging/ProfilerLogger.cs
index 77c521d5452..b80dcf8cf0e 100644
--- a/src/Build/Logging/ProfilerLogger.cs
+++ b/src/Build/Logging/ProfilerLogger.cs
@@ -297,19 +297,12 @@ private void GenerateProfilerReport()
 
                 Console.WriteLine(ResourceUtilities.GetResourceString("WritingProfilerReportDone"));
             }
-            catch (DirectoryNotFoundException ex)
-            {
-                Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ErrorWritingProfilerReport", ex.Message));
-            }
-            catch (IOException ex)
-            {
-                Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ErrorWritingProfilerReport", ex.Message));
-            }
-            catch (UnauthorizedAccessException ex)
-            {
-                Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ErrorWritingProfilerReport", ex.Message));
-            }
-            catch (SecurityException ex)
+            catch (Exception ex) when (ex is
+                DirectoryNotFoundException or
+                IOException or
+                UnauthorizedAccessException or
+                SecurityException or
+                ArgumentException)
             {
                 Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ErrorWritingProfilerReport", ex.Message));
             }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index b06858fa47a..24471d364ba 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -39,7 +39,7 @@
     <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildFromSource)' != 'true'">
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildSourceOnly)' != 'true'">
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" PrivateAssets="all" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 686b36c28c2..5829ce6fad9 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -604,6 +604,9 @@
       LOCALIZATION: "{0}" is the expression that was bad. "{1}" is a message from an FX exception that describes why the expression is bad.
     </comment>
   </data>
+  <data name="CouldNotDifferentiateBetweenCompatibleMethods">
+    <value>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</value>
+  </data>
   <data name="InvalidFunctionPropertyExpression" xml:space="preserve">
     <value>MSB4184: The expression "{0}" cannot be evaluated. {1}</value>
     <comment>{StrBegin="MSB4184: "}
@@ -2142,6 +2145,47 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="IllegalCharactersInFileOrDirectory" xml:space="preserve">
     <value>There are illegal characters in '{0}' in the {1} item.</value>
   </data>
+  <data name="BuildCheck_BC0101_Title" xml:space="preserve">
+    <value>Two projects should not share their 'OutputPath' nor 'IntermediateOutputPath' locations.</value>
+	<comment>'OutputPath' and 'IntermediateOutputPath' not to be translated.</comment>
+  </data>
+  <data name="BuildCheck_BC0101_MessageFmt" xml:space="preserve">
+    <value>Projects {0} and {1} have conflicting output paths: {2}.</value>
+  </data>
+  <data name="BuildCheck_BC0102_Title" xml:space="preserve">
+    <value>Two tasks should not write the same file.</value>
+  </data>
+  <data name="BuildCheck_BC0102_MessageFmt" xml:space="preserve">
+    <value>Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.</value>
+  </data>
+  <data name="BuildCheck_BC0103_Title" xml:space="preserve">
+    <value>No implicit property derived from an environment variable should be used during the build.</value>
+  </data>
+  <data name="BuildCheck_BC0103_MessageFmt" xml:space="preserve">
+    <value>Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.</value>
+  </data>
+  <data name="BuildCheck_BC0103_MessageAddendum" xml:space="preserve">
+    <value>'{0}' with value: '{1}'</value>
+	<comment>Will be used as a parameter {0} in previous message.</comment>
+  </data>
+  <data name="BuildCheck_BC0201_Title" xml:space="preserve">
+    <value>A property that is accessed should be declared first.</value>
+  </data>
+  <data name="BuildCheck_BC0201_MessageFmt" xml:space="preserve">
+    <value>Property: '{0}' was accessed, but it was never initialized.</value>
+  </data>
+  <data name="BuildCheck_BC0202_Title" xml:space="preserve">
+    <value>A property should be declared before it is first used.</value>
+  </data>
+  <data name="BuildCheck_BC0202_MessageFmt" xml:space="preserve">
+    <value>Property: '{0}' first declared/initialized at {1} used before it was initialized.</value>
+  </data>
+  <data name="BuildCheck_BC0203_Title" xml:space="preserve">
+    <value>A property that is not used should not be declared.</value>
+  </data>
+  <data name="BuildCheck_BC0203_MessageFmt" xml:space="preserve">
+    <value>Property: '{0}' was declared/initialized, but it was never used.</value>
+  </data>
   <!--
         The Build message bucket is: MSB4000 - MSB4999
 
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 67b17b2b26f..6f83bd2e035 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -136,6 +136,71 @@
         <target state="translated">Pro tento build je povolena funkce BuildCheck.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_MessageFmt">
+        <source>Projects {0} and {1} have conflicting output paths: {2}.</source>
+        <target state="translated">Projekty {0} a {1} mají konfliktní výstupní cesty: {2}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_Title">
+        <source>Two projects should not share their 'OutputPath' nor 'IntermediateOutputPath' locations.</source>
+        <target state="translated">Dva projekty by neměly sdílet své umístění OutputPath ani IntermediateOutputPath.</target>
+        <note>'OutputPath' and 'IntermediateOutputPath' not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_MessageFmt">
+        <source>Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.</source>
+        <target state="translated">Úlohy {0} a {1} z projektů {2} a {3} zapisují do stejného souboru: {4}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_Title">
+        <source>Two tasks should not write the same file.</source>
+        <target state="translated">Dvě úlohy by neměly zapisovat do stejného souboru.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageAddendum">
+        <source>'{0}' with value: '{1}'</source>
+        <target state="translated">{0} s hodnotou {1}</target>
+        <note>Will be used as a parameter {0} in previous message.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageFmt">
+        <source>Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.</source>
+        <target state="translated">Vlastnost je odvozena z proměnné prostředí: {0}. Vlastnosti by měly být předány explicitně pomocí parametru /p.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_Title">
+        <source>No implicit property derived from an environment variable should be used during the build.</source>
+        <target state="translated">Během sestavování by se neměla používat žádná implicitní vlastnost odvozená z proměnné prostředí.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_MessageFmt">
+        <source>Property: '{0}' was accessed, but it was never initialized.</source>
+        <target state="translated">K vlastnosti: {0} bylo přistupováno, ale nebyla nikdy inicializována.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_Title">
+        <source>A property that is accessed should be declared first.</source>
+        <target state="translated">Vlastnost, ke které se přistupuje, by se měla nejdříve deklarovat.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_MessageFmt">
+        <source>Property: '{0}' first declared/initialized at {1} used before it was initialized.</source>
+        <target state="translated">Vlastnost: {0} poprvé deklarována/inicializována v {1} byla použita dříve, než byla inicializována.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_Title">
+        <source>A property should be declared before it is first used.</source>
+        <target state="translated">Vlastnost by měla být před prvním použitím deklarována.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_MessageFmt">
+        <source>Property: '{0}' was declared/initialized, but it was never used.</source>
+        <target state="translated">Vlastnost: {0} byla deklarována nebo inicializována, ale nebyla nikdy použita.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_Title">
+        <source>A property that is not used should not be declared.</source>
+        <target state="translated">Vlastnost, která se nepoužívá, by se neměla deklarovat.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Vytvoření otázky SELHALO. Vytváření bylo předčasně ukončeno, protože se při něm narazilo na cíl nebo úlohu, které nebyly aktuální.</target>
@@ -222,6 +287,11 @@
         <target state="translated">Nepodařilo se najít zadané sestavení vlastní kontroly: {0}. Zkontrolujte prosím, jestli existuje.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">Nepodařilo se načíst typ vlastní kontroly: {0} ze sestavení: {1}. Ujistěte se, že dědí základní třídu Microsoft.Build.Experimental.BuildCheck.Check. Pokud se nemá jednat o vlastní kontrolu, neměl by být exponovaný. Další informace: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
@@ -310,7 +380,7 @@
       </trans-unit>
       <trans-unit id="IllegalCharactersInFileOrDirectory">
         <source>There are illegal characters in '{0}' in the {1} item.</source>
-        <target state="new">There are illegal characters in '{0}' in the {1} item.</target>
+        <target state="translated">V položce {1} jsou v „{0}“ neplatné znaky.</target>
         <note />
       </trans-unit>
       <trans-unit id="ImportedProjectFromVSDistribution">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index b4f65c4508e..91ed701c9fd 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -136,6 +136,71 @@
         <target state="translated">BuildCheck ist für diesen Build aktiviert.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_MessageFmt">
+        <source>Projects {0} and {1} have conflicting output paths: {2}.</source>
+        <target state="translated">Projekte „{0}“ und „{1}“ haben in Konflikt stehende Ausgabepfade: {2}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_Title">
+        <source>Two projects should not share their 'OutputPath' nor 'IntermediateOutputPath' locations.</source>
+        <target state="translated">Zwei Projekte sollten ihre Speicherorte „OutputPath“ und „IntermediateOutputPath“ nicht gemeinsam nutzen.</target>
+        <note>'OutputPath' and 'IntermediateOutputPath' not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_MessageFmt">
+        <source>Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.</source>
+        <target state="translated">Tasks „{0}“ und „{1}“ aus Projekten „{2}“ und „{3}“ schreiben dieselbe Datei: {4}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_Title">
+        <source>Two tasks should not write the same file.</source>
+        <target state="translated">Zwei Tasks sollten nicht dieselbe Datei schreiben.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageAddendum">
+        <source>'{0}' with value: '{1}'</source>
+        <target state="translated">„{0}“ mit Wert: „{1}“</target>
+        <note>Will be used as a parameter {0} in previous message.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageFmt">
+        <source>Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.</source>
+        <target state="translated">Die Eigenschaft wird von der Umgebungsvariablen abgeleitet: {0}. Eigenschaften sollten explizit mithilfe der Option /p übergeben werden.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_Title">
+        <source>No implicit property derived from an environment variable should be used during the build.</source>
+        <target state="translated">Während der Erstellung sollte keine implizite Eigenschaft verwendet werden, die von einer Umgebungsvariablen abgeleitet ist.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_MessageFmt">
+        <source>Property: '{0}' was accessed, but it was never initialized.</source>
+        <target state="translated">Auf die Eigenschaft „{0}“ wurde zugegriffen, sie wurde jedoch nie initialisiert.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_Title">
+        <source>A property that is accessed should be declared first.</source>
+        <target state="translated">Eine Eigenschaft, auf die zugegriffen wird, sollte zuerst deklariert werden.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_MessageFmt">
+        <source>Property: '{0}' first declared/initialized at {1} used before it was initialized.</source>
+        <target state="translated">Eigenschaft: „{0}“ wurde zuerst bei „{1}“ deklariert/initialisiert, die vor der Initialisierung verwendet wurde.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_Title">
+        <source>A property should be declared before it is first used.</source>
+        <target state="translated">Eine Eigenschaft sollte deklariert werden, bevor sie zum ersten Mal verwendet wird.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_MessageFmt">
+        <source>Property: '{0}' was declared/initialized, but it was never used.</source>
+        <target state="translated">Eigenschaft: „{0}“ wurde deklariert/initialisiert, aber nie verwendet.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_Title">
+        <source>A property that is not used should not be declared.</source>
+        <target state="translated">Eine Eigenschaft, die nicht verwendet wird, sollte nicht deklariert werden.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Fehler beim Erstellen der Frage. Der Build wurde früh beendet, da ein Ziel oder eine Aufgabe gefunden wurde, die nicht aktuell war.</target>
@@ -222,6 +287,11 @@
         <target state="translated">Fehler beim Suchen der angegebenen benutzerdefinierten Prüfassembly: {0}. Überprüfen Sie, ob sie vorhanden ist.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">Fehler beim Laden des benutzerdefinierten Prüftyps „{0}“ aus der Assembly: {1}. Stellen Sie sicher, dass es die Basisklasse „Microsoft.Build.Experimental.BuildCheck.Check“ erbt. Wenn es sich nicht um eine benutzerdefinierte Überprüfung handelt, sollte es nicht verfügbar gemacht werden. Weitere Informationen: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
@@ -310,7 +380,7 @@
       </trans-unit>
       <trans-unit id="IllegalCharactersInFileOrDirectory">
         <source>There are illegal characters in '{0}' in the {1} item.</source>
-        <target state="new">There are illegal characters in '{0}' in the {1} item.</target>
+        <target state="translated">Unzulässige Zeichen in „{0}“ im {1}-Element.</target>
         <note />
       </trans-unit>
       <trans-unit id="ImportedProjectFromVSDistribution">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 7999d29cc19..74b791c90f7 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -136,6 +136,71 @@
         <target state="translated">BuildCheck está habilitado para esta compilación.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_MessageFmt">
+        <source>Projects {0} and {1} have conflicting output paths: {2}.</source>
+        <target state="translated">Los proyectos {0} y {1} tienen rutas de acceso de salida en conflicto: {2}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_Title">
+        <source>Two projects should not share their 'OutputPath' nor 'IntermediateOutputPath' locations.</source>
+        <target state="translated">Dos proyectos no deben compartir sus ubicaciones "OutputPath" ni "IntermediateOutputPath".</target>
+        <note>'OutputPath' and 'IntermediateOutputPath' not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_MessageFmt">
+        <source>Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.</source>
+        <target state="translated">Las tareas {0} y {1} de los proyectos {2} y {3} escriben el mismo archivo: {4}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_Title">
+        <source>Two tasks should not write the same file.</source>
+        <target state="translated">Dos tareas no deben escribir el mismo archivo.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageAddendum">
+        <source>'{0}' with value: '{1}'</source>
+        <target state="translated">"{0}" con el valor: "{1}"</target>
+        <note>Will be used as a parameter {0} in previous message.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageFmt">
+        <source>Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.</source>
+        <target state="translated">La propiedad se deriva de la variable de entorno: {0}. Las propiedades se deben pasar explícitamente mediante la opción /p.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_Title">
+        <source>No implicit property derived from an environment variable should be used during the build.</source>
+        <target state="translated">No se debe usar ninguna propiedad implícita derivada de una variable de entorno durante la compilación.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_MessageFmt">
+        <source>Property: '{0}' was accessed, but it was never initialized.</source>
+        <target state="translated">Propiedad: se obtuvo acceso a "{0}", pero nunca se inicializó.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_Title">
+        <source>A property that is accessed should be declared first.</source>
+        <target state="translated">Una propiedad a la que se tiene acceso debe declararse primero.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_MessageFmt">
+        <source>Property: '{0}' first declared/initialized at {1} used before it was initialized.</source>
+        <target state="translated">Propiedad: "{0}" se declaró o inicializó por primera vez en {1} usado antes de inicializarse.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_Title">
+        <source>A property should be declared before it is first used.</source>
+        <target state="translated">Una propiedad debe declararse antes de que se use por primera vez.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_MessageFmt">
+        <source>Property: '{0}' was declared/initialized, but it was never used.</source>
+        <target state="translated">Propiedad: "{0}" se declaró o inicializó, pero nunca se usó.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_Title">
+        <source>A property that is not used should not be declared.</source>
+        <target state="translated">No se debe declarar una propiedad que no se use.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">La creación de la pregunta ha FALLADO. La creación finalizó antes de tiempo al encontrar un objetivo o tarea que no estaba actualizado.</target>
@@ -222,6 +287,11 @@
         <target state="translated">No se pudo encontrar el ensamblado de comprobación personalizado especificado: "{0}". Compruebe si existe.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">No se pudo cargar el tipo de comprobación personalizado: "{0}" desde el ensamblado: "{1}". Asegúrese de que hereda la clase base Microsoft.Build.Experimental.BuildCheck.Check. Si no está pensado para ser una comprobación personalizada, no debe exponerse. Más información: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
@@ -310,7 +380,7 @@
       </trans-unit>
       <trans-unit id="IllegalCharactersInFileOrDirectory">
         <source>There are illegal characters in '{0}' in the {1} item.</source>
-        <target state="new">There are illegal characters in '{0}' in the {1} item.</target>
+        <target state="translated">Hay caracteres no válidos en '{0}' en el elemento {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="ImportedProjectFromVSDistribution">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 1dc4f45c118..a2a7f46f41d 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -136,6 +136,71 @@
         <target state="translated">BuildCheck est activé pour cette build.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_MessageFmt">
+        <source>Projects {0} and {1} have conflicting output paths: {2}.</source>
+        <target state="translated">Les projets {0} et {1} ont des chemins de sortie en conflit : {2}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_Title">
+        <source>Two projects should not share their 'OutputPath' nor 'IntermediateOutputPath' locations.</source>
+        <target state="translated">Deux projets ne doivent pas partager leurs emplacements « OutputPath » ni « IntermediateOutputPath ».</target>
+        <note>'OutputPath' and 'IntermediateOutputPath' not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_MessageFmt">
+        <source>Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.</source>
+        <target state="translated">Tâches {0} et {1} de projets {2} et {3} écrivez le même fichier : {4}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_Title">
+        <source>Two tasks should not write the same file.</source>
+        <target state="translated">Deux tâches ne doivent pas écrire le même fichier.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageAddendum">
+        <source>'{0}' with value: '{1}'</source>
+        <target state="translated">'{0}' avec valeur : '{1}'</target>
+        <note>Will be used as a parameter {0} in previous message.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageFmt">
+        <source>Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.</source>
+        <target state="translated">La propriété est dérivée de la variable d'environnement : {0}. Les propriétés doivent être transmises explicitement à l'aide de l'option /p.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_Title">
+        <source>No implicit property derived from an environment variable should be used during the build.</source>
+        <target state="translated">Aucune propriété implicite dérivée d'une variable d'environnement ne doit être utilisée pendant la construction.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_MessageFmt">
+        <source>Property: '{0}' was accessed, but it was never initialized.</source>
+        <target state="translated">Propriété : « {0} » a été consultée, mais elle n'a jamais été initialisée.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_Title">
+        <source>A property that is accessed should be declared first.</source>
+        <target state="translated">Une propriété à laquelle on accède doit d’abord être déclarée.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_MessageFmt">
+        <source>Property: '{0}' first declared/initialized at {1} used before it was initialized.</source>
+        <target state="translated">Propriété : '{0}' déclarée/initialisée pour la première fois à l'utilisation de {1} avant d'être initialisée.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_Title">
+        <source>A property should be declared before it is first used.</source>
+        <target state="translated">Une propriété doit être déclarée avant sa première utilisation.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_MessageFmt">
+        <source>Property: '{0}' was declared/initialized, but it was never used.</source>
+        <target state="translated">Propriété : '{0}' a été déclarée/initialisée, mais elle n'a jamais été utilisée.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_Title">
+        <source>A property that is not used should not be declared.</source>
+        <target state="translated">Une propriété qui n'est pas utilisée ne doit pas être déclarée.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">ÉCHEC de la génération de la question. La génération s’est arrêtée tôt, car elle a rencontré une cible ou une tâche qui n’était pas à jour.</target>
@@ -222,6 +287,11 @@
         <target state="translated">Impossible de trouver l’assembly de vérification personnalisé spécifié : «{0}». Veuillez vérifier s’il existe.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">Échec du chargement du type de vérification personnalisé «{0}» à partir de l’assembly : «{1}». Assurez-vous qu’il hérite de la classe de base Microsoft.Build.Experimental.BuildCheck.Check. S’il ne s’agit pas d’une vérification personnalisée, elle ne doit pas être exposée. Plus d’informations : https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
@@ -310,7 +380,7 @@
       </trans-unit>
       <trans-unit id="IllegalCharactersInFileOrDirectory">
         <source>There are illegal characters in '{0}' in the {1} item.</source>
-        <target state="new">There are illegal characters in '{0}' in the {1} item.</target>
+        <target state="translated">Il existe des caractères non conformes dans « {0} » dans l’élément {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="ImportedProjectFromVSDistribution">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 6b49d22631f..04ba91d7a23 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -136,6 +136,71 @@
         <target state="translated">BuildCheck è abilitato per questa compilazione.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_MessageFmt">
+        <source>Projects {0} and {1} have conflicting output paths: {2}.</source>
+        <target state="translated">I percorsi di output dei progetti {0} e {1} sono in conflitto: {2}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_Title">
+        <source>Two projects should not share their 'OutputPath' nor 'IntermediateOutputPath' locations.</source>
+        <target state="translated">Due progetti non devono condividere i percorsi 'OutputPath' o 'IntermediateOutputPath'.</target>
+        <note>'OutputPath' and 'IntermediateOutputPath' not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_MessageFmt">
+        <source>Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.</source>
+        <target state="translated">Le attività {0} e {1} dai progetti {2} e {3} scrivere lo stesso file: {4}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_Title">
+        <source>Two tasks should not write the same file.</source>
+        <target state="translated">Due attività non devono scrivere lo stesso file.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageAddendum">
+        <source>'{0}' with value: '{1}'</source>
+        <target state="translated">'{0}' con il valore: '{1}'</target>
+        <note>Will be used as a parameter {0} in previous message.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageFmt">
+        <source>Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.</source>
+        <target state="translated">La proprietà è derivata dalla variabile di ambiente: {0}. Le proprietà devono essere passate in modo esplicito utilizzando l'opzione /p.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_Title">
+        <source>No implicit property derived from an environment variable should be used during the build.</source>
+        <target state="translated">Durante la compilazione non deve essere usata alcuna proprietà implicita derivata da una variabile di ambiente.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_MessageFmt">
+        <source>Property: '{0}' was accessed, but it was never initialized.</source>
+        <target state="translated">È stato eseguito l'accesso alla proprietà '{0}', ma non è mai stata inizializzata.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_Title">
+        <source>A property that is accessed should be declared first.</source>
+        <target state="translated">È prima necessario dichiarare una proprietà a cui si accede.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_MessageFmt">
+        <source>Property: '{0}' first declared/initialized at {1} used before it was initialized.</source>
+        <target state="translated">Proprietà: '{0}' prima dichiarata/inizializzata in {1} utilizzata prima dell'inizializzazione.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_Title">
+        <source>A property should be declared before it is first used.</source>
+        <target state="translated">È necessario dichiarare una proprietà prima di utilizzarla per la prima volta.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_MessageFmt">
+        <source>Property: '{0}' was declared/initialized, but it was never used.</source>
+        <target state="translated">La proprietà: '{0}' è stata dichiarata/inizializzata, ma non è mai stata utilizzata.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_Title">
+        <source>A property that is not used should not be declared.</source>
+        <target state="translated">Una proprietà non utilizzata non deve essere dichiarata.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Compilazione della domanda NON RIUSCITA. La compilazione è terminata in anticipo perché è stata rilevata una destinazione o un'attività non aggiornata.</target>
@@ -222,6 +287,11 @@
         <target state="translated">Impossibile trovare l'assembly di controllo personalizzato specificato: “{0}”. Verificare se esiste.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">Non è stato possibile caricare il tipo di controllo personalizzato: “{0}” dall'assembly: “{1}”. Assicurarsi che erediti la classe di base Microsoft.Build.Experimental.BuildCheck.Check. Se non è destinato a essere un controllo personalizzato, non deve essere esposto. Per altre informazioni: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
@@ -310,7 +380,7 @@
       </trans-unit>
       <trans-unit id="IllegalCharactersInFileOrDirectory">
         <source>There are illegal characters in '{0}' in the {1} item.</source>
-        <target state="new">There are illegal characters in '{0}' in the {1} item.</target>
+        <target state="translated">Sono presenti caratteri non validi in '{0}' nell'elemento {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="ImportedProjectFromVSDistribution">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index e41eb339db4..5e040372f98 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -136,6 +136,71 @@
         <target state="translated">BuildCheck は、このビルドに対して有効になっています。</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_MessageFmt">
+        <source>Projects {0} and {1} have conflicting output paths: {2}.</source>
+        <target state="translated">プロジェクト {0} と {1} の出力パスが競合しています: {2}。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_Title">
+        <source>Two projects should not share their 'OutputPath' nor 'IntermediateOutputPath' locations.</source>
+        <target state="translated">2 つのプロジェクトで 'OutputPath' と 'IntermediateOutputPath' の場所を共有することはできません。</target>
+        <note>'OutputPath' and 'IntermediateOutputPath' not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_MessageFmt">
+        <source>Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.</source>
+        <target state="translated">プロジェクト {2} と {3} のタスク {0} と {1} は、同じファイルを書き込みます: {4}。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_Title">
+        <source>Two tasks should not write the same file.</source>
+        <target state="translated">2 つのタスクで同じファイルに書き込むべきではありません。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageAddendum">
+        <source>'{0}' with value: '{1}'</source>
+        <target state="translated">'{0}' (値 '{1}')</target>
+        <note>Will be used as a parameter {0} in previous message.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageFmt">
+        <source>Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.</source>
+        <target state="translated">プロパティは環境変数から派生しています: {0}。プロパティは、/p オプションを使用して明示的に渡す必要があります。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_Title">
+        <source>No implicit property derived from an environment variable should be used during the build.</source>
+        <target state="translated">ビルド中に環境変数から派生した暗黙的なプロパティを使用しないでください。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_MessageFmt">
+        <source>Property: '{0}' was accessed, but it was never initialized.</source>
+        <target state="translated">プロパティ: '{0}' にアクセスしましたが、初期化されませんでした。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_Title">
+        <source>A property that is accessed should be declared first.</source>
+        <target state="translated">アクセスされるプロパティを、まず宣言する必要があります。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_MessageFmt">
+        <source>Property: '{0}' first declared/initialized at {1} used before it was initialized.</source>
+        <target state="translated">{1} で最初に宣言/初期化されたプロパティ: '{0}' は初期化前に使用されました。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_Title">
+        <source>A property should be declared before it is first used.</source>
+        <target state="translated">プロパティは、最初に使用する前に宣言する必要があります。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_MessageFmt">
+        <source>Property: '{0}' was declared/initialized, but it was never used.</source>
+        <target state="translated">プロパティ: '{0}' は宣言または初期化されましたが、使用されませんでした。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_Title">
+        <source>A property that is not used should not be declared.</source>
+        <target state="translated">使用されていないプロパティは宣言しないでください。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">質問のビルドに失敗しました。ビルドは、最新ではないターゲットまたはタスクが検出されたため、早期に終了しました。</target>
@@ -222,6 +287,11 @@
         <target state="translated">指定されたカスタム チェック アセンブリが見つかりませんでした: '{0}'。存在するかどうか確認してください。</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">カスタム チェックの種類を読み込めませんでした: アセンブリ '{1}' の '{0}'。Microsoft.Build.Experimental.BuildCheck.Check 基底クラスを継承していることを確認してください。カスタム チェックを意図していない場合は、公開しないでください。詳細情報: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
@@ -310,7 +380,7 @@
       </trans-unit>
       <trans-unit id="IllegalCharactersInFileOrDirectory">
         <source>There are illegal characters in '{0}' in the {1} item.</source>
-        <target state="new">There are illegal characters in '{0}' in the {1} item.</target>
+        <target state="translated">{1} 項目内の '{0}' に不正な文字があります。</target>
         <note />
       </trans-unit>
       <trans-unit id="ImportedProjectFromVSDistribution">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 9de6844b7d1..58ce075c959 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -136,6 +136,71 @@
         <target state="translated">이 빌드에 대해 BuildCheck를 사용할 수 있습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_MessageFmt">
+        <source>Projects {0} and {1} have conflicting output paths: {2}.</source>
+        <target state="translated">프로젝트 {0} 및 {1} 출력 경로가 충돌합니다. {2}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_Title">
+        <source>Two projects should not share their 'OutputPath' nor 'IntermediateOutputPath' locations.</source>
+        <target state="translated">두 프로젝트는 'OutputPath' 또는 'IntermediateOutputPath' 위치를 공유해서는 안 됩니다.</target>
+        <note>'OutputPath' and 'IntermediateOutputPath' not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_MessageFmt">
+        <source>Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.</source>
+        <target state="translated">{2} 및 {3} 프로젝트에서 작업 {0} 및 {1} 동일한 파일에 작성: {4}</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_Title">
+        <source>Two tasks should not write the same file.</source>
+        <target state="translated">두 작업에서 같은 파일을 쓰면 안 됩니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageAddendum">
+        <source>'{0}' with value: '{1}'</source>
+        <target state="translated">값이 있는 '{0}': '{1}'</target>
+        <note>Will be used as a parameter {0} in previous message.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageFmt">
+        <source>Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.</source>
+        <target state="translated">속성은 환경 변수 {0}에서 파생됩니다. /p 옵션을 사용하여 속성을 명시적으로 전달해야 합니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_Title">
+        <source>No implicit property derived from an environment variable should be used during the build.</source>
+        <target state="translated">빌드하는 동안 환경 변수에서 파생된 암시적 속성을 사용하면 안 됩니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_MessageFmt">
+        <source>Property: '{0}' was accessed, but it was never initialized.</source>
+        <target state="translated">속성: '{0}'에 액세스했지만 초기화되지 않았습니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_Title">
+        <source>A property that is accessed should be declared first.</source>
+        <target state="translated">액세스하는 속성을 먼저 선언해야 합니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_MessageFmt">
+        <source>Property: '{0}' first declared/initialized at {1} used before it was initialized.</source>
+        <target state="translated">속성: '{0}'(이)가 초기화되기 전에 사용된 {1} 첫 번째 선언/초기화되었습니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_Title">
+        <source>A property should be declared before it is first used.</source>
+        <target state="translated">속성을 처음 사용하려면 먼저 선언해야 합니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_MessageFmt">
+        <source>Property: '{0}' was declared/initialized, but it was never used.</source>
+        <target state="translated">속성: '{0}'이(가) 선언/초기화되었지만 사용되지 않았습니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_Title">
+        <source>A property that is not used should not be declared.</source>
+        <target state="translated">사용되지 않는 속성은 선언하면 안 됩니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">질문 빌드에 실패했습니다. 빌드가 최신이 아닌 대상 또는 작업을 발견하여 일찍 종료되었습니다.</target>
@@ -222,6 +287,11 @@
         <target state="translated">지정한 사용자 지정 검사 어셈블리를 찾지 못했습니다. '{0}'. 있는지 확인하세요.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">어셈블리에서 사용자 지정 검사 유형 '{0}'을(를) 로드하지 못했습니다. '{1}'. Microsoft.Build.Experimental.BuildCheck.Check 기본 클래스를 상속해야 합니다. 사용자 지정 검사가 아닌 경우 노출되지 않아야 합니다. 추가 정보: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
@@ -310,7 +380,7 @@
       </trans-unit>
       <trans-unit id="IllegalCharactersInFileOrDirectory">
         <source>There are illegal characters in '{0}' in the {1} item.</source>
-        <target state="new">There are illegal characters in '{0}' in the {1} item.</target>
+        <target state="translated">{1} 항목의 '{0}'에 허용되지 않는 문자가 있습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="ImportedProjectFromVSDistribution">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 5e238c643f8..5298a7ddf4c 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -136,6 +136,71 @@
         <target state="translated">Dla tej kompilacji włączono funkcję BuildCheck.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_MessageFmt">
+        <source>Projects {0} and {1} have conflicting output paths: {2}.</source>
+        <target state="translated">Projekty {0} i {1} mają ścieżki wyjściowe powodujące konflikt: {2}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_Title">
+        <source>Two projects should not share their 'OutputPath' nor 'IntermediateOutputPath' locations.</source>
+        <target state="translated">Dwa projekty nie powinny współużytkować lokalizacji „OutputPath” ani „IntermediateOutputPath”.</target>
+        <note>'OutputPath' and 'IntermediateOutputPath' not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_MessageFmt">
+        <source>Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.</source>
+        <target state="translated">Zadania {0} i {1} z projektów {2} oraz {3} zapisują ten sam plik: {4}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_Title">
+        <source>Two tasks should not write the same file.</source>
+        <target state="translated">Dwa zadania nie powinny zapisywać tego samego pliku.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageAddendum">
+        <source>'{0}' with value: '{1}'</source>
+        <target state="translated">„{0}” z wartością „{1}”</target>
+        <note>Will be used as a parameter {0} in previous message.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageFmt">
+        <source>Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.</source>
+        <target state="translated">Właściwość jest pochodną zmiennej środowiskowej: {0}. Właściwości powinny być przekazywane jawnie przy użyciu opcji /p.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_Title">
+        <source>No implicit property derived from an environment variable should be used during the build.</source>
+        <target state="translated">Podczas kompilacji nie należy używać żadnej niejawnej właściwości pochodzącej ze zmiennej środowiskowej.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_MessageFmt">
+        <source>Property: '{0}' was accessed, but it was never initialized.</source>
+        <target state="translated">Właściwość: uzyskano dostęp do „{0}”, ale nigdy nie dokonano inicjacji.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_Title">
+        <source>A property that is accessed should be declared first.</source>
+        <target state="translated">Właściwość, do których jest uzyskiwany dostęp, powinna być zadeklarowana jako pierwsza.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_MessageFmt">
+        <source>Property: '{0}' first declared/initialized at {1} used before it was initialized.</source>
+        <target state="translated">Właściwość: „{0}” została najpierw zadeklarowana/zainicjowana {1} i była używania przed jej zainicjowaniem.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_Title">
+        <source>A property should be declared before it is first used.</source>
+        <target state="translated">Właściwość powinna być zadeklarowana przed jej pierwszym użyciem.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_MessageFmt">
+        <source>Property: '{0}' was declared/initialized, but it was never used.</source>
+        <target state="translated">Właściwość: uzyskano dostęp do „{0}”, ale nigdy nie dokonano inicjacji.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_Title">
+        <source>A property that is not used should not be declared.</source>
+        <target state="translated">Nie należy deklarować właściwości, która nie jest używana.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">NIEPOWODZENIE kompilacji pytania. Kompilacja została zakończona wcześniej, ponieważ napotkała element docelowy lub zadanie, które nie było aktualne.</target>
@@ -222,6 +287,11 @@
         <target state="translated">Nie udało się znaleźć określonego niestandardowego zestawu kontrolnego: „{0}”. Sprawdź, czy istnieje.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">Nie udało się załadować niestandardowego typu kontrolnego: „{0}” z zestawu: „{1}”. Upewnij się, że dziedziczy po klasie bazowej Microsoft.Build.Experimental.BuildCheck.Check. Jeśli nie ma to być kontrola niestandardowa, to nie powinna być ona ujawniana. Więcej informacji: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
@@ -310,7 +380,7 @@
       </trans-unit>
       <trans-unit id="IllegalCharactersInFileOrDirectory">
         <source>There are illegal characters in '{0}' in the {1} item.</source>
-        <target state="new">There are illegal characters in '{0}' in the {1} item.</target>
+        <target state="translated">Element {0} zawiera niedozwolone znaki w „{1}”.</target>
         <note />
       </trans-unit>
       <trans-unit id="ImportedProjectFromVSDistribution">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 7da61784e66..69b4337e10f 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -136,6 +136,71 @@
         <target state="translated">O BuildCheck está habilitado para esse build.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_MessageFmt">
+        <source>Projects {0} and {1} have conflicting output paths: {2}.</source>
+        <target state="translated">Os projetos {0} e {1} têm caminhos de saída conflitantes: {2}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_Title">
+        <source>Two projects should not share their 'OutputPath' nor 'IntermediateOutputPath' locations.</source>
+        <target state="translated">Dois projetos não devem compartilhar seus locais "OutputPath" nem "IntermediateOutputPath".</target>
+        <note>'OutputPath' and 'IntermediateOutputPath' not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_MessageFmt">
+        <source>Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.</source>
+        <target state="translated">As tarefas {0} e {1} dos projetos {2} e {3} gravam o mesmo arquivo: {4}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_Title">
+        <source>Two tasks should not write the same file.</source>
+        <target state="translated">Duas tarefas não devem gravar o mesmo arquivo.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageAddendum">
+        <source>'{0}' with value: '{1}'</source>
+        <target state="translated">"{0}" com valor: "{1}"</target>
+        <note>Will be used as a parameter {0} in previous message.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageFmt">
+        <source>Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.</source>
+        <target state="translated">A propriedade é derivada da variável de ambiente: {0}. As propriedades devem ser passadas explicitamente usando a opção /p.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_Title">
+        <source>No implicit property derived from an environment variable should be used during the build.</source>
+        <target state="translated">Nenhuma propriedade implícita derivada de uma variável de ambiente deve ser usada durante o build.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_MessageFmt">
+        <source>Property: '{0}' was accessed, but it was never initialized.</source>
+        <target state="translated">Propriedade: "{0}" foi acessada, mas nunca foi inicializada.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_Title">
+        <source>A property that is accessed should be declared first.</source>
+        <target state="translated">Uma propriedade acessada deve ser declarada primeiro.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_MessageFmt">
+        <source>Property: '{0}' first declared/initialized at {1} used before it was initialized.</source>
+        <target state="translated">Propriedade: "{0}" primeiro declarada/inicializada em {1}, usada antes de ser inicializada.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_Title">
+        <source>A property should be declared before it is first used.</source>
+        <target state="translated">Uma propriedade deve ser declarada antes de ser usada pela primeira vez.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_MessageFmt">
+        <source>Property: '{0}' was declared/initialized, but it was never used.</source>
+        <target state="translated">Propriedade: "{0}" foi declarada/inicializada, mas nunca foi usada.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_Title">
+        <source>A property that is not used should not be declared.</source>
+        <target state="translated">Uma propriedade que não é usada não deve ser declarada.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">FALHA na compilação da pergunta. A compilação foi encerrada antecipadamente ao se deparar com um alvo ou tarefa que não estava atualizado.</target>
@@ -222,6 +287,11 @@
         <target state="translated">Falha ao localizar o assembly de verificação personalizado especificado: '{0}'. Verifique se existe.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">Falha ao carregar o tipo de verificação personalizada: '{0}' do assembly: '{1}'. Certifique-se de que ele herda a classe base Microsoft.Build.Experimental.BuildCheck.Check. Se não for destinado a ser uma verificação personalizada, então não deve ser exposto. Mais informações: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
@@ -310,7 +380,7 @@
       </trans-unit>
       <trans-unit id="IllegalCharactersInFileOrDirectory">
         <source>There are illegal characters in '{0}' in the {1} item.</source>
-        <target state="new">There are illegal characters in '{0}' in the {1} item.</target>
+        <target state="translated">Há caracteres inválidos em "{0}" no item {1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="ImportedProjectFromVSDistribution">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 8c3029e78a5..4a51ab49b0f 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -136,6 +136,71 @@
         <target state="translated">Для этой сборки включен параметр BuildCheck.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_MessageFmt">
+        <source>Projects {0} and {1} have conflicting output paths: {2}.</source>
+        <target state="translated">Проекты {0} и {1} имеют конфликтующие выходные пути: {2}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_Title">
+        <source>Two projects should not share their 'OutputPath' nor 'IntermediateOutputPath' locations.</source>
+        <target state="translated">Два проекта не должны совместно использовать расположения "OutputPath" и "IntermediateOutputPath".</target>
+        <note>'OutputPath' and 'IntermediateOutputPath' not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_MessageFmt">
+        <source>Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.</source>
+        <target state="translated">Задачи {0} и {1} из проектов {2} и {3} записывают один и тот же файл: {4}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_Title">
+        <source>Two tasks should not write the same file.</source>
+        <target state="translated">Две задачи не должны записывать один и тот же файл.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageAddendum">
+        <source>'{0}' with value: '{1}'</source>
+        <target state="translated">"{0}" со значением: "{1}"</target>
+        <note>Will be used as a parameter {0} in previous message.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageFmt">
+        <source>Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.</source>
+        <target state="translated">Свойство является производным от переменной среды: {0}. Свойства следует передавать явно с помощью параметра /p.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_Title">
+        <source>No implicit property derived from an environment variable should be used during the build.</source>
+        <target state="translated">Во время сборки не следует использовать неявные свойства, полученные из переменной среды.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_MessageFmt">
+        <source>Property: '{0}' was accessed, but it was never initialized.</source>
+        <target state="translated">Свойство: к "{0}" получен доступ, но он не инициализирован.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_Title">
+        <source>A property that is accessed should be declared first.</source>
+        <target state="translated">Свойство, к которому осуществляется доступ, должно быть объявлено первым.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_MessageFmt">
+        <source>Property: '{0}' first declared/initialized at {1} used before it was initialized.</source>
+        <target state="translated">Свойство: "{0}" впервые объявлено или инициализировано в {1} и используется до его инициализации.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_Title">
+        <source>A property should be declared before it is first used.</source>
+        <target state="translated">Свойство должно быть объявлено до его первого использования.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_MessageFmt">
+        <source>Property: '{0}' was declared/initialized, but it was never used.</source>
+        <target state="translated">Свойство: "{0}" объявлено или инициализировано, но оно никогда не использовалось.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_Title">
+        <source>A property that is not used should not be declared.</source>
+        <target state="translated">Не следует объявлять свойство, которое не используется.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">СБОЙ сборки вопроса. Выход из сборки выполнен раньше, так как была обнаружена цель или задача без обновления.</target>
@@ -222,6 +287,11 @@
         <target state="translated">Не удалось найти указанную сборку настраиваемой проверки "{0}". Убедитесь, что она существует.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">Не удалось загрузить тип настраиваемой проверки "{0}" из сборки "{1}". Убедитесь, что он наследует базовый класс Microsoft.Build.Experimental.BuildCheck.Check. Если он не предназначен для настраиваемой проверки, его не следует предоставлять. Подробнее: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
@@ -310,7 +380,7 @@
       </trans-unit>
       <trans-unit id="IllegalCharactersInFileOrDirectory">
         <source>There are illegal characters in '{0}' in the {1} item.</source>
-        <target state="new">There are illegal characters in '{0}' in the {1} item.</target>
+        <target state="translated">В "{0}" в элементе {1} есть запрещенные символы.</target>
         <note />
       </trans-unit>
       <trans-unit id="ImportedProjectFromVSDistribution">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 89c3c80f142..08bb0299385 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -136,6 +136,71 @@
         <target state="translated">BuildCheck bu derleme için etkinleştirildi.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_MessageFmt">
+        <source>Projects {0} and {1} have conflicting output paths: {2}.</source>
+        <target state="translated">{0} ve {1} projelerinin çakışan çıkış yolları var: {2}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_Title">
+        <source>Two projects should not share their 'OutputPath' nor 'IntermediateOutputPath' locations.</source>
+        <target state="translated">İki proje kendi 'OutputPath' veya 'IntermediateOutputPath' konumlarını paylaşmamalıdır.</target>
+        <note>'OutputPath' and 'IntermediateOutputPath' not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_MessageFmt">
+        <source>Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.</source>
+        <target state="translated">{2} ve {3} projelerindeki {0} ve {1} görevleri aynı dosyayı yazıyor: {4}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_Title">
+        <source>Two tasks should not write the same file.</source>
+        <target state="translated">İki görev aynı dosyayı yazmamalıdır.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageAddendum">
+        <source>'{0}' with value: '{1}'</source>
+        <target state="translated">'{1}' değerine sahip '{0}'</target>
+        <note>Will be used as a parameter {0} in previous message.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageFmt">
+        <source>Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.</source>
+        <target state="translated">Özellik şu ortam değişkeninden türetilir: {0}. Özellikler, /p seçeneği kullanılarak açıkça geçirilmelidir.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_Title">
+        <source>No implicit property derived from an environment variable should be used during the build.</source>
+        <target state="translated">Derleme sırasında bir ortam değişkeninden türetilen hiçbir örtük özellik kullanılmamalıdır.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_MessageFmt">
+        <source>Property: '{0}' was accessed, but it was never initialized.</source>
+        <target state="translated">'{0}' özelliğine erişildi, ancak hiç başlatılmadı.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_Title">
+        <source>A property that is accessed should be declared first.</source>
+        <target state="translated">Erişilen bir özelliğin önce bildirilmesi gerekir.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_MessageFmt">
+        <source>Property: '{0}' first declared/initialized at {1} used before it was initialized.</source>
+        <target state="translated">İlk olarak {1} konumunda bildirilmiş/başlatılmış '{0}' özelliği başlatılmadan önce kullanıldı.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_Title">
+        <source>A property should be declared before it is first used.</source>
+        <target state="translated">Özellik ilk olarak kullanılmadan önce bildirilmelidir.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_MessageFmt">
+        <source>Property: '{0}' was declared/initialized, but it was never used.</source>
+        <target state="translated">'{0}' özelliği bildirildi/başlatıldı, ancak hiç kullanılmadı.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_Title">
+        <source>A property that is not used should not be declared.</source>
+        <target state="translated">Kullanılmamış bir özellik bildirilmemelidir.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Soru derleme BAŞARISIZ oldu. Güncel olmayan bir hedef veya görev ile karşılaştığından derleme işleminden erken çıkıldı.</target>
@@ -222,6 +287,11 @@
         <target state="translated">Belirtilen özel denetim derlemesi bulunamadı: '{0}'. Lütfen var olup olmadığını kontrol edin.</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">‘{0}’ özel denetim türü ‘{1}’ derlemesinden yüklenemedi. Microsoft.Build.Experimental.BuildCheck.Check temel sınıfını devralmış olduğundan emin olun. Özel bir denetim olması amaçlanmadıysa açığa çıkarılmaması gerekir. Daha fazla bilgi: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
@@ -310,7 +380,7 @@
       </trans-unit>
       <trans-unit id="IllegalCharactersInFileOrDirectory">
         <source>There are illegal characters in '{0}' in the {1} item.</source>
-        <target state="new">There are illegal characters in '{0}' in the {1} item.</target>
+        <target state="translated">{1} maddesindeki '{0}'da yasadışı karakterler var.</target>
         <note />
       </trans-unit>
       <trans-unit id="ImportedProjectFromVSDistribution">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 0054ae46b6d..abb22957391 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -136,6 +136,71 @@
         <target state="translated">已为此内部版本启用 BuildCheck。</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_MessageFmt">
+        <source>Projects {0} and {1} have conflicting output paths: {2}.</source>
+        <target state="translated">项目 {0} 和 {1} 具有冲突的输出路径: {2}。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_Title">
+        <source>Two projects should not share their 'OutputPath' nor 'IntermediateOutputPath' locations.</source>
+        <target state="translated">两个项目不应共享其 "OutputPath" 位置，也不应共享其 "IntermediateOutputPath" 位置。</target>
+        <note>'OutputPath' and 'IntermediateOutputPath' not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_MessageFmt">
+        <source>Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.</source>
+        <target state="translated">项目 {2} 和 {3} 中的任务 {0} 和 {1} 写入同一文件 {4}。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_Title">
+        <source>Two tasks should not write the same file.</source>
+        <target state="translated">两个任务不应写入同一文件。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageAddendum">
+        <source>'{0}' with value: '{1}'</source>
+        <target state="translated">值为“{1}”的“{0}”</target>
+        <note>Will be used as a parameter {0} in previous message.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageFmt">
+        <source>Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.</source>
+        <target state="translated">属性派生自环境变量: {0}。应使用 /p 选项显式传递属性。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_Title">
+        <source>No implicit property derived from an environment variable should be used during the build.</source>
+        <target state="translated">在生成过程中，不应使用派生自环境变量的隐式属性。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_MessageFmt">
+        <source>Property: '{0}' was accessed, but it was never initialized.</source>
+        <target state="translated">已访问属性“{0}”，但从未将其初始化过。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_Title">
+        <source>A property that is accessed should be declared first.</source>
+        <target state="translated">应首先声明访问的属性。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_MessageFmt">
+        <source>Property: '{0}' first declared/initialized at {1} used before it was initialized.</source>
+        <target state="translated">属性“{0}”在 {1} 使用时首先声明/初始化，再进行初始化。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_Title">
+        <source>A property should be declared before it is first used.</source>
+        <target state="translated">在首次使用属性之前应声明该属性。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_MessageFmt">
+        <source>Property: '{0}' was declared/initialized, but it was never used.</source>
+        <target state="translated">属性“{0}”已声明/初始化，但从未使用过。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_Title">
+        <source>A property that is not used should not be declared.</source>
+        <target state="translated">不应声明未使用的属性。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">问题生成失败。生成提前退出，因为遇到不是最新的目标或任务。</target>
@@ -222,6 +287,11 @@
         <target state="translated">找不到指定的自定义检查程序集: {0}。请检查它是否存在。</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">未能从程序集“{1}”加载自定义检查类型“{0}”。请确保它继承 Microsoft.Build.Experimental.BuildCheck.Check 基类。如果不打算将其作为自定义检查，则不应将其公开。详细信息: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
@@ -310,7 +380,7 @@
       </trans-unit>
       <trans-unit id="IllegalCharactersInFileOrDirectory">
         <source>There are illegal characters in '{0}' in the {1} item.</source>
-        <target state="new">There are illegal characters in '{0}' in the {1} item.</target>
+        <target state="translated">{1} 项中的“{0}”中存在非法字符。</target>
         <note />
       </trans-unit>
       <trans-unit id="ImportedProjectFromVSDistribution">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 68dcd9bf614..50b9a761cdf 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -136,6 +136,71 @@
         <target state="translated">已為此組建啟用 BuildCheck。</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_MessageFmt">
+        <source>Projects {0} and {1} have conflicting output paths: {2}.</source>
+        <target state="translated">專案且 {0} 和 {1} 有衝突的輸出路徑: {2}。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0101_Title">
+        <source>Two projects should not share their 'OutputPath' nor 'IntermediateOutputPath' locations.</source>
+        <target state="translated">兩個專案不應共用其 'OutputPath' 或 'IntermediateOutputPath' 位置。</target>
+        <note>'OutputPath' and 'IntermediateOutputPath' not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_MessageFmt">
+        <source>Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.</source>
+        <target state="translated">工作 {0} 和 {1} 來自專案 {2} 且 {3} 寫入相同的檔案: {4}。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0102_Title">
+        <source>Two tasks should not write the same file.</source>
+        <target state="translated">兩個工作不應該寫入相同的檔案。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageAddendum">
+        <source>'{0}' with value: '{1}'</source>
+        <target state="translated">'{0}' 具有值: "{1}"</target>
+        <note>Will be used as a parameter {0} in previous message.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_MessageFmt">
+        <source>Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.</source>
+        <target state="translated">屬性衍生自環境變數: {0}。應該使用 /p 選項明確傳遞屬性。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0103_Title">
+        <source>No implicit property derived from an environment variable should be used during the build.</source>
+        <target state="translated">組建期間不應使用衍生自環境變數的隱含屬性。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_MessageFmt">
+        <source>Property: '{0}' was accessed, but it was never initialized.</source>
+        <target state="translated">已存取屬性: '{0}'，但從未初始化。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0201_Title">
+        <source>A property that is accessed should be declared first.</source>
+        <target state="translated">存取的屬性應先宣告。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_MessageFmt">
+        <source>Property: '{0}' first declared/initialized at {1} used before it was initialized.</source>
+        <target state="translated">屬性: '{0}' 在初始化之前先在 {1} 宣告/初始化。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0202_Title">
+        <source>A property should be declared before it is first used.</source>
+        <target state="translated">屬性應在第一次使用之前宣告。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_MessageFmt">
+        <source>Property: '{0}' was declared/initialized, but it was never used.</source>
+        <target state="translated">屬性: '{0}' 已宣告/初始化，但從未使用過。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0203_Title">
+        <source>A property that is not used should not be declared.</source>
+        <target state="translated">不應宣告未使用的屬性。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">問題建立失敗。建置提早結束，因為它遇到不是最新的目標或工作。</target>
@@ -222,6 +287,11 @@
         <target state="translated">找不到指定的自訂檢查組件: '{0}'。請確認其是否存在。</target>
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CouldNotDifferentiateBetweenCompatibleMethods">
+        <source>Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</source>
+        <target state="new">Found multiple overloads for method "{0}" with {1} parameter(s). That is currently not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
         <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
         <target state="translated">無法從組件: '{1}' 載入自訂檢查類型: '{0}'。請確認其繼承了 Microsoft.Build.Experimental.BuildCheck.Check 基底類別。如非作為自訂檢查，則不應公開。更多資訊: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
@@ -310,7 +380,7 @@
       </trans-unit>
       <trans-unit id="IllegalCharactersInFileOrDirectory">
         <source>There are illegal characters in '{0}' in the {1} item.</source>
-        <target state="new">There are illegal characters in '{0}' in the {1} item.</target>
+        <target state="translated">{1} 項目中的 '{0}' 有不合法的字元。</target>
         <note />
       </trans-unit>
       <trans-unit id="ImportedProjectFromVSDistribution">
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 9fc62d7b964..82724a46b03 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -185,7 +185,7 @@ private static string[] GetFileList(
         {
             ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
 
-            string[] fileList = Array.Empty<string>();
+            string[] fileList = [];
 
             // Used to properly detect and log drive enumerating wildcards when applicable.
             string excludeFileSpec = string.Empty;
@@ -200,7 +200,7 @@ private static string[] GetFileList(
             if (filespecMatchesLazyWildcard || (filespecHasNoWildCards && excludeSpecsAreEmpty))
             {
                 // Just return the original string.
-                fileList = new string[] { returnEscaped ? filespecEscaped : EscapingUtilities.UnescapeAll(filespecEscaped) };
+                fileList = [returnEscaped ? filespecEscaped : EscapingUtilities.UnescapeAll(filespecEscaped)];
             }
             else
             {
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 97ccb0de770..4e1f865bbae 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -66,7 +66,7 @@ public void Initialize(AssemblyName assemblyName, string assemblyFilePath)
             var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
             var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
             var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
-            ParseMethod = NuGetFramework.GetMethod("Parse", new Type[] { typeof(string) });
+            ParseMethod = NuGetFramework.GetMethod("Parse", [typeof(string)]);
             IsCompatibleMethod = NuGetFrameworkCompatibilityProvider.GetMethod("IsCompatible");
             DefaultCompatibilityProvider = NuGetFrameworkDefaultCompatibilityProvider.GetMethod("get_Instance").Invoke(null, Array.Empty<object>());
             FrameworkProperty = NuGetFramework.GetProperty("Framework");
@@ -78,7 +78,7 @@ public void Initialize(AssemblyName assemblyName, string assemblyFilePath)
 
         private object Parse(string tfm)
         {
-            return ParseMethod.Invoke(null, new object[] { tfm });
+            return ParseMethod.Invoke(null, [tfm]);
         }
 
         public string GetTargetFrameworkIdentifier(string tfm)
@@ -105,7 +105,7 @@ public string GetTargetPlatformVersion(string tfm, int minVersionPartCount)
 
         public bool IsCompatible(string target, string candidate)
         {
-            return Convert.ToBoolean(IsCompatibleMethod.Invoke(DefaultCompatibilityProvider, new object[] { Parse(target), Parse(candidate) }));
+            return Convert.ToBoolean(IsCompatibleMethod.Invoke(DefaultCompatibilityProvider, [Parse(target), Parse(candidate)]));
         }
 
         private string GetNonZeroVersionParts(Version version, int minVersionPartCount)
@@ -143,7 +143,7 @@ public string FilterTargetFrameworks(string incoming, string filter)
 
             IEnumerable<(string originalTfm, object parsedTfm)> ParseTfms(string desiredTargetFrameworks)
             {
-                return desiredTargetFrameworks.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries).Select(tfm =>
+                return desiredTargetFrameworks.Split([';'], StringSplitOptions.RemoveEmptyEntries).Select(tfm =>
                 {
                     (string originalTfm, object parsedTfm) parsed = (tfm, Parse(tfm));
                     return parsed;
diff --git a/src/Build/Utilities/RegistryKeyWrapper.cs b/src/Build/Utilities/RegistryKeyWrapper.cs
index ebe70f61d8c..e946a3546a3 100644
--- a/src/Build/Utilities/RegistryKeyWrapper.cs
+++ b/src/Build/Utilities/RegistryKeyWrapper.cs
@@ -128,7 +128,7 @@ public virtual string[] GetValueNames()
         {
             try
             {
-                return Exists() ? WrappedKey.GetValueNames() : Array.Empty<string>();
+                return Exists() ? WrappedKey.GetValueNames() : [];
             }
             catch (Exception ex) when (!ExceptionHandling.NotExpectedRegistryException(ex))
             {
@@ -144,7 +144,7 @@ public virtual string[] GetSubKeyNames()
         {
             try
             {
-                return Exists() ? WrappedKey.GetSubKeyNames() : Array.Empty<string>();
+                return Exists() ? WrappedKey.GetSubKeyNames() : [];
             }
             catch (Exception ex) when (!ExceptionHandling.NotExpectedRegistryException(ex))
             {
diff --git a/src/Build/Utilities/SimpleVersion.cs b/src/Build/Utilities/SimpleVersion.cs
index f66c5bb3880..b12e865dfd1 100644
--- a/src/Build/Utilities/SimpleVersion.cs
+++ b/src/Build/Utilities/SimpleVersion.cs
@@ -125,7 +125,7 @@ public static SimpleVersion Parse(string input)
             return new SimpleVersion(major, minor, build, revision);
         }
 
-        private static readonly char[] s_semverSeparators = new char[] { '-', '+' };
+        private static readonly char[] s_semverSeparators = ['-', '+'];
 
         private static ReadOnlySpan<char> RemoveTrivia(string input)
         {
diff --git a/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs b/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs
index 17bd60abbd1..459b06ab28a 100644
--- a/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs
+++ b/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs
@@ -81,7 +81,7 @@ public void EditorconfigFileDiscovery_RootTrue()
         """);
 
         var parser = new EditorConfigParser();
-        var listOfEditorConfigFile = parser.DiscoverEditorConfigFiles(Path.Combine(workFolder1.Path, "subfolder", "projectfile.proj") ).ToList();
+        var listOfEditorConfigFile = parser.DiscoverEditorConfigFiles(Path.Combine(workFolder1.Path, "subfolder", "projectfile.proj")).ToList();
         // should be one because root=true so we do not need to go further
         listOfEditorConfigFile.Count.ShouldBe(1);
         listOfEditorConfigFile[0].IsRoot.ShouldBeTrue();
@@ -116,4 +116,31 @@ public void EditorconfigFileDiscovery_RootFalse()
         listOfEditorConfigFile[0].IsRoot.ShouldBeFalse();
         listOfEditorConfigFile[0].NamedSections[0].Name.ShouldBe("*.csproj");
     }
+
+    [Fact]
+    public void Parse_HandlesDifferentLineEndings()
+    {
+        var mixedEndingsText = "root = true\r\n" +
+                           "[*.cs]\n" +
+                           "indent_style = space\r\n" +
+                           "indent_size = 4\n" +
+                           "[*.md]\r\n" +
+                           "trim_trailing_whitespace = true";
+
+        var result = EditorConfigFile.Parse(mixedEndingsText);
+
+        result.IsRoot.ShouldBeTrue("Root property should be true");
+        result.NamedSections.Length.ShouldBe(2);
+
+        var csSection = result.NamedSections.FirstOrDefault(s => s.Name == "*.cs");
+        csSection.ShouldNotBeNull();
+        csSection.Properties.Count.ShouldBe(2);
+        csSection.Properties["indent_style"].ShouldBe("space");
+        csSection.Properties["indent_size"].ShouldBe("4");
+
+        var mdSection = result.NamedSections.FirstOrDefault(s => s.Name == "*.md");
+        mdSection.ShouldNotBeNull();
+        mdSection.Properties.Count.ShouldBe(1);
+        mdSection.Properties["trim_trailing_whitespace"].ShouldBe("true");
+    }
 }
diff --git a/src/BuildCheck.UnitTests/EditorConfig_Tests.cs b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
index 84e9af60f02..bd8f4577bc6 100644
--- a/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
+++ b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
@@ -716,7 +716,7 @@ private static void Equal<T>(
             return;
         }
 
-        Assert.True(false, message);
+        Assert.Fail(message);
     }
 
     private static bool SequenceEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual, IEqualityComparer<T> comparer = null)
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index be460ba4062..58891677b6a 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -45,6 +45,7 @@ public void PropertiesUsageAnalyzerTest(bool buildInOutOfProcessNode)
         PrepareSampleProjectsAndConfig(
             buildInOutOfProcessNode,
             out TransientTestFile projectFile,
+            out _,
             "PropsCheckTest.csproj");
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild($"{projectFile.Path} -check", out bool success);
@@ -52,9 +53,9 @@ public void PropertiesUsageAnalyzerTest(bool buildInOutOfProcessNode)
         _env.Output.WriteLine("=========================");
         success.ShouldBeTrue(output);
 
-        output.ShouldMatch(@"BC0201: .* Property: \[MyProp11\]");
-        output.ShouldMatch(@"BC0202: .* Property: \[MyPropT2\]");
-        output.ShouldMatch(@"BC0203: .* Property: \[MyProp13\]");
+        output.ShouldMatch(@"BC0201: .* Property: 'MyProp11'");
+        output.ShouldMatch(@"BC0202: .* Property: 'MyPropT2'");
+        output.ShouldMatch(@"BC0203: .* Property: 'MyProp13'");
 
         // each finding should be found just once - but reported twice, due to summary
         Regex.Matches(output, "BC0201: .* Property").Count.ShouldBe(2);
@@ -62,6 +63,109 @@ public void PropertiesUsageAnalyzerTest(bool buildInOutOfProcessNode)
         Regex.Matches(output, "BC0203 .* Property").Count.ShouldBe(2);
     }
 
+
+    [Theory]
+    [InlineData(true, true)]
+    [InlineData(true, false)]
+    [InlineData(false, true)]
+    [InlineData(false, false)]
+    public void WarningsCountExceedsLimitTest(bool buildInOutOfProcessNode, bool limitReportsCount)
+    {
+        PrepareSampleProjectsAndConfig(
+            buildInOutOfProcessNode,
+            out TransientTestFile projectFile,
+            out _,
+            "PropsCheckTestWithLimit.csproj");
+
+        if (limitReportsCount)
+        {
+            _env.SetEnvironmentVariable("MSBUILDDONOTLIMITBUILDCHECKRESULTSNUMBER", "0");
+        }
+        else
+        {
+            _env.SetEnvironmentVariable("MSBUILDDONOTLIMITBUILDCHECKRESULTSNUMBER", "1");
+        }
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild($"{projectFile.Path} -check", out bool success);
+        _env.Output.WriteLine(output);
+        _env.Output.WriteLine("=========================");
+        success.ShouldBeTrue(output);
+
+        
+        // each finding should be found just once - but reported twice, due to summary
+        if (limitReportsCount)
+        {
+            output.ShouldMatch(@"has exceeded the maximum number of results allowed");
+            Regex.Matches(output, "BC0202: .* Property").Count.ShouldBe(2);
+            Regex.Matches(output, "BC0203: .* Property").Count.ShouldBe(38);
+        }
+        else
+        {
+            Regex.Matches(output, "BC0202: .* Property").Count.ShouldBe(2);
+            Regex.Matches(output, "BC0203: .* Property").Count.ShouldBe(42);
+        }
+    }
+
+
+    [Fact]
+    public void ConfigChangeReflectedOnReuse()
+    {
+        PrepareSampleProjectsAndConfig(
+            // we need out of proc build - to test node reuse
+            true,
+            out TransientTestFile projectFile,
+            out TransientTestFile editorconfigFile,
+            "PropsCheckTest.csproj");
+
+        // Build without BuildCheck - no findings should be reported
+        string output = RunnerUtilities.ExecBootstrapedMSBuild($"{projectFile.Path}", out bool success);
+        _env.Output.WriteLine(output);
+        _env.Output.WriteLine("=========================");
+        success.ShouldBeTrue(output);
+        output.ShouldNotContain("BC0201");
+        output.ShouldNotContain("BC0202");
+        output.ShouldNotContain("BC0203");
+
+        // Build with BuildCheck - findings should be reported
+        output = RunnerUtilities.ExecBootstrapedMSBuild($"{projectFile.Path} -check", out success);
+        _env.Output.WriteLine(output);
+        _env.Output.WriteLine("=========================");
+        success.ShouldBeTrue(output);
+        output.ShouldContain("warning BC0201");
+        output.ShouldContain("warning BC0202");
+        output.ShouldContain("warning BC0203");
+
+        // Flip config in editorconfig
+        string editorConfigChange = """
+                                    
+                                    build_check.BC0201.Severity=error
+                                    build_check.BC0202.Severity=error
+                                    build_check.BC0203.Severity=error
+                                    """;
+
+        File.AppendAllText(editorconfigFile.Path, editorConfigChange);
+
+        // Build with BuildCheck - findings with new severity should be reported
+        output = RunnerUtilities.ExecBootstrapedMSBuild($"{projectFile.Path} -check", out success);
+        _env.Output.WriteLine(output);
+        _env.Output.WriteLine("=========================");
+        // build should fail due to error checks
+        success.ShouldBeFalse(output);
+        output.ShouldContain("error BC0201");
+        output.ShouldContain("error BC0202");
+        output.ShouldContain("error BC0203");
+
+        // Build without BuildCheck - no findings should be reported
+        output = RunnerUtilities.ExecBootstrapedMSBuild($"{projectFile.Path}", out success);
+        _env.Output.WriteLine(output);
+        _env.Output.WriteLine("=========================");
+        success.ShouldBeTrue(output);
+        output.ShouldNotContain("BC0201");
+        output.ShouldNotContain("BC0202");
+        output.ShouldNotContain("BC0203");
+    }
+
+
     [Theory]
     [InlineData(true, true)]
     [InlineData(false, true)]
@@ -148,7 +252,7 @@ public void SampleCheckIntegrationTest_ReplayBinaryLogOfCheckedBuild(bool buildI
     [InlineData("suggestion", "BC0101", new string[] { "error BC0101", "warning BC0101" })]
     [InlineData("default", "warning BC0101", new string[] { "error BC0101" })]
     [InlineData("none", null, new string[] { "BC0101" })]
-    public void EditorConfig_SeverityAppliedCorrectly(string BC0101Severity, string expectedOutputValues, string[] unexpectedOutputValues)
+    public void EditorConfig_SeverityAppliedCorrectly(string BC0101Severity, string? expectedOutputValues, string[] unexpectedOutputValues)
     {
         PrepareSampleProjectsAndConfig(true, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", BC0101Severity) });
 
@@ -163,7 +267,7 @@ public void EditorConfig_SeverityAppliedCorrectly(string BC0101Severity, string
 
         if (!string.IsNullOrEmpty(expectedOutputValues))
         {
-            output.ShouldContain(expectedOutputValues);
+            output.ShouldContain(expectedOutputValues!);
         }
 
         foreach (string unexpectedOutputValue in unexpectedOutputValues)
@@ -172,7 +276,7 @@ public void EditorConfig_SeverityAppliedCorrectly(string BC0101Severity, string
         }
     }
 
-    [Fact]
+    [Fact(Skip = "https://github.com/dotnet/msbuild/issues/10702")]
     public void CheckHasAccessToAllConfigs()
     {
         using (var env = TestEnvironment.Create())
@@ -316,6 +420,41 @@ public void NoEnvironmentVariableProperty_Scoping(EvaluationCheckScope scope)
     }
 
     [Theory]
+    [InlineData(true, false)]
+    [InlineData(false, false)]
+    [InlineData(false, true)]
+    public void NoEnvironmentVariableProperty_DeferredProcessing(bool warnAsError, bool warnAsMessage)
+    {
+        PrepareSampleProjectsAndConfig(
+            buildInOutOfProcessNode: true,
+            out TransientTestFile projectFile,
+            new List<(string, string)>() { ("BC0103", "warning") });
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check" +
+            (warnAsError ? " /p:warn2err=BC0103" : "") + (warnAsMessage ? " /p:warn2msg=BC0103" : ""), out bool success,
+            false, _env.Output);
+
+        success.ShouldBe(!warnAsError);
+
+        if (warnAsMessage)
+        {
+            output.ShouldNotContain("warning BC0103");
+            output.ShouldNotContain("error BC0103");
+        }
+        else if (warnAsError)
+        {
+            output.ShouldNotContain("warning BC0103");
+            output.ShouldContain("error BC0103");
+        }
+        else
+        {
+            output.ShouldContain("warning BC0103");
+            output.ShouldNotContain("error BC0103");
+        }
+    }
+
+    [Theory(Skip = "https://github.com/dotnet/msbuild/issues/10702")]
     [InlineData("CheckCandidate", new[] { "CustomRule1", "CustomRule2" })]
     [InlineData("CheckCandidateWithMultipleChecksInjected", new[] { "CustomRule1", "CustomRule2", "CustomRule3" }, true)]
     public void CustomCheckTest_NoEditorConfig(string checkCandidate, string[] expectedRegisteredRules, bool expectedRejectedChecks = false)
@@ -348,7 +487,7 @@ public void CustomCheckTest_NoEditorConfig(string checkCandidate, string[] expec
         }
     }
 
-    [Theory]
+    [Theory(Skip = "https://github.com/dotnet/msbuild/issues/10702")]
     [InlineData("CheckCandidate", "X01234", "error", "error X01234")]
     [InlineData("CheckCandidateWithMultipleChecksInjected", "X01234", "warning", "warning X01234")]
     public void CustomCheckTest_WithEditorConfig(string checkCandidate, string ruleId, string severity, string expectedMessage)
@@ -375,6 +514,39 @@ public void CustomCheckTest_WithEditorConfig(string checkCandidate, string ruleI
         }
     }
 
+    [Theory(Skip = "https://github.com/dotnet/msbuild/issues/10702")]
+    [InlineData("X01236", "Something went wrong initializing")]
+    // These tests are for failure one different points, will be addressed in a different PR
+    // https://github.com/dotnet/msbuild/issues/10522
+    // [InlineData("X01237", "message")]
+    // [InlineData("X01238", "message")]
+    public void CustomChecksFailGracefully(string ruleId, string expectedMessage)
+    {
+        using (var env = TestEnvironment.Create())
+        {
+            string checkCandidate = "CheckCandidateWithMultipleChecksInjected";
+            string checkCandidatePath = Path.Combine(TestAssetsRootPath, checkCandidate);
+
+            // Can't use Transitive environment due to the need to dogfood local nuget packages.
+            AddCustomDataSourceToNugetConfig(checkCandidatePath);
+            string editorConfigName = Path.Combine(checkCandidatePath, EditorConfigFileName);
+            File.WriteAllText(editorConfigName, ReadEditorConfig(
+                new List<(string, string)>() { (ruleId, "warning") },
+                ruleToCustomConfig: null,
+                checkCandidatePath));
+
+            string projectCheckBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
+                $"{Path.Combine(checkCandidatePath, $"{checkCandidate}.csproj")} /m:1 -nr:False -restore -check -verbosity:n", out bool success);
+
+            success.ShouldBeTrue();
+            projectCheckBuildLog.ShouldContain(expectedMessage);
+            projectCheckBuildLog.ShouldNotContain("This check should have been disabled");
+
+            // Cleanup
+            File.Delete(editorConfigName);
+        }
+    }
+
     [Theory]
     [InlineData(true)]
     [InlineData(false)]
@@ -434,6 +606,7 @@ private void PopulateXmlAttribute(XmlDocument doc, XmlNode node, string attribut
     private void PrepareSampleProjectsAndConfig(
         bool buildInOutOfProcessNode,
         out TransientTestFile projectFile,
+        out TransientTestFile editorconfigFile,
         string entryProjectAssetName,
         IEnumerable<string>? supplementalAssetNames = null,
         IEnumerable<(string RuleId, string Severity)>? ruleToSeverity = null,
@@ -452,7 +625,7 @@ private void PrepareSampleProjectsAndConfig(
             TransientTestFile supplementalFile = _env.CreateFile(workFolder, supplementalAssetName, supplementalContent);
         }
 
-        _env.CreateFile(workFolder, ".editorconfig", ReadEditorConfig(ruleToSeverity, ruleToCustomConfig, testAssetsFolderName));
+        editorconfigFile = _env.CreateFile(workFolder, ".editorconfig", ReadEditorConfig(ruleToSeverity, ruleToCustomConfig, testAssetsFolderName));
 
         // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
         // This discrepancy breaks path equality checks in MSBuild checks if we pass to MSBuild full path to the initial project.
@@ -481,6 +654,7 @@ private void PrepareSampleProjectsAndConfig(
         => PrepareSampleProjectsAndConfig(
             buildInOutOfProcessNode,
             out projectFile,
+            out _,
             "Project1.csproj",
             new[] { "Project2.csproj", "ImportedFile1.props" },
             ruleToSeverity,
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index 3961ef049c3..27bf2a1542b 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -20,6 +20,7 @@
     <ProjectReference Include=".\TestAssets\CustomCheck\CustomCheck.csproj" />
     <ProjectReference Include=".\TestAssets\CustomCheck2\CustomCheck2.csproj" />
     <ProjectReference Include=".\TestAssets\InvalidCustomCheck\InvalidCustomCheck.csproj" />
+    <ProjectReference Include=".\TestAssets\ErrorCustomCheck\ErrorCustomCheck.csproj" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/.editorconfigtest b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/.editorconfigtest
index be166e833cd..9fc4aa489e8 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/.editorconfigtest
+++ b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/.editorconfigtest
@@ -2,3 +2,7 @@ root = true
 
 [*.csproj]
 build_check.X01234.Severity=X01234Severity
+
+build_check.X01236.Severity=X01236Severity
+build_check.X01237.Severity=X01237Severity
+build_check.X01238.Severity=X01238Severity
diff --git a/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/CheckCandidateWithMultipleChecksInjected.csproj b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/CheckCandidateWithMultipleChecksInjected.csproj
index 07695e19e8e..5bac9f39137 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/CheckCandidateWithMultipleChecksInjected.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/CheckCandidateWithMultipleChecksInjected.csproj
@@ -9,6 +9,7 @@
     <PackageReference Include="CustomCheck" Version="1.0.0"/>
     <PackageReference Include="CustomCheck2" Version="1.0.0"/>
     <PackageReference Include="InvalidCustomCheck" Version="1.0.0"/>
+    <PackageReference Include="ErrorCustomCheck" Version="1.0.0"/>
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorCustomCheck.csproj b/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorCustomCheck.csproj
new file mode 100644
index 00000000000..8bce5a83d8c
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorCustomCheck.csproj
@@ -0,0 +1,17 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <Import Project="..\Common\CommonTest.props" />
+
+  <PropertyGroup>
+    <TargetFramework>netstandard2.0</TargetFramework>
+    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <None Include="ErrorCustomCheck.props" Pack="true" PackagePath="build\ErrorCustomCheck.props" />
+    <Content Include="README.md" />
+  </ItemGroup>
+
+  <Import Project="..\Common\CommonTest.targets" />
+
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorCustomCheck.props b/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorCustomCheck.props
new file mode 100644
index 00000000000..843a7176c4c
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorCustomCheck.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)ErrorCustomCheck.dll))</MSBuildCheck>
+  </PropertyGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorOnInitializeCheck.cs b/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorOnInitializeCheck.cs
new file mode 100644
index 00000000000..9500479932d
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorOnInitializeCheck.cs
@@ -0,0 +1,43 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace ErrorCustomCheck
+{
+    public sealed class ErrorOnInitializeCheck : Check
+    {
+        public static CheckRule SupportedRule = new CheckRule(
+            "X01236",
+            "Title",
+            "Description",
+            "Message format: {0}",
+            new CheckConfiguration());
+
+        public override string FriendlyName => "ErrorOnInitializeCheck";
+
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
+
+        public override void Initialize(ConfigurationContext configurationContext)
+        {
+            // configurationContext to be used only if check needs external configuration data.
+            throw new Exception("Something went wrong initializing");
+        }
+
+        public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+        {
+            registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+        }
+
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
+        {
+            context.ReportResult(BuildCheckResult.Create(
+                SupportedRule,
+                ElementLocation.EmptyLocation,
+                "This check should have been disabled"));
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorOnRegisteredAction.cs b/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorOnRegisteredAction.cs
new file mode 100644
index 00000000000..1593dc9b997
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorOnRegisteredAction.cs
@@ -0,0 +1,39 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace ErrorCustomCheck
+{
+    public sealed class ErrorOnRegisteredAction : Check
+    {
+        public static CheckRule SupportedRule = new CheckRule(
+            "X01237",
+            "Title",
+            "Description",
+            "Message format: {0}",
+            new CheckConfiguration());
+
+        public override string FriendlyName => "ErrorOnEvaluatedPropertiesCheck";
+
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
+
+        public override void Initialize(ConfigurationContext configurationContext)
+        {
+            // configurationContext to be used only if check needs external configuration data.
+        }
+
+        public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+        {
+            registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+        }
+
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
+        {
+            throw new Exception("something went wrong");
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorWhenRegisteringActions.cs b/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorWhenRegisteringActions.cs
new file mode 100644
index 00000000000..9b3f5f0cf05
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorWhenRegisteringActions.cs
@@ -0,0 +1,43 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace ErrorCustomCheck
+{
+    public sealed class ErrorWhenRegisteringActions : Check
+    {
+        public static CheckRule SupportedRule = new CheckRule(
+            "X01238",
+            "Title",
+            "Description",
+            "Message format: {0}",
+            new CheckConfiguration());
+
+        public override string FriendlyName => "ErrorOnEvaluatedPropertiesCheck";
+
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
+
+        public override void Initialize(ConfigurationContext configurationContext)
+        {
+            // configurationContext to be used only if check needs external configuration data.
+        }
+
+        public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+        {
+            registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+            throw new Exception("something went wrong");
+        }
+
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
+        {
+            context.ReportResult(BuildCheckResult.Create(
+                SupportedRule,
+                ElementLocation.EmptyLocation,
+                "This check should have been disabled"));
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/README.md b/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/README.md
new file mode 100644
index 00000000000..ef41e00277e
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Check Template
+
+## Overview
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild check libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom check rules.
+
+## Getting Started
+To use the MSBuild Custom Check Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildcheck
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildcheck -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1.csproj b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1.csproj
index 81efb8fd795..67b42bf5bc9 100644
--- a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1.csproj
@@ -15,6 +15,8 @@
 
     <PropertyGroup>
         <ReadFromEnv>$(TestFromEvaluation)</ReadFromEnv>
+        <MSBuildWarningsAsErrors>$(warn2err)</MSBuildWarningsAsErrors>
+        <MSBuildWarningsAsMessages>$(warn2msg)</MSBuildWarningsAsMessages>
     </PropertyGroup>
 
    <Target Name="Hello">
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/PropsCheckTest.csproj b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/PropsCheckTest.csproj
index 4e5bb2af0e3..37b8b431f1d 100644
--- a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/PropsCheckTest.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/PropsCheckTest.csproj
@@ -9,6 +9,7 @@
 
     <PropertyGroup Condition="'$(MyProp12)' == ''">
         <MyProp13>$(MyProp11)</MyProp13>
+        <MSBuildTreatWarningsAsErrors>false</MSBuildTreatWarningsAsErrors>
     </PropertyGroup>
 
     <!--
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/PropsCheckTestWithLimit.csproj b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/PropsCheckTestWithLimit.csproj
new file mode 100644
index 00000000000..ecc625dde84
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/PropsCheckTestWithLimit.csproj
@@ -0,0 +1,32 @@
+<Project DefaultTargets="PrintEnvVar">
+    <PropertyGroup>
+        <MyProp01>$(MyProp01)</MyProp01>
+        <MyProp02>$(MyProp02)</MyProp02>
+        <MyProp03>$(MyProp03)</MyProp03>
+        <MyProp04>$(MyProp04)</MyProp04>
+        <MyProp05>$(MyProp05)</MyProp05>
+        <MyProp06>$(MyProp06)</MyProp06>
+        <MyProp07>$(MyProp07)</MyProp07>
+        <MyProp08>$(MyProp08)</MyProp08>
+        <MyProp09>$(MyProp09)</MyProp09>
+        <MyProp10>$(MyProp10)</MyProp10>
+        <MyProp11>$(MyProp11)</MyProp11>
+        <MyProp12>$(MyProp12)</MyProp12>
+        <MyProp13>$(MyProp13)</MyProp13>
+        <MyProp14>$(MyProp14)</MyProp14>
+        <MyProp15>$(MyProp15)</MyProp15>
+        <MyProp16>$(MyProp16)</MyProp16>
+        <MyProp17>$(MyProp17)</MyProp17>
+        <MyProp18>$(MyProp18)</MyProp18>
+        <MyProp19>$(MyProp19)</MyProp19>
+        <MyProp20>$(MyProp20)</MyProp20>
+        <MyProp21>$(MyProp21)</MyProp21>
+    </PropertyGroup>
+
+    <Target Name="PrintEnvVar">
+        <Message Text="MyPropT2 has value $(MyPropT2)" Importance="High" />
+        <PropertyGroup>
+            <MyPropT2>SomeValue</MyPropT2>
+        </PropertyGroup>
+    </Target>
+</Project>
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index 27628d8d2e8..10f4321b686 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -68,7 +68,7 @@
     <FeatureXamlTypes>true</FeatureXamlTypes>
     <DefineConstants>$(DefineConstants);FEATURE_XML_SCHEMA_VALIDATION</DefineConstants>
     <DefineConstants Condition="'$(MachineIndependentBuild)' != 'true'">$(DefineConstants);FEATURE_WIN32_REGISTRY</DefineConstants>
-    <DefineConstants Condition="'$(MachineIndependentBuild)' != 'true' and '$(TargetFrameworkVersion)' != 'v3.5' and '$(DotNetBuildFromSource)' != 'true'">$(DefineConstants);FEATURE_VISUALSTUDIOSETUP</DefineConstants>
+    <DefineConstants Condition="'$(MachineIndependentBuild)' != 'true' and '$(TargetFrameworkVersion)' != 'v3.5' and '$(DotNetBuildSourceOnly)' != 'true'">$(DefineConstants);FEATURE_VISUALSTUDIOSETUP</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_MSCOREE</DefineConstants>
   </PropertyGroup>
 
@@ -110,7 +110,7 @@
     <DocumentationFile Condition=" '$(GenerateDocumentationFile)' == 'true' ">$(IntermediateOutputPath)\$(AssemblyName).xml</DocumentationFile>
   </PropertyGroup>
 
-  <PropertyGroup Condition="'$(DotNetBuildFromSource)' != 'true' and $([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETFramework'">
+  <PropertyGroup Condition="'$(DotNetBuildSourceOnly)' != 'true' and $([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETFramework'">
     <DefineConstants>$(DefineConstants);FEATURE_MSIOREDIST</DefineConstants>
     <FeatureMSIORedist>true</FeatureMSIORedist>
   </PropertyGroup>
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index 8946c45dc5a..2263f0eef57 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -31,7 +31,7 @@
 
     <!-- Defaults for target frameworks and architecture -->
     <LibraryTargetFrameworks>$(FullFrameworkTFM);$(LatestDotNetCoreForMSBuild);netstandard2.0</LibraryTargetFrameworks>
-    <LibraryTargetFrameworks Condition="'$(DotNetBuildFromSource)' == 'true'">$(LatestDotNetCoreForMSBuild);netstandard2.0</LibraryTargetFrameworks>
+    <LibraryTargetFrameworks Condition="'$(DotNetBuildSourceOnly)' == 'true'">$(LatestDotNetCoreForMSBuild);netstandard2.0</LibraryTargetFrameworks>
     <PlatformTarget>AnyCPU</PlatformTarget>
 
     <!-- Target frameworks for Exe and unit test projects (ie projects with runtime output) -->
@@ -59,7 +59,7 @@
 
     <PackageLicenseUrl Condition="'$(PackageLicenseExpression)' == ''">http://go.microsoft.com/fwlink/?LinkId=329770</PackageLicenseUrl>
     <PackageProjectUrl>http://go.microsoft.com/fwlink/?LinkId=624683</PackageProjectUrl>
-    <PackageIconUrl>https://go.microsoft.com/fwlink/?linkid=825694</PackageIconUrl>
+    <PackageIconUrl>https://aka.ms/msbuildicon</PackageIconUrl>
 
     <DevDivPackagesDir>$(VisualStudioSetupOutputPath)DevDivPackages\</DevDivPackagesDir>
   </PropertyGroup>
diff --git a/src/Framework.UnitTests/BuildCanceledEventArgs_Tests.cs b/src/Framework.UnitTests/BuildCanceledEventArgs_Tests.cs
new file mode 100644
index 00000000000..0ad43127a32
--- /dev/null
+++ b/src/Framework.UnitTests/BuildCanceledEventArgs_Tests.cs
@@ -0,0 +1,41 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Framework.UnitTests
+{
+    public class BuildCanceledEventArgs_Tests
+    {
+        [Fact]
+        public void SerializationDeserializationTest()
+        {
+            var message = "message";
+            var datetime = DateTime.Today;
+
+            BuildCanceledEventArgs args = new(
+                message,
+                datetime
+                );
+            using MemoryStream stream = new MemoryStream();
+            using BinaryWriter bw = new BinaryWriter(stream);
+            args.WriteToStream(bw);
+
+            stream.Position = 0;
+            using BinaryReader br = new BinaryReader(stream);
+            BuildCanceledEventArgs argDeserialized = new("m");
+            int packetVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
+
+            argDeserialized.CreateFromStream(br, packetVersion);
+            argDeserialized.Message.ShouldBe(message);
+            argDeserialized.Timestamp.ShouldBe(datetime); 
+        }
+    }
+}
diff --git a/src/Framework.UnitTests/BuildCheckTracingEventArgs_Tests.cs b/src/Framework.UnitTests/BuildCheckTracingEventArgs_Tests.cs
new file mode 100644
index 00000000000..c96fa7b311d
--- /dev/null
+++ b/src/Framework.UnitTests/BuildCheckTracingEventArgs_Tests.cs
@@ -0,0 +1,58 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Framework.UnitTests
+{
+    public class BuildCheckTracingEventArgs_Tests
+    {
+        [Fact]
+        public void SerializationDeserializationTest()
+        {
+            string key1 = "AA";
+            TimeSpan span1 = TimeSpan.FromSeconds(5);
+            string key2 = "b";
+            TimeSpan span2 = TimeSpan.FromSeconds(15);
+            string key3 = "cCc";
+            TimeSpan span3 = TimeSpan.FromSeconds(50);
+
+            Dictionary<string, TimeSpan> stats = new() { { key1, span1 }, { key2, span2 }, { key3, span3 } };
+
+            BuildCheckRuleTelemetryData ruleData1 = new("id1", "name1", true, DiagnosticSeverity.Suggestion,
+                new HashSet<DiagnosticSeverity>() { DiagnosticSeverity.Default, DiagnosticSeverity.Suggestion },
+                new HashSet<string>() { "aa", "b" }, 5, 2, 8, true, TimeSpan.FromSeconds(123));
+
+            BuildCheckRuleTelemetryData ruleData2 = new("id2", "name2", false, DiagnosticSeverity.Error,
+                new HashSet<DiagnosticSeverity>(),
+                new HashSet<string>(), 0, 0, 500, false, TimeSpan.FromSeconds(1234));
+
+            BuildCheckTracingData data = new(new [] {ruleData1, ruleData2}, stats);
+            BuildCheckTracingEventArgs arg = new(data);
+
+            using MemoryStream stream = new MemoryStream();
+            using BinaryWriter bw = new BinaryWriter(stream);
+            arg.WriteToStream(bw);
+
+            stream.Position = 0;
+            using BinaryReader br = new BinaryReader(stream);
+            BuildCheckTracingEventArgs argDeserialized = new();
+            int packetVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
+            argDeserialized.CreateFromStream(br, packetVersion);
+
+            argDeserialized.TracingData.InfrastructureTracingData.ShouldBeEquivalentTo(arg.TracingData.InfrastructureTracingData);
+            argDeserialized.TracingData.TelemetryData.Keys.ShouldBeEquivalentTo(arg.TracingData.TelemetryData.Keys);
+
+            argDeserialized.TracingData.TelemetryData["id1"].ShouldBeEquivalentTo(arg.TracingData.TelemetryData["id1"]);
+            argDeserialized.TracingData.TelemetryData["id2"].ShouldBeEquivalentTo(arg.TracingData.TelemetryData["id2"]);
+        }
+    }
+}
diff --git a/src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs b/src/Framework.UnitTests/BuildSubmissionStartedEventArgs_Tests.cs
similarity index 97%
rename from src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs
rename to src/Framework.UnitTests/BuildSubmissionStartedEventArgs_Tests.cs
index 1db4853b515..199d2fc038d 100644
--- a/src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildSubmissionStartedEventArgs_Tests.cs
@@ -12,7 +12,7 @@
 
 namespace Microsoft.Build.Framework.UnitTests
 {
-    public class BuildSubmissionStartedEventAgs_Tests
+    public class BuildSubmissionStartedEventArgs_Tests
     {
         [Fact]
         public void SerializationDeserializationTest()
diff --git a/src/Framework/AssemblyUtilities.cs b/src/Framework/AssemblyUtilities.cs
index eea490775a7..c7e1ac2473b 100644
--- a/src/Framework/AssemblyUtilities.cs
+++ b/src/Framework/AssemblyUtilities.cs
@@ -166,7 +166,7 @@ private static CultureInfo[] GetValidCultures()
 
             var allCulturesEnumValue = Enum.Parse(cultureTypesType, "AllCultures", true);
 
-            var cultures = s_cultureInfoGetCultureMethod.Invoke(null, new[] { allCulturesEnumValue }) as CultureInfo[];
+            var cultures = s_cultureInfoGetCultureMethod.Invoke(null, [allCulturesEnumValue]) as CultureInfo[];
 
             FrameworkErrorUtilities.VerifyThrowInternalNull(cultures, "CultureInfo.GetCultures should work if all reflection checks pass");
 
diff --git a/src/Framework/BuildCheck/BuildCheckEventArgs.cs b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
index 5a2d1ad5043..adff612cc95 100644
--- a/src/Framework/BuildCheck/BuildCheckEventArgs.cs
+++ b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
@@ -19,15 +19,20 @@ internal abstract class BuildCheckEventArgs : BuildEventArgs
 /// <summary>
 /// Transport mean for the BuildCheck tracing data from additional nodes.
 /// </summary>
-/// <param name="tracingData"></param>
-internal sealed class BuildCheckTracingEventArgs(Dictionary<string, TimeSpan> tracingData) : BuildCheckEventArgs
+internal sealed class BuildCheckTracingEventArgs(
+    BuildCheckTracingData tracingData) : BuildCheckEventArgs
 {
     internal BuildCheckTracingEventArgs()
-        : this([])
-    {
-    }
+        : this(new BuildCheckTracingData())
+    { }
+
+    internal BuildCheckTracingEventArgs(Dictionary<string, TimeSpan> executionData)
+        : this(new BuildCheckTracingData(executionData))
+    { }
 
-    internal BuildCheckTracingEventArgs(Dictionary<string, TimeSpan> data, bool isAggregatedGlobalReport) : this(data) => IsAggregatedGlobalReport = isAggregatedGlobalReport;
+    internal BuildCheckTracingEventArgs(
+        BuildCheckTracingData tracingData,
+        bool isAggregatedGlobalReport) : this(tracingData) => IsAggregatedGlobalReport = isAggregatedGlobalReport;
 
     /// <summary>
     /// When true, the tracing information is from the whole build for logging purposes
@@ -35,18 +40,42 @@ internal BuildCheckTracingEventArgs()
     /// </summary>
     public bool IsAggregatedGlobalReport { get; private set; } = false;
 
-    public Dictionary<string, TimeSpan> TracingData { get; private set; } = tracingData;
+    public BuildCheckTracingData TracingData { get; private set; } = tracingData;
 
     internal override void WriteToStream(BinaryWriter writer)
     {
         base.WriteToStream(writer);
 
-        writer.Write7BitEncodedInt(TracingData.Count);
-        foreach (KeyValuePair<string, TimeSpan> kvp in TracingData)
+        writer.Write7BitEncodedInt(TracingData.InfrastructureTracingData.Count);
+        foreach (KeyValuePair<string, TimeSpan> kvp in TracingData.InfrastructureTracingData)
         {
             writer.Write(kvp.Key);
             writer.Write(kvp.Value.Ticks);
         }
+
+        writer.Write7BitEncodedInt(TracingData.TelemetryData.Count);
+        foreach (BuildCheckRuleTelemetryData data in TracingData.TelemetryData.Values)
+        {
+            writer.Write(data.RuleId);
+            writer.Write(data.CheckFriendlyName);
+            writer.Write(data.IsBuiltIn);
+            writer.Write7BitEncodedInt((int)data.DefaultSeverity);
+            writer.Write7BitEncodedInt(data.ExplicitSeverities.Count);
+            foreach (DiagnosticSeverity severity in data.ExplicitSeverities)
+            {
+                writer.Write7BitEncodedInt((int)severity);
+            }
+            writer.Write7BitEncodedInt(data.ProjectNamesWhereEnabled.Count);
+            foreach (string projectName in data.ProjectNamesWhereEnabled)
+            {
+                writer.Write(projectName);
+            }
+            writer.Write7BitEncodedInt(data.ViolationMessagesCount);
+            writer.Write7BitEncodedInt(data.ViolationWarningsCount);
+            writer.Write7BitEncodedInt(data.ViolationErrorsCount);
+            writer.Write(data.IsThrottled);
+            writer.Write(data.TotalRuntime.Ticks);
+        }
     }
 
     internal override void CreateFromStream(BinaryReader reader, int version)
@@ -54,14 +83,51 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         base.CreateFromStream(reader, version);
 
         int count = reader.Read7BitEncodedInt();
-        TracingData = new Dictionary<string, TimeSpan>(count);
+        var infrastructureTracingData = new Dictionary<string, TimeSpan>(count);
         for (int i = 0; i < count; i++)
         {
             string key = reader.ReadString();
             TimeSpan value = TimeSpan.FromTicks(reader.ReadInt64());
 
-            TracingData.Add(key, value);
+            infrastructureTracingData.Add(key, value);
         }
+
+        count = reader.Read7BitEncodedInt();
+        List<BuildCheckRuleTelemetryData> tracingData = new List<BuildCheckRuleTelemetryData>(count);
+        for (int i = 0; i < count; i++)
+        {
+            string ruleId = reader.ReadString();
+            string checkFriendlyName = reader.ReadString();
+            bool isBuiltIn = reader.ReadBoolean();
+            DiagnosticSeverity defaultSeverity = (DiagnosticSeverity)reader.Read7BitEncodedInt();
+            int explicitSeveritiesCount = reader.Read7BitEncodedInt();
+            HashSet<DiagnosticSeverity> explicitSeverities =
+                EnumerableExtensions.NewHashSet<DiagnosticSeverity>(explicitSeveritiesCount);
+            for (int j = 0; j < explicitSeveritiesCount; j++)
+            {
+                explicitSeverities.Add((DiagnosticSeverity)reader.Read7BitEncodedInt());
+            }
+            int projectNamesWhereEnabledCount = reader.Read7BitEncodedInt();
+            HashSet<string> projectNamesWhereEnabled =
+                EnumerableExtensions.NewHashSet<string>(projectNamesWhereEnabledCount);
+            for (int j = 0; j < projectNamesWhereEnabledCount; j++)
+            {
+                projectNamesWhereEnabled.Add(reader.ReadString());
+            }
+            int violationMessagesCount = reader.Read7BitEncodedInt();
+            int violationWarningsCount = reader.Read7BitEncodedInt();
+            int violationErrorsCount = reader.Read7BitEncodedInt();
+            bool isThrottled = reader.ReadBoolean();
+            TimeSpan totalRuntime = TimeSpan.FromTicks(reader.ReadInt64());
+
+            BuildCheckRuleTelemetryData data = new BuildCheckRuleTelemetryData(
+                ruleId, checkFriendlyName, isBuiltIn, defaultSeverity, explicitSeverities, projectNamesWhereEnabled,
+                violationMessagesCount, violationWarningsCount, violationErrorsCount, isThrottled, totalRuntime);
+
+            tracingData.Add(data);
+        }
+
+        TracingData = new BuildCheckTracingData(tracingData, infrastructureTracingData);
     }
 }
 
@@ -107,11 +173,11 @@ internal override void CreateFromStream(BinaryReader reader, int version)
 internal sealed class BuildCheckResultWarning : BuildWarningEventArgs
 {
     public BuildCheckResultWarning(IBuildCheckResult result, string code)
-        : base(subcategory: null, code: code, file: null, lineNumber: 0, columnNumber: 0, endLineNumber: 0, endColumnNumber: 0, message: result.FormatMessage(), helpKeyword: null, senderName: null) =>
+        : base(code: code, file: result.Location.File, lineNumber: result.Location.Line, columnNumber: result.Location.Column, message: result.FormatMessage()) =>
         RawMessage = result.FormatMessage();
 
     internal BuildCheckResultWarning(string formattedMessage, string code)
-        : base(subcategory: null, code: code, file: null, lineNumber: 0, columnNumber: 0, endLineNumber: 0, endColumnNumber: 0, message: formattedMessage, helpKeyword: null, senderName: null) =>
+        : base(code: code, file: null, lineNumber: 0, columnNumber: 0, message: formattedMessage) =>
         RawMessage = formattedMessage;
 
     internal BuildCheckResultWarning() { }
@@ -134,11 +200,11 @@ internal override void CreateFromStream(BinaryReader reader, int version)
 internal sealed class BuildCheckResultError : BuildErrorEventArgs
 {
     public BuildCheckResultError(IBuildCheckResult result, string code)
-        : base(subcategory: null, code: code, file: null, lineNumber: 0, columnNumber: 0, endLineNumber: 0, endColumnNumber: 0, message: result.FormatMessage(), helpKeyword: null, senderName: null)
+        : base(code: code, file: result.Location.File, lineNumber: result.Location.Line, columnNumber: result.Location.Column, message: result.FormatMessage())
         => RawMessage = result.FormatMessage();
 
     internal BuildCheckResultError(string formattedMessage, string code)
-        : base(subcategory: null, code: code, file: null, lineNumber: 0, columnNumber: 0, endLineNumber: 0, endColumnNumber: 0, message: formattedMessage, helpKeyword: null, senderName: null)
+        : base(code: code, file: null, lineNumber: 0, columnNumber: 0, message: formattedMessage)
         => RawMessage = formattedMessage;
 
     internal BuildCheckResultError() { }
@@ -160,7 +226,10 @@ internal override void CreateFromStream(BinaryReader reader, int version)
 
 internal sealed class BuildCheckResultMessage : BuildMessageEventArgs
 {
-    public BuildCheckResultMessage(IBuildCheckResult result) => RawMessage = result.FormatMessage();
+    public BuildCheckResultMessage(IBuildCheckResult result)
+        : base(message: result.FormatMessage(), file: result.Location.File, lineNumber: result.Location.Line, columnNumber: result.Location.Column, MessageImportance.High)
+        => RawMessage = result.FormatMessage();
+    
 
     internal BuildCheckResultMessage(string formattedMessage) => RawMessage = formattedMessage;
 
diff --git a/src/Framework/BuildCheck/BuildCheckRuleTelemetryData.cs b/src/Framework/BuildCheck/BuildCheckRuleTelemetryData.cs
new file mode 100644
index 00000000000..451b8ca55de
--- /dev/null
+++ b/src/Framework/BuildCheck/BuildCheckRuleTelemetryData.cs
@@ -0,0 +1,90 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Telemetry data for a single build check rule.
+/// </summary>
+/// <param name="ruleId"></param>
+/// <param name="checkFriendlyName"></param>
+/// <param name="isBuiltIn"></param>
+/// <param name="defaultSeverity"></param>
+internal sealed class BuildCheckRuleTelemetryData(
+    string ruleId,
+    string checkFriendlyName,
+    bool isBuiltIn,
+    DiagnosticSeverity defaultSeverity)
+{
+    public BuildCheckRuleTelemetryData(
+        string ruleId,
+        string checkFriendlyName,
+        bool isBuiltIn,
+        DiagnosticSeverity defaultSeverity,
+        HashSet<DiagnosticSeverity> explicitSeverities,
+        HashSet<string> projectNamesWhereEnabled,
+        int violationMessagesCount,
+        int violationWarningsCount,
+        int violationErrorsCount,
+        bool isThrottled,
+        TimeSpan totalRuntime) : this(ruleId, checkFriendlyName, isBuiltIn,
+        defaultSeverity)
+    {
+        ExplicitSeverities = explicitSeverities;
+        ProjectNamesWhereEnabled = projectNamesWhereEnabled;
+        ViolationMessagesCount = violationMessagesCount;
+        ViolationWarningsCount = violationWarningsCount;
+        ViolationErrorsCount = violationErrorsCount;
+        IsThrottled = isThrottled;
+        TotalRuntime = totalRuntime;
+    }
+
+    public static BuildCheckRuleTelemetryData Merge(
+        BuildCheckRuleTelemetryData data1,
+        BuildCheckRuleTelemetryData data2)
+    {
+        if (data1.RuleId != data2.RuleId)
+        {
+            throw new InvalidOperationException("Cannot merge telemetry data for different rules.");
+        }
+        return new BuildCheckRuleTelemetryData(
+            data1.RuleId,
+            data1.CheckFriendlyName,
+            data1.IsBuiltIn,
+            data1.DefaultSeverity,
+            new HashSet<DiagnosticSeverity>(data1.ExplicitSeverities.Union(data2.ExplicitSeverities)),
+            new HashSet<string>(data1.ProjectNamesWhereEnabled.Union(data2.ProjectNamesWhereEnabled)),
+            data1.ViolationMessagesCount + data2.ViolationMessagesCount,
+            data1.ViolationWarningsCount + data2.ViolationWarningsCount,
+            data1.ViolationErrorsCount + data2.ViolationErrorsCount,
+            data1.IsThrottled || data2.IsThrottled,
+            data1.TotalRuntime + data2.TotalRuntime);
+    }
+
+    public string RuleId { get; init; } = ruleId;
+    public string CheckFriendlyName { get; init; } = checkFriendlyName;
+    public bool IsBuiltIn { get; init; } = isBuiltIn;
+    public DiagnosticSeverity DefaultSeverity { get; init; } = defaultSeverity;
+
+    /// <summary>
+    /// A set of explicitly set severities (through editorconfig(s)) for the rule. There can be multiple - as different projects can have different settings.
+    /// </summary>
+    public HashSet<DiagnosticSeverity> ExplicitSeverities { get; init; } = [];
+    public HashSet<string> ProjectNamesWhereEnabled { get; init; } = [];
+    public int ViolationMessagesCount { get; private set; }
+    public int ViolationWarningsCount { get; private set; }
+    public int ViolationErrorsCount { get; private set; }
+    public int ViolationsCount => ViolationMessagesCount + ViolationWarningsCount + ViolationErrorsCount;
+    public bool IsThrottled { get; private set; }
+    public TimeSpan TotalRuntime { get; set; }
+
+    public void IncrementMessagesCount() => ViolationMessagesCount++;
+    public void IncrementWarningsCount() => ViolationWarningsCount++;
+    public void IncrementErrorsCount() => ViolationErrorsCount++;
+    public void SetThrottled() => IsThrottled = true;
+}
+
diff --git a/src/Framework/BuildCheck/BuildCheckTracingData.cs b/src/Framework/BuildCheck/BuildCheckTracingData.cs
new file mode 100644
index 00000000000..dc3ef3cb227
--- /dev/null
+++ b/src/Framework/BuildCheck/BuildCheckTracingData.cs
@@ -0,0 +1,51 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Wrapper for the tracing data to be transferred from the worker nodes to the central node.
+/// </summary>
+/// <param name="telemetryData"></param>
+/// <param name="infrastructureTracingData"></param>
+internal sealed class BuildCheckTracingData(
+    Dictionary<string, BuildCheckRuleTelemetryData> telemetryData,
+    Dictionary<string, TimeSpan> infrastructureTracingData)
+{
+    public BuildCheckTracingData(IReadOnlyList<BuildCheckRuleTelemetryData> telemetryData, Dictionary<string, TimeSpan> infrastructureTracingData)
+        : this(telemetryData.ToDictionary(data => data.RuleId), infrastructureTracingData)
+    { }
+
+    public BuildCheckTracingData()
+        : this(new Dictionary<string, BuildCheckRuleTelemetryData>(), [])
+    { }
+
+    internal BuildCheckTracingData(Dictionary<string, TimeSpan> executionData)
+        : this(new Dictionary<string, BuildCheckRuleTelemetryData>(), executionData)
+    { }
+
+    public Dictionary<string, BuildCheckRuleTelemetryData> TelemetryData { get; private set; } = telemetryData;
+    public Dictionary<string, TimeSpan> InfrastructureTracingData { get; private set; } = infrastructureTracingData;
+
+    /// <summary>
+    /// Gets the runtime stats per individual checks friendly names
+    /// </summary>
+    public Dictionary<string, TimeSpan> ExtractCheckStats() =>
+        // Stats are per rule, while runtime is per check - and check can have multiple rules.
+        // In case of multi-rule check, the runtime stats are duplicated for each rule.
+        TelemetryData
+            .GroupBy(d => d.Value.CheckFriendlyName)
+            .ToDictionary(g => g.Key, g => g.First().Value.TotalRuntime);
+
+    public void MergeIn(BuildCheckTracingData other)
+    {
+        InfrastructureTracingData.Merge(other.InfrastructureTracingData, (span1, span2) => span1 + span2);
+        TelemetryData.Merge(other.TelemetryData, BuildCheckRuleTelemetryData.Merge);
+    }
+}
diff --git a/src/Framework/BuildCheck/DiagnosticSeverity.cs b/src/Framework/BuildCheck/DiagnosticSeverity.cs
new file mode 100644
index 00000000000..025b83faa1b
--- /dev/null
+++ b/src/Framework/BuildCheck/DiagnosticSeverity.cs
@@ -0,0 +1,32 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+internal enum DiagnosticSeverity
+{
+    /// <summary>
+    /// When set, the default value of the BuildCheck rule will be used.
+    /// </summary>
+    Default,
+
+    /// <summary>
+    /// When set to None the rule will not run.
+    /// </summary>
+    None,
+
+    /// <summary>
+    /// Information level message.
+    /// </summary>
+    Suggestion,
+
+    /// <summary>
+    /// Results a warning in build if the BuildCheck rule applied.
+    /// </summary>
+    Warning,
+
+    /// <summary>
+    /// Results an error in build if the BuildCheck rule applied.
+    /// </summary>
+    Error
+}
diff --git a/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs b/src/Framework/BuildCheck/EnumerableExtensions.cs
similarity index 56%
rename from src/Build/BuildCheck/Utilities/EnumerableExtensions.cs
rename to src/Framework/BuildCheck/EnumerableExtensions.cs
index f89f72b0e2c..d74136269d9 100644
--- a/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs
+++ b/src/Framework/BuildCheck/EnumerableExtensions.cs
@@ -32,6 +32,36 @@ public static IEnumerable<T> AsSingleItemEnumerable<T>(this T item)
         yield return item;
     }
 
+    public static HashSet<T> NewHashSet<T>(int capacity)
+        => NewHashSet<T>(capacity, null);
+
+    public static HashSet<T> NewHashSet<T>(IEqualityComparer<T> equalityComparer)
+        => NewHashSet<T>(0, equalityComparer);
+
+    public static HashSet<T> NewHashSet<T>(int capacity, IEqualityComparer<T>? equalityComparer)
+    {
+#if NETSTANDARD2_0
+        return new HashSet<T>(equalityComparer);
+#else
+        return new HashSet<T>(capacity, equalityComparer);
+#endif
+    }
+
+    public static HashSet<T>? ToHashSet<T>(this ICollection<T>? source, IEqualityComparer<T>? equalityComparer = null)
+    {
+        if (source is null)
+        {
+            return null;
+        }
+
+        if (source is HashSet<T> set)
+        {
+            return set;
+        }
+
+        return new HashSet<T>(source, equalityComparer);
+    }
+
 #if !NET
     /// <summary>
     /// Returns a read-only <see cref="ReadOnlyDictionary{TKey, TValue}"/> wrapper
@@ -66,4 +96,33 @@ public static void Merge<TKey, TValue>(
             }
         }
     }
+
+    /// <summary>
+    /// Adds a content of given list to current dictionary.
+    /// </summary>
+    /// <typeparam name="TKey"></typeparam>
+    /// <typeparam name="TValue"></typeparam>
+    /// <param name="dict">Dictionary to receive another values.</param>
+    /// <param name="another">List to be merged into current.</param>
+    /// <param name="extractKey">Way of getting a key of an incoming value.</param>
+    /// <param name="mergeValues">Way of resolving keys conflicts.</param>
+    public static void Merge<TKey, TValue>(
+        this IDictionary<TKey, TValue> dict,
+        IReadOnlyList<TValue> another,
+        Func<TValue, TKey> extractKey,
+        Func<TValue, TValue, TValue> mergeValues)
+    {
+        foreach (var mergeValue in another)
+        {
+            TKey key = extractKey(mergeValue);
+            if (!dict.TryGetValue(key, out TValue? value))
+            {
+                dict[key] = mergeValue;
+            }
+            else
+            {
+                dict[key] = mergeValues(value, mergeValue);
+            }
+        }
+    }
 }
diff --git a/src/Framework/BuildCheck/IBuildCheckResult.cs b/src/Framework/BuildCheck/IBuildCheckResult.cs
index 1d471e6c9bc..4f7043b771b 100644
--- a/src/Framework/BuildCheck/IBuildCheckResult.cs
+++ b/src/Framework/BuildCheck/IBuildCheckResult.cs
@@ -1,11 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
@@ -18,6 +14,11 @@ internal interface IBuildCheckResult
     /// Optional location of the finding (in near future we might need to support multiple locations).
     /// </summary>
     string LocationString { get; }
+
+    /// <summary>
+    /// Location of the finding.
+    /// </summary>
+    IMSBuildElementLocation Location { get; }
     string[] MessageArgs { get; }
     string MessageFormat { get; }
 
diff --git a/src/Framework/BuildErrorEventArgs.cs b/src/Framework/BuildErrorEventArgs.cs
index 543f71e1ec3..1b793121678 100644
--- a/src/Framework/BuildErrorEventArgs.cs
+++ b/src/Framework/BuildErrorEventArgs.cs
@@ -201,6 +201,28 @@ public BuildErrorEventArgs(
             this.helpLink = helpLink;
         }
 
+        /// <summary>
+        /// This constructor allows event data without ends to be initialized.
+        /// </summary>
+        /// <param name="code">event code</param>
+        /// <param name="file">file associated with the event</param>
+        /// <param name="lineNumber">line number (0 if not applicable)</param>
+        /// <param name="columnNumber">column number (0 if not applicable)</param>
+        /// <param name="message">text message</param>
+        protected BuildErrorEventArgs(
+           string code,
+           string message,
+           string file,
+           int lineNumber,
+           int columnNumber)
+            : base(message, helpKeyword: null, senderName: null)
+        {
+            this.code = code;
+            this.file = file;
+            this.lineNumber = lineNumber;
+            this.columnNumber = columnNumber;
+        }
+
         /// <summary>
         /// Default constructor
         /// </summary>
diff --git a/src/Framework/BuildEventContext.cs b/src/Framework/BuildEventContext.cs
index 0622bf45896..83a7a1f9330 100644
--- a/src/Framework/BuildEventContext.cs
+++ b/src/Framework/BuildEventContext.cs
@@ -115,6 +115,16 @@ public BuildEventContext(
         }
 
         #endregion
+        internal BuildEventContext WithInstanceIdAndContextId(int projectInstanceId, int projectContextId)
+        {
+            return new BuildEventContext(_submissionId, _nodeId, _evaluationId, projectInstanceId, projectContextId,
+                _targetId, _taskId);
+        }
+
+        internal BuildEventContext WithInstanceIdAndContextId(BuildEventContext other)
+        {
+            return WithInstanceIdAndContextId(other.ProjectInstanceId, other.ProjectContextId);
+        }
 
         #region Properties
 
diff --git a/src/Framework/BuildException/BuildExceptionBase.cs b/src/Framework/BuildException/BuildExceptionBase.cs
index 07db4994b93..426ad35526b 100644
--- a/src/Framework/BuildException/BuildExceptionBase.cs
+++ b/src/Framework/BuildException/BuildExceptionBase.cs
@@ -127,7 +127,7 @@ internal static Exception ReadExceptionFromTranslator(ITranslator translator)
         string? deserializedStackTrace = reader.ReadOptionalString();
         string? source = reader.ReadOptionalString();
         string? helpLink = reader.ReadOptionalString();
-        int hResult = reader.ReadOptionalInt32();
+        int hResult = reader.ReadOptionalInt32() ?? 0;
 
         IDictionary<string, string?>? customKeyedSerializedData = null;
         if (reader.ReadByte() == 1)
diff --git a/src/Framework/BuildSubmissionStartedEventArgs.cs b/src/Framework/BuildSubmissionStartedEventArgs.cs
index f77fdf8cfd0..3e42bbb142b 100644
--- a/src/Framework/BuildSubmissionStartedEventArgs.cs
+++ b/src/Framework/BuildSubmissionStartedEventArgs.cs
@@ -19,8 +19,8 @@ public sealed class BuildSubmissionStartedEventArgs : BuildStatusEventArgs
         public BuildSubmissionStartedEventArgs()
         {
             GlobalProperties = new Dictionary<string, string?>();
-            EntryProjectsFullPath = Enumerable.Empty<string>();
-            TargetNames = Enumerable.Empty<string>();
+            EntryProjectsFullPath = [];
+            TargetNames = [];
             Flags = BuildRequestDataFlags.None;
             SubmissionId = 0;
         }
diff --git a/src/Framework/BuildWarningEventArgs.cs b/src/Framework/BuildWarningEventArgs.cs
index 8e2e522147b..7cd5ec1f09d 100644
--- a/src/Framework/BuildWarningEventArgs.cs
+++ b/src/Framework/BuildWarningEventArgs.cs
@@ -163,6 +163,20 @@ public BuildWarningEventArgs(
             this.helpLink = helpLink;
         }
 
+        /// <summary>
+        /// This constructor allows event data without ends to be initialized.
+        /// </summary>
+        /// <param name="code">event code</param>
+        /// <param name="file">file associated with the event</param>
+        /// <param name="lineNumber">line number (0 if not applicable)</param>
+        /// <param name="columnNumber">column number (0 if not applicable)</param>
+        /// <param name="message">text message</param>
+        public BuildWarningEventArgs(string code, string file, int lineNumber, int columnNumber, string message)
+            : this(subcategory: null, code: code, file: file, lineNumber: lineNumber, columnNumber: columnNumber, endLineNumber: 0, endColumnNumber: 0, message: message, helpKeyword: null, senderName: null)
+        {
+            // do nothing
+        }
+
         private string subcategory;
         private string code;
         private string file;
diff --git a/src/Framework/CompatibilitySuppressions.xml b/src/Framework/CompatibilitySuppressions.xml
index 23bea3c7b5b..d61bb3c6b1f 100644
--- a/src/Framework/CompatibilitySuppressions.xml
+++ b/src/Framework/CompatibilitySuppressions.xml
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
+<!-- https://learn.microsoft.com/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <Suppression>
     <DiagnosticId>PKV004</DiagnosticId>
@@ -49,85 +49,4 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
-  <!--
-  Since we are dropping the .net 8 and retarrgetting to .net 9, we need to suppress the following errors. 
-  The comparison ref/net.8 with ref/netstandard2.0 is not valid anymore.
-  -->
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Framework.AssemblyLoadingContext</Target>
-    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Framework.FeatureStatus</Target>
-    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Framework.LoggerVerbosity</Target>
-    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Framework.MessageImportance</Target>
-    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Framework.Profiler.EvaluationLocationKind</Target>
-    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Framework.Profiler.EvaluationPass</Target>
-    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Framework.RegisteredTaskObjectLifetime</Target>
-    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Framework.TargetBuiltReason</Target>
-    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Framework.TargetSkipReason</Target>
-    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Framework.TaskParameterMessageKind</Target>
-    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <!--
-    https://learn.microsoft.com/en-us/dotnet/fundamentals/apicompat/diagnostic-ids
-    Suppress PKV006 for net8.0 (The target framework is dropped in the latest version.)  -->
-  <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net8.0</Target>
-  </Suppression>
-</Suppressions>
+</Suppressions>
\ No newline at end of file
diff --git a/src/Framework/FileClassifier.cs b/src/Framework/FileClassifier.cs
index 8f19fd39b81..2072633870b 100644
--- a/src/Framework/FileClassifier.cs
+++ b/src/Framework/FileClassifier.cs
@@ -85,7 +85,7 @@ private set
         /// <summary>
         ///     Copy on write snapshot of <see cref="_knownImmutableDirectories"/>.
         /// </summary>
-        private volatile IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = Array.Empty<string>();
+        private volatile IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = [];
 
         /// <summary>
         ///     Creates default FileClassifier which following immutable folders:
@@ -103,7 +103,7 @@ private set
         public FileClassifier()
         {
             // Register Microsoft "Reference Assemblies" as immutable
-            string[] programFilesEnvs = new[] { "ProgramFiles(x86)", "ProgramW6432", "ProgramFiles(Arm)" };
+            string[] programFilesEnvs = ["ProgramFiles(x86)", "ProgramW6432", "ProgramFiles(Arm)"];
             foreach (string programFilesEnv in programFilesEnvs)
             {
                 string? programFiles = Environment.GetEnvironmentVariable(programFilesEnv);
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index 787ba544b89..736cccac2f1 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -39,6 +39,9 @@
     <Compile Include="..\Shared\BinaryWriterExtensions.cs">
       <Link>Shared\BinaryWriterExtensions.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\IMSBuildElementLocation.cs">
+      <Link>Shared\IMSBuildElementLocation.cs</Link>
+    </Compile>
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 8df49a7e054..bbc62463b1e 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -664,11 +664,20 @@ private static LongPathsStatus IsLongPathsEnabledRegistry()
         }
     }
 
+    private static SAC_State? s_sacState;
+
     /// <summary>
     /// Get from registry state of the Smart App Control (SAC) on the system.
     /// </summary>
     /// <returns>State of SAC</returns>
     internal static SAC_State GetSACState()
+    {
+        s_sacState ??= GetSACStateInternal();
+
+        return s_sacState.Value;
+    }
+
+    internal static SAC_State GetSACStateInternal()
     {
         if (IsWindows)
         {
@@ -1537,6 +1546,7 @@ private static unsafe int GetFullPathWin32(string target, int bufferLength, char
     /// <returns>True only if the contents of <paramref name="s"/> and the first <paramref name="len"/> characters in <paramref name="buffer"/> are identical.</returns>
     private static unsafe bool AreStringsEqual(char* buffer, int len, string s)
     {
+#if CLR2COMPATIBILITY
         if (len != s.Length)
         {
             return false;
@@ -1551,6 +1561,9 @@ private static unsafe bool AreStringsEqual(char* buffer, int len, string s)
         }
 
         return true;
+#else
+        return MemoryExtensions.SequenceEqual(new ReadOnlySpan<char>(buffer, len), s.AsSpan());
+#endif
     }
 
     internal static void VerifyThrowWin32Result(int result)
diff --git a/src/Framework/NullableAttributes.cs b/src/Framework/NullableAttributes.cs
index 4e46baa38f0..b6698fce618 100644
--- a/src/Framework/NullableAttributes.cs
+++ b/src/Framework/NullableAttributes.cs
@@ -99,7 +99,7 @@ internal sealed class MemberNotNullAttribute : Attribute
         /// <param name="member">
         /// The field or property member that is promised to be not-null.
         /// </param>
-        public MemberNotNullAttribute(string member) => Members = new[] { member };
+        public MemberNotNullAttribute(string member) => Members = [member];
 
         /// <summary>Initializes the attribute with the list of field and property members.</summary>
         /// <param name="members">
@@ -125,7 +125,7 @@ internal sealed class MemberNotNullWhenAttribute : Attribute
         public MemberNotNullWhenAttribute(bool returnValue, string member)
         {
             ReturnValue = returnValue;
-            Members = new[] { member };
+            Members = [member];
         }
 
         /// <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index 4636850306a..c8e0538eb25 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -8,6 +8,7 @@
 using System.IO;
 using System.Linq;
 using System.Runtime.Serialization;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Framework
@@ -302,7 +303,7 @@ public IEnumerable? Properties
                 // By doing this, we no longer need to transmit properties using this message because they've already
                 // been transmitted as part of the BuildRequestConfiguration.
                 return properties ?? (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
-                    ? Enumerable.Empty<DictionaryEntry>()
+                    ? (DictionaryEntry[])[]
                     : null);
             }
         }
@@ -328,11 +329,19 @@ public IEnumerable? Items
                 // has likely not loaded this project, and therefore the live items would not be available to them, which is
                 // the same as the current functionality.
                 return items ?? (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
-                    ? Enumerable.Empty<DictionaryEntry>()
+                    ? (DictionaryEntry[])[]
                     : null);
             }
         }
 
+        // Following 3 properties are intended only for internal transfer - to properly communicate the warn as error/msg
+        //  from the worker node, to the main node - that may be producing the buildcheck diagnostics.
+        // They are not going to be in a binlog (at least not as of now).
+
+        internal ISet<string>? WarningsAsErrors { get; set; }
+        internal ISet<string>? WarningsNotAsErrors { get; set; }
+        internal ISet<string>? WarningsAsMessages { get; set; }
+
         #region CustomSerializationToStream
 
         /// <summary>
@@ -389,6 +398,10 @@ internal override void WriteToStream(BinaryWriter writer)
                     writer.Write((string?)propertyPair.Value ?? "");
                 }
             }
+
+            WriteCollection(writer, WarningsAsErrors);
+            WriteCollection(writer, WarningsNotAsErrors);
+            WriteCollection(writer, WarningsAsMessages);
         }
 
         /// <summary>
@@ -457,7 +470,48 @@ internal override void CreateFromStream(BinaryReader reader, int version)
 
                 properties = dictionaryList;
             }
+
+            WarningsAsErrors = ReadStringSet(reader);
+            WarningsNotAsErrors = ReadStringSet(reader);
+            WarningsAsMessages = ReadStringSet(reader);
         }
+
+        private static void WriteCollection(BinaryWriter writer, ICollection<string>? collection)
+        {
+            if (collection == null)
+            {
+                writer.Write((byte)0);
+            }
+            else
+            {
+                writer.Write((byte)1);
+                writer.Write(collection.Count);
+                foreach (string item in collection)
+                {
+                    writer.Write(item);
+                }
+            }
+        }
+
+        private static ISet<string>? ReadStringSet(BinaryReader reader)
+        {
+            if (reader.ReadByte() == 0)
+            {
+                return null;
+            }
+            else
+            {
+                int count = reader.ReadInt32();
+                HashSet<string> set = EnumerableExtensions.NewHashSet<string>(count, StringComparer.OrdinalIgnoreCase);
+                for (int i = 0; i < count; i++)
+                {
+                    set.Add(reader.ReadString());
+                }
+
+                return set;
+            }
+        }
+
         #endregion
 
         #region SerializationSection
diff --git a/src/Framework/Telemetry/BuildCheckTelemetry.cs b/src/Framework/Telemetry/BuildCheckTelemetry.cs
new file mode 100644
index 00000000000..3b8507203c1
--- /dev/null
+++ b/src/Framework/Telemetry/BuildCheckTelemetry.cs
@@ -0,0 +1,96 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Linq;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.Framework.Telemetry;
+
+internal class BuildCheckTelemetry
+{
+    private const string FailedAcquisitionEventName = "buildcheck/acquisitionfailure";
+    private const string RunEventName = "buildcheck/run";
+    private const string RuleStatsEventName = "buildcheck/rule";
+    private Guid _submissionId = Guid.NewGuid();
+
+    /// <summary>
+    /// Translates failed acquisition event to telemetry transport data.
+    /// </summary>
+    internal (string, IDictionary<string, string>) ProcessCustomCheckLoadingFailure(string assemblyName,
+        Exception exception)
+    {
+        var properties = new Dictionary<string, string>();
+        properties["SubmissionId"] = _submissionId.ToString();
+        properties["AssemblyName"] = assemblyName;
+        string? exceptionType = exception.GetType().FullName;
+        if (exceptionType != null)
+        {
+            properties["ExceptionType"] = exceptionType;
+        }
+        if (exception.Message != null)
+        {
+            properties["ExceptionMessage"] = exception.Message;
+        }
+
+        return (FailedAcquisitionEventName, properties);
+    }
+
+    /// <summary>
+    /// Translates BuildCheck tracing data to telemetry transport data.
+    /// </summary>
+    internal IEnumerable<(string, IDictionary<string, string>)> ProcessBuildCheckTracingData(BuildCheckTracingData data)
+    {
+        int rulesCount = data.TelemetryData.Count;
+        int customRulesCount = data.TelemetryData.Count(t => !t.Value.IsBuiltIn);
+        int violationsCount = data.TelemetryData.Sum(t => t.Value.ViolationsCount);
+        long runtimeTicks = data.ExtractCheckStats().Sum(v => v.Value.Ticks);
+        runtimeTicks += data.InfrastructureTracingData.Sum(v => v.Value.Ticks);
+        TimeSpan totalRuntime = new TimeSpan(runtimeTicks);
+
+        var properties = new Dictionary<string, string>();
+        properties["SubmissionId"] = _submissionId.ToString();
+        properties["RulesCount"] = rulesCount.ToString(CultureInfo.InvariantCulture);
+        properties["CustomRulesCount"] = customRulesCount.ToString(CultureInfo.InvariantCulture);
+        properties["ViolationsCount"] = violationsCount.ToString(CultureInfo.InvariantCulture);
+        properties["TotalRuntimeInMilliseconds"] = totalRuntime.TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+
+        yield return (RunEventName, properties);
+
+        foreach (BuildCheckRuleTelemetryData buildCheckRuleTelemetryData in data.TelemetryData.Values)
+        {
+            properties = new Dictionary<string, string>();
+            properties["SubmissionId"] = _submissionId.ToString();
+            properties["RuleId"] = buildCheckRuleTelemetryData.RuleId;
+            properties["CheckFriendlyName"] = buildCheckRuleTelemetryData.CheckFriendlyName;
+            properties["IsBuiltIn"] = buildCheckRuleTelemetryData.IsBuiltIn.ToString(CultureInfo.InvariantCulture);
+            properties["DefaultSeverityId"] = ((int)buildCheckRuleTelemetryData.DefaultSeverity).ToString(CultureInfo.InvariantCulture);
+            properties["DefaultSeverity"] = buildCheckRuleTelemetryData.DefaultSeverity.ToString();
+            properties["EnabledProjectsCount"] = buildCheckRuleTelemetryData.ProjectNamesWhereEnabled.Count.ToString(CultureInfo.InvariantCulture);
+
+            if (buildCheckRuleTelemetryData.ExplicitSeverities.Any())
+            {
+                properties["ExplicitSeverities"] = buildCheckRuleTelemetryData.ExplicitSeverities
+                    .Select(s => s.ToString()).ToCsvString(false);
+                properties["ExplicitSeveritiesIds"] = buildCheckRuleTelemetryData.ExplicitSeverities
+                    .Select(s => ((int)s).ToString(CultureInfo.InvariantCulture)).ToCsvString(false);
+            }
+
+            properties["ViolationMessagesCount"] = buildCheckRuleTelemetryData.ViolationMessagesCount.ToString(CultureInfo.InvariantCulture);
+            properties["ViolationWarningsCount"] = buildCheckRuleTelemetryData.ViolationWarningsCount.ToString(CultureInfo.InvariantCulture);
+            properties["ViolationErrorsCount"] = buildCheckRuleTelemetryData.ViolationErrorsCount.ToString(CultureInfo.InvariantCulture);
+            properties["IsThrottled"] = buildCheckRuleTelemetryData.IsThrottled.ToString(CultureInfo.InvariantCulture);
+            properties["TotalRuntimeInMilliseconds"] = buildCheckRuleTelemetryData.TotalRuntime.TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+
+            yield return (RuleStatsEventName, properties);
+        }
+
+
+        // set for the new submission in case of build server
+        _submissionId = Guid.NewGuid();
+    }
+}
+
+
diff --git a/src/Framework/Telemetry/BuildTelemetry.cs b/src/Framework/Telemetry/BuildTelemetry.cs
index 7e2e0c6b514..c23d9269c9b 100644
--- a/src/Framework/Telemetry/BuildTelemetry.cs
+++ b/src/Framework/Telemetry/BuildTelemetry.cs
@@ -74,6 +74,16 @@ internal class BuildTelemetry : TelemetryBase
         /// </summary>
         public string? Host { get; set; }
 
+        /// <summary>
+        /// True if buildcheck was used.
+        /// </summary>
+        public bool? BuildCheckEnabled { get; set; }
+
+        /// <summary>
+        /// True if Smart Application Control was enabled.
+        /// </summary>
+        public bool? SACEnabled { get; set; }
+
         /// <summary>
         /// State of MSBuild server process before this build.
         /// One of 'cold', 'hot', null (if not run as server)
@@ -145,6 +155,16 @@ public override IDictionary<string, string> GetProperties()
                 properties["BuildEngineVersion"] = Version.ToString();
             }
 
+            if (BuildCheckEnabled != null)
+            {
+                properties["BuildCheckEnabled"] = BuildCheckEnabled.Value.ToString(CultureInfo.InvariantCulture);
+            }
+
+            if (SACEnabled != null)
+            {
+                properties["SACEnabled"] = SACEnabled.Value.ToString(CultureInfo.InvariantCulture);
+            }
+
             return properties;
         }
     }
diff --git a/src/Framework/Telemetry/KnownTelemetry.cs b/src/Framework/Telemetry/KnownTelemetry.cs
index 7685bdda537..e775bce1fe6 100644
--- a/src/Framework/Telemetry/KnownTelemetry.cs
+++ b/src/Framework/Telemetry/KnownTelemetry.cs
@@ -20,4 +20,9 @@ internal static class KnownTelemetry
     /// Describes how logging was configured.
     /// </summary>
     public static LoggingConfigurationTelemetry LoggingConfigurationTelemetry { get; } = new LoggingConfigurationTelemetry();
+
+    /// <summary>
+    /// Describes if and how BuildCheck was used.
+    /// </summary>
+    public static BuildCheckTelemetry BuildCheckTelemetry { get; } = new BuildCheckTelemetry();
 }
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index cc0ef31eee8..2558de02b41 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -364,6 +364,11 @@ public bool? LogPropertiesAndItemsAfterEvaluation
         /// </remarks>
         public readonly bool DoNotVersionBuildResult = Environment.GetEnvironmentVariable("MSBUILDDONOTVERSIONBUILDRESULT") == "1";
 
+        /// <summary>
+        /// Escape hatch to ensure build check does not limit amount of results.
+        /// </summary>
+        public readonly bool DoNotLimitBuildCheckResultsNumber = Environment.GetEnvironmentVariable("MSBUILDDONOTLIMITBUILDCHECKRESULTSNUMBER") == "1";
+
         private bool _sdkReferencePropertyExpansionInitialized;
         private SdkReferencePropertyExpansionMode? _sdkReferencePropertyExpansionValue;
 
@@ -418,26 +423,6 @@ public bool UnquoteTargetSwitchParameters
             }
         }
 
-        private bool? _isBinaryFormatterSerializationAllowed;
-        public bool IsBinaryFormatterSerializationAllowed
-        {
-            get
-            {
-                if (!_isBinaryFormatterSerializationAllowed.HasValue)
-                {
-#if RUNTIME_TYPE_NETCORE
-                    AppContext.TryGetSwitch("System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization",
-                        out bool enabled);
-                    _isBinaryFormatterSerializationAllowed = enabled;
-#else
-                    _isBinaryFormatterSerializationAllowed = true;
-#endif
-                }
-
-                return _isBinaryFormatterSerializationAllowed.Value;
-            }
-        }
-
 
         private static bool? ParseNullableBoolFromEnvironmentVariable(string environmentVariable)
         {
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 6ffae8dfb52..47e9361022d 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -1531,25 +1531,6 @@ public void ProcessInvalidTargetSwitch()
 #endif
         }
 
-        /// <summary>
-        /// Verifies that when the /profileevaluation switch is used with invalid filenames an error is shown.
-        /// </summary>
-        [MemberData(nameof(GetInvalidFilenames))]
-        [WindowsFullFrameworkOnlyTheory(additionalMessage: ".NET Core 2.1+ no longer validates paths: https://github.com/dotnet/corefx/issues/27779#issuecomment-371253486.")]
-        public void ProcessProfileEvaluationInvalidFilename(string filename)
-        {
-            bool enableProfiler = false;
-            Should.Throw(
-                () => MSBuildApp.ProcessProfileEvaluationSwitch(new[] { filename }, new List<ILogger>(), out enableProfiler),
-                typeof(CommandLineSwitchException));
-        }
-
-        public static IEnumerable<object[]> GetInvalidFilenames()
-        {
-            yield return new object[] { $"a_file_with${Path.GetInvalidFileNameChars().First()}invalid_chars" };
-            yield return new object[] { $"C:\\a_path\\with{Path.GetInvalidPathChars().First()}invalid\\chars" };
-        }
-
         /// <summary>
         /// Verifies that help messages are correctly formed with the right width and leading spaces.
         /// </summary>
diff --git a/src/MSBuild.UnitTests/NodeStatus_SizeChange_Tests.cs b/src/MSBuild.UnitTests/NodeStatus_SizeChange_Tests.cs
index ba6e2f50ecd..cdb004687af 100644
--- a/src/MSBuild.UnitTests/NodeStatus_SizeChange_Tests.cs
+++ b/src/MSBuild.UnitTests/NodeStatus_SizeChange_Tests.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using System.Linq;
 using System.Text;
 using System.Threading.Tasks;
@@ -19,12 +20,16 @@
 namespace Microsoft.Build.CommandLine.UnitTests;
 
 [UsesVerify]
-public class NodeStatus_SizeChange_Tests
+public class NodeStatus_SizeChange_Tests : IDisposable
 {
     private readonly NodeStatus _status = new("Namespace.Project", "TargetFramework", "Target", new MockStopwatch());
+    private CultureInfo _currentCulture;
 
     public NodeStatus_SizeChange_Tests()
     {
+        _currentCulture = CultureInfo.CurrentCulture;
+        CultureInfo.CurrentCulture = CultureInfo.InvariantCulture;
+
         UseProjectRelativeDirectory("Snapshots");
     }
 
@@ -59,4 +64,9 @@ public async Task GoesToProject()
 
         await Verify(frame.RenderNodeStatus(0).ToString());
     }
+
+    public void Dispose()
+    {
+        CultureInfo.CurrentCulture = _currentCulture;
+    }
 }
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 0ef451ba979..ee6eb6219fb 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -11,6 +11,7 @@
 using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Threading;
+using System.Xml.Linq;
 using Microsoft.Build.CommandLine;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
@@ -985,8 +986,8 @@ public void ConfigurationInvalid()
                 var msbuildExeName = Path.GetFileName(RunnerUtilities.PathToCurrentlyRunningMsBuildExe);
                 var newPathToMSBuildExe = Path.Combine(startDirectory, msbuildExeName);
                 var pathToConfigFile = Path.Combine(startDirectory, msbuildExeName + ".config");
-
-                string configContent = @"<?xml version =""1.0""?>
+                XElement configRuntimeElement = XDocument.Load(RunnerUtilities.PathToCurrentlyRunningMsBuildExe + ".config").Root.Element("runtime");
+                string configContent = $@"<?xml version =""1.0""?>
                                             <configuration>
                                                 <configSections>
                                                     <section name=""msbuildToolsets"" type=""Microsoft.Build.Evaluation.ToolsetConfigurationSection, Microsoft.Build, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"" />
@@ -1006,6 +1007,7 @@ public void ConfigurationInvalid()
                                                 <foo/>
                                                 </msbuildToolsets>
                                                 <foo/>
+                                                {configRuntimeElement}
                                             </configuration>";
                 File.WriteAllText(pathToConfigFile, configContent);
 
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index ae5646ca7d1..b192f584c19 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -213,24 +213,24 @@ internal ParameterizedSwitchInfo(
             //----------------------------------------------------------------------------------------------------------------------------------------------------------
             //                                          Switch Names                        Switch Id                             Dup Error  Light up key    resourceId
             //----------------------------------------------------------------------------------------------------------------------------------------------------------
-            new ParameterlessSwitchInfo(  new string[] { "help", "h", "?" },                         ParameterlessSwitch.Help,                  null,       "HelpMessage_4_HelpSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "version", "ver" },                         ParameterlessSwitch.Version,               null,       "HelpMessage_6_VersionSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "nologo" },                                 ParameterlessSwitch.NoLogo,                null,       "HelpMessage_5_NoLogoSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "noautoresponse", "noautorsp" },            ParameterlessSwitch.NoAutoResponse,        null,       "HelpMessage_8_NoAutoResponseSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "noconsolelogger", "noconlog" },            ParameterlessSwitch.NoConsoleLogger,       null,       "HelpMessage_14_NoConsoleLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger", "fl" },                       ParameterlessSwitch.FileLogger,            null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger1", "fl1" },                     ParameterlessSwitch.FileLogger1,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger2", "fl2" },                     ParameterlessSwitch.FileLogger2,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger3", "fl3" },                     ParameterlessSwitch.FileLogger3,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger4", "fl4" },                     ParameterlessSwitch.FileLogger4,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger5", "fl5" },                     ParameterlessSwitch.FileLogger5,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger6", "fl6" },                     ParameterlessSwitch.FileLogger6,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger7", "fl7" },                     ParameterlessSwitch.FileLogger7,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger8", "fl8" },                     ParameterlessSwitch.FileLogger8,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger9", "fl9" },                     ParameterlessSwitch.FileLogger9,           null,       "HelpMessage_20_FileLoggerSwitch"),
-            new ParameterlessSwitchInfo(  new string[] { "distributedfilelogger", "dfl" },           ParameterlessSwitch.DistributedFileLogger, null,       "HelpMessage_21_DistributedFileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["help", "h", "?"],                         ParameterlessSwitch.Help,                  null,       "HelpMessage_4_HelpSwitch"),
+            new ParameterlessSwitchInfo(  ["version", "ver"],                         ParameterlessSwitch.Version,               null,       "HelpMessage_6_VersionSwitch"),
+            new ParameterlessSwitchInfo(  ["nologo"],                                 ParameterlessSwitch.NoLogo,                null,       "HelpMessage_5_NoLogoSwitch"),
+            new ParameterlessSwitchInfo(  ["noautoresponse", "noautorsp"],            ParameterlessSwitch.NoAutoResponse,        null,       "HelpMessage_8_NoAutoResponseSwitch"),
+            new ParameterlessSwitchInfo(  ["noconsolelogger", "noconlog"],            ParameterlessSwitch.NoConsoleLogger,       null,       "HelpMessage_14_NoConsoleLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger", "fl"],                       ParameterlessSwitch.FileLogger,            null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger1", "fl1"],                     ParameterlessSwitch.FileLogger1,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger2", "fl2"],                     ParameterlessSwitch.FileLogger2,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger3", "fl3"],                     ParameterlessSwitch.FileLogger3,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger4", "fl4"],                     ParameterlessSwitch.FileLogger4,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger5", "fl5"],                     ParameterlessSwitch.FileLogger5,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger6", "fl6"],                     ParameterlessSwitch.FileLogger6,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger7", "fl7"],                     ParameterlessSwitch.FileLogger7,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger8", "fl8"],                     ParameterlessSwitch.FileLogger8,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["filelogger9", "fl9"],                     ParameterlessSwitch.FileLogger9,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  ["distributedfilelogger", "dfl"],           ParameterlessSwitch.DistributedFileLogger, null,       "HelpMessage_21_DistributedFileLoggerSwitch"),
 #if DEBUG
-            new ParameterlessSwitchInfo(  new string[] { "waitfordebugger", "wfd" },                 ParameterlessSwitch.WaitForDebugger,       null,       null),
+            new ParameterlessSwitchInfo(  ["waitfordebugger", "wfd"],                 ParameterlessSwitch.WaitForDebugger,       null,       null),
 #endif
         };
 
@@ -241,62 +241,62 @@ internal ParameterizedSwitchInfo(
             //-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
             //                                          Switch Names                            Switch Id                                       Duplicate Switch Error          Multi Params?   Missing Parameters Error           Unquote?    Empty?   reosurceId
             //-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-            new ParameterizedSwitchInfo(  new string[] { null },                                ParameterizedSwitch.Project,                    "DuplicateProjectSwitchError",  false,          null,                                  true,   false,   null),
-            new ParameterizedSwitchInfo(  new string[] { "target", "t"},                        ParameterizedSwitch.Target,                     null,                           true,           "MissingTargetError",                  true,   false,   "HelpMessage_9_TargetSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "property", "p" },                     ParameterizedSwitch.Property,                   null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_10_PropertySwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "logger", "l" },                       ParameterizedSwitch.Logger,                     null,                           false,          "MissingLoggerError",                  false,  false,   "HelpMessage_11_LoggerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "distributedlogger", "dl" },           ParameterizedSwitch.DistributedLogger,          null,                           false,          "MissingLoggerError",                  false,  false,   "HelpMessage_18_DistributedLoggerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "verbosity", "v" },                    ParameterizedSwitch.Verbosity,                  null,                           false,          "MissingVerbosityError",               true,   false,   "HelpMessage_12_VerbositySwitch"),
+            new ParameterizedSwitchInfo(  [null],                                ParameterizedSwitch.Project,                    "DuplicateProjectSwitchError",  false,          null,                                  true,   false,   null),
+            new ParameterizedSwitchInfo(  ["target", "t"],                       ParameterizedSwitch.Target,                     null,                           true,           "MissingTargetError",                  true,   false,   "HelpMessage_9_TargetSwitch"),
+            new ParameterizedSwitchInfo(  ["property", "p"],                     ParameterizedSwitch.Property,                   null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_10_PropertySwitch"),
+            new ParameterizedSwitchInfo(  ["logger", "l"],                       ParameterizedSwitch.Logger,                     null,                           false,          "MissingLoggerError",                  false,  false,   "HelpMessage_11_LoggerSwitch"),
+            new ParameterizedSwitchInfo(  ["distributedlogger", "dl"],           ParameterizedSwitch.DistributedLogger,          null,                           false,          "MissingLoggerError",                  false,  false,   "HelpMessage_18_DistributedLoggerSwitch"),
+            new ParameterizedSwitchInfo(  ["verbosity", "v"],                    ParameterizedSwitch.Verbosity,                  null,                           false,          "MissingVerbosityError",               true,   false,   "HelpMessage_12_VerbositySwitch"),
 #if FEATURE_XML_SCHEMA_VALIDATION
-            new ParameterizedSwitchInfo(  new string[] { "validate", "val" },                   ParameterizedSwitch.Validate,                   null,                           false,          null,                                  true,   false,   "HelpMessage_15_ValidateSwitch"),
+            new ParameterizedSwitchInfo(  ["validate", "val"],                   ParameterizedSwitch.Validate,                   null,                           false,          null,                                  true,   false,   "HelpMessage_15_ValidateSwitch"),
 #endif
-            new ParameterizedSwitchInfo(  new string[] { "consoleloggerparameters", "clp" },    ParameterizedSwitch.ConsoleLoggerParameters,    null,                           false,          "MissingConsoleLoggerParameterError",  true,   false,   "HelpMessage_13_ConsoleLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "nodemode", "nmode" },                 ParameterizedSwitch.NodeMode,                   null,                           false,          null,                                  false,  false,   null),
-            new ParameterizedSwitchInfo(  new string[] { "maxcpucount", "m" },                  ParameterizedSwitch.MaxCPUCount,                null,                           false,          "MissingMaxCPUCountError",             true,   false,   "HelpMessage_17_MaximumCPUSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "ignoreprojectextensions", "ignore" }, ParameterizedSwitch.IgnoreProjectExtensions,    null,                           true,           "MissingIgnoreProjectExtensionsError", true,   false,   "HelpMessage_19_IgnoreProjectExtensionsSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "toolsversion","tv" },                 ParameterizedSwitch.ToolsVersion,               null,                           false,          "MissingToolsVersionError",            true,   false,   "HelpMessage_23_ToolsVersionSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters", "flp" },       ParameterizedSwitch.FileLoggerParameters,       null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters1", "flp1" },     ParameterizedSwitch.FileLoggerParameters1,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters2", "flp2" },     ParameterizedSwitch.FileLoggerParameters2,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters3", "flp3" },     ParameterizedSwitch.FileLoggerParameters3,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters4", "flp4" },     ParameterizedSwitch.FileLoggerParameters4,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters5", "flp5" },     ParameterizedSwitch.FileLoggerParameters5,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters6", "flp6" },     ParameterizedSwitch.FileLoggerParameters6,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters7", "flp7" },     ParameterizedSwitch.FileLoggerParameters7,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters8", "flp8" },     ParameterizedSwitch.FileLoggerParameters8,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters9", "flp9" },     ParameterizedSwitch.FileLoggerParameters9,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["consoleloggerparameters", "clp"],    ParameterizedSwitch.ConsoleLoggerParameters,    null,                           false,          "MissingConsoleLoggerParameterError",  true,   false,   "HelpMessage_13_ConsoleLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["nodemode", "nmode"],                 ParameterizedSwitch.NodeMode,                   null,                           false,          null,                                  false,  false,   null),
+            new ParameterizedSwitchInfo(  ["maxcpucount", "m"],                  ParameterizedSwitch.MaxCPUCount,                null,                           false,          "MissingMaxCPUCountError",             true,   false,   "HelpMessage_17_MaximumCPUSwitch"),
+            new ParameterizedSwitchInfo(  ["ignoreprojectextensions", "ignore"], ParameterizedSwitch.IgnoreProjectExtensions,    null,                           true,           "MissingIgnoreProjectExtensionsError", true,   false,   "HelpMessage_19_IgnoreProjectExtensionsSwitch"),
+            new ParameterizedSwitchInfo(  ["toolsversion","tv"],                 ParameterizedSwitch.ToolsVersion,               null,                           false,          "MissingToolsVersionError",            true,   false,   "HelpMessage_23_ToolsVersionSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters", "flp"],       ParameterizedSwitch.FileLoggerParameters,       null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters1", "flp1"],     ParameterizedSwitch.FileLoggerParameters1,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters2", "flp2"],     ParameterizedSwitch.FileLoggerParameters2,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters3", "flp3"],     ParameterizedSwitch.FileLoggerParameters3,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters4", "flp4"],     ParameterizedSwitch.FileLoggerParameters4,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters5", "flp5"],     ParameterizedSwitch.FileLoggerParameters5,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters6", "flp6"],     ParameterizedSwitch.FileLoggerParameters6,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters7", "flp7"],     ParameterizedSwitch.FileLoggerParameters7,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters8", "flp8"],     ParameterizedSwitch.FileLoggerParameters8,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["fileloggerparameters9", "flp9"],     ParameterizedSwitch.FileLoggerParameters9,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
             // To not break existing use, keep supporting live logger switches
-            new ParameterizedSwitchInfo(  new string[] { "livelogger", "ll", "terminallogger", "tl" }, ParameterizedSwitch.TerminalLogger,      null,                           true,           null,                                  true,   true,    "HelpMessage_47_TerminalLoggerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "terminalloggerparameters", "tlp" },   ParameterizedSwitch.TerminalLoggerParameters,   null,                           false,          "MissingTerminalLoggerParameterError", true,   false,   "HelpMessage_48_TerminalLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  ["livelogger", "ll", "terminallogger", "tl"], ParameterizedSwitch.TerminalLogger,      null,                           true,           null,                                  true,   true,    "HelpMessage_47_TerminalLoggerSwitch"),
+            new ParameterizedSwitchInfo(  ["terminalloggerparameters", "tlp"],   ParameterizedSwitch.TerminalLoggerParameters,   null,                           false,          "MissingTerminalLoggerParameterError", true,   false,   "HelpMessage_48_TerminalLoggerParametersSwitch"),
 #if FEATURE_NODE_REUSE
-            new ParameterizedSwitchInfo(  new string[] { "nodereuse", "nr" },                   ParameterizedSwitch.NodeReuse,                  null,                           false,          "MissingNodeReuseParameterError",      true,   false,   "HelpMessage_24_NodeReuse"),
+            new ParameterizedSwitchInfo(  ["nodereuse", "nr"],                   ParameterizedSwitch.NodeReuse,                  null,                           false,          "MissingNodeReuseParameterError",      true,   false,   "HelpMessage_24_NodeReuse"),
 #endif
-            new ParameterizedSwitchInfo(  new string[] { "preprocess", "pp" },                  ParameterizedSwitch.Preprocess,                 null,                           false,          null,                                  true,   false,   "HelpMessage_25_PreprocessSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "targets", "ts" },                     ParameterizedSwitch.Targets,                    null,                           false,          null,                                  true,   false,   "HelpMessage_38_TargetsSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "warnaserror", "err" },                ParameterizedSwitch.WarningsAsErrors,           null,                           true,           null,                                  true,   true,    "HelpMessage_28_WarnAsErrorSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "warnnotaserror", "noerr" },           ParameterizedSwitch.WarningsNotAsErrors,        null,                           true,           "MissingWarnNotAsErrorParameterError", true,   false,   "HelpMessage_40_WarnNotAsErrorSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "warnasmessage", "nowarn" },           ParameterizedSwitch.WarningsAsMessages,         null,                           true,           "MissingWarnAsMessageParameterError",  true,   false,   "HelpMessage_29_WarnAsMessageSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "binarylogger", "bl" },                ParameterizedSwitch.BinaryLogger,               null,                           false,          null,                                  true,   false,   "HelpMessage_30_BinaryLoggerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "check", },                            ParameterizedSwitch.Check,                      null,                           false,          null,                                  true,   false,   null),
-            new ParameterizedSwitchInfo(  new string[] { "restore", "r" },                      ParameterizedSwitch.Restore,                    null,                           false,          null,                                  true,   false,   "HelpMessage_31_RestoreSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "profileevaluation", "prof" },         ParameterizedSwitch.ProfileEvaluation,          null,                           false,          "MissingProfileParameterError",        true,   false,   "HelpMessage_32_ProfilerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "restoreproperty", "rp" },             ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_33_RestorePropertySwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "interactive" },                       ParameterizedSwitch.Interactive,                null,                           false,          null,                                  true,   false,   "HelpMessage_34_InteractiveSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "isolateprojects", "isolate" },        ParameterizedSwitch.IsolateProjects,            null,                           false,          null,                                  true,   false,   "HelpMessage_35_IsolateProjectsSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "graphbuild", "graph" },               ParameterizedSwitch.GraphBuild,                 null,                           true,           null,                                  true,   false,   "HelpMessage_36_GraphBuildSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "inputResultsCaches", "irc" },         ParameterizedSwitch.InputResultsCaches,         null,                           true,           null,                                  true,   true,    "HelpMessage_InputCachesFiles"),
-            new ParameterizedSwitchInfo(  new string[] { "outputResultsCache", "orc" },         ParameterizedSwitch.OutputResultsCache,         "DuplicateOutputResultsCache",  false,          null,                                  true,   true,    "HelpMessage_OutputCacheFile"),
+            new ParameterizedSwitchInfo(  ["preprocess", "pp"],                  ParameterizedSwitch.Preprocess,                 null,                           false,          null,                                  true,   false,   "HelpMessage_25_PreprocessSwitch"),
+            new ParameterizedSwitchInfo(  ["targets", "ts"],                     ParameterizedSwitch.Targets,                    null,                           false,          null,                                  true,   false,   "HelpMessage_38_TargetsSwitch"),
+            new ParameterizedSwitchInfo(  ["warnaserror", "err"],                ParameterizedSwitch.WarningsAsErrors,           null,                           true,           null,                                  true,   true,    "HelpMessage_28_WarnAsErrorSwitch"),
+            new ParameterizedSwitchInfo(  ["warnnotaserror", "noerr"],           ParameterizedSwitch.WarningsNotAsErrors,        null,                           true,           "MissingWarnNotAsErrorParameterError", true,   false,   "HelpMessage_40_WarnNotAsErrorSwitch"),
+            new ParameterizedSwitchInfo(  ["warnasmessage", "nowarn"],           ParameterizedSwitch.WarningsAsMessages,         null,                           true,           "MissingWarnAsMessageParameterError",  true,   false,   "HelpMessage_29_WarnAsMessageSwitch"),
+            new ParameterizedSwitchInfo(  ["binarylogger", "bl"],                ParameterizedSwitch.BinaryLogger,               null,                           false,          null,                                  true,   false,   "HelpMessage_30_BinaryLoggerSwitch"),
+            new ParameterizedSwitchInfo(  ["check"],                             ParameterizedSwitch.Check,                      null,                           false,          null,                                  true,   false,   "HelpMessage_52_BuildCheckSwitch"),
+            new ParameterizedSwitchInfo(  ["restore", "r"],                      ParameterizedSwitch.Restore,                    null,                           false,          null,                                  true,   false,   "HelpMessage_31_RestoreSwitch"),
+            new ParameterizedSwitchInfo(  ["profileevaluation", "prof"],         ParameterizedSwitch.ProfileEvaluation,          null,                           false,          "MissingProfileParameterError",        true,   false,   "HelpMessage_32_ProfilerSwitch"),
+            new ParameterizedSwitchInfo(  ["restoreproperty", "rp"],             ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_33_RestorePropertySwitch"),
+            new ParameterizedSwitchInfo(  ["interactive"],                       ParameterizedSwitch.Interactive,                null,                           false,          null,                                  true,   false,   "HelpMessage_34_InteractiveSwitch"),
+            new ParameterizedSwitchInfo(  ["isolateprojects", "isolate"],        ParameterizedSwitch.IsolateProjects,            null,                           false,          null,                                  true,   false,   "HelpMessage_35_IsolateProjectsSwitch"),
+            new ParameterizedSwitchInfo(  ["graphbuild", "graph"],               ParameterizedSwitch.GraphBuild,                 null,                           true,           null,                                  true,   false,   "HelpMessage_36_GraphBuildSwitch"),
+            new ParameterizedSwitchInfo(  ["inputResultsCaches", "irc"],         ParameterizedSwitch.InputResultsCaches,         null,                           true,           null,                                  true,   true,    "HelpMessage_InputCachesFiles"),
+            new ParameterizedSwitchInfo(  ["outputResultsCache", "orc"],         ParameterizedSwitch.OutputResultsCache,         "DuplicateOutputResultsCache",  false,          null,                                  true,   true,    "HelpMessage_OutputCacheFile"),
 #if FEATURE_REPORTFILEACCESSES
-            new ParameterizedSwitchInfo(  new string[] { "reportfileaccesses" },                ParameterizedSwitch.ReportFileAccesses,         null,                           false,          null,                                  true,   false,   "HelpMessage_42_ReportFileAccessesSwitch"),
+            new ParameterizedSwitchInfo(  ["reportfileaccesses"],                ParameterizedSwitch.ReportFileAccesses,         null,                           false,          null,                                  true,   false,   "HelpMessage_42_ReportFileAccessesSwitch"),
 #endif
-            new ParameterizedSwitchInfo(  new string[] { "lowpriority", "low" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false,   "HelpMessage_39_LowPrioritySwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "question", "q" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false,   "HelpMessage_41_QuestionSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "detailedsummary", "ds" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false,   "HelpMessage_26_DetailedSummarySwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "getProperty" },                       ParameterizedSwitch.GetProperty,                null,                           true,           "MissingGetPropertyError",             true,   false,   "HelpMessage_43_GetPropertySwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "getItem" },                           ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",                 true,   false,   "HelpMessage_44_GetItemSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "getTargetResult" },                   ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",         true,   false,   "HelpMessage_45_GetTargetResultSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "getResultOutputFile" },               ParameterizedSwitch.GetResultOutputFile,        null,                           true,           "MissingGetResultFileError",           true,   false,   "HelpMessage_51_GetResultOutputFileSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "featureAvailability", "fa" },         ParameterizedSwitch.FeatureAvailability,        null,                           true,           "MissingFeatureAvailabilityError",     true,   false,   "HelpMessage_46_FeatureAvailabilitySwitch")
+            new ParameterizedSwitchInfo(  ["lowpriority", "low"],                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false,   "HelpMessage_39_LowPrioritySwitch"),
+            new ParameterizedSwitchInfo(  ["question", "q"],                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false,   "HelpMessage_41_QuestionSwitch"),
+            new ParameterizedSwitchInfo(  ["detailedsummary", "ds"],             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false,   "HelpMessage_26_DetailedSummarySwitch"),
+            new ParameterizedSwitchInfo(  ["getProperty"],                       ParameterizedSwitch.GetProperty,                null,                           true,           "MissingGetPropertyError",             true,   false,   "HelpMessage_43_GetPropertySwitch"),
+            new ParameterizedSwitchInfo(  ["getItem"],                           ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",                 true,   false,   "HelpMessage_44_GetItemSwitch"),
+            new ParameterizedSwitchInfo(  ["getTargetResult"],                   ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",         true,   false,   "HelpMessage_45_GetTargetResultSwitch"),
+            new ParameterizedSwitchInfo(  ["getResultOutputFile"],               ParameterizedSwitch.GetResultOutputFile,        null,                           true,           "MissingGetResultFileError",           true,   false,   "HelpMessage_51_GetResultOutputFileSwitch"),
+            new ParameterizedSwitchInfo(  ["featureAvailability", "fa"],         ParameterizedSwitch.FeatureAvailability,        null,                           true,           "MissingFeatureAvailabilityError",     true,   false,   "HelpMessage_46_FeatureAvailabilitySwitch")
         };
 
         /// <summary>
@@ -651,7 +651,7 @@ internal bool IsParameterizedSwitchSet(ParameterizedSwitch parameterizedSwitch)
         }
 
         // used to indicate a null parameter list for a switch
-        private static readonly string[] s_noParameters = Array.Empty<string>();
+        private static readonly string[] s_noParameters = [];
 
         /// <summary>
         /// Gets the parameters (if any) detected on the command line for the given parameterized switch.
@@ -745,7 +745,7 @@ private string[] GetSpecificFileLoggerParameters(ParameterlessSwitch parameterle
             }
             else if (IsParameterlessSwitchSet(parameterlessSwitch))
             {
-                result = Array.Empty<string>();
+                result = [];
             }
 
             return result;
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index b84cdc9dcd6..2ce4c96e4bf 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -17,7 +17,7 @@
     <!-- Set RuntimeIdentifiers so that NuGet will restore for both AnyCPU as well as x86 and x64.
          This is important for the MSBuild.VSSetup project, which "references" both the x86 and x64
          versions of this project -->
-    <RuntimeIdentifiers Condition="'$(DotNetBuildFromSource)' != 'true'">win7-x86;win7-x64</RuntimeIdentifiers>
+    <RuntimeIdentifiers Condition="'$(DotNetBuildSourceOnly)' != 'true'">win7-x86;win7-x64</RuntimeIdentifiers>
     <UseRidGraph>true</UseRidGraph>
 
     <EnableDefaultItems>false</EnableDefaultItems>
@@ -191,7 +191,7 @@
     <Reference Include="System.Xml" />
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
   </ItemGroup>
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework' AND '$(DotNetBuildFromSource)' != 'true'">
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework' AND '$(DotNetBuildSourceOnly)' != 'true'">
     <!-- Bump these to the latest version despite transitive references to older -->
     <PackageReference Include="System.Private.Uri" PrivateAssets="all" />
   </ItemGroup>
diff --git a/src/MSBuild/MSBuild.ico b/src/MSBuild/MSBuild.ico
index 69d0069cb74..f70202a070e 100644
Binary files a/src/MSBuild/MSBuild.ico and b/src/MSBuild/MSBuild.ico differ
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
index 2cd1b34f072..d3502c8befd 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
@@ -125,7 +125,7 @@ internal OutOfProcTaskHostTaskResult ExecuteTask(
                                 TaskCompleteType.CrashedDuringInitialization,
                                 exceptionToReturn,
                                 "TaskInstantiationFailureError",
-                                new string[] { taskName, taskLocation, String.Empty });
+                                [taskName, taskLocation, String.Empty]);
             }
 
             OutOfProcTaskHostTaskResult taskResult;
@@ -142,7 +142,7 @@ internal OutOfProcTaskHostTaskResult ExecuteTask(
                                                     TaskCompleteType.CrashedDuringInitialization,
                                                     null,
                                                     "TaskInstantiationFailureNotSupported",
-                                                    new string[] { taskName, taskLocation, typeof(RunInSTAAttribute).FullName });
+                                                    [taskName, taskLocation, typeof(RunInSTAAttribute).FullName]);
 #endif
             }
             else
@@ -318,7 +318,7 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
                     TaskCompleteType.CrashedDuringInitialization,
                     exceptionToReturn,
                     "TaskInstantiationFailureError",
-                    new string[] { taskName, taskLocation, String.Empty });
+                    [taskName, taskLocation, String.Empty]);
             }
 
             foreach (KeyValuePair<string, TaskParameter> param in taskParams)
@@ -335,7 +335,7 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask(
                                 // If it's a TargetInvocationException, we only care about the contents of the inner exception, so save that instead.
                                 e is TargetInvocationException ? e.InnerException : e,
                                 "InvalidTaskAttributeError",
-                                new string[] { param.Key, param.Value.ToString(), taskName });
+                                [param.Key, param.Value.ToString(), taskName]);
                 }
             }
 
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 00b1333080b..02d83eca1c6 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -644,7 +644,7 @@ public NodeEngineShutdownReason Run(out Exception shutdownException)
             _nodeEndpoint.OnLinkStatusChanged += new LinkStatusChangedDelegate(OnLinkStatusChanged);
             _nodeEndpoint.Listen(this);
 
-            WaitHandle[] waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent, _taskCompleteEvent, _taskCancelledEvent };
+            WaitHandle[] waitHandles = [_shutdownEvent, _packetReceivedEvent, _taskCompleteEvent, _taskCancelledEvent];
 
             while (true)
             {
diff --git a/src/MSBuild/PerformanceLogEventListener.cs b/src/MSBuild/PerformanceLogEventListener.cs
index 4aaa1283384..3eb6090cd4b 100644
--- a/src/MSBuild/PerformanceLogEventListener.cs
+++ b/src/MSBuild/PerformanceLogEventListener.cs
@@ -22,15 +22,15 @@ internal struct ProviderConfiguration
             internal EventLevel Level { get; set; }
         }
 
-        private static ProviderConfiguration[] s_config = new ProviderConfiguration[]
-        {
+        private static ProviderConfiguration[] s_config =
+        [
             new ProviderConfiguration()
             {
                 Name = "Microsoft-Build",
                 Keywords = MSBuildEventSource.Keywords.PerformanceLog,
                 Level = EventLevel.Verbose
             }
-        };
+        ];
 
         private const string PerfLogDirEnvVar = "DOTNET_PERFLOG_DIR";
         private const char EventDelimiter = '\n';
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 68f434f2df4..09887958d88 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -1016,6 +1016,17 @@
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </comment>
   </data>
+  <data name="HelpMessage_52_BuildCheckSwitch" Visibility="Public">
+    <value>  -check
+                     Enables BuildChecks during the build.
+                     BuildCheck enables evaluating rules to ensure properties 
+                     of the build. For more info see aka.ms/buildcheck
+	</value>
+	<comment>
+    {Locked="-check"}{Locked="BuildChecks"}{Locked="BuildCheck"}
+    LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+  </comment>
+  </data>
   <data name="HelpMessage_48_TerminalLoggerParametersSwitch" Visibility="Public">
     <value>  -terminalLoggerParameters: &lt;parameters&gt;
                      Parameters to terminal logger. (Short form: -tlp)
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index c1098a721df..0ac4e5b2af1 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -312,6 +312,22 @@
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_52_BuildCheckSwitch">
+        <source>  -check
+                     Enables BuildChecks during the build.
+                     BuildCheck enables evaluating rules to ensure properties 
+                     of the build. For more info see aka.ms/buildcheck
+	</source>
+        <target state="translated">  -check
+                     Povolí během sestavení BuildChecks.
+                     BuildCheck umožňuje vyhodnocovat pravidla, aby se zajistily vlastnosti 
+                     sestavení. Další informace viz aka.ms/buildcheck
+	</target>
+        <note>
+    {Locked="-check"}{Locked="BuildChecks"}{Locked="BuildCheck"}
+    LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+  </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
         <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
@@ -1819,22 +1835,22 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
       </trans-unit>
       <trans-unit id="SAC">
         <source>Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</source>
-        <target state="new">Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</target>
+        <target state="translated">Založeno na klíči registru Windows VerifiedAndReputablePolicyState, stav SAC = {0}.</target>
         <note>"Windows" is the OS, SAC is the Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Enforcement">
         <source>1: in enforcement</source>
-        <target state="new">1: in enforcement</target>
+        <target state="translated">1: Vynucuje se.</target>
         <note />
       </trans-unit>
       <trans-unit id="SAC_Evaluation">
         <source>2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</source>
-        <target state="new">2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</target>
+        <target state="translated">2: Vyhodnocuje se. Ve vývojovém prostředí se doporučuje vypnout funkci Inteligentní řízení aplikací, protože by mohla mít negativní dopad na výkon.</target>
         <note>Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Off">
         <source>0: turned off</source>
-        <target state="new">0: turned off</target>
+        <target state="translated">0: Vypnuto.</target>
         <note />
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 7ab8f892a35..0bd566b08c0 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -312,6 +312,22 @@
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_52_BuildCheckSwitch">
+        <source>  -check
+                     Enables BuildChecks during the build.
+                     BuildCheck enables evaluating rules to ensure properties 
+                     of the build. For more info see aka.ms/buildcheck
+	</source>
+        <target state="translated">  -check
+                     Aktiviert BuildChecks während des Builds.
+                     BuildCheck ermöglicht die Regelauswertung, um Eigenschaften 
+                     des Builds sicherzustellen. Weitere Infos: aka.ms/buildcheck
+	</target>
+        <note>
+    {Locked="-check"}{Locked="BuildChecks"}{Locked="BuildCheck"}
+    LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+  </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
         <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
@@ -1807,22 +1823,22 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
       </trans-unit>
       <trans-unit id="SAC">
         <source>Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</source>
-        <target state="new">Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</target>
+        <target state="translated">Basierend auf dem Windows-Registrierungsschlüssel „VerifiedAndReputablePolicyState“, SAC-Status = {0}.</target>
         <note>"Windows" is the OS, SAC is the Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Enforcement">
         <source>1: in enforcement</source>
-        <target state="new">1: in enforcement</target>
+        <target state="translated">1: bei der Erzwingung</target>
         <note />
       </trans-unit>
       <trans-unit id="SAC_Evaluation">
         <source>2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</source>
-        <target state="new">2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</target>
+        <target state="translated">2: in Auswertung. Es wird empfohlen, Smart App Control in der Entwicklungsumgebung zu deaktivieren, da andernfalls die Leistung beeinträchtigt werden könnte.</target>
         <note>Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Off">
         <source>0: turned off</source>
-        <target state="new">0: turned off</target>
+        <target state="translated">0: deaktiviert</target>
         <note />
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index ce11f6b9660..0772f58c6ef 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -311,6 +311,22 @@ Esta marca es experimental y puede que no funcione según lo previsto.
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_52_BuildCheckSwitch">
+        <source>  -check
+                     Enables BuildChecks during the build.
+                     BuildCheck enables evaluating rules to ensure properties 
+                     of the build. For more info see aka.ms/buildcheck
+	</source>
+        <target state="translated">  -check
+                     Habilita BuildChecks durante la compilación.
+                     BuildCheck permite evaluar reglas para garantizar que las propiedades 
+                     de la compilación. Para obtener más información, consulte aka.ms/buildcheck
+	</target>
+        <note>
+    {Locked="-check"}{Locked="BuildChecks"}{Locked="BuildCheck"}
+    LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+  </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
         <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
@@ -1813,22 +1829,22 @@ Esta marca es experimental y puede que no funcione según lo previsto.
       </trans-unit>
       <trans-unit id="SAC">
         <source>Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</source>
-        <target state="new">Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</target>
+        <target state="translated">Según la clave del Registro de Windows VerifiedAndReputablePolicyState, estado SAC = {0}.</target>
         <note>"Windows" is the OS, SAC is the Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Enforcement">
         <source>1: in enforcement</source>
-        <target state="new">1: in enforcement</target>
+        <target state="translated">1: en cumplimiento</target>
         <note />
       </trans-unit>
       <trans-unit id="SAC_Evaluation">
         <source>2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</source>
-        <target state="new">2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</target>
+        <target state="translated">2: en evaluación. Se recomienda desactivar el Control Inteligente de Aplicaciones en el entorno de desarrollo ya que, de lo contrario, el rendimiento podría verse afectado.</target>
         <note>Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Off">
         <source>0: turned off</source>
-        <target state="new">0: turned off</target>
+        <target state="translated">0: desactivado</target>
         <note />
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index cb4e97a06c8..53e83e8352b 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -312,6 +312,22 @@ futures
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_52_BuildCheckSwitch">
+        <source>  -check
+                     Enables BuildChecks during the build.
+                     BuildCheck enables evaluating rules to ensure properties 
+                     of the build. For more info see aka.ms/buildcheck
+	</source>
+        <target state="translated">  -check
+                     Active BuildChecks pendant la construction.
+                     BuildCheck permet d'évaluer les règles pour garantir les propriétés 
+                     de la construction. Pour plus d'informations, consultez aka.ms/buildcheck
+	</target>
+        <note>
+    {Locked="-check"}{Locked="BuildChecks"}{Locked="BuildCheck"}
+    LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+  </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
         <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
@@ -1807,22 +1823,22 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
       </trans-unit>
       <trans-unit id="SAC">
         <source>Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</source>
-        <target state="new">Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</target>
+        <target state="translated">Basé sur la clé de Registre Windows VerifiedAndReputablePolicyState, état SAC = {0}.</target>
         <note>"Windows" is the OS, SAC is the Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Enforcement">
         <source>1: in enforcement</source>
-        <target state="new">1: in enforcement</target>
+        <target state="translated">1 : mise en œuvre</target>
         <note />
       </trans-unit>
       <trans-unit id="SAC_Evaluation">
         <source>2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</source>
-        <target state="new">2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</target>
+        <target state="translated">2 : en évaluation Il est recommandé de désactiver smart App Control dans l’environnement de développement, car les performances risquent d’être affectées dans le cas contraire</target>
         <note>Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Off">
         <source>0: turned off</source>
-        <target state="new">0: turned off</target>
+        <target state="translated">0 : désactivé</target>
         <note />
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 64d7a0455b5..39f96bd265d 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -312,6 +312,22 @@ Questo flag è sperimentale e potrebbe non funzionare come previsto.
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_52_BuildCheckSwitch">
+        <source>  -check
+                     Enables BuildChecks during the build.
+                     BuildCheck enables evaluating rules to ensure properties 
+                     of the build. For more info see aka.ms/buildcheck
+	</source>
+        <target state="translated">  -check
+                     Abilita BuildChecks durante la compilazione.
+                     BuildCheck consente di valutare le regole per garantire le proprietà 
+                     della compilazione. Per altre informazioni, vedere aka.ms/buildcheck
+	</target>
+        <note>
+    {Locked="-check"}{Locked="BuildChecks"}{Locked="BuildCheck"}
+    LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+  </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
         <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
@@ -1818,22 +1834,22 @@ Nota: livello di dettaglio dei logger di file
       </trans-unit>
       <trans-unit id="SAC">
         <source>Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</source>
-        <target state="new">Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</target>
+        <target state="translated">In base alla chiave del Registro di sistema di Windows VerifiedAndReputablePolicyState, stato SAC = {0}.</target>
         <note>"Windows" is the OS, SAC is the Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Enforcement">
         <source>1: in enforcement</source>
-        <target state="new">1: in enforcement</target>
+        <target state="translated">1: in imposizione</target>
         <note />
       </trans-unit>
       <trans-unit id="SAC_Evaluation">
         <source>2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</source>
-        <target state="new">2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</target>
+        <target state="translated">2: in valutazione. È consigliabile disattivare Il Controllo intelligente delle app nell'ambiente di sviluppo perché in caso contrario le prestazioni potrebbero essere compromesse</target>
         <note>Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Off">
         <source>0: turned off</source>
-        <target state="new">0: turned off</target>
+        <target state="translated">0: disattivato</target>
         <note />
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index a7ff8a0a22b..b374332191a 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -312,6 +312,23 @@
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_52_BuildCheckSwitch">
+        <source>  -check
+                     Enables BuildChecks during the build.
+                     BuildCheck enables evaluating rules to ensure properties 
+                     of the build. For more info see aka.ms/buildcheck
+	</source>
+        <target state="translated">  -check
+                     ビルド中に BuildChecks を有効にします。
+                     BuildCheck を使用すると、ビルドのプロパティ 
+ を保証するための
+                     ルールを評価できます。詳細については、aka.ms/buildcheck を参照してください
+	</target>
+        <note>
+    {Locked="-check"}{Locked="BuildChecks"}{Locked="BuildCheck"}
+    LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+  </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
         <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
@@ -1807,22 +1824,22 @@
       </trans-unit>
       <trans-unit id="SAC">
         <source>Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</source>
-        <target state="new">Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</target>
+        <target state="translated">Windows レジストリ キー VerifiedAndReputablePolicyState に基づいて、SAC 状態 = {0}。</target>
         <note>"Windows" is the OS, SAC is the Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Enforcement">
         <source>1: in enforcement</source>
-        <target state="new">1: in enforcement</target>
+        <target state="translated">1: 実施中</target>
         <note />
       </trans-unit>
       <trans-unit id="SAC_Evaluation">
         <source>2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</source>
-        <target state="new">2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</target>
+        <target state="translated">2: 評価中。開発環境では、パフォーマンスに影響が出る可能性があるため、スマート アプリ コントロールをオフにすることをお勧めします。</target>
         <note>Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Off">
         <source>0: turned off</source>
-        <target state="new">0: turned off</target>
+        <target state="translated">0: オフ</target>
         <note />
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 630cc8baaf1..841e6e88e24 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -312,6 +312,22 @@
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_52_BuildCheckSwitch">
+        <source>  -check
+                     Enables BuildChecks during the build.
+                     BuildCheck enables evaluating rules to ensure properties 
+                     of the build. For more info see aka.ms/buildcheck
+	</source>
+        <target state="translated">  -check
+                     빌드하는 동안 BuildChecks를 사용하도록 설정합니다.
+                     BuildCheck를 사용하면 규칙을 평가하여 빌드의 속성을 
+                     확인할 수 있습니다. 자세한 내용은 aka.ms/buildcheck를 참조하세요.
+	</target>
+        <note>
+    {Locked="-check"}{Locked="BuildChecks"}{Locked="BuildCheck"}
+    LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+  </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
         <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
@@ -1807,22 +1823,22 @@
       </trans-unit>
       <trans-unit id="SAC">
         <source>Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</source>
-        <target state="new">Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</target>
+        <target state="translated">Windows 레지스트리 키 VerifiedAndReputablePolicyState에 따른 SAC 상태 = {0}.</target>
         <note>"Windows" is the OS, SAC is the Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Enforcement">
         <source>1: in enforcement</source>
-        <target state="new">1: in enforcement</target>
+        <target state="translated">1: 적용 중</target>
         <note />
       </trans-unit>
       <trans-unit id="SAC_Evaluation">
         <source>2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</source>
-        <target state="new">2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</target>
+        <target state="translated">2: 평가 중. 성능에 영향을 미칠 수 있으므로 개발 환경에서는 스마트 앱 컨트롤을 끄는 것이 좋습니다.</target>
         <note>Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Off">
         <source>0: turned off</source>
-        <target state="new">0: turned off</target>
+        <target state="translated">0: 꺼짐</target>
         <note />
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index d4aa816829a..6698f75f31b 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -311,6 +311,22 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_52_BuildCheckSwitch">
+        <source>  -check
+                     Enables BuildChecks during the build.
+                     BuildCheck enables evaluating rules to ensure properties 
+                     of the build. For more info see aka.ms/buildcheck
+	</source>
+        <target state="translated">  -check
+                     Włącza funkcję BuildChecks podczas kompilacji.
+                     Funkcja BuildCheck umożliwia ocenę reguł w celu zapewnienia właściwości 
+                     kompilacji. Aby uzyskać więcej informacji, zobacz aka.ms/buildcheck
+	</target>
+        <note>
+    {Locked="-check"}{Locked="BuildChecks"}{Locked="BuildCheck"}
+    LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+  </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
         <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
@@ -1817,22 +1833,22 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
       </trans-unit>
       <trans-unit id="SAC">
         <source>Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</source>
-        <target state="new">Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</target>
+        <target state="translated">Na podstawie klucza rejestru systemu Windows VerifiedAndReputablePolicyState, stan SAC = {0}.</target>
         <note>"Windows" is the OS, SAC is the Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Enforcement">
         <source>1: in enforcement</source>
-        <target state="new">1: in enforcement</target>
+        <target state="translated">1: w ramach wymuszania</target>
         <note />
       </trans-unit>
       <trans-unit id="SAC_Evaluation">
         <source>2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</source>
-        <target state="new">2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</target>
+        <target state="translated">2: w ocenie. Zaleca się wyłączenie usługi Inteligentna kontrola aplikacji w środowisku deweloperskim, ponieważ w przeciwnym razie może to wpłynąć na wydajność</target>
         <note>Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Off">
         <source>0: turned off</source>
-        <target state="new">0: turned off</target>
+        <target state="translated">0: wyłączone</target>
         <note />
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 40551221f3a..79df937a677 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -311,6 +311,22 @@
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_52_BuildCheckSwitch">
+        <source>  -check
+                     Enables BuildChecks during the build.
+                     BuildCheck enables evaluating rules to ensure properties 
+                     of the build. For more info see aka.ms/buildcheck
+	</source>
+        <target state="translated">  -check
+                     Habilita BuildChecks durante o build.
+                     BuildCheck habilita a avaliação de regras para garantir que as propriedades 
+                     do build. Para obter mais informações, confira aka.ms/buildcheck
+	</target>
+        <note>
+    {Locked="-check"}{Locked="BuildChecks"}{Locked="BuildCheck"}
+    LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+  </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
         <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
@@ -1807,22 +1823,22 @@ arquivo de resposta.
       </trans-unit>
       <trans-unit id="SAC">
         <source>Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</source>
-        <target state="new">Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</target>
+        <target state="translated">Com base na chave do Registro do Windows, VerifiedAndReputablePolicyState, estado SAC = {0}.</target>
         <note>"Windows" is the OS, SAC is the Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Enforcement">
         <source>1: in enforcement</source>
-        <target state="new">1: in enforcement</target>
+        <target state="translated">1: em imposição</target>
         <note />
       </trans-unit>
       <trans-unit id="SAC_Evaluation">
         <source>2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</source>
-        <target state="new">2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</target>
+        <target state="translated">2: em avaliação. É recomendável desativar o Controle Inteligente de Aplicativos no ambiente de desenvolvimento, pois, caso contrário, o desempenho poderá ser afetado</target>
         <note>Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Off">
         <source>0: turned off</source>
-        <target state="new">0: turned off</target>
+        <target state="translated">0: desativado</target>
         <note />
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 524af405340..768e078016e 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -311,6 +311,22 @@
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_52_BuildCheckSwitch">
+        <source>  -check
+                     Enables BuildChecks during the build.
+                     BuildCheck enables evaluating rules to ensure properties 
+                     of the build. For more info see aka.ms/buildcheck
+	</source>
+        <target state="translated">  -check
+                     Включает BuildChecks во время сборки.
+                     BuildCheck дает оценивать правила для проверки свойств 
+                     сборки. Дополнительные сведения см. на странице aka.ms/buildcheck
+	</target>
+        <note>
+    {Locked="-check"}{Locked="BuildChecks"}{Locked="BuildCheck"}
+    LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+  </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
         <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
@@ -324,7 +340,7 @@
       </trans-unit>
       <trans-unit id="InvalidTerminalLoggerValue">
         <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
-        <target state="new">MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</target>
+        <target state="translated">MSBUILD : error MSB1065: недопустимое значение регистратора терминала. Это должно быть одно из значений: "auto", "true" или "false". {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1065: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1805,22 +1821,22 @@
       </trans-unit>
       <trans-unit id="SAC">
         <source>Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</source>
-        <target state="new">Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</target>
+        <target state="translated">На основе раздела реестра Windows VerifiedAndReputablePolicyState, состояние SAC = {0}.</target>
         <note>"Windows" is the OS, SAC is the Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Enforcement">
         <source>1: in enforcement</source>
-        <target state="new">1: in enforcement</target>
+        <target state="translated">1: в состоянии принудительного применения</target>
         <note />
       </trans-unit>
       <trans-unit id="SAC_Evaluation">
         <source>2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</source>
-        <target state="new">2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</target>
+        <target state="translated">2: в процессе вычисления. Рекомендуется отключить Интеллектуальное управление приложениями в среде разработки. В противном случае может быть затронута производительность</target>
         <note>Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Off">
         <source>0: turned off</source>
-        <target state="new">0: turned off</target>
+        <target state="translated">0: отключено</target>
         <note />
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 3de65102c35..bec01683446 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -311,6 +311,23 @@
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_52_BuildCheckSwitch">
+        <source>  -check
+                     Enables BuildChecks during the build.
+                     BuildCheck enables evaluating rules to ensure properties 
+                     of the build. For more info see aka.ms/buildcheck
+	</source>
+        <target state="translated">  -check
+                     Derleme sırasında BuildChecks'i sağlar.
+                     BuildCheck, derleme özelliklerinin 
+ güvenliğini sağlamak için 
+                     kuralların değerlendirilmesini sağlar. Daha fazla bilgi için bkz. aka.ms/buildcheck
+	</target>
+        <note>
+    {Locked="-check"}{Locked="BuildChecks"}{Locked="BuildCheck"}
+    LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+  </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
         <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
@@ -1810,22 +1827,22 @@
       </trans-unit>
       <trans-unit id="SAC">
         <source>Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</source>
-        <target state="new">Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</target>
+        <target state="translated">Windows kayıt defteri anahtarı VerifiedAndReputablePolicyState'e göre SAC durumu = {0}.</target>
         <note>"Windows" is the OS, SAC is the Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Enforcement">
         <source>1: in enforcement</source>
-        <target state="new">1: in enforcement</target>
+        <target state="translated">1: zorlamada</target>
         <note />
       </trans-unit>
       <trans-unit id="SAC_Evaluation">
         <source>2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</source>
-        <target state="new">2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</target>
+        <target state="translated">2: değerlendirmede. Aksi takdirde performansın etkilenebileceği için geliştirme ortamında Akıllı Uygulama Denetimi’nin kapatılması önerilir</target>
         <note>Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Off">
         <source>0: turned off</source>
-        <target state="new">0: turned off</target>
+        <target state="translated">0: kapalı</target>
         <note />
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 23c95e3f5ec..c127b90e612 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -311,6 +311,22 @@
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_52_BuildCheckSwitch">
+        <source>  -check
+                     Enables BuildChecks during the build.
+                     BuildCheck enables evaluating rules to ensure properties 
+                     of the build. For more info see aka.ms/buildcheck
+	</source>
+        <target state="translated">  -check
+                     在生成中启用 BuildChecks。
+                     BuildCheck 允许评估规则以确保生成的
+                     属性。有关详细信息，请参阅 aka.ms/buildcheck
+	</target>
+        <note>
+    {Locked="-check"}{Locked="BuildChecks"}{Locked="BuildCheck"}
+    LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+  </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
         <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
@@ -1806,22 +1822,22 @@
       </trans-unit>
       <trans-unit id="SAC">
         <source>Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</source>
-        <target state="new">Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</target>
+        <target state="translated">基于 Windows 注册表项 VerifiedAndReputablePolicyState，SAC 状态 = {0}。</target>
         <note>"Windows" is the OS, SAC is the Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Enforcement">
         <source>1: in enforcement</source>
-        <target state="new">1: in enforcement</target>
+        <target state="translated">1: 强制中</target>
         <note />
       </trans-unit>
       <trans-unit id="SAC_Evaluation">
         <source>2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</source>
-        <target state="new">2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</target>
+        <target state="translated">2: 评估中。建议关闭开发环境中的智能应用控制，否则性能可能会受到影响</target>
         <note>Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Off">
         <source>0: turned off</source>
-        <target state="new">0: turned off</target>
+        <target state="translated">0: 已关闭</target>
         <note />
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 48afee5fcb9..7f1b2be29b3 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -312,6 +312,22 @@
       LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_52_BuildCheckSwitch">
+        <source>  -check
+                     Enables BuildChecks during the build.
+                     BuildCheck enables evaluating rules to ensure properties 
+                     of the build. For more info see aka.ms/buildcheck
+	</source>
+        <target state="translated">  -check
+                     在建置期間啟用 BuildChecks。
+                     BuildCheck 啟用評估規則以確保組建的 
+                     屬性。如需詳細資訊，請參閱 aka.ms/buildcheck
+	</target>
+        <note>
+    {Locked="-check"}{Locked="BuildChecks"}{Locked="BuildCheck"}
+    LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+  </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
         <source>MSBUILD : error MSB1064: Low priority value is not valid. {0}</source>
@@ -1807,22 +1823,22 @@
       </trans-unit>
       <trans-unit id="SAC">
         <source>Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</source>
-        <target state="new">Based on the Windows registry key VerifiedAndReputablePolicyState, SAC state = {0}.</target>
+        <target state="translated">根據 Windows 登錄機碼 VerifiedAndReputablePolicyState，SAC 狀態 = {0}。</target>
         <note>"Windows" is the OS, SAC is the Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Enforcement">
         <source>1: in enforcement</source>
-        <target state="new">1: in enforcement</target>
+        <target state="translated">1: 強制</target>
         <note />
       </trans-unit>
       <trans-unit id="SAC_Evaluation">
         <source>2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</source>
-        <target state="new">2: in evaluation. It is recommended to turn off Smart App Control in development environemnt as otherwise performance might be impacted</target>
+        <target state="translated">2: 評估中。建議關閉開發環境中的智慧型手機應用程式控制件，否則效能可能會受到影響</target>
         <note>Smart App Control, "VerifiedAndReputablePolicyState" should not be localized</note>
       </trans-unit>
       <trans-unit id="SAC_Off">
         <source>0: turned off</source>
-        <target state="new">0: turned off</target>
+        <target state="translated">0: 關閉</target>
         <note />
       </trans-unit>
       <trans-unit id="SchemaFileLocation">
diff --git a/src/MSBuild/TerminalLogger/TerminalLogger.cs b/src/MSBuild/TerminalLogger/TerminalLogger.cs
index bcae846e898..038ec536f6b 100644
--- a/src/MSBuild/TerminalLogger/TerminalLogger.cs
+++ b/src/MSBuild/TerminalLogger/TerminalLogger.cs
@@ -221,6 +221,8 @@ public ProjectContext(BuildEventContext context)
     /// </summary>
     private bool _showCommandLine = false;
 
+    private uint? _originalConsoleMode;
+
     /// <summary>
     /// Default constructor, used by the MSBuild logger infra.
     /// </summary>
@@ -263,6 +265,8 @@ public void Initialize(IEventSource eventSource, int nodeCount)
     /// <inheritdoc/>
     public void Initialize(IEventSource eventSource)
     {
+        (_, _, _originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
+
         ParseParameters();
 
         eventSource.BuildStarted += BuildStarted;
@@ -358,6 +362,8 @@ private bool TryApplyShowCommandLineParameter(string? parameterValue)
     /// <inheritdoc/>
     public void Shutdown()
     {
+        NativeMethodsShared.RestoreConsoleMode(_originalConsoleMode);
+
         _cts.Cancel();
         _refresher?.Join();
         Terminal.Dispose();
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 8411c5408ba..d850697a06f 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -43,6 +43,17 @@
 using SimpleErrorLogger = Microsoft.Build.Logging.SimpleErrorLogger.SimpleErrorLogger;
 using TerminalLogger = Microsoft.Build.Logging.TerminalLogger.TerminalLogger;
 
+#if NETFRAMEWORK
+// Use I/O operations from Microsoft.IO.Redist which is generally higher perf
+// and also works around https://github.com/dotnet/msbuild/issues/10540.
+// Unnecessary on .NET 6+ because the perf improvements are in-box there.
+using Microsoft.IO;
+using Directory = Microsoft.IO.Directory;
+using File = Microsoft.IO.File;
+using FileInfo = Microsoft.IO.FileInfo;
+using Path = Microsoft.IO.Path;
+#endif
+
 #nullable disable
 
 namespace Microsoft.Build.CommandLine
@@ -684,7 +695,7 @@ public static ExitType Execute(
                 // process the detected command line switches -- gather build information, take action on non-build switches, and
                 // check for non-trivial errors
                 string projectFile = null;
-                string[] targets = Array.Empty<string>();
+                string[] targets = [];
                 string toolsVersion = null;
                 Dictionary<string, string> globalProperties = null;
                 Dictionary<string, string> restoreProperties = null;
@@ -717,9 +728,9 @@ public static ExitType Execute(
                 string outputResultsCache = null;
                 bool question = false;
                 bool isBuildCheckEnabled = false;
-                string[] getProperty = Array.Empty<string>();
-                string[] getItem = Array.Empty<string>();
-                string[] getTargetResult = Array.Empty<string>();
+                string[] getProperty = [];
+                string[] getItem = [];
+                string[] getTargetResult = [];
                 string getResultOutputFile = string.Empty;
                 BuildResult result = null;
 #if FEATURE_REPORTFILEACCESSES
@@ -1569,7 +1580,7 @@ internal static bool BuildProject(
 
                                 if (graphBuildOptions != null)
                                 {
-                                    graphBuildRequest = new GraphBuildRequestData(new[] { new ProjectGraphEntryPoint(projectFile, globalProperties) }, targets, null, flags, graphBuildOptions);
+                                    graphBuildRequest = new GraphBuildRequestData([new ProjectGraphEntryPoint(projectFile, globalProperties)], targets, null, flags, graphBuildOptions);
                                 }
                                 else
                                 {
@@ -1854,7 +1865,7 @@ private static BuildResult ExecuteRestore(string projectFile, string toolsVersio
                 projectFile,
                 restoreGlobalProperties,
                 toolsVersion,
-                targetsToBuild: new[] { MSBuildConstants.RestoreTargetName },
+                targetsToBuild: [MSBuildConstants.RestoreTargetName],
                 hostServices: null,
                 flags: flags);
 
@@ -2648,9 +2659,9 @@ private static bool ProcessCommandLineSwitches(
                     targets = ProcessTargetSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Target]);
 
                     // If we are looking for the value of a specific property or item post-evaluation or a target post-build, figure that out now
-                    getProperty = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetProperty] ?? Array.Empty<string>();
-                    getItem = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetItem] ?? Array.Empty<string>();
-                    getTargetResult = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetTargetResult] ?? Array.Empty<string>();
+                    getProperty = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetProperty] ?? [];
+                    getItem = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetItem] ?? [];
+                    getTargetResult = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetTargetResult] ?? [];
                     getResultOutputFile = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetResultOutputFile].FirstOrDefault() ?? string.Empty;
 
                     bool minimizeStdOutOutput = getProperty.Length + getItem.Length + getTargetResult.Length > 0 && getResultOutputFile.Length == 0;
@@ -3251,7 +3262,7 @@ private static ISet<string> ProcessWarningRelatedSwitch(CommandLineSwitches comm
             ISet<string> warningSwitches = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             foreach (string code in parameters
-                .SelectMany(parameter => parameter?.Split(s_commaSemicolon, StringSplitOptions.RemoveEmptyEntries) ?? new string[] { null }))
+                .SelectMany(parameter => parameter?.Split(s_commaSemicolon, StringSplitOptions.RemoveEmptyEntries) ?? [null]))
             {
                 if (code == null)
                 {
@@ -3526,7 +3537,7 @@ internal static string ProcessProjectSwitch(
             if (projectFile == null)
             {
                 ValidateExtensions(projectsExtensionsToIgnore);
-                HashSet<string> extensionsToIgnore = new HashSet<string>(projectsExtensionsToIgnore ?? Array.Empty<string>(), StringComparer.OrdinalIgnoreCase);
+                HashSet<string> extensionsToIgnore = new HashSet<string>(projectsExtensionsToIgnore ?? [], StringComparer.OrdinalIgnoreCase);
                 // Get all files in the current directory that have a proj-like extension
                 string[] potentialProjectFiles = getFiles(projectDirectory ?? ".", "*.*proj");
                 List<string> actualProjectFiles = new List<string>();
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 330ab7d914e..7817604a16e 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -134,8 +134,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.4" newVersion="8.0.0.4" />
-          <codeBase version="8.0.0.4" href="..\System.Text.Json.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.5" newVersion="8.0.0.5" />
+          <codeBase version="8.0.0.5" href="..\System.Text.Json.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Channels" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -184,6 +184,17 @@
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis.Sdk" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
           <codeBase version="17.0.0.0" href="..\..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
         </dependentAssembly>
+
+        <!-- Redirects for SDK resolver components, see https://github.com/dotnet/msbuild/blob/main/documentation/NETFramework-NGEN.md#microsoftdotnetmsbuildsdkresolver for details -->
+        <qualifyAssembly partialName="Microsoft.DotNet.MSBuildSdkResolver" fullName="Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60" />
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.DotNet.MSBuildSdkResolver" culture="neutral" publicKeyToken="adb9793829ddae60" />
+          <codeBase version="8.0.100.0" href="..\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Microsoft.DotNet.MSBuildSdkResolver.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Deployment.DotNet.Releases" culture="neutral" publicKeyToken="31bf3856ad364e35" />
+          <codeBase version="2.0.0.0" href="..\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Microsoft.Deployment.DotNet.Releases.dll" />
+        </dependentAssembly>
       </assemblyBinding>
     </runtime>
     <!-- To define one or more new toolsets, add an 'msbuildToolsets' element in this file. -->
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 8372bfd8727..0931bf4a8ce 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -94,7 +94,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.4" newVersion="8.0.0.4" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.5" newVersion="8.0.0.5" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -137,6 +137,17 @@
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis.Sdk" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
           <codeBase version="17.0.0.0" href="..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
         </dependentAssembly>
+
+        <!-- Redirects for SDK resolver components, see https://github.com/dotnet/msbuild/blob/main/documentation/NETFramework-NGEN.md#microsoftdotnetmsbuildsdkresolver for details -->
+        <qualifyAssembly partialName="Microsoft.DotNet.MSBuildSdkResolver" fullName="Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60" />
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.DotNet.MSBuildSdkResolver" culture="neutral" publicKeyToken="adb9793829ddae60" />
+          <codeBase version="8.0.100.0" href=".\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Microsoft.DotNet.MSBuildSdkResolver.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Deployment.DotNet.Releases" culture="neutral" publicKeyToken="31bf3856ad364e35" />
+          <codeBase version="2.0.0.0" href=".\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Microsoft.Deployment.DotNet.Releases.dll" />
+        </dependentAssembly>
       </assemblyBinding>
     </runtime>
     <!-- To define one or more new toolsets, add an 'msbuildToolsets' element in this file. -->
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index db9503bd9e5..bca1b949230 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -13,7 +13,7 @@
     <!-- Set RuntimeIdentifiers so that NuGet will restore for both AnyCPU as well as x86 and x64.
          This is important for the MSBuild.VSSetup project, which "references" both the x86 and x64
          versions of this project -->
-    <RuntimeIdentifiers Condition="'$(DotNetBuildFromSource)' != 'true'">win7-x86;win7-x64</RuntimeIdentifiers>
+    <RuntimeIdentifiers Condition="'$(DotNetBuildSourceOnly)' != 'true'">win7-x86;win7-x64</RuntimeIdentifiers>
     <UseRidGraph>true</UseRidGraph>
 
     <EnableDefaultItems>false</EnableDefaultItems>
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
index 822af5c1a96..7990d261f93 100644
--- a/src/Shared/BinaryReaderExtensions.cs
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -22,9 +22,9 @@ internal static class BinaryReaderExtensions
 #if !TASKHOST
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
 #endif
-        public static int ReadOptionalInt32(this BinaryReader reader)
+        public static int? ReadOptionalInt32(this BinaryReader reader)
         {
-            return reader.ReadByte() == 0 ? 0 : reader.ReadInt32();
+            return reader.ReadByte() == 0 ? null : reader.ReadInt32();
         }
 
 #if !TASKHOST
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 314301eec05..d9d361df7ba 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -119,8 +119,8 @@ public override string ToString()
 
         public virtual int[] RetrieveHandshakeComponents()
         {
-            return new int[]
-            {
+            return
+            [
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(options),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor),
@@ -128,7 +128,7 @@ public virtual int[] RetrieveHandshakeComponents()
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId)
-            };
+            ];
         }
 
         public virtual string GetKey() => $"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}".ToString(CultureInfo.InvariantCulture);
@@ -152,15 +152,15 @@ internal ServerNodeHandshake(HandshakeOptions nodeType)
 
         public override int[] RetrieveHandshakeComponents()
         {
-            return new int[]
-            {
+            return
+            [
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(options),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild),
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate),
-            };
+            ];
         }
 
         public override string GetKey()
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index 27bdb7e93e3..c1e3d664d3e 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -119,7 +119,7 @@ private Assembly TryGetWellKnownAssembly(AssemblyLoadContext context, AssemblyNa
             // of the Microsoft.Build.* assembly.
             assemblyName.Version = _currentAssemblyVersion;
 
-            var searchPaths = new[] { Assembly.GetExecutingAssembly().Location };
+            string[] searchPaths = [Assembly.GetExecutingAssembly().Location];
             return TryResolveAssemblyFromPaths(context, assemblyName, searchPaths);
         }
 
@@ -145,14 +145,14 @@ private Assembly TryResolveAssembly(AssemblyLoadContext context, AssemblyName as
 
         private Assembly TryResolveAssemblyFromPaths(AssemblyLoadContext context, AssemblyName assemblyName, IEnumerable<string> searchPaths)
         {
-            foreach (var cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
+            foreach (string cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
                 // If no culture is specified, attempt to load directly from
                 // the known dependency paths.
                 ? new[] { string.Empty }
                 // Search for satellite assemblies in culture subdirectories
                 // of the assembly search directories, but fall back to the
                 // bare search directory if that fails.
-                : new[] { assemblyName.CultureName, string.Empty })
+                : [assemblyName.CultureName, string.Empty])
             {
                 foreach (var searchPath in searchPaths)
                 {
diff --git a/src/Shared/Debugging/PrintLineDebugger.cs b/src/Shared/Debugging/PrintLineDebugger.cs
index ea3b9735314..10afb6c4d4d 100644
--- a/src/Shared/Debugging/PrintLineDebugger.cs
+++ b/src/Shared/Debugging/PrintLineDebugger.cs
@@ -128,7 +128,7 @@ public void Log(
 #if DEBUG
             var writer = GetWriter();
 
-            writer?.Invoke(_id, CallsiteString(sourceFilePath, memberName, sourceLineNumber), new[] { message });
+            writer?.Invoke(_id, CallsiteString(sourceFilePath, memberName, sourceLineNumber), [message]);
 #endif
         }
 
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 43fb3d65d16..4cda8fc8a4e 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -231,7 +231,7 @@ private static IReadOnlyList<string> GetAccessibleFileSystemEntries(IFileSystem
                     ErrorUtilities.ThrowInternalError("Unexpected filesystem entity type.");
                     break;
             }
-            return Array.Empty<string>();
+            return [];
         }
 
         /// <summary>
@@ -266,7 +266,7 @@ private static IReadOnlyList<string> GetAccessibleFilesAndDirectories(IFileSyste
                 }
             }
 
-            return Array.Empty<string>();
+            return [];
         }
 
         /// <summary>
@@ -354,12 +354,12 @@ private static IReadOnlyList<string> GetAccessibleFiles(
             catch (System.Security.SecurityException)
             {
                 // For code access security.
-                return Array.Empty<string>();
+                return [];
             }
             catch (System.UnauthorizedAccessException)
             {
                 // For OS security.
-                return Array.Empty<string>();
+                return [];
             }
         }
 
@@ -410,12 +410,12 @@ private static IReadOnlyList<string> GetAccessibleDirectories(
             catch (System.Security.SecurityException)
             {
                 // For code access security.
-                return Array.Empty<string>();
+                return [];
             }
             catch (System.UnauthorizedAccessException)
             {
                 // For OS security.
-                return Array.Empty<string>();
+                return [];
             }
         }
 
@@ -1042,7 +1042,7 @@ private IEnumerable<string> GetFilesForStep(
         {
             if (!stepResult.ConsiderFiles)
             {
-                return Enumerable.Empty<string>();
+                return [];
             }
 
             // Back-compat hack: We don't use case-insensitive file enumeration I/O on Linux so the behavior is different depending
@@ -2340,18 +2340,18 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
                     // - maintain legacy behaviour where an illegal filespec is treated as a normal string
                     if (FileUtilities.PathsEqual(filespecUnescaped, excludeSpec))
                     {
-                        return Array.Empty<string>();
+                        return [];
                     }
 
                     var match = Default.FileMatch(excludeSpec, filespecUnescaped);
 
                     if (match.isLegalFileSpec && match.isMatch)
                     {
-                        return Array.Empty<string>();
+                        return [];
                     }
                 }
             }
-            return new[] { filespecUnescaped };
+            return [filespecUnescaped];
         }
 
         /// <summary>
@@ -2377,7 +2377,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
 
             if (action == SearchAction.ReturnEmptyList)
             {
-                return (Array.Empty<string>(), action, string.Empty);
+                return ([], action, string.Empty);
             }
             else if (action == SearchAction.ReturnFileSpec)
             {
@@ -2385,7 +2385,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
             }
             else if (action == SearchAction.FailOnDriveEnumeratingWildcard)
             {
-                return (Array.Empty<string>(), action, string.Empty);
+                return ([], action, string.Empty);
             }
             else if ((action != SearchAction.RunSearch) && (action != SearchAction.LogDriveEnumeratingWildcard))
             {
@@ -2430,7 +2430,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
                     }
                     else if (excludeAction == SearchAction.FailOnDriveEnumeratingWildcard)
                     {
-                        return (Array.Empty<string>(), excludeAction, excludeSpec);
+                        return ([], excludeAction, excludeSpec);
                     }
                     else if (excludeAction == SearchAction.LogDriveEnumeratingWildcard)
                     {
diff --git a/src/Shared/FileSystem/WindowsFileSystem.cs b/src/Shared/FileSystem/WindowsFileSystem.cs
index aa350505a0d..1493d0f29a8 100644
--- a/src/Shared/FileSystem/WindowsFileSystem.cs
+++ b/src/Shared/FileSystem/WindowsFileSystem.cs
@@ -60,7 +60,11 @@ public override bool DirectoryExists(string path)
 
         public override bool FileExists(string path)
         {
-            return NativeMethodsShared.FileExistsWindows(path);
+#if NETFRAMEWORK
+            return Microsoft.IO.File.Exists(path);
+#else
+            return File.Exists(path);
+#endif
         }
 
         public override bool FileOrDirectoryExists(string path)
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index fe1b7c6e2b0..d2d6108add8 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -91,27 +91,27 @@ public static bool GetIsFileSystemCaseSensitive()
         /// Copied from https://github.com/dotnet/corefx/blob/056715ff70e14712419d82d51c8c50c54b9ea795/src/Common/src/System/IO/PathInternal.Windows.cs#L61
         /// MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/dotnet/msbuild/issues/781#issuecomment-243942514
         /// </summary>
-        internal static readonly char[] InvalidPathChars = new char[]
-        {
+        internal static readonly char[] InvalidPathChars =
+        [
             '|', '\0',
             (char)1, (char)2, (char)3, (char)4, (char)5, (char)6, (char)7, (char)8, (char)9, (char)10,
             (char)11, (char)12, (char)13, (char)14, (char)15, (char)16, (char)17, (char)18, (char)19, (char)20,
             (char)21, (char)22, (char)23, (char)24, (char)25, (char)26, (char)27, (char)28, (char)29, (char)30,
             (char)31
-        };
+        ];
 
         /// <summary>
         /// Copied from https://github.com/dotnet/corefx/blob/387cf98c410bdca8fd195b28cbe53af578698f94/src/System.Runtime.Extensions/src/System/IO/Path.Windows.cs#L18
         /// MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/dotnet/msbuild/issues/781#issuecomment-243942514
         /// </summary>
-        internal static readonly char[] InvalidFileNameChars = new char[]
-        {
+        internal static readonly char[] InvalidFileNameChars =
+        [
             '\"', '<', '>', '|', '\0',
             (char)1, (char)2, (char)3, (char)4, (char)5, (char)6, (char)7, (char)8, (char)9, (char)10,
             (char)11, (char)12, (char)13, (char)14, (char)15, (char)16, (char)17, (char)18, (char)19, (char)20,
             (char)21, (char)22, (char)23, (char)24, (char)25, (char)26, (char)27, (char)28, (char)29, (char)30,
             (char)31, ':', '*', '?', '\\', '/'
-        };
+        ];
 
         internal static readonly char[] Slashes = { '/', '\\' };
 
@@ -361,7 +361,7 @@ internal static string TrimAndStripAnyQuotes(string path)
 
             // Trim returns the same string if trimming isn't needed
             path = path.Trim();
-            path = path.Trim(new char[] { '"' });
+            path = path.Trim(['"']);
 
             return path;
         }
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 51d551eef38..4107d4b4197 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -148,8 +148,8 @@ internal static class FrameworkLocationHelper
         /// <summary>
         /// List the supported .net versions.
         /// </summary>
-        private static DotNetFrameworkSpec[] DotNetFrameworkSpecs() => new DotNetFrameworkSpec[]
-        {
+        private static DotNetFrameworkSpec[] DotNetFrameworkSpecs() =>
+        [
             // v1.1
             new DotNetFrameworkSpecLegacy(
                 dotNetFrameworkVersion11,
@@ -223,7 +223,7 @@ internal static class FrameworkLocationHelper
 
             // v4.8.1
             CreateDotNetFrameworkSpecForV4(dotNetFrameworkVersion481, visualStudioVersion170),
-        };
+        ];
 
         /// <summary>
         /// List the supported visual studio versions.
@@ -231,30 +231,30 @@ internal static class FrameworkLocationHelper
         /// <remarks>
         /// The items must be ordered by the version, because some methods depend on that fact to find the previous visual studio version.
         /// </remarks>
-        private static readonly Lazy<VisualStudioSpec[]> VisualStudioSpecs = new(() => new VisualStudioSpec[]
-        {
+        private static readonly Lazy<VisualStudioSpec[]> VisualStudioSpecs = new(() =>
+        [
             // VS10
-            new VisualStudioSpec(visualStudioVersion100, "Windows\\v7.0A", null, null, new []
-            {
+            new VisualStudioSpec(visualStudioVersion100, "Windows\\v7.0A", null, null,
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
                 dotNetFrameworkVersion40,
-            }),
+            ]),
 
             // VS11
-            new VisualStudioSpec(visualStudioVersion110, "Windows\\v8.0A", "v8.0", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion110, "Windows\\v8.0A", "v8.0", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
                 dotNetFrameworkVersion40,
                 dotNetFrameworkVersion45,
-            }),
+            ]),
 
             // VS12
-            new VisualStudioSpec(visualStudioVersion120, "Windows\\v8.1A", "v8.1", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion120, "Windows\\v8.1A", "v8.1", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
@@ -262,11 +262,11 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion45,
                 dotNetFrameworkVersion451,
                 dotNetFrameworkVersion452,
-            }),
+            ]),
 
             // VS14
-            new VisualStudioSpec(visualStudioVersion140, "NETFXSDK\\{0}", "v8.1", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion140, "NETFXSDK\\{0}", "v8.1", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
@@ -276,11 +276,11 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion452,
                 dotNetFrameworkVersion46,
                 dotNetFrameworkVersion461,
-            }),
+            ]),
 
             // VS15
-            new VisualStudioSpec(visualStudioVersion150, "NETFXSDK\\{0}", "v8.1", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion150, "NETFXSDK\\{0}", "v8.1", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
@@ -295,11 +295,11 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion471,
                 dotNetFrameworkVersion472,
                 dotNetFrameworkVersion48,
-            }),
+            ]),
 
             // VS16
-            new VisualStudioSpec(visualStudioVersion160, "NETFXSDK\\{0}", "v10.0", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion160, "NETFXSDK\\{0}", "v10.0", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
@@ -314,11 +314,11 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion471,
                 dotNetFrameworkVersion472,
                 dotNetFrameworkVersion48,
-            }),
+            ]),
 
             // VS17
-            new VisualStudioSpec(visualStudioVersion170, "NETFXSDK\\{0}", "v10.0", "InstallationFolder", new []
-            {
+            new VisualStudioSpec(visualStudioVersion170, "NETFXSDK\\{0}", "v10.0", "InstallationFolder",
+            [
                 dotNetFrameworkVersion11,
                 dotNetFrameworkVersion20,
                 dotNetFrameworkVersion35,
@@ -334,8 +334,8 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion472,
                 dotNetFrameworkVersion48,
                 dotNetFrameworkVersion481,
-            }),
-        });
+            ]),
+        ]);
 
 #if FEATURE_WIN32_REGISTRY
         /// <summary>
diff --git a/src/Shared/IElementLocation.cs b/src/Shared/IElementLocation.cs
index 8ea57b003f3..4824e758d86 100644
--- a/src/Shared/IElementLocation.cs
+++ b/src/Shared/IElementLocation.cs
@@ -2,65 +2,11 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Shared
 {
     internal interface IElementLocation : IMSBuildElementLocation, ITranslatable { }
-
-    /// <summary>
-    /// Represents the location information for error reporting purposes.  This is normally used to
-    /// associate a run-time error with the original XML.
-    /// This is not used for arbitrary errors from tasks, which store location in a BuildXXXXEventArgs.
-    /// All implementations should be IMMUTABLE.
-    /// Any editing of the project XML through the MSBuild API's will invalidate locations in that XML until the XML is reloaded.
-    /// </summary>
-    /// <remarks>
-    /// This is currently internal - but it is prepared to be made public once it will be needed by other public BuildCheck OM
-    /// (e.g. by property read/write OM).
-    /// </remarks>
-    public interface IMSBuildElementLocation
-    {
-        /// <summary>
-        /// The file from which this particular element originated.  It may
-        /// differ from the ProjectFile if, for instance, it was part of
-        /// an import or originated in a targets file.
-        /// Should always have a value.
-        /// If not known, returns empty string.
-        /// </summary>
-        string File
-        {
-            get;
-        }
-
-        /// <summary>
-        /// The line number where this element exists in its file.
-        /// The first line is numbered 1.
-        /// Zero indicates "unknown location".
-        /// </summary>
-        int Line
-        {
-            get;
-        }
-
-        /// <summary>
-        /// The column number where this element exists in its file.
-        /// The first column is numbered 1.
-        /// Zero indicates "unknown location".
-        /// </summary>
-        int Column
-        {
-            get;
-        }
-
-        /// <summary>
-        /// The location in a form suitable for replacement
-        /// into a message.
-        /// </summary>
-        string LocationString
-        {
-            get;
-        }
-    }
 }
diff --git a/src/Shared/IMSBuildElementLocation.cs b/src/Shared/IMSBuildElementLocation.cs
new file mode 100644
index 00000000000..bd329f0580b
--- /dev/null
+++ b/src/Shared/IMSBuildElementLocation.cs
@@ -0,0 +1,56 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Shared
+{
+    /// <summary>
+    /// Represents the location information for error reporting purposes.  This is normally used to
+    /// associate a run-time error with the original XML.
+    /// This is not used for arbitrary errors from tasks, which store location in a BuildXXXXEventArgs.
+    /// All implementations should be IMMUTABLE.
+    /// Any editing of the project XML through the MSBuild API's will invalidate locations in that XML until the XML is reloaded.
+    /// </summary>
+    public interface IMSBuildElementLocation
+    {
+        /// <summary>
+        /// The file from which this particular element originated.  It may
+        /// differ from the ProjectFile if, for instance, it was part of
+        /// an import or originated in a targets file.
+        /// Should always have a value.
+        /// If not known, returns empty string.
+        /// </summary>
+        string File
+        {
+            get;
+        }
+
+        /// <summary>
+        /// The line number where this element exists in its file.
+        /// The first line is numbered 1.
+        /// Zero indicates "unknown location".
+        /// </summary>
+        int Line
+        {
+            get;
+        }
+
+        /// <summary>
+        /// The column number where this element exists in its file.
+        /// The first column is numbered 1.
+        /// Zero indicates "unknown location".
+        /// </summary>
+        int Column
+        {
+            get;
+        }
+
+        /// <summary>
+        /// The location in a form suitable for replacement
+        /// into a message.
+        /// </summary>
+        string LocationString
+        {
+            get;
+        }
+    }
+}
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 4caf4874652..650b62c2a1b 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -244,6 +244,11 @@ internal enum LoggingEventType : int
         /// Event is <see cref="BuildSubmissionStartedEventArgs"/>.
         /// </summary>
         BuildSubmissionStartedEvent = 40,
+
+        /// <summary>
+        /// Event is <see cref="BuildCanceledEventArgs"/>
+        /// </summary>
+        BuildCanceledEvent = 41,
     }
     #endregion
 
@@ -656,6 +661,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.BuildCheckTracingEvent => new BuildCheckTracingEventArgs(),
                 LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
                 LoggingEventType.BuildSubmissionStartedEvent => new BuildSubmissionStartedEventArgs(),
+                LoggingEventType.BuildCanceledEvent => new BuildCanceledEventArgs("Build canceled."),
 #endif
                 _ => throw new InternalErrorException("Should not get to the default of GetBuildEventArgFromId ID: " + _eventType)
             };
@@ -799,6 +805,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.BuildSubmissionStartedEvent;
             }
+            else if (eventType == typeof(BuildCanceledEventArgs))
+            {
+                return LoggingEventType.BuildCanceledEvent;
+            }
 #endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
@@ -1414,7 +1424,7 @@ private IEnumerable ReadProperties(ITranslator translator)
             int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
             if (count == 0)
             {
-                return Enumerable.Empty<DictionaryEntry>();
+                return (DictionaryEntry[])[];
             }
 
             var list = new ArrayList(count);
@@ -1436,7 +1446,7 @@ private IEnumerable ReadItems(ITranslator translator)
             int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
             if (count == 0)
             {
-                return Enumerable.Empty<DictionaryEntry>();
+                return (DictionaryEntry[])[];
             }
 
             var list = new ArrayList(count);
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index e2ebdff4f85..7427c5ed735 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -22,14 +22,13 @@ internal class MSBuildLoadContext : AssemblyLoadContext
         private readonly string _directory;
 
         internal static readonly ImmutableHashSet<string> WellKnownAssemblyNames =
-            new[]
-            {
-                "MSBuild",
-                "Microsoft.Build",
-                "Microsoft.Build.Framework",
-                "Microsoft.Build.Tasks.Core",
-                "Microsoft.Build.Utilities.Core",
-            }.ToImmutableHashSet();
+        [
+            "MSBuild",
+            "Microsoft.Build",
+            "Microsoft.Build.Framework",
+            "Microsoft.Build.Tasks.Core",
+            "Microsoft.Build.Utilities.Core",
+        ];
 
         public MSBuildLoadContext(string assemblyPath)
             : base($"MSBuild plugin {assemblyPath}")
@@ -69,11 +68,11 @@ public MSBuildLoadContext(string assemblyPath)
             foreach (var cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
                 // If no culture is specified, attempt to load directly from
                 // the known dependency paths.
-                ? new[] { string.Empty }
+                ? (string[])[string.Empty]
                 // Search for satellite assemblies in culture subdirectories
                 // of the assembly search directories, but fall back to the
                 // bare search directory if that fails.
-                : new[] { assemblyName.CultureName, string.Empty })
+                : [assemblyName.CultureName, string.Empty])
             {
                 var candidatePath = Path.Combine(_directory,
                     cultureSubfolder,
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 8783318b2e5..55cfb842bdf 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -531,13 +531,15 @@ private void RunReadLoop(Stream localReadPipe, Stream localWritePipe,
             {
                 // Ordering is important.  We want packetAvailable to supercede terminate otherwise we will not properly wait for all
                 // packets to be sent by other threads which are shutting down, such as the logging thread.
-                WaitHandle[] handles = new WaitHandle[] {
+                WaitHandle[] handles =
+                [
 #if FEATURE_APM
                     result.AsyncWaitHandle,
 #else
                     ((IAsyncResult)readTask).AsyncWaitHandle,
 #endif
-                    localPacketAvailable, localTerminatePacketPump };
+                    localPacketAvailable, localTerminatePacketPump
+                ];
 
                 int waitId = WaitHandle.WaitAny(handles);
                 switch (waitId)
diff --git a/src/Shared/StrongNameHelpers.cs b/src/Shared/StrongNameHelpers.cs
index ac9476181eb..b6ba9a50cc3 100644
--- a/src/Shared/StrongNameHelpers.cs
+++ b/src/Shared/StrongNameHelpers.cs
@@ -45,11 +45,10 @@ private static IClrStrongName StrongName
                     if (s_GetRuntimeInterfaceAsObjectMethod != null)
                     {
                         s_StrongName = (IClrStrongName)s_GetRuntimeInterfaceAsObjectMethod.Invoke(null,
-                            new object[]
-                            {
+                            [
                                 new Guid("B79B0ACD-F5CD-409b-B5A5-A16244610B92"),
                                 new Guid("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D")
-                            });
+                            ]);
                     }
                 }
                 return s_StrongName;
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index 9a9c199f732..723a4ba240b 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -417,27 +417,20 @@ public void Translate(ITranslator translator)
             translator.TranslateCulture(ref _culture);
             translator.TranslateCulture(ref _uiCulture);
 #if FEATURE_APPDOMAIN
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
-            {
-                byte[] appDomainConfigBytes = null;
+            byte[] appDomainConfigBytes = null;
 
-                // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
-                if (translator.Mode == TranslationDirection.WriteToStream)
-                {
-                    appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
-                }
+            // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
+            }
 
-                translator.Translate(ref appDomainConfigBytes);
+            translator.Translate(ref appDomainConfigBytes);
 
-                if (translator.Mode == TranslationDirection.ReadFromStream)
-                {
-                    _appDomainSetup = new AppDomainSetup();
-                    _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
-                }
-            }
-            else
+            if (translator.Mode == TranslationDirection.ReadFromStream)
             {
-                translator.TranslateDotNet(ref _appDomainSetup);
+                _appDomainSetup = new AppDomainSetup();
+                _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
             }
 #endif
             translator.Translate(ref _lineNumberOfTask);
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 187a7a43e4b..79e0ea37008 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -1003,12 +1003,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
             {
                 if (_customEscapedMetadata == null || _customEscapedMetadata.Count == 0)
                 {
-#if TASKHOST
-                    // MSBuildTaskHost.dll compiles against .NET 3.5 which doesn't have Enumerable.Empty()
-                    return new KeyValuePair<string, string>[0];
-#else
-                    return Enumerable.Empty<KeyValuePair<string, string>>();
-#endif
+                    return [];
                 }
 
                 var result = new KeyValuePair<string, string>[_customEscapedMetadata.Count];
diff --git a/src/Shared/UnitTests/ErrorUtilities_Tests.cs b/src/Shared/UnitTests/ErrorUtilities_Tests.cs
index 3fc2ee07aff..6adbc583bd9 100644
--- a/src/Shared/UnitTests/ErrorUtilities_Tests.cs
+++ b/src/Shared/UnitTests/ErrorUtilities_Tests.cs
@@ -26,7 +26,7 @@ public void VerifyThrowFalse()
                 return;
             }
 
-            Assert.True(false, "Should have thrown an exception");
+            Assert.Fail("Should have thrown an exception");
         }
 
         [Fact]
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index abf4e350cc4..5b4f91c6142 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -649,7 +649,7 @@ private static IReadOnlyList<string> GetFileSystemEntries(FileMatcher.FileSystem
             else
             {
                 Console.WriteLine("GetFileSystemEntries('{0}', '{1}')", path, pattern);
-                Assert.True(false, "Unexpected input into GetFileSystemEntries");
+                Assert.Fail("Unexpected input into GetFileSystemEntries");
             }
             return new string[] { "<undefined>" };
         }
@@ -2116,7 +2116,7 @@ private int GetMatchingFiles(string[] candidates, string path, string pattern, I
                             }
                             else
                             {
-                                Assert.True(false, String.Format("Unhandled case in GetMatchingFiles: {0}", pattern));
+                                Assert.Fail(String.Format("Unhandled case in GetMatchingFiles: {0}", pattern));
                             }
                         }
                     }
@@ -2173,7 +2173,7 @@ private void GetMatchingDirectories(string[] candidates, string path, string pat
                                 }
                                 else
                                 {
-                                    Assert.True(false, String.Format("Unhandled case in GetMatchingDirectories: {0}", pattern));
+                                    Assert.Fail(String.Format("Unhandled case in GetMatchingDirectories: {0}", pattern));
                                 }
                             }
                         }
@@ -2496,7 +2496,7 @@ private static void ValidateSplitFileSpec(
                 Console.WriteLine("Expect Fixed '{0}' got '{1}'", expectedFixedDirectoryPart, fixedDirectoryPart);
                 Console.WriteLine("Expect Wildcard '{0}' got '{1}'", expectedWildcardDirectoryPart, wildcardDirectoryPart);
                 Console.WriteLine("Expect Filename '{0}' got '{1}'", expectedFilenamePart, filenamePart);
-                Assert.True(false, "FileMatcher Regression: Failure while validating SplitFileSpec.");
+                Assert.Fail("FileMatcher Regression: Failure while validating SplitFileSpec.");
             }
         }
 
@@ -2524,7 +2524,7 @@ private static void ValidateFileMatch(
         {
             if (!IsFileMatchAssertIfIllegal(filespec, fileToMatch, shouldBeRecursive))
             {
-                Assert.True(false, "FileMatcher Regression: Failure while validating that files match.");
+                Assert.Fail("FileMatcher Regression: Failure while validating that files match.");
             }
 
             // Now, simulate a filesystem with only fileToMatch. Make sure the file exists that way.
@@ -2549,7 +2549,7 @@ private static void ValidateNoFileMatch(
         {
             if (IsFileMatchAssertIfIllegal(filespec, fileToMatch, shouldBeRecursive))
             {
-                Assert.True(false, "FileMatcher Regression: Failure while validating that files don't match.");
+                Assert.Fail("FileMatcher Regression: Failure while validating that files don't match.");
             }
 
             // Now, simulate a filesystem with only fileToMatch. Make sure the file doesn't exist that way.
@@ -2577,7 +2577,7 @@ private static void ValidateIllegal(
 
             if (isLegalFileSpec)
             {
-                Assert.True(false, "FileMatcher Regression: Expected an illegal filespec, but got a legal one.");
+                Assert.Fail("FileMatcher Regression: Expected an illegal filespec, but got a legal one.");
             }
 
             // Now, FileMatcher is supposed to take any legal file name and just return it immediately.
@@ -2602,7 +2602,7 @@ private static bool IsFileMatchAssertIfIllegal(
             if (!match.isLegalFileSpec)
             {
                 Console.WriteLine("Checking FileSpec: '{0}' against '{1}'", filespec, fileToMatch);
-                Assert.True(false, "FileMatcher Regression: Invalid filespec.");
+                Assert.Fail("FileMatcher Regression: Invalid filespec.");
             }
             if (shouldBeRecursive != match.isFileSpecRecursive)
             {
diff --git a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
index fefbe339983..efb5d7297ab 100644
--- a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
+++ b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
@@ -45,7 +45,7 @@ public void TestGetProcAddress()
                 }
                 else
                 {
-                    Assert.True(false);
+                    Assert.Fail();
                 }
 
                 // Make sure the pointer passed back for the method is not null
diff --git a/src/StringTools.Benchmark/StringTools.Benchmark.csproj b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
index 95e3ca90a7a..763be443c66 100644
--- a/src/StringTools.Benchmark/StringTools.Benchmark.csproj
+++ b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
@@ -16,7 +16,7 @@
     <PackageReference Include="BenchmarkDotNet" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true'">
+  <ItemGroup Condition="'$(DotNetBuildSourceOnly)' != 'true'">
     <!-- Bump these to the latest version despite transitive references to older -->
     <PackageReference Include="System.Private.Uri" />
     <PackageReference Include="System.Runtime" />
diff --git a/src/Tasks.UnitTests/AddToWin32Manifest_Tests.cs b/src/Tasks.UnitTests/AddToWin32Manifest_Tests.cs
index 2de044bbddd..78a8b68d00a 100644
--- a/src/Tasks.UnitTests/AddToWin32Manifest_Tests.cs
+++ b/src/Tasks.UnitTests/AddToWin32Manifest_Tests.cs
@@ -32,7 +32,7 @@ public class AddToWin32Manifest_Tests
         [InlineData("testManifestSavesTheCurrentNodesPositions.manifest", true)]
         [InlineData("testManifestNoPrefixes.manifest", true)]
         [InlineData(null, true)]
-        public void ManifestPopulationCheck(string manifestName, bool expectedResult)
+        public void ManifestPopulationCheck(string? manifestName, bool expectedResult)
         {
             AddToWin32Manifest task = new AddToWin32Manifest()
             {
@@ -75,7 +75,7 @@ public void ManifestPopulationCheck(string manifestName, bool expectedResult)
         [InlineData(null, true)]
         [InlineData("buildIn.manifest", true)]
         [InlineData("testManifestWithValidSupportedArchs.manifest", true)]
-        public void E2EScenarioTests(string manifestName, bool expectedResult)
+        public void E2EScenarioTests(string? manifestName, bool expectedResult)
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index b72e6d93a16..38842eb5eba 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -553,17 +553,17 @@ public void Basic()
                 {
                     // The version of System.Xml.dll in C:\MyProject is an older version.
                     // This version is not a match. When want the current version which should have been in a different directory.
-                    Assert.True(false, "Wrong version of System.Xml.dll matched--version was wrong");
+                    Assert.Fail("Wrong version of System.Xml.dll matched--version was wrong");
                 }
                 else if (String.Equals(item.ItemSpec, Path.Combine(s_myProjectPath, "System.Data.dll"), StringComparison.OrdinalIgnoreCase))
                 {
                     // The version of System.Data.dll in C:\MyProject has an incorrect PKT
                     // This version is not a match.
-                    Assert.True(false, "Wrong version of System.Data.dll matched--public key token was wrong");
+                    Assert.Fail("Wrong version of System.Data.dll matched--public key token was wrong");
                 }
                 else
                 {
-                    Assert.True(false, String.Format("A new resolved file called '{0}' was found. If this is intentional, then add unittests above.", item.ItemSpec));
+                    Assert.Fail(String.Format("A new resolved file called '{0}' was found. If this is intentional, then add unittests above.", item.ItemSpec));
                 }
             }
 
@@ -593,14 +593,14 @@ public void Basic()
                 }
                 else
                 {
-                    Assert.True(false, String.Format("A new dependency called '{0}' was found. If this is intentional, then add unittests above.", item.ItemSpec));
+                    Assert.Fail(String.Format("A new dependency called '{0}' was found. If this is intentional, then add unittests above.", item.ItemSpec));
                 }
             }
 
             // Process the related files.
             foreach (ITaskItem item in t.RelatedFiles)
             {
-                Assert.True(false, String.Format("A new dependency called '{0}' was found. If this is intentional, then add unittests above.", item.ItemSpec));
+                Assert.Fail(String.Format("A new dependency called '{0}' was found. If this is intentional, then add unittests above.", item.ItemSpec));
             }
 
             // Process the satellites.
@@ -622,7 +622,7 @@ public void Basic()
                 }
                 else
                 {
-                    Assert.True(false, String.Format("A new dependency called '{0}' was found. If this is intentional, then add unittests above.", item.ItemSpec));
+                    Assert.Fail(String.Format("A new dependency called '{0}' was found. If this is intentional, then add unittests above.", item.ItemSpec));
                 }
             }
 
@@ -786,7 +786,7 @@ public void EmbedInteropTypes()
 
                     if (j == assembliesCount)
                     {
-                        Assert.True(false, String.Format("{0}: A new resolved file called '{1}' was found. If this is intentional, then add unittests above.", fxVersion, item.ItemSpec));
+                        Assert.Fail(String.Format("{0}: A new resolved file called '{1}' was found. If this is intentional, then add unittests above.", fxVersion, item.ItemSpec));
                     }
                 }
 
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index fe46f88df33..774d8f3d735 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -325,7 +325,7 @@ internal void StopIOMonitoringAndAssert_Minimal_IOUse(int ioThreshold = 1)
                 if (count > ioThreshold)
                 {
                     string message = String.Format("File.Exists() was called {0} times with path {1}.", count, path);
-                    Assert.True(false, message);
+                    Assert.Fail(message);
                 }
             }
 
@@ -346,7 +346,7 @@ internal void StopIOMonitoringAndAssert_Zero_IOUse()
                 if (count > 0)
                 {
                     string message = String.Format("File.Exists() was called {0} times with path {1}.", count, path);
-                    Assert.True(false, message);
+                    Assert.Fail(message);
                 }
             }
 
@@ -358,7 +358,7 @@ internal void StopIOMonitoringAndAssert_Zero_IOUse()
                 if (count > 0)
                 {
                     string message = String.Format("GetAssemblyName() was called {0} times with path {1}.", count, path);
-                    Assert.True(false, message);
+                    Assert.Fail(message);
                 }
             }
 
@@ -644,7 +644,7 @@ internal static string[] GetFiles(string path, string pattern)
             }
             else
             {
-                Assert.True(false, "Unsupported GetFiles pattern " + pattern);
+                Assert.Fail("Unsupported GetFiles pattern " + pattern);
             }
 
             ArrayList matches = new ArrayList();
@@ -2769,7 +2769,7 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
                 }
             }
 
-            Assert.True(false, $"New GetRegistrySubKeyNames parameters encountered, need to add unittesting support for subKey={subKey}");
+            Assert.Fail($"New GetRegistrySubKeyNames parameters encountered, need to add unittesting support for subKey={subKey}");
             return null;
         }
 
@@ -2908,7 +2908,7 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
                 }
             }
 
-            Assert.True(false, $"New GetRegistrySubKeyDefaultValue parameters encountered, need to add unittesting support for subKey={subKey}");
+            Assert.Fail($"New GetRegistrySubKeyDefaultValue parameters encountered, need to add unittesting support for subKey={subKey}");
             return null;
         }
 
diff --git a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
index 4b0c881cead..ce9d7feadcb 100644
--- a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
+++ b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
@@ -81,7 +81,7 @@ public void KeyContainer()
                 }
                 else
                 {
-                    Assert.True(false, "Key container could not be created (perhaps you are not running as admin).");
+                    Assert.Fail("Key container could not be created (perhaps you are not running as admin).");
                 }
             }
             finally
diff --git a/src/Tasks.UnitTests/CombineTargetFrameworkInfoProperties_Tests.cs b/src/Tasks.UnitTests/CombineTargetFrameworkInfoProperties_Tests.cs
index ea0a3b0f166..e22a715f8a4 100644
--- a/src/Tasks.UnitTests/CombineTargetFrameworkInfoProperties_Tests.cs
+++ b/src/Tasks.UnitTests/CombineTargetFrameworkInfoProperties_Tests.cs
@@ -18,7 +18,7 @@ public sealed class CombineTargetFrameworkInfoProperties_Tests
         [InlineData(null, false, "MSB3991")]
         [InlineData("", false, "MSB3991")]
         [InlineData(null, true, "MSB3992")]
-        public void RootElementNameNotValid(string rootElementName, bool UseAttributeForTargetFrameworkInfoPropertyNames, string errorCode)
+        public void RootElementNameNotValid(string? rootElementName, bool UseAttributeForTargetFrameworkInfoPropertyNames, string errorCode)
         {
             MockEngine e = new MockEngine();
             var task = new CombineTargetFrameworkInfoProperties();
diff --git a/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs b/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs
index e60d67c1f9e..e816ca11e4d 100644
--- a/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs
+++ b/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs
@@ -47,7 +47,7 @@ public void AppendItemWithInvalidBooleanAttribute()
                 }
                 catch (ArgumentException e)
                 {
-                    Assert.True(false, "Got an unexpected exception:" + e.Message);
+                    Assert.Fail("Got an unexpected exception:" + e.Message);
                 }
 
                 // Now try a bogus boolean.
diff --git a/src/Tasks.UnitTests/CommandLine_Support.cs b/src/Tasks.UnitTests/CommandLine_Support.cs
index 97a7d57f2ec..faf373a6a5c 100644
--- a/src/Tasks.UnitTests/CommandLine_Support.cs
+++ b/src/Tasks.UnitTests/CommandLine_Support.cs
@@ -96,7 +96,7 @@ internal static int ValidateHasParameter(ToolTaskExtension t, string parameter,
 
             msg += "Not found!\r\n";
             Console.WriteLine(msg);
-            Assert.True(false, msg); // Could not find the parameter.
+            Assert.Fail(msg); // Could not find the parameter.
 
             return 0;
         }
@@ -185,7 +185,7 @@ internal static void ValidateNoParameterStartsWith(
                     {
                         msg += String.Format(" Found something!\r\n");
                         Console.WriteLine(msg);
-                        Assert.True(false, msg); // Found the startsWith but shouldn't have.
+                        Assert.Fail(msg); // Found the startsWith but shouldn't have.
                         return;
                     }
                 }
@@ -221,7 +221,7 @@ internal static void ValidateContains(ToolTaskExtension t, string lookFor, bool
             {
                 msg += "Not found!\r\n";
                 Console.WriteLine(msg);
-                Assert.True(false, msg);
+                Assert.Fail(msg);
             }
         }
 
@@ -253,7 +253,7 @@ internal static void ValidateDoesNotContain(ToolTaskExtension t, string lookFor,
             {
                 msg += "Found!\r\n";
                 Console.WriteLine(msg);
-                Assert.True(false, msg);
+                Assert.Fail(msg);
             }
         }
 
@@ -284,7 +284,7 @@ internal static void ValidateEquals(ToolTaskExtension t, string lookFor, bool us
             {
                 msg += "Does not match!\r\n";
                 Console.WriteLine(msg);
-                Assert.True(false, msg);
+                Assert.Fail(msg);
             }
         }
 
diff --git a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
index 2c97a736413..a29f5b938fc 100644
--- a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
@@ -780,7 +780,7 @@ private Stream CreateFileStream(string path, FileMode mode, FileAccess access)
             {
                 return StreamHelpers.StringToStream("namespace MyStuff.Namespace { class Class {} }");
             }
-            Assert.True(false, String.Format("Encountered a new path {0}, needs unittesting support", path));
+            Assert.Fail(String.Format("Encountered a new path {0}, needs unittesting support", path));
             return null;
         }
 
diff --git a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
index d22cd676005..70ec1fb1452 100644
--- a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
@@ -424,7 +424,7 @@ End Namespace
 ");
             }
 
-            Assert.True(false, String.Format("Encountered a new path {0}, needs unittesting support", path));
+            Assert.Fail(String.Format("Encountered a new path {0}, needs unittesting support", path));
             return null;
         }
 
diff --git a/src/Tasks.UnitTests/GetSDKReference_Tests.cs b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
index 851300230cd..db7e1f155f1 100644
--- a/src/Tasks.UnitTests/GetSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
@@ -634,7 +634,7 @@ public void VerifyCacheFileNames()
             // References from the two builds should not overlap, otherwise the cache files are being misused
             foreach (var ref2 in references2)
             {
-                Assert.Empty(references1.Where(i => i.ItemSpec.Equals(ref2.ItemSpec, StringComparison.InvariantCultureIgnoreCase)));
+                Assert.DoesNotContain(references1, i => i.ItemSpec.Equals(ref2.ItemSpec, StringComparison.InvariantCultureIgnoreCase));
             }
 
             Thread.Sleep(100);
diff --git a/src/Tasks.UnitTests/MSBuild_Tests.cs b/src/Tasks.UnitTests/MSBuild_Tests.cs
index ad1ab81787a..9a17e9b848f 100644
--- a/src/Tasks.UnitTests/MSBuild_Tests.cs
+++ b/src/Tasks.UnitTests/MSBuild_Tests.cs
@@ -39,7 +39,6 @@ public void Dispose()
         /// throw a path too long exception
         /// </summary>
         [Fact]
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/4247")]
         public void ProjectItemSpecTooLong()
         {
             string currentDirectory = Directory.GetCurrentDirectory();
@@ -47,8 +46,6 @@ public void ProjectItemSpecTooLong()
             {
                 Directory.SetCurrentDirectory(Path.GetTempPath());
 
-                string tempPath = Path.GetTempPath();
-
                 string tempProject = ObjectModelHelpers.CreateTempFileOnDisk(@"
                 <Project DefaultTargets=`TargetA; TargetB; TargetC` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
@@ -70,10 +67,10 @@ public void ProjectItemSpecTooLong()
                     projectFile1 += "..\\";
                 }
 
-                int rootLength = Path.GetPathRoot(tempPath).Length;
-                string tempPathNoRoot = tempPath.Substring(rootLength);
+                int rootLength = Path.GetPathRoot(tempProject).Length;
+                string tempPathNoRoot = tempProject.Substring(rootLength);
 
-                projectFile1 += Path.Combine(tempPathNoRoot, fileName);
+                projectFile1 += tempPathNoRoot;
                 try
                 {
                     MSBuild msbuildTask = new MSBuild
diff --git a/src/Tasks.UnitTests/MockTypeInfo.cs b/src/Tasks.UnitTests/MockTypeInfo.cs
index 140e6f596ca..3ba35b10e37 100644
--- a/src/Tasks.UnitTests/MockTypeInfo.cs
+++ b/src/Tasks.UnitTests/MockTypeInfo.cs
@@ -278,7 +278,7 @@ void IFixedTypeInfo.GetRefTypeInfo(System.IntPtr hRef, out IFixedTypeInfo ppTI)
             else
             {
                 ppTI = null;
-                Assert.True(false, "unexpected hRef value");
+                Assert.Fail("unexpected hRef value");
             }
         }
 
@@ -345,7 +345,7 @@ public void GetRefTypeInfo(int hRef, out ITypeInfo ppTI)
             else
             {
                 ppTI = null;
-                Assert.True(false, "unexpected hRef value");
+                Assert.Fail("unexpected hRef value");
             }
         }
 
diff --git a/src/Tasks.UnitTests/MockTypeLib.cs b/src/Tasks.UnitTests/MockTypeLib.cs
index 28b42a5fa5c..fd3fd1e5ebb 100644
--- a/src/Tasks.UnitTests/MockTypeLib.cs
+++ b/src/Tasks.UnitTests/MockTypeLib.cs
@@ -223,7 +223,7 @@ public void GetCustData(ref Guid guid, out object pVarVal)
             }
             else
             {
-                Assert.True(false, "unexpected guid in ITypeLib2.GetCustData");
+                Assert.Fail("unexpected guid in ITypeLib2.GetCustData");
                 pVarVal = null;
             }
         }
diff --git a/src/Tasks.UnitTests/Touch_Tests.cs b/src/Tasks.UnitTests/Touch_Tests.cs
index a6759421bad..7f6da5b32ee 100644
--- a/src/Tasks.UnitTests/Touch_Tests.cs
+++ b/src/Tasks.UnitTests/Touch_Tests.cs
@@ -65,7 +65,7 @@ private static bool FileExists(string path)
             {
                 return true;
             }
-            Assert.True(false, "Unexpected file exists: " + path);
+            Assert.Fail("Unexpected file exists: " + path);
 
             return true;
         }
@@ -87,7 +87,7 @@ private static FileStream FileCreate(string path)
             }
 
 
-            Assert.True(false, "Unexpected file create: " + path);
+            Assert.Fail("Unexpected file create: " + path);
             return null;
         }
 
@@ -114,7 +114,7 @@ private static FileAttributes GetAttributes(string path)
                 return System.IO.FileAttributes.ReadOnly;
             }
 
-            Assert.True(false, "Unexpected file attributes: " + path);
+            Assert.Fail("Unexpected file attributes: " + path);
             return a;
         }
 
@@ -128,7 +128,7 @@ private static void SetAttributes(string path, FileAttributes attributes)
             {
                 return;
             }
-            Assert.True(false, "Unexpected set file attributes: " + path);
+            Assert.Fail("Unexpected set file attributes: " + path);
         }
 
         /// <summary>
@@ -153,7 +153,7 @@ private static void SetLastAccessTime(string path, DateTime timestamp)
                 throw new IOException();
             }
 
-            Assert.True(false, "Unexpected set last access time: " + path);
+            Assert.Fail("Unexpected set last access time: " + path);
         }
 
         /// <summary>
@@ -178,7 +178,7 @@ private static void SetLastWriteTime(string path, DateTime timestamp)
             }
 
 
-            Assert.True(false, "Unexpected set last write time: " + path);
+            Assert.Fail("Unexpected set last write time: " + path);
         }
 
         [Fact]
diff --git a/src/Tasks.UnitTests/Unzip_Tests.cs b/src/Tasks.UnitTests/Unzip_Tests.cs
index b53c19047be..bcfe0b54460 100644
--- a/src/Tasks.UnitTests/Unzip_Tests.cs
+++ b/src/Tasks.UnitTests/Unzip_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
@@ -449,5 +450,39 @@ public void LogsErrorIfExcludeContainsPropertyReferences()
                 _mockEngine.Log.ShouldContain("MSB3938", customMessage: _mockEngine.Log);
             }
         }
+
+        [UnixOnlyFact]
+        public void CanKeepUnixFilePermissions()
+        {
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);
+            string executableName = "myapp";
+            var sourceFile = testEnvironment.CreateFile(source, executableName, "Dummy executable");
+
+            var ExecuteCommand = (string command, string filePath) =>
+            {
+                string output = RunnerUtilities.RunProcessAndGetOutput($"/bin/sh", $"-c \"{command} {sourceFile.Path}\"", out bool success);
+                return output;
+            };
+            ExecuteCommand("chmod +x", sourceFile.Path);
+            var permissions = ExecuteCommand("ls -l", sourceFile.Path).Substring(0, 10);
+
+            TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
+            TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);
+            Unzip unzip = new Unzip
+            {
+                BuildEngine = _mockEngine,
+                DestinationFolder = new TaskItem(destination.Path),
+                OverwriteReadOnlyFiles = true,
+                SkipUnchangedFiles = false,
+                SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+            };
+            unzip.Execute().ShouldBeTrue(_mockEngine.Log);
+            string unzippedFilePath = Path.Combine(destination.Path, executableName);
+            _mockEngine.Log.ShouldContain(unzippedFilePath, customMessage: _mockEngine.Log);
+            File.Exists(unzippedFilePath).ShouldBeTrue();
+            var unzippedFilePermissions = ExecuteCommand("ls -l", unzippedFilePath).Substring(0, 10);
+            unzippedFilePermissions.ShouldBe(permissions);
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/XamlTestHelpers.cs b/src/Tasks.UnitTests/XamlTestHelpers.cs
index d753b0d033f..99ae5a20808 100644
--- a/src/Tasks.UnitTests/XamlTestHelpers.cs
+++ b/src/Tasks.UnitTests/XamlTestHelpers.cs
@@ -121,7 +121,7 @@ public static Assembly SetupGeneratedCode(string xml)
             }
             catch (XamlParseException)
             {
-                Assert.True(false, "Parse of FakeTask XML failed");
+                Assert.Fail("Parse of FakeTask XML failed");
             }
 
             TaskGenerator tg = new TaskGenerator(tp);
diff --git a/src/Tasks.UnitTests/XslTransformation_Tests.cs b/src/Tasks.UnitTests/XslTransformation_Tests.cs
index 3c218f2ebe7..b7aa4258a25 100644
--- a/src/Tasks.UnitTests/XslTransformation_Tests.cs
+++ b/src/Tasks.UnitTests/XslTransformation_Tests.cs
@@ -126,7 +126,7 @@ public void XmlXslParameters()
                             t.XmlInputPaths = (TaskItem[])xmlValue;
                             break;
                         default:
-                            Assert.True(false, "Test error");
+                            Assert.Fail("Test error");
                             break;
                     }
 
@@ -142,7 +142,7 @@ public void XmlXslParameters()
                             t.XslCompiledDllPath = (TaskItem)xslValue;
                             break;
                         default:
-                            Assert.True(false, "Test error");
+                            Assert.Fail("Test error");
                             break;
                     }
 
@@ -187,7 +187,7 @@ public void MissingXslParameter()
                         t.XmlInputPaths = (TaskItem[])xmlValue;
                         break;
                     default:
-                        Assert.True(false, "Test error");
+                        Assert.Fail("Test error");
                         break;
                 }
 
@@ -236,7 +236,7 @@ public void MissingXmlParameter()
                         t.XslCompiledDllPath = (TaskItem)xslValue;
                         break;
                     default:
-                        Assert.True(false, "Test error");
+                        Assert.Fail("Test error");
                         break;
                 }
 
@@ -1212,7 +1212,7 @@ private void Compile(string inputFile, string outputFile)
             }
             catch (Exception e)
             {
-                Assert.True(false, "Compiler didn't work" + e.ToString());
+                Assert.Fail("Compiler didn't work" + e.ToString());
             }
 
             asmBldr.Save(Path.GetFileName(outputFile), PortableExecutableKinds.ILOnly, ImageFileMachine.I386);
diff --git a/src/Tasks/Al.cs b/src/Tasks/Al.cs
index 0b587df5b74..d1872e4fb39 100644
--- a/src/Tasks/Al.cs
+++ b/src/Tasks/Al.cs
@@ -356,17 +356,17 @@ protected internal override void AddResponseFileCommands(CommandLineBuilderExten
             commandLine.AppendSwitchIfNotNull("/win32icon:", Win32Icon);
             commandLine.AppendSwitchIfNotNull("/win32res:", Win32Resource);
 
-            commandLine.AppendSwitchIfNotNull("", SourceModules, new[] { "TargetFile" });
+            commandLine.AppendSwitchIfNotNull("", SourceModules, ["TargetFile"]);
 
             commandLine.AppendSwitchIfNotNull(
                 "/embed:",
                 EmbedResources,
-                new[] { "LogicalName", "Access" });
+                ["LogicalName", "Access"]);
 
             commandLine.AppendSwitchIfNotNull(
                 "/link:",
                 LinkResources,
-                new[] { "LogicalName", "TargetFile", "Access" });
+                ["LogicalName", "TargetFile", "Access"]);
 
             // It's a good idea for the response file to be the very last switch passed, just
             // from a predictability perspective.  This is also consistent with the compiler
diff --git a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
index d9803997df2..b7352e6b255 100644
--- a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
+++ b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
@@ -140,7 +140,7 @@ internal IEnumerable<AssemblyEntry> FindAssemblyNameFromSimpleName(string simple
         {
             if (_redistList == null)
             {
-                return Enumerable.Empty<AssemblyEntry>();
+                return [];
             }
 
             return _redistList.FindAssemblyNameFromSimpleName(simpleName);
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index 5819184dc59..d9ba3671e32 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -40,7 +40,7 @@ internal sealed class Reference
         /// <summary>
         /// Scatter files associated with this reference.
         /// </summary>
-        private string[] _scatterFiles = Array.Empty<string>();
+        private string[] _scatterFiles = [];
 
         /// <summary>
         /// Any errors that occurred while resolving or finding dependencies on this item.
@@ -258,7 +258,7 @@ internal void AttachScatterFiles(string[] scatterFilesToAttach)
         {
             if (scatterFilesToAttach == null || scatterFilesToAttach.Length == 0)
             {
-                _scatterFiles = Array.Empty<string>();
+                _scatterFiles = [];
             }
             else
             {
@@ -500,7 +500,7 @@ internal string FullPath
 
                     if (string.IsNullOrEmpty(_fullPath))
                     {
-                        _scatterFiles = Array.Empty<string>();
+                        _scatterFiles = [];
                         _satelliteFiles = new List<string>();
                         _serializationAssemblyFiles = new List<string>();
                         AssembliesConsideredAndRejected = new List<ResolutionSearchLocation>();
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index b8cf7e10aa4..e353f56470a 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -46,7 +46,7 @@ internal sealed class ReferenceTable
         private readonly Dictionary<string, AssemblyNameExtension> _externallyResolvedImmutableFiles = new Dictionary<string, AssemblyNameExtension>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>The table of remapped assemblies. Used for Unification.</summary>
-        private IEnumerable<DependentAssembly> _remappedAssemblies = Enumerable.Empty<DependentAssembly>();
+        private IEnumerable<DependentAssembly> _remappedAssemblies = [];
 
         /// <summary>If true, then search for dependencies.</summary>
         private readonly bool _findDependencies;
@@ -817,7 +817,7 @@ private static void TryGetAssemblyNameComponent(string fusionName, string compon
                 return;
             }
             position += component.Length + 1;
-            int nextDelimiter = fusionName.IndexOfAny(new[] { ',', ' ' }, position);
+            int nextDelimiter = fusionName.IndexOfAny([',', ' '], position);
             if (nextDelimiter == -1)
             {
                 value = fusionName.Substring(position);
@@ -1290,7 +1290,7 @@ private void ResolveReference(
             // If a reference has the SDKName metadata on it then we will only search using a single resolver, that is the InstalledSDKResolver.
             if (reference.SDKName.Length > 0)
             {
-                jaggedResolvers.Add(new Resolver[] { new InstalledSDKResolver(_resolvedSDKReferences, "SDKResolver", _getAssemblyName, _fileExists, _getRuntimeVersion, _targetedRuntimeVersion) });
+                jaggedResolvers.Add([new InstalledSDKResolver(_resolvedSDKReferences, "SDKResolver", _getAssemblyName, _fileExists, _getRuntimeVersion, _targetedRuntimeVersion)]);
             }
             else
             {
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 75ea877da61..a0f8ea6bb75 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -175,11 +175,11 @@ internal static void Initialize(TaskLoggingHelper log)
         private ITaskItem[] _resolvedSDKReferences = Array.Empty<TaskItem>();
         private bool _ignoreDefaultInstalledAssemblyTables = false;
         private bool _ignoreDefaultInstalledAssemblySubsetTables = false;
-        private string[] _candidateAssemblyFiles = Array.Empty<string>();
-        private string[] _targetFrameworkDirectories = Array.Empty<string>();
-        private string[] _searchPaths = Array.Empty<string>();
-        private string[] _allowedAssemblyExtensions = new string[] { ".winmd", ".dll", ".exe" };
-        private string[] _relatedFileExtensions = new string[] { ".pdb", ".xml", ".pri" };
+        private string[] _candidateAssemblyFiles = [];
+        private string[] _targetFrameworkDirectories = [];
+        private string[] _searchPaths = [];
+        private string[] _allowedAssemblyExtensions = [".winmd", ".dll", ".exe"];
+        private string[] _relatedFileExtensions = [".pdb", ".xml", ".pri"];
         private string _appConfigFile = null;
         private bool _supportsBindingRedirectGeneration;
         private bool _autoUnify = false;
@@ -194,8 +194,8 @@ internal static void Initialize(TaskLoggingHelper log)
         private ITaskItem[] _copyLocalFiles = Array.Empty<TaskItem>();
         private ITaskItem[] _suggestedRedirects = Array.Empty<TaskItem>();
         private List<ITaskItem> _unresolvedConflicts = new List<ITaskItem>();
-        private string[] _targetFrameworkSubsets = Array.Empty<string>();
-        private string[] _fullTargetFrameworkSubsetNames = Array.Empty<string>();
+        private string[] _targetFrameworkSubsets = [];
+        private string[] _fullTargetFrameworkSubsetNames = [];
         private string _targetedFrameworkMoniker = String.Empty;
 
         private bool _findDependencies = true;
@@ -211,8 +211,8 @@ internal static void Initialize(TaskLoggingHelper log)
         private string _targetProcessorArchitecture = null;
 
         private string _profileName = String.Empty;
-        private string[] _fullFrameworkFolders = Array.Empty<string>();
-        private string[] _latestTargetFrameworkDirectories = Array.Empty<string>();
+        private string[] _fullFrameworkFolders = [];
+        private string[] _latestTargetFrameworkDirectories = [];
         private bool _copyLocalDependenciesWhenParentReferenceInGac = true;
         private Dictionary<string, MessageImportance> _showAssemblyFoldersExLocations = new Dictionary<string, MessageImportance>(StringComparer.OrdinalIgnoreCase);
         private bool _logVerboseSearchResults = false;
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index e1923c87f9d..2b996326fc5 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -429,7 +429,7 @@ private List<string> ExtractReferencedAssemblies()
             {
                 XmlAttribute attribute = referenceNodes[i].Attributes["Include"];
 
-                bool hasInvalidChildNodes = HasInvalidChildNodes(referenceNodes[i], new[] { XmlNodeType.Comment, XmlNodeType.Whitespace });
+                bool hasInvalidChildNodes = HasInvalidChildNodes(referenceNodes[i], [XmlNodeType.Comment, XmlNodeType.Whitespace]);
 
                 if (hasInvalidChildNodes)
                 {
@@ -459,7 +459,7 @@ private List<string> ExtractUsingNamespaces()
             var usings = new List<string>();
             for (int i = 0; i < usingNodes.Count; i++)
             {
-                bool hasInvalidChildNodes = HasInvalidChildNodes(usingNodes[i], new[] { XmlNodeType.Comment, XmlNodeType.Whitespace });
+                bool hasInvalidChildNodes = HasInvalidChildNodes(usingNodes[i], [XmlNodeType.Comment, XmlNodeType.Whitespace]);
 
                 if (hasInvalidChildNodes)
                 {
@@ -509,7 +509,7 @@ private XmlNode ExtractTaskContent(string taskElementContents)
                 return null;
             }
 
-            bool hasInvalidChildNodes = HasInvalidChildNodes(codeNodes[0], new[] { XmlNodeType.Comment, XmlNodeType.Whitespace, XmlNodeType.Text, XmlNodeType.CDATA });
+            bool hasInvalidChildNodes = HasInvalidChildNodes(codeNodes[0], [XmlNodeType.Comment, XmlNodeType.Whitespace, XmlNodeType.Text, XmlNodeType.CDATA]);
 
             if (hasInvalidChildNodes)
             {
diff --git a/src/Tasks/CompatibilitySuppressions.xml b/src/Tasks/CompatibilitySuppressions.xml
index f7865631aa7..6e6f63a5eb6 100644
--- a/src/Tasks/CompatibilitySuppressions.xml
+++ b/src/Tasks/CompatibilitySuppressions.xml
@@ -1,10 +1,10 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
+<!-- https://learn.microsoft.com/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <!-- For ease of logging the "not supported on Core" message, these tasks are a
-         TaskRequiresFramework on netstandard/netcore. Since the type is sealed there,
-         that shouldn't cause any implementation problems since no one can derive
-         from it and try to call TaskExtension.Log. -->
+       TaskRequiresFramework on netstandard/netcore. Since the type is sealed there,
+       that shouldn't cause any implementation problems since no one can derive
+       from it and try to call TaskExtension.Log. -->
   <Suppression>
     <DiagnosticId>CP0007</DiagnosticId>
     <Target>T:Microsoft.Build.Tasks.AL</Target>
@@ -71,18 +71,11 @@
     <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
     <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
   </Suppression>
-
   <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
-       This is intentional, because you can only use MSBuild in the context of a .NET SDK
-       (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
-       have previously shipped netstandard2.0 packages, and if you want to support both
-       runtime contexts it still makes sense to target that. -->
-
-  <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
-       This is intentional, because you can only use MSBuild in the context of a .NET SDK
-       (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
-       have previously shipped netstandard2.0 packages, and if you want to support both
-       runtime contexts it still makes sense to target that. -->
+      This is intentional, because you can only use MSBuild in the context of a .NET SDK
+      (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
+      have previously shipped netstandard2.0 packages, and if you want to support both
+      runtime contexts it still makes sense to target that. -->
   <Suppression>
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>.NETCoreApp,Version=v2.0</Target>
@@ -131,64 +124,4 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
-  <!--
-  Since we are dropping the .net 8 and retarrgetting to .net 9, we need to suppress the following errors. 
-  The comparison ref/net.8 with ref/netstandard2.0 is not valid anymore.
-  -->
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity</Target>
-    <Left>ref/net8.0/Microsoft.Build.Tasks.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation</Target>
-    <Left>ref/net8.0/Microsoft.Build.Tasks.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags</Target>
-    <Left>ref/net8.0/Microsoft.Build.Tasks.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType</Target>
-    <Left>ref/net8.0/Microsoft.Build.Tasks.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType</Target>
-    <Left>ref/net8.0/Microsoft.Build.Tasks.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode</Target>
-    <Left>ref/net8.0/Microsoft.Build.Tasks.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit</Target>
-    <Left>ref/net8.0/Microsoft.Build.Tasks.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-    <!--
-    https://learn.microsoft.com/en-us/dotnet/fundamentals/apicompat/diagnostic-ids
-    Suppress PKV006 for net8.0 (The target framework is dropped in the latest version.)  -->
-  <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net8.0</Target>
-  </Suppression>
-</Suppressions>
+</Suppressions>
\ No newline at end of file
diff --git a/src/Tasks/CreateProperty.cs b/src/Tasks/CreateProperty.cs
index 7980feb2d14..d077411d58c 100644
--- a/src/Tasks/CreateProperty.cs
+++ b/src/Tasks/CreateProperty.cs
@@ -59,7 +59,7 @@ public override bool Execute()
         {
             if (Value == null)
             {
-                Value = Array.Empty<string>();
+                Value = [];
             }
 
             return true;
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index e37a9bcf300..aed8b824d4f 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -31,7 +31,7 @@ internal static class CultureInfoCache
         // These pseudo-locales are available in versions of Windows from Vista and later.
         // However, from Windows 10, version 1803, they are not returned when enumerating the
         // installed cultures, even if the registry keys are set. Therefore, add them to the list manually.
-        private static readonly string[] pseudoLocales = new[] { "qps-ploc", "qps-ploca", "qps-plocm", "qps-Latn-x-sh" };
+        private static readonly string[] pseudoLocales = ["qps-ploc", "qps-ploca", "qps-plocm", "qps-Latn-x-sh"];
 
         private static HashSet<string> InitializeValidCultureNames()
         {
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index faa3df5e80e..67d44af7c62 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -579,7 +579,7 @@ private void LogResgenCommandLine(List<ITaskItem> inputFiles, List<ITaskItem> ou
                     if (!ExtractResWFiles)
                     {
                         commandLineBuilder.AppendFileNamesIfNotNull(
-                            new string[] { inputFiles[i].ItemSpec, outputFiles[i].ItemSpec },
+                            [inputFiles[i].ItemSpec, outputFiles[i].ItemSpec],
                             ",");
                     }
                     else
@@ -597,7 +597,7 @@ private void LogResgenCommandLine(List<ITaskItem> inputFiles, List<ITaskItem> ou
                 // append the strongly-typed resource details
                 commandLineBuilder.AppendSwitchIfNotNull(
                     "/str:",
-                    new string[] { StronglyTypedLanguage, StronglyTypedNamespace, StronglyTypedClassName, StronglyTypedFileName },
+                    [StronglyTypedLanguage, StronglyTypedNamespace, StronglyTypedClassName, StronglyTypedFileName],
                     ",");
             }
 
@@ -1238,7 +1238,7 @@ private int CalculateResourceBatchSize(List<ITaskItem> inputsToProcess, List<ITa
             while (currentCommand.Length < s_maximumCommandLength && i < inputsToProcess.Count)
             {
                 currentCommand.AppendFileNamesIfNotNull(
-                        new ITaskItem[] { inputsToProcess[i], outputsToProcess[i] },
+                        [inputsToProcess[i], outputsToProcess[i]],
                         ",");
                 i++;
             }
@@ -1705,7 +1705,7 @@ private void UpdateNewestUncorrelatedInputWriteTime()
 
             // Check the timestamp of each of the passed-in references to find the newest;
             // and then the additional inputs
-            var inputs = (this.References ?? Enumerable.Empty<ITaskItem>()).Concat(this.AdditionalInputs ?? Enumerable.Empty<ITaskItem>());
+            ITaskItem[] inputs = this.References ?? [..(this.AdditionalInputs ?? [])];
 
             foreach (ITaskItem input in inputs)
             {
@@ -2020,7 +2020,7 @@ private bool DetermineWhetherSerializedObjectLoads(string data)
         /// <summary>
         /// Chars that should be ignored in the nicely justified block of base64
         /// </summary>
-        private static readonly char[] s_specialChars = new char[] { ' ', '\r', '\n' };
+        private static readonly char[] s_specialChars = [' ', '\r', '\n'];
 
         /// <summary>
         /// Turns the nicely justified block of base64 found in a resx into a byte array.
diff --git a/src/Tasks/GetAssembliesMetadata.cs b/src/Tasks/GetAssembliesMetadata.cs
index 520b979be03..73a3877001f 100644
--- a/src/Tasks/GetAssembliesMetadata.cs
+++ b/src/Tasks/GetAssembliesMetadata.cs
@@ -32,7 +32,7 @@ public class GetAssembliesMetadata : TaskExtension
         /// <summary>
         /// Assembly paths.
         /// </summary>
-        private string[] _assemblyPaths = Array.Empty<string>();
+        private string[] _assemblyPaths = [];
 
         /// <summary>
         /// Set of resolved assembly metadata.
diff --git a/src/Tasks/GetInstalledSDKLocations.cs b/src/Tasks/GetInstalledSDKLocations.cs
index e1d4bb966e7..05aa5d2a30f 100644
--- a/src/Tasks/GetInstalledSDKLocations.cs
+++ b/src/Tasks/GetInstalledSDKLocations.cs
@@ -169,8 +169,8 @@ public override bool Execute()
                     item.SetMetadata("PlatformVersion", sdk.Value.Item2);
 
                     // Need to stash these so we can unroll the platform via GetMatchingPlatformSDK when we get the reference files for the sdks
-                    item.SetMetadata(DirectoryRootsMetadataName, String.Join(";", SDKDirectoryRoots ?? Array.Empty<string>()));
-                    item.SetMetadata(ExtensionDirectoryRootsMetadataName, String.Join(";", SDKExtensionDirectoryRoots ?? Array.Empty<string>()));
+                    item.SetMetadata(DirectoryRootsMetadataName, String.Join(";", SDKDirectoryRoots ?? []));
+                    item.SetMetadata(ExtensionDirectoryRootsMetadataName, String.Join(";", SDKExtensionDirectoryRoots ?? []));
                     item.SetMetadata(RegistryRootMetadataName, SDKRegistryRoot);
 
                     outputItems.Add(item);
diff --git a/src/Tasks/GetReferenceAssemblyPaths.cs b/src/Tasks/GetReferenceAssemblyPaths.cs
index 621291acdac..50e3f54d4c4 100644
--- a/src/Tasks/GetReferenceAssemblyPaths.cs
+++ b/src/Tasks/GetReferenceAssemblyPaths.cs
@@ -65,7 +65,7 @@ public string[] ReferenceAssemblyPaths
                 }
                 else
                 {
-                    return Array.Empty<string>();
+                    return [];
                 }
             }
         }
@@ -87,7 +87,7 @@ public string[] FullFrameworkReferenceAssemblyPaths
                 }
                 else
                 {
-                    return Array.Empty<string>();
+                    return [];
                 }
             }
         }
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 2af5faaf3b8..b1a24a00d6a 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -1168,7 +1168,7 @@ private static IEnumerable<string> GetAllRedistDirectories(string sdkRoot)
                     return Directory.GetDirectories(redistPath, "*", SearchOption.AllDirectories);
                 }
 
-                return Enumerable.Empty<string>();
+                return [];
             }
 
             /// <summary>
@@ -1182,7 +1182,7 @@ private static IEnumerable<string> GetAllReferenceDirectories(string sdkRoot)
                     return Directory.GetDirectories(referencesPath, "*", SearchOption.AllDirectories);
                 }
 
-                return Enumerable.Empty<string>();
+                return [];
             }
         }
 
diff --git a/src/Tasks/Hash.cs b/src/Tasks/Hash.cs
index d1d6f8f7bc6..0bc42f56bfe 100644
--- a/src/Tasks/Hash.cs
+++ b/src/Tasks/Hash.cs
@@ -26,7 +26,7 @@ public class Hash : TaskExtension
     {
         private const char ItemSeparatorCharacter = '\u2028';
         private static readonly Encoding s_encoding = Encoding.UTF8;
-        private static readonly byte[] s_itemSeparatorCharacterBytes = s_encoding.GetBytes(new char[] { ItemSeparatorCharacter });
+        private static readonly byte[] s_itemSeparatorCharacterBytes = s_encoding.GetBytes([ItemSeparatorCharacter]);
 
         // Size of buffer where bytes of the strings are stored until sha.TransformBlock is to be run on them.
         // It is needed to get a balance between amount of costly sha.TransformBlock calls and amount of allocated memory.
diff --git a/src/Tasks/InstalledSDKResolver.cs b/src/Tasks/InstalledSDKResolver.cs
index 9fd40f7963e..b8f7d6a0b12 100644
--- a/src/Tasks/InstalledSDKResolver.cs
+++ b/src/Tasks/InstalledSDKResolver.cs
@@ -62,13 +62,13 @@ public override bool Resolve(
                     string referenceAssemblyPathNeutral = Path.Combine(sdkDirectory, "References", configuration, "Neutral");
                     string referenceAssemblyArchFilePathNeutral = Path.Combine(sdkDirectory, "References", "CommonConfiguration", "Neutral");
 
-                    string[] searchLocations = new string[]
-                    {
+                    string[] searchLocations =
+                    [
                         referenceAssemblyFilePath, // Config-Arch
                         referenceAssemblyPathNeutral, // Config-Neutral
                         referenceAssemblyCommonArchFilePath, // CommonArch-Config
                         referenceAssemblyArchFilePathNeutral // CommonArch-Neutral
-                    };
+                    ];
 
                     // Lets try and resovle from the windowsmetadata directory first
 
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index 9e78a48daf4..3169eaec219 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -460,7 +460,7 @@ internal static List<string[]> CreateTargetLists(string[] targets, bool runEachT
                 // Separate target invocations for each individual target.
                 foreach (string targetName in targets)
                 {
-                    targetLists.Add(new[] { targetName });
+                    targetLists.Add([targetName]);
                 }
             }
             else
diff --git a/src/Tasks/ManifestUtil/AssemblyIdentity.cs b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
index 64af947c9d1..6328476020f 100644
--- a/src/Tasks/ManifestUtil/AssemblyIdentity.cs
+++ b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
@@ -509,7 +509,7 @@ internal string Resolve(string[] searchPaths, bool specificVersion)
         {
             if (searchPaths == null)
             {
-                searchPaths = new[] { ".\\" };
+                searchPaths = [".\\"];
             }
 
             foreach (string searchPath in searchPaths)
diff --git a/src/Tasks/ManifestUtil/CngLightup.cs b/src/Tasks/ManifestUtil/CngLightup.cs
index 3ccb3de31b9..9df8266fb8e 100644
--- a/src/Tasks/ManifestUtil/CngLightup.cs
+++ b/src/Tasks/ManifestUtil/CngLightup.cs
@@ -558,7 +558,7 @@ private static Func<X509Certificate2, T> BindCoreDelegate<T>(string algorithmNam
                 methodName,
                 BindingFlags.Public | BindingFlags.Static,
                 null,
-                new[] { typeof(X509Certificate2) },
+                [typeof(X509Certificate2)],
                 null);
 
             Debug.Assert(api != null, "Method '" + methodName + "(X509Certificate2 c)' not found on type '" + type + "'");
diff --git a/src/Tasks/ManifestUtil/ComImporter.cs b/src/Tasks/ManifestUtil/ComImporter.cs
index 084c04b607e..b4678e65365 100644
--- a/src/Tasks/ManifestUtil/ComImporter.cs
+++ b/src/Tasks/ManifestUtil/ComImporter.cs
@@ -125,7 +125,7 @@ public ComImporter(string path, OutputMessageCollection outputMessages, string o
 
         private void CheckForUnknownSubKeys(RegistryKey key)
         {
-            CheckForUnknownSubKeys(key, Array.Empty<string>());
+            CheckForUnknownSubKeys(key, []);
         }
 
         private void CheckForUnknownSubKeys(RegistryKey key, string[] knownNames)
@@ -144,7 +144,7 @@ private void CheckForUnknownSubKeys(RegistryKey key, string[] knownNames)
 
         private void CheckForUnknownValues(RegistryKey key)
         {
-            CheckForUnknownValues(key, Array.Empty<string>());
+            CheckForUnknownValues(key, []);
         }
 
         private void CheckForUnknownValues(RegistryKey key, string[] knownNames)
@@ -230,7 +230,7 @@ private bool GetRegisteredClassInfo(RegistryKey rootKey, Guid clsid, ref ClassIn
                     registeredPath = (string)subKey.GetValue(null);
                     threadingModel = (string)subKey.GetValue("ThreadingModel");
                     CheckForUnknownSubKeys(subKey);
-                    CheckForUnknownValues(subKey, new string[] { "ThreadingModel" });
+                    CheckForUnknownValues(subKey, ["ThreadingModel"]);
                 }
                 else if (String.Equals(subKeyName, "ProgID", StringComparison.OrdinalIgnoreCase))
                 {
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index b49395de0d6..a737ed59012 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -255,7 +255,7 @@ private static XmlElement GetCurrentCLRPermissions(string targetZone)
                 Internet => SecurityZone.Internet,
                 _ => throw new ArgumentException(String.Empty /* no message */, nameof(targetZone)),
             };
-            var evidence = new Evidence(new EvidenceBase[] { new Zone(zone), new System.Runtime.Hosting.ActivationArguments(new System.ApplicationIdentity("")) }, null);
+            var evidence = new Evidence([new Zone(zone), new System.Runtime.Hosting.ActivationArguments(new System.ApplicationIdentity(""))], null);
 
             PermissionSet sandbox = SecurityManager.GetStandardSandbox(evidence);
             string resultInString = sandbox.ToString();
@@ -455,7 +455,7 @@ private static string[] XmlToIdentityList(XmlElement psElement)
             }
             else
             {
-                a = Array.Empty<string>();
+                a = [];
             }
             return a;
         }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index de91092b31e..a6f26407daf 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -684,7 +684,7 @@
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildFromSource)' != 'true'">
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildSourceOnly)' != 'true'">
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" PrivateAssets="all" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
diff --git a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
index 4e348de04aa..60045885791 100644
--- a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
@@ -384,6 +384,8 @@ using System.Reflection%3b
         <_ExplicitReference Include="$(FrameworkPathOverride)\mscorlib.dll" />
     </ItemGroup>
 
+    <Import Project="$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\ProjectServices\Microsoft.DesignTime.targets" Condition="'$(MSBuildRuntimeType)' == 'Full' and exists('$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\ProjectServices\Microsoft.DesignTime.targets')"/>
+
     <Import Project="$(CustomAfterMicrosoftCSharpTargets)" Condition="'$(CustomAfterMicrosoftCSharpTargets)' != '' and Exists('$(CustomAfterMicrosoftCSharpTargets)')" />
 
     <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.CSharp.targets\ImportAfter')"/>
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 59e9f6c1ba5..111880e1d30 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -1334,7 +1334,7 @@ private void InitializeEnum(String assemblyName)
                     }
                     else
                     {
-                        _gacDirectories = Array.Empty<string>();
+                        _gacDirectories = [];
                     }
                 }
             }
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index c46d663bbb7..e94588e4264 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -215,7 +215,7 @@ public AssemblyNameExtension RemapAssembly(AssemblyNameExtension extensionToRema
         public static RedistList GetFrameworkList20()
         {
             string frameworkVersion20Path = ToolLocationHelper.GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version20);
-            string[] redistListPaths = Array.Empty<string>();
+            string[] redistListPaths = [];
             if (frameworkVersion20Path != null)
             {
                 redistListPaths = RedistList.GetRedistListPathsFromDisk(frameworkVersion20Path);
@@ -255,7 +255,7 @@ public static RedistList GetFrameworkList35()
         /// </summary>
         public static RedistList GetRedistListFromPath(string path)
         {
-            string[] redistListPaths = (path == null) ? Array.Empty<string>() : GetRedistListPathsFromDisk(path);
+            string[] redistListPaths = (path == null) ? [] : GetRedistListPathsFromDisk(path);
 
             var assemblyTableInfos = new AssemblyTableInfo[redistListPaths.Length];
             for (int i = 0; i < redistListPaths.Length; ++i)
@@ -272,7 +272,7 @@ private static RedistList GetFrameworkListFromReferenceAssembliesPath(TargetDotN
 
             // On dogfood build machines, v3.5 is not formally installed, so this returns null.
             // We don't use redist lists in this case.
-            string[] redistListPaths = (referenceAssembliesPath == null) ? Array.Empty<string>() : GetRedistListPathsFromDisk(referenceAssembliesPath);
+            string[] redistListPaths = (referenceAssembliesPath == null) ? [] : GetRedistListPathsFromDisk(referenceAssembliesPath);
 
             var assemblyTableInfos = new AssemblyTableInfo[redistListPaths.Length];
             for (int i = 0; i < redistListPaths.Length; ++i)
@@ -317,7 +317,7 @@ public static string[] GetRedistListPathsFromDisk(string frameworkDirectory)
                 }
             }
 
-            return Array.Empty<string>();
+            return [];
         }
 
         /// <summary>
@@ -1067,7 +1067,7 @@ public string[] GetSubsetListPathsFromDisk(string frameworkDirectory)
                 }
             }
 
-            return Array.Empty<string>();
+            return [];
         }
         #endregion
     }
diff --git a/src/Tasks/ResGen.cs b/src/Tasks/ResGen.cs
index 614ed571685..4931ce4aa84 100644
--- a/src/Tasks/ResGen.cs
+++ b/src/Tasks/ResGen.cs
@@ -601,7 +601,7 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
                             else
                             {
                                 resGenArguments.AppendFileNamesIfNotNull(
-                                    new[] { inputFiles[i], outputFiles[i] },
+                                    [inputFiles[i], outputFiles[i]],
                                     ",");
                             }
                         }
@@ -616,7 +616,7 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
                     // append the strongly-typed resource details
                     resGenArguments.AppendSwitchIfNotNull(
                         "/str:",
-                        new[] { StronglyTypedLanguage, StronglyTypedNamespace, StronglyTypedClassName, StronglyTypedFileName },
+                        [StronglyTypedLanguage, StronglyTypedNamespace, StronglyTypedClassName, StronglyTypedFileName],
                         ",");
                 }
             }
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index b3a1bca439a..c8ba6d686f4 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -1297,7 +1297,7 @@ internal bool ResolveComReferencePia(ComReferenceInfo referenceInfo, string refN
         /// <returns></returns>
         internal IEnumerable<string> GetResolvedAssemblyReferenceItemSpecs()
         {
-            return (ResolvedAssemblyReferences == null) ? Array.Empty<string>() : ResolvedAssemblyReferences.Select(rar => rar.ItemSpec);
+            return (ResolvedAssemblyReferences == null) ? [] : ResolvedAssemblyReferences.Select(rar => rar.ItemSpec);
         }
 
         /// <summary>
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index f67cab5f410..80620581904 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -83,7 +83,7 @@ public string[] AdditionalSearchPaths
         public ITaskItem[] ContainedLooseEtcFiles { get; set; }
 
         private ITaskItem[] _nativeReferences;
-        private string[] _additionalSearchPaths = Array.Empty<string>();
+        private string[] _additionalSearchPaths = [];
         #endregion
 
         #region Nested classes
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index 0e458a48807..824bb439e46 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -561,7 +561,7 @@ internal SDKReference ParseSDKReference(ITaskItem referenceItem)
 
             if (!splitSuccessful)
             {
-                LogErrorOrWarning(new Tuple<string, object[]>("ResolveSDKReference.SDKReferenceIncorrectFormat", new object[] { referenceItem.ItemSpec }));
+                LogErrorOrWarning(new Tuple<string, object[]>("ResolveSDKReference.SDKReferenceIncorrectFormat", [referenceItem.ItemSpec]));
                 return null;
             }
 
@@ -613,7 +613,7 @@ private void LogResolution(SDKReference reference)
             else if (reference.ResolutionErrors == null || reference.ResolutionErrors.Count == 0)
             {
                 // We only want to say we could not find it if there were no other errors which would cause it not to be found
-                LogErrorOrWarning(new Tuple<string, object[]>("ResolveSDKReference.CouldNotResolveSDK", new object[] { reference.ReferenceItem.ItemSpec }));
+                LogErrorOrWarning(new Tuple<string, object[]>("ResolveSDKReference.CouldNotResolveSDK", [reference.ReferenceItem.ItemSpec]));
             }
 
             // Log warnings
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index 05c2e50efe6..29ca1ce275f 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -366,15 +366,15 @@ internal static string[] ParseResxFileRefString(string stringValue)
                 string[] parts = remainingString.Split(';');
                 if (parts.Length > 1)
                 {
-                    result = new string[] { fileName, parts[0], parts[1] };
+                    result = [fileName, parts[0], parts[1]];
                 }
                 else if (parts.Length > 0)
                 {
-                    result = new string[] { fileName, parts[0] };
+                    result = [fileName, parts[0]];
                 }
                 else
                 {
-                    result = new string[] { fileName };
+                    result = [fileName];
                 }
             }
             return result;
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 6498e9b0d72..e4d7888b40c 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -1102,8 +1102,8 @@
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="needs-review-translation">MSB3825: Prostředek „{0}“ typu „{1}“ je deserializován prostřednictvím BinaryFormatter za běhu. BinaryFormatter je zastaralý kvůli možným bezpečnostním rizikům a odebere se s .NET 9. Pokud ho chcete používat dál, nastavte vlastnost GenerateResourceWarnOnBinaryFormatterUse na false. 
-           Další informace: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <target state="translated">MSB3825: Prostředek {0} typu {1} může být deserializován přes BinaryFormatter za běhu. BinaryFormatter je zastaralý kvůli známým bezpečnostním rizikům a byl odebrán z rozhraní .NET 9+. Pokud ho chcete dál používat, nastavte vlastnost GenerateResourceWarnOnBinaryFormatterUse na false.
+           Další informace: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 3eb64739489..24f91f6a13f 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -1102,8 +1102,8 @@
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="needs-review-translation">MSB3825: Die Ressource "{0}" vom Typ "{1}" wird zur Laufzeit über BinaryFormatter deserialisiert. BinaryFormatter ist aufgrund möglicher Sicherheitsrisiken veraltet und wird mit .NET 9 entfernt. Wenn Sie sie weiterhin verwenden möchten, legen Sie die Eigenschaft "GenerateResourceWarnOnBinaryFormatterUse" auf "false" fest.
-           Weitere Informationen: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <target state="translated">MSB3825: Die Ressource "{0}" vom Typ "{1}" kann zur Laufzeit über BinaryFormatter deserialisiert werden. BinaryFormatter ist aufgrund bekannter Sicherheitsrisiken veraltet und wird aus .NET 9 und höher entfernt. Wenn Sie ihn weiterhin verwenden möchten, legen Sie die Eigenschaft "GenerateResourceWarnOnBinaryFormatterUse" auf "false" fest.
+           Weitere Informationen finden Sie unter: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 441855b7f7b..c51dcaf045a 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -1102,8 +1102,8 @@
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="needs-review-translation">MSB3825: El recurso "{0}" de tipo "{1}" se deserializa a través de BinaryFormatter en tiempo de ejecución. BinaryFormatter está en desuso debido a posibles riesgos de seguridad y se quitará con .NET 9. Si desea seguir usándola, establezca la propiedad "GenerateResourceWarnOnBinaryFormatterUse" en falso.
-           Más información: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <target state="translated">MSB3825: El recurso "{0}" del tipo "{1}" puede que se haya deserializado a través de BinaryFormatter en el tiempo de ejecución. BinaryFormatter está en desuso debido a riesgos de seguridad conocidos y se ha eliminado de .NET 9+. Si desea seguir usándolo, establezca la propiedad "GenerateResourceWarnOnBinaryFormatterUse" en false.
+           Más información: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index ac50dfb4d5e..97da601672e 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -1102,8 +1102,8 @@
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="needs-review-translation">MSB3825: La ressource «{0}» de type «{1}» est désérialisée via BinaryFormatter au moment de l’exécution. BinaryFormatter est déconseillé en raison de risques de sécurité possibles et sera supprimé avec .NET 9. Si vous souhaitez continuer à l’utiliser, définissez la propriété « GenerateResourceWarnOnBinaryFormatterUse » sur false.
-           Plus d’informations : https://aka.ms/msbuild/net8-binaryformatter</target>
+        <target state="translated">MSB3825: La ressource « {0} » de type « {1} » peut être désérialisée via BinaryFormatter lors de l'exécution. BinaryFormatter est obsolète en raison de risques de sécurité connus et est supprimé de .NET 9+. Si vous souhaitez continuer à l'utiliser, définissez la propriété « GenerateResourceWarnOnBinaryFormatterUse » sur false.
+           Plus d'informations : https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index b9746371bea..931335b4567 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -1102,8 +1102,8 @@
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="needs-review-translation">MSB3825: la risorsa "{0}" di tipo "{1}" viene deserializzata tramite BinaryFormatter in fase di esecuzione. BinaryFormatter è deprecato a causa di possibili rischi per la sicurezza e verrà rimosso con .NET 9. Per continuare a utilizzarla, impostare la proprietà "GenerateResourceWarnOnBinaryFormatterUse" su false.
-           Altre informazioni: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <target state="translated">MSB3825: la risorsa "{0}" di tipo "{1}" può essere deserializzata tramite BinaryFormatter in fase di esecuzione. BinaryFormatter è deprecato a causa di rischi noti per la sicurezza ed è stato rimosso da .NET 9+. Se si desidera continuare a usarlo, impostare la proprietà "GenerateResourceWarnOnBinaryFormatterUse" su false.
+           Altre informazioni: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 84f8419d127..14d2d33a370 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -1102,8 +1102,8 @@
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="needs-review-translation">MSB3825: "{0}" 型のリソース "{1}" は、実行時に BinaryFormatter を介して逆シリアル化されます。BinaryFormatter は、セキュリティ上のリスクが発生する可能性があるため非推奨であり、.NET 9 を使用して削除されます。引き続き使用する場合は、プロパティ "GenerateResourceWarnOnBinaryFormatterUse" を false に設定してください。
-           詳細情報: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <target state="translated">MSB3825: 実行時に BinaryFormatter を使用して、型が "{1}" のリソース "{0}" が逆シリアル化されている可能性があります。BinaryFormatter は、既知のセキュリティ リスクにより非推奨となり、.NET 9 以降では削除されます。引き続き使用する場合は、プロパティ "GenerateResourceWarnOnBinaryFormatterUse" を false に設定します。
+           詳細情報: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 52206460b68..8200d6303e3 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -1102,8 +1102,8 @@
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="needs-review-translation">MSB3825: "{1}" 유형의 "{0}" 리소스가 런타임 시 BinaryFormatter를 통해 역직렬화됩니다. BinaryFormatter는 가능한 보안 위험으로 인해 사용되지 않으며 .NET 9에서 제거됩니다. 계속 사용하려면 "GenerateResourceWarnOnBinaryFormatterUse" 속성을 false로 설정하세요.
-            추가 정보: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <target state="translated">MSB3825: "{1}" 형식의 리소스 "{0}"은(는) 런타임 시 BinaryFormatter를 통해 역직렬화될 수 있습니다. BinaryFormatter는 알려진 보안 위험으로 인해 사용되지 않으며 .NET 9 이상에서 제거됩니다. 계속 사용하려면 "GenerateResourceWarnOnBinaryFormatterUse" 속성을 false로 설정합니다.
+           추가 정보: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index b3014585c6a..ffa383198a1 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -1102,8 +1102,8 @@
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="needs-review-translation">MSB3825: zasób „{0}” typu „{1}” jest deserializowany za pośrednictwem elementu BinaryFormatter w czasie wykonywania. Element BinaryFormatter jest przestarzały z powodu możliwych zagrożeń bezpieczeństwa i zostanie usunięty z platformy .NET 9. Jeśli chcesz nadal go używać, ustaw właściwość „GenerateResourceWarnOnBinaryFormatterUse” na wartość false.
-           Więcej informacji: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <target state="translated">MSB3825: zasób „{0}” typu „{1}” może być deserializowany za pośrednictwem elementu BinaryFormatter w czasie wykonywania. Element BinaryFormatter jest przestarzały ze względu na znane zagrożenia bezpieczeństwa i został usunięty z platformy .NET 9 lub nowszej. Jeśli chcesz nadal go używać, ustaw właściwość „GenerateResourceWarnOnBinaryFormatterUse” na false.
+           Więcej informacji: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 136a7033376..b1fbdae6b1e 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -1102,8 +1102,8 @@
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="needs-review-translation">MSB3825: o recurso "{0}" do tipo "{1}" é desserializado por meio de BinaryFormatter no runtime. O BinaryFormatter foi preterido devido a possíveis riscos de segurança e será removido com o .NET 9. Se você quiser continuar a usá-lo, defina a propriedade "GenerateResourceWarnOnBinaryFormatterUse" como false.
-           Mais informações: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <target state="translated">MSB3825: O recurso "{0}" do tipo "{1}" pode ser desserializado via BinaryFormatter em tempo de execução. O BinaryFormatter foi preterido devido a riscos de segurança conhecidos e foi removido do .NET 9+. Se desejar continuar usando, defina a propriedade "GenerateResourceWarnOnBinaryFormatterUse" como false.
+           Mais informações: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index a93243bcf42..7dd8f4c5939 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -1102,8 +1102,8 @@
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="needs-review-translation">MSB3825: ресурс "{0}" с типом "{1}" десериализуется с помощью BinaryFormatter во время выполнения. BinaryFormatter является устаревшим в связи с возможными угрозами безопасности и будет удален с .NET 9. Чтобы продолжить использование, задайте свойству "GenerateResourceWarnOnBinaryFormatterUse" значение "false".
-           Дополнительные сведения: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <target state="translated">MSB3825: для ресурса "{0}" с типом "{1}" может быть выполнена десериализация с помощью BinaryFormatter во время выполнения. BinaryFormatter является нерекомендуемым из-за известных рисков безопасности и удален из .NET 9+. Если вы хотите продолжить использовать его, задайте для свойства GenerateResourceWarnOnBinaryFormatterUse значение false.
+           Дополнительные сведения см. в руководстве по миграции по ссылке https://aka.ms/binaryformatter.</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index ab3c2f4fd29..ffec1acd85d 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -1102,8 +1102,8 @@
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="needs-review-translation">MSB3825: "{1}" türündeki "{0}" kaynağı, çalışma zamanında BinaryFormatter aracılığıyla seri durumdan çıkarılır. BinaryFormatter, olası güvenlik riskleri nedeniyle kullanım dışı bırakıldı ve .NET 9 ile kaldırılacak. Kullanmaya devam etmek istiyorsanız, "GenerateResourceWarnOnBinaryFormatterUse" özelliğini false olarak ayarlayın.
-           Daha fazla bilgi: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <target state="translated">MSB3825: "{1}" türündeki "{0}" kaynağı çalışma zamanında BinaryFormatter aracılığıyla seri duruma getiriliyor olabilir. BinaryFormatter, bilinen güvenlik riskleri nedeniyle kullanım dışıdır ve .NET 9+'dan kaldırılır. Kullanmaya devam etmek istiyorsanız "GenerateResourceWarnOnBinaryFormatterUse" özelliğini false olarak ayarlayın.
+           Daha fazla bilgi için bkz. https://aka.ms/binaryformatter-migration-guide.</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 1c8df7d808a..230cd56322d 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -1102,8 +1102,8 @@
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="needs-review-translation">MSB3825: “{1}”类型的资源“{0}”在运行时通过 BinaryFormatter 进行反序列化。由于可能存在安全风险，BinaryFormatter 已被弃用，并将使用 .NET 9 移除它。如果要继续使用它，请将属性 "GenerateResourceWarnOnBinaryFormatterUse" 设置为 false。
-           详细信息: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <target state="translated">MSB3825: 可在运行时通过 BinaryFormatter 反序列化类型为“{1}”的资源“{0}”。由于已知的安全风险，BinaryFormatter 已被弃用，并从 .NET 9+ 中删除。如果要继续使用它，请将属性“GenerateResourceWarnOnBinaryFormatterUse”设置为 false。
+           有关详细信息，请参阅：https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 71a4f18684d..e76b7fe1b2b 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -1102,8 +1102,8 @@
       <trans-unit id="GenerateResource.BinaryFormatterUse">
         <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="needs-review-translation">MSB3825: 類型 "{1}" 的資源 "{0}" 在執行階段透過 BinaryFormatter 還原序列化。BinaryFormatter 已因可能的安全性風險而被取代，並將隨著 .NET 9 移除。如果您要繼續使用它，請將屬性 "GenerateResourceWarnOnBinaryFormatterUse" 設定為 false。
-           詳細資訊: https://aka.ms/msbuild/net8-binaryformatter</target>
+        <target state="translated">MSB3825: 在執行階段，可能會透過 BinaryFormatter 將類型為「{1}」的資源「{0}」取消初始化。BinaryFormatter 已因已知的安全性風險而被棄用，且已從 .NET 9+ 中移除。如果您想要繼續使用它，請將屬性 "GenerateResourceWarnOnBinaryFormatterUse" 設為 false。
+           詳細資訊: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 7989a98917a..b2bac7f674a 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -737,7 +737,7 @@ private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTask
                     managedCompiler.Optimize = false;
                     managedCompiler.OutputAssembly = new TaskItem(assemblyPath);
                     managedCompiler.References = references;
-                    managedCompiler.Sources = new ITaskItem[] { new TaskItem(sourceCodePath) };
+                    managedCompiler.Sources = [new TaskItem(sourceCodePath)];
                     managedCompiler.TargetType = "Library";
                     managedCompiler.UseSharedCompilation = false;
 
diff --git a/src/Tasks/SGen.cs b/src/Tasks/SGen.cs
index 743cbf2eaf8..7be17cf5dc2 100644
--- a/src/Tasks/SGen.cs
+++ b/src/Tasks/SGen.cs
@@ -365,7 +365,7 @@ protected override string GenerateCommandLineCommands()
                 {
                     Debug.Assert(ShouldGenerateSerializer, "GenerateCommandLineCommands() should not be called if ShouldGenerateSerializer is true and SerializationAssembly is null.");
 
-                    SerializationAssembly = new ITaskItem[] { new TaskItem(SerializationAssemblyPath) };
+                    SerializationAssembly = [new TaskItem(SerializationAssemblyPath)];
                 }
 
                 // Add the assembly switch
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index 7e1e971b48d..e44fbf5f2bf 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -102,7 +102,7 @@ internal static T DeserializeCache<T>(string stateFile, TaskLoggingHelper log) w
                             var parameters = constructor.GetParameters();
                             if (parameters.Length == 1 && parameters[0].ParameterType == typeof(ITranslator))
                             {
-                                retVal = constructor.Invoke(new object[] { translator }) as T;
+                                retVal = constructor.Invoke([translator]) as T;
                             }
                         }
 
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index ff6a99fbd48..690308135f0 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -231,7 +231,33 @@ private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirector
                 {
                     Log.LogMessageFromResources(MessageImportance.Normal, "Unzip.FileComment", zipArchiveEntry.FullName, destinationPath.FullName);
 
+#if NET
+                    FileStreamOptions fileStreamOptions = new()
+                    {
+                        Access = FileAccess.Write,
+                        Mode = FileMode.Create,
+                        Share = FileShare.None,
+                        BufferSize = 0x1000
+                    };
+
+                    const UnixFileMode OwnershipPermissions =
+                        UnixFileMode.UserRead | UnixFileMode.UserWrite | UnixFileMode.UserExecute |
+                        UnixFileMode.GroupRead | UnixFileMode.GroupWrite | UnixFileMode.GroupExecute |
+                        UnixFileMode.OtherRead | UnixFileMode.OtherWrite | UnixFileMode.OtherExecute;
+
+                    // Restore Unix permissions.
+                    // For security, limit to ownership permissions, and respect umask (through UnixCreateMode).
+                    // We don't apply UnixFileMode.None because .zip files created on Windows and .zip files created
+                    // with previous versions of .NET don't include permissions.
+                    UnixFileMode mode = (UnixFileMode)(zipArchiveEntry.ExternalAttributes >> 16) & OwnershipPermissions;
+                    if (mode != UnixFileMode.None && !NativeMethodsShared.IsWindows)
+                    {
+                        fileStreamOptions.UnixCreateMode = mode;
+                    }
+                    using (FileStream destination = new FileStream(destinationPath.FullName, fileStreamOptions))
+#else
                     using (Stream destination = File.Open(destinationPath.FullName, FileMode.Create, FileAccess.Write, FileShare.None))
+#endif
                     using (Stream stream = zipArchiveEntry.Open())
                     {
                         stream.CopyToAsync(destination, _DefaultCopyBufferSize, _cancellationToken.Token)
@@ -293,7 +319,7 @@ private void ParseIncludeExclude()
 
         private void ParsePattern(string pattern, out string[] patterns)
         {
-            patterns = Array.Empty<string>();
+            patterns = [];
             if (!string.IsNullOrWhiteSpace(pattern))
             {
                 if (FileMatcher.HasPropertyOrItemReferences(pattern))
@@ -308,8 +334,8 @@ private void ParsePattern(string pattern, out string[] patterns)
                 else
                 {
                     patterns = pattern.Contains(';')
-                                   ? pattern.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries).Select(FileMatcher.Normalize).ToArray()
-                                   : new[] { pattern };
+                                   ? pattern.Split([';'], StringSplitOptions.RemoveEmptyEntries).Select(FileMatcher.Normalize).ToArray()
+                                   : [pattern];
                 }
             }
         }
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index 79efdf61495..ecfe9bad0d6 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -34,7 +34,7 @@ public class WriteCodeFragment : TaskExtension
     {
         private const string TypeNameSuffix = "_TypeName";
         private const string IsLiteralSuffix = "_IsLiteral";
-        private static readonly IEnumerable<string> NamespaceImports = new string[] { "System", "System.Reflection" };
+        private static readonly string[] NamespaceImports = ["System", "System.Reflection"];
         private static readonly IReadOnlyDictionary<string, ParameterType> EmptyParameterTypes = new Dictionary<string, ParameterType>();
 
         /// <summary>
diff --git a/src/Tasks/XamlTaskFactory/TaskGenerator.cs b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
index 38a2a4562e5..83d45753651 100644
--- a/src/Tasks/XamlTaskFactory/TaskGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
@@ -765,19 +765,19 @@ private void GenerateIntegers(Property property, CodeMemberProperty propertyName
             string name = property.SwitchName != String.Empty ? property.Prefix + property.SwitchName : property.Name;
             if (!String.IsNullOrEmpty(property.Min) && !String.IsNullOrEmpty(property.Max))
             {
-                parameters = new CodeExpression[] { new CodeSnippetExpression(SurroundWithQuotes(name)), new CodePrimitiveExpression(Int32.Parse(property.Min, CultureInfo.CurrentCulture)), new CodePrimitiveExpression(Int32.Parse(property.Max, CultureInfo.CurrentCulture)), new CodePropertySetValueReferenceExpression() };
+                parameters = [new CodeSnippetExpression(SurroundWithQuotes(name)), new CodePrimitiveExpression(Int32.Parse(property.Min, CultureInfo.CurrentCulture)), new CodePrimitiveExpression(Int32.Parse(property.Max, CultureInfo.CurrentCulture)), new CodePropertySetValueReferenceExpression()];
             }
             else if (!String.IsNullOrEmpty(property.Min))
             {
-                parameters = new CodeExpression[] { new CodeSnippetExpression(SurroundWithQuotes(name)), new CodePrimitiveExpression(Int32.Parse(property.Min, CultureInfo.CurrentCulture)), new CodeSnippetExpression("Int32.MaxValue"), new CodePropertySetValueReferenceExpression() };
+                parameters = [new CodeSnippetExpression(SurroundWithQuotes(name)), new CodePrimitiveExpression(Int32.Parse(property.Min, CultureInfo.CurrentCulture)), new CodeSnippetExpression("Int32.MaxValue"), new CodePropertySetValueReferenceExpression()];
             }
             else if (!String.IsNullOrEmpty(property.Max))
             {
-                parameters = new CodeExpression[] { new CodeSnippetExpression(SurroundWithQuotes(name)), new CodeSnippetExpression("Int32.MinValue"), new CodePrimitiveExpression(Int32.Parse(property.Max, CultureInfo.CurrentCulture)), new CodePropertySetValueReferenceExpression() };
+                parameters = [new CodeSnippetExpression(SurroundWithQuotes(name)), new CodeSnippetExpression("Int32.MinValue"), new CodePrimitiveExpression(Int32.Parse(property.Max, CultureInfo.CurrentCulture)), new CodePropertySetValueReferenceExpression()];
             }
             else
             {
-                parameters = new CodeExpression[] { new CodeSnippetExpression(SurroundWithQuotes(name)), new CodeSnippetExpression("Int32.MinValue"), new CodeSnippetExpression("Int32.MaxValue"), new CodePropertySetValueReferenceExpression() };
+                parameters = [new CodeSnippetExpression(SurroundWithQuotes(name)), new CodeSnippetExpression("Int32.MinValue"), new CodeSnippetExpression("Int32.MaxValue"), new CodePropertySetValueReferenceExpression()];
             }
 
             var validateInt = new CodeMethodReferenceExpression(new CodeThisReferenceExpression(), ValidateIntegerMethod);
@@ -896,9 +896,9 @@ private void GenerateStrings(Property property, CodeMemberProperty propertyName)
                     // The condition to test.
                     new CodeVariableReferenceExpression("i >= 0"),
                     // The statements to execute if the condition evaluates to true.
-                    new CodeStatement[] { setToolSwitchNameGoodIndex, setArgumentsGoodIndex },
+                    [setToolSwitchNameGoodIndex, setArgumentsGoodIndex],
                     // The statements to execute if the condition evalues to false.
-                    new CodeStatement[] { setToolSwitchNameBadIndex, setArgumentsBadIndex });
+                    [setToolSwitchNameBadIndex, setArgumentsBadIndex]);
 
                 propertyName.SetStatements.Add(conditionalStatement);
                 // Set the separator
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index 342fb1f30b2..b2823627ffd 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -118,13 +118,12 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
             // create the code generator options
             // Since we are running msbuild 12.0 these had better load.
             var compilerParameters = new CompilerParameters(
-                new[]
-                {
+                [
                     "System.dll",
                     Path.Combine(pathToMSBuildBinaries, "Microsoft.Build.Framework.dll"),
                     Path.Combine(pathToMSBuildBinaries, "Microsoft.Build.Utilities.Core.dll"),
                     Path.Combine(pathToMSBuildBinaries, "Microsoft.Build.Tasks.Core.dll")
-                })
+                ])
             {
                 GenerateInMemory = true,
                 TreatWarningsAsErrors = false
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index f55532b9546..dd15d64cea9 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -292,7 +292,7 @@ public XmlInput(ITaskItem[] xmlFile, string xml)
                 else
                 {
                     XmlMode = XmlModes.Xml;
-                    _data = new[] { xml };
+                    _data = [xml];
                 }
             }
 
diff --git a/src/Tasks/system.design/stronglytypedresourcebuilder.cs b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
index 6f6bf7f491e..c43ddc11ad1 100644
--- a/src/Tasks/system.design/stronglytypedresourcebuilder.cs
+++ b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
@@ -71,10 +71,10 @@ internal static class StronglyTypedResourceBuilder
 
         // When fixing up identifiers, we will replace all these chars with
         // a single char that is valid in identifiers, such as '_'.
-        private static readonly char[] s_charsToReplace = new char[] { ' ',
+        private static readonly char[] s_charsToReplace = [' ',
         '\u00A0' /* non-breaking space */, '.', ',', ';', '|', '~', '@',
         '#', '%', '^', '&', '*', '+', '-', '/', '\\', '<', '>', '?', '[',
-        ']', '(', ')', '{', '}', '\"', '\'', ':', '!' };
+        ']', '(', ')', '{', '}', '\"', '\'', ':', '!'];
         private const char ReplacementChar = '_';
 
         private const String DocCommentSummaryStart = "<summary>";
diff --git a/src/UnitTests.Shared/MockLogger.cs b/src/UnitTests.Shared/MockLogger.cs
index b530cc538f0..c07a43b58a5 100644
--- a/src/UnitTests.Shared/MockLogger.cs
+++ b/src/UnitTests.Shared/MockLogger.cs
@@ -538,7 +538,7 @@ public void AssertLogDoesntContain(string contains)
                         PrintFullLog();
                     }
 
-                    Assert.True(false, $"Log was not expected to contain '{contains}', but did.");
+                    Assert.Fail($"Log was not expected to contain '{contains}', but did.");
                 }
             }
         }
diff --git a/src/UnitTests.Shared/ObjectModelHelpers.cs b/src/UnitTests.Shared/ObjectModelHelpers.cs
index 48f0f504b59..1d560f54315 100644
--- a/src/UnitTests.Shared/ObjectModelHelpers.cs
+++ b/src/UnitTests.Shared/ObjectModelHelpers.cs
@@ -442,7 +442,7 @@ public static void AssertItemsMatch(string expectedItemsString, ITaskItem[] actu
             // Log an error for any leftover items in the expectedItems collection.
             foreach (ITaskItem expectedItem in expectedItems)
             {
-                Assert.True(false, string.Format("Item '{0}' was expected but not returned.", expectedItem.ItemSpec));
+                Assert.Fail(string.Format("Item '{0}' was expected but not returned.", expectedItem.ItemSpec));
             }
 
             if (outOfOrder)
@@ -450,7 +450,7 @@ public static void AssertItemsMatch(string expectedItemsString, ITaskItem[] actu
                 Console.WriteLine("ERROR:  Items were returned in the incorrect order...");
                 Console.WriteLine("Expected:  " + expectedItemSpecs);
                 Console.WriteLine("Actual:    " + actualItemSpecs);
-                Assert.True(false, "Items were returned in the incorrect order.  See 'Standard Out' tab for more details.");
+                Assert.Fail("Items were returned in the incorrect order.  See 'Standard Out' tab for more details.");
             }
         }
 
@@ -1150,7 +1150,7 @@ public static string GetOSPlatformAsString()
             }
             else
             {
-                Assert.True(false, "unrecognized current platform");
+                Assert.Fail("unrecognized current platform");
             }
 
             return currentPlatformString;
@@ -1896,7 +1896,7 @@ public static void VerifyAssertThrowsSameWay(Action method1, Action method2)
 
             if (ex1 == null && ex2 == null)
             {
-                Assert.True(false, "Neither threw");
+                Assert.Fail("Neither threw");
             }
 
             Assert.NotNull(ex1); // "First method did not throw, second: {0}", ex2 == null ? "" : ex2.GetType() + ex2.Message);
@@ -1954,7 +1954,7 @@ public static void VerifyAssertLineByLine(string expected, string actual, bool i
                 string output = "\r\n#################################Expected#################################\n" + string.Join("\r\n", expectedLines);
                 output += "\r\n#################################Actual#################################\n" + string.Join("\r\n", actualLines);
 
-                Assert.True(false, output);
+                Assert.Fail(output);
             }
 
             if (actualLines.Length > expectedLines.Length)
@@ -1962,14 +1962,14 @@ public static void VerifyAssertLineByLine(string expected, string actual, bool i
                 LogLine("\n#################################Expected#################################\n" + string.Join("\n", expectedLines));
                 LogLine("#################################Actual#################################\n" + string.Join("\n", actualLines));
 
-                Assert.True(false, "Expected content was shorter, actual had this extra line: '" + actualLines[expectedLines.Length] + "'");
+                Assert.Fail("Expected content was shorter, actual had this extra line: '" + actualLines[expectedLines.Length] + "'");
             }
             else if (actualLines.Length < expectedLines.Length)
             {
                 LogLine("\n#################################Expected#################################\n" + string.Join("\n", expectedLines));
                 LogLine("#################################Actual#################################\n" + string.Join("\n", actualLines));
 
-                Assert.True(false, "Actual content was shorter, expected had this extra line: '" + expectedLines[actualLines.Length] + "'");
+                Assert.Fail("Actual content was shorter, expected had this extra line: '" + expectedLines[actualLines.Length] + "'");
             }
         }
 
diff --git a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
index d491a5a0469..1bcad909332 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
@@ -2526,7 +2526,7 @@ public static void AssertDidntFindStringInTLog(string file, string tlog)
             {
                 if (file.Equals(lines[i], StringComparison.OrdinalIgnoreCase))
                 {
-                    Assert.True(false, "Found string '" + file + "' in '" + tlog + "' at line " + i + ", when it shouldn't have been in the log at all.");
+                    Assert.Fail("Found string '" + file + "' in '" + tlog + "' at line " + i + ", when it shouldn't have been in the log at all.");
                 }
             }
         }
@@ -2551,7 +2551,7 @@ public static void AssertFoundStringInTLog(string file, string tlog, int timesFo
 
             if (timesFound != timesFoundSoFar)
             {
-                Assert.True(false, "Searched " + tlog + " but didn't find " + timesFound + " instances of " + file);
+                Assert.Fail("Searched " + tlog + " but didn't find " + timesFound + " instances of " + file);
             }
         }
 
diff --git a/src/Utilities/CompatibilitySuppressions.xml b/src/Utilities/CompatibilitySuppressions.xml
index 6e9b7a42dea..eeee8bb3f8a 100644
--- a/src/Utilities/CompatibilitySuppressions.xml
+++ b/src/Utilities/CompatibilitySuppressions.xml
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
+<!-- https://learn.microsoft.com/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
        This is intentional, because you can only use MSBuild in the context of a .NET SDK
@@ -54,57 +54,4 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
-  <!--
-  Since we are dropping the .net 8 and retarrgetting to .net 9, we need to suppress the following errors. 
-  The comparison ref/net.8 with ref/netstandard2.0 is not valid anymore.
-  -->
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Utilities.DotNetFrameworkArchitecture</Target>
-    <Left>ref/net8.0/Microsoft.Build.Utilities.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Utilities.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Utilities.HostObjectInitializationStatus</Target>
-    <Left>ref/net8.0/Microsoft.Build.Utilities.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Utilities.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Utilities.MultipleVersionSupport</Target>
-    <Left>ref/net8.0/Microsoft.Build.Utilities.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Utilities.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Utilities.SDKType</Target>
-    <Left>ref/net8.0/Microsoft.Build.Utilities.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Utilities.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Utilities.TargetDotNetFrameworkVersion</Target>
-    <Left>ref/net8.0/Microsoft.Build.Utilities.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Utilities.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Utilities.VisualStudioVersion</Target>
-    <Left>ref/net8.0/Microsoft.Build.Utilities.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Utilities.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <!--
-    https://learn.microsoft.com/en-us/dotnet/fundamentals/apicompat/diagnostic-ids
-    Suppress PKV006 for net8.0 (The target framework is dropped in the latest version.)  -->
-  <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net8.0</Target>
-  </Suppression>
-</Suppressions>
+</Suppressions>
\ No newline at end of file
diff --git a/src/Utilities/LockCheck.cs b/src/Utilities/LockCheck.cs
index c2de1dfaa65..7b191851e70 100644
--- a/src/Utilities/LockCheck.cs
+++ b/src/Utilities/LockCheck.cs
@@ -342,7 +342,7 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]
                         // If pnProcInfo == 0, then there is simply no locking process (found), in this case rgAffectedApps is "null".
                         if (pnProcInfo == 0)
                         {
-                            return Enumerable.Empty<ProcessInfo>();
+                            return [];
                         }
 
                         var lockInfos = new List<ProcessInfo>((int)pnProcInfo);
@@ -371,7 +371,7 @@ internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[]
                 }
             }
 
-            return Enumerable.Empty<ProcessInfo>();
+            return [];
         }
 
         private static Exception GetException(int res, string apiName, string message)
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 966c169c409..6b8153dbc9c 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -27,14 +27,14 @@
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETStandard' and '$(DotNetBuildFromSource)' != 'true'">
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETStandard' and '$(DotNetBuildSourceOnly)' != 'true'">
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" PrivateAssets="all" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
     <PackageReference Include="System.Text.Encoding.CodePages" />
   </ItemGroup>
-  
+
   <ItemGroup Label="Shared Code">
     <Compile Include="..\Shared\AssemblyFolders\AssemblyFoldersEx.cs">
       <Link>Shared\AssemblyFolders\AssemblyFoldersEx.cs</Link>
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index f4e818e278e..ab2c1fd9b9b 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.ComponentModel;
 using System.Linq;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security;
@@ -60,8 +61,12 @@ public sealed class TaskItem :
         #region Constructors
 
         /// <summary>
-        /// Default constructor -- we need it so this type is COM-createable.
+        /// Default constructor -- do not use.
         /// </summary>
+        /// <remarks>
+        /// This constructor exists only so that the type is COM-creatable. Prefer <see cref="TaskItem(string)"/>.
+        /// </remarks>
+        [EditorBrowsable(EditorBrowsableState.Never)]
         public TaskItem()
         {
             _itemSpec = string.Empty;
@@ -490,7 +495,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
         {
             if (_metadata == null)
             {
-                return Enumerable.Empty<KeyValuePair<string, string>>();
+                return [];
             }
 
             int count = _metadata.Count;
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 20510c33d8b..0ee514640fc 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -1060,7 +1060,7 @@ private static string[] GetLegacyTargetPlatformReferences(string targetPlatformI
                 ErrorUtilities.DebugTraceMessage("GetLegacyTargetPlatformReferences", "Encountered exception trying to gather the platform references: {0}", e.Message);
             }
 
-            return Array.Empty<string>();
+            return [];
         }
 
         /// <summary>
@@ -1081,7 +1081,7 @@ private static string[] GetTargetPlatformReferencesFromManifest(
             ErrorUtilities.VerifyThrowArgumentLength(targetPlatformIdentifier, nameof(targetPlatformIdentifier));
             ErrorUtilities.VerifyThrowArgumentLength(targetPlatformVersion, nameof(targetPlatformVersion));
 
-            string[] contractWinMDs = Array.Empty<string>();
+            string[] contractWinMDs = [];
 
             TargetPlatformSDK matchingSdk = GetMatchingPlatformSDK(targetPlatformIdentifier, targetPlatformVersion, diskRoots, null, registryRoot);
             string platformKey = TargetPlatformSDK.GetSdkKey(targetPlatformIdentifier, targetPlatformVersion);
@@ -1119,7 +1119,7 @@ internal static string[] GetApiContractReferences(IEnumerable<ApiContract> apiCo
         {
             if (apiContracts == null)
             {
-                return Array.Empty<string>();
+                return [];
             }
 
             var contractWinMDs = new List<string>();
@@ -2479,7 +2479,7 @@ private static IEnumerable<TargetPlatformSDK> RetrieveTargetPlatformList(string[
                         GatherExtensionSDKListFromDirectory(extensionSdkDiskRoots, extensionSdk);
                         s_cachedExtensionSdks.Add(cachedExtensionSdksKey, extensionSdk);
                     }
-                    collection = collection.Concat(new[] { extensionSdk });
+                    collection = collection.Concat([extensionSdk]);
                 }
 
                 return collection;
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index c196b0afcc8..ae2f672a390 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -127,7 +127,7 @@ public CanonicalTrackedInputFiles(ITask ownerTask, ITaskItem[] tlogFiles, ITaskI
         /// <param name="useMinimalRebuildOptimization">WARNING: Minimal rebuild optimization requires 100% accurate computed outputs to be specified!</param>
         /// <param name="maintainCompositeRootingMarkers">True to keep composite rooting markers around (many-to-one case) or false to shred them (one-to-one or one-to-many case)</param>
         public CanonicalTrackedInputFiles(ITask ownerTask, ITaskItem[] tlogFiles, ITaskItem sourceFile, ITaskItem[] excludedInputPaths, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers)
-            => InternalConstruct(ownerTask, tlogFiles, new[] { sourceFile }, null, excludedInputPaths, outputs, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);
+            => InternalConstruct(ownerTask, tlogFiles, [sourceFile], null, excludedInputPaths, outputs, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);
 
         /// <summary>
         /// Common internal constructor
@@ -930,7 +930,7 @@ public void SaveTlog(DependencyFilter includeInTLog)
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Source that should be removed from the graph</param>
-        public void RemoveEntriesForSource(ITaskItem source) => RemoveEntriesForSource(new[] { source });
+        public void RemoveEntriesForSource(ITaskItem source) => RemoveEntriesForSource([source]);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
@@ -1002,14 +1002,14 @@ private void RemoveDependencyFromEntry(string rootingMarker, ITaskItem dependenc
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Source that should be removed from the graph</param>
-        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source) => RemoveDependenciesFromEntryIfMissing(new ITaskItem[] { source }, null);
+        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source) => RemoveDependenciesFromEntryIfMissing([source], null);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Source that should be removed from the graph</param>
         /// <param name="correspondingOutput">Output that correspond ot the sources (used for same file processing)</param>
-        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput) => RemoveDependenciesFromEntryIfMissing(new[] { source }, new[] { correspondingOutput });
+        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput) => RemoveDependenciesFromEntryIfMissing([source], [correspondingOutput]);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index 5a94ceeb1ad..fad06ee59a9 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -617,14 +617,14 @@ public void SaveTlog(DependencyFilter includeInTLog)
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Sources that should be removed from the graph</param>
-        public void RemoveEntriesForSource(ITaskItem source) => RemoveEntriesForSource(new[] { source }, null);
+        public void RemoveEntriesForSource(ITaskItem source) => RemoveEntriesForSource([source], null);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Sources that should be removed from the graph</param>
         /// <param name="correspondingOutput">Outputs that correspond ot the sources (used for same file processing)</param>
-        public void RemoveEntriesForSource(ITaskItem source, ITaskItem correspondingOutput) => RemoveEntriesForSource(new[] { source }, new[] { correspondingOutput });
+        public void RemoveEntriesForSource(ITaskItem source, ITaskItem correspondingOutput) => RemoveEntriesForSource([source], [correspondingOutput]);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
@@ -696,14 +696,14 @@ private void RemoveDependencyFromEntry(string rootingMarker, ITaskItem dependenc
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Source that should be removed from the graph</param>
-        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source) => RemoveDependenciesFromEntryIfMissing(new[] { source }, null);
+        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source) => RemoveDependenciesFromEntryIfMissing([source], null);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
         /// </summary>
         /// <param name="source">Source that should be removed from the graph</param>
         /// <param name="correspondingOutput">Output that correspond ot the sources (used for same file processing)</param>
-        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput) => RemoveDependenciesFromEntryIfMissing(new[] { source }, new[] { correspondingOutput });
+        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput) => RemoveDependenciesFromEntryIfMissing([source], [correspondingOutput]);
 
         /// <summary>
         /// Remove the output graph entries for the given sources and corresponding outputs
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index be62498f6ee..f3db3169e4f 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -284,14 +284,14 @@ public static bool FileIsUnderPath(string fileName, string path)
         /// Construct a rooting marker string from the ITaskItem array of primary sources.
         /// </summary>
         /// <param name="source">An <see cref="ITaskItem"/> containing information about the primary source.</param>
-        public static string FormatRootingMarker(ITaskItem source) => FormatRootingMarker(new[] { source }, null);
+        public static string FormatRootingMarker(ITaskItem source) => FormatRootingMarker([source], null);
 
         /// <summary>
         /// Construct a rooting marker string from the ITaskItem array of primary sources.
         /// </summary>
         /// <param name="source">An <see cref="ITaskItem"/> containing information about the primary source.</param>
         /// <param name="output">An <see cref="ITaskItem"/> containing information about the output.</param>
-        public static string FormatRootingMarker(ITaskItem source, ITaskItem output) => FormatRootingMarker(new[] { source }, new[] { output });
+        public static string FormatRootingMarker(ITaskItem source, ITaskItem output) => FormatRootingMarker([source], [output]);
 
         /// <summary>
         /// Construct a rooting marker string from the ITaskItem array of primary sources.
diff --git a/template_feed/README.md b/template_feed/README.md
index f6bd358ffcd..502b0245caf 100644
--- a/template_feed/README.md
+++ b/template_feed/README.md
@@ -1,9 +1,10 @@
 ## MSBuild Custom Check Template Package
 
 The package contains the template designed to streamline the creation of MSBuild check libraries.
-| Template name | Short name | Description|
-|---|---|---|
-|MSBuild Custom Check Template|`msbuildcheck`|A project for creating a MSBuild check library that targets .NET Standard.|
+
+| Template name | Short name | Description |
+| --- | --- | --- |
+| MSBuild Custom Check Template | `msbuildcheck` | A project for creating a MSBuild check library that targets .NET Standard. |
 
 The package is available for download from nuget.org.
 Please feel to contribute or provide the feedback in discussions or via opening the issue in dotnet/msbuild repo.
diff --git a/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
index 3647f61a8dc..c3b83f0c8e8 100644
--- a/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
+++ b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
@@ -27,7 +27,7 @@
       "type": "parameter",
       "description": "Overrides the default Microsoft.Build version where check's interfaces are placed",
       "datatype": "text",
-      "defaultValue": "17.12.0",
+      "defaultValue": "17.13.0",
       "replaces": "1.0.0-MicrosoftBuildPackageVersion",
       "displayName": "Microsoft.Build default package version override"
     }
diff --git a/template_feed/content/Microsoft.CheckTemplate/Directory.Packages.props b/template_feed/content/Microsoft.CheckTemplate/Directory.Packages.props
index c6d3f5fb1e5..92c952cfd3d 100644
--- a/template_feed/content/Microsoft.CheckTemplate/Directory.Packages.props
+++ b/template_feed/content/Microsoft.CheckTemplate/Directory.Packages.props
@@ -1,6 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Project>
+  <PropertyGroup>
+    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
+  </PropertyGroup>
   <ItemGroup>
     <PackageVersion Include="Microsoft.Build" Version="1.0.0-MicrosoftBuildPackageVersion" />
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
