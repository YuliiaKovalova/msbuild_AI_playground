diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 1c28b3bf2ca..661671069c9 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -96,9 +96,8 @@ stages:
       value: Products/$(System.TeamProject)/$(Build.Repository.Name)/$(Build.SourceBranchName)/$(Build.BuildNumber)
 
     steps:
-    - task: NuGetToolInstaller@0
-      inputs:
-        versionSpec: '4.9.2'
+    - task: NuGetToolInstaller@1
+      displayName: 'Install NuGet.exe'
 
     - task: NuGetCommand@2
       displayName: Restore internal tools
diff --git a/documentation/specs/project-cache.md b/documentation/specs/project-cache.md
index 7c3a2fad63a..b0ce961313d 100644
--- a/documentation/specs/project-cache.md
+++ b/documentation/specs/project-cache.md
@@ -1,10 +1,10 @@
 # Summary
 
-Project cache is a new assembly-based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and/or distribution](https://github.com/dotnet/msbuild/blob/main/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).
+Project cache is a new assembly-based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and/or distribution](static-graph.md#weakness-of-the-old-model-caching-and-distributability).
 
 # Motivation
 
-As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/main/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, large and complex repos expose the weaknesses in MSBuild's scheduling and incrementality models as build times elongate. This project cache plugin lets MSBuild natively communicate with existing tools that enable build caching and/or distribution, enabling true scalability.
+As the introduction to [static graph](static-graph.md#what-is-static-graph-for) suggests, large and complex repos expose the weaknesses in MSBuild's scheduling and incrementality models as build times elongate. This project cache plugin lets MSBuild natively communicate with existing tools that enable build caching and/or distribution, enabling true scalability.
 
 Visual Studio is one beneficiary. This plugin inverts dependencies among build systems: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild calls into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.
 
@@ -14,106 +14,185 @@ This change also simplifies and unifies user experiences. MSBuild works the same
 
 - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:
   - it makes the filesystem look as if the project built
-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.
+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.
 
 # High-level design
-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.
-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.
-- If the plugin decides to build, then MSBuild proceeds building the project as usual.
-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.
-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.
+
+Conceptually, there are two parts of caching: "cache get" and "cache add". "Cache get" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. "Cache add" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin to add the results to its cache and safely be able to retrieve it for some future build.
+
+The "cache get" functionality was introduced in 16.9, while "cache add" was added in 17.8.
+
+## Plugin discovery
+
 - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).
   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.
   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.
-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.
-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.
-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the "graph" when static graph is not available).
-- A single plugin is supported (for now).
-
-# APIs and calling patterns
-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).
-
-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.
-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.
-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.
-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.
-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.
-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.
-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.
-
-## From command line
-- Requires /graph. It is the easiest way to implement the plugin:
-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.
-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.
-- User calls msbuild /graph.
-- MSBuild constructs the static graph.
-- The graph builder finds and loads the plugin into the `BuildManager`.
-  - Each graph node has a ProjectInstance, which is used to search for the plugin.
-  - If a project defines a plugin, then all projects in the graph must define that same plugin.
-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).
-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.
-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.
-
-## From Visual Studio, a temporary workaround
-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:
-  - The workaround logic activates only when MSBuild detects that it's running under VS.
-  - Plugin discovery
-    - When VS evaluates projects via "new Project(..)" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.
-  - Plugin usage:
-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.
-
-# Details
-- Plugin discovery
-  - Each project defines an item containing the path to the plugin DLL:
 ```xml
-<ProjectCachePlugin Include="..\..\QuickbuildProjectCachePlugin.dll">
+<ItemGroup>
+  <ProjectCachePlugin Include="$(SomePath)\MyAmazingCachePlugin.dll" />
+</ItemGroup>
 ```
-- Plugin acquisition
-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.
-- Defining the "graph" when static graph is not available
-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.
-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.
-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.
-- Returning a valid BuildResult object on cache hits.
-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).
+- Programmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.
+
+## Plugin lifetime
+
+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.
+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a "fire-and-forget" call at this point. The first query on the plugin will wait for plugin initialization.
+  - `BeginBuildAsync` may be called with or without a `ProjectGraph`, depending on MSBuild has one to provide. When it is not provided, hints about the graph entry points are provided with which the plugin may decide to construct the `ProjectGraph` itself, if desired.
+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before the build can complete.
+- The plugin instance will get called in reverse topological sort order (from referenced projects up towards referencing projects). This happens when performing a graph build (`/graph`), Visual Studio solution builds, and commonly in higher build engines.
+- Only the top-level build requests are checked against the cache. Build requests issued recursively from the top-level requests, for example a project building its dependencies, are not checked against the cache. However, because the build requests are assumed to be issued in reverse topological sort order, those requests should have already been built and present in MSBuild's internal result cache, provided either by the project cache plugin or real builds. A consequence of this is that projects which are not well-described in the graph (e.g. using `<MSBuild>` tasks directly) will not benefit from the cache.
+
+## Cache get scenario
+
+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.
+  
+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.
+- If the plugin decides to build, then MSBuild proceeds building the project as usual.
+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets ("proxy targets").
+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.
   - Plugins have three options:
-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.
-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.
+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.
+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.
       - Proxy target assumptions:
         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).
         - They do not mutate state (file system, environment variables, etc).
         - They do not MSBuild task call into other projects.
-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.
-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.
-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.
-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.
-- Configuring plugins
-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.
+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.
+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.
+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.
+
+## Cache add scenario
+
+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.
+- MSBuild uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. To facilitate the plugin being able to handle future builds, it forwards this information as well as the build result to the plugin for it to use as desired, for example to add to a cache.
+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programmatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.
+  - The in-proc node is disabled since MSBuild is unable to use Detours on the currently running process. It also would not want to capture the file accesses of the plugins themselves.
+  - Detours adds some overhead to file accesses. Based on initial experimentation, it's around 10-15%. There's the overhead of the plugin adding to the cache. Caching becomes valuable if it can save more than the overhead on average.
+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`), only for the x64 flavor (not x86 or arm64), and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.
+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.
+
+# APIs and calling patterns
+
+## Plugin API
+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass.
+
+See the [Plugin implementation guidance and simple example design](#plugin-implementation-guidance-and-simple-example-design) section for guidance for plugin implementations.
+
+## Configuring plugins
+
+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:
+
 ```xml
-<ProjectCachePlugin Update="@(ProjectCachePlugin)" setting1="val1" setting2="val2" />
+<ItemGroup>
+  <ProjectCachePlugin Include="$(SomePath)\MyAmazingCachePlugin.dll">
+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>
+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>
+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>
+  </ProjectCachePlugin>
+</ItemGroup>
 ```
-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):
-  - From command line: `msbuild /graph:NoBuild`
-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`
-- Logging
-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.
-  - Log messages from querying a project get parented under that project's logging context.
-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.
+
+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.
+
+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.
+
+## Enabling from command line
+
+- Requires `/graph` to light up cache get scenarios.
+- Requires `/reportfileaccesses` to light up cache add scenarios.
+- The static graph has all the project instances in the same process, making it easy to find and keep plugin instances in one process.
+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.
+
+## Enabling from Visual Studio, a temporary workaround
+
+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.
+- The workaround logic activates only when MSBuild detects that it's running under VS.
+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.
+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.
+- Plugins will be given the graph entry points instead of the entire graph in this scenario.
+- There is currently no way to enable cache add scenarios in Visual Studio.
+
+# Detours (cache add scenario)
+
+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will emit events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.
+
+Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.
+
+## Pipe synchronization
+
+Because the Detours implementation being used communicates over a pipe, and nodes communicate over a pipe as well, and pipes are async, there is some coordination required to ensure that file accesses are associated with the proper build request. For example, if a "project finished" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.
+
+To address this problem, when a worker node finishes a project it will emit a dummy file access with a specific format known to MSBuild. When the scheduler node receives as "project finished" event over the node communication pipe, it will wait to determine that the project is actually finished until it also receives the dummy file access. This ensures that the all file accesses associated with the project have fully flushed from the pipe before the scheduler determines the project is finished and schedules new work to the worker node (which would trigger new file accesses).
+
+# Plugin implementation guidance and simple example design
+
+The following will describe a very basic (and not very correct) plugin implementation.
+
+In practice, plugins will have to choose the specific level of correctness they're willing to trade off for the ability to get cache hits. Any machine state *could* impact build results, and the plugin implementation will need to determine what state matters and what doesn't. An obvious example to consider would be the content of the project file. An example which has trade-offs would be the processes' environment variables. Even the current time could possibly impact the build ("if Tuesday copy this file"), but if considered caching would be quite infeasible.
+
+## Fingerprinting
+
+A "fingerprint" describes each unique input which went into the building a build request. The more granular the fingerprint, the more "correct" the caching is, as described above.
+
+In this example, we will only consider the following as inputs, and thus part of the fingerprint:
+- The global properties of the build request (eg `Configuration=Debug`, `Platform=AnyCPU`)
+- The content hash of the project file
+- The content hash of files defined in specific items we know contribute to the build, like `<Compile>` and `<Content>`
+- The fingerprint of referenced projects
+
+Again, this is for illustrative purposes and a real implementation will want to use additional state for fingerprinting depending on the environment in which it runs and the correctness requirements.
+
+It can make sense for a fingerprint to be a hash of its inputs, so effectively is a byte array which can be represented by a string.
+
+At the beginning of the build, the plugin's `BeginBuildAsync` method will be called. As part of the `CacheContext`, the plugin is either given the graph or the entry points to the graph for which it can create a graph from. The plugin can use this graph to do some initial processing, like predicting various inputs which a project is likely to use. This information can then be stored to help construct a fingerprint for a build request later.
+
+## Cache storage
+
+Any storage mechanism can be used as a cache implementation, for example [Azure Blob Storage](https://azure.microsoft.com/products/storage/blobs/), or even just the local filesystem. At least in this example the only real requirement is that it can be used effectively as a key-value store. In many cases it can be useful for content to be keyed by its hash, and for the metadata file to be keyed by the fingerprint. In particular when content is keyed by hash, it is effectively deduplicated across multiple copies of the same file, which is common in builds.
+
+For illustration purposes, consider our cache implementation is based on a simple filesystem with a separate metadata and content directory inside it. Under the metadata dir, each file is a metadata file where the filename matches the fingerprint it's describing. Under the content dir, each file is a content file where the filename matches the hash of the content itself.
+
+## First build (cache population)
+
+In the very first build there will be no cache hits so the "cache add" scenario will be most relevant here.
+
+For a given project, `GetCacheResultAsync` will be invoked, but will end up returning a cache miss since the cache is empty.
+
+MSBuild will then build the project normally but under a detoured worker node. Because of this, the plugin will recieve `HandleFileAccess` and `HandleProcess` events. In this example implementation we will ignore `HandleProcess`. For `HandleFileAccess`, the plugin will simply store all `FileAccessData`s for a `FileAccessContext` to build up a list of all file accesses during the build. The plugin may decide to avoid storing the entire `FileAccessData` and instead just peel off the data it finds relevant (eg. paths, whether it was a read or write, etc).
+
+Once MSBuild is done building the project, it will call the plugin's `HandleProjectFinishedAsync`. Now the plugin knows the project is done and can process the results and add them to a cache. In general it's only useful to cache successful results, so the plugin should filter out non-success results. The `FileAccessContext` provided can then be used to retrieve the list of `FileAccessData` the plugin recieved. These `FileAccessData` can be processed to understand which files were read and written as part of the build.
+
+In our example, we can use the read files to construct a fingerprint for the build request. We can then add the files written during the build ("outputs") to some cache implementation.
+
+The plugin would then create some metadata describing the outputs (eg. the paths and hashes) and the serialized `BuildResult`, and associate it with the fingerprint and put that assocation in the cache.
+
+To illustrate this, consider a project with fingerprint `F` which wrote a single file `O` with hash `H` and had `BuildResult R`. The plugin could create a metadata file `M` which describes the outputs of the build (the path and hash of `O`) as well as the serialized `R`. Using the cache implementation described above, the plugin would write the following two files to the cache:
+ - `metadata/F -> M:"{outputs: [{path: 'path/to/O', hash: H}], result: R}"`
+ - `content/H -> O`
+
+This can then be used for future builds.
+
+ ## Second Build (cache hits)
+ 
+ In the second build we have a populated cache and so it could be possible to get cache hits.
+
+ For a given project, `GetCacheResultAsync` will be invoked. The plugin can fingerprint the request and use that fingerprint to look up in its cache. If the cache entry exists, it can declare a cache hit.
+
+In the example above, if all inputs are the same as in the first build, we should end up with a fingerprint `F`. We look up in the metadata part of the cache (file `metadata/F`) and find that it exists. This means we have a cache hit. We can fetch that metadata `M` from the cache and find that it describes the output with path `O` and hash `H`. The plugin would then copy `content/H` to `O` and return the deserialized `BuildResult R` contained in `M` to MSBuild.
+
+If the inputs were not the same as in the first build, for example if a `Compile` item (a .cs file) changed, the fingerprint would be something else besides `F` and so would not have corresponding cache entries for it, indicating a cache miss. This will then go through the "cache add" scenario described above to populate the cache with the new fingerprint.
 
 # Caveats
+- Without the "cache add" scenario enabled, the content which powers "cache get" must be populated by some external entity, for example some higher-order build engine.
 - Absolute paths circulating through the saved build results
   - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.
+  - Plugins can attempt to normalize well-known paths, like the repo root, but this can be brittle and there may be unknown path types.
 - Slow connections. In a coffee shop it might be faster to build everything instead of downloading from the cache. Consider racing plugin checks and building: if the bottom up build traversal reaches a node that's still querying the cache, cancel the cache query and build the node instead.
 - Inferring what targets to run on each node when using /graph
-  - Msbuild /graph requires that the [target inference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/specs/static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.
+  - Msbuild /graph requires that the [target inference protocol](static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.
 - Small repos will probably be slower with plugin implementations that access the network. Remote distribution and caching will only be worth it for repos that are large enough.
 
-# Future work
-- On cache misses plugins can build the project with IO monitoring and write to the local cache. As far as we can tell there are two main possibilities:
-  - plugins build the projects themselves in isolation (without projects building their reference, probably by setting `BuildProjectReferences` to false) by calling msbuild.exe.
-  - plugins request msbuild to build the projects on special out of proc nodes whose IO system calls can be monitored.
-
-# Potential work of dubious value
-- Allow multiple plugin instances and query them based on some priority, similar to sdk resolvers.
+# Potential future work of dubious value
 - Enable plugins to work with the just-in-time top down msbuild traversal that msbuild natively does when it's not using `/graph`.
 - Extend the project cache API to allow skipping individual targets or tasks instead of entire projects. This would allow for smaller specialized plugins, like plugins that only know to distribute, cache, and skip CSC.exe calls.
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index ec84d18521a..f7d92318dc7 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -30,6 +30,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Target parameters will be unquoted](https://github.com/dotnet/msbuild/pull/9452), meaning  the ';' symbol in the parameter target name will always be treated as separator
 - [Change Version switch output to finish with a newline](https://github.com/dotnet/msbuild/pull/9485)
 - [Load Microsoft.DotNet.MSBuildSdkResolver into default load context (MSBuild.exe only)](https://github.com/dotnet/msbuild/pull/9439)
+- [Load NuGet.Frameworks into secondary AppDomain (MSBuild.exe only)](https://github.com/dotnet/msbuild/pull/9446)
 
 ### 17.8
 - [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index de395d970df..b341b5e5b5a 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -3,8 +3,6 @@
 
 <UsageData>
   <IgnorePatterns>
-    <UsagePattern IdentityGlob="Microsoft.SourceBuild.Intermediate.*/*" />
-
     <!-- Baseline 7.0 dependencies until msbuild targets net8 and uses a net8 arcade, SBRP, etc.
          These cannot be added to 7.0 SBRP, because they would are produced in the 7.0 build. -->
     <UsagePattern IdentityGlob="System.Collections.Immutable/*8.0.0*" />
diff --git a/eng/Versions.props b/eng/Versions.props
index 6c0a14f7560..2a566e3b801 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,8 +2,7 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.9.1</VersionPrefix>
-    <DotNetFinalVersionKind>release</DotNetFinalVersionKind>
+    <VersionPrefix>17.10.0</VersionPrefix>
     <PackageValidationBaselineVersion>17.8.3</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index 4928a8d29f8..2693be21f78 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -172,12 +172,13 @@ public void UnusedEnvironmentVariablesDoNotAppearInBinaryLog()
 </Project>";
                 TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
                 TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
-                BinaryLogger logger = new();
-                logger.Parameters = _logFile;
-                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -bl:{logger.Parameters}", out bool success);
+                
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -bl:{_logFile}", out bool success);
                 success.ShouldBeTrue();
-                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic", out success);
+
+                RunnerUtilities.ExecMSBuild($"{_logFile} -flp:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic", out success);
                 success.ShouldBeTrue();
+
                 string text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile.log"));
                 text.ShouldContain("EnvVar2");
                 text.ShouldContain("value2");
@@ -230,10 +231,9 @@ private void AssemblyLoadsDuringTaskRun(string additionalEventText)
                     """;
                 TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
                 TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
-                BinaryLogger logger = new();
-                logger.Parameters = _logFile;
+                
                 env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
-                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -nr:False -bl:{logger.Parameters} -flp1:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile2.log")};verbosity=normal", out bool success);
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -nr:False -bl:{_logFile} -flp1:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile2.log")};verbosity=normal", out bool success);
                 success.ShouldBeTrue();
 
                 string assemblyLoadedEventText =
@@ -245,7 +245,7 @@ private void AssemblyLoadsDuringTaskRun(string additionalEventText)
                 string text2 = File.ReadAllText(Path.Combine(logFolder.Path, "logFile2.log"));
                 text2.ShouldNotContain(assemblyLoadedEventText);
                 text2.ShouldNotContain(additionalEventText);
-                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp1:logfile={Path.Combine(logFolder.Path, "logFile3.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile4.log")};verbosity=normal", out success);
+                RunnerUtilities.ExecMSBuild($"{_logFile} -flp1:logfile={Path.Combine(logFolder.Path, "logFile3.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile4.log")};verbosity=normal", out success);
                 success.ShouldBeTrue();
                 text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile3.log"));
                 text.ShouldContain(assemblyLoadedEventText);
@@ -438,22 +438,22 @@ public void SuppressCommandOutputForNonDiagVerbosity()
                             <Exec Command='echo a'/>
                         </Target>
                     </Project>";
-                BinaryLogger logger = new();
-                logger.Parameters = _logFile;
+
+
                 TransientTestFolder testFolder = env.CreateFolder(createFolder: true);
 
                 TransientTestFile projectFile1 = env.CreateFile(testFolder, "testProject01.proj", contents);
-                string consoleOutput1 = RunnerUtilities.ExecMSBuild($"{projectFile1.Path} -bl:{logger.Parameters} -verbosity:diag -nologo", out bool success1);
+                string consoleOutput1 = RunnerUtilities.ExecMSBuild($"{projectFile1.Path} -bl:{_logFile} -verbosity:diag -nologo", out bool success1);
                 success1.ShouldBeTrue();
-                var expected1 = $"-nologo -bl:{logger.Parameters} -verbosity:diag {projectFile1.Path}";
+                var expected1 = $"-nologo -bl:{_logFile} -verbosity:diag {projectFile1.Path}";
                 consoleOutput1.ShouldContain(expected1);
 
                 foreach (var verbosity in new string[] { "q", "m", "n", "d" })
                 {
                     TransientTestFile projectFile2 = env.CreateFile(testFolder, $"testProject_{verbosity}.proj", contents);
-                    string consoleOutput2 = RunnerUtilities.ExecMSBuild($"{projectFile2.Path} -bl:{logger.Parameters} -verbosity:{verbosity} -nologo", out bool success2);
+                    string consoleOutput2 = RunnerUtilities.ExecMSBuild($"{projectFile2.Path} -bl:{_logFile} -verbosity:{verbosity} -nologo", out bool success2);
                     success2.ShouldBeTrue();
-                    var expected2 = $"-nologo -bl:{logger.Parameters} -verbosity:{verbosity} {projectFile2.Path}";
+                    var expected2 = $"-nologo -bl:{_logFile} -verbosity:{verbosity} {projectFile2.Path}";
                     consoleOutput2.ShouldNotContain(expected2);
                 }
             }
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 758c98729ac..c994283bdbe 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -557,6 +557,7 @@ public void ProjectCacheByVsScenarioIgnoresSlnDisabledProjects()
                         currentBuildEnvironment.Mode,
                         currentBuildEnvironment.CurrentMSBuildExePath,
                         currentBuildEnvironment.RunningTests,
+                        currentBuildEnvironment.RunningInMSBuildExe,
                         runningInVisualStudio: true,
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
@@ -674,6 +675,7 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
                         currentBuildEnvironment.Mode,
                         currentBuildEnvironment.CurrentMSBuildExePath,
                         currentBuildEnvironment.RunningTests,
+                        currentBuildEnvironment.RunningInMSBuildExe,
                         runningInVisualStudio: true,
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
@@ -1440,6 +1442,7 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
                         currentBuildEnvironment.Mode,
                         currentBuildEnvironment.CurrentMSBuildExePath,
                         currentBuildEnvironment.RunningTests,
+                        currentBuildEnvironment.RunningInMSBuildExe,
                         runningInVisualStudio: true,
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index b2aae4fb743..3d2088d264c 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1332,6 +1332,7 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
                             _projectCacheService.InitializePluginsForVsScenario(
                                 ProjectCacheDescriptors.Values,
                                 resolvedConfiguration,
+                                submission.BuildRequestData.TargetNames,
                                 _executionCancellationTokenSource.Token);
                         }
 
@@ -1953,7 +1954,7 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
 
             if (submission.BuildRequestData.GraphBuildOptions.Build)
             {
-                _projectCacheService.InitializePluginsForGraph(projectGraph, _executionCancellationTokenSource.Token);
+                _projectCacheService.InitializePluginsForGraph(projectGraph, submission.BuildRequestData.TargetNames, _executionCancellationTokenSource.Token);
 
                 var targetListTask = projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames);
 
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
index 256102d0d86..d7b5ea98cca 100644
--- a/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
@@ -1,6 +1,7 @@
 ï»¿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using System.Collections.Generic;
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Graph;
@@ -22,12 +23,23 @@ public class CacheContext
         public IReadOnlyCollection<ProjectGraphEntryPoint>? GraphEntryPoints { get; }
         public string? MSBuildExePath { get; }
         public MSBuildFileSystemBase FileSystem { get; }
+        public IReadOnlyCollection<string> RequestedTargets { get; }
 
         public CacheContext(
             IReadOnlyDictionary<string, string> pluginSettings,
             MSBuildFileSystemBase fileSystem,
             ProjectGraph? graph = null,
             IReadOnlyCollection<ProjectGraphEntryPoint>? graphEntryPoints = null)
+            : this(pluginSettings, fileSystem, requestedTargets: Array.Empty<string>(), graph, graphEntryPoints)
+        {
+        }
+
+        public CacheContext(
+            IReadOnlyDictionary<string, string> pluginSettings,
+            MSBuildFileSystemBase fileSystem,
+            IReadOnlyCollection<string> requestedTargets,
+            ProjectGraph? graph = null,
+            IReadOnlyCollection<ProjectGraphEntryPoint>? graphEntryPoints = null)
         {
             ErrorUtilities.VerifyThrow(
                 (graph != null) ^ (graphEntryPoints != null),
@@ -38,6 +50,7 @@ public CacheContext(
             GraphEntryPoints = graphEntryPoints;
             MSBuildExePath = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
             FileSystem = fileSystem;
+            RequestedTargets = requestedTargets;
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 4d695e99076..e53d28292d1 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -95,7 +95,10 @@ public ProjectCacheService(
         /// <summary>
         /// Optimization which frontloads plugin initialization since we have an entire graph.
         /// </summary>
-        public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationToken cancellationToken)
+        public void InitializePluginsForGraph(
+            ProjectGraph projectGraph,
+            ICollection<string> requestedTargets,
+            CancellationToken cancellationToken)
         {
             EnsureNotDisposed();
 
@@ -111,7 +114,7 @@ public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationTok
                             foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
                             {
                                 // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                                _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)
+                                _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, requestedTargets, cancellationToken)
                                     .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
                             }
                         });
@@ -122,6 +125,7 @@ public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationTok
         public void InitializePluginsForVsScenario(
             IEnumerable<ProjectCacheDescriptor> projectCacheDescriptors,
             BuildRequestConfiguration buildRequestConfiguration,
+            ICollection<string> requestedTargets,
             CancellationToken cancellationToken)
         {
             EnsureNotDisposed();
@@ -144,7 +148,7 @@ public void InitializePluginsForVsScenario(
                         projectCacheDescriptor =>
                         {
                             // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                            _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)
+                            _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, requestedTargets, cancellationToken)
                                 .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
                         });
                 },
@@ -155,12 +159,13 @@ private Task<ProjectCachePlugin> GetProjectCachePluginAsync(
             ProjectCacheDescriptor projectCacheDescriptor,
             ProjectGraph? projectGraph,
             BuildRequestConfiguration? buildRequestConfiguration,
+            ICollection<string> requestedTargets,
             CancellationToken cancellationToken)
             => _projectCachePlugins.GetOrAdd(
                 projectCacheDescriptor,
                 // The use of Lazy is because ConcurrentDictionary doesn't guarantee the value factory executes only once if there are multiple simultaneous callers,
                 // so this ensures that CreateAndInitializePluginAsync is only called exactly once.
-                descriptor => new Lazy<Task<ProjectCachePlugin>>(() => CreateAndInitializePluginAsync(descriptor, projectGraph, buildRequestConfiguration, cancellationToken)))
+                descriptor => new Lazy<Task<ProjectCachePlugin>>(() => CreateAndInitializePluginAsync(descriptor, projectGraph, buildRequestConfiguration, requestedTargets, cancellationToken)))
                .Value;
 
         private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectInstance projectInstance)
@@ -189,6 +194,7 @@ private async Task<ProjectCachePlugin> CreateAndInitializePluginAsync(
             ProjectCacheDescriptor projectCacheDescriptor,
             ProjectGraph? projectGraph,
             BuildRequestConfiguration? buildRequestConfiguration,
+            ICollection<string> requestedTargets,
             CancellationToken cancellationToken)
         {
             BuildEventContext buildEventContext = BuildEventContext.Invalid;
@@ -241,6 +247,9 @@ private async Task<ProjectCachePlugin> CreateAndInitializePluginAsync(
                 ? GetGraphEntryPoints(buildRequestConfiguration)
                 : null;
 
+            // In practice, the underlying type of the ICollection is a List<string> so attempt to cast first
+            IReadOnlyList<string> requestedTargetsList = requestedTargets as List<string> ?? requestedTargets.ToList();
+
             _loggingService.LogComment(buildEventContext, MessageImportance.High, "LoadingProjectCachePlugin", pluginTypeName);
             MSBuildEventSource.Log.ProjectCacheBeginBuildStart(pluginTypeName);
 
@@ -250,6 +259,7 @@ await pluginInstance.BeginBuildAsync(
                     new CacheContext(
                         projectCacheDescriptor.PluginSettings,
                         DefaultMSBuildFileSystem.Instance,
+                        requestedTargetsList,
                         projectGraph,
                         graphEntryPoints),
                     pluginLogger,
@@ -517,7 +527,8 @@ private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildReques
                     continue;
                 }
 
-                ProjectCachePlugin plugin = await GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken);
+                ICollection<string> requestedTargetsList = buildRequestConfiguration.RequestedTargets as ICollection<string> ?? buildRequestConfiguration.RequestedTargets.ToList();
+                ProjectCachePlugin plugin = await GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, requestedTargetsList, cancellationToken);
                 try
                 {
                     // Rethrow any initialization exception.
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 924b3e25db7..11dd0a1143d 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -11,6 +11,7 @@
 using System.Threading;
 using System.Xml;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
@@ -1732,6 +1733,7 @@ private void ShutDownLoggingService()
             {
                 try
                 {
+                    (LoggingService as LoggingService)?.WaitForLoggingToProcessEvents();
                     ((IBuildComponent)LoggingService).ShutdownComponent();
                 }
                 catch (LoggerException)
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 3fff5c28e65..0f721647326 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -35,7 +35,7 @@ internal static class IntrinsicFunctions
 
         private static readonly Lazy<Regex> RegistrySdkRegex = new Lazy<Regex>(() => new Regex(@"^HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Microsoft SDKs\\Windows\\v(\d+\.\d+)$", RegexOptions.IgnoreCase));
 
-        private static readonly Lazy<NuGetFrameworkWrapper> NuGetFramework = new Lazy<NuGetFrameworkWrapper>(() => new NuGetFrameworkWrapper());
+        private static readonly Lazy<NuGetFrameworkWrapper> NuGetFramework = new Lazy<NuGetFrameworkWrapper>(() => NuGetFrameworkWrapper.CreateInstance());
 
         /// <summary>
         /// Add two doubles
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index 21271e12fb0..67b1d939f93 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -68,7 +68,7 @@ private void ParseFileLoggerParameters()
         /// </summary>
         private void ApplyFileLoggerParameter(string parameterName, string parameterValue)
         {
-            if (String.Equals("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase))
+            if (string.Equals("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase))
             {
                 if (string.IsNullOrEmpty(parameterValue))
                 {
@@ -104,7 +104,7 @@ public void Initialize(IEventSource eventSource)
                 _nodeFileLogger = new FileLogger();
                 string extension = Path.GetExtension(_logFile);
                 // If there is no extension add a default of .log to it
-                if (String.IsNullOrEmpty(extension))
+                if (string.IsNullOrEmpty(extension))
                 {
                     _logFile += ".log";
                     extension = ".log";
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 436bf030051..7248660300c 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -670,4 +670,54 @@
       <LogicalName>$(AssemblyName).Strings.shared.resources</LogicalName>
     </EmbeddedResource>
   </ItemGroup>
+
+  <PropertyGroup>
+    <NuGetFrameworkWrapperRedirects_FilePath>$(IntermediateOutputPath)NuGetFrameworkWrapper.redirects.cs</NuGetFrameworkWrapperRedirects_FilePath>
+  </PropertyGroup>
+
+  <!-- Extract binding redirects for Microsoft.Build from MSBuild.exe.config into a source file -->
+  <Target Name="GenerateAppDomainConfig"
+          Inputs="..\MSBuild\app.config;..\MSBuild\app.amd64.config"
+          Outputs="$(NuGetFrameworkWrapperRedirects_FilePath)"
+          BeforeTargets="CoreCompile"
+          Condition="'$(FeatureAppDomain)' == 'true'">
+    <PropertyGroup>
+      <BindingRedirectNamespace>&lt;Namespace Prefix='ns' Uri='urn:schemas-microsoft-com:asm.v1' /&gt;</BindingRedirectNamespace>
+      <BindingRedirectXPath>/configuration/runtime/ns:assemblyBinding/ns:dependentAssembly[ns:assemblyIdentity/@name='Microsoft.Build']</BindingRedirectXPath>
+    </PropertyGroup>
+
+    <XmlPeek XmlInputPath="..\MSBuild\app.config" Query="$(BindingRedirectXPath)" Namespaces="$(BindingRedirectNamespace)">
+      <Output TaskParameter="Result" ItemName="BindingRedirect32" />
+    </XmlPeek>
+    <XmlPeek XmlInputPath="..\MSBuild\app.amd64.config" Query="$(BindingRedirectXPath)" Namespaces="$(BindingRedirectNamespace)">
+      <Output TaskParameter="Result" ItemName="BindingRedirect64" />
+    </XmlPeek>
+
+    <PropertyGroup>
+      <NuGetFrameworkWrapperRedirects_Content><![CDATA[
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Evaluation%3B;
+
+[System.CodeDom.Compiler.GeneratedCode("GenerateAppDomainConfig", "1.0")]
+internal sealed partial class NuGetFrameworkWrapper
+{
+    private const string _bindingRedirect32 = """;@(BindingRedirect32);"""%3B;
+    private const string _bindingRedirect64 = """;@(BindingRedirect64);"""%3B;
+}
+]]>
+      </NuGetFrameworkWrapperRedirects_Content>
+    </PropertyGroup>
+
+    <WriteLinesToFile File="$(NuGetFrameworkWrapperRedirects_FilePath)" Overwrite="true" WriteOnlyWhenDifferent="true" Lines="$(NuGetFrameworkWrapperRedirects_Content)" />
+
+    <ItemGroup>
+      <Compile Remove="$(NuGetFrameworkWrapperRedirects_FilePath)" />
+      <Compile Include="$(NuGetFrameworkWrapperRedirects_FilePath)">
+        <Link>Utilities\NuGetFrameworkWrapper.redirects.cs</Link>
+      </Compile>
+      <FileWrites Include="$(NuGetFrameworkWrapperRedirects_FilePath)" />
+    </ItemGroup>
+  </Target>
 </Project>
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 119cfeaf410..632884ce86c 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1889,7 +1889,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>Property initial value: $({0})="{1}" Source: {2}</value>
   </data>
   <data name="NuGetAssemblyNotFound" xml:space="preserve">
-    <value>A required NuGet assembly was not found. Expected Path: {0}</value>
+    <value>A required NuGet assembly '{0}' could not be loaded.</value>
   </data>
   <data name="StaticGraphConstructionMetrics" xml:space="preserve">
     <value>Static graph loaded in {0} seconds: {1} nodes, {2} edges</value>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 93df3aa370f..bce0cd169f9 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -222,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">PoÅ¾adovanÃ© sestavenÃ­ NuGet se nenaÅ¡lo. OÄekÃ¡vanÃ¡ cesta: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">Nepovedlo se naÄÃ­st poÅ¾adovanÃ© sestavenÃ­ NuGet {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -1500,7 +1500,7 @@
       </trans-unit>
       <trans-unit id="SolutionVenusProjectSkipped">
         <source>Skipping because the "$(AspNetConfiguration)" configuration is not supported for this web project.  You can use the AspNetConfiguration property to override the configuration used for building web projects, by adding /p:AspNetConfiguration=&lt;value&gt; to the command line. Currently web projects only support Debug and Release configurations.</source>
-        <target state="translated">VynechÃ¡no, protoÅ¾e konfigurace "$(AspNetConfiguration)" nenÃ­ pro tento webovÃ½ projekt podporovÃ¡na. PomocÃ­ vlastnosti AspNetConfiguration mÅ¯Å¾ete pÅepsat konfiguraci pouÅ¾Ã­vanou k sestavovÃ¡nÃ­ webovÃ½ch projektÅ¯, a to pÅidÃ¡nÃ­m pÅÃ­kazu /p:AspNetConfiguration=&lt;hodnota&gt; do pÅÃ­kazovÃ©ho ÅÃ¡dku. WebovÃ© projekty nynÃ­ podporujÃ­ pouze konfigurace Debug a Release.</target>
+        <target state="translated">VynechÃ¡no, protoÅ¾e konfigurace $(AspNetConfiguration) nenÃ­ pro tento webovÃ½ projekt podporovÃ¡na. PomocÃ­ vlastnosti AspNetConfiguration mÅ¯Å¾ete pÅepsat konfiguraci pouÅ¾Ã­vanou k sestavovÃ¡nÃ­ webovÃ½ch projektÅ¯, a to pÅidÃ¡nÃ­m pÅÃ­kazu /p:AspNetConfiguration=&lt;hodnota&gt; do pÅÃ­kazovÃ©ho ÅÃ¡dku. WebovÃ© projekty nynÃ­ podporujÃ­ pouze konfigurace Debug a Release.</target>
         <note>
     UE: This is not an error, so doesn't need an error code.
     LOCALIZATION: Do NOT localize "AspNetConfiguration", "Debug", "Release".
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 0ac225d5314..be95e6e8f12 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -222,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Eine erforderliche NuGet-Assembly wurde nicht gefunden. Erwarteter Pfad: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">Eine erforderliche NuGet-Assembly "{0}" konnte nicht geladen werden.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -492,7 +492,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Dies ist ein Ausnahmefehler in MSBuild. STIMMEN SIE EINEM VORHANDENEN ISSUE ZU, ODER ERSTELLEN SIE EIN NEUES ISSUE UNTER https://aka.ms/msbuild/unhandled
+        <target state="translated">Dies ist eine nicht behandelte Ausnahme in MSBuild. RUFEN SIE EIN VORHANDENES PROBLEM AUF, ODER ERSTELLEN SIE EIN NEUES UNTER https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index ad0b6a876a3..e3ab82956ad 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -222,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">No se encontrÃ³ un ensamblado de NuGet necesario. Ruta de acceso esperada: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">No se pudo cargar un ensamblado NuGet necesario "{0}".</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 15ca23b22a4..8fdb220057b 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -222,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Un assembly NuGet obligatoire est introuvable. Chemin attenduÂ : {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">Impossible de charger une assemblÃ©e NuGet Â«{0}Â» requise.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -492,7 +492,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Il sâagit dâune exception non prise en charge dans MSBuildÂ ââ VOTEZ POUR UN PROBLÃME EXISTANT OU CRÃEZ-EN UN SUR https://aka.ms/msbuild/unhandled
+        <target state="translated">Il sâagit dâune exception non gÃ©rÃ©e dans MSBuildÂ ââ VOTEZ POUR UN PROBLÃME EXISTANT OU ENTREZ UN NOUVEAU FICHIER Ã https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index b8fe5cd168d..12f8460c1e0 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -222,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Un assembly NuGet obbligatorio non Ã¨ stato trovato. Percorso previsto: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">Non Ã¨ stato possibile caricare un assembly NuGet obbligatorio '{0}'.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 59c1576e9c3..f21702818b4 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -222,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">å¿è¦ãª NuGet ã¢ã»ã³ããªãè¦ã¤ããã¾ããã§ãããæ³å®ããããã¹: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">å¿è¦ãª NuGet ã¢ã»ã³ããª '{0}' ãèª­ã¿è¾¼ãã¾ããã§ããã</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index f971f5ac61e..432ff34b4eb 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -222,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">íìí NuGet ì´ìë¸ë¦¬ë¥¼ ì°¾ì ì ììµëë¤. ìì ê²½ë¡: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">íìí NuGet ì´ìë¸ë¦¬ '{0}'ì(ë¥¼) ë¡ëí  ì ììµëë¤.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index a12062ad5a9..3842b13b712 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -222,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Nie znaleziono wymaganego zestawu NuGet. Oczekiwano ÅcieÅ¼ki {0}.</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">Nie moÅ¼na zaÅadowaÄ wymaganego zestawu NuGet â{0}â.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -492,7 +492,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Jest to nieobsÅugiwany wyjÄtek na platformie MSBuild -- ZAGÅOSUJ NA ISTNIEJÄCY PROBLEM LUB ZAREJESTRUJ NOWY W WITRYNIE https://aka.ms/msbuild/unhandled.
+        <target state="translated">Jest to nieobsÅugiwany wyjÄtek w aplikacji MSBuild -- ZAGÅOSUJ NA ISTNIEJÄCY PROBLEM LUB ZAGÅOSUJ NA NOWY NA https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 258fdf8c1e5..bee8a55e88d 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -222,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Um assembly NuGet necessÃ¡rio nÃ£o foi encontrado. Caminho Esperado: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">NÃ£o foi possÃ­vel carregar um assembly NuGet "{0}" obrigatÃ³rio.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -492,7 +492,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Essa Ã© uma exceÃ§Ã£o nÃ£o tratada no MSBuild -- POR FAVOR, ATUALIZE UMA QUESTÃO EXISTENTE OU ENCAMINHE UMA NOVA EM https://aka.ms/msbuild/unhandled
+        <target state="translated">Esta Ã© uma exceÃ§Ã£o nÃ£o tratada no MSBuild -- POR FAVOR, APOIE UM PROBLEMA EXISTENTE OU ARQUIVE UM NOVO EM https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 11007faa0ee..40ebdbfe1e6 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -222,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">ÐÐµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð° Ð¾Ð±ÑÐ·Ð°ÑÐµÐ»ÑÐ½Ð°Ñ ÑÐ±Ð¾ÑÐºÐ° NuGet. ÐÐ¶Ð¸Ð´Ð°ÐµÐ¼ÑÐ¹ Ð¿ÑÑÑ: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">ÐÐµ ÑÐ´Ð°Ð»Ð¾ÑÑ Ð·Ð°Ð³ÑÑÐ·Ð¸ÑÑ ÑÑÐµÐ±ÑÐµÐ¼ÑÑ ÑÐ±Ð¾ÑÐºÑ NuGet "{0}".</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -492,7 +492,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Ð­ÑÐ¾ Ð½ÐµÐ¾Ð±ÑÐ°Ð±Ð¾ÑÐ°Ð½Ð½Ð¾Ðµ Ð¸ÑÐºÐ»ÑÑÐµÐ½Ð¸Ðµ Ð² MSBuild. ÐÐ ÐÐÐÐÐÐ¡Ð£ÐÐ¢Ð ÐÐ Ð¡Ð£Ð©ÐÐ¡Ð¢ÐÐ£Ð®Ð©Ð£Ð® ÐÐ ÐÐÐÐÐÐ£ ÐÐÐ Ð¡ÐÐÐÐ©ÐÐ¢Ð Ð ÐÐÐÐ£Ð ÐÐ https://aka.ms/msbuild/unhandled
+        <target state="translated">Ð­ÑÐ¾ Ð½ÐµÐ¾Ð±ÑÐ°Ð±Ð¾ÑÐ°Ð½Ð½Ð¾Ðµ Ð¸ÑÐºÐ»ÑÑÐµÐ½Ð¸Ðµ Ð² MSBuild. ÐÑÐ¾Ð³Ð¾Ð»Ð¾ÑÑÐ¹ÑÐµ Ð·Ð° ÑÑÑÐµÑÑÐ²ÑÑÑÑÑ Ð¿ÑÐ¾Ð±Ð»ÐµÐ¼Ñ Ð¸Ð»Ð¸ ÑÐ¾Ð¾Ð±ÑÐ¸ÑÐµ Ð¾ Ð½Ð¾Ð²Ð¾Ð¹ Ð¿Ð¾ Ð°Ð´ÑÐµÑÑ https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index b0255efe91b..8eaeeb2fa66 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -222,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Gereken NuGet derlemesi bulunamadÄ±. Beklenen Yol: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">Gerekli bir NuGet '{0}' derlemesi yÃ¼klenemedi.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -492,7 +492,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Bu, MSBuild'de iÅlenmeyen bir istisnadÄ±r -- LÃTFEN MEVCUT BÄ°R SORUNU OYLAYIN VEYA https://aka.ms/msbuild/unhandled ADRESÄ°NDE YENÄ° BÄ°R SORUN OLUÅTURUN
+        <target state="translated">Bu, MSBuild'de iÅlenmeyen bir istisnadÄ±r -- LÃTFEN MEVCUT BÄ°R SORUNU OYLAYIN VEYA https://aka.ms/msbuild/unhandled ADRESÄ°NDE YENÄ° BÄ°R SORUN DOSYALAYIN
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index d13b0908ee6..29acca521f2 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -222,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">æªæ¾å°æéç NuGet ç¨åºéãæéè·¯å¾: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">æ æ³å è½½æéç NuGet ç¨åºéâ{0}âã</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -2421,7 +2421,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
       </trans-unit>
       <trans-unit id="InvalidSdkFormat">
         <source>MSB4229: The value "{0}" is not valid for an Sdk specification. The attribute should be a semicolon-delimited list of Sdk-name/minimum-version pairs, separated by a forward slash.</source>
-        <target state="translated">MSB4229: å¼â{0}âå¯¹ Sdk è§èæ æãæ­¤å±æ§åºè¯¥æ¯ä»¥åå·åéçSdk-name/minimum-version å¯¹ (ç¨æ­£ææ åé) çåè¡¨ã</target>
+        <target state="translated">MSB4229: å¼â{0}âå¯¹ Sdk è§èæ æãæ­¤å±æ§åºè¯¥æ¯ä»¥åå·åéçSdk-name/minimum-version å¯¹ï¼ç¨æ­£ææ åéï¼çåè¡¨ã</target>
         <note>{StrBegin="MSB4229: "}</note>
       </trans-unit>
       <trans-unit id="TaskInstantiationFailureNotSupported">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 69a33fe9a21..d7e86b932b4 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -222,8 +222,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">æ¾ä¸å°å¿è¦ç NuGet åä»¶ãé æçè·¯å¾: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">ç¡æ³è¼å¥å¿è¦ç NuGet çµä»¶ '{0}'ã</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 367ef9ddf2b..0f5736349a8 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using System.IO;
 using System.Linq;
 using System.Reflection;
@@ -16,47 +17,63 @@
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
-    /// Wraps the NuGet.Frameworks assembly, which is referenced by reflection.
+    /// Wraps the NuGet.Frameworks assembly, which is referenced by reflection and optionally loaded into a separate AppDomain for performance.
     /// </summary>
-    internal class NuGetFrameworkWrapper
+    internal sealed partial class NuGetFrameworkWrapper
+#if FEATURE_APPDOMAIN
+        : MarshalByRefObject
+#endif
     {
+        private const string NuGetFrameworksAssemblyName = "NuGet.Frameworks";
+        private const string NuGetFrameworksFileName = NuGetFrameworksAssemblyName + ".dll";
+
         /// <summary>
-        /// NuGet Types
+        /// Methods, properties, and objects used from the NuGet.Frameworks assembly.
         /// </summary>
-        private static MethodInfo ParseMethod;
-        private static MethodInfo IsCompatibleMethod;
-        private static object DefaultCompatibilityProvider;
-        private static PropertyInfo FrameworkProperty;
-        private static PropertyInfo VersionProperty;
-        private static PropertyInfo PlatformProperty;
-        private static PropertyInfo PlatformVersionProperty;
-        private static PropertyInfo AllFrameworkVersionsProperty;
+        private MethodInfo ParseMethod;
+        private MethodInfo IsCompatibleMethod;
+        private object DefaultCompatibilityProvider;
+        private PropertyInfo FrameworkProperty;
+        private PropertyInfo VersionProperty;
+        private PropertyInfo PlatformProperty;
+        private PropertyInfo PlatformVersionProperty;
+        private PropertyInfo AllFrameworkVersionsProperty;
 
+        /// <summary>
+        /// Public constructor for cross-domain activation only. Use <see cref="CreateInstance"/> to instantiate.
+        /// </summary>
         public NuGetFrameworkWrapper()
+        { }
+
+        /// <summary>
+        /// Initialized this instance. May run in a separate AppDomain.
+        /// </summary>
+        /// <param name="assemblyName">The NuGet.Frameworks to be loaded or null to load by path.</param>
+        /// <param name="assemblyFilePath">The file path from which NuGet.Frameworks should be loaded of <paramref name="assemblyName"/> is null.</param>
+        public void Initialize(AssemblyName assemblyName, string assemblyFilePath)
         {
-            // Resolve the location of the NuGet.Frameworks assembly
-            var assemblyDirectory = BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio ?
-                Path.Combine(BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory, "Common7", "IDE", "CommonExtensions", "Microsoft", "NuGet") :
-                BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
-            try
+            Assembly NuGetAssembly;
+            if (assemblyName != null)
             {
-                var NuGetAssembly = Assembly.LoadFile(Path.Combine(assemblyDirectory, "NuGet.Frameworks.dll"));
-                var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
-                var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
-                var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
-                ParseMethod = NuGetFramework.GetMethod("Parse", new Type[] { typeof(string) });
-                IsCompatibleMethod = NuGetFrameworkCompatibilityProvider.GetMethod("IsCompatible");
-                DefaultCompatibilityProvider = NuGetFrameworkDefaultCompatibilityProvider.GetMethod("get_Instance").Invoke(null, Array.Empty<object>());
-                FrameworkProperty = NuGetFramework.GetProperty("Framework");
-                VersionProperty = NuGetFramework.GetProperty("Version");
-                PlatformProperty = NuGetFramework.GetProperty("Platform");
-                PlatformVersionProperty = NuGetFramework.GetProperty("PlatformVersion");
-                AllFrameworkVersionsProperty = NuGetFramework.GetProperty("AllFrameworkVersions");
+                // This will load the assembly into the default load context if possible, and fall back to LoadFrom context.
+                NuGetAssembly = Assembly.Load(assemblyName);
             }
-            catch
+            else
             {
-                throw new InternalErrorException(string.Format(AssemblyResources.GetString("NuGetAssemblyNotFound"), assemblyDirectory));
+                NuGetAssembly = Assembly.LoadFile(assemblyFilePath);
             }
+
+            var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
+            var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
+            var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
+            ParseMethod = NuGetFramework.GetMethod("Parse", new Type[] { typeof(string) });
+            IsCompatibleMethod = NuGetFrameworkCompatibilityProvider.GetMethod("IsCompatible");
+            DefaultCompatibilityProvider = NuGetFrameworkDefaultCompatibilityProvider.GetMethod("get_Instance").Invoke(null, Array.Empty<object>());
+            FrameworkProperty = NuGetFramework.GetProperty("Framework");
+            VersionProperty = NuGetFramework.GetProperty("Version");
+            PlatformProperty = NuGetFramework.GetProperty("Platform");
+            PlatformVersionProperty = NuGetFramework.GetProperty("PlatformVersion");
+            AllFrameworkVersionsProperty = NuGetFramework.GetProperty("AllFrameworkVersions");
         }
 
         private object Parse(string tfm)
@@ -133,5 +150,99 @@ public string FilterTargetFrameworks(string incoming, string filter)
                 });
             }
         }
+
+#if FEATURE_APPDOMAIN
+        /// <summary>
+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.
+        /// </summary>
+        public override object InitializeLifetimeService() => null;
+
+        private static AppDomainSetup CreateAppDomainSetup(AssemblyName assemblyName, string assemblyPath)
+        {
+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();
+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);
+            for (int i = 0; i < publicKeyToken.Length; i++)
+            {
+                publicKeyTokenString.Append(publicKeyToken[i].ToString("x2", CultureInfo.InvariantCulture));
+            }
+
+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,
+            // NuGet.Frameworks, and Framework assemblies. It is important to use the same binding redirects that were used when
+            // NGENing MSBuild for the native images to be used.
+            string configuration = $"""
+<?xml version="1.0" encoding="utf-8"?>
+  <configuration>
+    <runtime>
+      <DisableFXClosureWalk enabled="true" />
+      <DeferFXClosureWalk enabled="true" />
+      <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
+        {(Environment.Is64BitProcess ? _bindingRedirect64 : _bindingRedirect32)}
+        <dependentAssembly>
+          <assemblyIdentity name="{NuGetFrameworksAssemblyName}" publicKeyToken="{publicKeyTokenString}" culture="{assemblyName.CultureName}" />
+          <codeBase version="{assemblyName.Version}" href="{assemblyPath}" />
+        </dependentAssembly>
+      </assemblyBinding>
+    </runtime>
+  </configuration>
+""";
+
+            AppDomainSetup appDomainSetup = AppDomain.CurrentDomain.SetupInformation;
+            appDomainSetup.SetConfigurationBytes(Encoding.UTF8.GetBytes(configuration));
+            return appDomainSetup;
+        }
+#endif
+
+        public static NuGetFrameworkWrapper CreateInstance()
+        {
+            // Resolve the location of the NuGet.Frameworks assembly
+            string assemblyDirectory = BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio ?
+                Path.Combine(BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory, "Common7", "IDE", "CommonExtensions", "Microsoft", "NuGet") :
+                BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
+
+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);
+
+            NuGetFrameworkWrapper instance = null;
+            AssemblyName assemblyName = null;
+#if FEATURE_APPDOMAIN
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) &&
+                (BuildEnvironmentHelper.Instance.RunningInMSBuildExe || BuildEnvironmentHelper.Instance.RunningInVisualStudio))
+            {
+                // If we are running in MSBuild.exe or VS, we can load the assembly with Assembly.Load, which enables
+                // the runtime to bind to the native image, eliminating some non-trivial JITting cost. Devenv.exe knows how to
+                // load the assembly by name. In MSBuild.exe, however, we don't know the version of the assembly statically so
+                // we create a separate AppDomain with the right binding redirects.
+                try
+                {
+                    assemblyName = AssemblyName.GetAssemblyName(assemblyPath);
+                    if (assemblyName != null && BuildEnvironmentHelper.Instance.RunningInMSBuildExe)
+                    {
+                        AppDomainSetup appDomainSetup = CreateAppDomainSetup(assemblyName, assemblyPath);
+                        if (appDomainSetup != null)
+                        {
+                            AppDomain appDomain = AppDomain.CreateDomain(nameof(NuGetFrameworkWrapper), null, appDomainSetup);
+                            instance = (NuGetFrameworkWrapper)appDomain.CreateInstanceAndUnwrap(Assembly.GetExecutingAssembly().FullName, typeof(NuGetFrameworkWrapper).FullName);
+                        }
+                    }
+                }
+                catch
+                {
+                    // If anything goes wrong just fall back to loading into current AD by path.
+                    instance = null;
+                    assemblyName = null;
+                }
+            }
+#endif
+            try
+            {
+                instance ??= new NuGetFrameworkWrapper();
+                instance.Initialize(assemblyName, assemblyPath);
+
+                return instance;
+            }
+            catch (Exception ex)
+            {
+                throw new InternalErrorException(string.Format(AssemblyResources.GetString("NuGetAssemblyNotFound"), assemblyDirectory), ex);
+            }
+        }
     }
 }
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index fd9dc2a5974..554aa2b2533 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -24,8 +24,8 @@
 
     <ProduceReferenceAssembly Condition="'$(IsTestProject)' != 'true'">true</ProduceReferenceAssembly>
 
-    <!-- Set up BeforeCommon.targets -->
-    <CustomBeforeMicrosoftCommonTargets>$(MSBuildThisFileDirectory)Directory.BeforeCommon.targets</CustomBeforeMicrosoftCommonTargets>
+    <!-- Set up BeforeCommon.targets. Arcade uses this property as well, so don't overwrite it. -->
+    <CustomBeforeMicrosoftCommonTargets>$(CustomBeforeMicrosoftCommonTargets);$(MSBuildThisFileDirectory)Directory.BeforeCommon.targets</CustomBeforeMicrosoftCommonTargets>
 
     <Platforms>AnyCPU;x64;arm64</Platforms>
 
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 1f925324acf..b6479c3698e 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Diagnostics;
 using System.Linq;
 
 #nullable disable
@@ -22,7 +23,7 @@ internal enum ChangeWaveConversionState
     /// </summary>
     /// See docs here: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves.md
     /// For dev docs: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves-Dev.md
-    internal class ChangeWaves
+    internal static class ChangeWaves
     {
         internal static readonly Version Wave17_4 = new Version(17, 4);
         internal static readonly Version Wave17_6 = new Version(17, 6);
@@ -35,6 +36,13 @@ internal class ChangeWaves
         /// </summary>
         internal static readonly Version EnableAllFeatures = new Version(999, 999);
 
+#if DEBUG
+        /// <summary>
+        /// True if <see cref="ResetStateForTests"/> has been called.
+        /// </summary>
+        private static bool _runningTests = false;
+#endif
+
         /// <summary>
         /// The lowest wave in the current rotation of Change Waves.
         /// </summary>
@@ -162,6 +170,10 @@ internal static bool AreFeaturesEnabled(Version wave)
         {
             ApplyChangeWave();
 
+#if DEBUG
+            Debug.Assert(_runningTests || AllWaves.Contains(wave), $"Change wave version {wave} is invalid");
+#endif
+
             return wave < _cachedWave;
         }
 
@@ -171,6 +183,9 @@ internal static bool AreFeaturesEnabled(Version wave)
         /// </summary>
         internal static void ResetStateForTests()
         {
+#if DEBUG
+            _runningTests = true;
+#endif
             _cachedWave = null;
             _state = ChangeWaveConversionState.NotConvertedYet;
         }
diff --git a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
index 80353d7ab31..75749517b55 100644
--- a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
+++ b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
@@ -413,13 +413,8 @@ public void TestTerminalLoggerTogetherWithOtherLoggers()
                 TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
                 TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
 
-                BinaryLogger loggerWithTL = new();
                 string logFileWithTL = env.ExpectFile(".binlog").Path;
-                loggerWithTL.Parameters = logFileWithTL;
-
-                BinaryLogger loggerWithoutTL = new();
                 string logFileWithoutTL = env.ExpectFile(".binlog").Path;
-                loggerWithoutTL.Parameters = logFileWithoutTL;
 
                 // Execute MSBuild with binary, file and terminal loggers
                 RunnerUtilities.ExecMSBuild($"{projectFile.Path} /m /bl:{logFileWithTL} -flp:logfile={Path.Combine(logFolder.Path, "logFileWithTL.log")};verbosity=diagnostic -tl:on", out bool success);
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index c18c5ad2d90..33c482df035 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -793,6 +793,22 @@ public void ExecuteAppWithGetPropertyItemAndTargetResult(
             results.ShouldNotContain(ResourceUtilities.GetResourceString("BuildFailedWithPropertiesItemsOrTargetResultsRequested"));
         }
 
+        [Fact]
+        public void BuildFailsWithBadPropertyName()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            TransientTestFile project = env.CreateFile("testProject.csproj", @"
+<Project>
+  <Target Name=""Build"">
+  </Target>
+</Project>
+");
+            string results = RunnerUtilities.ExecMSBuild($" {project.Path} /p:someProperty:fdalse= ", out bool success);
+            success.ShouldBeFalse(results);
+
+            results.ShouldContain("error MSB4177");
+        }
+
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 6ac15c07dec..3ae01e17f17 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -278,8 +278,8 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "question", "q" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "detailedsummary", "ds" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "getProperty" },                       ParameterizedSwitch.GetProperty,                null,                           true,           "MissingGetPropertyError",             true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "getItem" },                           ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",             true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "getTargetResult" },                   ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",             true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "getItem" },                           ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",                 true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "getTargetResult" },                   ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",         true,   false),
         };
 
         /// <summary>
@@ -301,7 +301,7 @@ internal static bool IsParameterlessSwitch(
             {
                 foreach (string parameterlessSwitchName in switchInfo.switchNames)
                 {
-                    if (String.Equals(switchName, parameterlessSwitchName, StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(switchName, parameterlessSwitchName, StringComparison.OrdinalIgnoreCase))
                     {
                         parameterlessSwitch = switchInfo.parameterlessSwitch;
                         duplicateSwitchErrorMessage = switchInfo.duplicateSwitchErrorMessage;
@@ -313,17 +313,6 @@ internal static bool IsParameterlessSwitch(
             return false;
         }
 
-        /// <summary>
-        /// Identifies/detects a switch that takes no parameters.
-        /// </summary>
-        internal static bool IsParameterlessSwitch(
-            string switchName)
-        {
-            ParameterlessSwitch parameterlessSwitch;
-            string duplicateSwitchErrorMessage;
-            return CommandLineSwitches.IsParameterlessSwitch(switchName, out parameterlessSwitch, out duplicateSwitchErrorMessage);
-        }
-
         /// <summary>
         /// Identifies/detects a switch that takes parameters.
         /// </summary>
@@ -354,7 +343,7 @@ internal static bool IsParameterizedSwitch(
             {
                 foreach (string parameterizedSwitchName in switchInfo.switchNames)
                 {
-                    if (String.Equals(switchName, parameterizedSwitchName, StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(switchName, parameterizedSwitchName, StringComparison.OrdinalIgnoreCase))
                     {
                         parameterizedSwitch = switchInfo.parameterizedSwitch;
                         duplicateSwitchErrorMessage = switchInfo.duplicateSwitchErrorMessage;
@@ -480,7 +469,7 @@ internal bool SetParameterizedSwitch(
             // check if the switch has multiple parameters
             if (multipleParametersAllowed)
             {
-                if (String.Empty.Equals(switchParameters) && emptyParametersAllowed)
+                if (string.Empty.Equals(switchParameters) && emptyParametersAllowed)
                 {
                     // Store a null parameter if its allowed
                     _parameterizedSwitches[(int)parameterizedSwitch].parameters.Add(null);
@@ -551,7 +540,7 @@ internal string GetEquivalentCommandLineExceptProjectFile()
             commandLineA.Sort(StringComparer.OrdinalIgnoreCase);
             commandLineB.Sort(StringComparer.OrdinalIgnoreCase);
 
-            return (String.Join(" ", commandLineA).Trim() + " " + String.Join(" ", commandLineB).Trim()).Trim();
+            return (string.Join(" ", commandLineA).Trim() + " " + string.Join(" ", commandLineB).Trim()).Trim();
         }
 
         /// <summary>
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index bc757f96072..cbfc554f4b5 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -575,17 +575,20 @@ KdyÅ¾ se nastavÃ­ na MessageUponIsolationViolation (nebo jeho krÃ¡tkÃ½
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;logger&gt;   PouÅ¾Ã­t danÃ½ protokolovacÃ­ nÃ¡stroj k protokolovÃ¡nÃ­ udÃ¡lostÃ­ nÃ¡stroje MSBuild. Pokud chcete zadat 
-                     vÃ­ce protokolovacÃ­ch nÃ¡strojÅ¯, musÃ­te je zadat jednotlivÄ.
-                     Syntaxe hodnoty &lt;logger&gt; je:
-                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
-                     Syntaxe hodnoty &lt;logger class&gt; je:
-                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;
-                     Syntaxe hodnoty &lt;logger assembly&gt; je:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+        <target state="translated">  -logger:&lt;protok_nÃ¡st&gt;   PouÅ¾Ã­t danÃ½ protokolovacÃ­ nÃ¡stroj k protokolovÃ¡nÃ­
+                     udÃ¡lostÃ­ nÃ¡stroje MSBuild. Chcete-li zadat vÃ­ce protokolovacÃ­ch.
+                     nÃ¡strojÅ¯, musÃ­te je zadat jednotlivÄ.
+                     Syntaxe hodnoty &lt;protok_nÃ¡st&gt;:
+                        [&lt;tÅÃ­da_protok_nÃ¡st&gt;,]&lt;sestavenÃ­_protok_nÃ¡st&gt;
+                        [;&lt;param_protok_nÃ¡st&gt;]
+                     Syntaxe hodnoty &lt;tÅÃ­da_protok_nÃ¡st&gt;:
+                        [&lt;ÄÃ¡st/Ãºpl_obor_nÃ¡zvÅ¯&gt;.]&lt;nÃ¡z_tÅ_protok_nÃ¡st&gt;
+                     Syntaxe hodnoty &lt;sestavenÃ­_protok_nÃ¡st&gt;:
+                        {&lt;nÃ¡zev_sestavenÃ­&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavenÃ­&gt;}
                      Parametry protokolovacÃ­ho nÃ¡stroje urÄujÃ­, jak MSBuild vytvoÅÃ­ protokolovacÃ­ nÃ¡stroj.
-                     Parametry &lt;logger parameters&gt; jsou volitelnÃ© a pÅedÃ¡vajÃ­ se
-                     protokolovacÃ­mu nÃ¡stroji pÅesnÄ v tom tvaru, v jakÃ©m byly zadÃ¡ny. (KrÃ¡tkÃ½ tvar: -l)
+                     Parametry &lt;param_protok_nÃ¡st&gt; jsou volitelnÃ© a pÅedÃ¡vajÃ­ se 
+                     protokolovacÃ­mu nÃ¡stroji pÅesnÄ v tom tvaru, v jakÃ©m
+                     byly zadÃ¡ny. (KrÃ¡tkÃ½ tvar: -l)
                      PÅÃ­klady:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
@@ -854,20 +857,23 @@ KdyÅ¾ se nastavÃ­ na MessageUponIsolationViolation (nebo jeho krÃ¡tkÃ½
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
-        <target state="translated">  -distributedLogger:&lt;central logger&gt;*&lt;forwarding logger&gt;
-                     PouÅ¾Ã­t zadanÃ½ protokolovacÃ­ nÃ¡stroj pro protokolovÃ¡nÃ­ udÃ¡lostÃ­ z nÃ¡stroje MSBuild; ke kaÅ¾dÃ©mu uzlu pÅipojit
-                     jinou instanci protokolovacÃ­ho nÃ¡stroje. Pokud chcete zadat vÃ­ce
-                     protokolovacÃ­ch nÃ¡strojÅ¯, uveÄte je jednotlivÄ.
+        <target state="translated">  -distributedlogger:&lt;centr_protok_nÃ¡st&gt;*&lt;pÅedÃ¡v_protok_nÃ¡st&gt;                     
+                     PouÅ¾Ã­t zadanÃ½ protokolovacÃ­ nÃ¡stroj pro protokolovÃ¡nÃ­ udÃ¡lostÃ­
+                     z nÃ¡stroje MSBuild; ke kaÅ¾dÃ©mu uzlu pÅipojit jinou instanci 
+                     protokolovacÃ­ho nÃ¡stroje. Chcete-li zadat vÃ­ce 
+                     protokolovacÃ­ch nÃ¡strojÅ¯, uveÄte je jednotlivÄ. 
                      (KrÃ¡tkÃ½ tvar: -dl)
-                     Syntaxe hodnoty &lt;logger&gt; je:
-                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
-                     Syntaxe hodnoty &lt;logger class&gt; je:
-                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;
-                     Syntaxe hodnoty &lt;logger assembly&gt; je:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                     Syntaxe hodnoty &lt;protok_nÃ¡st&gt;:
+                        [&lt;tÅÃ­da_protok_nÃ¡st&gt;,]&lt;sestav_protok_nÃ¡st&gt;
+                        [;&lt;param_protok_nÃ¡st&gt;]
+                     Syntaxe hodnoty &lt;tÅÃ­da_protok_nÃ¡st&gt;:
+                        [&lt;ÄÃ¡st/Ãºpl_obor_nÃ¡zvÅ¯&gt;.]&lt;nÃ¡z_tÅ_protok_nÃ¡st&gt;
+                     Syntaxe hodnoty &lt;sestav_protok_nÃ¡st&gt;:
+                        {&lt;nÃ¡zev_sestavenÃ­&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavenÃ­&gt;}
                      Parametry protokolovacÃ­ho nÃ¡stroje urÄujÃ­, jak MSBuild vytvoÅÃ­ protokolovacÃ­ nÃ¡stroj.
                      Parametry &lt;param_protok_nÃ¡st&gt; jsou volitelnÃ© a pÅedÃ¡vajÃ­ se
-                     protokolovacÃ­mu nÃ¡stroji pÅesnÄ v zadanÃ©m tvaru. (KrÃ¡tkÃ½ tvar: -l)
+                     protokolovacÃ­mu nÃ¡stroji pÅesnÄ v zadanÃ©m tvaru.
+                     (KrÃ¡tkÃ½ tvar: -l)
                      PÅÃ­klady:
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
@@ -1055,7 +1061,7 @@ KdyÅ¾ se nastavÃ­ na MessageUponIsolationViolation (nebo jeho krÃ¡tkÃ½
                                              Verbosity=diagnostic;Encoding=UTF-8
 
                        -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index a21843226d1..7a1059f935d 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -112,11 +112,12 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -reportFileAccesses[:True|False]
-                     FÃ¼hrt dazu, dass MSBuild Dateizugriffe auf ein beliebiges konfiguriertes
-                     Projektcache-Plug-In meldet.
+        <target state="translated">  -reportFileAccesses[:True|Falsch]
+                     FÃ¼hrt dazu, dass MSBuild Dateizugriffe an alle konfigurierten
+ meldet
+                     Projektcache-Plug-Ins.
 
-                     Dieses Flag ist experimentell und funktioniert mÃ¶glicherweise nicht wie vorgesehen.
+                     Dieses Kennzeichen ist experimentell und funktioniert mÃ¶glicherweise nicht wie vorgesehen.
     </target>
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
@@ -573,11 +574,11 @@ Dies ist ein restriktiverer Modus von MSBuild, da er erfordert,
         <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben, 
                      wird jede Protokollierung gesondert angegeben.
                      Die Syntax fÃ¼r die &lt;Protokollierung&gt; lautet:
-                       [&lt;Klasse&gt;,]&lt;assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
+                       [&lt;Klasse&gt;,]&lt;Assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
                      Die Syntax fÃ¼r die &lt;Protokollierungsklasse&gt; lautet:
                         [&lt;Teilweiser oder vollstÃ¤ndiger Namespace&gt;.]&lt;Name der Protokollierungsklasse&gt;
                      Die Syntax fÃ¼r die &lt;Protokollierungsassembly&gt; lautet:
-                        {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
                      Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
                      so an die Protokollierung Ã¼bergeben, wie sie eingegeben wurden. (Kurzform: -l)
@@ -855,11 +856,11 @@ Dieses Protokollierungsformat ist standardmÃ¤Ãig aktiviert.
                      gesondert angegeben.
                      (Kurzform -dl)
                      Die Syntax fÃ¼r die &lt;Protokollierung&gt; lautet:
-                       [&lt;Klasse&gt;,]&lt;assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
+                       [&lt;Klasse&gt;,]&lt;Assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
                      Die Syntax fÃ¼r die &lt;Protokollierungsklasse&gt; lautet:
                         [&lt;Teilweiser oder vollstÃ¤ndiger Namespace&gt;.]&lt;Name der Protokollierungsklasse&gt;
                      Die Syntax fÃ¼r die &lt;Protokollierungsassembly&gt; lautet:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
                      Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
                      so an die Protokollierung Ã¼bergeben, wie sie eingegeben wurden. (Kurzform: -l)
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 5e02da6973e..7360c1e9799 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -116,7 +116,7 @@
                      Hace que MSBuild informe de los accesos a los archivos a cualquier
                      complemento de cachÃ© de proyectos.
 
-                     Esta marca es experimental y puede que no funcione segÃºn lo previsto.
+Esta marca es experimental y puede que no funcione segÃºn lo previsto.
     </target>
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
@@ -571,14 +571,18 @@
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
         <target state="translated">  -logger:&lt;registrador&gt;   Use este registrador para registrar eventos
-                     de MSBuild. Para especificar varios registradores, especifique cada uno de ellos por separado.
+                     de MSBuild. Para especificar varios registradores, especifique
+                     cada uno de ellos por separado.
                      La sintaxis de &lt;registrador&gt; es:
-                       [&lt;clase&gt;,]&lt;assembly&gt;[,&lt;opciones&gt;][;&lt;parÃ¡metros&gt;]
+                       [&lt;clase&gt;,]&lt;ensamblado&gt;[,&lt;opciones&gt;][;&lt;parÃ¡metros&gt;]
                      La sintaxis de &lt;clase del registrador&gt; es:
-                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre de clase del registrador&gt;
-                       La sintaxis de &lt;ensamblado del registrador&gt; es:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
-                     Las opciones del registrador especifican cÃ³mo crea MSBuild el registrador.
+                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre de
+                       clase del registrador&gt;
+                     La sintaxis de &lt;ensamblado del registrador&gt; es:
+                       {&lt;nombre del ensamblado&gt;[,&lt;strong name&gt;] | &lt;archivo
+                       de ensamblado&gt;}
+                     Las opciones del registrador especifican cÃ³mo crea MSBuild
+                     el registrador.
                      Los &lt;parÃ¡metros del registrador&gt; son opcionales y se pasan
                      al registrador tal como se escriben. (Forma corta: -l)
                      Ejemplos:
@@ -855,12 +859,15 @@
                      Para especificar varios registradores, especifique cada uno
                      de ellos por separado. (Forma corta: -dl)
                      La sintaxis de &lt;registrador&gt; es:
-                       [&lt;clase&gt;,]&lt;assembly&gt;[,&lt;opciones&gt;][;&lt;parÃ¡metros&gt;]
+                       [&lt;clase&gt;,]&lt;ensamblado&gt;[,&lt;opciones&gt;][;&lt;parÃ¡metros&gt;]
                      La sintaxis de &lt;clase del registrador&gt; es:
-                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre de la clase del registrador&gt;
+                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre
+                       de la clase del registrador&gt;
                      La sintaxis de &lt;ensamblado del registrador&gt; es:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
-                     Las opciones del registrador especifican cÃ³mo crea MSBuild el registrador.
+                       {&lt;nombre del ensamblado&gt;[,&lt;strong name&gt;] | &lt;archivo
+                      de ensamblado&gt;}
+                     Las opciones del registrador especifican cÃ³mo crea MSBuild
+                     el registrador.
                      Los &lt;parÃ¡metros del registrador&gt; son opcionales y se pasan
                      al registrador tal como se escriben. (Forma corta: -l)
                      Ejemplos:
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 61673b8b84b..5667032596d 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -114,7 +114,7 @@
     </source>
         <target state="translated">  -reportFileAccesses[:True|False]
                      EntraÃ®ne le signalement par MSBuild des accÃ¨s par fichiers aux plug-ins
-                     de cache de projet configurÃ©s.
+                     cache de projet configurÃ©s.
 
                      Cet indicateur est expÃ©rimental et peut ne pas fonctionner comme prÃ©vu.
     </target>
@@ -577,7 +577,7 @@ Cet indicateur est expÃ©rimental et peut ne pas fonctionner comme prÃ©vu.
                      Syntaxe de &lt;classe de journalisation&gt;Â :
                        [&lt;espace de noms partiels ou complets&gt;.]&lt;nom de la classe de journalisation&gt;
                      Syntaxe de &lt;assembly de journalisation&gt;Â :
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;nom d'assembly&gt;[,&lt;strong name&gt;] | &lt;fichier d'assembly&gt;}
                      Les options de journalisation spÃ©cifient la faÃ§on dont MSBuild crÃ©e le journaliseur.
                      Les &lt;paramÃ¨tres de journalisation&gt; sont facultatifs. Ils sont passÃ©s
                      au journaliseur tels que vous les avez tapÃ©s. (Forme abrÃ©gÃ©eÂ : -l)
@@ -859,7 +859,7 @@ Remarque : verbositÃ© des enregistreurs dâÃ©vÃ©nements de fichiers
                      Syntaxe de &lt;classe de journalisation&gt;Â :
                        [&lt;espace de noms partiels ou complets&gt;.]&lt;nom de la classe de journalisation&gt;
                      Syntaxe de &lt;assembly de journalisation&gt;Â :
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;nom d'assembly&gt;[,&lt;strong name&gt;] | &lt;fichier d'assembly&gt;}
                      Les options de journalisation spÃ©cifient la faÃ§on dont MSBuild crÃ©e le journaliseur.
                      Les &lt;paramÃ¨tres de journalisation&gt; sont facultatifs. Ils sont passÃ©s
                      au journaliseur tels que vous les avez tapÃ©s. (Forme abrÃ©gÃ©eÂ : -l)
@@ -1323,7 +1323,7 @@ Remarque : verbositÃ© des enregistreurs dâÃ©vÃ©nements de fichiers
       </trans-unit>
       <trans-unit id="MissingGetItemError">
         <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
-        <target state="translated">MSBUILD : error MSB1014: Doit fournir un nom d'Ã©lÃ©ment pour le commutateur getItem.</target>
+        <target state="new">MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
       following the switch, as in "msbuild.exe -getItem:blah".
@@ -1332,7 +1332,7 @@ Remarque : verbositÃ© des enregistreurs dâÃ©vÃ©nements de fichiers
       </trans-unit>
       <trans-unit id="MissingGetPropertyError">
         <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
-        <target state="translated">MSBUILD : error MSB1010: Doit fournir un nom de propriÃ©tÃ© pour le commutateur getProperty.</target>
+        <target state="new">MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
       following the switch, as in "msbuild.exe -getProperty:blah".
@@ -1341,7 +1341,7 @@ Remarque : verbositÃ© des enregistreurs dâÃ©vÃ©nements de fichiers
       </trans-unit>
       <trans-unit id="MissingGetTargetResultError">
         <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
-        <target state="translated">MSBUILD : error MSB1017: Doit fournir un nom de cible pour le commutateur getTargetResult.</target>
+        <target state="new">MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -getTargetResult:blah".
@@ -1605,7 +1605,7 @@ Remarque : verbositÃ© des enregistreurs dâÃ©vÃ©nements de fichiers
       </trans-unit>
       <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
         <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
-        <target state="translated">MSBUILD : error MSB1063: Impossible d'accÃ©der aux propriÃ©tÃ©s ou aux Ã©lÃ©ments lors de la crÃ©ation de fichiers de solution ou de fichiers de filtre de solution. Cette fonctionnalitÃ© est disponible uniquement lors de la gÃ©nÃ©ration de projets individuels.</target>
+        <target state="new">MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 03015b156c1..bf5056ca594 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -113,10 +113,10 @@
                      This flag is experimental and may not work as intended.
     </source>
         <target state="translated">  -reportFileAccesses[:True|False]
-                     Fa in modo che MSBuild segnali gli accessi ai file a qualsiasi
+                     Fa in modo che MSBuild segnali gli accessi ai file a qualsiasi file configurato
                      plug-in della cache del progetto.
 
-                     Questo flag Ã¨ sperimentale e potrebbe non funzionare come previsto.
+Questo flag Ã¨ sperimentale e potrebbe non funzionare come previsto.
     </target>
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
@@ -155,7 +155,7 @@
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="translated">Versione di MSBuild Å{0} per {1}</target>
+        <target state="translated">Versione di MSBuild {0} per {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -583,8 +583,8 @@ Questo flag Ã¨ sperimentale e potrebbe non funzionare come previsto.
                        [&lt;classe&gt;,]&lt;assembly&gt;[,&lt;opzioni&gt;][;&lt;parametri&gt;]
                      La sintassi di &lt;classe logger&gt; Ã¨ la seguente:
                        [&lt;spazio dei nomi parziale o completo&gt;.]&lt;nome classe logger&gt;
-                     La sintassi di &lt;logger assembly&gt; Ã¨ la seguente:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                     La sintassi di &lt;assembly logger&gt; Ã¨ la seguente:
+                       {&lt;nome assembly&gt;[,&lt;strong name&gt;] | &lt;file di assembly&gt;}
                      Le opzioni di logger consentono di specificare in che modo MSBuild crea il logger.
                      I &lt;parametri logger&gt; sono facoltativi e vengono passati al
                      logger cosÃ¬ come vengono digitati. Forma breve: -l.
@@ -865,8 +865,8 @@ Nota: livello di dettaglio dei logger di file
                        [&lt;classe&gt;,]&lt;assembly&gt;[,&lt;opzioni&gt;][;&lt;parametri&gt;]
                      La sintassi di &lt;classe logger&gt; Ã¨ la seguente:
                        [&lt;spazio dei nomi parziale o completo&gt;.]&lt;nome classe logger&gt;
-                     La sintassi di &lt;logger assembly&gt; Ã¨ la seguente:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                     La sintassi di &lt;assembly logger&gt; Ã¨ la seguente:
+                       {&lt;nome assembly&gt;[,&lt;strong name&gt;] | &lt;file di assembly&gt;}
                      Le opzioni di logger consentono di specificare in che modo MSBuild crea il logger.
                      I &lt;parametri logger&gt; sono facoltativi e vengono passati al
                      logger cosÃ¬ come vengono digitati. Forma breve: -l
@@ -985,8 +985,9 @@ Nota: livello di dettaglio dei logger di file
                      Ã¨ la directory corrente. Per impostazione predefinita, ai
                      file viene assegnato il nome "MSBuild&lt;idnodo&gt;.log". Il
                      percorso dei file e altri parametri di fileLogger possono
-                     essere specificati aggiungendo l'opzione "-fileLoggerParameters".
+                     essere specificati aggiungendo l'opzione
 
+                     "-fileLoggerParameters".
                      Se il nome di un file di log viene impostato con l'opzione
                      fileLoggerParameters, il logger distribuito userÃ  il nome
                      file come modello e aggiungerÃ  l'ID del nodo per creare un
@@ -2033,15 +2034,16 @@ Esegue la profilatura della valutazione di MSBuild e scrive
                        -restoreProperty:IsRestore=true;MyProperty=value
     </source>
         <target state="translated">  -restoreProperty:&lt;n&gt;=&lt;v&gt;
-                     Imposta queste proprietÃ  a livello di progetto o ne esegue
-                     l'override solo durante il ripristino e non usa le
-                     proprietÃ  specificate con l'argomento -property.
-                     &lt;v&gt; rappresenta il nome della proprietÃ  e &lt;v&gt; il
-                     valore della proprietÃ . Usare il punto e virgola o la
-                     virgola per delimitare piÃ¹ proprietÃ  o specificare ogni proprietÃ  separatamente.
-                     (Forma breve: -rp)
-                     Esempio:
-                       -restoreProperty:IsRestore=true;MyProperty=value
+                      Imposta queste proprietÃ  a livello di progetto o ne esegue
+                      l'override solo durante il ripristino e non usa le
+                      proprietÃ  specificate con l'argomento -property.
+                      &lt;v&gt; rappresenta il nome della proprietÃ  e &lt;v&gt; il
+                      valore della proprietÃ . Usare il punto e virgola o la
+                      virgola per delimitare piÃ¹ proprietÃ  o specificare ogni
+                      proprietÃ  separatamente.
+                      Forma breve: -rp.
+                      Esempio:
+                        -restoreProperty:IsRestore=true;MyProperty=value
     </target>
         <note>
       LOCALIZATION: "-restoreProperty" and "-rp" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 533e64a7478..201adf1b476 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -114,7 +114,7 @@
     </source>
         <target state="translated">  -reportFileAccesses[:True|False]
                      MSBuild ããæ§æããã¦ãããã­ã¸ã§ã¯ã ã­ã£ãã·ã¥ ãã©ã°ã¤ã³ã¸ã®
-                     ãã¡ã¤ã« ã¢ã¯ã»ã¹ãå ±åããããã«ãã¾ãã
+                     ãã¡ã¤ã« ã¢ã¯ã»ã¹ãå ±åãã¾ãã
 
                      ãã®ãã©ã°ã¯å®é¨çãªãã®ã§ãããæå³ããã¨ããã«åä½ããªãå¯è½æ§ãããã¾ãã
     </target>
@@ -135,7 +135,7 @@
       </trans-unit>
       <trans-unit id="InvalidTerminalLoggerValue">
         <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
-        <target state="translated">MSBUILD : error MSB1065: ã¿ã¼ããã« ã­ã¬ã¼ã®å¤ãç¡å¹ã§ãã'auto'ã'true'ãã¾ãã¯ 'false' ã®ããããã§ããå¿è¦ãããã¾ãã{0}</target>
+        <target state="translated">MSBUILD : error MSB1065: ã¿ã¼ããã« ã­ã¬ã¼ã®å¤ãç¡å¹ã§ãã'auto'ã'true'ãã¾ãã¯ 'false' ã®ããããã§ããå¿è¦ãããã¾ãã {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1065: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 37618cdb38b..9f8357fdf3f 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -573,11 +573,11 @@
         <target state="translated">  -logger:&lt;ë¡ê±°&gt;   ì´ ë¡ê±°ë¥¼ ì¬ì©íì¬ MSBuildì ì´ë²¤í¸ë¥¼ ê¸°ë¡í©ëë¤. ì¬ë¬
                      ë¡ê±°ë¥¼ ì§ì íë ¤ë©´ ê° ë¡ê±°ë¥¼ ê°ë³ì ì¼ë¡ ì§ì í©ëë¤.
                      &lt;ë¡ê±°&gt; êµ¬ë¬¸ì ë¤ìê³¼ ê°ìµëë¤.
-                       [&lt;í´ëì¤&gt;,]&lt;assembly&gt;[,&lt;ìµì&gt;][;&lt;ë§¤ê° ë³ì&gt;]
+                       [&lt;í´ëì¤&gt;,]&lt;ì´ìë¸ë¦¬&gt;[,&lt;ìµì&gt;][;&lt;ë§¤ê° ë³ì&gt;]
                      &lt;ë¡ê±° í´ëì¤&gt; êµ¬ë¬¸ì ë¤ìê³¼ ê°ìµëë¤.
                        [&lt;ë¶ë¶ ëë ì ì²´ ë¤ìì¤íì´ì¤&gt;.]&lt;ë¡ê±° í´ëì¤ ì´ë¦&gt;
                      &lt;ë¡ê±° ì´ìë¸ë¦¬&gt; êµ¬ë¬¸ì ë¤ìê³¼ ê°ìµëë¤.
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;ì´ìë¸ë¦¬ ì´ë¦&gt;[,&lt;strong name&gt;] | &lt;ì´ìë¸ë¦¬ íì¼&gt;}
                      ë¡ê±° ìµìì MSBuildê° ë¡ê±°ë¥¼ ë§ëë ë°©ë²ì ì§ì í©ëë¤.
                      &lt;ë¡ê±° ë§¤ê° ë³ì&gt;ë ì í ì¬í­ì´ê³  ìë ¥í ëë¡ ì íí
                      ë¡ê±°ì ì ë¬ë©ëë¤. (ì½ì: -l)
@@ -855,11 +855,11 @@
                      ë¡ê±°ë¥¼ ì§ì íë ¤ë©´ ê° ë¡ê±°ë¥¼ ê°ë³ì ì¼ë¡ ì§ì í©ëë¤.
                      (ì½ì -dl)
                      &lt;ë¡ê±°&gt; êµ¬ë¬¸ì ë¤ìê³¼ ê°ìµëë¤.
-                       [&lt;í´ëì¤&gt;,]&lt;assembly&gt;[,&lt;ìµì&gt;][;&lt;ë§¤ê° ë³ì&gt;]
+                       [&lt;í´ëì¤&gt;,]&lt;ì´ìë¸ë¦¬&gt;[,&lt;ìµì&gt;][;&lt;ë§¤ê° ë³ì&gt;]
                      &lt;ë¡ê±° í´ëì¤&gt; êµ¬ë¬¸ì ë¤ìê³¼ ê°ìµëë¤.
                        [&lt;ë¶ë¶ ëë ì ì²´ ë¤ìì¤íì´ì¤&gt;.]&lt;ë¡ê±° í´ëì¤ ì´ë¦&gt;
                      &lt;ë¡ê±° ì´ìë¸ë¦¬&gt; êµ¬ë¬¸ì ë¤ìê³¼ ê°ìµëë¤.
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;ì´ìë¸ë¦¬ ì´ë¦&gt;[,&lt;strong name&gt;] | &lt;ì´ìë¸ë¦¬ íì¼&gt;}
                      ë¡ê±° ìµìì MSBuildê° ë¡ê±°ë¥¼ ë§ëë ë°©ë²ì ì§ì í©ëë¤.
                       &lt;ë¡ê±° ë§¤ê° ë³ì&gt;ë ì í ì¬í­ì´ê³ 
                      ìë ¥í ëë¡ ì íí ë¡ê±°ì ì ë¬ë©ëë¤. (ì½ì: -l)
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index f4caceb0acc..3005884206c 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -113,10 +113,10 @@
                      This flag is experimental and may not work as intended.
     </source>
         <target state="translated">  -reportFileAccesses[:True|False]
-                     Powoduje, Å¼e platforma MSBuild zgÅasza dostÄpy do wszystkich skonfigurowanych
+                     Powoduje, Å¼e program MSBuild zgÅasza dostÄpy do wszystkich skonfigurowanych plikÃ³w
                      wtyczek pamiÄci podrÄcznej projektu.
 
-                     Ta flaga jest eksperymentalna i moÅ¼e nie dziaÅaÄ zgodnie z oczekiwaniami.
+Ta flaga jest eksperymentalna i moÅ¼e nie dziaÅaÄ zgodnie z oczekiwaniami.
     </target>
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
@@ -575,14 +575,17 @@
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;rejestrator&gt;  UmoÅ¼liwia uÅ¼ycie podanego rejestratora do rejestrowania zdarzeÅ pochodzÄcych
-                     z programu MSBuild. Aby okreÅliÄ wiele rejestratorÃ³w, okreÅl kaÅ¼dy z nich osobno.
+        <target state="translated">  -logger:&lt;rejestrator&gt;  UmoÅ¼liwia uÅ¼ycie podanego rejestratora do rejestrowania
+                         zdarzeÅ pochodzÄcych z programu MSBuild. Aby okreÅliÄ
+                     wiele rejestratorÃ³w, okreÅl kaÅ¼dy z nich osobno.
                      SkÅadnia elementu &lt;rejestrator&gt;:
-                      [&lt;klasa rejestratora&gt;,]&lt;assembly&gt; [;&lt;parametry rejestratora&gt;]
+                        [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt;
+                        [;&lt;parametry rejestratora&gt;]
                      SkÅadnia elementu &lt;klasa rejestratora&gt;:
-                       [&lt;czÄÅciowa lub peÅna przestrzeÅ nazw&gt;.] &lt;nazwa klasy rejestratora&gt;
+                        [&lt;czÄÅciowa lub peÅna przestrzeÅ nazw&gt;.]
+                        &lt;nazwa klasy rejestratora&gt;
                      SkÅadnia elementu &lt;zestaw rejestratora&gt;:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                        {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
                      WartoÅci &lt;parametry rejestratora&gt; sÄ opcjonalne i sÄ
                      przekazywane do rejestratora dokÅadnie tak, jak zostaÅy
                      wpisane. (KrÃ³tka wersja: -l)
@@ -861,11 +864,11 @@
                      wiele rejestratorÃ³w, okreÅl kaÅ¼dy z nich osobno.
                      (KrÃ³tka wersja: -dl)
                      SkÅadnia elementu &lt;rejestrator&gt;:
-                       [&lt;klasa rejestratora&gt;,]&lt;assembly&gt;[;&lt;parametry rejestratora&gt;]
+                       [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt;[;&lt;parametry rejestratora&gt;]
                      SkÅadnia elementu &lt;klasa rejestratora&gt;:
                        [&lt;czÄÅciowa lub peÅna przestrzeÅ nazw&gt;.]&lt;nazwa klasy rejestratora&gt;
                      SkÅadnia elementu &lt;zestaw rejestratora&gt;:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
                      WartoÅci &lt;parametry rejestratora&gt; sÄ opcjonalne i sÄ
                      przekazywane do rejestratora dokÅadnie tak, jak zostaÅy
                      wpisane. (KrÃ³tka wersja: -l)
@@ -977,11 +980,13 @@
                      create a log file for each node.
     </source>
         <target state="translated">  -distributedFileLogger
-                     Rejestruje dane wyjÅciowe kompilacji w wielu plikach dziennika,po jednym pliku
-                     na wÄzeÅ programu MSBuild. PoczÄtkowÄ lokalizacjÄ tych plikÃ³w
-                     jest bieÅ¼Äcy katalog. DomyÅlnie pliki majÄ nazwÄ
+                     Rejestruje dane wyjÅciowe kompilacji w wielu plikach
+                     dziennika, po jednym pliku na wÄzeÅ programu MSBuild.
+                     PoczÄtkowÄ lokalizacjÄ tych plikÃ³w jest bieÅ¼Äcy katalog.
+                     DomyÅlnie pliki majÄ nazwÄ
                      âMSBuild&lt;identyfikator wÄzÅa&gt;.logâ. LokalizacjÄ plikÃ³w
                      i inne parametry rejestratora plikÃ³w moÅ¼na okreÅliÄ
+
                      przez dodanie przeÅÄcznika â-fileLoggerParametersâ.
 
                      JeÅli nazwa pliku zostanie ustawiona za pomocÄ przeÅÄcznika
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index f84a9fbf2fa..7bc78b2a794 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -113,9 +113,8 @@
                      This flag is experimental and may not work as intended.
     </source>
         <target state="translated">  -reportFileAccesses[:True|False]
-                     Faz com que o MSBuild relate acessos a arquivos a qualquer
- configurado
-                     plug-ins de cache do projeto.
+                     Faz com que o MSBuild relate acessos a arquivos para qualquer plug-in
+                     de cache de projeto configurado.
 
                      Este sinalizador Ã© experimental e pode nÃ£o funcionar conforme o esperado.
     </target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index b17262420f6..9e7bb335c03 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -79,7 +79,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="translated">({0:F1}Ñ)</target>
+        <target state="translated">({0:F1}s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -135,7 +135,7 @@
       </trans-unit>
       <trans-unit id="InvalidTerminalLoggerValue">
         <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
-        <target state="translated">MSBUILD : error MSB1065: ÐÐµÐ´Ð¾Ð¿ÑÑÑÐ¸Ð¼Ð¾Ðµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ ÑÑÐµÐ´ÑÑÐ²Ð° Ð²ÐµÐ´ÐµÐ½Ð¸Ñ Ð¶ÑÑÐ½Ð°Ð»Ð° ÑÐµÑÐ¼Ð¸Ð½Ð°Ð»Ð°. Ð­ÑÐ¾ Ð´Ð¾Ð»Ð¶Ð½Ð¾ Ð±ÑÑÑ Ð¾Ð´Ð½Ð¾ Ð¸Ð· ÑÐ»ÐµÐ´ÑÑÑÐ¸Ñ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ð¹: "auto", "ÐÐ¡Ð¢ÐÐÐ" Ð¸Ð»Ð¸ "ÐÐÐÐ¬". {0}</target>
+        <target state="new">MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1065: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index aba51dfc9b3..ac8963bfc96 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -79,7 +79,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="translated">({0:F1} sn)</target>
+        <target state="translated">({0:F1}s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -573,13 +573,13 @@
         <target state="translated">  -logger:&lt;gÃ¼nlÃ¼kÃ§Ã¼&gt;   MSBuild'deki olaylarÄ± gÃ¼nlÃ¼Äe almak iÃ§in bu gÃ¼nlÃ¼kÃ§Ã¼yÃ¼ kullanÄ±n. Birden fazla
                      gÃ¼nlÃ¼kÃ§Ã¼ belirtmek iÃ§in her gÃ¼nlÃ¼kÃ§Ã¼yÃ¼ ayrÄ± ayrÄ± belirtin.
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼&gt; sÃ¶z dizimi ÅÃ¶yledir:
-                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
+                       [&lt;sÄ±nÄ±f&gt;,]&lt;derleme&gt;[,&lt;seÃ§enekler&gt;][;&lt;parametreler&gt;]
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼ sÄ±nÄ±fÄ± &gt; sÃ¶z dizimi ÅÃ¶yledir:
                        [&lt;kÄ±smi veya tam ad alanÄ± &gt;.]&lt;gÃ¼nlÃ¼kÃ§Ã¼ sÄ±nÄ±fÄ± adÄ±&gt;
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼ derlemesi&gt; sÃ¶z dizimi ÅÃ¶yledir:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;derleme adÄ±&gt;[,&lt;strong name&gt;] | &lt;derleme dosyasÄ±&gt;}
                      GÃ¼nlÃ¼kÃ§Ã¼ seÃ§enekleri, MSBuild'in gÃ¼nlÃ¼kÃ§Ã¼yÃ¼ oluÅturma biÃ§imini belirtir.
-                     &lt;gÃ¼nlÃ¼kÃ§Ã¼ parametreleri &gt; isteÄe baÄlÄ±dÄ±r ve tam olarak
+                     &lt;gÃ¼nlÃ¼kÃ§Ã¼ parametreleri &gt; isteÄe baÄlÄ±dÄ±r ve tam olarak 
                      yazdÄ±ÄÄ±nÄ±z Åekliyle gÃ¼nlÃ¼kÃ§Ã¼ye geÃ§irilir. (KÄ±sa biÃ§im: -l)
                      Ãrnekler:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -855,11 +855,11 @@
                      gÃ¼nlÃ¼kÃ§Ã¼ belirtmek iÃ§in her gÃ¼nlÃ¼kÃ§Ã¼yÃ¼ ayrÄ± ayrÄ± belirtin.
                      (KÄ±sa biÃ§im -dl)
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼&gt; sÃ¶z dizimi ÅÃ¶yledir:
-                       [&lt;sÄ±nÄ±f&gt;,]&lt;assembly&gt;[,&lt;seÃ§enekler&gt;][;&lt;parametreler&gt;]
+                       [&lt;sÄ±nÄ±f&gt;,]&lt;derleme&gt;[,&lt;seÃ§enekler&gt;][;&lt;parametreler&gt;]
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼ sÄ±nÄ±fÄ±&gt; sÃ¶z dizimi ÅÃ¶yledir:
                        [&lt;kÄ±smi veya tam ad alanÄ±&gt;.]&lt;gÃ¼nlÃ¼kÃ§Ã¼ sÄ±nÄ±fÄ± adÄ±&gt;
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼ derlemesi&gt; sÃ¶z dizimi ÅÃ¶yledir:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;derleme adÄ±&gt;[,&lt;strong name&gt;] | &lt;derleme dosyasÄ±&gt;}
                      GÃ¼nlÃ¼kÃ§Ã¼ seÃ§enekleri, MSBuild'in gÃ¼nlÃ¼kÃ§Ã¼yÃ¼ oluÅturma biÃ§imini belirtir.
                      &lt;gÃ¼nlÃ¼kÃ§Ã¼ parametreleri&gt; isteÄe baÄlÄ±dÄ±r ve tam olarak
                      yazdÄ±ÄÄ±nÄ±z Åekliyle gÃ¼nlÃ¼kÃ§Ã¼ye geÃ§irilir. (KÄ±sa biÃ§im: -l)
@@ -886,9 +886,10 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;uzantÄ±lar&gt;
-                     Hangi proje dosyasÄ±nÄ±n oluÅturulacaÄÄ± belirlenirken
-                     yoksayÄ±lacak uzantÄ±larÄ±n listesi. Birden Ã§ok uzantÄ±yÄ±
-                     birbirinden ayÄ±rmak iÃ§in noktalÄ± virgÃ¼l veya virgÃ¼l kullanÄ±n.
+                     Hangi proje dosyasÄ±nÄ±n oluÅturulacaÄÄ± belirlenirken 
+                     yoksayÄ±lacak uzantÄ±larÄ±n listesi. Birden Ã§ok uzantÄ±yÄ± 
+                     birbirinden ayÄ±rmak iÃ§in noktalÄ± virgÃ¼l veya 
+                     virgÃ¼l kullanÄ±n.
                      (KÄ±sa biÃ§im: -ignore)
                      Ãrnek:
                        -ignoreProjectExtensions:.sln
@@ -978,6 +979,7 @@
                      DosyalarÄ±n konumu ve fileLogger'Ä±n diÄer parametreleri 
                      "/fileLoggerParameters" anahtarÄ±nÄ±n eklenmesi yoluyla
                      belirtilebilir.
+
                      GÃ¼nlÃ¼k dosyasÄ± adÄ± fileLoggerParameters anahtarÄ±
                      aracÄ±lÄ±ÄÄ±yla ayarlanÄ±rsa daÄÄ±tÄ±lmÄ±Å gÃ¼nlÃ¼kÃ§Ã¼ fileName 
                      deÄerini Åablon olarak kullanÄ±p her dÃ¼ÄÃ¼mÃ¼n gÃ¼nlÃ¼k dosyasÄ±nÄ±
@@ -1024,31 +1026,32 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parametreler&gt;
                      Dosya gÃ¼nlÃ¼kÃ§Ã¼leri iÃ§in ek parametreler saÄlar.
-                     Bu anahtarÄ±n olmasÄ± karÅÄ±lÄ±k gelen -fileLogger[n]
+                     Bu anahtarÄ±n olmasÄ± karÅÄ±lÄ±k gelen -fileLogger[n] 
                      anahtarÄ±nÄ±n olduÄu anlamÄ±na gelir.
                      "n" varsa, 1-9 arasÄ±nda bir rakam olabilir.
-                     DaÄÄ±tÄ±lmÄ±Å dosya gÃ¼nlÃ¼kÃ§Ã¼leri varsa -fileLoggerParameters
-                     bunlar tarafÄ±ndan da kullanÄ±lÄ±r; -distributedFileLogger aÃ§Ä±klamasÄ±na bakÄ±n.
+                     DaÄÄ±tÄ±lmÄ±Å dosya gÃ¼nlÃ¼kÃ§Ã¼leri varsa -fileLoggerParameters 
+                     bunlar tarafÄ±ndan da kullanÄ±lÄ±r; -distributedFileLogger 
+                     aÃ§Ä±klamasÄ±na bakÄ±n.
                      (KÄ±sa biÃ§im: -flp[n])
-                     Konsol gÃ¼nlÃ¼kÃ§Ã¼sÃ¼ iÃ§in listelenenlerle aynÄ± parametreler
+                     Konsol gÃ¼nlÃ¼kÃ§Ã¼sÃ¼ iÃ§in listelenenlerle aynÄ± parametreler 
                      kullanÄ±labilir. KullanÄ±labilecek bazÄ± ek parametreler:
-                        LogFile--OluÅturma gÃ¼nlÃ¼ÄÃ¼nÃ¼n yazÄ±lacaÄÄ± gÃ¼nlÃ¼k
+                        LogFile--OluÅturma gÃ¼nlÃ¼ÄÃ¼nÃ¼n yazÄ±lacaÄÄ± gÃ¼nlÃ¼k 
                             dosyasÄ±nÄ±n yolu.
-                        Append--Derleme gÃ¼nlÃ¼ÄÃ¼nÃ¼n gÃ¼n dosyasÄ±nÄ±n sonuna mÄ±
-                            ekleneceÄini yoksa Ã¼zerine mi yazÄ±lacaÄÄ±nÄ±
-                            belirler. Anahtar ayarlandÄ±ÄÄ±nda oluÅturma gÃ¼nlÃ¼ÄÃ¼
-                            dosyanÄ±n sonuna eklenir. Anahtar ayarlanmadÄ±ÄÄ±nda
-                            varolan gÃ¼nlÃ¼k dosyasÄ±nÄ±n Ã¼zerine yazÄ±lÄ±r.
+                        Append--Derleme gÃ¼nlÃ¼ÄÃ¼nÃ¼n gÃ¼n dosyasÄ±nÄ±n sonuna mÄ± 
+                            ekleneceÄini yoksa Ã¼zerine mi yazÄ±lacaÄÄ±nÄ± 
+                            belirler. Anahtar ayarlandÄ±ÄÄ±nda oluÅturma gÃ¼nlÃ¼ÄÃ¼ 
+                            dosyanÄ±n sonuna eklenir. Anahtar ayarlanmadÄ±ÄÄ±nda 
+                            varolan gÃ¼nlÃ¼k dosyasÄ±nÄ±n Ã¼zerine yazÄ±lÄ±r. 
                             VarsayÄ±lan: gÃ¼nlÃ¼k dosyasÄ±nÄ±n sonuna eklenmez.
-                        Encoding--DosyanÄ±n kodlamasÄ±nÄ± belirtir; Ã¶rneÄin,
+                        Encoding--DosyanÄ±n kodlamasÄ±nÄ± belirtir; Ã¶rneÄin, 
                             UTF-8, Unicode veya ASCII
                      VarsayÄ±lan ayrÄ±ntÄ± dÃ¼zeyi ayarÄ± Detailed'dÄ±r.
                      Ãrnekler:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-                       -flp1:warningsonly;logfile=msbuild.wrn
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+                       -flp1:warningsonly;logfile=msbuild.wrn 
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1072,7 +1075,8 @@
                        -nr:true
     </source>
         <target state="translated">  -nodeReuse:&lt;parametreler&gt;
-                     MSBuild dÃ¼ÄÃ¼mlerinin yeniden kullanÄ±mÄ±nÄ± etkinleÅtirir veya devre dÄ±ÅÄ± bÄ±rakÄ±r.
+                     MSBuild dÃ¼ÄÃ¼mlerinin yeniden kullanÄ±mÄ±nÄ± etkinleÅtirir
+                     veya devre dÄ±ÅÄ± bÄ±rakÄ±r.
                      Parametreler:
                      True --Derleme tamamlandÄ±ktan sonra dÃ¼ÄÃ¼mler kalÄ±r ve
                             izleyen derlemelerde yeniden kullanÄ±lÄ±r (varsayÄ±lan)
@@ -1403,7 +1407,7 @@
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="translated">MSBUILD : error MSB1066: terminalLoggerParameters anahtarÄ± kullanÄ±lÄ±yorsa terminal gÃ¼nlÃ¼kÃ§Ã¼sÃ¼ iÃ§in bir veya birden Ã§ok parametre belirtin</target>
+        <target state="translated">MSBUILD : error MSB1066: -terminalLoggerParameters anahtarÄ± kullanÄ±lÄ±yorsa terminal gÃ¼nlÃ¼kÃ§Ã¼sÃ¼ iÃ§in bir veya birden Ã§ok parametre belirtin</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 2a4877909af..10005ca388c 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -573,11 +573,11 @@
         <target state="translated">  -logger:&lt;è¨éå¨&gt;   ä½¿ç¨æ­¤è¨éå¨å¯è¨é MSBuild çäºä»¶ã
                      è¥è¦æå®å¤åè¨éå¨ï¼è«åå¥æå®æ¯åè¨éå¨ã
                      &lt;è¨éå¨&gt; èªæ³çº:
-                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
+                       [&lt;é¡å¥&gt;,]&lt;çµä»¶&gt;[,&lt;é¸é &gt;][;&lt;åæ¸&gt;]
                      &lt;è¨éå¨é¡å¥&gt; èªæ³çº:
                        [&lt;ä¸é¨åæå®æ´çå½åç©ºé&gt;.]&lt;è¨éå¨é¡å¥åç¨±&gt;
                      &lt;è¨éå¨çµä»¶&gt; èªæ³çº:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;çµä»¶åç¨±&gt;[,&lt;strong name&gt;] | &lt;çµä»¶æªæ¡&gt;}
                      è¨éå¨é¸é ææå® MSBuild å»ºç«è¨éå¨çæ¹å¼ã
                      &lt;è¨éå¨åæ¸&gt; æ¯é¸ææ§åæ¸ï¼å¶æä¾æ¨è¼¸å¥çå§å®¹ï¼
                      å®å¨ä¸æ¨£å°å³éå°è¨éå¨ã(ç°¡ç­å½¢å¼: -l)
@@ -855,11 +855,11 @@
                      è¥è¦æå®å¤åè¨éå¨ï¼è«åå¥æå®æ¯åè¨éå¨ã
                      (ç°¡ç­å½¢å¼ -dl)
                      &lt;è¨éå¨&gt; èªæ³çº:
-                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
+                       [&lt;é¡å¥&gt;,]&lt;çµä»¶&gt;[,&lt;é¸é &gt;][;&lt;åæ¸&gt;]
                      &lt;è¨éå¨é¡å¥&gt; èªæ³çº:
                        [&lt;ä¸é¨åæå®æ´çå½åç©ºé&gt;.]&lt;è¨éå¨é¡å¥åç¨±&gt;
                      &lt;è¨éå¨çµä»¶&gt; èªæ³çº:
-                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                       {&lt;çµä»¶åç¨±&gt;[,&lt;strong name&gt;] | &lt;çµä»¶æªæ¡&gt;}
                      è¨éå¨é¸é ææå® MSBuild å»ºç«è¨éå¨çæ¹å¼ã
                      &lt;è¨éå¨åæ¸&gt; æ¯é¸ææ§åæ¸ï¼å¶æä¾æ¨è¼¸å¥çå§å®¹ï¼
                      å®å¨ä¸æ¨£å°å³éå°è¨éå¨ã(ç°¡ç­å½¢å¼: -l)
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 0210df145df..68fed6e926f 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -211,9 +211,15 @@ private static void HandleConfigurationException(Exception ex)
         /// MSBuild no longer runs any arbitrary code (tasks or loggers) on the main thread, so it never needs the
         /// main thread to be in an STA. Accordingly, to avoid ambiguity, we explicitly use the [MTAThread] attribute.
         /// This doesn't actually do any work unless COM interop occurs for some reason.
+        /// We use the MultiDomainHost loader policy because we may create secondary AppDomains and need NGEN images
+        /// for Framework / GACed assemblies to be loaded domain neutral so their native images can be used.
+        /// See <see cref="NuGetFrameworkWrapper"/>.
         /// </remarks>
         /// <returns>0 on success, 1 on failure</returns>
         [MTAThread]
+#if FEATURE_APPDOMAIN
+        [LoaderOptimization(LoaderOptimization.MultiDomainHost)]
+#endif
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
         public static int Main(
 #if !FEATURE_GET_COMMANDLINE
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index b2f5106d38d..2f3dce9f66b 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -120,6 +120,7 @@ private static BuildEnvironment Initialize()
                 BuildEnvironmentMode.None,
                 msbuildExePath,
                 runningTests: s_runningTests(),
+                runningInMSBuildExe: false,
                 runningInVisualStudio: false,
                 visualStudioPath: null);
         }
@@ -153,6 +154,7 @@ private static BuildEnvironment TryFromVisualStudioProcess()
                 BuildEnvironmentMode.VisualStudio,
                 msBuildExe,
                 runningTests: false,
+                runningInMSBuildExe: false,
                 runningInVisualStudio: true,
                 visualStudioPath: vsRoot);
         }
@@ -173,6 +175,7 @@ private static BuildEnvironment TryFromMSBuildProcess()
                     BuildEnvironmentMode.VisualStudio,
                     msBuildExe,
                     runningTests: false,
+                    runningInMSBuildExe: true,
                     runningInVisualStudio: false,
                     visualStudioPath: GetVsRootFromMSBuildAssembly(msBuildExe));
             }
@@ -182,6 +185,7 @@ private static BuildEnvironment TryFromMSBuildProcess()
                 BuildEnvironmentMode.Standalone,
                 msBuildExe,
                 runningTests: false,
+                runningInMSBuildExe: true,
                 runningInVisualStudio: false,
                 visualStudioPath: null);
         }
@@ -223,6 +227,7 @@ private static BuildEnvironment TryFromMSBuildAssembly()
                     BuildEnvironmentMode.Standalone,
                     msBuildPath,
                     runningTests: s_runningTests(),
+                    runningInMSBuildExe: false,
                     runningInVisualStudio: false,
                     visualStudioPath: null);
             }
@@ -244,6 +249,7 @@ private static BuildEnvironment TryFromMSBuildExeUnderVisualStudio(string msbuil
                         BuildEnvironmentMode.VisualStudio,
                         GetMSBuildExeFromVsRoot(visualStudioRoot),
                         runningTests: s_runningTests(),
+                        runningInMSBuildExe: false,
                         runningInVisualStudio: false,
                         visualStudioPath: visualStudioRoot);
             }
@@ -274,6 +280,7 @@ private static BuildEnvironment TryFromDevConsole()
                 BuildEnvironmentMode.VisualStudio,
                 GetMSBuildExeFromVsRoot(vsInstallDir),
                 runningTests: false,
+                runningInMSBuildExe: false,
                 runningInVisualStudio: false,
                 visualStudioPath: vsInstallDir);
         }
@@ -306,6 +313,7 @@ private static BuildEnvironment TryFromSetupApi()
                 BuildEnvironmentMode.VisualStudio,
                 GetMSBuildExeFromVsRoot(instances[0].Path),
                 runningTests: false,
+                runningInMSBuildExe: false,
                 runningInVisualStudio: false,
                 visualStudioPath: instances[0].Path);
         }
@@ -338,6 +346,7 @@ private static BuildEnvironment TryFromStandaloneMSBuildExe(string msBuildExePat
                     BuildEnvironmentMode.Standalone,
                     msBuildExePath,
                     runningTests: s_runningTests(),
+                    runningInMSBuildExe: false,
                     runningInVisualStudio: false,
                     visualStudioPath: null);
             }
@@ -527,13 +536,15 @@ internal enum BuildEnvironmentMode
     /// </summary>
     internal sealed class BuildEnvironment
     {
-        public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath, bool runningTests, bool runningInVisualStudio, string visualStudioPath)
+        public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath, bool runningTests, bool runningInMSBuildExe, bool runningInVisualStudio,
+                string visualStudioPath)
         {
             FileInfo currentMSBuildExeFile = null;
             DirectoryInfo currentToolsDirectory = null;
 
             Mode = mode;
             RunningTests = runningTests;
+            RunningInMSBuildExe = runningInMSBuildExe;
             RunningInVisualStudio = runningInVisualStudio;
             CurrentMSBuildExePath = currentMSBuildExePath;
             VisualStudioInstallRootDirectory = visualStudioPath;
@@ -620,6 +631,11 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA
         /// </summary>
         internal bool RunningTests { get; }
 
+        /// <summary>
+        /// Returns true when the entry point application is MSBuild.exe.
+        /// </summary>
+        internal bool RunningInMSBuildExe { get; }
+
         /// <summary>
         /// Returns true when the entry point application is Visual Studio.
         /// </summary>
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 1792dad790f..3c15516a43f 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -16,10 +16,11 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
+
 using Shouldly;
+
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -27,6 +28,20 @@ namespace Microsoft.Build.UnitTests
 {
     public class Copy_Tests : IDisposable
     {
+        public static IEnumerable<object[]> GetDestinationExists() =>
+            new List<object[]>
+            {
+                new object[] { true },
+                new object[] { false },
+            };
+
+        public static IEnumerable<object[]> GetNullAndEmptyArrays() =>
+            new List<object[]>
+            {
+                new object[] { null },
+                new object[] { Array.Empty<ITaskItem>() },
+            };
+
         /// <summary>
         /// Gets data for testing with combinations of isUseHardLinks and isUseSymbolicLinks.
         /// Index 0 is the value for isUseHardLinks.
@@ -112,6 +127,356 @@ public void Dispose()
             Copy.RefreshInternalEnvironmentValues();
         }
 
+        [Fact]
+        public void CopyWithNoInput()
+        {
+            var task = new Copy { BuildEngine = new MockEngine(true), };
+            task.Execute().ShouldBeTrue();
+            (task.CopiedFiles == null || task.CopiedFiles.Length == 0).ShouldBeTrue();
+            (task.DestinationFiles == null || task.DestinationFiles.Length == 0).ShouldBeTrue();
+            task.WroteAtLeastOneFile.ShouldBeFalse();
+        }
+
+        [Fact]
+        public void CopyWithMatchingSourceFilesToDestinationFiles()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var sourceFile = env.CreateFile("source.txt");
+
+                var task = new Copy
+                {
+                    BuildEngine = new MockEngine(true),
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination.txt") },
+                    RetryDelayMilliseconds = 1,
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(1);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(1);
+                task.WroteAtLeastOneFile.ShouldBeTrue();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetDestinationExists))]
+        public void CopyWithSourceFilesToDestinationFolder(bool isDestinationExists)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var sourceFile = env.CreateFile("source.txt");
+                var destinationFolder = env.CreateFolder(isDestinationExists);
+
+                var task = new Copy
+                {
+                    BuildEngine = new MockEngine(true),
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                    RetryDelayMilliseconds = 1,
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(1);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(1);
+                task.WroteAtLeastOneFile.ShouldBeTrue();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetDestinationExists))]
+        public void CopyWithSourceFoldersToDestinationFolder(bool isDestinationExists)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var s0Folder = env.DefaultTestDirectory.CreateDirectory("source0");
+                s0Folder.CreateFile("00.txt");
+                s0Folder.CreateFile("01.txt");
+                var s0AFolder = s0Folder.CreateDirectory("a");
+                s0AFolder.CreateFile("a0.txt");
+                s0AFolder.CreateFile("a1.txt");
+                _ = s0Folder.CreateDirectory("b");
+                var s0CFolder = s0Folder.CreateDirectory("c");
+                s0CFolder.CreateFile("c0.txt");
+
+                var s1Folder = env.DefaultTestDirectory.CreateDirectory("source1");
+                s1Folder.CreateFile("10.txt");
+                s1Folder.CreateFile("11.txt");
+                var s1AFolder = s1Folder.CreateDirectory("a");
+                s1AFolder.CreateFile("a0.txt");
+                s1AFolder.CreateFile("a1.txt");
+                var s1BFolder = s1Folder.CreateDirectory("b");
+                s1BFolder.CreateFile("b0.txt");
+
+                var destinationFolder = env.CreateFolder(isDestinationExists);
+
+                var task = new Copy
+                {
+                    BuildEngine = new MockEngine(true),
+                    SourceFolders = new ITaskItem[] { new TaskItem(s0Folder.Path), new TaskItem(s1Folder.Path) },
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                    RetryDelayMilliseconds = 1,
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(10);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(10);
+                task.WroteAtLeastOneFile.ShouldBeTrue();
+                Directory.Exists(Path.Combine(destinationFolder.Path, "source0")).ShouldBeTrue();
+                Directory.Exists(Path.Combine(destinationFolder.Path, "source1")).ShouldBeTrue();
+            }
+        }
+
+        [Fact]
+        public void CopyWithNoSource()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var destinationFolder = env.CreateFolder(true);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(0);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(0);
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetDestinationExists))]
+        public void CopyWithMultipleSourceTypes(bool isDestinationExists)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+                var sourceFolder = env.DefaultTestDirectory.CreateDirectory("source");
+                sourceFolder.CreateFile("source.txt");
+                var aDirectory = sourceFolder.CreateDirectory("a");
+                aDirectory.CreateFile("a.txt");
+                sourceFolder.CreateDirectory("b");
+                var destinationFolder = env.CreateFolder(isDestinationExists);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    SourceFolders = new ITaskItem[] { new TaskItem(sourceFolder.Path) },
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(3);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(3);
+                task.WroteAtLeastOneFile.ShouldBeTrue();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetNullAndEmptyArrays))]
+        public void CopyWithEmptySourceFiles(ITaskItem[] sourceFiles)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var destinationFolder = env.CreateFolder(true);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = sourceFiles,
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(0);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(0);
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetNullAndEmptyArrays))]
+        public void CopyWithEmptySourceFolders(ITaskItem[] sourceFolders)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var destinationFolder = env.CreateFolder(true);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFolders = sourceFolders,
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(0);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(0);
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetNullAndEmptyArrays))]
+        public void CopyWithNoDestination(ITaskItem[] destinationFiles)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = destinationFiles,
+                };
+                task.Execute().ShouldBeFalse();
+                // Copy.NeedsDestination (MSB3023) or General.TwoVectorsMustHaveSameLength (MSB3094)
+                engine.AssertLogContains(destinationFiles == null ? "MSB3023" : "MSB3094");
+                task.CopiedFiles.ShouldBeNull();
+                (task.DestinationFiles == null || task.DestinationFiles.Length == 0).ShouldBeTrue();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Fact]
+        public void CopyWithMultipleDestinationTypes()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+                var destinationFolder = env.CreateFolder(true);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination.txt") },
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                };
+                task.Execute().ShouldBeFalse();
+                engine.AssertLogContains("MSB3022"); // Copy.ExactlyOneTypeOfDestination
+                task.CopiedFiles.ShouldBeNull();
+                task.DestinationFiles.ShouldNotBeNull();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Fact]
+        public void CopyWithSourceFoldersAndDestinationFiles()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+                var sourceFolder = env.CreateFolder(true);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    SourceFolders = new ITaskItem[] { new TaskItem(sourceFolder.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination0.txt"), new TaskItem("destination1.txt") },
+                };
+                task.Execute().ShouldBeFalse();
+                engine.AssertLogContains("MSB3896"); // Copy.IncompatibleParameters
+                task.CopiedFiles.ShouldBeNull();
+                task.DestinationFiles.ShouldNotBeNull();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Fact]
+        public void CopyWithDifferentLengthSourceFilesToDestinationFiles()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination0.txt"), new TaskItem("destination1.txt") },
+                };
+                task.Execute().ShouldBeFalse();
+                engine.AssertLogContains("MSB3094"); // General.TwoVectorsMustHaveSameLength
+                task.CopiedFiles.ShouldBeNull();
+                task.DestinationFiles.ShouldNotBeNull();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        /// <summary>
+        /// Verifies that we error for retries less than 0
+        /// </summary>
+        [Fact]
+        public void CopyWithInvalidRetryCount()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination.txt") },
+                    Retries = -1,
+                };
+                task.Execute().ShouldBeFalse();
+                engine.AssertLogContains("MSB3028"); // Copy.InvalidRetryCount
+                task.CopiedFiles.ShouldBeNull();
+                task.DestinationFiles.ShouldNotBeNull();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        /// <summary>
+        /// Verifies that we error for retry delay less than 0
+        /// </summary>
+        [Fact]
+        public void CopyWithInvalidRetryDelay()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination.txt") },
+                    RetryDelayMilliseconds = -1,
+                };
+                task.Execute().ShouldBeFalse();
+                engine.AssertLogContains("MSB3029"); // Copy.InvalidRetryDelay
+                task.CopiedFiles.ShouldBeNull();
+                task.DestinationFiles.ShouldNotBeNull();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
         /// <summary>
         /// If OnlyCopyIfDifferent is set to "true" then we shouldn't copy over files that
         /// have the same date and time.
@@ -1898,6 +2263,30 @@ public void ExitGracefullyOnInvalidPathCharacters(bool isUseHardLinks, bool isUs
             ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
         }
 
+        /// <summary>
+        /// If the DestinationFolder parameter is given invalid path characters, make sure the task exits gracefully.
+        /// </summary>
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void ExitGracefullyOnInvalidPathCharactersInDestinationFolder(bool isUseHardLinks, bool isUseSymbolicLinks)
+        {
+            var t = new Copy
+            {
+                RetryDelayMilliseconds = 1,  // speed up tests!
+                BuildEngine = new MockEngine(_testOutputHelper),
+                SourceFiles = new ITaskItem[] { new TaskItem("foo") },
+                DestinationFolder = new TaskItem("here | there"),
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
+            };
+
+            bool result = t.Execute();
+
+            // Expect for there to have been no copies.
+            Assert.False(result);
+            ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
+        }
+
         /// <summary>
         /// Verifies that we error for retries less than 0
         /// </summary>
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 381fa520766..2c3e3779d45 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -2066,12 +2066,6 @@ internal void WriteStateFile()
             {
                 // Either the cache is dirty (we added or updated an item) or the number of items actually used is less than what
                 // we got by reading the state file prior to execution. Serialize the cache into the state file.
-                if (FailIfNotIncremental)
-                {
-                    Log.LogErrorFromResources("ResolveAssemblyReference.WritingCacheFile", _stateFile);
-                    return;
-                }
-
                 _cache.SerializeCache(_stateFile, Log);
             }
         }
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index cdb28ee4dc9..8d8b081a208 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -8,6 +8,7 @@
 using System.Runtime.InteropServices;
 using System.Threading;
 using System.Threading.Tasks.Dataflow;
+
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -99,9 +100,10 @@ public Copy()
         /// </summary>
         private const int RetryDelayMillisecondsDefault = 1000;
 
-        [Required]
         public ITaskItem[] SourceFiles { get; set; }
 
+        public ITaskItem[] SourceFolders { get; set; }
+
         public ITaskItem DestinationFolder { get; set; }
 
         /// <summary>
@@ -402,7 +404,7 @@ internal bool Execute(
             int parallelism)
         {
             // If there are no source files then just return success.
-            if (SourceFiles == null || SourceFiles.Length == 0)
+            if (IsSourceSetEmpty())
             {
                 DestinationFiles = Array.Empty<ITaskItem>();
                 CopiedFiles = Array.Empty<ITaskItem>();
@@ -643,6 +645,11 @@ private bool CopyParallel(
             return success;
         }
 
+        private bool IsSourceSetEmpty()
+        {
+            return (SourceFiles == null || SourceFiles.Length == 0) && (SourceFolders == null || SourceFolders.Length == 0);
+        }
+
         /// <summary>
         /// Verify that the inputs are correct.
         /// </summary>
@@ -661,7 +668,7 @@ private bool ValidateInputs()
                 return false;
             }
 
-            // There must be a destinationFolder (either files or directory).
+            // There must be a destination (either files or directory).
             if (DestinationFiles == null && DestinationFolder == null)
             {
                 Log.LogErrorWithCodeFromResources("Copy.NeedsDestination", "DestinationFiles", "DestinationFolder");
@@ -675,6 +682,13 @@ private bool ValidateInputs()
                 return false;
             }
 
+            // SourceFolders and DestinationFiles can't be used together.
+            if (SourceFolders != null && DestinationFiles != null)
+            {
+                Log.LogErrorWithCodeFromResources("Copy.IncompatibleParameters", "SourceFolders", "DestinationFiles");
+                return false;
+            }
+
             // If the caller passed in DestinationFiles, then its length must match SourceFiles.
             if (DestinationFiles != null && DestinationFiles.Length != SourceFiles.Length)
             {
@@ -682,7 +696,6 @@ private bool ValidateInputs()
                 return false;
             }
 
-
             if (ErrorIfLinkFails && !UseHardlinksIfPossible && !UseSymboliclinksIfPossible)
             {
                 Log.LogErrorWithCodeFromResources("Copy.ErrorIfLinkFailsSetWithoutLinkOption");
@@ -694,41 +707,127 @@ private bool ValidateInputs()
 
         /// <summary>
         /// Set up our list of destination files.
+        /// For SourceFiles: Apply DestinationFolder to each SourceFiles item to create a DestinationFiles item.
+        /// For SourceFolders: With each SourceFolders item, get the files in the represented directory. Create both SourceFiles and DestinationFiles items.
         /// </summary>
         /// <returns>False if an error occurred, implying aborting the overall copy operation.</returns>
         private bool InitializeDestinationFiles()
         {
-            if (DestinationFiles == null)
+            bool isSuccess = true;
+
+            try
             {
                 // If the caller passed in DestinationFolder, convert it to DestinationFiles
-                DestinationFiles = new ITaskItem[SourceFiles.Length];
-
-                for (int i = 0; i < SourceFiles.Length; ++i)
+                if (DestinationFiles == null && SourceFiles != null)
                 {
-                    // Build the correct path.
-                    string destinationFile;
-                    try
+                    DestinationFiles = new ITaskItem[SourceFiles.Length];
+
+                    for (int i = 0; i < SourceFiles.Length; ++i)
                     {
-                        destinationFile = Path.Combine(DestinationFolder.ItemSpec, Path.GetFileName(SourceFiles[i].ItemSpec));
+                        // Build the correct path.
+                        if (!TryPathOperation(
+                                () => Path.Combine(DestinationFolder.ItemSpec, Path.GetFileName(SourceFiles[i].ItemSpec)),
+                                SourceFiles[i].ItemSpec,
+                                DestinationFolder.ItemSpec,
+                                out string destinationFile))
+                        {
+                            isSuccess = false;
+                            break;
+                        }
+
+                        // Initialize the destinationFolder item.
+                        // ItemSpec is unescaped, and the TaskItem constructor expects an escaped input, so we need to
+                        // make sure to re-escape it here.
+                        DestinationFiles[i] = new TaskItem(EscapingUtilities.Escape(destinationFile));
+
+                        // Copy meta-data from source to destinationFolder.
+                        SourceFiles[i].CopyMetadataTo(DestinationFiles[i]);
                     }
-                    catch (ArgumentException e)
+                }
+
+                if (isSuccess && SourceFolders != null && SourceFolders.Length > 0)
+                {
+                    var sourceFiles = SourceFiles != null ? new List<ITaskItem>(SourceFiles) : new List<ITaskItem>();
+                    var destinationFiles = DestinationFiles != null ? new List<ITaskItem>(DestinationFiles) : new List<ITaskItem>();
+
+                    foreach (ITaskItem sourceFolder in SourceFolders)
                     {
-                        Log.LogErrorWithCodeFromResources("Copy.Error", SourceFiles[i].ItemSpec, DestinationFolder.ItemSpec, e.Message);
-                        // Clear the outputs.
-                        DestinationFiles = Array.Empty<ITaskItem>();
-                        return false;
-                    }
+                        string src = FileUtilities.NormalizePath(sourceFolder.ItemSpec);
+                        string srcName = Path.GetFileName(src);
 
-                    // Initialize the destinationFolder item.
-                    // ItemSpec is unescaped, and the TaskItem constructor expects an escaped input, so we need to
-                    // make sure to re-escape it here.
-                    DestinationFiles[i] = new TaskItem(EscapingUtilities.Escape(destinationFile));
+                        (string[] filesInFolder, _, _) = FileMatcher.Default.GetFiles(src, "**");
 
-                    // Copy meta-data from source to destinationFolder.
-                    SourceFiles[i].CopyMetadataTo(DestinationFiles[i]);
+                        foreach (string file in filesInFolder)
+                        {
+                            if (!TryPathOperation(
+                                    () => Path.Combine(src, file),
+                                    sourceFolder.ItemSpec,
+                                    DestinationFolder.ItemSpec,
+                                    out string sourceFile))
+                            {
+                                isSuccess = false;
+                                break;
+                            }
+
+                            if (!TryPathOperation(
+                                    () => Path.Combine(DestinationFolder.ItemSpec, srcName, file),
+                                    sourceFolder.ItemSpec,
+                                    DestinationFolder.ItemSpec,
+                                    out string destinationFile))
+                            {
+                                isSuccess = false;
+                                break;
+                            }
+
+
+                            var item = new TaskItem(EscapingUtilities.Escape(sourceFile));
+                            sourceFolder.CopyMetadataTo(item);
+                            sourceFiles.Add(item);
+
+                            item = new TaskItem(EscapingUtilities.Escape(destinationFile));
+                            sourceFolder.CopyMetadataTo(item);
+                            destinationFiles.Add(item);
+                        }
+                    }
+
+                    SourceFiles = sourceFiles.ToArray();
+                    DestinationFiles = destinationFiles.ToArray();
+                }
+            }
+            finally
+            {
+                if (!isSuccess)
+                {
+                    // Clear the outputs.
+                    DestinationFiles = Array.Empty<ITaskItem>();
                 }
             }
 
+            return isSuccess;
+        }
+
+        /// <summary>
+        /// Tries the path operation. Logs a 'Copy.Error' if an exception is thrown.
+        /// </summary>
+        /// <param name="operation">The operation.</param>
+        /// <param name="src">The source to use for the log message.</param>
+        /// <param name="dest">The destination to use for the log message.</param>
+        /// <param name="resultPathOperation">The result of the path operation.</param>
+        /// <returns></returns>
+        private bool TryPathOperation(Func<string> operation, string src, string dest, out string resultPathOperation)
+        {
+            resultPathOperation = string.Empty;
+
+            try
+            {
+                resultPathOperation = operation();
+            }
+            catch (ArgumentException e)
+            {
+                Log.LogErrorWithCodeFromResources("Copy.Error", src, dest, e.Message);
+                return false;
+            }
+
             return true;
         }
 
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 1ed602b0251..7ea4d4d06fb 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -323,7 +323,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <!-- Example, C:\MyProjects\MyProject\bin\Debug\MyAssembly.dll -->
     <TargetPath Condition=" '$(TargetPath)' == '' ">$(TargetDir)$(TargetFileName)</TargetPath>
 
-    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' and ('$(ProduceReferenceAssemblyInOutDir)' == 'true' or '$([MSBuild]::AreFeaturesEnabled(17.0))' != 'true' ) ">$([MSBuild]::NormalizePath($(TargetDir), 'ref', $(TargetFileName)))</TargetRefPath>
+    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' and '$(ProduceReferenceAssemblyInOutDir)' == 'true' ">$([MSBuild]::NormalizePath($(TargetDir), 'ref', $(TargetFileName)))</TargetRefPath>
     <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' ">$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(IntermediateOutputPath), 'ref', $(TargetFileName)))</TargetRefPath>
 
     <!-- Example, C:\MyProjects\MyProject\ -->
@@ -1374,6 +1374,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_Temp Remove="@(_Temp)" />
     </ItemGroup>
 
+    <!-- RESOURCE ITEMS -->
+    <AssignLinkMetadata Items="@(Resource)"
+                        Condition="'@(Resource)' != '' and '%(Resource.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)' and $([MSBuild]::AreFeaturesEnabled('17.10'))">
+      <Output TaskParameter="OutputItems" ItemName="_Temp" />
+    </AssignLinkMetadata>
+
+    <ItemGroup Condition="$([MSBuild]::AreFeaturesEnabled('17.10'))">
+      <Resource Remove="@(_Temp)" />
+      <Resource Include="@(_Temp)" />
+      <_Temp Remove="@(_Temp)" />
+    </ItemGroup>
+
   </Target>
 
   <!--
@@ -5012,7 +5024,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       This target enforces the dependency.
     -->
 
-    <MSBuildCopyContentTransitively Condition=" '$(MSBuildCopyContentTransitively)' == '' and $([MSBuild]::AreFeaturesEnabled('17.0'))">true</MSBuildCopyContentTransitively>
+    <MSBuildCopyContentTransitively Condition=" '$(MSBuildCopyContentTransitively)' == ''">true</MSBuildCopyContentTransitively>
 
     <_TargetsThatPrepareProjectReferences Condition=" '$(MSBuildCopyContentTransitively)' == 'true' ">
       AssignProjectConfiguration;
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 3ba788b9c76..d4c6d77ab34 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -1776,10 +1776,6 @@
     <value>Assembly file '{0}' could not be opened -- PE image doesn't contain managed metadata.</value>
     <comment></comment>
   </data>
-  <data name="ResolveAssemblyReference.WritingCacheFile">
-    <value>Updating assembly cache file "{0}".</value>
-    <comment></comment>
-  </data>
   <!--
         The ResolveComReference message bucket is: MSB3281 - MSB3320
 
@@ -2793,6 +2789,10 @@
     <value>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</value>
     <comment>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</comment>
   </data>
+  <data name="Copy.IncompatibleParameters">
+    <value>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</value>
+    <comment>{StrBegin="MSB3896: "}</comment>
+  </data>
 
   <!--
         MSB3901 - MSB3910   Task: Telemetry
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 162dd1ea684..117552d0067 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: PÅi kopÃ­rovÃ¡nÃ­ â{1}â do â{2}â doÅ¡lo k vÃ½jimce {0} a HR je {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: V souboru projektu byl zadÃ¡n jak parametr {0}, tak parametr {1}. Nelze je vÅ¡ak pouÅ¾Ã­t oba najednou. Zvolte prosÃ­m jenom jeden z nich.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: NedÃ¡ se pouÅ¾Ã­t odkaz pro kopÃ­rovÃ¡nÃ­ {0} do {1}.</target>
@@ -2175,11 +2180,6 @@
         <target state="translated">NÃ¡zev redistribuÄnÃ­ho balÃ­Äku v elementu FileList v souboru seznamu redistribuÄnÃ­ho balÃ­Äku {0} je null nebo prÃ¡zdnÃ½. NÃ¡zev redistribuÄnÃ­ho balÃ­Äku nesmÃ­ bÃ½t null ani prÃ¡zdnÃ½.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Aktualizuje se soubor mezipamÄti sestavenÃ­ â{0}â.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">Odkaz modelu COM {0} je definiÄnÃ­ sestavenÃ­ ovlÃ¡dacÃ­ho prvku ActiveX {1}, ale kompilÃ¡tor ho oznaÄil pÅÃ­znakem /link. S tÃ­mto odkazem modelu COM se bude zachÃ¡zet jako s odkazem a nebude propojen.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 58d7ba7e5dc..11600335b91 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: Erhalt von {0} Kopieren von "{1}" zu "{2}" und HR ist {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: Sowohl "{0}" als auch "{1}" wurden als Parameter in der Projektdatei angegeben, kÃ¶nnen aber nicht zusammen verwendet werden. WÃ¤hlen Sie eins oder das andere aus.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Es konnte kein Link verwendet werden, um "{0}" in "{1}" zu kopieren.</target>
@@ -2175,11 +2180,6 @@
         <target state="translated">Der Redist-Name im FileList-Element der Redistributable-Listendatei "{0}" ist NULL oder leer. Vergewissern Sie sich, dass der Redist-Name nicht NULL oder leer ist.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Aktualisiert Assemblycachedatei "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">Der COM-Verweis "{0}" ist die Interopassembly fÃ¼r das ActiveX-Steuerelement "{1}". Entsprechend der Markierung ist der Verweis jedoch durch den Compiler mit dem /link-Flag verknÃ¼pft. Der COM-Verweis wird als Verweis behandelt und nicht verknÃ¼pft.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 7715a0c317b..5c2e9732092 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -118,7 +118,7 @@
       </trans-unit>
       <trans-unit id="AxTlbBaseTask.StrongNameUtils.NoPublicKeySpecified">
         <source>MSB3654: Delay signing requires that at least a public key be specified.  Please either supply a public key using the KeyFile or KeyContainer properties, or disable delay signing.</source>
-        <target state="translated">MSB3654: La firma retrasada requiere que se especifique al menos una clave pÃºblica.  Proporcione una clave pÃºblica mediante las propiedades KeyFile o KeyContainer, o deshabilite la firma retrasada.</target>
+        <target state="translated">MSB3654: La firma retardada requiere que se especifique al menos una clave pÃºblica.  Proporcione una clave pÃºblica mediante las propiedades KeyFile o KeyContainer, o deshabilite la firma retardada.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: Se obtuvo {0} al copiar "{1}" en "{2}" y HR es {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: "{0}" y "{1}" se especificaron como parÃ¡metros en el archivo de proyecto, pero no se pueden usar juntos. Elija una u otra.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: No se puede usar un vÃ­nculo para copiar "{0}" en "{1}".</target>
@@ -2175,11 +2180,6 @@
         <target state="translated">El archivo de lista de paquetes redistribuibles "{0}" tiene un nombre Redist NULL o vacÃ­o en el elemento FileList. AsegÃºrese de que el nombre Redist no sea NULL ni estÃ© vacÃ­o.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Actualizando el archivo de cachÃ© de ensamblado "{0}".</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">La referencia COM '{0}' es el ensamblado de interoperabilidad del control ActiveX '{1}' pero estaba marcada para su vinculaciÃ³n por el compilador con la marca /link. Esta referencia COM se tratarÃ¡ como una referencia y no se vincularÃ¡.</target>
@@ -2302,7 +2302,7 @@
       </trans-unit>
       <trans-unit id="ResolveComReference.LoadingDelaySignedAssemblyWithStrongNameVerificationEnabled">
         <source>MSB3295: Failed to load an assembly. Please make sure you have disabled strong name verification for your public key if you want to generate delay signed wrappers. {0}</source>
-        <target state="translated">MSB3295: No se pudo cargar un ensamblado. AsegÃºrese de que deshabilitÃ³ la comprobaciÃ³n de nombres seguros para su clave pÃºblica si desea generar contenedores de firma con retraso. {0}</target>
+        <target state="translated">MSB3295: No se pudo cargar un ensamblado. AsegÃºrese de que deshabilitÃ³ la comprobaciÃ³n de nombres seguros para su clave pÃºblica si desea generar contenedores de firma retardada. {0}</target>
         <note>{StrBegin="MSB3295: "}</note>
       </trans-unit>
       <trans-unit id="ResolveComReference.MissingOrUnknownComReferenceAttribute">
@@ -2511,7 +2511,7 @@
       </trans-unit>
       <trans-unit id="StrongNameUtils.NoPublicKeySpecified">
         <source>MSB3353: Public key necessary for delay signing was not specified.</source>
-        <target state="translated">MSB3353: No se especificÃ³ la clave pÃºblica necesaria para la firma con retraso.</target>
+        <target state="translated">MSB3353: No se especificÃ³ la clave pÃºblica necesaria para la firma retardada.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index d309c31905c..67ace11922c 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: Nous avons copiÃ© {0} Â«{1}Â» vers Â«{2}Â» et les ressources humaines sont {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: Â«Â {0}Â Â» et Â«Â {1}Â Â» ont Ã©tÃ© spÃ©cifiÃ©es comme paramÃ¨tres dans le Fichier projet, mais ne peuvent pas Ãªtre utilisÃ©s ensemble. Choisissez lâune ou lâautre.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: impossible d'utiliser un lien pour copier "{0}" vers "{1}".</target>
@@ -2175,11 +2180,6 @@
         <target state="translated">Le fichier de liste de packages redistribuables "{0}" a un nom Redist vide ou ayant une valeur null dans l'Ã©lÃ©ment FileList. VÃ©rifiez que le nom Redist n'est pas vide ou qu'il n'a pas une valeur null.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Mise Ã  jour du fichier de cache dâassembly Â«{0}Â».</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">La rÃ©fÃ©rence COM '{0}' est l'assembly d'interopÃ©rabilitÃ© pour le contrÃ´le ActiveX '{1}', mais elle a Ã©tÃ© marquÃ©e comme Ã©tant liÃ©e au compilateur avec l'indicateur /link. Cette rÃ©fÃ©rence COM sera traitÃ©e comme une rÃ©fÃ©rence, mais ne sera pas liÃ©e.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 49d2bb9524a..e06c1b4c72a 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="translated">MSB3991: â{0}â non Ã¨ impostato o Ã¨ vuoto. Quando {1} Ã¨ false, assicurarsi di impostare un valore non vuoto per "{0}".</target>
+        <target state="translated">MSB3991: '{0}' non Ã¨ impostato o Ã¨ vuoto. Quando {1} Ã¨ false, assicurarsi di impostare un valore non vuoto per '{0}'.</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="translated">MSB3992: "{0}" non impostato. Quando {1} Ã¨ true, assicurarsi di impostare un valore per "{0}".</target>
+        <target state="translated">MSB3992: '{0}' non Ã¨ impostato. Quando {1} Ã¨ true, assicurarsi di impostare un valore per '{0}'.</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: Ottenuto {0} copiando "{1}" in "{2}" e HR Ã¨ {3}"</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: i parametri "{0}" e "{1}" sono stati specificati come parametri nel file di progetto, ma non possono essere usati insieme. Scegliere uno o l'altro.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: non Ã¨ stato possibile usare un collegamento per copiare "{0}" in "{1}".</target>
@@ -2175,11 +2180,6 @@
         <target state="translated">Il file di elenco di pacchetti ridistribuibili "{0}" include un nome di Redist Null o vuoto nell'elemento FileList. Verificare che il nome di Redist non sia Null o vuoto.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Aggiornamento del file della cache di assembly "{0}".</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">Il riferimento COM '{0}' Ã¨ l'assembly di interoperabilitÃ  per il controllo ActiveX '{1}', tuttavia Ã¨ stato contrassegnato dal compilatore con il flag /link per il collegamento. Il riferimento COM verrÃ  trattato come riferimento e non verrÃ  collegato.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index c9cd6028fc9..9d616e3a9e3 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: "{1}" ã "{2}" ã«ã³ãã¼ä¸­ã« {0}ãçºçãã¾ãããHR ã¯ {3} ã§ã</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: "{0}" ã¨ "{1}" ã®ä¸¡æ¹ããã­ã¸ã§ã¯ã ãã¡ã¤ã«ã®ãã©ã¡ã¼ã¿ã¼ã¨ãã¦æå®ããã¾ããããä¸ç·ã«ä½¿ç¨ãããã¨ã¯ã§ãã¾ãããã©ã¡ããä¸æ¹ãé¸æãã¦ãã ããã</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: ãªã³ã¯ãä½¿ç¨ãã¦ "{0}" ã "{1}" ã«ã³ãã¼ã§ãã¾ããã§ããã</target>
@@ -2175,11 +2180,6 @@
         <target state="translated">åé å¸å¯è½ããã±ã¼ã¸ ãªã¹ã ãã¡ã¤ã« "{0}" ã® FileList è¦ç´ ã« null ã¾ãã¯ç©ºã®åé å¸å¯è½ããã±ã¼ã¸åãããã¾ããåé å¸å¯è½ããã±ã¼ã¸åã null ã¾ãã¯ç©ºã§ãªããã¨ãç¢ºèªãã¦ãã ããã</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">ã¢ã»ã³ããª ã­ã£ãã·ã¥ ãã¡ã¤ã« "{0}" ãæ´æ°ãã¦ãã¾ãã</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM åç§ '{0}' ã¯ ActiveX ã³ã³ãã­ã¼ã« '{1}' ã®ç¸äºéç¨ã¢ã»ã³ããªã§ãããã³ã³ãã¤ã©ã«ãã£ã¦ /link ãã©ã°ã§ãªã³ã¯ãããããã«è¨­å®ããã¦ãã¾ãããã® COM åç§ã¯åç§ã¨ãã¦å¦çããããªã³ã¯ããã¾ããã</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 0ca9222197f..0e852a33b29 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: {0}ì(ë¥¼) â{1}â(ì¼)ë¡ ë³µì¬íë â{2}âì´(ê°) ìê³  HRì {3}ìëë¤.</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: "{0}" ë° "{1}" ëª¨ë íë¡ì í¸ íì¼ìì ë§¤ê° ë³ìë¡ ì§ì ëìì§ë§ í¨ê» ì¬ì©í  ìë ììµëë¤. íë ëë ë¤ë¥¸ í­ëª©ì ì ííì¸ì.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: ë§í¬ë¥¼ ì¬ì©íì¬ "{0}"ì(ë¥¼) "{1}"ì ë³µì¬í  ì ììµëë¤.</target>
@@ -2175,11 +2180,6 @@
         <target state="translated">ì¬ë°°í¬ ê°ë¥ í¨í¤ì§ ëª©ë¡ íì¼ "{0}"ì FileList ììì nullì´ê±°ë ë¹ì´ ìë ì¬ë°°í¬ ê°ë¥ í¨í¤ì§ ì´ë¦ì´ ììµëë¤. ì¬ë°°í¬ ê°ë¥ í¨í¤ì§ ì´ë¦ì´ nullì´ê±°ë ë¹ì´ ìì§ ìëë¡ íì¸ì.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">ì´ìë¸ë¦¬ ìºì íì¼ "{0}"ì(ë¥¼) ìë°ì´í¸íë ì¤ìëë¤.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM ì°¸ì¡° '{0}'ì(ë) ActiveX ì»¨í¸ë¡¤ '{1}'ì ëí interop ì´ìë¸ë¦¬ì´ì§ë§ /link íëê·¸ë¡ ì»´íì¼ë¬ì ìí´ ë§í¬ëëë¡ íìëì´ ììµëë¤. ì´ COM ì°¸ì¡°ë ì°¸ì¡°ë¡ ê°ì£¼ëì§ë§ ë§í¬ëì§ ììµëë¤.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index a21fc7cd781..2202834f7eb 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: âMam {0} kopiowane z â{1}â do â{2}â, a HR to {3}â</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: parametry â{0}â i â{1}â zostaÅy okreÅlone jako parametry w pliku projektu, ale nie mogÄ byÄ uÅ¼ywane razem. Wybierz jeden lub drugi.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Nie moÅ¼na uÅ¼yÄ linku w celu skopiowania ÅcieÅ¼ki â{0}â do ÅcieÅ¼ki â{1}â.</target>
@@ -2175,11 +2180,6 @@
         <target state="translated">Plik z listÄ pakietÃ³w redystrybucyjnych â{0}â ma nazwÄ Redist rÃ³wnÄ null lub pustÄ w elemencie FileList. Upewnij siÄ, Å¼e nazwa Redist nie ma wartoÅci null ani nie jest pusta.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Aktualizowanie pliku pamiÄci podrÄcznej zestawu â{0}â.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">OdwoÅanie COM â{0}â jest zestawem miÄdzyoperacyjnym dla kontrolki ActiveX â{1}â, ale zostaÅo wybrane do poÅÄczenia przez kompilator przy uÅ¼yciu flagi /link. To odwoÅanie COM jest traktowane jako odwoÅanie i nie zostanie poÅÄczone.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 2cbac98a44a..7d1700c57b8 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: Recebi {0} copiando "{1}" para {2} e o RH Ã© {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: "{0}" e "{1}" foram especificados como parÃ¢metros no arquivo de projeto, mas nÃ£o podem ser usados juntos. Escolha um ou outro.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: NÃ£o foi possÃ­vel usar um link para copiar "{0}" para "{1}".</target>
@@ -2175,11 +2180,6 @@
         <target state="translated">O arquivo da lista de pacote redistribuÃ­vel "{0}" tem um nome de Pacote RedistribuÃ­vel nulo ou vazio no elemento FileList. Verifique se o Nome do Pacote RedistribuÃ­vel nÃ£o Ã© nulo nem estÃ¡ vazio.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Atualizando o arquivo de cache do assembly "{0}".</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">A ReferÃªncia COM "{0}" Ã© o assembly de interoperabilidade para o controle ActiveX "{1}", mas foi marcada para ser vinculada pelo compilador com o sinalizador /link. Essa referÃªncia COM serÃ¡ tratada como uma referÃªncia e nÃ£o serÃ¡ vinculada.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 9f27ce3a87d..021f23c3c21 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: ÐÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¾ ÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ {0} "{1}" Ð² "{2}" Ð¸ HR â {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: "{0}" Ð¸ "{1}" Ð±ÑÐ»Ð¸ ÑÐºÐ°Ð·Ð°Ð½Ñ ÐºÐ°Ðº Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÑ Ð² ÑÐ°Ð¹Ð»Ðµ Ð¿ÑÐ¾ÐµÐºÑÐ°, Ð½Ð¾ Ð½Ðµ Ð¼Ð¾Ð³ÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑÑÑ Ð²Ð¼ÐµÑÑÐµ. ÐÑÐ±ÐµÑÐ¸ÑÐµ Ð¾Ð´Ð¸Ð½ Ð¸Ð»Ð¸ Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ Ð²Ð°ÑÐ¸Ð°Ð½ÑÐ¾Ð².</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Ð½Ðµ ÑÐ´Ð°Ð»Ð¾ÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÑÐ²ÑÐ·Ñ Ð´Ð»Ñ ÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ "{0}" Ð² "{1}".</target>
@@ -2175,11 +2180,6 @@
         <target state="translated">Ð ÑÐ°Ð¹Ð»Ðµ ÑÐ¿Ð¸ÑÐºÐ° ÑÐ°ÑÐ¿ÑÐ¾ÑÑÑÐ°Ð½ÑÐµÐ¼ÑÑ Ð¿Ð°ÐºÐµÑÐ¾Ð² "{0}" Ð¸Ð¼Ñ ÑÐ°ÑÐ¿ÑÐ¾ÑÑÑÐ°Ð½ÑÐµÐ¼Ð¾Ð³Ð¾ Ð¿Ð°ÐºÐµÑÐ° Ð² ÑÐ»ÐµÐ¼ÐµÐ½ÑÐµ FileList Ð¸Ð¼ÐµÐµÑ Ð¿ÑÑÑÐ¾Ðµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ Ð¸Ð»Ð¸ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ NULL. Ð£Ð±ÐµÐ´Ð¸ÑÐµÑÑ, ÑÑÐ¾ Ð¸Ð¼Ñ ÑÐ°ÑÐ¿ÑÐ¾ÑÑÑÐ°Ð½ÑÐµÐ¼Ð¾Ð³Ð¾ Ð¿Ð°ÐºÐµÑÐ° (Redist Name) Ð½Ðµ Ð¿ÑÑÑÐ¾ Ð¸ Ð½Ðµ ÑÐ°Ð²Ð½Ð¾ NULL.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">ÐÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ ÑÐ°Ð¹Ð»Ð° ÐºÑÑÐ° ÑÐ±Ð¾ÑÐºÐ¸ "{0}".</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM-ÑÑÑÐ»ÐºÐ° "{0}" ÑÐ²Ð»ÑÐµÑÑÑ ÑÐ±Ð¾ÑÐºÐ¾Ð¹ Ð²Ð·Ð°Ð¸Ð¼Ð¾Ð´ÐµÐ¹ÑÑÐ²Ð¸Ñ Ð´Ð»Ñ ÑÐ»ÐµÐ¼ÐµÐ½ÑÐ° ActiveX "{1}", Ð½Ð¾ Ð±ÑÐ»Ð° Ð¿Ð¾Ð¼ÐµÑÐµÐ½Ð° Ð½Ð° ÐºÐ¾Ð¼Ð¿Ð¾Ð½Ð¾Ð²ÐºÑ ÐºÐ¾Ð¼Ð¿Ð¸Ð»ÑÑÐ¾ÑÐ¾Ð¼ ÑÐ»Ð°Ð³Ð¾Ð¼ /link. Ð­ÑÐ° COM-ÑÑÑÐ»ÐºÐ° Ð±ÑÐ´ÐµÑ ÑÑÐ¸ÑÐ°ÑÑÑÑ ÑÑÑÐ»ÐºÐ¾Ð¹ Ð¸ Ð½Ðµ Ð±ÑÐ´ÐµÑ ÑÐºÐ¾Ð¼Ð¿Ð¾Ð½Ð¾Ð²Ð°Ð½Ð°.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 0b59127f2b0..dbef7d2ebe4 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: {0} iÃ§in {1} yolu {2} yoluna kopyalandÄ± ve HR: {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: "{0}" ve "{1}" proje dosyasÄ±nda parametre olarak belirtilmiÅ ancak birlikte kullanÄ±lamaz. LÃ¼tfen birini veya diÄerini seÃ§in.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: "{0}" dosyasÄ±nÄ± "{1}" yoluna kopyalama baÄlantÄ±sÄ± kullanÄ±lamadÄ±.</target>
@@ -2175,11 +2180,6 @@
         <target state="translated">"{0}" yeniden daÄÄ±tÄ±m liste dosyasÄ±nÄ±n FileList Ã¶Äesindeki Redist adÄ± null veya boÅ. Redist adÄ±nÄ±n null veya boÅ olmadÄ±ÄÄ±ndan emin olun.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Derleme Ã¶nbelleÄi dosyasÄ± "{0}" gÃ¼ncelleÅtiriliyor.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">'{0}' COM BaÅvurusu, '{1}' ActiveX denetiminin birlikte Ã§alÄ±Åma bÃ¼tÃ¼nleÅtirilmiÅ kodu, ancak /link bayraÄÄ±yla derleyici tarafÄ±ndan baÄlanmak Ã¼zere iÅaretlenmiÅ. Bu COM baÅvurusu, baÅvuru olarak deÄerlendirilecek ve baÄlanmayacak.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 8272b18a8a5..bf9b8c54683 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: å° "{1}" å¤å¶å° "{2}" æ¶åºç° {0}ï¼HR ä¸º {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: â{0}âåâ{1}âåè¢«æå®ä¸ºé¡¹ç®æä»¶ä¸­çåæ°ï¼ä½ä¸è½ä¸èµ·ä½¿ç¨ãè¯·éæ©å¶ä¸­ä¸ä¸ªã</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: æ æ³ä½¿ç¨é¾æ¥å°â{0}âå¤å¶å°â{1}âã</target>
@@ -2175,11 +2180,6 @@
         <target state="translated">å¯ååè¡ç¨åºååè¡¨æä»¶â{0}âå¨ FileList åç´ ä¸­å·æ null æç©ºçå¯ååè¡ç¨åºååç§°ãè¯·ç¡®ä¿å¯ååè¡ç¨åºååç§°ä¸ä¸º null æç©ºå¼ã</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">æ­£å¨æ´æ°ç¨åºéç¼å­æä»¶â{0}âã</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM å¼ç¨â{0}âæ¯ ActiveX æ§ä»¶â{1}âçäºæä½ç¨åºéï¼ä½å«æ /link æ å¿çç¼è¯å¨å·²å°å¶æ ä¸ºå·²é¾æ¥ãç³»ç»ä¼å°æ­¤ COM å¼ç¨è§ä¸ºå¼ç¨ï¼å¹¶ä¸ä¸ä¼é¾æ¥è¯¥å¼ç¨ã</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index ef2d07887fa..0a0662e6b05 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: ææ {0} å° "{1}" è¤è£½è³ "{2}"ï¼ä¸ HR çº {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: "{0}" å "{1}" é½æå®çºå°æ¡æªä¸­çåæ¸ï¼ä½ä¸è½ä¸èµ·ä½¿ç¨ãè«é¸æå¶ä¸­ä¸åã</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: ç¡æ³ä½¿ç¨é£çµå° "{0}" è¤è£½å° "{1}"ã</target>
@@ -2175,11 +2180,6 @@
         <target state="translated">å¯è½æ£ç¼å¥ä»¶æ¸å®æª "{0}" å¨ FileList é ç®ä¸­ç Redist åç¨±çº null æç©ºç½ãè«ç¢ºèª Redist åç¨±ä¸çº null æç©ºç½ã</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">æ´æ°çµä»¶å¿«åæªæ¡ "{0}"ã</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM åè '{0}' æ¯ ActiveX æ§å¶é  '{1}' ç Interop çµä»¶ï¼ä½æ¯æ¨è¨çºè¦ç±ç·¨è­¯å¨ä»¥ /link ææ¨é£çµãéå COM åèå°è¢«è¦çºåèï¼ä¸æé²è¡é£çµã</target>
