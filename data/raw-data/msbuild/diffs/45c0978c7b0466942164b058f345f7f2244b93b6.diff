diff --git a/documentation/release-checklist.md b/documentation/release-checklist.md
index 80d9467259d..9d86581f0b5 100644
--- a/documentation/release-checklist.md
+++ b/documentation/release-checklist.md
@@ -53,6 +53,7 @@ _(This is for the case where we create the branch too early and want it to be ba
 - [ ] Get M2 or QB approval as necessary per the VS schedule
 - [ ]  Merge to VS (babysit the automatically generated VS insertion PR https://devdiv.visualstudio.com/DevDiv/_git/VS/pullrequests for the MSBuild commit noted in above step): {{URL_OF_VS_INSERTION}}
 - [ ] Update the PackageValidationBaselineVersion to the latest released version ({{THIS_RELEASE_VERSION}}.0) - this might require temporary addition of the [build artifacts feed](https://github.com/dotnet/msbuild/blob/29397b577e3ec0fe0c7650c3ab0400909655dc88/NuGet.config#L9) as the new version is not yet added to the official feeds (this is post release). This can trigger a high severity CG error (https://eng.ms/docs/cloud-ai-platform/devdiv/one-engineering-system-1es/1es-docs/secure-supply-chain/how-to-securely-configure-package-source-files) - however it should be fine to keep this temporary feed untill the release.
+- [ ] Update the requested SDK version for bootstrap folder (the `BootstrapSdkVersion` property in [Versions.props](https://github.com/dotnet/msbuild/blob/main/eng/Versions.props)) and buildToolCommand/_InitializeBuildToolCommand values in cibuild_bootstrapped_msbuild scripts if a fresh sdk was released (released runtimes and associated sdk versions can be checked here - https://dotnet.microsoft.com/download/visual-studio-sdks - make sure to always check the details of the appropriate targeted version of .NET for the matching latest version of SDK).
 
 ## ASAP On/After GA:
 
diff --git a/documentation/wiki/Bootstrap.md b/documentation/wiki/Bootstrap.md
new file mode 100644
index 00000000000..e33007c0f73
--- /dev/null
+++ b/documentation/wiki/Bootstrap.md
@@ -0,0 +1,22 @@
+# Bootstrap MSBuild
+
+Because the binaries and build logic in this repo aren't sufficient to build real-world projects, we need a test environment that mimics the real-world combinations of MSBuild, Roslyn compilers, and other things that combine in the .NET SDK and in Visual Studio to produce a functional build environment. We call this the "bootstrap".
+
+## Quick Intro
+The document describes the logic behind the bootstrap and testing capabilities for the fresh MSBuild bits.
+
+## History
+MSBuild supports two different environments: .NET and .NET Framework. To test changes for .NET, fresh bits were published (the actual target Publish run) to the MSBuild.Bootstrap folder. These bits, along with specific dependencies, were later combined with parts of the .NET SDK that was used to build MSBuild to the bootstrap, making them ready for use with dotnet.exe. To execute the bootstrap MSBuild, you'd combine the `dotnet.exe` muxer from the .dotnet folder with the path to the bootstrap's `MSBuild.dll`.
+
+## Current Implementation for .NET
+During the bootstrap phase, install-scripts are used to download a full copy of the .NET SDK compatible with the current version. The logic for interacting with the scripts has been encapsulated in a separate MSBuild task: InstallDotNetCoreTask.cs. Hereâ€™s what happens under the hood:
+
+The SDK is downloaded to the bootstrap folder.
+Fresh MSBuild bits are then copied to this folder.
+The constructed SDK is used for both local end-to-end tests and CI runs.
+
+## Potential Cons
+The reliance on downloading the SDK from a remote source requires an internet connection. For the initial build of the repository, this doesn't change as the SDK is always downloaded to the .dotnet folder first. For subsequent runs, the SDK in bootstrap will be downloaded again only **if the requested version was changed**.
+
+## Pros
+This approach simplifies testing MSBuild as part of dotnet by providing a ready and reliable environment without needing to patch anything into a globally installed SDK, as was previously required.
\ No newline at end of file
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 9aff19e9e15..9d90c75075e 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -43,27 +43,6 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Introduce [MSBuild]::StableStringHash overloads](https://github.com/dotnet/msbuild/issues/9519)
 - [Keep the encoding of standard output & error consistent with the console code page for ToolTask](https://github.com/dotnet/msbuild/pull/9539)
 
-### 17.8
-- [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
-- [Delete destination file before copy](https://github.com/dotnet/msbuild/pull/8685)
-- [Moving from SHA1 to SHA256 for Hash task](https://github.com/dotnet/msbuild/pull/8812)
-- [Deprecating custom derived BuildEventArgs](https://github.com/dotnet/msbuild/pull/8917) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
-
-### 17.6
-- [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
-- [Eliminate project string cache](https://github.com/dotnet/msbuild/pull/7965)
-- [Log an error when no provided search path for an import exists](https://github.com/dotnet/msbuild/pull/8095)
-- [Log assembly loads](https://github.com/dotnet/msbuild/pull/8316)
-- [AnyHaveMetadataValue returns false when passed an empty list](https://github.com/dotnet/msbuild/pull/8603)
-- [Log item self-expansion](https://github.com/dotnet/msbuild/pull/8581)
-
-### 17.4
-- [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
-- [Consider `Platform` as default during Platform Negotiation](https://github.com/dotnet/msbuild/pull/7511)
-- [Adding accepted SDK name match pattern to SDK manifests](https://github.com/dotnet/msbuild/pull/7597)
-- [Throw warning indicating invalid project types](https://github.com/dotnet/msbuild/pull/7708)
-- [MSBuild server](https://github.com/dotnet/msbuild/pull/7634)
-
 ## Change Waves No Longer In Rotation
 ### 16.8
 - [Enable NoWarn](https://github.com/dotnet/msbuild/pull/5671)
@@ -89,3 +68,27 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Add Microsoft.IO.Redist for directory enumeration](https://github.com/dotnet/msbuild/pull/6771)
 - [Process-wide caching of ToolsetConfigurationSection](https://github.com/dotnet/msbuild/pull/6832)
 - [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
+
+### 17.4
+
+- [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
+- [Consider `Platform` as default during Platform Negotiation](https://github.com/dotnet/msbuild/pull/7511)
+- [Adding accepted SDK name match pattern to SDK manifests](https://github.com/dotnet/msbuild/pull/7597)
+- [Throw warning indicating invalid project types](https://github.com/dotnet/msbuild/pull/7708)
+- [MSBuild server](https://github.com/dotnet/msbuild/pull/7634)
+
+### 17.6
+
+- [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
+- [Eliminate project string cache](https://github.com/dotnet/msbuild/pull/7965)
+- [Log an error when no provided search path for an import exists](https://github.com/dotnet/msbuild/pull/8095)
+- [Log assembly loads](https://github.com/dotnet/msbuild/pull/8316)
+- [AnyHaveMetadataValue returns false when passed an empty list](https://github.com/dotnet/msbuild/pull/8603)
+- [Log item self-expansion](https://github.com/dotnet/msbuild/pull/8581)
+
+### 17.8
+
+- [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
+- [Delete destination file before copy](https://github.com/dotnet/msbuild/pull/8685)
+- [Moving from SHA1 to SHA256 for Hash task](https://github.com/dotnet/msbuild/pull/8812)
+- [Deprecating custom derived BuildEventArgs](https://github.com/dotnet/msbuild/pull/8917) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
diff --git a/eng/BootStrapMsBuild.props b/eng/BootStrapMsBuild.props
index 858cf76ac54..3dd91450e88 100644
--- a/eng/BootStrapMsBuild.props
+++ b/eng/BootStrapMsBuild.props
@@ -1,20 +1,19 @@
 <Project>
 
-  <!--
-  Construct a location of MSBuild bootstrap folder - to be used for deployment and for tests
-   relying on bootstrapped MSBuild
-   -->
+  <!-- Construct a location of MSBuild bootstrap folder - to be used for deployment and for tests relying on bootstrapped MSBuild -->
 
   <PropertyGroup>
     <BootstrapDestination>$(ArtifactsBinDir)bootstrap\</BootstrapDestination>
     <BootstrapDestination Condition="'$(Platform)' == 'x64' or '$(Platform)' == 'arm64'">$(BootstrapDestination)$(Platform)\</BootstrapDestination>
+
+    <!-- This path is used for Windows Full test run and it points to net472 during execution-->
     <BootstrapDestination>$(BootstrapDestination)$(TargetFramework.ToLowerInvariant())\MSBuild\</BootstrapDestination>
   </PropertyGroup>
-  
+
   <PropertyGroup Condition="$(TargetFramework.StartsWith('net4'))">
     <BootstrapBinaryDestination>$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin</BootstrapBinaryDestination>
   </PropertyGroup>
-  
+
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
     <BootstrapBinaryDestination>$(BootstrapDestination)</BootstrapBinaryDestination>
   </PropertyGroup>
diff --git a/eng/BootStrapMsBuild.targets b/eng/BootStrapMsBuild.targets
index 9209876eecf..dcff8617638 100644
--- a/eng/BootStrapMsBuild.targets
+++ b/eng/BootStrapMsBuild.targets
@@ -202,56 +202,40 @@
            AlwaysCreate="true" />
   </Target>
 
-  <Target Name="BootstrapNetCore" DependsOnTargets="CleanBootstrapFolder">
+  <!-- The task allow to download sdk bits for the specified version. It will be used later to bootstrap the runnable MSBuild. -->
+  <UsingTask TaskName="InstallDotNetCoreTask"
+             AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"
+             TaskFactory="RoslynCodeTaskFactory">
+    <Task>
+      <Code Source="$(MSBuildThisFileDirectory)..\src\MSBuild.Bootstrap.Utils\Tasks\InstallDotNetCoreTask.cs" Language="cs" />
+    </Task>
+  </UsingTask>
+  <Target Name="AcquireSdk"
+          BeforeTargets="PrepareForBuild"
+          Condition="!$(TargetFramework.StartsWith('net4'))">
+
+    <PropertyGroup>
+      <InstallDir>$(ArtifactsBinDir)bootstrap\core\</InstallDir>
+    </PropertyGroup>
+
+    <InstallDotNetCoreTask DotNetInstallScriptRootPath="$(DotNetRoot)" InstallDir="$(InstallDir)" Version="$(BootstrapSdkVersion)"/>
+  </Target>
 
-    <!-- Publish the project first.  The more obvious way to do this would be to depend on the Publish target,
-         but that causes a target dependency cycle, even though it seems like AfterTargets="AfterBuild" should
-         probably not count as a link in the cycle. -->
-    <MSBuild Projects="$(MSBuildProjectFile)" Targets="Publish" BuildInParallel="$(BuildInParallel)" />
+  <Target Name="BootstrapNetCore" DependsOnTargets="AcquireSdk">
 
     <ItemGroup>
-      <!-- Copy all items from the publish folder to the bootstrap folder.  We might be able to just use the published
-            version as the bootstrapped version, but the extra separation here seems like it could be valuable. -->
-      <DeployedItems Include="$(PublishDir)\**\*.*" />
-
-      <NuGetSdkResolverManifest Include= "$(RepoRoot)src\MSBuild\SdkResolvers\Standalone\Microsoft.Build.NuGetSdkResolver.xml" />
-      <InstalledSdks Include="$(DOTNET_INSTALL_DIR)\sdk\$(DotNetCliVersion)\Sdks\**\*.*" />
-      <InstalledExtensions Include="$(DOTNET_INSTALL_DIR)\sdk\$(DotNetCliVersion)\Current\**\*.*" Exclude="$(DOTNET_INSTALL_DIR)\sdk\$(DotNetCliVersion)\Current\Microsoft.Common.props" />
+     <!-- *.deps.json are excluded because the SDK rewrites these files for consistency with the rest of the SDK, so take their version. -->
+      <FreshlyBuiltNetBinaries Include="$(OutDir)**\*.*" Exclude="$(OutDir)**\*.deps.json" />
     </ItemGroup>
-    <Copy SourceFiles="@(DeployedItems)"
-          DestinationFolder="$(BootstrapDestination)%(RecursiveDir)" />
-
-    <Copy SourceFiles="@(NuGetSdkResolverManifest)"
-          DestinationFolder="$(BootstrapDestination)SdkResolvers\Microsoft.Build.NuGetSdkResolver" />
-
-    <Copy SourceFiles="$(RuntimeIdentifierGraphPath)"
-          DestinationFolder="$(BootstrapDestination)" />
-
-    <Copy SourceFiles="@(InstalledSdks)"
-          DestinationFiles="@(InstalledSdks -> '$(BootstrapDestination)Sdks\%(RecursiveDir)%(Filename)%(Extension)')" />
-
-    <!-- The .NET SDK has a dependency on DependencyModel, but relies on having it in the final
-         MSBuild.deps.json, which differs from ours because it's generated in the SDK repo.
-
-         Copy it from "next to MSBuild" in the pre-bootstrap SDK to our little weirdo bootstrap
-         layout next to the SDK tasks, so it can get loaded by the SDK tasks that need it. -->
-    <Copy SourceFiles="$(DOTNET_INSTALL_DIR)\sdk\$(DotNetCliVersion)\Microsoft.Extensions.DependencyModel.dll"
-          DestinationFolder="$(BootstrapDestination)Sdks\Microsoft.NET.Sdk\tools\$(LatestDotNetCoreForMSBuild)" />
-
-    <Copy SourceFiles="@(InstalledExtensions)"
-          DestinationFolder="$(BootstrapDestination)Current\%(RecursiveDir)" />
 
+    <!-- The copying of these dependencies is required by bootstrap\**\sdk\**\NuGet.RestoreEx.targets. Otherwise NuGet.Build.Tasks.dll can not be found. -->
     <Copy SourceFiles="@(_NuGetRuntimeDependencies)"
-          DestinationFolder="$(BootstrapDestination)" />
-
-    <Copy SourceFiles="$(RepoRoot)src\MSBuild.Bootstrap\RedirectNuGetConsoleProcess.After.Microsoft.Common.targets"
-          DestinationFolder="$(BootstrapDestination)\Current\Microsoft.Common.targets\ImportAfter" />
+          DestinationFolder="$(InstallDir)sdk\$(BootstrapSdkVersion)\"
+          SkipUnchangedFiles="true" />
 
-    <Copy SourceFiles="$(RepoRoot)src\MSBuild.Bootstrap\RedirectNuGetConsoleProcess.After.Microsoft.Common.targets"
-          DestinationFolder="$(BootstrapDestination)\Current\SolutionFile\ImportAfter" />
+    <Copy SourceFiles="@(FreshlyBuiltNetBinaries)"
+          DestinationFiles="@(FreshlyBuiltNetBinaries->'$(InstallDir)sdk\$(BootstrapSdkVersion)\%(RecursiveDir)%(Filename)%(Extension)')" />
 
-    <!-- Disable workload resolver until we can figure out whether it can work in the bootstrap
-         https://github.com/dotnet/msbuild/issues/6566 -->
-    <Touch Files="$(BootstrapDestination)\DisableWorkloadResolver.sentinel" AlwaysCreate="true" />
   </Target>
+
 </Project>
diff --git a/eng/Versions.props b/eng/Versions.props
index 4b06a08a38d..28671ba9b35 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -56,6 +56,11 @@
     <NuGetBuildTasksVersion>6.11.0-rc.122</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
+
+  <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
+    <BootstrapSdkVersion>8.0.302</BootstrapSdkVersion>
+  </PropertyGroup>
+
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
 
diff --git a/eng/cibuild_bootstrapped_msbuild.ps1 b/eng/cibuild_bootstrapped_msbuild.ps1
index b6e3c089135..ff9673037d8 100644
--- a/eng/cibuild_bootstrapped_msbuild.ps1
+++ b/eng/cibuild_bootstrapped_msbuild.ps1
@@ -84,8 +84,9 @@ try {
   }
   else
   {
-    $buildToolPath = $dotnetExePath
-    $buildToolCommand = Join-Path $bootstrapRoot "net8.0\MSBuild\MSBuild.dll"
+    $buildToolPath = Join-Path $bootstrapRoot "core\dotnet.exe"
+    # The version must be consistent with BootstrapSdkVersion
+    $buildToolCommand = Join-Path $bootstrapRoot "core\sdk\8.0.302\MSBuild.dll"
     $buildToolFramework = "net8.0"
   }
 
diff --git a/eng/cibuild_bootstrapped_msbuild.sh b/eng/cibuild_bootstrapped_msbuild.sh
index 8edd377ec73..019829d55b9 100755
--- a/eng/cibuild_bootstrapped_msbuild.sh
+++ b/eng/cibuild_bootstrapped_msbuild.sh
@@ -58,8 +58,9 @@ bootstrapRoot="$Stage1Dir/bin/bootstrap"
 
 if [ $host_type = "core" ]
 then
-  _InitializeBuildTool="$_InitializeDotNetCli/dotnet"
-  _InitializeBuildToolCommand="$bootstrapRoot/net8.0/MSBuild/MSBuild.dll"
+  _InitializeBuildTool="$bootstrapRoot/core/dotnet"
+  # The version must be consistent with BootstrapSdkVersion
+  _InitializeBuildToolCommand="$bootstrapRoot/core/sdk/8.0.302/MSBuild.dll"
   _InitializeBuildToolFramework="net8.0"
 else
   echo "Unsupported hostType ($host_type)"
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index 6522e66bbef..271bbd11e8e 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -1850,35 +1850,6 @@ public void ReloadCanOverwriteUnsavedChanges()
             AssertReload(SimpleProject, ComplexProject, true, true, true, act);
         }
 
-        [Fact]
-        public void ReloadDoesNotLeakCachedXmlDocuments()
-        {
-            using var env = TestEnvironment.Create();
-            ChangeWaves.ResetStateForTests();
-            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-            var testFiles = env.CreateTestProjectWithFiles("", new[] { "build.proj" });
-            var projectFile = testFiles.CreatedFiles.First();
-
-            var projectElement = ObjectModelHelpers.CreateInMemoryProjectRootElement(SimpleProject);
-            projectElement.Save(projectFile);
-
-            int originalDocumentCount = GetNumberOfDocumentsInProjectStringCache(projectElement);
-
-            // Test successful reload.
-            projectElement.Reload(false);
-            GetNumberOfDocumentsInProjectStringCache(projectElement).ShouldBe(originalDocumentCount);
-
-            // Test failed reload.
-            using (StreamWriter sw = new StreamWriter(projectFile))
-            {
-                sw.WriteLine("<XXX />"); // Invalid root element
-            }
-            Should.Throw<InvalidProjectFileException>(() => projectElement.Reload(false));
-            GetNumberOfDocumentsInProjectStringCache(projectElement).ShouldBe(originalDocumentCount);
-        }
-
         private void AssertReload(
             string initialContents,
             string changedContents,
@@ -2015,17 +1986,5 @@ private void VerifyAssertLineByLine(string expected, string actual)
         {
             Helpers.VerifyAssertLineByLine(expected, actual, false);
         }
-
-        /// <summary>
-        /// Returns the number of documents retained by the project string cache.
-        /// Peeks at it via reflection since internals are not visible to these tests.
-        /// </summary>
-        private int GetNumberOfDocumentsInProjectStringCache(ProjectRootElement project)
-        {
-            var bindingFlags = BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.GetProperty;
-            object document = typeof(ProjectRootElement).InvokeMember("XmlDocument", bindingFlags, null, project, Array.Empty<object>());
-            object cache = document.GetType().InvokeMember("StringCache", bindingFlags, null, document, Array.Empty<object>());
-            return (int)cache.GetType().InvokeMember("DocumentCount", bindingFlags, null, cache, Array.Empty<object>());
-        }
     }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
index cdbf64f9774..2cb88649b35 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
@@ -340,19 +340,12 @@ public void SetReturns()
         /// <summary>
         /// Parse invalid property under target
         /// </summary>
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void ReadInvalidPropertyUnderTarget(bool enableNewBehavior)
+        [Fact]
+        public void ReadInvalidPropertyUnderTarget()
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
                 ChangeWaves.ResetStateForTests();
-                if (!enableNewBehavior)
-                {
-                    env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-                }
 
                 string projectFile = @"
                     <Project>
@@ -369,14 +362,7 @@ public void ReadInvalidPropertyUnderTarget(bool enableNewBehavior)
 
                 error.ErrorCode.ShouldMatch("MSB4067");
                 var expectedString = "<PropertyGroup>";
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
-                {
-                    error.Message.ShouldMatch(expectedString);
-                }
-                else
-                {
-                    error.Message.ShouldNotMatch(expectedString);
-                }
+                error.Message.ShouldMatch(expectedString);
             }
         }
 
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index f5887f5a46b..62e842a2558 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -150,29 +150,6 @@ public void AssertFirstResolverCanResolve()
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
         }
 
-        [Fact]
-        // Scenario: MockSdkResolver1 has higher priority than MockSdkResolverWithResolvableSdkPattern1 and resolves sdk.
-        public void AssertFirstResolverWithPatternCantResolveChangeWave17_4()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_4.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));
-
-                SdkReference sdk = new SdkReference("1sdkName", "referencedVersion", "minimumVersion");
-
-                var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
-
-                result.Path.ShouldBe("resolverpath1");
-                _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
-                _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
-                ChangeWaves.ResetStateForTests();
-            }
-        }
-
         [Fact]
         // Scenario: MockSdkResolver1 has higher priority than MockSdkResolverWithResolvableSdkPattern1 but MockSdkResolverWithResolvableSdkPattern1 resolves sdk,
         // becuase MockSdkResolver1 is general and MockSdkResolverWithResolvableSdkPattern1 is specific.
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 5c82a444f39..ebb24ca82e6 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -61,31 +61,11 @@ public void TaskNodesDieAfterBuild()
             }
         }
 
-        [DotNetOnlyTheory]
-        [InlineData(false)]
-        // [InlineData(true)] <-- explicitly opting out on core will lead to node crash
-        public void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost_NetCore(
-            bool testLegacyImplementation)
-            => VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(testLegacyImplementation);
-
-        [WindowsFullFrameworkOnlyTheory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost_Framework(
-            bool testLegacyImplementation)
-            => VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(testLegacyImplementation);
-
-        private void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(bool testLegacyImplementation)
+        [Fact]
+        private void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost()
         {
             using TestEnvironment env = TestEnvironment.Create(_output);
 
-            ChangeWaves.ResetStateForTests();
-            if (testLegacyImplementation)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
-
             string boolParam = "True";
             string boolArrayParam = "False;True;False";
             string byteParam = "42";
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index f137cf89960..b29a857dc69 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -40,8 +40,6 @@ public class Expander_Tests
         private string _dateToParse = new DateTime(2010, 12, 25).ToString(CultureInfo.CurrentCulture);
         private static readonly string s_rootPathPrefix = NativeMethodsShared.IsWindows ? "C:\\" : Path.VolumeSeparatorChar.ToString();
 
-        private static bool IsIntrinsicFunctionOverloadsEnabled => ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8);
-
         [Fact]
         public void ExpandAllIntoTaskItems0()
         {
@@ -4577,7 +4575,7 @@ public void PropertyFunctionMSBuildAddRealLiteral()
         public void PropertyFunctionMSBuildAddIntegerOverflow()
         {
             // Overflow wrapping - result exceeds size of long
-            string expected = IsIntrinsicFunctionOverloadsEnabled ? "-9223372036854775808" : (long.MaxValue + 1.0).ToString();
+            string expected = "-9223372036854775808";
             TestPropertyFunction("$([MSBuild]::Add($(X), 1))", "X", long.MaxValue.ToString(), expected);
         }
 
@@ -4612,7 +4610,7 @@ public void PropertyFunctionMSBuildSubtractRealLiteral()
         public void PropertyFunctionMSBuildSubtractIntegerMaxValue()
         {
             // If the double overload is used, there will be a rounding error.
-            string expected = IsIntrinsicFunctionOverloadsEnabled ? "1" : "0";
+            string expected = "1";
             TestPropertyFunction("$([MSBuild]::Subtract($(X), 9223372036854775806))", "X", long.MaxValue.ToString(), expected);
         }
 
@@ -4632,7 +4630,7 @@ public void PropertyFunctionMSBuildMultiplyRealLiteral()
         public void PropertyFunctionMSBuildMultiplyIntegerOverflow()
         {
             // Overflow - result exceeds size of long
-            string expected = IsIntrinsicFunctionOverloadsEnabled ? "-2" : (long.MaxValue * 2.0).ToString();
+            string expected = "-2";
             TestPropertyFunction("$([MSBuild]::Multiply($(X), 2))", "X", long.MaxValue.ToString(), expected);
         }
 
@@ -4645,7 +4643,7 @@ public void PropertyFunctionMSBuildMultiplyComplex()
         [Fact]
         public void PropertyFunctionMSBuildDivideIntegerLiteral()
         {
-            string expected = IsIntrinsicFunctionOverloadsEnabled ? "6" : "6.5536";
+            string expected = "6";
             TestPropertyFunction("$([MSBuild]::Divide($(X), 10000))", "X", "65536", expected);
         }
 
diff --git a/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs b/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
index 9ca64ef3923..099e1404c2c 100644
--- a/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
@@ -18,12 +18,8 @@ namespace Microsoft.Build.Engine.UnitTests.Evaluation
 {
     public class IntrinsicFunctionOverload_Tests
     {
-        private Version ChangeWaveForOverloading = ChangeWaves.Wave17_8;
-
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void MSBuildAddInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        [Fact]
+        public void MSBuildAddInteger()
         {
             const string projectContent = @"
                     <Project>
@@ -32,16 +28,11 @@ public void MSBuildAddInteger(bool isIntrinsicFunctionOverloadsEnabled)
                         </PropertyGroup>
                     </Project>";
 
-            string expected = isIntrinsicFunctionOverloadsEnabled ? unchecked(long.MaxValue + 1).ToString() : (long.MaxValue + 1.0).ToString();
+            string expected = unchecked(long.MaxValue + 1).ToString();
 
             using TestEnvironment env = TestEnvironment.Create();
 
             ChangeWaves.ResetStateForTests();
-            if (!isIntrinsicFunctionOverloadsEnabled)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
 
             using ProjectFromString projectFromString = new(projectContent.Cleanup());
             Project project = projectFromString.Project;
@@ -115,10 +106,8 @@ public void MSBuildAddReal()
             actualProperty.EvaluatedValue.ShouldBe(expected);
         }
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void MSBuildSubtractInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        [Fact]
+        public void MSBuildSubtractInteger()
         {
             const string projectContent = @"
                     <Project>
@@ -127,17 +116,10 @@ public void MSBuildSubtractInteger(bool isIntrinsicFunctionOverloadsEnabled)
                         </PropertyGroup>
                     </Project>";
 
-            string expected = isIntrinsicFunctionOverloadsEnabled ? 1.ToString() : 0.ToString();
+            string expected = 1.ToString();
 
             using TestEnvironment env = TestEnvironment.Create();
 
-            ChangeWaves.ResetStateForTests();
-            if (!isIntrinsicFunctionOverloadsEnabled)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
-
             using ProjectFromString projectFromString = new(projectContent.Cleanup());
             Project project = projectFromString.Project;
             ProjectProperty? actualProperty = project.GetProperty("Actual");
@@ -210,10 +192,8 @@ public void MSBuildSubtractReal()
             actualProperty.EvaluatedValue.ShouldBe(expected);
         }
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void MSBuildMultiplyInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        [Fact]
+        public void MSBuildMultiplyInteger()
         {
             const string projectContent = @"
                     <Project>
@@ -222,17 +202,10 @@ public void MSBuildMultiplyInteger(bool isIntrinsicFunctionOverloadsEnabled)
                         </PropertyGroup>
                     </Project>";
 
-            string expected = isIntrinsicFunctionOverloadsEnabled ? unchecked(long.MaxValue * 2).ToString() : (long.MaxValue * 2.0).ToString();
+            string expected = unchecked(long.MaxValue * 2).ToString();
 
             using TestEnvironment env = TestEnvironment.Create();
 
-            ChangeWaves.ResetStateForTests();
-            if (!isIntrinsicFunctionOverloadsEnabled)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
-
             using ProjectFromString projectFromString = new(projectContent.Cleanup());
             Project project = projectFromString.Project;
             ProjectProperty? actualProperty = project.GetProperty("Actual");
@@ -305,10 +278,8 @@ public void MSBuildMultiplyReal()
             actualProperty.EvaluatedValue.ShouldBe(expected);
         }
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void MSBuildDivideInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        [Fact]
+        public void MSBuildDivideInteger()
         {
             const string projectContent = @"
                     <Project>
@@ -317,17 +288,10 @@ public void MSBuildDivideInteger(bool isIntrinsicFunctionOverloadsEnabled)
                         </PropertyGroup>
                     </Project>";
 
-            string expected = isIntrinsicFunctionOverloadsEnabled ? (10 / 3).ToString() : (10.0 / 3.0).ToString();
+            string expected = (10 / 3).ToString();
 
             using TestEnvironment env = TestEnvironment.Create();
 
-            ChangeWaves.ResetStateForTests();
-            if (!isIntrinsicFunctionOverloadsEnabled)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
-
             using ProjectFromString projectFromString = new(projectContent.Cleanup());
             Project project = projectFromString.Project;
             ProjectProperty? actualProperty = project.GetProperty("Actual");
@@ -400,10 +364,8 @@ public void MSBuildDivideReal()
             actualProperty.EvaluatedValue.ShouldBe(expected);
         }
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void MSBuildModuloInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        [Fact]
+        public void MSBuildModuloInteger()
         {
             const string projectContent = @"
                     <Project>
@@ -416,13 +378,6 @@ public void MSBuildModuloInteger(bool isIntrinsicFunctionOverloadsEnabled)
 
             using TestEnvironment env = TestEnvironment.Create();
 
-            ChangeWaves.ResetStateForTests();
-            if (!isIntrinsicFunctionOverloadsEnabled)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
-
             using ProjectFromString projectFromString = new(projectContent.Cleanup());
             Project project = projectFromString.Project;
             ProjectProperty? actualProperty = project.GetProperty("Actual");
diff --git a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
deleted file mode 100644
index 923fe822ce4..00000000000
--- a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
+++ /dev/null
@@ -1,501 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.IO;
-using System.Text;
-using System.Xml;
-using Microsoft.Build.Construction;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Xunit;
-
-#nullable disable
-
-namespace Microsoft.Build.UnitTests.OM.Evaluation
-{
-    /// <summary>
-    /// Tests for ProjectStringCache
-    /// </summary>
-    public class ProjectStringCache_Tests
-    {
-        /// <summary>
-        /// Test that loading two instances of the same xml file uses the same strings
-        /// to store read values.
-        /// </summary>
-        [Fact]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
-        public void ContentIsSameAcrossInstances()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                string content = ObjectModelHelpers.CleanupFileContents(@"
-                    <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
-                        <ItemGroup>
-                           Item group content
-                        </ItemGroup>
-                    </Project>
-                    ");
-
-                string path = FileUtilities.GetTemporaryFileName();
-
-                try
-                {
-                    File.WriteAllText(path, content);
-
-                    ProjectStringCache cache = new ProjectStringCache();
-                    XmlDocumentWithLocation document1 = new XmlDocumentWithLocation();
-                    document1.StringCache = cache;
-                    document1.Load(path);
-
-                    XmlDocumentWithLocation document2 = new XmlDocumentWithLocation();
-                    document2.StringCache = cache;
-                    document2.Load(path);
-
-                    XmlNodeList nodes1 = document1.GetElementsByTagName("ItemGroup");
-                    XmlNodeList nodes2 = document2.GetElementsByTagName("ItemGroup");
-
-                    Assert.Equal(1, nodes1.Count);
-                    Assert.Equal(1, nodes2.Count);
-
-                    XmlNode node1 = nodes1[0].FirstChild;
-                    XmlNode node2 = nodes2[0].FirstChild;
-
-                    Assert.NotNull(node1);
-                    Assert.NotNull(node2);
-                    Assert.NotSame(node1, node2);
-                    Assert.Same(node1.Value, node2.Value);
-                }
-                finally
-                {
-                    File.Delete(path);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Test that modifying one instance of a file does not affect the other file.
-        /// </summary>
-        [Fact]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
-        public void ContentCanBeModified()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                string content = ObjectModelHelpers.CleanupFileContents(@"
-                    <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
-                        <ItemGroup attr1='attr1value'>
-                           Item group content
-                        </ItemGroup>
-                    </Project>
-                    ");
-
-                string path = FileUtilities.GetTemporaryFileName();
-
-                try
-                {
-                    File.WriteAllText(path, content);
-                    ProjectStringCache cache = new ProjectStringCache();
-                    XmlDocumentWithLocation document1 = new XmlDocumentWithLocation();
-                    document1.StringCache = cache;
-                    document1.Load(path);
-
-                    XmlDocumentWithLocation document2 = new XmlDocumentWithLocation();
-                    document2.StringCache = cache;
-                    document2.Load(path);
-
-                    string outerXml1 = document1.OuterXml;
-                    string outerXml2 = document2.OuterXml;
-                    Assert.Equal(outerXml1, outerXml2);
-
-                    XmlNodeList nodes1 = document1.GetElementsByTagName("ItemGroup");
-                    XmlNodeList nodes2 = document2.GetElementsByTagName("ItemGroup");
-
-                    Assert.Equal(1, nodes1.Count);
-                    Assert.Equal(1, nodes2.Count);
-
-                    XmlNode node1 = nodes1[0];
-                    XmlNode node2 = nodes2[0];
-                    Assert.NotNull(node1);
-                    Assert.NotNull(node2);
-                    Assert.NotSame(node1, node2);
-                    Assert.Single(node1.Attributes);
-                    Assert.Single(node2.Attributes);
-                    Assert.Same(node1.Attributes[0].Value, node2.Attributes[0].Value);
-
-                    node2.Attributes[0].Value = "attr1value";
-                    Assert.Equal(node1.Attributes[0].Value, node2.Attributes[0].Value);
-                    Assert.NotSame(node1.Attributes[0].Value, node2.Attributes[0].Value);
-
-                    node1 = nodes1[0].FirstChild;
-                    node2 = nodes2[0].FirstChild;
-                    Assert.NotSame(node1, node2);
-                    Assert.Same(node1.Value, node2.Value);
-
-                    XmlText newText = document2.CreateTextNode("New Value");
-                    XmlNode parent = node2.ParentNode;
-                    parent.ReplaceChild(newText, node2);
-
-                    Assert.NotEqual(outerXml1, document2.OuterXml);
-                }
-                finally
-                {
-                    File.Delete(path);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Test that unloading a project file makes its string entries disappear from
-        /// the string cache.
-        /// </summary>
-        [Fact]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
-        public void RemovingFilesRemovesEntries()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                string content = ObjectModelHelpers.CleanupFileContents(@"
-                    <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
-                        <ItemGroup>Content</ItemGroup>
-                    </Project>
-                    ");
-
-                string path = FileUtilities.GetTemporaryFileName();
-
-                try
-                {
-                    File.WriteAllText(path, content);
-
-                    ProjectStringCache cache = new ProjectStringCache();
-                    using ProjectCollection collection = new ProjectCollection();
-                    int entryCount;
-
-                    ProjectRootElement pre1 = ProjectRootElement.Create(collection);
-                    pre1.XmlDocument.StringCache = cache;
-                    pre1.FullPath = path;
-                    pre1.XmlDocument.Load(path);
-
-                    entryCount = cache.Count;
-                    Assert.True(entryCount > 0);
-
-                    ProjectRootElement pre2 = ProjectRootElement.Create(collection);
-                    pre2.XmlDocument.StringCache = cache;
-                    pre2.FullPath = path;
-                    pre2.XmlDocument.Load(path);
-
-                    // Entry count should not have changed
-                    Assert.Equal(entryCount, cache.Count);
-
-                    string itemGroupContent = cache.Get("Content");
-                    Assert.NotNull(itemGroupContent);
-
-                    XmlNodeList nodes1 = pre1.XmlDocument.GetElementsByTagName("ItemGroup");
-                    XmlNodeList nodes2 = pre2.XmlDocument.GetElementsByTagName("ItemGroup");
-
-                    Assert.Equal(1, nodes1.Count);
-                    Assert.Equal(1, nodes2.Count);
-
-                    XmlNode node1 = nodes1[0];
-                    XmlNode node2 = nodes2[0];
-                    Assert.NotNull(node1);
-                    Assert.NotNull(node2);
-                    Assert.NotSame(node1, node2);
-                    Assert.Same(node1.Value, node2.Value);
-
-                    // Now remove one document
-                    collection.UnloadProject(pre1);
-
-                    // We should still be able to get Content
-                    itemGroupContent = cache.Get("Content");
-                    Assert.NotNull(itemGroupContent);
-
-                    // Now remove the second document
-                    collection.UnloadProject(pre2);
-
-                    // Now we should not be able to get Content
-                    itemGroupContent = cache.Get("Content");
-                    Assert.Null(itemGroupContent);
-
-                    // And there should be no entries
-                    Assert.Equal(0, cache.Count);
-                }
-                finally
-                {
-                    File.Delete(path);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Adding a string equivalent to an existing instance and under the same document should
-        /// return the existing instance.
-        /// </summary>
-        [Fact]
-        public void AddReturnsSameInstanceForSameDocument()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                string return1 = cache.Add(stringToAdd, document);
-
-                // Content of string should be the same.
-                Assert.Equal(1, cache.Count);
-                Assert.Equal(stringToAdd, return1);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('1');
-
-                string return2 = cache.Add(builder.ToString(), document);
-
-                // Content of string should be the same.
-                Assert.Equal(builder.ToString(), return2);
-
-                // Returned references should be the same
-                Assert.Same(return1, return2);
-
-                // Should not have added any new string instances to the cache.
-                Assert.Equal(1, cache.Count);
-            }
-        }
-
-        /// <summary>
-        /// Adding a string equivalent to an existing instance but under a different document
-        /// should return the existing instance.
-        /// </summary>
-        [Fact]
-        public void AddReturnsSameInstanceForDifferentDocument()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                string return1 = cache.Add(stringToAdd, document);
-
-                // Content of string should be the same.
-                Assert.Equal(stringToAdd, return1);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('1');
-                XmlDocument document2 = new XmlDocument();
-
-                string return2 = cache.Add(builder.ToString(), document2);
-
-                // Content of string should be the same.
-                Assert.Equal(builder.ToString(), return2);
-
-                // Returned references should be the same
-                Assert.Same(return1, return2);
-
-                // Should not have added any new string instances to the cache.
-                Assert.Equal(1, cache.Count);
-            }
-        }
-
-        /// <summary>
-        /// Removing the last document containing an instance of a string should remove the string entry.
-        /// A subsequent add should then return a different instance.
-        /// </summary>
-        /// <remarks>
-        /// WHITEBOX ASSUMPTION:
-        /// The following method assumes knowledge of the ProjectStringCache internal implementation
-        /// details, and may become invalid if those details change.
-        /// </remarks>
-        [Fact]
-        public void RemoveLastInstanceDeallocatesEntry()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                string return1 = cache.Add(stringToAdd, document);
-
-                cache.Clear(document);
-
-                // Should be no instances left.
-                Assert.Equal(0, cache.Count);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('1');
-                XmlDocument document2 = new XmlDocument();
-
-                string return2 = cache.Add(builder.ToString(), document2);
-
-                // Returned references should NOT be the same
-                Assert.NotSame(return1, return2);
-            }
-        }
-
-        /// <summary>
-        /// Removing one document containing a string which already existed in the collection
-        /// should still leave a reference in the collection, so that a subsequent add will
-        /// return the existing reference.
-        /// </summary>
-        [Fact]
-        public void RemoveOneInstance()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                string return1 = cache.Add(stringToAdd, document);
-                Assert.Equal(1, cache.Count);
-
-                XmlDocument document2 = new XmlDocument();
-                cache.Add(stringToAdd, document2);
-                Assert.Equal(1, cache.Count);
-
-                cache.Clear(document2);
-
-                // Since there is still one document referencing the string, it should remain.
-                Assert.Equal(1, cache.Count);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('1');
-                XmlDocument document3 = new XmlDocument();
-
-                string return3 = cache.Add(builder.ToString(), document3);
-
-                // Returned references should be the same
-                Assert.Same(return1, return3);
-
-                // Still should only be one cached instance.
-                Assert.Equal(1, cache.Count);
-            }
-        }
-
-        /// <summary>
-        /// Different strings should get their own entries.
-        /// </summary>
-        [Fact]
-        public void DifferentStringsSameDocument()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                cache.Add(stringToAdd, document);
-                Assert.Equal(1, cache.Count);
-
-                stringToAdd = "Test2";
-                string return2 = cache.Add(stringToAdd, document);
-
-                // The second string gets its own instance.
-                Assert.Equal(2, cache.Count);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('2');
-                string return3 = cache.Add(builder.ToString(), document);
-
-                // The new string should be the same as the other one already in the collection.
-                Assert.Same(return2, return3);
-
-                // No new instances for string with the same content.
-                Assert.Equal(2, cache.Count);
-            }
-        }
-
-        /// <summary>
-        /// Different strings should get their own entries.
-        /// </summary>
-        [Fact]
-        public void DifferentStringsDifferentDocuments()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                cache.Add(stringToAdd, document);
-                Assert.Equal(1, cache.Count);
-
-                stringToAdd = "Test2";
-                XmlDocument document2 = new XmlDocument();
-                string return2 = cache.Add(stringToAdd, document2);
-
-                // The second string gets its own instance.
-                Assert.Equal(2, cache.Count);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('2');
-                XmlDocument document3 = new XmlDocument();
-                string return3 = cache.Add(builder.ToString(), document3);
-
-                // The new string should be the same as the other one already in the collection.
-                Assert.Same(return2, return3);
-
-                // No new instances for string with the same content.
-                Assert.Equal(2, cache.Count);
-            }
-        }
-    }
-}
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index d00b7d90a1d..a3d5e1d18c7 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -968,7 +968,6 @@ public void PacketReceived(int node, INodePacket packet)
         private void WarnOnDeprecatedCustomArgsSerialization(LogMessagePacket loggingPacket)
         {
             if (loggingPacket.EventType == LoggingEventType.CustomEvent
-                && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8)
                 && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
             {
                 BuildEventArgs buildEvent = loggingPacket.NodeBuildEvent.Value.Value;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
index 8835f4278ca..5fd70efcc79 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
@@ -66,7 +66,7 @@ public static IDisposable StartTracking(
 #if FEATURE_APPDOMAIN
         public static void StopTracking(AppDomain appDomain)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && !appDomain.IsDefaultAppDomain())
+            if (!appDomain.IsDefaultAppDomain())
             {
                 lock (s_instances)
                 {
@@ -106,20 +106,15 @@ private static IDisposable StartTracking(
             string? initiatorName,
             AppDomain? appDomain)
         {
-            if (
-                // Feature is not enabled
-                !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) ||
+            if (// We do not want to load all assembly loads (including those triggered by builtin types)
+                !Traits.Instance.LogAllAssemblyLoads &&
                 (
-                    // We do not want to load all assembly loads (including those triggered by builtin types)
-                    !Traits.Instance.LogAllAssemblyLoads &&
-                    (
-                        // Load will be initiated by internal type - so we are not interested in those
-                        initiatorType?.Assembly == Assembly.GetExecutingAssembly()
-                        ||
-                        IsBuiltinType(initiatorType?.FullName)
-                        ||
-                        IsBuiltinType(initiatorName)
-                    )
+                    // Load will be initiated by internal type - so we are not interested in those
+                    initiatorType?.Assembly == Assembly.GetExecutingAssembly()
+                    ||
+                    IsBuiltinType(initiatorType?.FullName)
+                    ||
+                    IsBuiltinType(initiatorName)
                 )
             )
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index e5d09b99d8a..2a9cc0e26b0 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -182,8 +182,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                 if (condition)
                 {
                     ExpanderOptions expanderOptions = ExpanderOptions.ExpandAll;
-                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) &&
-                        // If multiple buckets were expanded - we do not want to repeat same error for same metadatum on a same line
+                    if (// If multiple buckets were expanded - we do not want to repeat same error for same metadatum on a same line
                         bucket.BucketSequenceNumber == 0 &&
                         // Referring to unqualified metadata of other item (transform) is fine.
                         child.Include.IndexOf("@(", StringComparison.Ordinal) == -1)
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index a7f54890bbd..9de6967036e 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -119,22 +119,11 @@ internal virtual IReadOnlyList<SdkResolverManifest> FindPotentialSdkResolversMan
                 var assembly = Path.Combine(subfolder.FullName, $"{subfolder.Name}.dll");
                 bool assemblyAdded = false;
 
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-                {
-                    // Prefer manifest over the assembly. Try to read the xml first, and if not found then look for an assembly.
-                    assemblyAdded = TryAddAssemblyManifestFromXml(manifest, subfolder.FullName, manifestsList, location);
-                    if (!assemblyAdded)
-                    {
-                        assemblyAdded = TryAddAssemblyManifestFromDll(assembly, manifestsList);
-                    }
-                }
-                else
+                // Prefer manifest over the assembly. Try to read the xml first, and if not found then look for an assembly.
+                assemblyAdded = TryAddAssemblyManifestFromXml(manifest, subfolder.FullName, manifestsList, location);
+                if (!assemblyAdded)
                 {
                     assemblyAdded = TryAddAssemblyManifestFromDll(assembly, manifestsList);
-                    if (!assemblyAdded)
-                    {
-                        assemblyAdded = TryAddAssemblyManifestFromXml(manifest, subfolder.FullName, manifestsList, location);
-                    }
                 }
 
                 if (!assemblyAdded)
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 5b0265c8ae2..252bf62ab14 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -40,14 +40,6 @@ internal class SdkResolverService : ISdkResolverService
         /// </summary>
         private readonly ConcurrentDictionary<int, ConcurrentDictionary<SdkResolver, object>> _resolverStateBySubmission = new ConcurrentDictionary<int, ConcurrentDictionary<SdkResolver, object>>();
 
-        /// <summary>
-        /// Stores the list of SDK resolvers which were loaded.
-        /// </summary>
-        /// <remarks>
-        /// Need it for supporting the ChangeWave less than <see cref="ChangeWaves.Wave17_4"/>. Remove when move out Wave17_4.
-        /// </remarks>
-        private IReadOnlyList<SdkResolver> _resolversList;
-
         /// <summary>
         /// Stores the loaded SDK resolvers, mapped to the manifest from which they came.
         /// </summary>
@@ -118,7 +110,7 @@ public virtual void ClearCaches()
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk)
         {
-            // If we are running in .NET core, we ask the built-in default resolver first.
+                        // If we are running in .NET core, we ask the built-in default resolver first.
             // - It is a perf optimization (no need to discover and load any of the plug-in assemblies to resolve an "in-box" Sdk).
             // - It brings `dotnet build` to parity with `MSBuild.exe` functionally, as the Framework build of Microsoft.DotNet.MSBuildSdkResolver
             //   contains the same logic and it is the first resolver in priority order.
@@ -165,27 +157,8 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
                 }
             }
 #endif
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-            {
-                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, failOnUnresolvedSdk);
-            }
-            else
-            {
-                SdkResult result = ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, out IEnumerable<string> errors, out IEnumerable<string> warnings);
-
-                // Warnings are already logged on success.
-                if (!result.Success)
-                {
-                    if (failOnUnresolvedSdk)
-                    {
-                        loggingContext.LogError(new BuildEventFileInfo(sdkReferenceLocation), "FailedToResolveSDK", sdk.Name, string.Join($"{Environment.NewLine}  ", errors));
-                    }
-
-                    LogWarnings(loggingContext, sdkReferenceLocation, warnings);
-                }
 
-                return result;
-            }
+            return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, failOnUnresolvedSdk);
         }
 
         /// <remarks>
@@ -311,31 +284,6 @@ private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManif
             return resolvers;
         }
 
-        private SdkResult ResolveSdkUsingAllResolvers(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, out IEnumerable<string> errors, out IEnumerable<string> warnings)
-        {
-            // Lazy initialize all SDK resolvers
-            if (_resolversList == null)
-            {
-                Initialize(sdkReferenceLocation);
-            }
-
-            TryResolveSdkUsingSpecifiedResolvers(
-                _resolversList,
-                submissionId,
-                sdk,
-                loggingContext,
-                sdkReferenceLocation,
-                solutionPath,
-                projectPath,
-                interactive,
-                isRunningInVisualStudio,
-                out SdkResult sdkResult,
-                out errors,
-                out warnings);
-
-            return sdkResult;
-        }
-
         private bool TryResolveSdkUsingSpecifiedResolvers(
             IReadOnlyList<SdkResolver> resolvers,
             int submissionId,
@@ -458,24 +406,16 @@ internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IReadO
             _specificResolversManifestsRegistry = null;
             _generalResolversManifestsRegistry = null;
             _manifestToResolvers = null;
-            _resolversList = null;
 
             if (resolvers != null)
             {
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-                {
-                    _specificResolversManifestsRegistry = new List<SdkResolverManifest>();
-                    _generalResolversManifestsRegistry = new List<SdkResolverManifest>();
-                    _manifestToResolvers = new Dictionary<SdkResolverManifest, IReadOnlyList<SdkResolver>>();
+                _specificResolversManifestsRegistry = new List<SdkResolverManifest>();
+                _generalResolversManifestsRegistry = new List<SdkResolverManifest>();
+                _manifestToResolvers = new Dictionary<SdkResolverManifest, IReadOnlyList<SdkResolver>>();
 
-                    SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(DisplayName: "TestResolversManifest", Path: null, ResolvableSdkRegex: null);
-                    _generalResolversManifestsRegistry.Add(sdkResolverManifest);
-                    _manifestToResolvers[sdkResolverManifest] = resolvers;
-                }
-                else
-                {
-                    _resolversList = resolvers;
-                }
+                SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(DisplayName: "TestResolversManifest", Path: null, ResolvableSdkRegex: null);
+                _generalResolversManifestsRegistry.Add(sdkResolverManifest);
+                _manifestToResolvers[sdkResolverManifest] = resolvers;
             }
         }
 
@@ -517,19 +457,6 @@ private object GetResolverState(int submissionId, SdkResolver resolver)
             return null;
         }
 
-        private void Initialize(ElementLocation location)
-        {
-            lock (_lockObject)
-            {
-                if (_resolversList != null)
-                {
-                    return;
-                }
-
-                _resolversList = _sdkResolverLoader.LoadAllResolvers(location);
-            }
-        }
-
         private void RegisterResolversManifests(ElementLocation location)
         {
             lock (_lockObject)
@@ -587,7 +514,7 @@ private void SetResolverState(int submissionId, SdkResolver resolver, object sta
                     submissionId,
                     _ => new ConcurrentDictionary<SdkResolver, object>(
                         NativeMethodsShared.GetLogicalCoreCount(),
-                        ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) ? _specificResolversManifestsRegistry.Count + _generalResolversManifestsRegistry.Count : _resolversList.Count));
+                        _specificResolversManifestsRegistry.Count + _generalResolversManifestsRegistry.Count));
 
                 resolverState.AddOrUpdate(resolver, state, (sdkResolver, obj) => state);
             }
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index f0fd2ca4af5..af13beb079d 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -586,8 +586,6 @@ private void SendPacket(INodePacket packet)
 #if RUNTIME_TYPE_NETCORE
                 if (packet is LogMessagePacketBase logMessage
                     && logMessage.EventType == LoggingEventType.CustomEvent
-                    &&
-                    (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
                     && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
                 {
                     BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index 5aa8ca900e9..1e1964748af 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -12,6 +12,14 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
+/// <summary>
+/// Central logger for the build check infrastructure.
+/// Receives events from the <see cref="BuildCheckForwardingLogger"/>.
+/// Processes the events and forwards them to the <see cref="IBuildCheckManager"/> and registered analyzers.
+/// </summary>
+/// <remarks>
+/// Ensure that the consuming events are in sync with <see cref="BuildCheckForwardingLogger"/>.
+/// </remarks>
 internal sealed class BuildCheckConnectorLogger : ILogger
 {
     private readonly BuildCheckBuildEventHandler _eventHandler;
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
index 6e8f969b544..81dffca84ff 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
@@ -7,13 +7,61 @@
 using System.Text;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck.Acquisition;
+using Microsoft.Build.Framework;
+using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.BuildCheckManagerProvider;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
 /// Forwarding logger for the build check infrastructure.
-/// For now we jus want to forward all events, while disable verbose logging of tasks.
+/// For now we just want to forward all events that are needed for BuildCheckConnectorLogger and filter out all other.
+/// If the custom analyzer is detected, starts to unconditionally forward all events.
 /// In the future we may need more specific behavior.
 /// </summary>
-internal class BuildCheckForwardingLogger : CentralForwardingLogger
-{ }
+/// <remarks>
+/// Ensure that events filtering is in sync with <see cref="BuildCheckConnectorLogger"/>
+/// </remarks>
+internal class BuildCheckForwardingLogger : IForwardingLogger
+{
+    public IEventRedirector? BuildEventRedirector { get; set; }
+
+    public int NodeId { get; set; }
+
+    public LoggerVerbosity Verbosity { get => LoggerVerbosity.Quiet; set { return; } }
+
+    public string? Parameters { get; set; }
+
+    /// <summary>
+    /// Set of events to be forwarded to  <see cref="BuildCheckConnectorLogger"/>
+    /// </summary>
+    private HashSet<Type> _eventsToForward = new HashSet<Type>
+    {
+        typeof(ProjectEvaluationFinishedEventArgs),
+        typeof(ProjectEvaluationStartedEventArgs),
+        typeof(ProjectStartedEventArgs),
+        typeof(ProjectFinishedEventArgs),
+        typeof(BuildCheckTracingEventArgs),
+        typeof(BuildCheckAcquisitionEventArgs),
+        typeof(TaskStartedEventArgs),
+        typeof(TaskFinishedEventArgs),
+        typeof(TaskParameterEventArgs)
+    };
+
+    public void Initialize(IEventSource eventSource, int nodeCount) => Initialize(eventSource);
+
+    public void Initialize(IEventSource eventSource)
+    {
+        eventSource.AnyEventRaised += EventSource_AnyEventRaised;
+    }
+
+    public void EventSource_AnyEventRaised(object sender, BuildEventArgs buildEvent)
+    {
+        if (_eventsToForward.Contains(buildEvent.GetType()))
+        {
+            BuildEventRedirector?.ForwardEvent(buildEvent);
+        }
+    }
+
+    public void Shutdown() { }
+}
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 92e920c3f80..2ab9a1a53d4 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -1691,31 +1691,13 @@ private void ReloadFrom(Func<bool, XmlDocumentWithLocation> documentProducer, bo
 
             var oldDocument = XmlDocument;
             XmlDocumentWithLocation newDocument = documentProducer(preserveFormatting ?? PreserveFormatting);
-            try
-            {
-                // Reload should only mutate the state if there are no parse errors.
-                ThrowIfDocumentHasParsingErrors(newDocument);
 
-                RemoveAllChildren();
+            // Reload should only mutate the state if there are no parse errors.
+            ThrowIfDocumentHasParsingErrors(newDocument);
 
-                ProjectParser.Parse(newDocument, this);
-            }
-            finally
-            {
-                // Whichever document didn't become this element's document must be removed from the string cache.
-                // We do it after the fact based on the assumption that Projects are reloaded repeatedly from their
-                // file with small increments, and thus most strings would get reused avoiding unnecessary churn in
-                // the string cache.
-                var currentDocument = XmlDocument;
-                if (!object.ReferenceEquals(currentDocument, oldDocument))
-                {
-                    oldDocument.ClearAnyCachedStrings();
-                }
-                if (!object.ReferenceEquals(currentDocument, newDocument))
-                {
-                    newDocument.ClearAnyCachedStrings();
-                }
-            }
+            RemoveAllChildren();
+
+            ProjectParser.Parse(newDocument, this);
 
             MarkDirty("Project reloaded", null);
         }
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index ef1fbe5bd37..d7d90b3a939 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -3571,7 +3571,6 @@ public override void Unload()
             {
                 Xml.OnAfterProjectRename -= _renameHandler;
                 Xml.OnProjectXmlChanged -= ProjectRootElement_ProjectXmlChangedHandler;
-                Xml.XmlDocument.ClearAnyCachedStrings();
                 _renameHandler = null;
             }
 
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 9429ec8ecf8..93e536f0aa8 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -1363,18 +1363,6 @@ public void UnloadProject(Project project)
                 // free memory. These may be the last references to the ProjectRootElements
                 // in the cache, so the cache shouldn't hold strong references to them of its own.
                 ProjectRootElementCache.DiscardStrongReferences();
-
-                // Aggressively release any strings from all the contributing documents.
-                // It's fine if we cache less (by now we likely did a lot of loading and got the benefits)
-                // If we don't do this, we could be releasing the last reference to a
-                // ProjectRootElement, causing it to fall out of the weak cache leaving its strings and XML
-                // behind in the string cache.
-                project.Xml.XmlDocument.ClearAnyCachedStrings();
-
-                foreach (var import in project.Imports)
-                {
-                    import.ImportedProject.XmlDocument.ClearAnyCachedStrings();
-                }
             }
         }
 
@@ -1405,7 +1393,6 @@ public void UnloadProject(ProjectRootElement projectRootElement)
                     ErrorUtilities.ThrowInvalidOperation("OM_ProjectXmlCannotBeUnloadedDueToLoadedProjects", projectRootElement.FullPath, conflictingProject.FullPath);
                 }
 
-                projectRootElement.XmlDocument.ClearAnyCachedStrings();
                 ProjectRootElementCache.DiscardAnyWeakReference(projectRootElement);
             }
         }
@@ -1556,7 +1543,6 @@ public bool TryUnloadProject(ProjectRootElement projectRootElement)
                 if (conflictingProject == null)
                 {
                     ProjectRootElementCache.DiscardAnyWeakReference(projectRootElement);
-                    projectRootElement.XmlDocument.ClearAnyCachedStrings();
                     return true;
                 }
 
@@ -2041,7 +2027,7 @@ public ReusableLogger(ILogger originalLogger)
             /// The telemetry sent event.
             /// </summary>
             public event TelemetryEventHandler TelemetryLogged;
-            
+
             /// <summary>
             /// Should evaluation events include generated metaprojects?
             /// </summary>
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index 71f51e9f272..cfa910da6a8 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -7,6 +7,7 @@
 using System.Xml;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
+using Microsoft.NET.StringTools;
 
 #nullable disable
 
@@ -23,11 +24,6 @@ namespace Microsoft.Build.Construction
     /// </remarks>
     internal class XmlDocumentWithLocation : XmlDocument
     {
-        /// <summary>
-        /// Used to cache strings used in attribute values and comments.
-        /// </summary>
-        private static ProjectStringCache s_globalStringCache = new ProjectStringCache();
-
         /// <summary>
         /// Used to cache tag names in loaded files.
         /// </summary>
@@ -49,11 +45,6 @@ internal class XmlDocumentWithLocation : XmlDocument
         /// </summary>
         private string _fullPath;
 
-        /// <summary>
-        /// Local cache of strings for attribute values and comments. Used for testing.
-        /// </summary>
-        private ProjectStringCache _stringCache;
-
         /// <summary>
         /// Whether we can expect to never save this file.
         /// In such a case, we can discard as much as possible on load, like comments and whitespace.
@@ -124,19 +115,6 @@ internal string FullPath
             set { _fullPath = value; }
         }
 
-        /// <summary>
-        /// Sets or gets the string cache used by this XmlDocument.
-        /// </summary>
-        /// <remarks>
-        /// When a particular instance has not been set will use the global string cache. The ability
-        /// to use a particular instance is useful for tests.
-        /// </remarks>
-        internal ProjectStringCache StringCache
-        {
-            get { return _stringCache ?? s_globalStringCache; }
-            set { _stringCache = value; }
-        }
-
         /// <summary>
         /// Loads from an XmlReader, intercepting the reader.
         /// </summary>
@@ -262,7 +240,7 @@ public override XmlWhitespace CreateWhitespace(string text)
                 text = String.Empty;
             }
 
-            string interned = StringCache.Add(text, this);
+            string interned = Strings.WeakIntern(text);
             return base.CreateWhitespace(interned);
         }
 
@@ -278,7 +256,7 @@ public override XmlSignificantWhitespace CreateSignificantWhitespace(string text
                 text = String.Empty;
             }
 
-            string interned = StringCache.Add(text, this);
+            string interned = Strings.WeakIntern(text);
             return base.CreateSignificantWhitespace(interned);
         }
 
@@ -288,7 +266,7 @@ public override XmlSignificantWhitespace CreateSignificantWhitespace(string text
         /// </summary>
         public override XmlText CreateTextNode(string text)
         {
-            string textNode = StringCache.Add(text, this);
+            string textNode = Strings.WeakIntern(text);
             return base.CreateTextNode(textNode);
         }
 
@@ -303,7 +281,7 @@ public override XmlComment CreateComment(string data)
                 data = String.Empty;
             }
 
-            string interned = StringCache.Add(data, this);
+            string interned = Strings.WeakIntern(data);
             return base.CreateComment(interned);
         }
 
@@ -356,16 +334,6 @@ internal static void ClearReadOnlyFlags_UnitTestsOnly()
             s_readOnlyFlags = ReadOnlyLoadFlags.Undefined;
         }
 
-        /// <summary>
-        /// Called when the XmlDocument is unloaded to remove this XML's
-        /// contribution to the string interning cache.
-        /// Does NOT zombie the ProjectRootElement or anything else.
-        /// </summary>
-        internal void ClearAnyCachedStrings()
-        {
-            StringCache.Clear(this);
-        }
-
         /// <summary>
         /// Determine whether we should load this file read only.
         /// We decide yes if it is in program files or the OS directory, and the file name starts with "microsoft", else no.
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 3e67f786ac8..8e0f9318b89 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -1593,7 +1593,7 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin
                 if (!_fallbackSearchPathsCache.DirectoryExists(extensionPathExpanded))
                 {
                     // Set to log an error only if the change wave is enabled.
-                    missingDirectoryDespiteTrueCondition = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && !containsWildcards;
+                    missingDirectoryDespiteTrueCondition = !containsWildcards;
                     continue;
                 }
 
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 75f0216028f..7f2680b75ab 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -396,7 +396,7 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMeta
         /// This is for the purpose of evaluations through API calls, that might not be able to pass the logging context
         ///  - BuildCheck analysis won't be executed for those.
         /// (for one of the calls we can actually pass IDataConsumingContext - as we have logging service and project)
-        /// 
+        ///
         /// </summary>
         internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMetadataTable metadata, IFileSystem fileSystem)
             : this(properties, items, fileSystem, null)
@@ -1558,7 +1558,7 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                                    MSBuildNameIgnoreCaseComparer.Default.Equals("MSBuild", propertyName, startIndex, 7);
 
                 propertiesUseTracker.TrackRead(propertyName, startIndex, endIndex, elementLocation, property == null, isArtifical);
-                
+
                 if (isArtifical)
                 {
                     // It could be one of the MSBuildThisFileXXXX properties,
@@ -1654,9 +1654,8 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
             {
 #if RUNTIME_TYPE_NETCORE
                 // .NET Core MSBuild used to always return empty, so match that behavior
-                // on non-Windows (no registry), and with a changewave (in case someone
-                // had a registry property and it breaks when it lights up).
-                if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                // on non-Windows (no registry).
+                if (!NativeMethodsShared.IsWindows)
                 {
                     return string.Empty;
                 }
@@ -2017,8 +2016,7 @@ internal static bool ExpandExpressionCapture<S>(
                     if (expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "Count", StringComparison.OrdinalIgnoreCase)) != true)
                     {
                         // ...or a function "AnyHaveMetadataValue", since that will want to return false for an empty list.
-                        if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) ||
-                            expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "AnyHaveMetadataValue", StringComparison.OrdinalIgnoreCase)) != true)
+                        if (expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "AnyHaveMetadataValue", StringComparison.OrdinalIgnoreCase)) != true)
                         {
                             itemsFromCapture = new List<KeyValuePair<string, S>>();
                             return false;
@@ -4927,13 +4925,10 @@ private static bool TryExecuteArithmeticOverload(object[] args, Func<long, long,
                     return false;
                 }
 
-                if (IntrinsicFunctionOverload.IsIntrinsicFunctionOverloadsEnabled())
+                if (TryConvertToLong(args[0], out long argLong0) && TryConvertToLong(args[1], out long argLong1))
                 {
-                    if (TryConvertToLong(args[0], out long argLong0) && TryConvertToLong(args[1], out long argLong1))
-                    {
-                        resultValue = integerOperation(argLong0, argLong1);
-                        return true;
-                    }
+                    resultValue = integerOperation(argLong0, argLong1);
+                    return true;
                 }
 
                 if (TryConvertToDouble(args[0], out double argDouble0) && TryConvertToDouble(args[1], out double argDouble1))
@@ -5565,17 +5560,11 @@ internal static class IntrinsicFunctionOverload
         // For reuse, the comparer is cached in a non-generic type.
         // Both comparer instances can be cached to support change wave testing.
         private static IComparer<MemberInfo>? s_comparerLongBeforeDouble;
-        private static IComparer<MemberInfo>? s_comparerDoubleBeforeLong;
 
-        internal static IComparer<MemberInfo> IntrinsicFunctionOverloadMethodComparer => IsIntrinsicFunctionOverloadsEnabled() ? LongBeforeDoubleComparer : DoubleBeforeLongComparer;
+        internal static IComparer<MemberInfo> IntrinsicFunctionOverloadMethodComparer => LongBeforeDoubleComparer;
 
         private static IComparer<MemberInfo> LongBeforeDoubleComparer => s_comparerLongBeforeDouble ??= Comparer<MemberInfo>.Create((key0, key1) => SelectTypeOfFirstParameter(key0).CompareTo(SelectTypeOfFirstParameter(key1)));
 
-        private static IComparer<MemberInfo> DoubleBeforeLongComparer => s_comparerDoubleBeforeLong ??= Comparer<MemberInfo>.Create((key0, key1) => SelectTypeOfFirstParameter(key1).CompareTo(SelectTypeOfFirstParameter(key0)));
-
-        // The arithmetic overload feature uses this method to test for the change wave.
-        internal static bool IsIntrinsicFunctionOverloadsEnabled() => ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8);
-
         internal static bool IsKnownOverloadMethodName(string methodName) => s_knownOverloadName.Any(name => string.Equals(name, methodName, StringComparison.OrdinalIgnoreCase));
 
         private static TypeCode SelectTypeOfFirstParameter(MemberInfo member)
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 17e67ce123a..d9de22f294e 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -191,9 +191,8 @@ internal static object GetRegistryValue(string keyName, string valueName)
         {
 #if RUNTIME_TYPE_NETCORE
             // .NET Core MSBuild used to always return empty, so match that behavior
-            // on non-Windows (no registry), and with a changewave (in case someone
-            // had a registry property and it breaks when it lights up).
-            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            // on non-Windows (no registry).
+            if (!NativeMethodsShared.IsWindows)
             {
                 return null;
             }
@@ -208,9 +207,8 @@ internal static object GetRegistryValue(string keyName, string valueName, object
         {
 #if RUNTIME_TYPE_NETCORE
             // .NET Core MSBuild used to always return empty, so match that behavior
-            // on non-Windows (no registry), and with a changewave (in case someone
-            // had a registry property and it breaks when it lights up).
-            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            // on non-Windows (no registry).
+            if (!NativeMethodsShared.IsWindows)
             {
                 return defaultValue;
             }
@@ -222,9 +220,8 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
         {
 #if RUNTIME_TYPE_NETCORE
             // .NET Core MSBuild used to always return empty, so match that behavior
-            // on non-Windows (no registry), and with a changewave (in case someone
-            // had a registry property and it breaks when it lights up).
-            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            // on non-Windows (no registry).
+            if (!NativeMethodsShared.IsWindows)
             {
                 return defaultValue;
             }
@@ -245,9 +242,8 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
         {
 #if RUNTIME_TYPE_NETCORE
             // .NET Core MSBuild used to always return empty, so match that behavior
-            // on non-Windows (no registry), and with a changewave (in case someone
-            // had a registry property and it breaks when it lights up).
-            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            // on non-Windows (no registry).
+            if (!NativeMethodsShared.IsWindows)
             {
                 return defaultValue;
             }
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index 5de3520dab8..5ad09b27116 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -629,13 +629,10 @@ private ProjectTargetElement ParseProjectTargetElement(XmlElementWithLocation el
                         {
                             ProjectErrorUtilities.ThrowInvalidProject(onError.Location, "NodeMustBeLastUnderElement", XMakeElements.onError, XMakeElements.target, childElement.Name);
                         }
-                        if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+                        if (childElement.ChildNodes.Count == 1 && childElement.FirstChild.NodeType == XmlNodeType.Text)
                         {
-                            if (childElement.ChildNodes.Count == 1 && childElement.FirstChild.NodeType == XmlNodeType.Text)
-                            {
-                                // If the element has inner text and no other child elements except text, then this should be a property and throw invalid child element of <Target>
-                                ProjectErrorUtilities.ThrowInvalidProject(childElement.Location, "PropertyOutsidePropertyGroupInTarget", childElement.Name, childElement.ParentNode.Name);
-                            }
+                            // If the element has inner text and no other child elements except text, then this should be a property and throw invalid child element of <Target>
+                            ProjectErrorUtilities.ThrowInvalidProject(childElement.Location, "PropertyOutsidePropertyGroupInTarget", childElement.Name, childElement.ParentNode.Name);
                         }
 
                         child = ParseProjectTaskElement(childElement, target);
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 143587d96ee..97c925a0327 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -438,14 +438,8 @@ internal override void DiscardStrongReferences()
             {
                 DebugTraceCache("Clearing strong refs: ", _strongCache.Count);
 
-                LinkedList<ProjectRootElement> oldStrongCache = _strongCache;
                 _strongCache = new LinkedList<ProjectRootElement>();
 
-                foreach (ProjectRootElement projectRootElement in oldStrongCache)
-                {
-                    RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);
-                }
-
                 // A scavenge of the weak cache is probably not worth it as
                 // the GC would have had to run immediately after the line above.
             }
@@ -459,45 +453,8 @@ internal override void Clear()
         {
             lock (_locker)
             {
-                if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)
-                {
-                    LinkedList<ProjectRootElement> oldStrongCache = _strongCache;
-                    _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);
-                    _strongCache = new LinkedList<ProjectRootElement>();
-
-                    foreach (ProjectRootElement projectRootElement in oldStrongCache)
-                    {
-                        RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);
-                    }
-                }
-                else
-                {
-                    // Manually iterate through LinkedList so we can remove items during this iteration
-                    for (var listNode = _strongCache.First; listNode != null;)
-                    {
-                        var nextNode = listNode.Next;
-
-                        ProjectRootElement projectRootElement = listNode.Value;
-                        // Do not remove cache of files from immutable locations.
-                        // Those are mostly SDK project files and will be most probably needed in next builds.
-                        if (!FileClassifier.Shared.IsNonModifiable(projectRootElement.FullPath))
-                        {
-                            _weakCache.Remove(projectRootElement.FullPath);
-                            _strongCache.Remove(listNode);
-                            RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);
-                        }
-
-                        listNode = nextNode;
-                    }
-
-                    // From weak list remove all which is not in strong list anymore
-                    IList<string> toBeRemovedFromWeakRefs = _weakCache.Keys.Except(_strongCache.Select(i => i.FullPath)).ToList();
-                    foreach (string victim in toBeRemovedFromWeakRefs)
-                    {
-                        _weakCache.Remove(victim);
-                    }
-                    _weakCache.Scavenge();
-                }
+                _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);
+                _strongCache = new LinkedList<ProjectRootElement>();
             }
         }
 
@@ -540,10 +497,6 @@ internal override void DiscardImplicitReferences()
                         {
                             _strongCache.AddFirst(kvp.Value);
                         }
-                        else
-                        {
-                            RaiseProjectRootElementRemovedFromStrongCache(kvp.Value);
-                        }
                     }
                 }
             }
@@ -608,7 +561,6 @@ private void RenameEntryInternal(string oldFullPathIfAny, ProjectRootElement pro
             if (existingWeakEntry != null && !object.ReferenceEquals(existingWeakEntry, projectRootElement))
             {
                 _strongCache.Remove(existingWeakEntry);
-                RaiseProjectRootElementRemovedFromStrongCache(existingWeakEntry);
             }
 
             DebugTraceCache("Adding: ", projectRootElement.FullPath);
@@ -654,7 +606,6 @@ private void BoostEntryInStrongCache(ProjectRootElement projectRootElement)
 
                 DebugTraceCache("Shedding: ", node.Value.FullPath);
                 _strongCache.Remove(node);
-                RaiseProjectRootElementRemovedFromStrongCache(node.Value);
             }
         }
 
@@ -674,7 +625,6 @@ private void ForgetEntry(ProjectRootElement projectRootElement)
             if (strongCacheEntry != null)
             {
                 _strongCache.Remove(strongCacheEntry);
-                RaiseProjectRootElementRemovedFromStrongCache(strongCacheEntry.Value);
             }
 
             DebugTraceCache("Out of date dropped from XML cache: ", projectRootElement.FullPath);
diff --git a/src/Build/Evaluation/ProjectRootElementCacheBase.cs b/src/Build/Evaluation/ProjectRootElementCacheBase.cs
index 97857fa0b6e..bc8823398b5 100644
--- a/src/Build/Evaluation/ProjectRootElementCacheBase.cs
+++ b/src/Build/Evaluation/ProjectRootElementCacheBase.cs
@@ -27,11 +27,6 @@ internal abstract class ProjectRootElementCacheBase
         /// </summary>
         internal delegate ProjectRootElement OpenProjectRootElement(string path, ProjectRootElementCacheBase cache);
 
-        /// <summary>
-        /// Event that is fired when an entry in the Strong Cache is removed.
-        /// </summary>
-        internal static event StrongCacheEntryRemovedDelegate StrongCacheEntryRemoved;
-
         /// <summary>
         /// Event which is fired when a project root element is added to this cache.
         /// </summary>
@@ -96,15 +91,6 @@ protected void RaiseProjectRootElementAddedToCacheEvent(ProjectRootElement rootE
         {
             ProjectRootElementAddedHandler?.Invoke(this, new ProjectRootElementCacheAddEntryEventArgs(rootElement));
         }
-
-        /// <summary>
-        /// Raises an event which is raised when a project root element is removed from the strong cache.
-        /// </summary>
-        protected virtual void RaiseProjectRootElementRemovedFromStrongCache(ProjectRootElement projectRootElement)
-        {
-            StrongCacheEntryRemovedDelegate removedEvent = StrongCacheEntryRemoved;
-            removedEvent?.Invoke(this, projectRootElement);
-        }
     }
 
     /// <summary>
diff --git a/src/Build/Evaluation/ProjectStringCache.cs b/src/Build/Evaluation/ProjectStringCache.cs
deleted file mode 100644
index 7753ae7e5a5..00000000000
--- a/src/Build/Evaluation/ProjectStringCache.cs
+++ /dev/null
@@ -1,320 +0,0 @@
-ï»¿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Xml;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-
-#nullable disable
-
-namespace Microsoft.Build.Construction
-{
-    /// <summary>
-    /// This class will cache string values for loaded Xml files.
-    /// </summary>
-    [DebuggerDisplay("#Strings={Count} #Documents={_documents.Count}")]
-    internal class ProjectStringCache
-    {
-        /// <summary>
-        /// Start off with a large size as there are very many strings in common scenarios and resizing is expensive.
-        /// Note that there is a single instance of this cache for the lifetime of the process (albeit cleared out on XML unload)
-        /// Australian Govt has about 3000 strings; a single VC project with all its various XML files has about 4000 strings.
-        /// </summary>
-        private const int InitialSize = 5000;
-
-        /// <summary>
-        /// Store interned strings, and also a ref count, one per document using them.
-        /// </summary>
-        private RetrievableEntryHashSet<StringCacheEntry> _strings = new RetrievableEntryHashSet<StringCacheEntry>(InitialSize, StringComparer.Ordinal);
-
-        /// <summary>
-        /// Store all the strings a document is using, so their ref count can be decremented.
-        /// </summary>
-        private Dictionary<XmlDocument, HashSet<StringCacheEntry>> _documents = new Dictionary<XmlDocument, HashSet<StringCacheEntry>>();
-
-        /// <summary>
-        /// Locking object for this shared cache
-        /// </summary>
-        private Object _locker = new Object();
-
-        /// <summary>
-        /// Public constructor.
-        /// </summary>
-        public ProjectStringCache()
-        {
-            ProjectRootElementCacheBase.StrongCacheEntryRemoved += OnStrongCacheEntryRemoved;
-        }
-
-        /// <summary>
-        /// Obtain the number of entries contained in the cache.
-        /// </summary>
-        internal int Count
-        {
-            get
-            {
-                lock (_locker)
-                {
-                    return _strings.Count;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Obtain the number of documents contained in the cache.
-        /// </summary>
-        internal int DocumentCount
-        {
-            get
-            {
-                lock (_locker)
-                {
-                    return _documents.Count;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Add the given string to the cache or return the existing string if it is already
-        /// in the cache.
-        /// Constant time operation.
-        /// </summary>
-        public string Add(string key, XmlDocument document)
-        {
-            // Remove string interning in ChangeWave 17.6
-            // Note: When ready to remove the ChangeWaves under 17.6, please delete this entire class and all references to it. (See the PR https://github.com/dotnet/msbuild/pull/7952).
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
-            {
-                return key;
-            }
-
-            if (key.Length == 0)
-            {
-                return String.Empty;
-            }
-
-            // see Microsoft.Build.BackEnd.BuildRequestConfiguration.CreateUniqueGlobalProperty
-            if (key.StartsWith(MSBuildConstants.MSBuildDummyGlobalPropertyHeader, StringComparison.Ordinal))
-            {
-                return key;
-            }
-
-            lock (_locker)
-            {
-                VerifyState();
-
-                StringCacheEntry entry;
-                HashSet<StringCacheEntry> entries;
-
-                bool seenString = _strings.TryGetValue(key, out entry);
-                bool seenDocument = _documents.TryGetValue(document, out entries);
-
-                if (!seenString)
-                {
-                    entry = new StringCacheEntry(key);
-                    _strings.Add(entry);
-                }
-
-                if (!seenDocument)
-                {
-                    entries = new HashSet<StringCacheEntry>();
-                    _documents.Add(document, entries);
-                }
-
-                bool seenStringInThisDocument = seenString && seenDocument && entries.Contains(entry);
-
-                if (!seenStringInThisDocument)
-                {
-                    entries.Add(entry);
-
-                    // We've been referred to by a new document, so increment our ref count.
-                    entry.Increment();
-                }
-
-                VerifyState();
-
-                return entry.CachedString;
-            }
-        }
-
-        /// <summary>
-        /// Find the matching string in the cache.
-        /// Constant time operation.
-        /// </summary>
-        /// <param name="key">String to find in the cache.</param>
-        /// <returns>Existing string in the cache, or null if it is not contained.</returns>
-        public string Get(string key)
-        {
-            lock (_locker)
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(key, nameof(key));
-
-                if (key.Length == 0)
-                {
-                    return String.Empty;
-                }
-
-                StringCacheEntry entry;
-                if (_strings.TryGetValue(key, out entry))
-                {
-                    return entry.CachedString;
-                }
-
-                return null;
-            }
-        }
-
-        /// <summary>
-        /// Indicates that a document's entries should be removed.
-        /// If document is unknown, does nothing.
-        /// Complexity proportional to the number of strings in the document,
-        /// if the document is anywhere in the cache, otherwise O(1).
-        /// </summary>
-        public void Clear(XmlDocument document)
-        {
-            lock (_locker)
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(document, nameof(document));
-
-                VerifyState();
-
-                HashSet<StringCacheEntry> entries;
-                if (_documents.TryGetValue(document, out entries))
-                {
-                    foreach (var entry in entries)
-                    {
-                        string str = entry.CachedString;
-                        entry.Decrement();
-
-                        if (entry.RefCount == 0)
-                        {
-                            _strings.Remove(str);
-                        }
-                    }
-
-                    _documents.Remove(document);
-                }
-
-                VerifyState();
-            }
-        }
-
-        /// <summary>
-        /// Verifies that each string entry has only one instance in the system.
-        /// Enable the conditional if and while you make any modifications to the class, then disable as it is very slow.
-        /// </summary>
-        [Conditional("NEVER")]
-        private void VerifyState()
-        {
-            HashSet<StringCacheEntry> uniqueEntries = new HashSet<StringCacheEntry>();
-            foreach (var entries in _documents.Values)
-            {
-                foreach (var entry in entries)
-                {
-                    uniqueEntries.Add(entry);
-                    ErrorUtilities.VerifyThrow(entry.RefCount > 0, "extra deref");
-
-                    // We only ever create one StringCacheEntry instance per unique string, and that instance should be
-                    // the same in both collections.
-                    ErrorUtilities.VerifyThrow(Object.ReferenceEquals(entry, _strings[entry.CachedString]), "bad state");
-                }
-            }
-
-            ErrorUtilities.VerifyThrow(uniqueEntries.Count == _strings.Count, "bad state");
-        }
-
-        /// <summary>
-        /// Handle event that is fired when an entry in the project root element cache is removed
-        /// from its strong cache.
-        /// </summary>
-        /// <remarks>
-        /// When an entry is removed from a project root element cache's strong cache, we will remove
-        /// its entries from our string cache. Otherwise the string cache ends up being the only one
-        /// holding references to the Xml documents that have already been dropped.
-        /// </remarks>
-        private void OnStrongCacheEntryRemoved(object sender, ProjectRootElement projectRootElement)
-        {
-            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, nameof(projectRootElement));
-            Clear(projectRootElement.XmlDocument);
-        }
-
-        /// <summary>
-        /// Represents an entry in the ProjectStringCache.
-        /// Can't be a struct because the copy-by-value and the ref counting don't go well together.
-        /// </summary>
-        [DebuggerDisplay("Count={_refCount} String={_cachedString}")]
-        private class StringCacheEntry : IKeyed
-        {
-            /// <summary>
-            /// Cached string
-            /// </summary>
-            private string _cachedString;
-
-            /// <summary>
-            /// Number of XmlDocuments where this string is included.
-            /// </summary>
-            private int _refCount;
-
-            /// <summary>
-            /// Constructor.
-            /// Caller must then do Increment().
-            /// </summary>
-            internal StringCacheEntry(string str)
-            {
-                _cachedString = str;
-                _refCount = 0;
-            }
-
-            /// <summary>
-            /// Key to find it
-            /// </summary>
-            public string Key
-            {
-                get { return _cachedString; }
-            }
-
-            /// <summary>
-            /// Number of documents using this string
-            /// </summary>
-            internal int RefCount
-            {
-                get { return _refCount; }
-            }
-
-            /// <summary>
-            /// Get the cached string.
-            /// </summary>
-            internal string CachedString
-            {
-                get
-                {
-                    ErrorUtilities.VerifyThrow(_refCount > 0, "extra deref");
-                    return _cachedString;
-                }
-            }
-
-            /// <summary>
-            /// Indicates that this entry is included in the given document.
-            /// Callers must verify that we were not already adreffed for this document.
-            /// </summary>
-            internal void Increment()
-            {
-                _refCount++;
-            }
-
-            /// <summary>
-            /// Removes a container for this entry.
-            /// Callers must verify that this was not already reffed and not subsequently dereffed.
-            /// </summary>
-            internal void Decrement()
-            {
-                ErrorUtilities.VerifyThrow(_refCount > 0, "extra deref");
-                _refCount--;
-            }
-        }
-    }
-}
diff --git a/src/Build/Evaluation/SimpleProjectRootElementCache.cs b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
index f359d3cbd07..e2a9d7d782e 100644
--- a/src/Build/Evaluation/SimpleProjectRootElementCache.cs
+++ b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
@@ -139,10 +139,5 @@ internal override void OnProjectDirtied(Project sender, ProjectChangedEventArgs
         {
             throw new NotImplementedException();
         }
-
-        protected override void RaiseProjectRootElementRemovedFromStrongCache(ProjectRootElement projectRootElement)
-        {
-            throw new NotImplementedException();
-        }
     }
 }
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 7dc448e6fb5..d254e53458d 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -881,7 +881,7 @@ public int Compare(object o1, object o2)
 
         public virtual void Shutdown()
         {
-            Traits.LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES")) && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4);
+            Traits.LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES"));
         }
 
         internal abstract void ResetConsoleLoggerState();
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 289a3b2c959..b06858fa47a 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -487,7 +487,6 @@
     <Compile Include="Evaluation\ProjectRootElementCacheBase.cs" />
     <Compile Include="Evaluation\ProjectRootElementCache.cs" />
     <Compile Include="Evaluation\SimpleProjectRootElementCache.cs" />
-    <Compile Include="Evaluation\ProjectStringCache.cs" />
     <Compile Include="Evaluation\SemiColonTokenizer.cs" />
     <Compile Include="Evaluation\StringMetadataTable.cs" />
     <Compile Include="Evaluation\ExpressionShredder.cs" />
diff --git a/src/Build/Xml/ProjectXmlUtilities.cs b/src/Build/Xml/ProjectXmlUtilities.cs
index c5ef688824e..e555da0aae3 100644
--- a/src/Build/Xml/ProjectXmlUtilities.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.cs
@@ -98,7 +98,7 @@ internal static bool VerifyValidProjectNamespace(XmlElementWithLocation element)
             }
             else if (string.IsNullOrEmpty(element.NamespaceURI))
             {
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) && Path.GetExtension(element.Location.File).Equals(".dwproj", StringComparison.OrdinalIgnoreCase))
+                if (Path.GetExtension(element.Location.File).Equals(".dwproj", StringComparison.OrdinalIgnoreCase))
                 {
                     bool validMSBuildProject = true;
                     foreach (XmlNode child in element.ChildNodes)
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 51717c375ae..1d682c4fc75 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -25,12 +25,9 @@ internal enum ChangeWaveConversionState
     /// For dev docs: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves-Dev.md
     internal static class ChangeWaves
     {
-        internal static readonly Version Wave17_4 = new Version(17, 4);
-        internal static readonly Version Wave17_6 = new Version(17, 6);
-        internal static readonly Version Wave17_8 = new Version(17, 8);
         internal static readonly Version Wave17_10 = new Version(17, 10);
         internal static readonly Version Wave17_12 = new Version(17, 12);
-        internal static readonly Version[] AllWaves = { Wave17_4, Wave17_6, Wave17_8, Wave17_10, Wave17_12 };
+        internal static readonly Version[] AllWaves = { Wave17_10, Wave17_12 };
 
         /// <summary>
         /// Special value indicating that all features behind all Change Waves should be enabled.
diff --git a/src/Framework/EncodingUtilities.cs b/src/Framework/EncodingUtilities.cs
index 93e0dd940fe..4ee4679dd3f 100644
--- a/src/Framework/EncodingUtilities.cs
+++ b/src/Framework/EncodingUtilities.cs
@@ -264,11 +264,6 @@ internal static Encoding BatchFileEncoding(string contents, string encodingSpeci
         /// </returns>
         public static CultureInfo? GetExternalOverriddenUILanguageIfSupportableWithEncoding()
         {
-            if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
-            {
-                return null;
-            }
-
             CultureInfo? externalLanguageSetting = GetExternalOverriddenUILanguage();
             if (externalLanguageSetting != null)
             {
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 9bca9afa1a5..cc0ef31eee8 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -110,11 +110,8 @@ public Traits()
         /// <summary>
         /// Log all environment variables whether or not they are used in a build in the binary log.
         /// </summary>
-        public static bool LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES"))
-#if !TASKHOST
-            && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4)
-#endif
-            ;
+        public static bool LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES"));
+
         /// <summary>
         /// Log property tracking information.
         /// </summary>
diff --git a/src/MSBuild.Bootstrap.Utils/MSBuild.Bootstrap.Utils.csproj b/src/MSBuild.Bootstrap.Utils/MSBuild.Bootstrap.Utils.csproj
new file mode 100644
index 00000000000..7539d0dcedb
--- /dev/null
+++ b/src/MSBuild.Bootstrap.Utils/MSBuild.Bootstrap.Utils.csproj
@@ -0,0 +1,10 @@
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <TargetFramework>netstandard2.0</TargetFramework>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <PackageReference Include="Microsoft.Build.Utilities.Core" VersionOverride="15.5.180" ExcludeAssets="runtime" PrivateAssets="all" />
+  </ItemGroup>
+
+</Project>
\ No newline at end of file
diff --git a/src/MSBuild.Bootstrap.Utils/Tasks/InstallDotNetCoreTask.cs b/src/MSBuild.Bootstrap.Utils/Tasks/InstallDotNetCoreTask.cs
new file mode 100644
index 00000000000..0eda643f491
--- /dev/null
+++ b/src/MSBuild.Bootstrap.Utils/Tasks/InstallDotNetCoreTask.cs
@@ -0,0 +1,172 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.IO;
+using System.Net.Http;
+using System.Runtime.InteropServices;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+
+using AsyncTasks = System.Threading.Tasks;
+
+namespace MSBuild.Bootstrap.Utils.Tasks
+{
+    /// <summary>
+    /// This task is designed to automate the installation of .NET Core SDK.
+    /// It downloads the appropriate installation script and executes it to install the specified version of .NET Core SDK.
+    /// </summary>
+    public sealed class InstallDotNetCoreTask : ToolTask
+    {
+        private const string ScriptName = "dotnet-install";
+
+        /// <summary>
+        /// Initializes a new instance of the <see cref="InstallDotNetCoreTask"/> class.
+        /// </summary>
+        public InstallDotNetCoreTask()
+        {
+            InstallDir = string.Empty;
+            DotNetInstallScriptRootPath = string.Empty;
+            Version = string.Empty;
+        }
+
+        /// <summary>
+        /// Gets or sets the directory where the .NET Core SDK should be installed. This property is required.
+        /// </summary>
+        [Required]
+        public string InstallDir { get; set; }
+
+        /// <summary>
+        /// Gets or sets the root path where the .NET Core installation script is located. This property is required.
+        /// </summary>
+        [Required]
+        public string DotNetInstallScriptRootPath { get; set; }
+
+        /// <summary>
+        /// Gets or sets the version of the .NET Core SDK to be installed. This property is required.
+        /// </summary>
+        [Required]
+        public string Version { get; set; }
+
+        /// <summary>
+        /// Gets or sets the base URL for downloading the .NET Core installation script. The default value is "https://dot.net/v1/".
+        /// </summary>
+        public string DotNetInstallBaseUrl { get; set; } = "https://dot.net/v1/";
+
+        private bool IsWindows => RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
+
+        protected override string ToolName => IsWindows ? "powershell.exe" : "/bin/bash";
+
+        /// <summary>
+        /// Executes the task, downloading and running the .NET Core installation script.
+        /// </summary>
+        /// <returns>True if the task succeeded; otherwise, false.</returns>
+        public override bool Execute()
+        {
+            if (Directory.Exists(Path.Combine(InstallDir, "sdk", Version)))
+            {
+                // no need to download sdk again, it exists locally
+                return true;
+            }
+
+            ScriptExecutionSettings executionSettings = SetupScriptsExecutionSettings();
+            if (!File.Exists(executionSettings.ScriptsFullPath))
+            {
+                AsyncTasks.Task.Run(() => DownloadScriptAsync(executionSettings.ScriptName, executionSettings.ScriptsFullPath)).GetAwaiter().GetResult();
+            }
+
+            MakeScriptExecutable(executionSettings.ScriptsFullPath);
+
+            return RunScript(executionSettings);
+        }
+
+        protected override string GenerateFullPathToTool() => ToolName;
+
+        /// <summary>
+        /// Downloads the .NET Core installation script asynchronously from the specified URL.
+        /// </summary>
+        /// <param name="scriptName">The name of the script to download.</param>
+        /// <param name="scriptPath">The path where the script will be saved.</param>
+        private async AsyncTasks.Task DownloadScriptAsync(string scriptName, string scriptPath)
+        {
+            using (HttpClient client = new HttpClient())
+            {
+                HttpResponseMessage response = await client.GetAsync($"{DotNetInstallBaseUrl}{scriptName}").ConfigureAwait(false);
+                if (response.IsSuccessStatusCode)
+                {
+                    string scriptContent = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
+                    if (!string.IsNullOrEmpty(scriptContent))
+                    {
+                        File.WriteAllText(scriptPath, scriptContent);
+                    }
+                }
+                else
+                {
+                    Log.LogError($"Install-scripts download from {DotNetInstallBaseUrl} error. Status code: {response.StatusCode}.");
+                }
+            }
+        }
+
+        /// <summary>
+        /// Makes the installation script executable on non-Windows platforms.
+        /// </summary>
+        /// <param name="scriptPath">The path of the script to make executable.</param>
+        private void MakeScriptExecutable(string scriptPath)
+        {
+            if (!IsWindows)
+            {
+                int exitCode = ExecuteTool("/bin/chmod", string.Empty, $"+x {scriptPath}");
+                if (exitCode != 0)
+                {
+                    Log.LogError($"Install-scripts can not be made executable due to the errors reported above.");
+                }
+            }
+        }
+
+        /// <summary>
+        /// Runs the .NET Core installation script with the specified settings.
+        /// </summary>
+        /// <param name="executionSettings">The settings required for script execution.</param>
+        /// <returns>True if the script executed successfully; otherwise, false.</returns>
+        private bool RunScript(ScriptExecutionSettings executionSettings)
+        {
+            if (!Log.HasLoggedErrors)
+            {
+                int exitCode = ExecuteTool(ToolName, string.Empty, executionSettings.ExecutableArgs);
+
+                if (exitCode != 0)
+                {
+                    Log.LogError($"Install-scripts was not executed successfully.");
+                }
+            }
+
+            return !Log.HasLoggedErrors;
+        }
+
+        /// <summary>
+        /// Sets up the settings required for executing the .NET Core installation script.
+        /// </summary>
+        /// <returns>The settings required for script execution.</returns>
+        private ScriptExecutionSettings SetupScriptsExecutionSettings()
+        {
+            string scriptExtension = IsWindows ? "ps1" : "sh";
+            string scriptPath = Path.Combine(DotNetInstallScriptRootPath, $"{ScriptName}.{scriptExtension}");
+            string scriptArgs = IsWindows
+                ? $"-NoProfile -ExecutionPolicy Bypass -File {scriptPath} -Version {Version} -InstallDir {InstallDir}"
+                : $"{scriptPath} --version {Version} --install-dir {InstallDir}";
+
+            return new ScriptExecutionSettings($"{ScriptName}.{scriptExtension}", scriptPath, scriptArgs);
+        }
+
+        /// <summary>
+        /// A private struct to hold settings for script execution.
+        /// </summary>
+        private readonly struct ScriptExecutionSettings(string scriptName, string scriptsFullPath, string executableArgs)
+        {
+            public string ScriptName { get; } = scriptName;
+
+            public string ScriptsFullPath { get; } = scriptsFullPath;
+
+            public string ExecutableArgs { get; } = executableArgs;
+        }
+    }
+}
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index 8a2a558e452..1d116d117d2 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -50,4 +50,4 @@
 
   <Import Project="$(RepoRoot)eng\BootStrapMsBuild.targets" />
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/MSBuild.Bootstrap/RedirectNuGetConsoleProcess.After.Microsoft.Common.targets b/src/MSBuild.Bootstrap/RedirectNuGetConsoleProcess.After.Microsoft.Common.targets
deleted file mode 100644
index 3571d7e37f5..00000000000
--- a/src/MSBuild.Bootstrap/RedirectNuGetConsoleProcess.After.Microsoft.Common.targets
+++ /dev/null
@@ -1,23 +0,0 @@
-<Project>
-  <!-- The CoreCLR flavor of NuGet.Build.Tasks.Console.exe looks for dotnet under "..\..\dotnet", so we need to redirect it for the bootstrap to the currently executing dotnet.exe.
-       See: https://github.com/NuGet/NuGet.Client/blob/91f6fdb26b09e16c4520b1d13ee30bb38172a7bd/src/NuGet.Core/NuGet.Build.Tasks/StaticGraphRestoreTaskBase.cs#L240-L252 -->
-  <UsingTask
-    TaskName="GetCurrentProcessFileName"
-    TaskFactory="RoslynCodeTaskFactory"
-    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll" >
-    <ParameterGroup>
-      <CurrentProcessFileName ParameterType="System.String" Output="true" />
-    </ParameterGroup>
-    <Task>
-      <Using Namespace="System.Diagnostics" />
-      <Code Type="Fragment" Language="cs"><![CDATA[
-      CurrentProcessFileName = Process.GetCurrentProcess().MainModule.FileName;
-      ]]></Code>
-    </Task>
-  </UsingTask>
-  <Target Name="RedirectNuGetConsoleProcess" BeforeTargets="Restore">
-    <GetCurrentProcessFileName>
-      <Output TaskParameter="CurrentProcessFileName" PropertyName="NuGetConsoleProcessFileName" />
-    </GetCurrentProcessFileName>
-  </Target>
-</Project>
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index c33b4e8da98..6851120de48 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -899,10 +899,8 @@ public void SetConsoleUICulture()
         }
 
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void ConsoleUIRespectsSDKLanguage(bool enableFeature)
+        [Fact]
+        public void ConsoleUIRespectsSDKLanguage()
         {
             if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && !EncodingUtilities.CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding())
             {
@@ -923,18 +921,10 @@ public void ConsoleUIRespectsSDKLanguage(bool enableFeature)
             {
                 // Set the UI language based on the SDK environment var.
                 testEnvironment.SetEnvironmentVariable(DOTNET_CLI_UI_LANGUAGE, "ja"); // Japanese chose arbitrarily.
-                ChangeWaves.ResetStateForTests();
-                if (!enableFeature)
-                {
-                    testEnvironment.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_8.ToString());
-                }
                 MSBuildApp.SetConsoleUI();
 
-                Assert.Equal(enableFeature ? new CultureInfo("ja") : CultureInfo.CurrentUICulture.GetConsoleFallbackUICulture(), thisThread.CurrentUICulture);
-                if (enableFeature)
-                {
-                    Assert.Equal(65001, Console.OutputEncoding.CodePage); // UTF-8 enabled for correct rendering.
-                }
+                Assert.Equal(new CultureInfo("ja"), thisThread.CurrentUICulture);
+                Assert.Equal(65001, Console.OutputEncoding.CodePage); // UTF-8 enabled for correct rendering.
             }
             finally
             {
@@ -956,7 +946,6 @@ public void ConsoleUIRespectsSDKLanguage(bool enableFeature)
         /// We shouldn't change the UI culture if the current UI culture is invariant.
         /// In other cases, we can get an exception on CultureInfo creation when System.Globalization.Invariant enabled.
         /// </summary>
-
         [Fact]
         public void SetConsoleUICultureInInvariantCulture()
         {
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 3c2c494eec0..bfc061b5a1d 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -247,7 +247,6 @@ string[] args
 
             int exitCode;
             if (
-                ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) &&
                 Environment.GetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName) == "1" &&
                 !Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout &&
                 CanRunServerBasedOnCommandLineSwitches(
@@ -317,7 +316,7 @@ private static bool CanRunServerBasedOnCommandLineSwitches(
                     commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.NodeMode) ||
                     commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.Version] ||
                     FileUtilities.IsBinaryLogFilename(projectFile) ||
-                    ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]) == false ||
+                    !ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]) ||
                     IsInteractiveBuild(commandLineSwitches))
                 {
                     canRunServer = false;
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index 9bde8a4db14..e2ebdff4f85 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -56,14 +56,11 @@ public MSBuildLoadContext(string assemblyPath)
                 return null;
             }
 
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            // respect plugin.dll.json with the AssemblyDependencyResolver
+            string? assemblyPath = _resolver?.ResolveAssemblyToPath(assemblyName);
+            if (assemblyPath != null)
             {
-                // respect plugin.dll.json with the AssemblyDependencyResolver
-                string? assemblyPath = _resolver?.ResolveAssemblyToPath(assemblyName);
-                if (assemblyPath != null)
-                {
-                    return LoadFromAssemblyPath(assemblyPath);
-                }
+                return LoadFromAssemblyPath(assemblyPath);
             }
 
             // Fall back to the older MSBuild-on-Core behavior to continue to support
@@ -113,13 +110,10 @@ public MSBuildLoadContext(string assemblyPath)
 
         protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            string? libraryPath = _resolver?.ResolveUnmanagedDllToPath(unmanagedDllName);
+            if (libraryPath != null)
             {
-                string? libraryPath = _resolver?.ResolveUnmanagedDllToPath(unmanagedDllName);
-                if (libraryPath != null)
-                {
-                    return LoadUnmanagedDllFromPath(libraryPath);
-                }
+                return LoadUnmanagedDllFromPath(libraryPath);
             }
 
             return base.LoadUnmanagedDll(unmanagedDllName);
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 4595adaba62..187a7a43e4b 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -238,24 +238,10 @@ public void Translate(ITranslator translator)
                     TranslatePrimitiveTypeArray(translator);
                     break;
                 case TaskParameterType.ValueType:
-                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
-                    {
                         TranslateValueType(translator);
-                    }
-                    else
-                    {
-                        translator.TranslateDotNet(ref _wrappedParameter);
-                    }
                     break;
                 case TaskParameterType.ValueTypeArray:
-                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
-                    {
                         TranslateValueTypeArray(translator);
-                    }
-                    else
-                    {
-                        translator.TranslateDotNet(ref _wrappedParameter);
-                    }
                     break;
                 case TaskParameterType.ITaskItem:
                     TranslateITaskItem(translator);
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index f8cc28a2fa4..b8cf7e10aa4 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -1258,14 +1258,11 @@ private void ResolveReference(
             Reference reference)
         {
             bool isImmutableFrameworkReference = false;
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
+            // For a path to be an immutable reference, it must be externally resolved and has a FrameworkReferenceName defined.
+            if (assemblyName == null && !string.IsNullOrEmpty(rawFileNameCandidate) && reference.IsPrimary && reference.ExternallyResolved)
             {
-                // For a path to be an immutable reference, it must be externally resolved and has a FrameworkReferenceName defined.
-                if (assemblyName == null && !string.IsNullOrEmpty(rawFileNameCandidate) && reference.IsPrimary && reference.ExternallyResolved)
-                {
-                    string frameworkReferenceName = reference.PrimarySourceItem.GetMetadata(ItemMetadataNames.frameworkReferenceName);
-                    isImmutableFrameworkReference = !string.IsNullOrEmpty(frameworkReferenceName);
-                }
+                string frameworkReferenceName = reference.PrimarySourceItem.GetMetadata(ItemMetadataNames.frameworkReferenceName);
+                isImmutableFrameworkReference = !string.IsNullOrEmpty(frameworkReferenceName);
             }
 
             // Now, resolve this reference.
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index accb98d7438..c22ab73bc9f 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -2121,7 +2121,7 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
                     // If the public key in the file doesn't match the public key on disk, issue a build warning
                     // Skip this check if the public key attribute is "0", as this means we're expecting the public key
                     // comparison to be skipped at install time because the file is signed by an MS trusted cert.
-                    if (publicKeyAttribute.Value.Equals("0", StringComparison.OrdinalIgnoreCase) == false &&
+                    if (!publicKeyAttribute.Value.Equals("0", StringComparison.OrdinalIgnoreCase) &&
                         publicKey?.Equals(publicKeyAttribute.Value, StringComparison.OrdinalIgnoreCase) == false)
                     {
                         results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", PUBLICKEY_ATTRIBUTE, builder.Name, fileSource));
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index e6663e9b12e..bc2dc2279a9 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -287,8 +287,7 @@ private void LogAlwaysRetryDiagnosticFromResources(string messageResourceName, p
                 MakeFileWriteable(destinationFileState, true);
             }
 
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) &&
-                Traits.Instance.EscapeHatches.CopyWithoutDelete != true &&
+            if (!Traits.Instance.EscapeHatches.CopyWithoutDelete &&
                 destinationFileState.FileExists &&
                 !destinationFileState.IsReadOnly)
             {
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index 476c2b52ae6..e37a9bcf300 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -23,7 +23,9 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal static class CultureInfoCache
     {
+#if !NET5_0_OR_GREATER
         private static readonly Lazy<HashSet<string>> ValidCultureNames = new Lazy<HashSet<string>>(() => InitializeValidCultureNames());
+#endif
 
         // https://docs.microsoft.com/en-gb/windows/desktop/Intl/using-pseudo-locales-for-localization-testing
         // These pseudo-locales are available in versions of Windows from Vista and later.
@@ -62,22 +64,20 @@ private static HashSet<string> InitializeValidCultureNames()
         internal static bool IsValidCultureString(string name)
         {
 #if NET5_0_OR_GREATER
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            try
             {
-                try
-                {
-                    // GetCultureInfo throws if the culture doesn't exist
-                    CultureInfo.GetCultureInfo(name, predefinedOnly: true);
-                    return true;
-                }
-                catch
-                {
-                    // Second attempt: try pseudolocales (see above)
-                    return pseudoLocales.Contains(name, StringComparer.OrdinalIgnoreCase);
-                }
+                // GetCultureInfo throws if the culture doesn't exist
+                CultureInfo.GetCultureInfo(name, predefinedOnly: true);
+                return true;
             }
-#endif
+            catch
+            {
+                // Second attempt: try pseudolocales (see above)
+                return pseudoLocales.Contains(name, StringComparer.OrdinalIgnoreCase);
+            }
+#else
             return ValidCultureNames.Value.Contains(name);
+#endif
         }
 
 #if !FEATURE_CULTUREINFO_GETCULTURES
diff --git a/src/Tasks/Hash.cs b/src/Tasks/Hash.cs
index ea271573fd0..d1d6f8f7bc6 100644
--- a/src/Tasks/Hash.cs
+++ b/src/Tasks/Hash.cs
@@ -121,12 +121,7 @@ public override bool Execute()
 
         private HashAlgorithm CreateHashAlgorithm()
         {
-            return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) ?
-                SHA256.Create() :
-#pragma warning disable CA5350
-                // Kept for back compatibility reasons when chnange wave is opted-out
-                SHA1.Create();
-#pragma warning restore CA5350
+            return SHA256.Create();
         }
 
         /// <summary>
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index 8776175eddc..bc10cb1d02c 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -500,7 +500,7 @@ private void ReadTrustInfo(string xml)
             // Partial trust is not supported on .NET Core.
             // Fail if loaded manifest does not specify full-trust.
             // It can happen if manifest is manually modifed.
-            if (unrestrictedAttribute == null || (false == Boolean.Parse(unrestrictedAttribute.Value)))
+            if (unrestrictedAttribute == null || (!Boolean.Parse(unrestrictedAttribute.Value)))
             {
                 throw new ArgumentException("Partial trust is not supported.");
             }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 8bb06dd496f..de91092b31e 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -432,12 +432,6 @@
     <Content Include="Microsoft.Common.props">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
-    <!-- For .NET Core, Microsoft.Common.props needs to be in version subfolder for bootstrap build, but in MSBuild exe
-         path for some tests.  So include it twice. -->
-    <Content Include="Microsoft.Common.props" Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-      <Link>Current\Microsoft.Common.props</Link>
-    </Content>
     <Content Include="Microsoft.Common.tasks">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index 9850e8cc161..811dcdc42cc 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -48,7 +48,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <!-- Extract necessary information for SetPlatform negotiation -->
         <!-- This target does not run for cpp projects. -->
         <IsVcxOrNativeProj>false</IsVcxOrNativeProj>
-        <Platform Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))">$(Platform)</Platform>
+        <Platform>$(Platform)</Platform>
         <Platforms>$(Platforms)</Platforms>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index bc59d692a76..d881ab86b69 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1551,8 +1551,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
     -->
   <Target Name="IgnoreJavaScriptOutputAssembly"
-    BeforeTargets="AssignProjectConfiguration"
-    Condition="$([MSBuild]::AreFeaturesEnabled('17.8'))">
+    BeforeTargets="AssignProjectConfiguration">
       <ItemGroup>
         <ProjectReference Condition="'%(ProjectReference.Extension)' == '.esproj' and '%(ProjectReference.ReferenceOutputAssembly)' == ''">
           <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
@@ -1985,7 +1984,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <IsRidAgnostic>@(_TargetFrameworkInfo->'%(IsRidAgnostic)')</IsRidAgnostic>
         <!-- Extract necessary information for SetPlatform negotiation -->
         <IsVcxOrNativeProj Condition="'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'">true</IsVcxOrNativeProj>
-        <Platform Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))">$(Platform)</Platform>
+        <Platform>$(Platform)</Platform>
         <Platforms>$(Platforms)</Platforms>
         <!-- .vcxproj and .nativeproj contain a `ProjectConfiguration` item that have `Platform` metadata within.
              Build the `Platforms` property from that. -->
@@ -4553,7 +4552,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </_ClickOnceTransitiveContentItemsTemp>
       <_ClickOnceTransitiveContentItems Include="@(_ClickOnceTransitiveContentItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
 
-      <!-- 
+      <!--
         ClickOnce content items is union of transitive content items and content items from this project.
         We also exclude content items from this project that have set CopyToPublishDirectory to Never.
       -->
diff --git a/src/UnitTests.Shared/BootstrapLocationAttribute.cs b/src/UnitTests.Shared/BootstrapLocationAttribute.cs
index 7f8627a69b3..7dfeb62ce64 100644
--- a/src/UnitTests.Shared/BootstrapLocationAttribute.cs
+++ b/src/UnitTests.Shared/BootstrapLocationAttribute.cs
@@ -6,8 +6,9 @@
 namespace Microsoft.Build.UnitTests.Shared;
 
 [System.AttributeUsage(System.AttributeTargets.Assembly)]
-internal sealed class BootstrapLocationAttribute(string bootstrapMsbuildBinaryLocation)
-    : System.Attribute
+internal sealed class BootstrapLocationAttribute(string bootstrapMsBuildBinaryLocation, string bootstrapSdkVersion) : System.Attribute
 {
-    public string BootstrapMsbuildBinaryLocation { get; } = bootstrapMsbuildBinaryLocation;
+    public string BootstrapMsBuildBinaryLocation { get; } = bootstrapMsBuildBinaryLocation;
+
+    public string BootstrapSdkVersion { get; } = bootstrapSdkVersion;
 }
diff --git a/src/UnitTests.Shared/EnvironmentProvider.cs b/src/UnitTests.Shared/EnvironmentProvider.cs
index 4ca3c276867..c0a7fcaddc4 100644
--- a/src/UnitTests.Shared/EnvironmentProvider.cs
+++ b/src/UnitTests.Shared/EnvironmentProvider.cs
@@ -74,7 +74,7 @@ private IEnumerable<string> SearchPaths
             string? environmentOverride = _getEnvironmentVariable(Constants.DotnetMsbuildSdkResolverCliDir);
             if (!string.IsNullOrEmpty(environmentOverride))
             {
-                return Path.Combine(environmentOverride, Constants.DotNet + Constants.ExeSuffix);
+                return GetDotnetExePathFromFolder(environmentOverride);
             }
 
             string? dotnetExe = _getCurrentProcessPath();
@@ -105,6 +105,8 @@ private IEnumerable<string> SearchPaths
             return dotnetExe;
         }
 
+        public static string? GetDotnetExePathFromFolder(string? netRootFolder) => Path.Combine(netRootFolder ?? string.Empty, Constants.DotNet + Constants.ExeSuffix);
+
         public static string? GetDotnetExePath(Func<string, string?>? getEnvironmentVariable = null)
         {
             if (getEnvironmentVariable == null)
diff --git a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
index fee3abf670f..74fa38bee83 100644
--- a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
+++ b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
@@ -30,9 +30,18 @@
 
   <Import Project="..\..\eng\BootStrapMsBuild.props" />
 
+  <PropertyGroup Condition="$(TargetFramework.StartsWith('net4'))">
+    <TestBootstrapBinaryDestination>$(BootstrapDestination)Current\Bin</TestBootstrapBinaryDestination>
+  </PropertyGroup>
+
+  <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
+    <TestBootstrapBinaryDestination>$(ArtifactsBinDir)bootstrap\core</TestBootstrapBinaryDestination>
+  </PropertyGroup>
+
   <ItemGroup>
     <AssemblyAttribute Include="Microsoft.Build.UnitTests.Shared.BootstrapLocationAttribute">
-      <_Parameter1>$(BootstrapBinaryDestination)</_Parameter1>
+      <_Parameter1>$(TestBootstrapBinaryDestination)</_Parameter1>
+      <_Parameter2>$(BootstrapSdkVersion)</_Parameter2>
     </AssemblyAttribute>
   </ItemGroup>
 </Project>
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 8264bc07be9..4f76371d8b1 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -63,10 +63,10 @@ public static string ExecBootstrapedMSBuild(
             BootstrapLocationAttribute attribute = Assembly.GetExecutingAssembly().GetCustomAttribute<BootstrapLocationAttribute>()
                                                    ?? throw new InvalidOperationException("This test assembly does not have the BootstrapLocationAttribute");
 
-            string binaryFolder = attribute.BootstrapMsbuildBinaryLocation;
+            string binaryFolder = attribute.BootstrapMsBuildBinaryLocation;
 #if NET
-            string pathToExecutable = EnvironmentProvider.GetDotnetExePath()!;
-            msbuildParameters = Path.Combine(binaryFolder, "MSBuild.dll") + " " + msbuildParameters;
+            string pathToExecutable = EnvironmentProvider.GetDotnetExePathFromFolder(binaryFolder);
+            msbuildParameters = Path.Combine(binaryFolder, "sdk", attribute.BootstrapSdkVersion, "MSBuild.dll") + " " + msbuildParameters;
 #else
             string pathToExecutable = Path.Combine(binaryFolder, "MSBuild.exe");
 #endif
diff --git a/src/Utilities/LockCheck.cs b/src/Utilities/LockCheck.cs
index 186f627f28e..c2de1dfaa65 100644
--- a/src/Utilities/LockCheck.cs
+++ b/src/Utilities/LockCheck.cs
@@ -271,13 +271,10 @@ private static string GetLockedFileMessageWindows(string filePath)
 
             try
             {
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-                {
-                    var processes = GetProcessesLockingFile(filePath);
-                    message = !string.IsNullOrEmpty(processes)
-                        ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("LockCheck.FileLocked", processes)
-                        : String.Empty;
-                }
+                var processes = GetProcessesLockingFile(filePath);
+                message = !string.IsNullOrEmpty(processes)
+                    ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("LockCheck.FileLocked", processes)
+                    : String.Empty;
             }
             catch (Exception)
             {
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index a4f1f9295aa..20510c33d8b 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -2460,7 +2460,7 @@ private static IEnumerable<TargetPlatformSDK> RetrieveTargetPlatformList(string[
                     var monikers = new Dictionary<TargetPlatformSDK, TargetPlatformSDK>();
                     GatherSDKListFromDirectory(sdkDiskRoots, monikers);
 
-                    if (NativeMethodsShared.IsWindows && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                    if (NativeMethodsShared.IsWindows)
                     {
                         GatherSDKListFromRegistry(registryRoot, monikers);
                     }
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 2443ff50c43..fe6ab5d92ed 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -380,7 +380,7 @@ protected virtual void ProcessStarted() { }
         /// <returns>true, if successful</returns>
         protected internal virtual bool ValidateParameters()
         {
-            if (TaskProcessTerminationTimeout < -1 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+            if (TaskProcessTerminationTimeout < -1)
             {
                 Log.LogWarningWithCodeFromResources("ToolTask.InvalidTerminationTimeout", TaskProcessTerminationTimeout);
                 return false;
@@ -694,7 +694,7 @@ protected virtual ProcessStartInfo GetProcessStartInfo(
         /// <summary>
         /// We expect tasks to override this method if they need information about the tool process or its process events during task execution.
         /// Implementation should make sure that the task is started in this method.
-        /// Starts the process during task execution. 
+        /// Starts the process during task execution.
         /// </summary>
         /// <param name="proc">Fully populated <see cref="Process"/> instance representing the tool process to be started.</param>
         /// <returns>A started process. This could be <paramref name="proc"/> or another <see cref="Process"/> instance.</returns>
@@ -1000,7 +1000,7 @@ private void KillToolProcessOnTimeout(Process proc, bool isBeingCancelled)
                     LogShared.LogWarningWithCodeFromResources("Shared.KillingProcessByCancellation", processName);
                 }
 
-                int timeout = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && TaskProcessTerminationTimeout >= -1 ? TaskProcessTerminationTimeout : 5000;
+                int timeout = TaskProcessTerminationTimeout >= -1 ? TaskProcessTerminationTimeout : 5000;
                 string timeoutFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDTOOLTASKCANCELPROCESSWAITTIMEOUT");
                 if (timeoutFromEnvironment != null)
                 {
