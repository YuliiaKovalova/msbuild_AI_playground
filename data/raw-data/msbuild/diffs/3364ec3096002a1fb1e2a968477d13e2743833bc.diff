diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index 0abf86a2aa2..5cceeb22d66 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -7,7 +7,6 @@
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
-using System.IO.Pipes;
 using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Client;
@@ -75,19 +74,9 @@ public sealed class MSBuildClient
         private readonly string _pipeName;
 
         /// <summary>
-        /// The named pipe stream for client-server communication.
+        /// The named pipe client for client-server communication.
         /// </summary>
-        private NamedPipeClientStream _nodeStream = null!;
-
-        /// <summary>
-        /// A way to cache a byte array when writing out packets
-        /// </summary>
-        private readonly MemoryStream _packetMemoryStream;
-
-        /// <summary>
-        /// A binary writer to help write into <see cref="_packetMemoryStream"/>
-        /// </summary>
-        private readonly BinaryWriter _binaryWriter;
+        private NodePipeClient _pipeClient = null!;
 
         /// <summary>
         /// Used to estimate the size of the build with an ETW trace.
@@ -130,26 +119,14 @@ public MSBuildClient(
             // Client <-> Server communication stream
             _handshake = GetHandshake();
             _pipeName = OutOfProcServerNode.GetPipeName(_handshake);
-            _packetMemoryStream = new MemoryStream();
-            _binaryWriter = new BinaryWriter(_packetMemoryStream);
 
             CreateNodePipeStream();
         }
 
         private void CreateNodePipeStream()
         {
-#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-            _nodeStream = new NamedPipeClientStream(
-                serverName: ".",
-                _pipeName,
-                PipeDirection.InOut,
-                PipeOptions.Asynchronous
-#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-                | PipeOptions.CurrentUserOnly
-#endif
-            );
-#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-            _packetPump = new MSBuildClientPacketPump(_nodeStream);
+            _pipeClient = new NodePipeClient(_pipeName, _handshake);
+            _packetPump = new MSBuildClientPacketPump(_pipeClient);
         }
 
         /// <summary>
@@ -423,7 +400,7 @@ private bool TrySendPacket(Func<INodePacket> packetResolver)
             try
             {
                 packet = packetResolver();
-                WritePacket(_nodeStream, packet);
+                _pipeClient.WritePacket(packet);
                 CommunicationsUtilities.Trace("Command packet of type '{0}' sent...", packet.Type);
             }
             catch (Exception ex)
@@ -621,7 +598,7 @@ private bool TryConnectToServer(int timeoutMilliseconds)
                 tryAgain = false;
                 try
                 {
-                    NodeProviderOutOfProcBase.ConnectToPipeStream(_nodeStream, _pipeName, _handshake, Math.Max(1, timeoutMilliseconds - (int)sw.ElapsedMilliseconds));
+                    _pipeClient.ConnectToServer(Math.Max(1, timeoutMilliseconds - (int)sw.ElapsedMilliseconds));
                 }
                 catch (Exception ex)
                 {
@@ -644,30 +621,5 @@ private bool TryConnectToServer(int timeoutMilliseconds)
 
             return true;
         }
-
-        private void WritePacket(Stream nodeStream, INodePacket packet)
-        {
-            MemoryStream memoryStream = _packetMemoryStream;
-            memoryStream.SetLength(0);
-
-            ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(memoryStream);
-
-            // Write header
-            memoryStream.WriteByte((byte)packet.Type);
-
-            // Pad for packet length
-            _binaryWriter.Write(0);
-
-            // Reset the position in the write buffer.
-            packet.Translate(writeTranslator);
-
-            int packetStreamLength = (int)memoryStream.Position;
-
-            // Now write in the actual packet length
-            memoryStream.Position = 1;
-            _binaryWriter.Write(packetStreamLength - 5);
-
-            nodeStream.Write(memoryStream.GetBuffer(), 0, packetStreamLength);
-        }
     }
 }
diff --git a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
index 65a7b72a4dd..34ec9d28df1 100644
--- a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
+++ b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
@@ -2,15 +2,11 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Buffers.Binary;
 using System.Collections.Concurrent;
-using System.IO;
 using System.Threading;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-#if !FEATURE_APM
 using System.Threading.Tasks;
-#endif
 
 namespace Microsoft.Build.BackEnd.Client
 {
@@ -46,25 +42,15 @@ internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketF
         /// </summary>
         private readonly NodePacketFactory _packetFactory;
 
-        /// <summary>
-        /// The memory stream for a read buffer.
-        /// </summary>
-        private readonly MemoryStream _readBufferMemoryStream;
-
         /// <summary>
         /// The thread which runs the asynchronous packet pump
         /// </summary>
         private Thread? _packetPumpThread;
 
         /// <summary>
-        /// The stream from where to read packets.
-        /// </summary>
-        private readonly Stream _stream;
-
-        /// <summary>
-        /// The binary translator for reading packets.
+        /// The pipe client from where to read packets.
         /// </summary>
-        private readonly ITranslator _binaryReadTranslator;
+        private readonly NodePipeClient _pipeClient;
 
         /// <summary>
         /// True if this side is gracefully disconnecting.
@@ -73,11 +59,12 @@ internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketF
         /// </summary>
         private bool _isServerDisconnecting;
 
-        public MSBuildClientPacketPump(Stream stream)
+        public MSBuildClientPacketPump(NodePipeClient pipeClient)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(stream);
+            ErrorUtilities.VerifyThrowArgumentNull(pipeClient);
 
-            _stream = stream;
+            _pipeClient = pipeClient;
+            _pipeClient.RegisterPacketFactory(this);
             _isServerDisconnecting = false;
             _packetFactory = new NodePacketFactory();
 
@@ -85,9 +72,6 @@ public MSBuildClientPacketPump(Stream stream)
             PacketReceivedEvent = new AutoResetEvent(false);
             PacketPumpCompleted = new ManualResetEvent(false);
             _packetPumpShutdownEvent = new ManualResetEvent(false);
-
-            _readBufferMemoryStream = new MemoryStream();
-            _binaryReadTranslator = BinaryTranslator.GetReadTranslator(_readBufferMemoryStream, InterningBinaryReader.CreateSharedBuffer());
         }
 
         #region INodePacketFactory Members
@@ -113,14 +97,13 @@ public void UnregisterPacketHandler(NodePacketType packetType)
         }
 
         /// <summary>
-        /// Deserializes and routes a packer to the appropriate handler.
+        /// Deserializes a packet.
         /// </summary>
-        /// <param name="nodeId">The node from which the packet was received.</param>
         /// <param name="packetType">The packet type.</param>
         /// <param name="translator">The translator to use as a source for packet data.</param>
-        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
         {
-            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
+            return _packetFactory.DeserializePacket(packetType, translator);
         }
 
         /// <summary>
@@ -182,21 +165,16 @@ public void Stop()
         /// </remarks>
         private void PacketPumpProc()
         {
-            RunReadLoop(_stream, _packetPumpShutdownEvent);
+            RunReadLoop(_pipeClient, _packetPumpShutdownEvent);
         }
 
-        private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShutdownEvent)
+        private void RunReadLoop(NodePipeClient pipeClient, ManualResetEvent localPacketPumpShutdownEvent)
         {
             CommunicationsUtilities.Trace("Entering read loop.");
 
             try
             {
-                byte[] headerByte = new byte[5];
-#if FEATURE_APM
-                IAsyncResult result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);
-#else
-                Task<int> readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);
-#endif
+                Task<INodePacket> readTask = pipeClient.ReadPacketAsync();
 
                 bool continueReading = true;
                 do
@@ -208,11 +186,7 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
                     WaitHandle[] handles =
                     [
                         localPacketPumpShutdownEvent,
-#if FEATURE_APM
-                        result.AsyncWaitHandle
-#else
                         ((IAsyncResult)readTask).AsyncWaitHandle
-#endif
                     ];
                     int waitId = WaitHandle.WaitAny(handles);
                     switch (waitId)
@@ -224,80 +198,27 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
                             break;
 
                         case 1:
+                            INodePacket packet = readTask.GetAwaiter().GetResult();
+
+                            if (packet.Type == NodePacketType.NodeShutdown)
                             {
-                                // Client recieved a packet header. Read the rest of it.
-                                int headerBytesRead = 0;
-#if FEATURE_APM
-                                headerBytesRead = localStream.EndRead(result);
-#else
-                                headerBytesRead = readTask.Result;
-#endif
-
-                                if ((headerBytesRead != headerByte.Length) && !localPacketPumpShutdownEvent.WaitOne(0))
+                                if (!_isServerDisconnecting)
                                 {
-                                    // Incomplete read. Abort.
-                                    if (headerBytesRead == 0)
-                                    {
-                                        if (_isServerDisconnecting)
-                                        {
-                                            continueReading = false;
-                                            break;
-                                        }
-
-                                        ErrorUtilities.ThrowInternalError("Server disconnected abruptly");
-                                    }
-                                    else
-                                    {
-                                        ErrorUtilities.ThrowInternalError("Incomplete header read.  {0} of {1} bytes read", headerBytesRead, headerByte.Length);
-                                    }
+                                    ErrorUtilities.ThrowInternalError("Server disconnected abruptly.");
                                 }
 
-                                NodePacketType packetType = (NodePacketType)Enum.ToObject(typeof(NodePacketType), headerByte[0]);
-
-                                int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(headerByte, 1, 4));
-                                int packetBytesRead = 0;
-
-                                _readBufferMemoryStream.Position = 0;
-                                _readBufferMemoryStream.SetLength(packetLength);
-                                byte[] packetData = _readBufferMemoryStream.GetBuffer();
-
-                                while (packetBytesRead < packetLength)
-                                {
-                                    int bytesRead = localStream.Read(packetData, packetBytesRead, packetLength - packetBytesRead);
-                                    if (bytesRead == 0)
-                                    {
-                                        // Incomplete read.  Abort.
-                                        ErrorUtilities.ThrowInternalError("Incomplete packet read. {0} of {1} bytes read", packetBytesRead, packetLength);
-                                    }
-
-                                    packetBytesRead += bytesRead;
-                                }
+                                continueReading = false;
+                                break;
+                            }
 
-                                try
-                                {
-                                    _packetFactory.DeserializeAndRoutePacket(0, packetType, _binaryReadTranslator);
-                                }
-                                catch
-                                {
-                                    // Error while deserializing or handling packet. Logging additional info.
-                                    CommunicationsUtilities.Trace("Packet factory failed to receive package. Exception while deserializing packet {0}.", packetType);
-                                    throw;
-                                }
+                            _packetFactory.RoutePacket(0, packet);
 
-                                if (packetType == NodePacketType.ServerNodeBuildResult)
-                                {
-                                    continueReading = false;
-                                }
-                                else
-                                {
-                                    // Start reading the next package header.
-#if FEATURE_APM
-                                    result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);
-#else
-                                    readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);
-#endif
-                                }
+                            continueReading = packet.Type != NodePacketType.ServerNodeBuildResult;
+                            if (continueReading)
+                            {
+                                readTask = pipeClient.ReadPacketAsync();
                             }
+
                             break;
 
                         default:
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index c506179bcd6..1f69d1b6699 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -1,32 +1,22 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#nullable disable
+
 using System;
-using System.Buffers.Binary;
-using System.Collections.Generic;
 using System.Collections.Concurrent;
+using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
-using System.IO.Pipes;
 using System.Diagnostics;
 using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
-#if FEATURE_PIPE_SECURITY
-using System.Security.Principal;
-#endif
-
-#if FEATURE_APM
-using Microsoft.Build.Eventing;
-#endif
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Task = System.Threading.Tasks.Task;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd.Logging;
 
-#nullable disable
-
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
@@ -35,11 +25,6 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal abstract class NodeProviderOutOfProcBase
     {
-        /// <summary>
-        /// The maximum number of bytes to write
-        /// </summary>
-        private const int MaxPacketWriteSize = 1048576;
-
         /// <summary>
         /// The number of times to retry creating an out-of-proc node.
         /// </summary>
@@ -55,9 +40,6 @@ internal abstract class NodeProviderOutOfProcBase
         /// </summary>
         private const int TimeoutForWaitForExit = 30000;
 
-#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-        private static readonly WindowsIdentity s_currentWindowsIdentity = WindowsIdentity.GetCurrent();
-#endif
         /// <summary>
         /// The build component host.
         /// </summary>
@@ -163,21 +145,18 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
                 int timeout = 30;
 
                 // Attempt to connect to the process with the handshake without low priority.
-                Stream nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, false));
+                NodePipeClient pipeClient = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, false));
 
-                if (nodeStream == null)
-                {
-                    // If we couldn't connect attempt to connect to the process with the handshake including low priority.
-                    nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, true));
-                }
+                // If we couldn't connect attempt to connect to the process with the handshake including low priority.
+                pipeClient ??= TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, true));
 
-                if (nodeStream != null)
+                if (pipeClient != null)
                 {
                     // If we're able to connect to such a process, send a packet requesting its termination
                     CommunicationsUtilities.Trace("Shutting down node with pid = {0}", nodeProcess.Id);
-                    NodeContext nodeContext = new NodeContext(0, nodeProcess, nodeStream, factory, terminateNode);
+                    NodeContext nodeContext = new(0, nodeProcess, pipeClient, factory, terminateNode);
                     nodeContext.SendData(new NodeBuildComplete(false /* no node reuse */));
-                    nodeStream.Dispose();
+                    pipeClient.Dispose();
                 }
             }
         }
@@ -284,8 +263,8 @@ bool TryReuseAnyFromPossibleRunningNodes(int currentProcessId, int nodeId)
                     _processesToIgnore.TryAdd(nodeLookupKey, default);
 
                     // Attempt to connect to each process in turn.
-                    Stream nodeStream = TryConnectToProcess(nodeToReuse.Id, 0 /* poll, don't wait for connections */, hostHandshake);
-                    if (nodeStream != null)
+                    NodePipeClient pipeClient = TryConnectToProcess(nodeToReuse.Id, 0 /* poll, don't wait for connections */, hostHandshake);
+                    if (pipeClient != null)
                     {
                         // Connection successful, use this node.
                         CommunicationsUtilities.Trace("Successfully connected to existed node {0} which is PID {1}", nodeId, nodeToReuse.Id);
@@ -295,7 +274,7 @@ bool TryReuseAnyFromPossibleRunningNodes(int currentProcessId, int nodeId)
                             BuildEventContext = new BuildEventContext(nodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId)
                         });
 
-                        CreateNodeContext(nodeId, nodeToReuse, nodeStream);
+                        CreateNodeContext(nodeId, nodeToReuse, pipeClient);
                         return true;
                     }
                 }
@@ -344,13 +323,13 @@ bool StartNewNode(int nodeId)
                     // to the debugger process. Instead, use MSBUILDDEBUGONSTART=1
 
                     // Now try to connect to it.
-                    Stream nodeStream = TryConnectToProcess(msbuildProcess.Id, TimeoutForNewNodeCreation, hostHandshake);
-                    if (nodeStream != null)
+                    NodePipeClient pipeClient = TryConnectToProcess(msbuildProcess.Id, TimeoutForNewNodeCreation, hostHandshake);
+                    if (pipeClient != null)
                     {
                         // Connection successful, use this node.
                         CommunicationsUtilities.Trace("Successfully connected to created node {0} which is PID {1}", nodeId, msbuildProcess.Id);
 
-                        CreateNodeContext(nodeId, msbuildProcess, nodeStream);
+                        CreateNodeContext(nodeId, msbuildProcess, pipeClient);
                         return true;
                     }
 
@@ -379,9 +358,9 @@ bool StartNewNode(int nodeId)
                 return false;
             }
 
-            void CreateNodeContext(int nodeId, Process nodeToReuse, Stream nodeStream)
+            void CreateNodeContext(int nodeId, Process nodeToReuse, NodePipeClient pipeClient)
             {
-                NodeContext nodeContext = new(nodeId, nodeToReuse, nodeStream, factory, terminateNode);
+                NodeContext nodeContext = new(nodeId, nodeToReuse, pipeClient, factory, terminateNode);
                 nodeContexts.Enqueue(nodeContext);
                 createNode(nodeContext);
             }
@@ -419,52 +398,22 @@ private string GetProcessesToIgnoreKey(Handshake hostHandshake, int nodeProcessI
             return hostHandshake.ToString() + "|" + nodeProcessId.ToString(CultureInfo.InvariantCulture);
         }
 
-#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-        // This code needs to be in a separate method so that we don't try (and fail) to load the Windows-only APIs when JIT-ing the code
-        //  on non-Windows operating systems
-        private static void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStream)
-        {
-            SecurityIdentifier identifier = s_currentWindowsIdentity.Owner;
-#if FEATURE_PIPE_SECURITY
-            PipeSecurity remoteSecurity = nodeStream.GetAccessControl();
-#else
-            var remoteSecurity = new PipeSecurity(nodeStream.SafePipeHandle, System.Security.AccessControl.AccessControlSections.Access |
-                System.Security.AccessControl.AccessControlSections.Owner | System.Security.AccessControl.AccessControlSections.Group);
-#endif
-            IdentityReference remoteOwner = remoteSecurity.GetOwner(typeof(SecurityIdentifier));
-            if (remoteOwner != identifier)
-            {
-                CommunicationsUtilities.Trace("The remote pipe owner {0} does not match {1}", remoteOwner.Value, identifier.Value);
-                throw new UnauthorizedAccessException();
-            }
-        }
-#endif
-
         /// <summary>
         /// Attempts to connect to the specified process.
         /// </summary>
-        private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake handshake)
+        private NodePipeClient TryConnectToProcess(int nodeProcessId, int timeout, Handshake handshake)
         {
             // Try and connect to the process.
             string pipeName = NamedPipeUtil.GetPlatformSpecificPipeName(nodeProcessId);
 
-#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-            NamedPipeClientStream nodeStream = new NamedPipeClientStream(
-                serverName: ".",
-                pipeName,
-                PipeDirection.InOut,
-                PipeOptions.Asynchronous
-#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-                | PipeOptions.CurrentUserOnly
-#endif
-            );
-#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-            CommunicationsUtilities.Trace("Attempting connect to PID {0} with pipe {1} with timeout {2} ms", nodeProcessId, pipeName, timeout);
+            NodePipeClient pipeClient = new(pipeName, handshake);
+
+            CommunicationsUtilities.Trace("Attempting connect to PID {0}", nodeProcessId);
 
             try
             {
-                ConnectToPipeStream(nodeStream, pipeName, handshake, timeout);
-                return nodeStream;
+                pipeClient.ConnectToServer(timeout);
+                return pipeClient;
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
@@ -476,56 +425,12 @@ private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake han
                 CommunicationsUtilities.Trace("Failed to connect to pipe {0}. {1}", pipeName, e.Message.TrimEnd());
 
                 // If we don't close any stream, we might hang up the child
-                nodeStream?.Dispose();
+                pipeClient?.Dispose();
             }
 
             return null;
         }
 
-        /// <summary>
-        /// Connect to named pipe stream and ensure validate handshake and security.
-        /// </summary>
-        /// <remarks>
-        /// Reused by MSBuild server client <see cref="Microsoft.Build.Experimental.MSBuildClient"/>.
-        /// </remarks>
-        internal static void ConnectToPipeStream(NamedPipeClientStream nodeStream, string pipeName, Handshake handshake, int timeout)
-        {
-            nodeStream.Connect(timeout);
-
-#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-            if (NativeMethodsShared.IsWindows)
-            {
-                // Verify that the owner of the pipe is us.  This prevents a security hole where a remote node has
-                // been faked up with ACLs that would let us attach to it.  It could then issue fake build requests back to
-                // us, potentially causing us to execute builds that do harmful or unexpected things.  The pipe owner can
-                // only be set to the user's own SID by a normal, unprivileged process.  The conditions where a faked up
-                // remote node could set the owner to something else would also let it change owners on other objects, so
-                // this would be a security flaw upstream of us.
-                ValidateRemotePipeSecurityOnWindows(nodeStream);
-            }
-#endif
-
-            int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
-            for (int i = 0; i < handshakeComponents.Length; i++)
-            {
-                CommunicationsUtilities.Trace("Writing handshake part {0} ({1}) to pipe {2}", i, handshakeComponents[i], pipeName);
-                nodeStream.WriteIntForHandshake(handshakeComponents[i]);
-            }
-
-            // This indicates that we have finished all the parts of our handshake; hopefully the endpoint has as well.
-            nodeStream.WriteEndOfHandshakeSignal();
-
-            CommunicationsUtilities.Trace("Reading handshake from pipe {0}", pipeName);
-
-#if NETCOREAPP2_1_OR_GREATER
-            nodeStream.ReadEndOfHandshakeSignal(true, timeout);
-#else
-            nodeStream.ReadEndOfHandshakeSignal(true);
-#endif
-            // We got a connection.
-            CommunicationsUtilities.Trace("Successfully connected to pipe {0}...!", pipeName);
-        }
-
         /// <summary>
         /// Class which wraps up the communications infrastructure for a given node.
         /// </summary>
@@ -538,14 +443,13 @@ private enum ExitPacketState
                 ExitPacketSent
             }
 
-            // The pipe(s) used to communicate with the node.
-            private Stream _clientToServerStream;
-            private Stream _serverToClientStream;
+            // The pipe client used to communicate with the node.
+            private readonly NodePipeClient _pipeClient;
 
             /// <summary>
             /// The factory used to create packets from data read off the pipe.
             /// </summary>
-            private INodePacketFactory _packetFactory;
+            private readonly INodePacketFactory _packetFactory;
 
             /// <summary>
             /// The node id assigned by the node provider.
@@ -559,23 +463,6 @@ private enum ExitPacketState
 
             internal Process Process { get { return _process; } }
 
-            /// <summary>
-            /// An array used to store the header byte for each packet when read.
-            /// </summary>
-            private byte[] _headerByte;
-
-            /// <summary>
-            /// A buffer typically big enough to handle a packet body.
-            /// We use this as a convenient way to manage and cache a byte[] that's resized
-            /// automatically to fit our payload.
-            /// </summary>
-            private MemoryStream _readBufferMemoryStream;
-
-            /// <summary>
-            /// A reusable buffer for writing packets.
-            /// </summary>
-            private MemoryStream _writeBufferMemoryStream;
-
             /// <summary>
             /// A queue used for enqueuing packets to write to the stream asynchronously.
             /// </summary>
@@ -598,28 +485,19 @@ private enum ExitPacketState
             /// </summary>
             private ExitPacketState _exitPacketState;
 
-            /// <summary>
-            /// Per node read buffers
-            /// </summary>
-            private BinaryReaderFactory _binaryReaderFactory;
-
             /// <summary>
             /// Constructor.
             /// </summary>
             public NodeContext(int nodeId, Process process,
-                Stream nodePipe,
+                NodePipeClient pipeClient,
                 INodePacketFactory factory, NodeContextTerminateDelegate terminateDelegate)
             {
                 _nodeId = nodeId;
                 _process = process;
-                _clientToServerStream = nodePipe;
-                _serverToClientStream = nodePipe;
+                _pipeClient = pipeClient;
+                _pipeClient.RegisterPacketFactory(factory);
                 _packetFactory = factory;
-                _headerByte = new byte[5]; // 1 for the packet type, 4 for the body length
-                _readBufferMemoryStream = new MemoryStream();
-                _writeBufferMemoryStream = new MemoryStream();
                 _terminateDelegate = terminateDelegate;
-                _binaryReaderFactory = InterningBinaryReader.CreateSharedBuffer();
             }
 
             /// <summary>
@@ -632,73 +510,49 @@ public NodeContext(int nodeId, Process process,
             /// </summary>
             public void BeginAsyncPacketRead()
             {
-#if FEATURE_APM
-                _clientToServerStream.BeginRead(_headerByte, 0, _headerByte.Length, HeaderReadComplete, this);
-#else
-                ThreadPool.QueueUserWorkItem(delegate
-                {
-                    var ignored = RunPacketReadLoopAsync();
-                });
-#endif
+                _ = ThreadPool.QueueUserWorkItem(_ => _ = RunPacketReadLoopAsync());
             }
 
-#if !FEATURE_APM
             public async Task RunPacketReadLoopAsync()
             {
-                while (true)
+                INodePacket packet = null;
+
+                while (packet?.Type != NodePacketType.NodeShutdown)
                 {
                     try
                     {
-                        int bytesRead = await CommunicationsUtilities.ReadAsync(_clientToServerStream, _headerByte, _headerByte.Length);
-                        if (!ProcessHeaderBytesRead(bytesRead))
-                        {
-                            return;
-                        }
+                        packet = await _pipeClient.ReadPacketAsync().ConfigureAwait(false);
                     }
                     catch (IOException e)
                     {
-                        CommunicationsUtilities.Trace(_nodeId, "EXCEPTION in RunPacketReadLoopAsync: {0}", e);
-                        _packetFactory.RoutePacket(_nodeId, new NodeShutdown(NodeShutdownReason.ConnectionFailed));
-                        Close();
-                        return;
+                        CommunicationsUtilities.Trace(_nodeId, "COMMUNICATIONS ERROR (HRC) Node: {0} Process: {1} Exception: {2}", _nodeId, _process.Id, e.Message);
+                        packet = new NodeShutdown(NodeShutdownReason.ConnectionFailed);
                     }
 
-                    NodePacketType packetType = (NodePacketType)_headerByte[0];
-                    int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(_headerByte, 1, 4));
-
-                    _readBufferMemoryStream.SetLength(packetLength);
-                    byte[] packetData = _readBufferMemoryStream.GetBuffer();
-
-                    try
+                    if (packet.Type == NodePacketType.NodeShutdown && (packet as NodeShutdown).Reason == NodeShutdownReason.ConnectionFailed)
                     {
-                        int bytesRead = await CommunicationsUtilities.ReadAsync(_clientToServerStream, packetData, packetLength);
-                        if (!ProcessBodyBytesRead(bytesRead, packetLength, packetType))
+                        try
                         {
-                            return;
+                            if (_process.HasExited)
+                            {
+                                CommunicationsUtilities.Trace(_nodeId, "   Child Process {0} has exited.", _process.Id);
+                            }
+                            else
+                            {
+                                CommunicationsUtilities.Trace(_nodeId, "   Child Process {0} is still running.", _process.Id);
+                            }
+                        }
+                        catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
+                        {
+                            CommunicationsUtilities.Trace(_nodeId, "Unable to retrieve remote process information. {0}", e);
                         }
-                    }
-                    catch (IOException e)
-                    {
-                        CommunicationsUtilities.Trace(_nodeId, "EXCEPTION in RunPacketReadLoopAsync (Reading): {0}", e);
-                        _packetFactory.RoutePacket(_nodeId, new NodeShutdown(NodeShutdownReason.ConnectionFailed));
-                        Close();
-                        return;
-                    }
-
-                    // Read and route the packet.
-                    if (!ReadAndRoutePacket(packetType, packetData, packetLength))
-                    {
-                        return;
                     }
 
-                    if (packetType == NodePacketType.NodeShutdown)
-                    {
-                        Close();
-                        return;
-                    }
+                    _packetFactory.RoutePacket(_nodeId, packet);
                 }
+
+                Close();
             }
-#endif
 
             /// <summary>
             /// Sends the specified packet to this node asynchronously.
@@ -744,37 +598,11 @@ private void DrainPacketQueue()
                     static async Task SendDataCoreAsync(Task _, object state)
                     {
                         NodeContext context = (NodeContext)state;
-                        while (context._packetWriteQueue.TryDequeue(out var packet))
+                        while (context._packetWriteQueue.TryDequeue(out INodePacket packet))
                         {
-                            MemoryStream writeStream = context._writeBufferMemoryStream;
-
-                            // clear the buffer but keep the underlying capacity to avoid reallocations
-                            writeStream.SetLength(0);
-
-                            ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(writeStream);
                             try
                             {
-                                writeStream.WriteByte((byte)packet.Type);
-
-                                // Pad for the packet length
-                                WriteInt32(writeStream, 0);
-                                packet.Translate(writeTranslator);
-
-                                int writeStreamLength = (int)writeStream.Position;
-
-                                // Now plug in the real packet length
-                                writeStream.Position = 1;
-                                WriteInt32(writeStream, writeStreamLength - 5);
-
-                                byte[] writeStreamBuffer = writeStream.GetBuffer();
-
-                                for (int i = 0; i < writeStreamLength; i += MaxPacketWriteSize)
-                                {
-                                    int lengthToWrite = Math.Min(writeStreamLength - i, MaxPacketWriteSize);
-#pragma warning disable CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
-                                    await context._serverToClientStream.WriteAsync(writeStreamBuffer, i, lengthToWrite, CancellationToken.None);
-#pragma warning restore CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
-                                }
+                                await context._pipeClient.WritePacketAsync(packet).ConfigureAwait(false);
 
                                 if (IsExitPacket(packet))
                                 {
@@ -800,27 +628,12 @@ private static bool IsExitPacket(INodePacket packet)
                 return packet is NodeBuildComplete buildCompletePacket && !buildCompletePacket.PrepareForReuse;
             }
 
-            /// <summary>
-            /// Avoid having a BinaryWriter just to write a 4-byte int
-            /// </summary>
-            private static void WriteInt32(MemoryStream stream, int value)
-            {
-                stream.WriteByte((byte)value);
-                stream.WriteByte((byte)(value >> 8));
-                stream.WriteByte((byte)(value >> 16));
-                stream.WriteByte((byte)(value >> 24));
-            }
-
             /// <summary>
             /// Closes the node's context, disconnecting it from the node.
             /// </summary>
             private void Close()
             {
-                _clientToServerStream.Dispose();
-                if (!object.ReferenceEquals(_clientToServerStream, _serverToClientStream))
-                {
-                    _serverToClientStream.Dispose();
-                }
+                _pipeClient.Dispose();
                 _terminateDelegate(_nodeId);
             }
 
@@ -869,191 +682,6 @@ public async Task WaitForExitAsync(ILoggingService loggingService)
 
                 _process.KillTree(timeoutMilliseconds: 5000);
             }
-
-#if FEATURE_APM
-            /// <summary>
-            /// Completes the asynchronous packet write to the node.
-            /// </summary>
-            private void PacketWriteComplete(IAsyncResult result)
-            {
-                try
-                {
-                    _serverToClientStream.EndWrite(result);
-                }
-                catch (IOException)
-                {
-                    // Do nothing here because any exception will be caught by the async read handler
-                }
-            }
-#endif
-
-            private bool ProcessHeaderBytesRead(int bytesRead)
-            {
-                if (bytesRead != _headerByte.Length)
-                {
-                    CommunicationsUtilities.Trace(_nodeId, "COMMUNICATIONS ERROR (HRC) Node: {0} Process: {1} Bytes Read: {2} Expected: {3}", _nodeId, _process.Id, bytesRead, _headerByte.Length);
-                    try
-                    {
-                        if (_process.HasExited)
-                        {
-                            CommunicationsUtilities.Trace(_nodeId, "   Child Process {0} has exited.", _process.Id);
-                        }
-                        else
-                        {
-                            CommunicationsUtilities.Trace(_nodeId, "   Child Process {0} is still running.", _process.Id);
-                        }
-                    }
-                    catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
-                    {
-                        CommunicationsUtilities.Trace(_nodeId, "Unable to retrieve remote process information. {0}", e);
-                    }
-
-                    _packetFactory.RoutePacket(_nodeId, new NodeShutdown(NodeShutdownReason.ConnectionFailed));
-                    Close();
-                    return false;
-                }
-
-                return true;
-            }
-
-#if FEATURE_APM
-            /// <summary>
-            /// Callback invoked by the completion of a read of a header byte on one of the named pipes.
-            /// </summary>
-            private void HeaderReadComplete(IAsyncResult result)
-            {
-                int bytesRead;
-                try
-                {
-                    try
-                    {
-                        bytesRead = _clientToServerStream.EndRead(result);
-                    }
-
-                    // Workaround for CLR stress bug; it sporadically calls us twice on the same async
-                    // result, and EndRead will throw on the second one. Pretend the second one never happened.
-                    catch (ArgumentException)
-                    {
-                        CommunicationsUtilities.Trace(_nodeId, "Hit CLR bug #825607: called back twice on same async result; ignoring");
-                        return;
-                    }
-
-                    if (!ProcessHeaderBytesRead(bytesRead))
-                    {
-                        return;
-                    }
-                }
-                catch (IOException e)
-                {
-                    CommunicationsUtilities.Trace(_nodeId, "EXCEPTION in HeaderReadComplete: {0}", e);
-                    _packetFactory.RoutePacket(_nodeId, new NodeShutdown(NodeShutdownReason.ConnectionFailed));
-                    Close();
-                    return;
-                }
-
-                int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(_headerByte, 1, 4));
-                MSBuildEventSource.Log.PacketReadSize(packetLength);
-
-                // Ensures the buffer is at least this length.
-                // It avoids reallocations if the buffer is already large enough.
-                _readBufferMemoryStream.SetLength(packetLength);
-                byte[] packetData = _readBufferMemoryStream.GetBuffer();
-
-                _clientToServerStream.BeginRead(packetData, 0, packetLength, BodyReadComplete, new Tuple<byte[], int>(packetData, packetLength));
-            }
-#endif
-
-            private bool ProcessBodyBytesRead(int bytesRead, int packetLength, NodePacketType packetType)
-            {
-                if (bytesRead != packetLength)
-                {
-                    CommunicationsUtilities.Trace(_nodeId, "Bad packet read for packet {0} - Expected {1} bytes, got {2}", packetType, packetLength, bytesRead);
-                    _packetFactory.RoutePacket(_nodeId, new NodeShutdown(NodeShutdownReason.ConnectionFailed));
-                    Close();
-                    return false;
-                }
-                return true;
-            }
-
-            private bool ReadAndRoutePacket(NodePacketType packetType, byte[] packetData, int packetLength)
-            {
-                try
-                {
-                    // The buffer is publicly visible so that InterningBinaryReader doesn't have to copy to an intermediate buffer.
-                    // Since the buffer is publicly visible dispose right away to discourage outsiders from holding a reference to it.
-                    using (var packetStream = new MemoryStream(packetData, 0, packetLength, /*writeable*/ false, /*bufferIsPubliclyVisible*/ true))
-                    {
-                        ITranslator readTranslator = BinaryTranslator.GetReadTranslator(packetStream, _binaryReaderFactory);
-                        _packetFactory.DeserializeAndRoutePacket(_nodeId, packetType, readTranslator);
-                    }
-                }
-                catch (IOException e)
-                {
-                    CommunicationsUtilities.Trace(_nodeId, "EXCEPTION in ReadAndRoutPacket: {0}", e);
-                    _packetFactory.RoutePacket(_nodeId, new NodeShutdown(NodeShutdownReason.ConnectionFailed));
-                    Close();
-                    return false;
-                }
-                return true;
-            }
-
-#if FEATURE_APM
-            /// <summary>
-            /// Method called when the body of a packet has been read.
-            /// </summary>
-            private void BodyReadComplete(IAsyncResult result)
-            {
-                NodePacketType packetType = (NodePacketType)_headerByte[0];
-                var state = (Tuple<byte[], int>)result.AsyncState;
-                byte[] packetData = state.Item1;
-                int packetLength = state.Item2;
-                int bytesRead;
-
-                try
-                {
-                    try
-                    {
-                        bytesRead = _clientToServerStream.EndRead(result);
-                    }
-
-                    // Workaround for CLR stress bug; it sporadically calls us twice on the same async
-                    // result, and EndRead will throw on the second one. Pretend the second one never happened.
-                    catch (ArgumentException)
-                    {
-                        CommunicationsUtilities.Trace(_nodeId, "Hit CLR bug #825607: called back twice on same async result; ignoring");
-                        return;
-                    }
-
-                    if (!ProcessBodyBytesRead(bytesRead, packetLength, packetType))
-                    {
-                        return;
-                    }
-                }
-                catch (IOException e)
-                {
-                    CommunicationsUtilities.Trace(_nodeId, "EXCEPTION in BodyReadComplete (Reading): {0}", e);
-                    _packetFactory.RoutePacket(_nodeId, new NodeShutdown(NodeShutdownReason.ConnectionFailed));
-                    Close();
-                    return;
-                }
-
-                // Read and route the packet.
-                if (!ReadAndRoutePacket(packetType, packetData, packetLength))
-                {
-                    return;
-                }
-
-                if (packetType != NodePacketType.NodeShutdown)
-                {
-                    // Read the next packet.
-                    BeginAsyncPacketRead();
-                }
-                else
-                {
-                    Close();
-                }
-            }
-#endif
         }
     }
 }
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 70629ecf2d8..5a5d1db3eb5 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -3,25 +3,16 @@
 
 using System;
 using System.Diagnostics.CodeAnalysis;
-#if CLR2COMPATIBILITY
+#if TASKHOST
 using Microsoft.Build.Shared.Concurrent;
 #else
 using System.Collections.Concurrent;
+using System.Threading.Tasks;
 #endif
 using System.IO;
-using System.IO.Pipes;
 using System.Threading;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-#if FEATURE_SECURITY_PERMISSIONS || FEATURE_PIPE_SECURITY
-using System.Security.AccessControl;
-#endif
-#if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
-using System.Security.Principal;
-#endif
-#if NET451_OR_GREATER || NETCOREAPP
-using System.Threading.Tasks;
-#endif
 
 #nullable disable
 
@@ -35,18 +26,6 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
     {
         #region Private Data
 
-#if NETCOREAPP2_1_OR_GREATER
-        /// <summary>
-        /// The amount of time to wait for the client to connect to the host.
-        /// </summary>
-        private const int ClientConnectTimeout = 60000;
-#endif // NETCOREAPP2_1
-
-        /// <summary>
-        /// The size of the buffers to use for named pipes
-        /// </summary>
-        private const int PipeBufferSize = 131072;
-
         /// <summary>
         /// The current communication status of the node.
         /// </summary>
@@ -55,7 +34,7 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         /// <summary>
         /// The pipe client used by the nodes.
         /// </summary>
-        private NamedPipeServerStream _pipeServer;
+        private NodePipeServer _pipeServer;
 
         // The following private data fields are used only when the endpoint is in ASYNCHRONOUS mode.
 
@@ -100,21 +79,6 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         /// </remarks>
         private ConcurrentQueue<INodePacket> _packetQueue;
 
-        /// <summary>
-        /// Per-node shared read buffer.
-        /// </summary>
-        private BinaryReaderFactory _sharedReadBuffer;
-
-        /// <summary>
-        /// A way to cache a byte array when writing out packets
-        /// </summary>
-        private MemoryStream _packetStream;
-
-        /// <summary>
-        /// A binary writer to help write into <see cref="_packetStream"/>
-        /// </summary>
-        private BinaryWriter _binaryWriter;
-
         #endregion
 
         #region INodeEndpoint Events
@@ -153,6 +117,7 @@ public void Listen(INodePacketFactory factory)
             ErrorUtilities.VerifyThrow(_status == LinkStatus.Inactive, "Link not inactive.  Status is {0}", _status);
             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
             _packetFactory = factory;
+            _pipeServer.RegisterPacketFactory(factory);
 
             InitializeAsyncPacketThread();
         }
@@ -206,54 +171,9 @@ internal void InternalConstruct(string pipeName = null)
         {
             _status = LinkStatus.Inactive;
             _asyncDataMonitor = new object();
-            _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
-
-            _packetStream = new MemoryStream();
-            _binaryWriter = new BinaryWriter(_packetStream);
 
             pipeName ??= NamedPipeUtil.GetPlatformSpecificPipeName();
-
-#if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
-            SecurityIdentifier identifier = WindowsIdentity.GetCurrent().Owner;
-            PipeSecurity security = new PipeSecurity();
-
-            // Restrict access to just this account.  We set the owner specifically here, and on the
-            // pipe client side they will check the owner against this one - they must have identical
-            // SIDs or the client will reject this server.  This is used to avoid attacks where a
-            // hacked server creates a less restricted pipe in an attempt to lure us into using it and
-            // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)
-            PipeAccessRule rule = new PipeAccessRule(identifier, PipeAccessRights.ReadWrite, AccessControlType.Allow);
-            security.AddAccessRule(rule);
-            security.SetOwner(identifier);
-
-            _pipeServer = new NamedPipeServerStream(
-                pipeName,
-                PipeDirection.InOut,
-                1, // Only allow one connection at a time.
-                PipeTransmissionMode.Byte,
-                PipeOptions.Asynchronous | PipeOptions.WriteThrough
-#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-                | PipeOptions.CurrentUserOnly
-#endif
-                ,
-                PipeBufferSize, // Default input buffer
-                PipeBufferSize,  // Default output buffer
-                security,
-                HandleInheritability.None);
-#else
-            _pipeServer = new NamedPipeServerStream(
-                pipeName,
-                PipeDirection.InOut,
-                1, // Only allow one connection at a time.
-                PipeTransmissionMode.Byte,
-                PipeOptions.Asynchronous | PipeOptions.WriteThrough
-#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-                | PipeOptions.CurrentUserOnly
-#endif
-                ,
-                PipeBufferSize, // Default input buffer
-                PipeBufferSize);  // Default output buffer
-#endif
+            _pipeServer = new NodePipeServer(pipeName, GetHandshake());
         }
 
         #endregion
@@ -295,7 +215,7 @@ private void InternalDisconnect()
             ErrorUtilities.VerifyThrow(_packetPump.ManagedThreadId != Thread.CurrentThread.ManagedThreadId, "Can't join on the same thread.");
             _terminatePacketPump.Set();
             _packetPump.Join();
-#if CLR2COMPATIBILITY
+#if TASKHOST
             _terminatePacketPump.Close();
 #else
             _terminatePacketPump.Dispose();
@@ -345,172 +265,25 @@ private void InitializeAsyncPacketThread()
         /// </summary>
         private void PacketPumpProc()
         {
-            NamedPipeServerStream localPipeServer = _pipeServer;
+            NodePipeServer localPipeServer = _pipeServer;
 
             AutoResetEvent localPacketAvailable = _packetAvailable;
             AutoResetEvent localTerminatePacketPump = _terminatePacketPump;
             ConcurrentQueue<INodePacket> localPacketQueue = _packetQueue;
 
-            DateTime originalWaitStartTime = DateTime.UtcNow;
-            bool gotValidConnection = false;
-            while (!gotValidConnection)
+            ChangeLinkStatus(localPipeServer.WaitForConnection());
+            if (_status != LinkStatus.Active)
             {
-                gotValidConnection = true;
-                DateTime restartWaitTime = DateTime.UtcNow;
-
-                // We only wait to wait the difference between now and the last original start time, in case we have multiple hosts attempting
-                // to attach.  This prevents each attempt from resetting the timer.
-                TimeSpan usedWaitTime = restartWaitTime - originalWaitStartTime;
-                int waitTimeRemaining = Math.Max(0, CommunicationsUtilities.NodeConnectionTimeout - (int)usedWaitTime.TotalMilliseconds);
-
-                try
-                {
-                    // Wait for a connection
-#if FEATURE_APM
-                    IAsyncResult resultForConnection = localPipeServer.BeginWaitForConnection(null, null);
-                    CommunicationsUtilities.Trace("Waiting for connection {0} ms...", waitTimeRemaining);
-                    bool connected = resultForConnection.AsyncWaitHandle.WaitOne(waitTimeRemaining, false);
-#else
-                    Task connectionTask = localPipeServer.WaitForConnectionAsync();
-                    CommunicationsUtilities.Trace("Waiting for connection {0} ms...", waitTimeRemaining);
-                    bool connected = connectionTask.Wait(waitTimeRemaining);
-#endif
-                    if (!connected)
-                    {
-                        CommunicationsUtilities.Trace("Connection timed out waiting a host to contact us.  Exiting comm thread.");
-                        ChangeLinkStatus(LinkStatus.ConnectionFailed);
-                        return;
-                    }
-
-                    CommunicationsUtilities.Trace("Parent started connecting. Reading handshake from parent");
-#if FEATURE_APM
-                    localPipeServer.EndWaitForConnection(resultForConnection);
-#endif
-
-                    // The handshake protocol is a series of int exchanges.  The host sends us a each component, and we
-                    // verify it. Afterwards, the host sends an "End of Handshake" signal, to which we respond in kind.
-                    // Once the handshake is complete, both sides can be assured the other is ready to accept data.
-                    Handshake handshake = GetHandshake();
-                    try
-                    {
-                        int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
-                        for (int i = 0; i < handshakeComponents.Length; i++)
-                        {
-#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-                            int handshakePart = _pipeServer.ReadIntForHandshake(
-                                byteToAccept: i == 0 ? (byte?)CommunicationsUtilities.handshakeVersion : null /* this will disconnect a < 16.8 host; it expects leading 00 or F5 or 06. 0x00 is a wildcard */
-#if NETCOREAPP2_1_OR_GREATER
-                            , ClientConnectTimeout /* wait a long time for the handshake from this side */
-#endif
-                            );
-#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-
-                            if (handshakePart != handshakeComponents[i])
-                            {
-                                CommunicationsUtilities.Trace("Handshake failed. Received {0} from host not {1}. Probably the host is a different MSBuild build.", handshakePart, handshakeComponents[i]);
-                                _pipeServer.WriteIntForHandshake(i + 1);
-                                gotValidConnection = false;
-                                break;
-                            }
-                        }
-
-                        if (gotValidConnection)
-                        {
-                            // To ensure that our handshake and theirs have the same number of bytes, receive and send a magic number indicating EOS.
-#if NETCOREAPP2_1_OR_GREATER
-                            _pipeServer.ReadEndOfHandshakeSignal(false, ClientConnectTimeout); /* wait a long time for the handshake from this side */
-#else
-                            _pipeServer.ReadEndOfHandshakeSignal(false);
-#endif
-                            CommunicationsUtilities.Trace("Successfully connected to parent.");
-                            _pipeServer.WriteEndOfHandshakeSignal();
-
-#if FEATURE_SECURITY_PERMISSIONS
-                            // We will only talk to a host that was started by the same user as us.  Even though the pipe access is set to only allow this user, we want to ensure they
-                            // haven't attempted to change those permissions out from under us.  This ensures that the only way they can truly gain access is to be impersonating the
-                            // user we were started by.
-                            WindowsIdentity currentIdentity = WindowsIdentity.GetCurrent();
-                            WindowsIdentity clientIdentity = null;
-                            localPipeServer.RunAsClient(delegate () { clientIdentity = WindowsIdentity.GetCurrent(true); });
-
-                            if (clientIdentity == null || !String.Equals(clientIdentity.Name, currentIdentity.Name, StringComparison.OrdinalIgnoreCase))
-                            {
-                                CommunicationsUtilities.Trace("Handshake failed. Host user is {0} but we were created by {1}.", (clientIdentity == null) ? "<unknown>" : clientIdentity.Name, currentIdentity.Name);
-                                gotValidConnection = false;
-                                continue;
-                            }
-#endif
-                        }
-                    }
-                    catch (IOException e)
-                    {
-                        // We will get here when:
-                        // 1. The host (OOP main node) connects to us, it immediately checks for user privileges
-                        //    and if they don't match it disconnects immediately leaving us still trying to read the blank handshake
-                        // 2. The host is too old sending us bits we automatically reject in the handshake
-                        // 3. We expected to read the EndOfHandshake signal, but we received something else
-                        CommunicationsUtilities.Trace("Client connection failed but we will wait for another connection. Exception: {0}", e.Message);
-
-                        gotValidConnection = false;
-                    }
-                    catch (InvalidOperationException)
-                    {
-                        gotValidConnection = false;
-                    }
-
-                    if (!gotValidConnection)
-                    {
-                        if (localPipeServer.IsConnected)
-                        {
-                            localPipeServer.Disconnect();
-                        }
-                        continue;
-                    }
-
-                    ChangeLinkStatus(LinkStatus.Active);
-                }
-                catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
-                {
-                    CommunicationsUtilities.Trace("Client connection failed.  Exiting comm thread. {0}", e);
-                    if (localPipeServer.IsConnected)
-                    {
-                        localPipeServer.Disconnect();
-                    }
-
-                    ExceptionHandling.DumpExceptionToFile(e);
-                    ChangeLinkStatus(LinkStatus.Failed);
-                    return;
-                }
+                return;
             }
 
-            RunReadLoop(
-                new BufferedReadStream(_pipeServer),
-                _pipeServer,
-                localPacketQueue, localPacketAvailable, localTerminatePacketPump);
+            RunReadLoop(localPipeServer, localPacketQueue, localPacketAvailable, localTerminatePacketPump);
 
             CommunicationsUtilities.Trace("Ending read loop");
-
-            try
-            {
-                if (localPipeServer.IsConnected)
-                {
-#if NETCOREAPP // OperatingSystem.IsWindows() is new in .NET 5.0
-                    if (OperatingSystem.IsWindows())
-#endif
-                    {
-                        localPipeServer.WaitForPipeDrain();
-                    }
-
-                    localPipeServer.Disconnect();
-                }
-            }
-            catch (Exception)
-            {
-                // We don't really care if Disconnect somehow fails, but it gives us a chance to do the right thing.
-            }
+            localPipeServer.Disconnect();
         }
 
-        private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream localWritePipe,
+        private void RunReadLoop(NodePipeServer localPipeServer,
             ConcurrentQueue<INodePacket> localPacketQueue, AutoResetEvent localPacketAvailable, AutoResetEvent localTerminatePacketPump)
         {
             // Ordering of the wait handles is important.  The first signalled wait handle in the array
@@ -518,13 +291,11 @@ private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream
             // terminate event triggered so that we cannot get into a situation where packets are being
             // spammed to the endpoint and it never gets an opportunity to shutdown.
             CommunicationsUtilities.Trace("Entering read loop.");
-            byte[] headerByte = new byte[5];
-#if NET451_OR_GREATER
-            Task<int> readTask = localReadPipe.ReadAsync(headerByte, 0, headerByte.Length, CancellationToken.None);
-#elif NETCOREAPP
-            Task<int> readTask = CommunicationsUtilities.ReadAsync(localReadPipe, headerByte, headerByte.Length);
+#if TASKHOST
+            Func<INodePacket> readPacketFunc = localPipeServer.ReadPacket;
+            IAsyncResult result = readPacketFunc.BeginInvoke(null, null);
 #else
-            IAsyncResult result = localReadPipe.BeginRead(headerByte, 0, headerByte.Length, null, null);
+            Task<INodePacket> readTask = localPipeServer.ReadPacketAsync();
 #endif
 
             // Ordering is important.  We want packetAvailable to supercede terminate otherwise we will not properly wait for all
@@ -548,36 +319,25 @@ private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream
                 {
                     case 0:
                         {
-                            int bytesRead = 0;
+                            INodePacket packet = null;
+
                             try
                             {
-#if NET451_OR_GREATER || NETCOREAPP
-                                bytesRead = readTask.Result;
+#if TASKHOST
+                                packet = readPacketFunc.EndInvoke(result);
 #else
-                                bytesRead = localReadPipe.EndRead(result);
+                                packet = readTask.GetAwaiter().GetResult();
 #endif
-                            }
-                            catch (Exception e)
-                            {
-                                // Lost communications.  Abort (but allow node reuse)
-                                CommunicationsUtilities.Trace("Exception reading from server.  {0}", e);
-                                ExceptionHandling.DumpExceptionToFile(e);
-                                ChangeLinkStatus(LinkStatus.Inactive);
-                                exitLoop = true;
-                                break;
-                            }
-
-                            if (bytesRead != headerByte.Length)
-                            {
-                                // Incomplete read.  Abort.
-                                if (bytesRead == 0)
+                                if (packet.Type == NodePacketType.NodeShutdown)
                                 {
                                     if (_isClientDisconnecting)
                                     {
-                                        CommunicationsUtilities.Trace("Parent disconnected gracefully.");
+                                        // Lost communications.  Abort (but allow node reuse).
                                         // Do not change link status to failed as this could make node think connection has failed
                                         // and recycle node, while this is perfectly expected and handled race condition
                                         // (both client and node is about to close pipe and client can be faster).
+                                        CommunicationsUtilities.Trace("Parent disconnected gracefully.");
+                                        ChangeLinkStatus(LinkStatus.Inactive);
                                     }
                                     else
                                     {
@@ -587,43 +347,35 @@ private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream
                                 }
                                 else
                                 {
-                                    CommunicationsUtilities.Trace("Incomplete header read from server.  {0} of {1} bytes read", bytesRead, headerByte.Length);
-                                    ChangeLinkStatus(LinkStatus.Failed);
+                                    _packetFactory.RoutePacket(0, packet);
                                 }
-
-                                exitLoop = true;
-                                break;
-                            }
-
-                            NodePacketType packetType = (NodePacketType)headerByte[0];
-
-                            try
-                            {
-                                _packetFactory.DeserializeAndRoutePacket(0, packetType, BinaryTranslator.GetReadTranslator(localReadPipe, _sharedReadBuffer));
                             }
                             catch (Exception e)
                             {
-                                // Error while deserializing or handling packet.  Abort.
-                                CommunicationsUtilities.Trace("Exception while deserializing packet {0}: {1}", packetType, e);
+                                if (packet == null)
+                                {
+                                    CommunicationsUtilities.Trace("Exception while reading packet from server:  {0}", e);
+                                }
+                                else
+                                {
+                                    CommunicationsUtilities.Trace("Exception while deserializing or handling packet {0}: {1}", packet.Type, e);
+                                }
+
                                 ExceptionHandling.DumpExceptionToFile(e);
                                 ChangeLinkStatus(LinkStatus.Failed);
-                                exitLoop = true;
-                                break;
                             }
 
-#if NET451_OR_GREATER
-                            readTask = localReadPipe.ReadAsync(headerByte, 0, headerByte.Length, CancellationToken.None);
-#elif NETCOREAPP
-                            readTask = CommunicationsUtilities.ReadAsync(localReadPipe, headerByte, headerByte.Length);
-#else
-                            result = localReadPipe.BeginRead(headerByte, 0, headerByte.Length, null, null);
-#endif
-
-#if NET451_OR_GREATER || NETCOREAPP
-                            handles[0] = ((IAsyncResult)readTask).AsyncWaitHandle;
+                            exitLoop = _status != LinkStatus.Active;
+                            if (!exitLoop)
+                            {
+#if TASKHOST
+                                result = readPacketFunc.BeginInvoke(null, null);
+                                handles[0] = result.AsyncWaitHandle;
 #else
-                            handles[0] = result.AsyncWaitHandle;
+                                readTask = localPipeServer.ReadPacketAsync();
+                                handles[0] = ((IAsyncResult)readTask).AsyncWaitHandle;
 #endif
+                            }
                         }
 
                         break;
@@ -633,29 +385,9 @@ private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream
                         try
                         {
                             // Write out all the queued packets.
-                            INodePacket packet;
-                            while (localPacketQueue.TryDequeue(out packet))
+                            while (localPacketQueue.TryDequeue(out INodePacket packet))
                             {
-                                var packetStream = _packetStream;
-                                packetStream.SetLength(0);
-
-                                ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(packetStream);
-
-                                packetStream.WriteByte((byte)packet.Type);
-
-                                // Pad for packet length
-                                _binaryWriter.Write(0);
-
-                                // Reset the position in the write buffer.
-                                packet.Translate(writeTranslator);
-
-                                int packetStreamLength = (int)packetStream.Position;
-
-                                // Now write in the actual packet length
-                                packetStream.Position = 1;
-                                _binaryWriter.Write(packetStreamLength - 5);
-
-                                localWritePipe.Write(packetStream.GetBuffer(), 0, packetStreamLength);
+                                localPipeServer.WritePacket(packet);
                             }
                         }
                         catch (Exception e)
@@ -685,8 +417,8 @@ private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream
             while (!exitLoop);
         }
 
-#endregion
+        #endregion
 
-#endregion
+        #endregion
     }
 }
