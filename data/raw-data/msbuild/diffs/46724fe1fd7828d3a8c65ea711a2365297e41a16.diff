diff --git a/documentation/Home.md b/documentation/Home.md
deleted file mode 100644
index b7cf33e3e8b..00000000000
--- a/documentation/Home.md
+++ /dev/null
@@ -1,24 +0,0 @@
-# Getting Started
-
- * [What is MSBuild?](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild)
- * Building Testing and Debugging
-   * [Full Framework MSBuild](wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md)
-   * [.Net Core MSBuild](wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md)
-   * [Mono MSBuild](wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md)
-
-# Resources
- * [MSBuild Resources](wiki/MSBuild-Resources.md)
- * [Contributed documentation](Contributions/README.md)
- * [MSBuild Tips & Tricks](wiki/MSBuild-Tips-&-Tricks.md)
- * [Binary log](wiki/Binary-Log.md)
- * [Providing Binary Logs for investigation](wiki/Providing-Binary-Logs.md)
- * [Contributing Code](wiki/Contributing-Code.md)
- * [Target Maps](wiki/Target-Maps.md)
- * Tasks
-   * [ResolveAssemblyReference](wiki/ResolveAssemblyReference.md)
- * Problems?
-   * [Rebuilding when nothing changed](wiki/Rebuilding-when-nothing-changed.md)
-   * [Something's wrong in my build](wiki/Something's-wrong-in-my-build.md)
-   * [Microsoft.Build.Framework](wiki/Microsoft.Build.Framework.md)
-     *  Some gotchas around the Microsoft.Build.Framework project/assembly.
-
diff --git a/documentation/README.md b/documentation/README.md
new file mode 100644
index 00000000000..99fec003daf
--- /dev/null
+++ b/documentation/README.md
@@ -0,0 +1,86 @@
+Welcome to MSBuild docs!
+
+The folder contains collection of docs and references for MSBuild, detailed information on how to work with this repo, and covers in-depth technical topics related to implementation.
+
+## Getting Started
+
+* [What is MSBuild?](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild)
+* Building Testing and Debugging
+  * [Full Framework MSBuild](wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md)
+  * [.Net Core MSBuild](wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md)
+  * [macOS](wiki/Mac-Debugging.md)
+
+* [MSBuild resources](wiki/MSBuild-Resources.md)
+* [MSBuild tips & tricks](wiki/MSBuild-Tips-&-Tricks.md)
+
+## NuGet packages
+
+* [General information](consuming-nuget-package.md)
+
+## Release information
+
+* [Changelog](Changelog.md)
+* [Release process](release.md)
+* [Change waves](wiki/ChangeWaves.md)
+* [Interactions with the internal repository](wiki/Interactions-with-the-internal-repository.md)
+
+## Development and contributing
+
+* [Providing binary logs for investigation](wiki/Providing-Binary-Logs.md)
+* [Contributing code](wiki/Contributing-Code.md)
+   * [Contributing tasks](wiki/Contributing-Tasks.md)
+* [Error codes](assigning-msb-error-code.md)
+* [Deploying built MSBuild](Deploy-MSBuild.md)
+* [Events emitted by MSBuild](specs/event-source.md)
+* [Change waves (for developers)](wiki/ChangeWaves-Dev.md)
+* [GitHub labels](wiki/Labels.md)
+* [Localization](wiki/Localization.md)
+
+### Problems?
+
+* [Rebuilding when nothing changed](wiki/Rebuilding-when-nothing-changed.md)
+* [Something's wrong in my build](wiki/Something's-wrong-in-my-build.md)
+* [Some gotchas around the Microsoft.Build.Framework project/assembly](wiki/Microsoft.Build.Framework.md)
+* [GAC and MSBuild](wiki/UnGAC.md)
+* [When globbing returns original filespec](WhenGlobbingReturnsOriginalFilespec.md)
+
+## In-depth tech topics
+
+* [Reserved and built-in properties](Built-in-Propeties.md)
+* [`ProjectReference`](ProjectReference-Protocol.md)
+* [MSBuild Server](MSBuild-Server.md)
+* [Low priority nodes](specs/low-priority-switch.md)
+* [Project cache plugin](specs/project-cache.md)
+* [Support for remote host objects](specs/remote-host-object.md)
+* [Static graph](specs/static-graph.md)
+* [Single project isolated builds: implementation details](specs/single-project-isolated-builds.md)
+* [Task isolation](specs/task-isolation-and-dependencies.md)
+* [Threading in MSBuild worker nodes](specs/threading.md)
+* [Target maps](wiki/Target-Maps.md)
+* [Managing parallelism in MSBuild](specs/resource-management.md)
+* [SDK resolution](specs/sdk-resolvers-algorithm.md)
+
+### Tasks
+
+* [`ResolveAssemblyReference`](wiki/ResolveAssemblyReference.md)
+
+### Evaluation
+
+* [Evaluation profiling](evaluation-profiling.md)
+
+### Logging
+
+* [Binary log](wiki/Binary-Log.md)
+* [Live logger: how to opt in](livelogger/Opt-In-Mechanism.md)
+
+## Designs
+
+* [Resolve Assembly Reference as a service](design/rar-as-service.md)
+   * Prototype: https://github.com/dotnet/msbuild/issues/6193
+
+## Community contributions
+
+* [MSBuild overview](Contributions/MSBuild-overview.md)
+* [Solution parser](Contributions/solution-parser.md)
+
+Note: community contributions has documentation that was contributed by developers or users, but it might not been fully vetted for accuracy and correctness. Explanations in this folder may not be fully accurate, but can still be very informative for developing an understanding of MSBuild or a specific problem.
\ No newline at end of file
diff --git a/documentation/WhenGlobbingReturnsOriginalFilespec.md b/documentation/WhenGlobbingReturnsOriginalFilespec.md
index ac9a74c887f..d824eeeddcc 100644
--- a/documentation/WhenGlobbingReturnsOriginalFilespec.md
+++ b/documentation/WhenGlobbingReturnsOriginalFilespec.md
@@ -1,3 +1,5 @@
+# When globbing returns original filespec
+
 Original itemspec is returned when:
 - illegal filespec contains
 	- both wildcards and escaped wildcards (`%2a`, `%3f`)
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md b/documentation/deprecated/Building-Testing-and-Debugging-on-Mono-MSBuild.md
similarity index 100%
rename from documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md
rename to documentation/deprecated/Building-Testing-and-Debugging-on-Mono-MSBuild.md
diff --git a/documentation/specs/rar-as-service.md b/documentation/design/rar-as-service.md
similarity index 100%
rename from documentation/specs/rar-as-service.md
rename to documentation/design/rar-as-service.md
diff --git a/documentation/specs/sdk-resolvers-algorithm.md b/documentation/specs/sdk-resolvers-algorithm.md
index eb962ad2644..e5cd05a0dd3 100644
--- a/documentation/specs/sdk-resolvers-algorithm.md
+++ b/documentation/specs/sdk-resolvers-algorithm.md
@@ -25,4 +25,35 @@ Note, that the manifest file, if exists, from ChangeWave 17.4 would have prefere
 The sdk discovery works according to the following algorithm:
 - First try locate the manifest file and use it. 
 - If it is not found, we try to locate the dll in the resolver's folder. 
-Both xml and dll name should match the following name pattern `...\SdkResolvers\(ResolverName)\(ResolverName).(xml/dll)`.
\ No newline at end of file
+Both xml and dll name should match the following name pattern `...\SdkResolvers\(ResolverName)\(ResolverName).(xml/dll)`.
+
+### Failed SDK Resolution
+
+> 🚧 Note
+>
+> This page is a work in progress.
+
+SDK resolvers previously attempted to continue when one critically fails (throws an unhandled exception). This lead to misleading error messages such as:
+
+```
+warning MSB4242: The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed to run. 's' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8.
+error MSB4236: The SDK 'Microsoft.NET.SDK.WorkloadAutoImportPropsLocator' specified could not be found. [C:\foo\bar.csproj]
+```
+
+`MSB4236` is a red herring while `MSB4242` is the real error despite being logged as a warning. Because of this, SDK resolvers now fail the build _immediately_ upon unhandled exceptions. These exceptions are propogated as `SdkResolverException`s, and `MSB4242` has been promoted to an error code. The new error message appears like so:
+
+```
+C:\src\temp\8-18>"C:\foo\dotnet-sdk-6.0.100-preview.7.21379.14-win-x64\dotnet.exe" build    
+Microsoft (R) Build Engine version 17.0.0-dev-21420-01+5df152759 for .NET
+Copyright (C) Microsoft Corporation. All rights reserved.
+
+C:\foo\bar.csproj : error MSB4242: SDK Resolver Failure: "The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed while attempting to resolve the SDK "Microsoft.NET.Sdk". Exception: "'s' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8."".
+
+Build FAILED.
+
+C:\foo\bar.csproj : error MSB4242: SDK Resolver Failure: "The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed while attempting to resolve the SDK "Microsoft.NET.Sdk". Exception: "'s' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8."".
+    0 Warning(s)
+    1 Error(s)
+
+Time Elapsed 00:00:00.15
+```
\ No newline at end of file
diff --git a/documentation/specs/sdk-resolvers.md b/documentation/specs/sdk-resolvers.md
deleted file mode 100644
index ddb73668e2b..00000000000
--- a/documentation/specs/sdk-resolvers.md
+++ /dev/null
@@ -1,29 +0,0 @@
-> 🚧 Note
->
-> This page is a work in progress.
-
-### Failed SDK Resolution
-SDK resolvers previously attempted to continue when one critically fails (throws an unhandled exception). This lead to misleading error messages such as:
-
-```
-warning MSB4242: The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed to run. 's' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8.
-error MSB4236: The SDK 'Microsoft.NET.SDK.WorkloadAutoImportPropsLocator' specified could not be found. [C:\foo\bar.csproj]
-```
-
-`MSB4236` is a red herring while `MSB4242` is the real error despite being logged as a warning. Because of this, SDK resolvers now fail the build _immediately_ upon unhandled exceptions. These exceptions are propogated as `SdkResolverException`s, and `MSB4242` has been promoted to an error code. The new error message appears like so:
-
-```
-C:\src\temp\8-18>"C:\foo\dotnet-sdk-6.0.100-preview.7.21379.14-win-x64\dotnet.exe" build    
-Microsoft (R) Build Engine version 17.0.0-dev-21420-01+5df152759 for .NET
-Copyright (C) Microsoft Corporation. All rights reserved.
-
-C:\foo\bar.csproj : error MSB4242: SDK Resolver Failure: "The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed while attempting to resolve the SDK "Microsoft.NET.Sdk". Exception: "'s' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8."".
-
-Build FAILED.
-
-C:\foo\bar.csproj : error MSB4242: SDK Resolver Failure: "The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed while attempting to resolve the SDK "Microsoft.NET.Sdk". Exception: "'s' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8."".
-    0 Warning(s)
-    1 Error(s)
-
-Time Elapsed 00:00:00.15
-```
\ No newline at end of file
diff --git a/documentation/specs/static-graph-implementation-details.md b/documentation/specs/single-project-isolated-builds.md
similarity index 100%
rename from documentation/specs/static-graph-implementation-details.md
rename to documentation/specs/single-project-isolated-builds.md
diff --git a/documentation/wiki/Interactions-with-the-internal-repository.md b/documentation/wiki/Interactions-with-the-internal-repository.md
index a6b0b414114..916ac2bd78d 100644
--- a/documentation/wiki/Interactions-with-the-internal-repository.md
+++ b/documentation/wiki/Interactions-with-the-internal-repository.md
@@ -1,3 +1,5 @@
+# Interactions with the internal repository
+
 MSbuild got forked from an internal Microsoft repository. Although the Github repository is the official one, where development takes place, there are still some left-over connections to the internal one. This page attempts to document these.
 
 Changes to these files need to be migrated back into the internal repo because that's where they are localized:
diff --git a/documentation/wiki/Mac-Debugging.md b/documentation/wiki/Mac-Debugging.md
index e6458e6f978..fedab4908d6 100644
--- a/documentation/wiki/Mac-Debugging.md
+++ b/documentation/wiki/Mac-Debugging.md
@@ -1,6 +1,6 @@
-#Debugging with MacOS
+# Debugging with MacOS
 * Open terminal 
-  * Hit command-space, type terminal, hit enter. Alternatively, hit magnifying glass (spotlight) in upper-right corner and search for terminal.)
+  * Hit command-space, type terminal, hit enter. Alternatively, hit magnifying glass (spotlight) in upper-right corner and search for terminal.
 * Build and run tests
   * Navigation in terminal is similar to command prompt (cd), although you type `ls` in place of `dir`.
   * **Use `./build.sh -test` instead of `.\build.cmd -test`.**
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 7310d68883a..e719ef73e02 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.23060.6">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.23073.7">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>74b7648c106865057c78ca1e4b2ffcb5e9bce071</Sha>
+      <Sha>05a8ec6db75694246db7a7b9ab680c9be91bf1d6</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.5.0-preview.3.136">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.5.0-rc.149">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>743503cb3c7e9ced2602ee2e29c38d63cc339451</Sha>
+      <Sha>ca5029046d7b6e55f322c45abb7b342054543710</Sha>
     </Dependency>
     <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.5.0-3.23062.15">
       <Uri>https://github.com/dotnet/roslyn</Uri>
       <Sha>7061c64ddbd931d55b9a97f95243fcf91d04d7b1</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23060.6">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23073.7">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>74b7648c106865057c78ca1e4b2ffcb5e9bce071</Sha>
+      <Sha>05a8ec6db75694246db7a7b9ab680c9be91bf1d6</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 84ab06e6da4..e173379e310 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -48,11 +48,11 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23060.6</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23073.7</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
     <MicrosoftNetCompilersToolsetVersion>4.5.0-3.23062.15</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.5.0-preview.3.136</NuGetBuildTasksVersion>
+    <NuGetBuildTasksVersion>6.5.0-rc.149</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>7.0.0</SystemTextJsonVersion>
     <SystemThreadingTasksDataflowVersion>7.0.0</SystemThreadingTasksDataflowVersion>
diff --git a/global.json b/global.json
index c809c9cec27..12a0dabf951 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
     "xcopy-msbuild": "17.4.1"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.23060.6"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.23073.7"
   }
 }
diff --git a/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs b/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs
index 527c35aa556..32078810707 100644
--- a/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using System.Collections.Generic;
 using System.IO;
 using Microsoft.Build.BackEnd;
@@ -22,31 +23,63 @@ public static IEnumerable<object[]> CacheData
             {
                 var configCache = new ConfigCache();
                 var brq1 = new BuildRequestConfiguration(
-                   1,
-                   new BuildRequestData("path1", new Dictionary<string, string> { ["a1"] = "b1" }, Constants.defaultToolsVersion, new[] { "target1" }, null),
-                   Constants.defaultToolsVersion);
+                    1,
+                    new BuildRequestData("path1", new Dictionary<string, string> { ["a1"] = "b1" }, Constants.defaultToolsVersion, new[] { "target1", "target2" }, null),
+                    Constants.defaultToolsVersion);
 
                 var brq2 = new BuildRequestConfiguration(
                     2,
                     new BuildRequestData("path2", new Dictionary<string, string> { ["a2"] = "b2" }, Constants.defaultToolsVersion, new[] { "target2" }, null),
                     Constants.defaultToolsVersion);
                 var brq3 = new BuildRequestConfiguration(
-                   3,
-                   new BuildRequestData("path3", new Dictionary<string, string> { ["a3"] = "b3" }, Constants.defaultToolsVersion, new[] { "target3" }, null),
-                   Constants.defaultToolsVersion);
+                    3,
+                    new BuildRequestData("path3", new Dictionary<string, string> { ["a3"] = "b3" }, Constants.defaultToolsVersion, new[] { "target3" }, null),
+                    Constants.defaultToolsVersion);
 
                 configCache.AddConfiguration(brq1);
                 configCache.AddConfiguration(brq2);
                 configCache.AddConfiguration(brq3);
 
                 var resultsCache = new ResultsCache();
-                var request1 = new BuildRequest(1, 0, 1, new string[] { "target1" }, null, BuildEventContext.Invalid, null);
+                var request1 = new BuildRequest(1, 0, 1, new string[] { "target1", "target2", "target3" }, null, BuildEventContext.Invalid, null);
                 var request2 = new BuildRequest(2, 0, 2, new string[] { "target2" }, null, BuildEventContext.Invalid, null);
                 var request3 = new BuildRequest(3, 0, 3, new string[] { "target3" }, null, BuildEventContext.Invalid, null);
 
-                resultsCache.AddResult(new BuildResult(request1));
-                resultsCache.AddResult(new BuildResult(request2));
-                resultsCache.AddResult(new BuildResult(request3));
+                var buildResult1 = new BuildResult(request1);
+                var buildResult2 = new BuildResult(request2);
+                var buildResult3 = new BuildResult(request3);
+
+                buildResult1.AddResultsForTarget(
+                    "target1",
+                    new TargetResult(
+                        Array.Empty<ProjectItemInstance.TaskItem>(),
+                        new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null)));
+                buildResult1.AddResultsForTarget(
+                    "target2",
+                    new TargetResult(
+                        Array.Empty<ProjectItemInstance.TaskItem>(),
+                        new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null)));
+                buildResult1.AddResultsForTarget(
+                    "target3",
+                    new TargetResult(
+                        Array.Empty<ProjectItemInstance.TaskItem>(),
+                        new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null)));
+
+                buildResult2.AddResultsForTarget(
+                    "target2",
+                    new TargetResult(
+                        Array.Empty<ProjectItemInstance.TaskItem>(),
+                        new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null)));
+
+                buildResult3.AddResultsForTarget(
+                    "target3",
+                    new TargetResult(
+                        Array.Empty<ProjectItemInstance.TaskItem>(),
+                        new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null)));
+
+                resultsCache.AddResult(buildResult1);
+                resultsCache.AddResult(buildResult2);
+                resultsCache.AddResult(buildResult3);
 
                 return new List<object[]>
                 {
@@ -63,7 +96,11 @@ public void OnlySerializeCacheEntryWithSmallestConfigId(object configCache, obje
             try
             {
                 cacheFile = FileUtilities.GetTemporaryFile("MSBuildResultsCache");
-                Assert.Null(CacheSerialization.SerializeCaches((ConfigCache)configCache, (ResultsCache)resultsCache, cacheFile));
+                Assert.Null(CacheSerialization.SerializeCaches(
+                    (ConfigCache)configCache,
+                    (ResultsCache)resultsCache,
+                    cacheFile,
+                    ProjectIsolationMode.True));
 
                 var result = CacheSerialization.DeserializeCaches(cacheFile);
                 Assert.True(result.ConfigCache.HasConfiguration(1));
@@ -75,5 +112,39 @@ public void OnlySerializeCacheEntryWithSmallestConfigId(object configCache, obje
                 File.Delete(cacheFile);
             }
         }
+
+        [Theory]
+        [MemberData(nameof(CacheData))]
+        public void OnlySerializeResultsForSpecifiedTargets(object configCache, object resultsCache)
+        {
+            // Setup:
+            // 1. Create a config with id 1 whose project is built with top-level targets target1
+            // and target2.
+            // 2. Send a build request and collect the BuildResults for targets target1, target2,
+            // and target3.
+            // 3. Ensure the BuildResult for target3 is excluded from output cache serialization
+            // since it's not a top-level target.
+            string cacheFile = null;
+            try
+            {
+                cacheFile = FileUtilities.GetTemporaryFile("MSBuildResultsCache");
+                Assert.Null(CacheSerialization.SerializeCaches(
+                    (ConfigCache)configCache,
+                    (ResultsCache)resultsCache,
+                    cacheFile,
+                    ProjectIsolationMode.MessageUponIsolationViolation));
+
+                var result = CacheSerialization.DeserializeCaches(cacheFile);
+                Assert.True(result.ConfigCache.HasConfiguration(1));
+                BuildResult buildResult = result.ResultsCache.GetResultsForConfiguration(1);
+                Assert.True(buildResult.HasResultsForTarget("target1"));
+                Assert.True(buildResult.HasResultsForTarget("target2"));
+                Assert.False(buildResult.HasResultsForTarget("target3"));
+            }
+            finally
+            {
+                File.Delete(cacheFile);
+            }
+        }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/MockHost.cs b/src/Build.UnitTests/BackEnd/MockHost.cs
index caae65aa14d..ff6ed17aefe 100644
--- a/src/Build.UnitTests/BackEnd/MockHost.cs
+++ b/src/Build.UnitTests/BackEnd/MockHost.cs
@@ -1,9 +1,9 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
-using System;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Engine.UnitTests.BackEnd;
 using Microsoft.Build.Evaluation;
@@ -66,24 +66,47 @@ internal class MockHost : MockLoggingService, IBuildComponentHost, IBuildCompone
         #endregion;
 
         /// <summary>
-        /// Constructor
+        /// Initializes a new instance of the <see cref="MockHost"/> class.
         /// </summary>
-        public MockHost()
-            : this(new BuildParameters())
+        /// <param name="overrideConfigCache">The override config cache.</param>
+        /// <param name="overrideResultsCache">The override results cache.</param>
+        public MockHost(ConfigCache overrideConfigCache = null, ResultsCache overrideResultsCache = null)
+            : this(new BuildParameters(), overrideConfigCache, overrideResultsCache)
         {
         }
 
         /// <summary>
-        /// Constructor
+        /// Initializes a new instance of the <see cref="MockHost"/> class.
         /// </summary>
-        public MockHost(BuildParameters buildParameters)
+        /// <param name="buildParameters">The mock host's build parameters.</param>
+        /// <param name="overrideConfigCache">The override config cache.</param>
+        /// <param name="overrideResultsCache">The override results cache.</param>
+        public MockHost(BuildParameters buildParameters, ConfigCache overrideConfigCache = null, ResultsCache overrideResultsCache = null)
         {
             _buildParameters = buildParameters;
 
             _buildParameters.ProjectRootElementCache = new ProjectRootElementCache(false);
 
-            _configCache = new ConfigCache();
-            ((IBuildComponent)_configCache).InitializeComponent(this);
+            if (overrideConfigCache != null && overrideResultsCache != null)
+            {
+                _configCache = new ConfigCacheWithOverride(overrideConfigCache);
+                _resultsCache = new ResultsCacheWithOverride(overrideResultsCache);
+            }
+            else if (overrideConfigCache == null && overrideResultsCache == null)
+            {
+                _configCache = new ConfigCache();
+                _resultsCache = new ResultsCache();
+            }
+            else if (overrideConfigCache == null)
+            {
+                throw new ArgumentNullException($"Attempted to create an override cache with a null {nameof(overrideConfigCache)}.");
+            }
+            else
+            {
+                throw new ArgumentNullException($"Attempted to create an override cache with a null {nameof(overrideResultsCache)}.");
+            }
+
+            _configCache.InitializeComponent(this);
 
             // We are a logging service
             _loggingService = this;
@@ -93,10 +116,9 @@ public MockHost(BuildParameters buildParameters)
             _requestEngine = new BuildRequestEngine();
             ((IBuildComponent)_requestEngine).InitializeComponent(this);
 
-            _resultsCache = new ResultsCache();
-            ((IBuildComponent)_resultsCache).InitializeComponent(this);
+            _resultsCache.InitializeComponent(this);
 
-            _requestBuilder = new Microsoft.Build.UnitTests.BackEnd.BuildRequestEngine_Tests.MockRequestBuilder();
+            _requestBuilder = new BuildRequestEngine_Tests.MockRequestBuilder();
             ((IBuildComponent)_requestBuilder).InitializeComponent(this);
 
             _targetBuilder = new TestTargetBuilder();
diff --git a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
index 7675567e257..4a30daafd4f 100644
--- a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using LegacyThreadingData = Microsoft.Build.Execution.LegacyThreadingData;
 using Xunit;
 
diff --git a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
index 94079fa39f1..d292d13983a 100644
--- a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
@@ -597,6 +597,22 @@ public void VerifyNoOverCreationOfNodesWithBuildLoop()
             Assert.Equal(4, nextNodeId); // 3 nodes
         }
 
+        [Fact]
+        public void BuildResultNotPlacedInCurrentCacheIfConfigExistsInOverrideCache()
+        {
+            ConfigCache overrideConfigCache = new();
+            ResultsCache overrideResultsCache = new();
+            CreateConfiguration(1, "test.csproj", overrideConfigCache);
+            BuildRequest br1 = CreateBuildRequest(1, 1, new string[] { "A" });
+            CacheBuildResult(br1, "A", BuildResultUtilities.GetSuccessResult(), overrideResultsCache);
+            _host = new MockHost(overrideConfigCache, overrideResultsCache);
+            _scheduler = new Scheduler();
+            _scheduler.InitializeComponent(_host);
+            BuildRequest br2 = CreateBuildRequest(1, 1, new string[] { "B" });
+            _scheduler.RecordResultToCurrentCacheIfConfigNotInOverrideCache(CreateBuildResult(br2, "B", BuildResultUtilities.GetSuccessResult()));
+            Assert.Null(((ResultsCacheWithOverride)_host.GetComponent(BuildComponentType.ResultsCache)).CurrentCache.GetResultsForConfiguration(1));
+        }
+
         /// <summary>
         /// Verify that if we get two requests but one of them is a failure, we only get the failure result back.
         /// </summary>
@@ -706,26 +722,48 @@ public void TestDetailedSummary()
         }
 
         /// <summary>
-        /// Creates a configuration and stores it in the cache.
+        /// Creates a configuration to store in the <see cref="ConfigCache"/>.
         /// </summary>
-        private void CreateConfiguration(int configId, string file)
+        /// <param name="configId">The configuration id.</param>
+        /// <param name="projectFullPath">The project's full path.</param>
+        /// <param name="configCache">The config cache in which to place the configuration. If
+        /// <see cref="langword"="null" />, use the host's config cache.</param>
+        private void CreateConfiguration(int configId, string projectFullPath, ConfigCache configCache = null)
         {
-            BuildRequestData data = new BuildRequestData(file, new Dictionary<string, string>(), "4.0", Array.Empty<string>(), null);
-            BuildRequestConfiguration config = new BuildRequestConfiguration(configId, data, "4.0");
-            config.ProjectInitialTargets = new List<string>();
-            config.ProjectDefaultTargets = new List<string>();
-
-            (_host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache).AddConfiguration(config);
+            BuildRequestData data = new(projectFullPath, new Dictionary<string, string>(), "4.0", Array.Empty<string>(), null);
+            BuildRequestConfiguration config = new(configId, data, "4.0") { ProjectInitialTargets = new List<string>(), ProjectDefaultTargets = new List<string>() };
+            if (configCache == null)
+            {
+                (_host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache).AddConfiguration(config);
+            }
+            else
+            {
+                configCache.AddConfiguration(config);
+            }
         }
 
         /// <summary>
-        /// Creates and caches a built result.
+        /// Creates and caches a <see cref="BuildResult"/> in the <see cref="ResultsCache"/>.
         /// </summary>
-        private BuildResult CacheBuildResult(BuildRequest request, string target, WorkUnitResult workUnitResult)
+        /// <param name="request">The build request corresponding to the <see cref="BuildResult"/> to be
+        /// created and cached.</param>
+        /// <param name="target">The target for which there will be a result.</param>
+        /// <param name="workUnitResult">The result of executing the specified target.</param>
+        /// <param name="resultsCache">The results cache to contain the <see cref="BuildResult"/>.
+        /// If <see cref="langword"="null"/>, use the host's results cache.</param>
+        /// <returns>The build result.</returns>
+        private BuildResult CacheBuildResult(BuildRequest request, string target, WorkUnitResult workUnitResult, ResultsCache resultsCache = null)
         {
             BuildResult result = CreateBuildResult(request, target, workUnitResult);
-            IResultsCache resultsCache = _host.GetComponent(BuildComponentType.ResultsCache) as IResultsCache;
-            resultsCache.AddResult(result);
+            if (resultsCache == null)
+            {
+                (_host.GetComponent(BuildComponentType.ResultsCache) as IResultsCache).AddResult(result);
+            }
+            else
+            {
+                resultsCache.AddResult(result);
+            }
+
             return result;
         }
 
diff --git a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
index 78e73980389..2623dfa5e8f 100644
--- a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
+++ b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
@@ -7,11 +7,14 @@
 using System.Linq;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using ExpectedNodeBuildOutput = System.Collections.Generic.Dictionary<Microsoft.Build.Graph.ProjectGraphNode, string[]>;
+using OutputCacheDictionary = System.Collections.Generic.Dictionary<Microsoft.Build.Graph.ProjectGraphNode, string>;
 
 #nullable disable
 
@@ -146,7 +149,7 @@ public IsolateProjectsTests(ITestOutputHelper testOutput)
             _buildParametersPrototype = new BuildParameters
             {
                 EnableNodeReuse = false,
-                IsolateProjects = true,
+                ProjectIsolationMode = ProjectIsolationMode.True,
                 DisableInProcNode = disableInProcNode
             };
         }
@@ -239,7 +242,130 @@ public void IsolationRelatedMessagesShouldNotBePresentInNonIsolatedBuilds()
                     logger.AssertLogDoesntContain("MSB4260");
                 },
                 excludeReferencesFromConstraints: true,
-                isolateProjects: false);
+                isolateProjects: ProjectIsolationMode.False);
+        }
+
+        [Fact]
+        public void IsolationRelatedMessageShouldBePresentInIsolatedBuildsWithMessaging()
+        {
+            AssertBuild(
+                new[] { "BuildDeclaredReference", "BuildUndeclaredReference" },
+                (result, logger) =>
+                {
+                    result.OverallResult.ShouldBe(BuildResultCode.Success);
+
+                    logger.ErrorCount.ShouldBe(0);
+                    logger.Errors.ShouldBeEmpty();
+
+                    // The references got built because the isolation mode is set to ProjectIsolationMode.MessageUponIsolationViolation.
+                    logger.AssertMessageCount("Message from reference", 2);
+                    logger.AllBuildEvents.OfType<ProjectStartedEventArgs>().Count().ShouldBe(3);
+
+                    logger.AssertMessageCount("MSB4260", 2);
+                },
+                isolateProjects: ProjectIsolationMode.MessageUponIsolationViolation);
+        }
+
+        [Fact]
+        public void UndeclaredReferenceBuildResultNotPresentInOutputCache()
+        {
+            // Create the graph 1 -> 2 -> 3, where 2 is a declared project reference
+            // and 3 is an undeclared project reference.
+            // 3 outputs an item UndeclaredReferenceTargetItem that 2 outputs.
+            // Run under ProjectIsolationMode.MessageUponIsolationViolation mode
+            // and verify that 3's build result is not present in 2's output results
+            // cache since, under this mode, only the results of the project
+            // to build under isolation (2) should be serialized.
+            // See CacheSerialization.SerializeCaches for more info.
+            string undeclaredReferenceFile = GraphTestingUtilities.CreateProjectFile(
+                _env,
+                3,
+                extraContent: @"
+                    <Target Name='UndeclaredReferenceTarget' Outputs='@(UndeclaredReferenceTargetItem)'>
+                        <ItemGroup>
+                            <UndeclaredReferenceTargetItem Include='Foo.cs' />
+                        </ItemGroup>
+                        <Message Text='Message from undeclared reference' Importance='High' />
+                    </Target>",
+                defaultTargets: "UndeclaredReferenceTarget").Path;
+            string declaredReferenceContents = string.Format(
+                @"
+                <Target Name='DeclaredReferenceTarget' Outputs='@(UndeclaredReferenceTargetItem)'>
+                    <MSBuild
+                        Projects='{0}'
+                        Targets='UndeclaredReferenceTarget'>
+                        <Output TaskParameter='TargetOutputs' ItemName='UndeclaredReferenceTargetItem' />
+                    </MSBuild>
+                </Target>".Cleanup(),
+                undeclaredReferenceFile).Cleanup();
+            string declaredReferenceFile = GraphTestingUtilities.CreateProjectFile(
+                _env,
+                2,
+                extraContent: declaredReferenceContents,
+                defaultTargets: "DeclaredReferenceTarget").Path;
+            string rootProjectContents = string.Format(
+                @"
+                <ItemGroup>
+                    <ProjectReference Include='{0}' />
+                </ItemGroup>
+                <Target Name='BuildDeclaredReference'>
+                    <MSBuild
+                        Projects='{1}'
+                        Targets='DeclaredReferenceTarget'
+                    />
+                </Target>".Cleanup(),
+                declaredReferenceFile,
+                declaredReferenceFile).Cleanup();
+            string rootFile = GraphTestingUtilities.CreateProjectFile(
+                _env,
+                1,
+                extraContent: rootProjectContents,
+                defaultTargets: "BuildDeclaredReference").Path;
+            var projectGraph = new ProjectGraph(
+                rootFile,
+                new Dictionary<string, string>(),
+                _env.CreateProjectCollection().Collection);
+            var expectedOutput = new ExpectedNodeBuildOutput();
+            var outputCaches = new OutputCacheDictionary();
+            ProjectGraphNode[] topoSortedProjectGraphNodes = projectGraph.ProjectNodesTopologicallySorted.ToArray();
+            Dictionary<string, (BuildResult Result, MockLogger Logger)> results = ResultCacheBasedBuilds_Tests.BuildUsingCaches(
+                _env,
+                topoSortedProjectGraphNodes,
+                expectedOutput,
+                outputCaches,
+                generateCacheFiles: true,
+                assertBuildResults: false,
+                projectIsolationMode: ProjectIsolationMode.MessageUponIsolationViolation);
+            var deserializedOutputCacheDeclaredReference = CacheSerialization.DeserializeCaches(outputCaches[topoSortedProjectGraphNodes[0]]);
+            var deserializedOutputCacheRoot = CacheSerialization.DeserializeCaches(outputCaches[topoSortedProjectGraphNodes[1]]);
+            deserializedOutputCacheDeclaredReference.exception.ShouldBeNull();
+            deserializedOutputCacheRoot.exception.ShouldBeNull();
+            BuildResult[] declaredReferenceBuildResults = deserializedOutputCacheDeclaredReference.ResultsCache.GetEnumerator().ToArray();
+            BuildResult[] rootBuildResults = deserializedOutputCacheRoot.ResultsCache.GetEnumerator().ToArray();
+
+            // Both the root and declared reference projects should only have one build result.
+            declaredReferenceBuildResults.Length.ShouldBe(1);
+            rootBuildResults.Length.ShouldBe(1);
+            declaredReferenceBuildResults[0].OverallResult.ShouldBe(BuildResultCode.Success);
+            rootBuildResults[0].OverallResult.ShouldBe(BuildResultCode.Success);
+            MockLogger rootLogger = results["1"].Logger;
+            MockLogger declaredReferenceLogger = results["2"].Logger;
+            rootLogger.ErrorCount.ShouldBe(0);
+            declaredReferenceLogger.ErrorCount.ShouldBe(0);
+            rootLogger.Errors.ShouldBeEmpty();
+            declaredReferenceLogger.Errors.ShouldBeEmpty();
+            rootLogger.AllBuildEvents.OfType<ProjectStartedEventArgs>().Count().ShouldBe(2);
+            declaredReferenceLogger.AllBuildEvents.OfType<ProjectStartedEventArgs>().Count().ShouldBe(2);
+
+            // One undeclared reference was built in isolation violation.
+            declaredReferenceLogger.AssertMessageCount("Message from undeclared reference", 1);
+            declaredReferenceLogger.AssertMessageCount("MSB4260", 1);
+
+            // The declared reference project's output item is that of the undeclared reference
+            // project.
+            declaredReferenceBuildResults[0]["DeclaredReferenceTarget"].Items.Length.ShouldBe(1);
+            declaredReferenceBuildResults[0]["DeclaredReferenceTarget"].Items[0].ItemSpec.ShouldBe("Foo.cs");
+            rootBuildResults[0]["BuildDeclaredReference"].Items.Length.ShouldBe(0);
         }
 
         [Theory]
@@ -385,7 +511,7 @@ private void AssertBuild(
             bool buildUndeclaredReference = false,
             bool addContinueOnError = false,
             bool excludeReferencesFromConstraints = false,
-            bool isolateProjects = true,
+            ProjectIsolationMode isolateProjects = ProjectIsolationMode.True,
             Func<string, string> projectReferenceModifier = null,
             Func<string, string> msbuildOnDeclaredReferenceModifier = null)
         {
@@ -411,7 +537,7 @@ private void AssertBuild(
             File.WriteAllText(undeclaredReferenceFile, _undeclaredReference);
 
             var buildParameters = _buildParametersPrototype.Clone();
-            buildParameters.IsolateProjects = isolateProjects;
+            buildParameters.ProjectIsolationMode = isolateProjects;
 
             using (var buildManagerSession = new Helpers.BuildManagerSession(_env, buildParameters))
             {
@@ -474,7 +600,7 @@ public void SkippedTargetsShouldNotTriggerCacheMissEnforcement()
 </Project>
 ".Cleanup()).Path;
 
-            _buildParametersPrototype.IsolateProjects.ShouldBeTrue();
+            _buildParametersPrototype.ProjectIsolationMode.ShouldBe(ProjectIsolationMode.True);
             var buildParameters = _buildParametersPrototype.Clone();
 
             using (var buildManagerSession = new Helpers.BuildManagerSession(_env, buildParameters))
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 841a48e4e64..d07f8cc81fc 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -1277,6 +1277,114 @@ public void GetTargetsListProjectReferenceTargetsOrDefaultComplexPropagation()
             }
         }
 
+        [Fact]
+        public void GetTargetsListSupportsTargetsMarkedSkipNonexistentTargets()
+        {
+            ProjectGraph graph = Helpers.CreateProjectGraph(
+                _env,
+                dependencyEdges: new Dictionary<int, int[]>
+                {
+                    { 1, new[] { 2 } },
+                },
+                extraContentPerProjectNumber: new Dictionary<int, string>
+                {
+                    {
+                        1,
+                        @"
+                          <ItemGroup>
+                            <ProjectReferenceTargets Include='Build' Targets='NonskippableTarget1' />
+                            <ProjectReferenceTargets Include='Build' Targets='NonskippableTarget2' SkipNonexistentTargets='false' />
+                            <ProjectReferenceTargets Include='Build' Targets='SkippableExistingTarget;SkippableNonexistentTarget' SkipNonexistentTargets='true' />
+                            <ProjectReference Include='2.proj' />
+                          </ItemGroup>
+                          <Target Name='Build'>
+                            <MSBuild Projects='2.proj' Targets='NonskippableTarget1; NonskippableTarget2' />
+                            <MSBuild Projects='2.proj' Targets='SkippableExistingTarget;SkippableNonexistentTarget' SkipNonexistentTargets='true' />
+                          </Target>"
+                    },
+                    {
+                        2,
+                        @"<Target Name='NonskippableTarget1'>
+                          </Target>
+                          <Target Name='NonskippableTarget2'>
+                          </Target>
+                          <Target Name='SkippableExistingTarget'>
+                          </Target>"
+                    },
+                });
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = graph.GetTargetLists(entryProjectTargets: new[] { "Build" });
+            targetLists[key: GetFirstNodeWithProjectNumber(graph: graph, projectNum: 1)].ShouldBe(expected: new[] { "Build" });
+            targetLists[key: GetFirstNodeWithProjectNumber(graph: graph, projectNum: 2)].ShouldBe(expected: new[] { "NonskippableTarget1", "NonskippableTarget2", "SkippableExistingTarget" });
+            Dictionary<string, (BuildResult Result, MockLogger Logger)> results = ResultCacheBasedBuilds_Tests.BuildUsingCaches(
+                _env,
+                topoSortedNodes: graph.ProjectNodesTopologicallySorted,
+                generateCacheFiles: true,
+                expectedNodeBuildOutput: new Dictionary<ProjectGraphNode, string[]>(),
+                outputCaches: new Dictionary<ProjectGraphNode, string>(),
+                assertBuildResults: false,
+                targetListsPerNode: targetLists);
+            foreach (KeyValuePair<string, (BuildResult Result, MockLogger Logger)> result in results)
+            {
+                result.Value.Result.OverallResult.ShouldBe(BuildResultCode.Success);
+            }
+        }
+
+        [Fact]
+        public void SkipNonexistentTargetsDoesNotHideMissedTargetResults()
+        {
+            ProjectGraph graph = Helpers.CreateProjectGraph(
+                env: _env,
+                dependencyEdges: new Dictionary<int, int[]>
+                {
+                    { 1, new[] { 2 } },
+                },
+                extraContentPerProjectNumber: new Dictionary<int, string>
+                {
+                    {
+                        1,
+                        @"
+                          <ItemGroup>
+                            <!-- NonskippableTarget2 is not specified in the target protocol, which should cause the build to fail -->
+                            <ProjectReferenceTargets Include='Build' Targets='NonskippableTarget1;SkippableExistingTarget;SkippableNonexistentTarget' SkipNonexistentTargets='true' />
+                            <ProjectReference Include='2.proj' />
+                          </ItemGroup>
+                          <Target Name='Build'>
+                            <MSBuild Projects='2.proj' Targets='NonskippableTarget1;NonskippableTarget2;SkippableExistingTarget;SkippableNonexistentTarget' SkipNonexistentTargets='true' />
+                          </Target>"
+                    },
+                    {
+                        2,
+                        @"<Target Name='NonskippableTarget1'>
+                          </Target>
+                          <Target Name='NonskippableTarget2'>
+                          </Target>
+                          <Target Name='SkippableExistingTarget'>
+                          </Target>"
+                    },
+                });
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = graph.GetTargetLists(entryProjectTargets: new[] { "Build" });
+            targetLists[key: GetFirstNodeWithProjectNumber(graph: graph, projectNum: 1)].ShouldBe(expected: new[] { "Build" });
+            targetLists[key: GetFirstNodeWithProjectNumber(graph: graph, projectNum: 2)].ShouldBe(expected: new[] { "NonskippableTarget1", "SkippableExistingTarget" });
+            Dictionary<string, (BuildResult Result, MockLogger Logger)> results = ResultCacheBasedBuilds_Tests.BuildUsingCaches(
+                env: _env,
+                topoSortedNodes: graph.ProjectNodesTopologicallySorted,
+                generateCacheFiles: true,
+                expectedNodeBuildOutput: new Dictionary<ProjectGraphNode, string[]>(),
+                outputCaches: new Dictionary<ProjectGraphNode, string>(),
+                assertBuildResults: false,
+                targetListsPerNode: targetLists);
+            results["2"].Result.OverallResult.ShouldBe(BuildResultCode.Success);
+            BuildResult project1BuildResult = results["1"].Result;
+            project1BuildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+            MockLogger project1MockLogger = results["1"].Logger;
+            project1MockLogger.ErrorCount.ShouldBe(1);
+            string project1ErrorMessage = project1MockLogger.Errors.First().Message;
+            project1ErrorMessage.ShouldContain("MSB4252");
+            project1ErrorMessage.ShouldContain("1.proj");
+            project1ErrorMessage.ShouldContain("2.proj");
+            project1ErrorMessage.ShouldContain(" with the (NonskippableTarget1;NonskippableTarget2;SkippableExistingTarget;SkippableNonexistentTarget) target(s) but the build result for the built project is not in the engine cache");
+        }
+
         [Fact]
         public void ReferencedMultitargetingEntryPointNodeTargetListContainsDefaultTarget()
         {
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index 59309f030e8..65ab4706791 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.Immutable;
 using System.IO;
 using System.Linq;
 using System.Text;
@@ -298,7 +299,7 @@ public void BuildProjectGraphUsingCaches(Dictionary<int, int[]> edges)
             var outputCaches = new OutputCacheDictionary();
 
             // Build unchanged project files using caches.
-            BuildUsingCaches(topoSortedNodes, expectedOutput, outputCaches, generateCacheFiles: true);
+            BuildUsingCaches(_env, topoSortedNodes, expectedOutput, outputCaches, generateCacheFiles: true);
 
             // Change the project files to remove all items.
             var collection = _env.CreateProjectCollection().Collection;
@@ -318,6 +319,7 @@ public void BuildProjectGraphUsingCaches(Dictionary<int, int[]> edges)
 
             // Build again using the first caches. Project file changes from references should not be visible.
             BuildUsingCaches(
+                _env,
                 topoSortedNodes,
                 expectedOutput,
                 outputCaches,
@@ -343,7 +345,7 @@ public void OutputCacheShouldNotContainInformationFromInputCaches()
 
             var outputCaches = new OutputCacheDictionary();
 
-            BuildUsingCaches(topoSortedNodes, expectedOutput, outputCaches, generateCacheFiles: true);
+            BuildUsingCaches(_env, topoSortedNodes, expectedOutput, outputCaches, generateCacheFiles: true);
 
             var rootNode = topoSortedNodes.First(n => Path.GetFileNameWithoutExtension(n.ProjectInstance.FullPath) == "1");
             var outputCache = outputCaches[rootNode];
@@ -381,12 +383,12 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
 
             var outputCaches = new OutputCacheDictionary();
 
-            BuildUsingCaches(topoSortedNodes, expectedOutput, outputCaches, generateCacheFiles: true);
+            BuildUsingCaches(_env, topoSortedNodes, expectedOutput, outputCaches, generateCacheFiles: true);
 
             // remove cache for project 3 to cause a cache miss
             outputCaches.Remove(expectedOutput.Keys.First(n => ProjectNumber(n) == "3"));
 
-            var results = BuildUsingCaches(topoSortedNodes, expectedOutput, outputCaches, generateCacheFiles: false, assertBuildResults: false);
+            var results = BuildUsingCaches(_env, topoSortedNodes, expectedOutput, outputCaches, generateCacheFiles: false, assertBuildResults: false);
 
             results["3"].Result.OverallResult.ShouldBe(BuildResultCode.Success);
             results["2"].Result.OverallResult.ShouldBe(BuildResultCode.Success);
@@ -408,21 +410,27 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
         /// When it is false, it uses the filled in <param name="outputCaches"/> and <param name="expectedNodeBuildOutput"/> to simulate a fully cached build.
         /// 
         /// </summary>
+        /// <param name="env">The test environment under which to run.</param>
         /// <param name="topoSortedNodes"></param>
         /// <param name="expectedNodeBuildOutput"></param>
         /// <param name="outputCaches"></param>
         /// <param name="generateCacheFiles"></param>
         /// <param name="assertBuildResults"></param>
         /// <param name="expectedOutputProducer"></param>
+        /// <param name="targetListsPerNode">The list of targets to build per node.</param>
+        /// <param name="projectIsolationMode">The isolation mode under which to run.</param>
         /// <returns></returns>
-        private Dictionary<string, (BuildResult Result, MockLogger Logger)> BuildUsingCaches(
+        internal static Dictionary<string, (BuildResult Result, MockLogger Logger)> BuildUsingCaches(
+            TestEnvironment env,
             IReadOnlyCollection<ProjectGraphNode> topoSortedNodes,
             ExpectedNodeBuildOutput expectedNodeBuildOutput,
             OutputCacheDictionary outputCaches,
             bool generateCacheFiles,
             bool assertBuildResults = true,
             // (current node, expected output dictionary) -> actual expected output for current node
-            Func<ProjectGraphNode, ExpectedNodeBuildOutput, string[]> expectedOutputProducer = null)
+            Func<ProjectGraphNode, ExpectedNodeBuildOutput, string[]> expectedOutputProducer = null,
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetListsPerNode = null,
+            ProjectIsolationMode projectIsolationMode = ProjectIsolationMode.False)
         {
             expectedOutputProducer ??= ((node, expectedOutputs) => expectedOutputs[node]);
 
@@ -445,23 +453,25 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
 
                 var buildParameters = new BuildParameters
                 {
-                    InputResultsCacheFiles = cacheFilesForReferences
+                    InputResultsCacheFiles = cacheFilesForReferences,
+                    ProjectIsolationMode = projectIsolationMode,
                 };
 
                 if (generateCacheFiles)
                 {
-                    outputCaches[node] = _env.DefaultTestDirectory.CreateFile($"OutputCache-{ProjectNumber(node)}").Path;
+                    outputCaches[node] = env.DefaultTestDirectory.CreateFile($"OutputCache-{ProjectNumber(node)}").Path;
                     buildParameters.OutputResultsCacheFile = outputCaches[node];
                 }
 
-                var logger = new MockLogger();
+                var logger = new MockLogger(env.Output);
 
                 buildParameters.Loggers = new[] { logger };
 
                 var result = BuildProjectFileUsingBuildManager(
                     node.ProjectInstance.FullPath,
                     null,
-                    buildParameters);
+                    buildParameters,
+                    targetListsPerNode?[node] != null ? targetListsPerNode?[node] : node.ProjectInstance.DefaultTargets);
 
                 results[ProjectNumber(node)] = (result, logger);
 
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 532f9b3e778..0c828f621ff 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -525,9 +525,14 @@ public void BeginBuild(BuildParameters parameters)
                 // Initialize additional build parameters.
                 _buildParameters.BuildId = GetNextBuildId();
 
-                if (_buildParameters.UsesCachedResults())
+                if (_buildParameters.UsesCachedResults() && parameters.ProjectIsolationMode == ProjectIsolationMode.False)
                 {
-                    _buildParameters.IsolateProjects = true;
+                    // If input or output caches are used and the project isolation mode is set to
+                    // ProjectIsolationMode.False, then set it to ProjectIsolationMode.True. The explicit
+                    // condition on ProjectIsolationMode is necessary to ensure that, if we're using input
+                    // or output caches and ProjectIsolationMode is set to ProjectIsolationMode.MessageUponIsolationViolation,
+                    // ProjectIsolationMode isn't changed to ProjectIsolationMode.True.
+                    _buildParameters.ProjectIsolationMode = ProjectIsolationMode.True;
                 }
 
                 if (_buildParameters.UsesOutputCache() && string.IsNullOrWhiteSpace(_buildParameters.OutputResultsCacheFile))
@@ -1053,8 +1058,11 @@ public void EndBuild()
 
             void SerializeCaches()
             {
-                var errorMessage = CacheSerialization.SerializeCaches(_configCache, _resultsCache, _buildParameters.OutputResultsCacheFile);
-
+                string errorMessage = CacheSerialization.SerializeCaches(
+                    _configCache,
+                    _resultsCache,
+                    _buildParameters.OutputResultsCacheFile,
+                    _buildParameters.ProjectIsolationMode);
                 if (!string.IsNullOrEmpty(errorMessage))
                 {
                     LogErrorAndShutdown(errorMessage);
@@ -1389,7 +1397,7 @@ private void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, Bui
                 ((IBuildComponentHost)this).LoggingService,
                 request.BuildEventContext,
                 false /* loaded by solution parser*/,
-                config.TargetNames,
+                config.RequestedTargets,
                 SdkResolverService,
                 request.SubmissionId);
 
@@ -2328,23 +2336,17 @@ private void HandleConfigurationRequest(int node, BuildRequestConfiguration unre
         /// </summary>
         private void HandleResult(int node, BuildResult result)
         {
-            // Update cache with the default and initial targets, as needed.
+            // Update cache with the default, initial, and project targets, as needed.
             BuildRequestConfiguration configuration = _configCache[result.ConfigurationId];
             if (result.DefaultTargets != null)
             {
-                // If the result has Default and Initial targets, we populate the configuration cache with them if it
+                // If the result has Default, Initial, and project targets, we populate the configuration cache with them if it
                 // doesn't already have entries.  This can happen if we created a configuration based on a request from
                 // an external node, but hadn't yet received a result since we may not have loaded the Project locally
-                // and thus wouldn't know what the default and initial targets were.
-                if (configuration.ProjectDefaultTargets == null)
-                {
-                    configuration.ProjectDefaultTargets = result.DefaultTargets;
-                }
-
-                if (configuration.ProjectInitialTargets == null)
-                {
-                    configuration.ProjectInitialTargets = result.InitialTargets;
-                }
+                // and thus wouldn't know what the default, initial, and project targets were.
+                configuration.ProjectDefaultTargets ??= result.DefaultTargets;
+                configuration.ProjectInitialTargets ??= result.InitialTargets;
+                configuration.ProjectTargets ??= result.ProjectTargets;
             }
 
             IEnumerable<ScheduleResponse> response = _scheduler.ReportResult(node, result);
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index a91ec457ef8..459814decca 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -212,7 +212,7 @@ public class BuildParameters : ITranslatable
 
         private bool _interactive;
 
-        private bool _isolateProjects;
+        private ProjectIsolationMode _projectIsolationMode;
 
         private string[] _inputResultsCacheFiles;
 
@@ -298,7 +298,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             WarningsAsMessages = other.WarningsAsMessages == null ? null : new HashSet<string>(other.WarningsAsMessages, StringComparer.OrdinalIgnoreCase);
             _projectLoadSettings = other._projectLoadSettings;
             _interactive = other._interactive;
-            _isolateProjects = other._isolateProjects;
+            _projectIsolationMode = other.ProjectIsolationMode;
             _inputResultsCacheFiles = other._inputResultsCacheFiles;
             _outputResultsCacheFile = other._outputResultsCacheFile;
             DiscardBuildResults = other.DiscardBuildResults;
@@ -760,17 +760,26 @@ public bool Interactive
         }
 
         /// <summary>
-        /// Gets or sets a value indicating whether projects should build in isolation.
+        /// Gets or sets a value indicating the isolation mode to use.
         /// </summary>
+        /// <remarks>
+        /// Kept for API backwards compatibility.
+        /// </remarks>
         public bool IsolateProjects
         {
-            get => _isolateProjects;
-            set => _isolateProjects = value;
+            get => ProjectIsolationMode == ProjectIsolationMode.True;
+            set => ProjectIsolationMode = value ? ProjectIsolationMode.True : ProjectIsolationMode.False;
         }
 
+        /// <summary>
+        /// Gets or sets a value indicating the isolation mode to use.
+        /// </summary>
+        public ProjectIsolationMode ProjectIsolationMode { get => _projectIsolationMode; set => _projectIsolationMode = value; }
+
         /// <summary>
         /// Input cache files that MSBuild will use to read build results from.
-        /// Setting this also turns on isolated builds.
+        /// If the isolation mode is set to <see cref="ProjectIsolationMode.False"/>,
+        /// this sets the isolation mode to <see cref="ProjectIsolationMode.True"/>.
         /// </summary>
         public string[] InputResultsCacheFiles
         {
@@ -780,7 +789,8 @@ public string[] InputResultsCacheFiles
 
         /// <summary>
         /// Output cache file where MSBuild will write the contents of its build result caches during EndBuild.
-        /// Setting this also turns on isolated builds.
+        /// If the isolation mode is set to <see cref="ProjectIsolationMode.False"/>,
+        /// this sets the isolation mode to <see cref="ProjectIsolationMode.True"/>.
         /// </summary>
         public string OutputResultsCacheFile
         {
@@ -828,7 +838,7 @@ public BuildParameters Clone()
 
         internal bool UsesInputCaches() => InputResultsCacheFiles != null;
 
-        internal bool SkippedResultsDoNotCauseCacheMiss() => IsolateProjects;
+        internal bool SkippedResultsDoNotCauseCacheMiss() => ProjectIsolationMode == ProjectIsolationMode.True;
 
         /// <summary>
         /// Implementation of the serialization mechanism.
@@ -861,7 +871,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _logInitialPropertiesAndItems);
             translator.TranslateEnum(ref _projectLoadSettings, (int)_projectLoadSettings);
             translator.Translate(ref _interactive);
-            translator.Translate(ref _isolateProjects);
+            translator.TranslateEnum(ref _projectIsolationMode, (int)_projectIsolationMode);
 
             // ProjectRootElementCache is not transmitted.
             // ResetCaches is not transmitted.
diff --git a/src/Build/BackEnd/BuildManager/CacheSerialization.cs b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
index d1864fef845..3fa59bfe28b 100644
--- a/src/Build/BackEnd/BuildManager/CacheSerialization.cs
+++ b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
@@ -13,7 +13,11 @@ namespace Microsoft.Build.Execution
 {
     internal static class CacheSerialization
     {
-        public static string SerializeCaches(IConfigCache configCache, IResultsCache resultsCache, string outputCacheFile)
+        public static string SerializeCaches(
+            IConfigCache configCache,
+            IResultsCache resultsCache,
+            string outputCacheFile,
+            ProjectIsolationMode projectIsolationMode)
         {
             ErrorUtilities.VerifyThrowInternalNull(outputCacheFile, nameof(outputCacheFile));
 
@@ -83,6 +87,19 @@ public static string SerializeCaches(IConfigCache configCache, IResultsCache res
                         resultsCacheToSerialize = tempResultsCacheToSerialize;
                     }
 
+                    if (projectIsolationMode == ProjectIsolationMode.MessageUponIsolationViolation)
+                    {
+                        int smallestConfigId = configCacheToSerialize.GetSmallestConfigId();
+
+                        // In MessageUponIsolationViolation mode, only keep the TargetResults for
+                        // top-level targets to mitigate the chances of an isolation-
+                        // violating target on a dependency project using incorrect state
+                        // due to its dependency on a cached target whose side effects would
+                        // not be taken into account. (E.g., the definition of a property.)
+                        resultsCacheToSerialize.GetResultsForConfiguration(smallestConfigId)
+                            .KeepSpecificTargetResults(configCacheToSerialize[smallestConfigId].RequestedTargets);
+                    }
+
                     translator.Translate(ref configCacheToSerialize);
                     translator.Translate(ref resultsCacheToSerialize);
                 }
diff --git a/src/Build/BackEnd/BuildManager/ProjectIsolationMode.cs b/src/Build/BackEnd/BuildManager/ProjectIsolationMode.cs
new file mode 100644
index 00000000000..31d5273b51b
--- /dev/null
+++ b/src/Build/BackEnd/BuildManager/ProjectIsolationMode.cs
@@ -0,0 +1,34 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Execution
+{
+    /// <summary>
+    /// The isolation mode to use.
+    /// </summary>
+    public enum ProjectIsolationMode
+    {
+        /// <summary>
+        /// Do not enable isolation.
+        /// </summary>
+        False,
+
+        /// <summary>
+        /// Enable isolation and log isolation violations as messages.
+        /// </summary>
+        /// <remarks>
+        /// Under this mode, only the results from top-level targets
+        /// are serialized if the -orc switch is supplied to mitigate
+        /// the chances of an isolation-violating target on a
+        /// dependency project using incorrect state due to its
+        /// dependency on a cached target whose side effects would
+        /// not be taken into account. (E.g., the definition of a property.)
+        /// </remarks>
+        MessageUponIsolationViolation,
+
+        /// <summary>
+        /// Enable isolation and log isolation violations as errors.
+        /// </summary>
+        True,
+    }
+}
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 99fff072659..250d4b4c8bf 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -809,6 +809,7 @@ private void EvaluateRequestStates()
                     // own cache.
                     completedEntry.Result.DefaultTargets = configuration.ProjectDefaultTargets;
                     completedEntry.Result.InitialTargets = configuration.ProjectInitialTargets;
+                    completedEntry.Result.ProjectTargets = configuration.ProjectTargets;
                 }
 
                 TraceEngine("ERS: Request is now {0}({1}) (nr {2}) has had its builder cleaned up.", completedEntry.Request.GlobalRequestId, completedEntry.Request.ConfigurationId, completedEntry.Request.NodeRequestId);
diff --git a/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs b/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs
index ce4d7e531a0..a0dcaa0c89f 100644
--- a/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs
+++ b/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs
@@ -50,7 +50,7 @@ public BuildRequestConfiguration this[int configId]
         {
             get
             {
-                if (_override.HasConfiguration(configId))
+                if (HasConfigurationInOverrideCache(configId))
                 {
 #if DEBUG
                     ErrorUtilities.VerifyThrow(!CurrentCache.HasConfiguration(configId), "caches should not overlap");
@@ -115,7 +115,7 @@ public BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata
 
         public bool HasConfiguration(int configId)
         {
-            var overrideHasConfiguration = _override.HasConfiguration(configId);
+            bool overrideHasConfiguration = HasConfigurationInOverrideCache(configId);
 
             if (overrideHasConfiguration)
             {
@@ -125,7 +125,12 @@ public bool HasConfiguration(int configId)
                 return overrideHasConfiguration;
             }
 
-            return _override.HasConfiguration(configId) || CurrentCache.HasConfiguration(configId);
+            return overrideHasConfiguration || CurrentCache.HasConfiguration(configId);
+        }
+
+        public bool HasConfigurationInOverrideCache(int configId)
+        {
+            return _override.HasConfiguration(configId);
         }
 
         public void ClearConfigurations()
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 607e0f576e4..5e2cac8e282 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -362,12 +362,14 @@ public async Task<BuildResult[]> BuildProjects(string[] projectFiles, PropertyDi
                 BuildRequestData data = new BuildRequestData(projectFiles[i], properties[i].ToDictionary(), explicitToolsVersion, targets, null);
 
                 BuildRequestConfiguration config = new BuildRequestConfiguration(data, _componentHost.BuildParameters.DefaultToolsVersion);
-
+                ProjectIsolationMode isolateProjects = _componentHost.BuildParameters.ProjectIsolationMode;
+                bool skipStaticGraphIsolationConstraints = (isolateProjects != ProjectIsolationMode.False && _requestEntry.RequestConfiguration.ShouldSkipIsolationConstraintsForReference(config.ProjectFullPath))
+                    || isolateProjects == ProjectIsolationMode.MessageUponIsolationViolation;
                 requests[i] = new FullyQualifiedBuildRequest(
                     config: config,
                     targets: targets,
                     resultsNeeded: waitForResults,
-                    skipStaticGraphIsolationConstraints: _componentHost.BuildParameters.IsolateProjects && _requestEntry.RequestConfiguration.ShouldSkipIsolationConstraintsForReference(config.ProjectFullPath),
+                    skipStaticGraphIsolationConstraints: skipStaticGraphIsolationConstraints,
                     flags: skipNonexistentTargets
                         ? BuildRequestDataFlags.SkipNonexistentTargets
                         : BuildRequestDataFlags.None);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 2fbe1580634..f90ce5d8024 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -1024,7 +1024,8 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
 
         private List<string> GetUndeclaredProjects(MSBuild msbuildTask)
         {
-            if (!_componentHost.BuildParameters.IsolateProjects)
+            ProjectIsolationMode isolateProjects = _componentHost.BuildParameters.ProjectIsolationMode;
+            if (isolateProjects == ProjectIsolationMode.False || isolateProjects == ProjectIsolationMode.MessageUponIsolationViolation)
             {
                 return null;
             }
@@ -1051,11 +1052,7 @@ private List<string> GetUndeclaredProjects(MSBuild msbuildTask)
                     !(declaredProjects.Contains(normalizedMSBuildProject)
                       || _buildRequestEntry.RequestConfiguration.ShouldSkipIsolationConstraintsForReference(normalizedMSBuildProject)))
                 {
-                    if (undeclaredProjects == null)
-                    {
-                        undeclaredProjects = new List<string>(projectReferenceItems.Count);
-                    }
-
+                    undeclaredProjects ??= new List<string>(projectReferenceItems.Count);
                     undeclaredProjects.Add(normalizedMSBuildProject);
                 }
             }
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 2dea902ef71..0c11f731cb5 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -364,9 +364,7 @@ public IEnumerable<ScheduleResponse> ReportResult(int nodeId, BuildResult result
             _schedulingData.EventTime = DateTime.UtcNow;
             List<ScheduleResponse> responses = new List<ScheduleResponse>();
             TraceScheduler("Reporting result from node {0} for request {1}, parent {2}.", nodeId, result.GlobalRequestId, result.ParentGlobalRequestId);
-
-            // Record these results to the cache.
-            _resultsCache.AddResult(result);
+            RecordResultToCurrentCacheIfConfigNotInOverrideCache(result);
 
             if (result.NodeRequestId == BuildRequest.ResultsTransferNodeRequestId)
             {
@@ -1961,13 +1959,15 @@ private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeF
         {
             emitNonErrorLogs = _ => { };
 
-            var isIsolatedBuild = _componentHost.BuildParameters.IsolateProjects;
+            ProjectIsolationMode isolateProjects = _componentHost.BuildParameters.ProjectIsolationMode;
             var configCache = (IConfigCache)_componentHost.GetComponent(BuildComponentType.ConfigCache);
 
             // do not check root requests as nothing depends on them
-            if (!isIsolatedBuild || request.IsRootRequest || request.SkipStaticGraphIsolationConstraints)
+            if (isolateProjects == ProjectIsolationMode.False || request.IsRootRequest || request.SkipStaticGraphIsolationConstraints
+                || SkipNonexistentTargetsIfExistentTargetsHaveResults(request))
             {
-                if (isIsolatedBuild && request.SkipStaticGraphIsolationConstraints)
+                bool logComment = ((isolateProjects == ProjectIsolationMode.True || isolateProjects == ProjectIsolationMode.MessageUponIsolationViolation) && request.SkipStaticGraphIsolationConstraints);
+                if (logComment)
                 {
                     // retrieving the configs is not quite free, so avoid computing them eagerly
                     var configs = GetConfigurations();
@@ -1976,14 +1976,14 @@ private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeF
                             NewBuildEventContext(),
                             MessageImportance.Normal,
                             "SkippedConstraintsOnRequest",
-                            configs.parentConfig.ProjectFullPath,
-                            configs.requestConfig.ProjectFullPath);
+                            configs.ParentConfig.ProjectFullPath,
+                            configs.RequestConfig.ProjectFullPath);
                 }
 
                 return true;
             }
 
-            var (requestConfig, parentConfig) = GetConfigurations();
+            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) = GetConfigurations();
 
             // allow self references (project calling the msbuild task on itself, potentially with different global properties)
             if (parentConfig.ProjectFullPath.Equals(requestConfig.ProjectFullPath, StringComparison.OrdinalIgnoreCase))
@@ -2022,20 +2022,20 @@ BuildEventContext NewBuildEventContext()
                     BuildEventContext.InvalidTaskId);
             }
 
-            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) GetConfigurations()
+            (BuildRequestConfiguration RequestConfig, BuildRequestConfiguration ParentConfig) GetConfigurations()
             {
-                var buildRequestConfiguration = configCache[request.ConfigurationId];
+                BuildRequestConfiguration buildRequestConfiguration = configCache[request.ConfigurationId];
 
                 // Need the parent request. It might be blocked or executing; check both.
-                var parentRequest = _schedulingData.BlockedRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId)
-                                    ?? _schedulingData.ExecutingRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);
+                SchedulableRequest parentRequest = _schedulingData.BlockedRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId)
+                    ?? _schedulingData.ExecutingRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);
 
                 ErrorUtilities.VerifyThrowInternalNull(parentRequest, nameof(parentRequest));
                 ErrorUtilities.VerifyThrow(
                     configCache.HasConfiguration(parentRequest.BuildRequest.ConfigurationId),
                     "All non root requests should have a parent with a loaded configuration");
 
-                var parentConfiguration = configCache[parentRequest.BuildRequest.ConfigurationId];
+                BuildRequestConfiguration parentConfiguration = configCache[parentRequest.BuildRequest.ConfigurationId];
                 return (buildRequestConfiguration, parentConfiguration);
             }
 
@@ -2043,6 +2043,57 @@ string ConcatenateGlobalProperties(BuildRequestConfiguration configuration)
             {
                 return string.Join("; ", configuration.GlobalProperties.Select<ProjectPropertyInstance, string>(p => $"{p.Name}={p.EvaluatedValue}"));
             }
+
+            bool SkipNonexistentTargetsIfExistentTargetsHaveResults(BuildRequest buildRequest)
+            {
+                // Return early if the top-level target(s) of this build request weren't requested to be skipped if nonexistent.
+                if ((buildRequest.BuildRequestDataFlags & BuildRequestDataFlags.SkipNonexistentTargets) != BuildRequestDataFlags.SkipNonexistentTargets)
+                {
+                    return false;
+                }
+
+                BuildResult requestResults = _resultsCache.GetResultsForConfiguration(buildRequest.ConfigurationId);
+
+                // On a self-referenced build, cache misses are allowed.
+                if (requestResults == null)
+                {
+                    return false;
+                }
+
+                // A cache miss on at least one existing target without results is disallowed,
+                // as it violates isolation constraints.
+                foreach (string target in request.Targets)
+                {
+                    if (_configCache[buildRequest.ConfigurationId]
+                        .ProjectTargets
+                        .Contains(target) &&
+                        !requestResults.HasResultsForTarget(target))
+                    {
+                        return false;
+                    }
+                }
+
+                // A cache miss on nonexistent targets on the reference is allowed, given the request
+                // to skip nonexistent targets.
+                return true;
+            }
+        }
+
+        /// <summary>
+        /// Records the result to the current cache if its config isn't in the override cache.
+        /// </summary>
+        /// <param name="result">The result to potentially record in the current cache.</param>
+        internal void RecordResultToCurrentCacheIfConfigNotInOverrideCache(BuildResult result)
+        {
+            // Record these results to the current cache only if their config isn't in the
+            // override cache, which can happen if we are building in the project isolation mode
+            // ProjectIsolationMode.MessageUponIsolationViolation, and the received result was built by an
+            // isolation-violating dependency project.
+            if (_configCache is not ConfigCacheWithOverride configCacheWithOverride
+                || !configCacheWithOverride.HasConfigurationInOverrideCache(result.ConfigurationId))
+            {
+                _resultsCache.AddResult(result);
+            }
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index b1616f43858..b720431fc5e 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -107,6 +107,11 @@ internal class BuildRequestConfiguration : IEquatable<BuildRequestConfiguration>
         /// </summary>
         private List<string> _projectDefaultTargets;
 
+        /// <summary>
+        /// The defined targets for the project.
+        /// </summary>
+        private HashSet<string> _projectTargets;
+
         /// <summary>
         /// This is the lookup representing the current project items and properties 'state'.
         /// </summary>
@@ -138,7 +143,7 @@ internal class BuildRequestConfiguration : IEquatable<BuildRequestConfiguration>
         /// <summary>
         /// The target names that were requested to execute.
         /// </summary>
-        internal IReadOnlyCollection<string> TargetNames { get; }
+        internal IReadOnlyCollection<string> RequestedTargets { get; }
 
         /// <summary>
         /// Initializes a configuration from a BuildRequestData structure.  Used by the BuildManager.
@@ -170,7 +175,7 @@ internal BuildRequestConfiguration(int configId, BuildRequestData data, string d
             _explicitToolsVersionSpecified = data.ExplicitToolsVersionSpecified;
             _toolsVersion = ResolveToolsVersion(data, defaultToolsVersion);
             _globalProperties = data.GlobalPropertiesDictionary;
-            TargetNames = new List<string>(data.TargetNames);
+            RequestedTargets = new List<string>(data.TargetNames);
 
             // The following information only exists when the request is populated with an existing project.
             if (data.ProjectInstance != null)
@@ -178,7 +183,7 @@ internal BuildRequestConfiguration(int configId, BuildRequestData data, string d
                 _project = data.ProjectInstance;
                 _projectInitialTargets = data.ProjectInstance.InitialTargets;
                 _projectDefaultTargets = data.ProjectInstance.DefaultTargets;
-
+                _projectTargets = GetProjectTargets(data.ProjectInstance.Targets);
                 if (data.PropertiesToTransfer != null)
                 {
                     _transferredProperties = new List<ProjectPropertyInstance>();
@@ -215,6 +220,7 @@ internal BuildRequestConfiguration(int configId, ProjectInstance instance)
             _project = instance;
             _projectInitialTargets = instance.InitialTargets;
             _projectDefaultTargets = instance.DefaultTargets;
+            _projectTargets = GetProjectTargets(instance.Targets);
             IsCacheable = false;
         }
 
@@ -231,13 +237,14 @@ private BuildRequestConfiguration(int configId, BuildRequestConfiguration other)
             _transferredProperties = other._transferredProperties;
             _projectDefaultTargets = other._projectDefaultTargets;
             _projectInitialTargets = other._projectInitialTargets;
+            _projectTargets = other._projectTargets;
             _projectFullPath = other._projectFullPath;
             _toolsVersion = other._toolsVersion;
             _explicitToolsVersionSpecified = other._explicitToolsVersionSpecified;
             _globalProperties = other._globalProperties;
             IsCacheable = other.IsCacheable;
             _configId = configId;
-            TargetNames = other.TargetNames;
+            RequestedTargets = other.RequestedTargets;
         }
 
         /// <summary>
@@ -404,9 +411,11 @@ private void SetProjectBasedState(ProjectInstance project)
             // Clear these out so the other accessors don't complain.  We don't want to generally enable resetting these fields.
             _projectDefaultTargets = null;
             _projectInitialTargets = null;
+            _projectTargets = null;
 
             ProjectDefaultTargets = _project.DefaultTargets;
             ProjectInitialTargets = _project.InitialTargets;
+            ProjectTargets = GetProjectTargets(_project.Targets);
 
             if (IsCached)
             {
@@ -548,6 +557,23 @@ public List<string> ProjectDefaultTargets
             }
         }
 
+        /// <summary>
+        /// Gets or sets the targets defined for the project.
+        /// </summary>
+        internal HashSet<string> ProjectTargets
+        {
+            [DebuggerStepThrough]
+            get => _projectTargets;
+            [DebuggerStepThrough]
+            set
+            {
+                ErrorUtilities.VerifyThrow(
+                    _projectTargets == null,
+                    "Targets cannot be reset once set.");
+                _projectTargets = value;
+            }
+        }
+
         /// <summary>
         /// Returns the node packet type
         /// </summary>
@@ -879,6 +905,7 @@ internal void TranslateForFutureUse(ITranslator translator)
             translator.Translate(ref _explicitToolsVersionSpecified);
             translator.Translate(ref _projectDefaultTargets);
             translator.Translate(ref _projectInitialTargets);
+            translator.Translate(ref _projectTargets);
             translator.TranslateDictionary(ref _globalProperties, ProjectPropertyInstance.FactoryForDeserialization);
         }
 
@@ -961,6 +988,13 @@ private bool InternalEquals(BuildRequestConfiguration other)
             }
         }
 
+        /// <summary>
+        /// Gets the set of project targets for this <see cref="BuildRequestConfiguration"/>.
+        /// </summary>
+        /// <param name="projectTargets">The project targets to transform into a set.</param>
+        /// <returns>The set of project targets for this <see cref="BuildRequestConfiguration"/>.</returns>
+        private HashSet<string> GetProjectTargets(IDictionary<string, ProjectTargetInstance> projectTargets) => projectTargets.Keys.ToHashSet();
+
         /// <summary>
         /// Determines what the real tools version is.
         /// </summary>
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 414eb216ed6..ca443451880 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -5,6 +5,7 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Linq;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -117,6 +118,8 @@ public class BuildResult : INodePacket, IBuildResults
 
         private string _schedulerInducedError;
 
+        private HashSet<string> _projectTargets;
+
         /// <summary>
         /// Constructor for serialization.
         /// </summary>
@@ -228,6 +231,7 @@ internal BuildResult(BuildResult result, int nodeRequestId)
             _circularDependency = result._circularDependency;
             _initialTargets = result._initialTargets;
             _defaultTargets = result._defaultTargets;
+            _projectTargets = result._projectTargets;
             _baseOverallResult = result.OverallResult == BuildResultCode.Success;
         }
 
@@ -244,6 +248,7 @@ internal BuildResult(BuildResult result, int submissionId, int configurationId,
             _circularDependency = result._circularDependency;
             _initialTargets = result._initialTargets;
             _defaultTargets = result._defaultTargets;
+            _projectTargets = result._projectTargets;
             _baseOverallResult = result.OverallResult == BuildResultCode.Success;
         }
 
@@ -433,6 +438,17 @@ internal List<string> DefaultTargets
             { _defaultTargets = value; }
         }
 
+        /// <summary>
+        /// The defined targets for the project associated with this build result.
+        /// </summary>
+        internal HashSet<string> ProjectTargets
+        {
+            [DebuggerStepThrough]
+            get => _projectTargets;
+            [DebuggerStepThrough]
+            set => _projectTargets = value;
+        }
+
         /// <summary>
         /// Container used to transport errors from the scheduler (issued while computing a build result)
         /// to the TaskHost that has the proper logging context (project id, target id, task id, file location)
@@ -480,6 +496,25 @@ public void AddResultsForTarget(string target, TargetResult result)
             _resultsByTarget[target] = result;
         }
 
+        /// <summary>
+        /// Keep the results only for targets in <paramref name="targetsToKeep"/>.
+        /// </summary>
+        /// <param name="targetsToKeep">The targets whose results to keep.</param>
+        internal void KeepSpecificTargetResults(IReadOnlyCollection<string> targetsToKeep)
+        {
+            ErrorUtilities.VerifyThrow(
+                targetsToKeep.Count > 0,
+                $"{nameof(targetsToKeep)} should contain at least one target.");
+
+            foreach (string target in _resultsByTarget.Keys)
+            {
+                if (!targetsToKeep.Contains(target))
+                {
+                    _ = _resultsByTarget.TryRemove(target, out _);
+                }
+            }
+        }
+
         /// <summary>
         /// Merges the specified results with the results contained herein.
         /// </summary>
@@ -537,6 +572,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _nodeRequestId);
             translator.Translate(ref _initialTargets);
             translator.Translate(ref _defaultTargets);
+            translator.Translate(ref _projectTargets);
             translator.Translate(ref _circularDependency);
             translator.TranslateException(ref _requestException);
             translator.TranslateDictionary(ref _resultsByTarget, TargetResult.FactoryForDeserialization, CreateTargetResultDictionary);
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 389f8c6459b..eed1d5872a3 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -152,7 +152,8 @@ internal TaskExecutionHost(IBuildComponentHost host)
         }
 
         /// <summary>
-        /// Constructor, for unit testing only.  
+        /// Initializes a new instance of the <see cref="TaskExecutionHost"/> class
+        /// for unit testing only.
         /// </summary>
         internal TaskExecutionHost()
         {
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index 35b57e90b01..fa1642fb36b 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -63,6 +63,25 @@ public ReferenceInfo(ConfigurationMetadata referenceConfiguration, ProjectItemIn
             }
         }
 
+        private readonly struct TargetSpecification
+        {
+            public TargetSpecification(string target, bool skipIfNonexistent)
+            {
+                // Verify that if this target is skippable then it equals neither 
+                // ".default" nor ".projectReferenceTargetsOrDefaultTargets".
+                ErrorUtilities.VerifyThrow(
+                    !skipIfNonexistent || (!target.Equals(MSBuildConstants.DefaultTargetsMarker)
+                    && !target.Equals(MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker)),
+                    target + " cannot be marked as SkipNonexistentTargets");
+                Target = target;
+                SkipIfNonexistent = skipIfNonexistent;
+            }
+
+            public string Target { get; }
+
+            public bool SkipIfNonexistent { get; }
+        }
+
         public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstance, ProjectCollection _projectCollection, ProjectGraph.ProjectInstanceFactoryFunc _projectInstanceFactory)
         {
             IEnumerable<ProjectItemInstance> projectReferenceItems;
@@ -391,10 +410,10 @@ private static void RemoveFromPropertyDictionary(
 
         public readonly struct TargetsToPropagate
         {
-            private readonly ImmutableList<string> _outerBuildTargets;
-            private readonly ImmutableList<string> _allTargets;
+            private readonly ImmutableList<TargetSpecification> _outerBuildTargets;
+            private readonly ImmutableList<TargetSpecification> _allTargets;
 
-            private TargetsToPropagate(ImmutableList<string> outerBuildTargets, ImmutableList<string> nonOuterBuildTargets)
+            private TargetsToPropagate(ImmutableList<TargetSpecification> outerBuildTargets, ImmutableList<TargetSpecification> nonOuterBuildTargets)
             {
                 _outerBuildTargets = outerBuildTargets;
 
@@ -416,23 +435,22 @@ private TargetsToPropagate(ImmutableList<string> outerBuildTargets, ImmutableLis
             /// <returns></returns>
             public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance project, ImmutableList<string> entryTargets)
             {
-                var targetsForOuterBuild = ImmutableList.CreateBuilder<string>();
-                var targetsForInnerBuild = ImmutableList.CreateBuilder<string>();
+                ImmutableList<TargetSpecification>.Builder targetsForOuterBuild = ImmutableList.CreateBuilder<TargetSpecification>();
+                ImmutableList<TargetSpecification>.Builder targetsForInnerBuild = ImmutableList.CreateBuilder<TargetSpecification>();
 
-                var projectReferenceTargets = project.GetItems(ItemTypeNames.ProjectReferenceTargets);
+                ICollection<ProjectItemInstance> projectReferenceTargets = project.GetItems(ItemTypeNames.ProjectReferenceTargets);
 
-                foreach (var entryTarget in entryTargets)
+                foreach (string entryTarget in entryTargets)
                 {
-                    foreach (var projectReferenceTarget in projectReferenceTargets)
+                    foreach (ProjectItemInstance projectReferenceTarget in projectReferenceTargets)
                     {
                         if (projectReferenceTarget.EvaluatedInclude.Equals(entryTarget, StringComparison.OrdinalIgnoreCase))
                         {
-                            var targetsMetadataValue = projectReferenceTarget.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
-
-                            var targetsAreForOuterBuild = MSBuildStringIsTrue(projectReferenceTarget.GetMetadataValue(ProjectReferenceTargetIsOuterBuildMetadataName));
-
-                            var targets = ExpressionShredder.SplitSemiColonSeparatedList(targetsMetadataValue).ToArray();
-
+                            string targetsMetadataValue = projectReferenceTarget.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
+                            bool skipNonexistentTargets = MSBuildStringIsTrue(projectReferenceTarget.GetMetadataValue("SkipNonexistentTargets"));
+                            bool targetsAreForOuterBuild = MSBuildStringIsTrue(projectReferenceTarget.GetMetadataValue(ProjectReferenceTargetIsOuterBuildMetadataName));
+                            TargetSpecification[] targets = ExpressionShredder.SplitSemiColonSeparatedList(targetsMetadataValue)
+                                .Select(t => new TargetSpecification(t, skipNonexistentTargets)).ToArray();
                             if (targetsAreForOuterBuild)
                             {
                                 targetsForOuterBuild.AddRange(targets);
@@ -450,11 +468,20 @@ public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance proj
 
             public ImmutableList<string> GetApplicableTargetsForReference(ProjectInstance reference)
             {
-                return (GetProjectType(reference)) switch
+                ImmutableList<string> RemoveNonexistentTargetsIfSkippable(ImmutableList<TargetSpecification> targets)
+                {
+                    // Keep targets that are non-skippable or that exist but are skippable.
+                    return targets
+                        .Where(t => !t.SkipIfNonexistent || reference.Targets.ContainsKey(t.Target))
+                        .Select(t => t.Target)
+                        .ToImmutableList();
+                }
+
+                return GetProjectType(reference) switch
                 {
-                    ProjectType.InnerBuild => _allTargets,
-                    ProjectType.OuterBuild => _outerBuildTargets,
-                    ProjectType.NonMultitargeting => _allTargets,
+                    ProjectType.InnerBuild => RemoveNonexistentTargetsIfSkippable(_allTargets),
+                    ProjectType.OuterBuild => RemoveNonexistentTargetsIfSkippable(_outerBuildTargets),
+                    ProjectType.NonMultitargeting => RemoveNonexistentTargetsIfSkippable(_allTargets),
                     _ => throw new ArgumentOutOfRangeException(),
                 };
             }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 35780421fb1..fe944b6e87f 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -65,6 +65,7 @@ public sealed class BinaryLogger : ILogger
         private ProjectImportsCollector projectImportsCollector;
         private string _initialTargetOutputLogging;
         private bool _initialLogImports;
+        private string _initialIsBinaryLoggerEnabled;
 
         /// <summary>
         /// Describes whether to collect the project files (including imported project files) used during the build.
@@ -114,9 +115,12 @@ public void Initialize(IEventSource eventSource)
         {
             _initialTargetOutputLogging = Environment.GetEnvironmentVariable("MSBUILDTARGETOUTPUTLOGGING");
             _initialLogImports = Traits.Instance.EscapeHatches.LogProjectImports;
+            _initialIsBinaryLoggerEnabled = Environment.GetEnvironmentVariable("MSBUILDBINARYLOGGERENABLED");
 
             Environment.SetEnvironmentVariable("MSBUILDTARGETOUTPUTLOGGING", "true");
             Environment.SetEnvironmentVariable("MSBUILDLOGIMPORTS", "1");
+            Environment.SetEnvironmentVariable("MSBUILDBINARYLOGGERENABLED", bool.TrueString);
+
             Traits.Instance.EscapeHatches.LogProjectImports = true;
             bool logPropertiesAndItemsAfterEvaluation = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation ?? true;
 
@@ -214,6 +218,8 @@ public void Shutdown()
         {
             Environment.SetEnvironmentVariable("MSBUILDTARGETOUTPUTLOGGING", _initialTargetOutputLogging);
             Environment.SetEnvironmentVariable("MSBUILDLOGIMPORTS", _initialLogImports ? "1" : "");
+            Environment.SetEnvironmentVariable("MSBUILDBINARYLOGGERENABLED", _initialIsBinaryLoggerEnabled);
+
             Traits.Instance.EscapeHatches.LogProjectImports = _initialLogImports;
 
             if (projectImportsCollector != null)
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 6e13af19356..f2bd969073c 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -148,6 +148,7 @@
     <Compile Include="BackEnd\BuildManager\BuildParameters.cs" />
     <Compile Include="BackEnd\BuildManager\CacheSerialization.cs" />
     <Compile Include="BackEnd\BuildManager\CacheAggregator.cs" />
+    <Compile Include="BackEnd\BuildManager\ProjectIsolationMode.cs" />
     <Compile Include="BackEnd\Client\MSBuildClientPacketPump.cs" />
     <Compile Include="BackEnd\Client\MSBuildClientExitType.cs" />
     <Compile Include="BackEnd\Client\MSBuildClientExitResult.cs" />
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index b5bdead5c07..bdf84b30922 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -195,6 +195,21 @@ internal enum ProcessorArchitectures
         // ARM64
         ARM64,
 
+        // WebAssembly
+        WASM,
+
+        // S390x
+        S390X,
+
+        // LongAarch64
+        LOONGARCH64,
+
+        // 32-bit ARMv6
+        ARMV6,
+
+        // PowerPC 64-bit (little-endian) 
+        PPC64LE,
+
         // Who knows
         Unknown
     }
@@ -435,7 +450,8 @@ public SystemInformationData()
             else
             {
                 ProcessorArchitectures processorArchitecture = ProcessorArchitectures.Unknown;
-#if !NET35
+
+#if NETCOREAPP || NETSTANDARD1_1_OR_GREATER
                 // Get the architecture from the runtime.
                 processorArchitecture = RuntimeInformation.OSArchitecture switch
                 {
@@ -443,64 +459,21 @@ public SystemInformationData()
                     Architecture.Arm64 => ProcessorArchitectures.ARM64,
                     Architecture.X64 => ProcessorArchitectures.X64,
                     Architecture.X86 => ProcessorArchitectures.X86,
+#if NET5_0_OR_GREATER
+                    Architecture.Wasm => ProcessorArchitectures.WASM,
+#endif
+#if NET6_0_OR_GREATER
+                    Architecture.S390x => ProcessorArchitectures.S390X,
+#endif
+#if NET7_0_OR_GREATER
+                    Architecture.LoongArch64 => ProcessorArchitectures.LOONGARCH64,
+                    Architecture.Armv6 => ProcessorArchitectures.ARMV6,
+                    Architecture.Ppc64le => ProcessorArchitectures.PPC64LE,
+#endif
                     _ => ProcessorArchitectures.Unknown,
                 };
-#endif
-                // Fall back to 'uname -m' to get the architecture.
-                if (processorArchitecture == ProcessorArchitectures.Unknown)
-                {
-                    try
-                    {
-                        // On Unix run 'uname -m' to get the architecture. It's common for Linux and Mac
-                        using (
-                            var proc =
-                                Process.Start(
-                                    new ProcessStartInfo("uname")
-                                    {
-                                        Arguments = "-m",
-                                        UseShellExecute = false,
-                                        RedirectStandardOutput = true,
-                                        CreateNoWindow = true
-                                    }))
-                        {
-                            string arch = null;
-                            if (proc != null)
-                            {
-                                arch = proc.StandardOutput.ReadLine();
-                                proc.WaitForExit();
-                            }
 
-                            if (!string.IsNullOrEmpty(arch))
-                            {
-                                if (arch.StartsWith("x86_64", StringComparison.OrdinalIgnoreCase))
-                                {
-                                    ProcessorArchitectureType = ProcessorArchitectures.X64;
-                                }
-                                else if (arch.StartsWith("ia64", StringComparison.OrdinalIgnoreCase))
-                                {
-                                    ProcessorArchitectureType = ProcessorArchitectures.IA64;
-                                }
-                                else if (arch.StartsWith("arm", StringComparison.OrdinalIgnoreCase))
-                                {
-                                    ProcessorArchitectureType = ProcessorArchitectures.ARM;
-                                }
-                                else if (arch.StartsWith("aarch64", StringComparison.OrdinalIgnoreCase))
-                                {
-                                    ProcessorArchitectureType = ProcessorArchitectures.ARM64;
-                                }
-                                else if (arch.StartsWith("i", StringComparison.OrdinalIgnoreCase)
-                                        && arch.EndsWith("86", StringComparison.OrdinalIgnoreCase))
-                                {
-                                    ProcessorArchitectureType = ProcessorArchitectures.X86;
-                                }
-                            }
-                        }
-                    }
-                    catch
-                    {
-                        // Best effort: fall back to Unknown
-                    }
-                }
+#endif
 
                 ProcessorArchitectureTypeNative = ProcessorArchitectureType = processorArchitecture;
             }
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 71fbd6ff54e..ca52d2e3156 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -10,6 +10,7 @@
 using System.Resources;
 using Microsoft.Build.CommandLine;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
 using Microsoft.Build.Shared;
@@ -1019,7 +1020,7 @@ public void InvalidToolsVersionErrors()
                                         profilerLogger: null,
                                         enableProfiler: false,
                                         interactive: false,
-                                        isolateProjects: false,
+                                        isolateProjects: ProjectIsolationMode.False,
                                         graphBuildOptions: null,
                                         lowPriority: false,
                                         inputResultsCaches: null,
diff --git a/src/MSBuild/LiveLogger/ANSIBuilder.cs b/src/MSBuild/LiveLogger/ANSIBuilder.cs
index 39cac24db2b..a5004f3931d 100644
--- a/src/MSBuild/LiveLogger/ANSIBuilder.cs
+++ b/src/MSBuild/LiveLogger/ANSIBuilder.cs
@@ -9,7 +9,7 @@ namespace Microsoft.Build.Logging.LiveLogger
 {
     internal static class ANSIBuilder
     {
-        public static string ANSIRegex = @"\x1b(?:[@-Z\-_]|\[[0-?]*[ -\/]*[@-~])";
+        public static string ANSIRegex = @"\x1b(?:[@-Z\-_]|\[[0-?]*[ -\/]*[@-~]|(?:\]8;;.*?\x1b\\))";
         // TODO: This should replace ANSIRegex once LiveLogger's API is internal
         public static Regex ANSIRegexRegex = new Regex(ANSIRegex);
         public static string ANSIRemove(string text)
@@ -17,6 +17,12 @@ public static string ANSIRemove(string text)
             return ANSIRegexRegex.Replace(text, "");
         }
 
+        /// <summary>
+        /// Find a place to break a string after a number of visible characters, not counting VT-100 codes.
+        /// </summary>
+        /// <param name="text">String to split.</param>
+        /// <param name="position">Number of visible characters to split after.</param>
+        /// <returns>Index in <paramref name="text"/> that represents <paramref name="position"/> visible characters.</returns>
         // TODO: This should be an optional parameter for ANSIBreakpoint(string text, int positioon, int initialPosition = 0)
         public static int ANSIBreakpoint(string text, int position)
         {
@@ -29,34 +35,33 @@ public static int ANSIBreakpoint(string text, int position, int initialPosition)
                 return text.Length;
             }
             int nonAnsiIndex = 0;
-            // Match nextMatch = Regex.Match(text, ANSIRegex);
             Match nextMatch = ANSIRegexRegex.Match(text, initialPosition);
-            int i = 0;
-            while (i < text.Length && nonAnsiIndex != position)
+            int logicalIndex = 0;
+            while (logicalIndex < text.Length && nonAnsiIndex != position)
             {
                 // Jump over ansi codes
-                if (i == nextMatch.Index && nextMatch.Length > 0)
+                if (logicalIndex == nextMatch.Index && nextMatch.Length > 0)
                 {
-                    i += nextMatch.Length;
+                    logicalIndex += nextMatch.Length;
                     nextMatch = nextMatch.NextMatch();
                 }
                 // Increment non ansi index
                 nonAnsiIndex++;
-                i++;
+                logicalIndex++;
             }
-            return i;
+            return logicalIndex;
         }
 
-        public static List<string> ANSIWrap(string text, int position)
+        public static List<string> ANSIWrap(string text, int maxLength)
         {
             ReadOnlySpan<char> textSpan = text.AsSpan();
             List<string> result = new();
-            int breakpoint = ANSIBreakpoint(text, position);
+            int breakpoint = ANSIBreakpoint(text, maxLength);
             while (textSpan.Length > breakpoint)
             {
                 result.Add(textSpan.Slice(0, breakpoint).ToString());
                 textSpan = textSpan.Slice(breakpoint);
-                breakpoint = ANSIBreakpoint(text, position, breakpoint);
+                breakpoint = ANSIBreakpoint(text, maxLength, breakpoint);
             }
             result.Add(textSpan.ToString());
             return result;
@@ -115,12 +120,12 @@ public static string SpaceBetween(string leftText, string rightText, int width)
                 string result = String.Empty;
                 string leftNoFormatString = ANSIRemove(leftText);
                 string rightNoFormatString = ANSIRemove(rightText);
-                if (leftNoFormatString.Length + rightNoFormatString.Length > Console.BufferWidth)
+                if (leftNoFormatString.Length + rightNoFormatString.Length >= width)
                 {
                     return leftText + rightText;
                 }
 
-                int space = Console.BufferWidth - (leftNoFormatString.Length + rightNoFormatString.Length);
+                int space = width - (leftNoFormatString.Length + rightNoFormatString.Length);
                 result += leftText;
                 result += new string(' ', space - 1);
                 result += rightText;
@@ -216,11 +221,10 @@ public static string Overlined(string text)
                 return String.Format("\x1b[53m{0}\x1b[55m", text);
             }
 
-            // TODO: Right now only replaces \ with /. Needs review to make sure it works on all or most terminal emulators.
-            public static string Hyperlink(string text, string url)
+            public static string Hyperlink(string text, string rawUrl)
             {
-                // return String.Format("\x1b[]8;;{0}\x1b\\{1}\x1b[]8;\x1b\\", text, url);
-                return url.Replace("\\", "/");
+                string url = rawUrl.Length > 0 ? new System.Uri(rawUrl).AbsoluteUri : rawUrl;
+                return $"\x1b]8;;{url}\x1b\\{text}\x1b]8;;\x1b\\";
             }
 
             public static string DECLineDrawing(string text)
diff --git a/src/MSBuild/LiveLogger/LiveLogger.cs b/src/MSBuild/LiveLogger/LiveLogger.cs
index 0694fa41f89..1dcbe2080bb 100644
--- a/src/MSBuild/LiveLogger/LiveLogger.cs
+++ b/src/MSBuild/LiveLogger/LiveLogger.cs
@@ -1,4 +1,4 @@
-// Licensed to the .NET Foundation under one or more agreements.
+﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -13,12 +13,9 @@ internal class LiveLogger : ILogger
         private Dictionary<int, ProjectNode> projects = new Dictionary<int, ProjectNode>();
 
         private bool Succeeded;
-
-        private float existingTasks = 1;
-        private float completedTasks = 0;
-
         public string Parameters { get; set; }
-
+        public int StartedProjects = 0;
+        public int FinishedProjects = 0;
         public LoggerVerbosity Verbosity { get; set; }
 
         public LiveLogger()
@@ -101,6 +98,15 @@ private void Render()
             }
         }
 
+        private void UpdateFooter()
+        {
+            float percentage = (float)FinishedProjects / StartedProjects;
+            TerminalBuffer.FooterText = ANSIBuilder.Alignment.SpaceBetween(
+                $"Build progress (approx.) [{ANSIBuilder.Graphics.ProgressBar(percentage)}]",
+                ANSIBuilder.Formatting.Italic(ANSIBuilder.Formatting.Dim("[Up][Down] Scroll")),
+                Console.BufferWidth);
+        }
+
         // Build
         private void eventSource_BuildStarted(object sender, BuildStartedEventArgs e)
         {
@@ -114,6 +120,7 @@ private void eventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
         // Project
         private void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e)
         {
+            StartedProjects++;
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
             // If id already exists...
@@ -125,6 +132,8 @@ private void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e
             ProjectNode node = new ProjectNode(e);
             projects[id] = node;
             // Log
+            // Update footer
+            UpdateFooter();
             node.ShouldRerender = true;
         }
 
@@ -138,7 +147,8 @@ private void eventSource_ProjectFinished(object sender, ProjectFinishedEventArgs
             }
             // Update line
             node.Finished = true;
-            // Log
+            FinishedProjects++;
+            UpdateFooter();
             node.ShouldRerender = true;
         }
 
@@ -182,14 +192,12 @@ private void eventSource_TaskStarted(object sender, TaskStartedEventArgs e)
             }
             // Update
             node.AddTask(e);
-            existingTasks++;
             // Log
             node.ShouldRerender = true;
         }
 
         private void eventSource_TaskFinished(object sender, TaskFinishedEventArgs e)
         {
-            completedTasks++;
         }
 
         // Raised messages, warnings and errors
@@ -248,18 +256,23 @@ private void console_CancelKeyPressed(object? sender, ConsoleCancelEventArgs eve
         public void Shutdown()
         {
             TerminalBuffer.Terminate();
-            // TODO: Remove. There is a bug that causes switching to main buffer without deleting the contents of the alternate buffer
-            Console.Clear();
             int errorCount = 0;
             int warningCount = 0;
             foreach (var project in projects)
             {
+                if (project.Value.AdditionalDetails.Count == 0)
+                {
+                    continue;
+                }
+
+                Console.WriteLine(project.Value.ToANSIString());
                 errorCount += project.Value.ErrorCount;
                 warningCount += project.Value.WarningCount;
                 foreach (var message in project.Value.AdditionalDetails)
                 {
-                    Console.WriteLine(message.ToANSIString());
+                    Console.WriteLine($"    └── {message.ToANSIString()}");
                 }
+                Console.WriteLine();
             }
 
             // Emmpty line
diff --git a/src/MSBuild/LiveLogger/MessageNode.cs b/src/MSBuild/LiveLogger/MessageNode.cs
index 0d969a61774..7d6029e041d 100644
--- a/src/MSBuild/LiveLogger/MessageNode.cs
+++ b/src/MSBuild/LiveLogger/MessageNode.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Logging.LiveLogger
@@ -15,7 +16,8 @@ public enum MessageType
         {
             HighPriorityMessage,
             Warning,
-            Error
+            Error,
+            ProjectOutputMessage
         }
         public string Message;
         public TerminalBufferLine? Line;
@@ -24,6 +26,7 @@ public enum MessageType
         public string? FilePath;
         public int? LineNumber;
         public int? ColumnNumber;
+        public string? ProjectOutputExecutablePath;
         public MessageNode(LazyFormattedBuildEventArgs args)
         {
             Message = args.Message ?? string.Empty;
@@ -34,8 +37,20 @@ public MessageNode(LazyFormattedBuildEventArgs args)
             // Get type
             switch (args)
             {
-                case BuildMessageEventArgs:
-                    Type = MessageType.HighPriorityMessage;
+                case BuildMessageEventArgs message:
+                    // Detect output messages
+                    var finalOutputMarker = " -> ";
+                    int i = message.Message!.IndexOf(finalOutputMarker, StringComparison.Ordinal);
+                    if (i > 0)
+                    {
+                        Type = MessageType.ProjectOutputMessage;
+                        ProjectOutputExecutablePath = message.Message!.Substring(i + finalOutputMarker.Length);
+                    }
+                    else
+                    {
+                        Type = MessageType.HighPriorityMessage;
+                        Code = message.Subcategory;
+                    }
                     break;
                 case BuildWarningEventArgs warning:
                     Type = MessageType.Warning;
@@ -66,9 +81,11 @@ public string ToANSIString()
                     return $"❌ {ANSIBuilder.Formatting.Color(
                         $"Error {Code}: {FilePath}({LineNumber},{ColumnNumber}) {Message}",
                         ANSIBuilder.Formatting.ForegroundColor.Red)}";
+                case MessageType.ProjectOutputMessage:
+                    return $"⚙️ {ANSIBuilder.Formatting.Hyperlink(ProjectOutputExecutablePath!, Path.GetDirectoryName(ProjectOutputExecutablePath)!)}";
                 case MessageType.HighPriorityMessage:
                 default:
-                    return $"ℹ️ {ANSIBuilder.Formatting.Italic(Message)}";
+                    return $"ℹ️ {Code}{(Code is not null ? ": " : string.Empty)} {ANSIBuilder.Formatting.Italic(Message)}";
             }
         }
 
diff --git a/src/MSBuild/LiveLogger/ProjectNode.cs b/src/MSBuild/LiveLogger/ProjectNode.cs
index d43c6f1f32a..e8980c1fb40 100644
--- a/src/MSBuild/LiveLogger/ProjectNode.cs
+++ b/src/MSBuild/LiveLogger/ProjectNode.cs
@@ -25,6 +25,7 @@ private static string GetUnambiguousPath(string path)
         public string ProjectPath;
         public string TargetFramework;
         public bool Finished;
+        public string? ProjectOutputExecutable;
         // Line to display project info
         public TerminalBufferLine? Line;
         // Targets
@@ -55,6 +56,29 @@ public ProjectNode(ProjectStartedEventArgs args)
             }
         }
 
+        public string ToANSIString()
+        {
+            ANSIBuilder.Formatting.ForegroundColor color = ANSIBuilder.Formatting.ForegroundColor.Default;
+            string icon = ANSIBuilder.Formatting.Blinking(ANSIBuilder.Graphics.Spinner()) + " ";
+
+            if (Finished && WarningCount + ErrorCount == 0)
+            {
+                color = ANSIBuilder.Formatting.ForegroundColor.Green;
+                icon = "✓";
+            }
+            else if (ErrorCount > 0)
+            {
+                color = ANSIBuilder.Formatting.ForegroundColor.Red;
+                icon = "X";
+            }
+            else if (WarningCount > 0)
+            {
+                color = ANSIBuilder.Formatting.ForegroundColor.Yellow;
+                icon = "✓";
+            }
+            return icon + " " + ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Bold(GetUnambiguousPath(ProjectPath)), color) + " " + ANSIBuilder.Formatting.Inverse(TargetFramework);
+        }
+
         // TODO: Rename to Render() after LiveLogger's API becomes internal
         public void Log()
         {
@@ -65,16 +89,7 @@ public void Log()
 
             ShouldRerender = false;
             // Project details
-            string lineContents = ANSIBuilder.Alignment.SpaceBetween(
-                // Show indicator
-                (Finished ? ANSIBuilder.Formatting.Color("✓", ANSIBuilder.Formatting.ForegroundColor.Green) : ANSIBuilder.Graphics.Spinner()) +
-                // Project
-                ANSIBuilder.Formatting.Dim("Project: ") +
-                // Project file path with color
-                $"{ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Bold(GetUnambiguousPath(ProjectPath)), Finished ? ANSIBuilder.Formatting.ForegroundColor.Green : ANSIBuilder.Formatting.ForegroundColor.Default)} [{TargetFramework ?? "*"}]",
-                $"({MessageCount} Messages, {WarningCount} Warnings, {ErrorCount} Errors)",
-                Console.WindowWidth);
-
+            string lineContents = ANSIBuilder.Alignment.SpaceBetween(ToANSIString(), $"({MessageCount} ℹ️, {WarningCount} ⚠️, {ErrorCount} ❌)", Console.BufferWidth - 1);
             // Create or update line
             if (Line is null)
             {
@@ -168,6 +183,12 @@ public TargetNode AddTarget(TargetStartedEventArgs args)
 
             MessageCount++;
             MessageNode node = new MessageNode(args);
+            // Add output executable path
+            if (node.ProjectOutputExecutablePath is not null)
+            {
+                ProjectOutputExecutable = node.ProjectOutputExecutablePath;
+            }
+
             AdditionalDetails.Add(node);
             return node;
         }
diff --git a/src/MSBuild/LiveLogger/TerminalBuffer.cs b/src/MSBuild/LiveLogger/TerminalBuffer.cs
index 68164bc0342..676e9d09829 100644
--- a/src/MSBuild/LiveLogger/TerminalBuffer.cs
+++ b/src/MSBuild/LiveLogger/TerminalBuffer.cs
@@ -57,6 +57,7 @@ public TerminalBufferLine(string text, bool shouldWrapLines)
     internal class TerminalBuffer
     {
         private static List<TerminalBufferLine> Lines = new();
+        public static string FooterText = string.Empty;
         public static int TopLineIndex = 0;
         public static string Footer = string.Empty;
         internal static bool IsTerminated = false;
@@ -80,10 +81,12 @@ public static void Initialize()
         public static void Terminate()
         {
             IsTerminated = true;
+            // Delete contents from alternate buffer before switching back to main buffer
+            Console.Write(
+                ANSIBuilder.Cursor.Home() +
+                ANSIBuilder.Eraser.DisplayCursorToEnd());
             // Reset configuration for buffer and cursor, and clear screen
             Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
-            Console.Write(ANSIBuilder.Eraser.Display());
-            Console.Clear();
             Console.Write(ANSIBuilder.Cursor.Visible());
             Lines = new();
         }
@@ -102,9 +105,8 @@ public static void Render()
                 ANSIBuilder.Cursor.Home() +
                 ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Formatting.Inverse(ANSIBuilder.Alignment.Center("MSBuild - Build in progress")) +
                 // Write footer
-                ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Cursor.Position(Console.BufferHeight - 1, 0) +
-                // TODO: Remove and replace with actual footer
-                new string('-', Console.BufferWidth) + $"\nBuild progress: XX%\tTopLineIndex={TopLineIndex}");
+                ANSIBuilder.Cursor.Position(Console.BufferHeight - 1, 0) + ANSIBuilder.Eraser.LineCursorToEnd() +
+                new string('-', Console.BufferWidth) + '\n' + FooterText);
 
             if (Lines.Count == 0)
             {
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 5701c2d3cc9..3cea4a096b1 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -470,7 +470,7 @@
    <value>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </value>
     <comment>
@@ -482,9 +482,8 @@
   <data name="HelpMessage_InputCachesFiles" UESanitized="false" Visibility="Public">
    <value>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </value>
     <comment>
       LOCALIZATION: The following should not be localized: MSBuild, -isolate
@@ -756,9 +755,18 @@
     </comment>
   </data>
   <data name="HelpMessage_35_IsolateProjectsSwitch" UESanitized="false" Visibility="Public">
-    <value>  -isolateProjects[:True|False]
+    <value>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -1187,7 +1195,8 @@
     <comment>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </comment>
   </data>
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 629795762ae..827a5cd91a3 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,7 +150,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      Způsobí, že MSBuild sestaví jednotlivé projekty izolovaně.
 
                      Jde o omezenější režim nástroje MSBuild, protože vyžaduje,
@@ -336,9 +345,9 @@
         <target state="translated">  @&lt;soubor&gt;            Vložení nastavení příkazového řádku z textového souboru. Chcete-li zadat
                      více souborů odpovědí, uveďte každý soubor
                      odpovědí zvlášť.
-                     
-                     Automaticky jsou použity všechny soubory s názvem msbuild.rsp 
-                     nacházející se v následujících umístěních: 
+
+                     Automaticky jsou použity všechny soubory s názvem msbuild.rsp
+                     nacházející se v následujících umístěních:
                      (1) adresář nástroje msbuild.exe
                      (2) adresář prvního sestaveného projektu nebo řešení
 </target>
@@ -399,7 +408,7 @@
 </source>
         <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  Nastavení nebo potlačení daných vlastností na úrovni
                      projektu. &lt;n&gt; je název vlastnosti a &lt;v&gt; je její hodnota. Více
-                     vlastností oddělte středníkem či čárkou nebo zadejte 
+                     vlastností oddělte středníkem či čárkou nebo zadejte
                      každou vlastnost zvlášť. (Krátký tvar: -p)
                      Příklad:
                        -property:WarningLevel=2;OutDir=bin\Debug\
@@ -440,7 +449,7 @@
                      Syntaxe hodnoty &lt;sestavení_protok_nást&gt;:
                         {&lt;název_sestavení&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavení&gt;}
                      Parametry protokolovacího nástroje určují, jak MSBuild vytvoří protokolovací nástroj.
-                     Parametry &lt;param_protok_nást&gt; jsou volitelné a předávají se 
+                     Parametry &lt;param_protok_nást&gt; jsou volitelné a předávají se
                      protokolovacímu nástroji přesně v tom tvaru, v jakém
                      byly zadány. (Krátký tvar: -l)
                      Příklady:
@@ -587,10 +596,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate          Ověřit projekt podle výchozího schématu. 
+        <target state="translated">  -validate          Ověřit projekt podle výchozího schématu.
                      (Krátký tvar: -val)
 
-  -validate:&lt;schéma&gt; Ověřit projekt podle zadaného schématu. 
+  -validate:&lt;schéma&gt; Ověřit projekt podle zadaného schématu.
                      (Krátký tvar: -val)
                      Příklad:
                        -validate:MyExtendedBuildSchema.xsd
@@ -647,11 +656,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
                      Seznam středníkem oddělených vstupních souborů mezipaměti, ze kterých
                      MSBuild přečte výsledky sestavení.
                      Nastavení tohoto atributu zároveň zapne izolované buildy (-isolate).
@@ -666,10 +674,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[souborMezipaměti]...
+        <target state="needs-review-translation">  -outputResultsCache:[souborMezipaměti]...
                      Výstupní soubor mezipaměti, do něhož bude MSBuild
                      zapisovat obsah svých mezipamětí výsledků sestavení.
                      Nastavením této možnosti zapnete také izolované buildy (-isolate).
@@ -705,11 +713,11 @@
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
-        <target state="translated">  -distributedlogger:&lt;centr_protok_nást&gt;*&lt;předáv_protok_nást&gt;                     
+        <target state="translated">  -distributedlogger:&lt;centr_protok_nást&gt;*&lt;předáv_protok_nást&gt;
                      Použít zadaný protokolovací nástroj pro protokolování událostí
-                     z nástroje MSBuild; ke každému uzlu připojit jinou instanci 
-                     protokolovacího nástroje. Chcete-li zadat více 
-                     protokolovacích nástrojů, uveďte je jednotlivě. 
+                     z nástroje MSBuild; ke každému uzlu připojit jinou instanci
+                     protokolovacího nástroje. Chcete-li zadat více
+                     protokolovacích nástrojů, uveďte je jednotlivě.
                      (Krátký tvar: -dl)
                      Syntaxe hodnoty &lt;protok_nást&gt;:
                         [&lt;třída_protok_nást&gt;,]&lt;sestav_protok_nást&gt;
@@ -773,7 +781,7 @@
         <target state="translated">  -toolsversion:&lt;verze&gt;
                      Verze sady nástrojů MSBuild (úloh, cílů apod.), která má být
                      použita při sestavení. Tato verze má přednost před verzemi
-                     uvedenými v jednotlivých projektech. 
+                     uvedenými v jednotlivých projektech.
                      (Krátký tvar: -tv)
                      Příklad:
                        -toolsversion:3.5
@@ -891,25 +899,25 @@
                      popis přepínače -distributedFileLogger.
                      (Krátký tvar: -flp[n])
                      K dispozici jsou stejné parametry jako ty,
-                     které jsou uvedeny u protokolovacího nástroje 
+                     které jsou uvedeny u protokolovacího nástroje
                      konzoly. Některé další dostupné parametry:
                        LogFile – cesta k souboru protokolu, do nějž bude zapsán
-                                  protokol sestavení 
+                                  protokol sestavení
                        Append  – určuje, zda bude protokol sestavení připojen
-                                  k souboru protokolu, nebo jej přepíše. Při nastavení 
+                                  k souboru protokolu, nebo jej přepíše. Při nastavení
                                   přepínače bude protokol sestavení připojen k souboru
-                                  protokolu. Není-li přepínač nastaven, bude obsah 
-                                  existujícího souboru protokolu přepsán. 
+                                  protokolu. Není-li přepínač nastaven, bude obsah
+                                  existujícího souboru protokolu přepsán.
                                   Podle výchozího nastavení je soubor protokolu přepsán.
-                       Encoding – určuje kódování souboru, například 
+                       Encoding – určuje kódování souboru, například
                      UTF-8, Unicode nebo ASCII.
                        Výchozí úroveň podrobností je Detailed.
                      Příklady:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                              Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1032,11 +1040,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: Hodnota izolace projektů není platná. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: Hodnota izolace projektů není platná. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 3c0965cfed9..a48f6fd867d 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -116,7 +116,7 @@
                      value that comes from a response file.
     </source>
         <target state="translated">  -interactive[:True|False]
-                     Weist darauf hin, dass für Aktionen im Build eine 
+                     Weist darauf hin, dass für Aktionen im Build eine
                      Interaktion mit dem Benutzer zugelassen ist. Verwenden Sie dieses Argument
                      in einem automatisierten Szenario, in dem keine Interaktivität
                      erwartet wird.
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,11 +150,11 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      Führt dazu, dass MSBuild jedes Projekt isoliert erstellt.
 
                      Dies ist ein restriktiverer Modus von MSBuild, da er erfordert, dass
-                     der Projektgraph zur Auswertungszeit statisch ermittelbar ist. Er kann jedoch 
+                     der Projektgraph zur Auswertungszeit statisch ermittelbar ist. Er kann jedoch
                      die Planung verbessern und den Speichermehraufwand
                      beim Erstellen einer großen Anzahl von Projekten verringern.
                      (Kurzform: -isolate)
@@ -337,8 +346,8 @@ Beispiel:
                      Antwortdateien anzugeben, geben Sie jede Antwortdatei
                      gesondert an.
 
-                     Alle Antwortdateien mit dem Name "msbuild.rsp" werden automatisch 
-                     in den folgenden Speicherorten verwendet: 
+                     Alle Antwortdateien mit dem Name "msbuild.rsp" werden automatisch
+                     in den folgenden Speicherorten verwendet:
                      (1) Verzeichnis von "msbuild.exe"
                      (2) Verzeichnis des ersten erstellten Projekts oder Projektmappe
 </target>
@@ -429,7 +438,7 @@ Beispiel:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben, 
+        <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben,
                      wird jede Protokollierung gesondert angegeben.
                      Die Syntax für die &lt;Protokollierung&gt; lautet:
                        [&lt;Klasse&gt;,]&lt;Assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
@@ -438,7 +447,7 @@ Beispiel:
                      Die Syntax für die &lt;Protokollierungsassembly&gt; lautet:
                        {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
-                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
+                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau
                      so an die Protokollierung übergeben, wie sie eingegeben wurden. (Kurzform: -l)
                      Beispiele:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -644,11 +653,10 @@ Beispiel:
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
                      Durch Semikolons getrennte Liste von Eingabecachedateien, aus denen MSBuild
                      Buildergebnisse liest.
                      Durch Festlegen dieser Option werden auch isolierte Builds aktiviert (-isolate).
@@ -663,10 +671,10 @@ Beispiel:
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[Cachedatei]
+        <target state="needs-review-translation">  -outputResultsCache:[Cachedatei]
                      Ausgabecachedateien, in die MSBuild am Ende des Buildvorgangs die Inhalte
                      der zugehörigen Caches mit Buildergebnissen schreibt.
                      Durch Festlegung dieser Option werden außerdem isolierte Builds aktiviert (-isolate).
@@ -703,8 +711,8 @@ Beispiel:
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
         <target state="translated">  -distributedlogger:&lt;Zentrale Protokollierung&gt;*&lt;Weiterleitende Protokollierung&gt;
-                     Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert, wobei an jeden Knoten eine andere 
-                     Protokollierungsinstanz angefügt wird. Um mehrere Protokollierungen anzugeben, wird jede Protokollierung 
+                     Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert, wobei an jeden Knoten eine andere
+                     Protokollierungsinstanz angefügt wird. Um mehrere Protokollierungen anzugeben, wird jede Protokollierung
                      gesondert angegeben.
                      (Kurzform -dl)
                      Die Syntax für die &lt;Protokollierung&gt; lautet:
@@ -714,7 +722,7 @@ Beispiel:
                      Die Syntax für die &lt;Protokollierungsassembly&gt; lautet:
                        {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
-                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
+                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau
                      so an die Protokollierung übergeben, wie sie eingegeben wurden. (Kurzform: -l)
                      Beispiele:
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -739,8 +747,8 @@ Beispiel:
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreprojectextensions:&lt;Erweiterungen&gt;
-                     Liste der zu ignorierenden Erweiterungen, wenn die zu erstellende 
-                     Projektdatei ermittelt wird. Verwenden Sie ein Semikolon oder ein Komma, 
+                     Liste der zu ignorierenden Erweiterungen, wenn die zu erstellende
+                     Projektdatei ermittelt wird. Verwenden Sie ein Semikolon oder ein Komma,
                      um mehrere Erweiterungen voneinander zu trennen.
                      (Kurzform: -ignore)
                      Beispiel:
@@ -766,8 +774,8 @@ Beispiel:
    </source>
         <target state="translated">  -toolsversion:&lt;Version&gt;
                      Die Version des MSBuild-Toolsets (Aufgaben, Ziele usw.),
-                     die während des Erstellens zu verwenden ist. Diese Version überschreibt die 
-                     von einzelnen Projekten angegebenen Versionen. (Kurzform: 
+                     die während des Erstellens zu verwenden ist. Diese Version überschreibt die
+                     von einzelnen Projekten angegebenen Versionen. (Kurzform:
                      -tv)
                      Beispiel:
                        -toolsversion:3.5
@@ -826,14 +834,14 @@ Beispiel:
         <target state="translated">  -distributedFileLogger
                      Protokolliert die Erstellungsausgabe in mehrere Dateien, eine Protokolldatei
                      pro MSBuild-Knoten. Der anfängliche Speicherort für diese Dateien ist
-                     das aktuelle Verzeichnis. Standardmäßig werden die Dateien 
+                     das aktuelle Verzeichnis. Standardmäßig werden die Dateien
                      "MSBuild&lt;Knoten-ID&gt;.log" benannt. Der Speicherort der Datei und
-                     andere Parameter für fileLogger können durch das Hinzufügen 
+                     andere Parameter für fileLogger können durch das Hinzufügen
                      des Schalters "-fileLoggerParameters" angegeben werden.
 
                      Wenn mithilfe des fileLoggerParameters-Parameters ein Protokolldateiname festgelegt wurde,
-                     verwendet die verteilte Protokollierung den Dateinamen als 
-                     Vorlage und fügt die Knoten-ID an diesen Dateinamen an, 
+                     verwendet die verteilte Protokollierung den Dateinamen als
+                     Vorlage und fügt die Knoten-ID an diesen Dateinamen an,
                      um für jeden Knoten eine Protokolldatei zu erstellen.
     </target>
         <note>
@@ -877,31 +885,31 @@ Beispiel:
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;Parameter&gt;
                      Gibt zusätzliche Parameter für Dateiprotokollierungen an.
-                     Dieser Schalter bedeutet, dass der entsprechende 
+                     Dieser Schalter bedeutet, dass der entsprechende
                      Schalter "-fileLogger[n]" ebenfalls vorhanden ist.
                      "n" (optional) kann eine Zahl von 1–9 sein.
-                     "-fileLoggerParameters" wird auch von verteilten 
+                     "-fileLoggerParameters" wird auch von verteilten
                      Dateiprotokollierungen verwendet (siehe Beschreibung zu "-distributedFileLogger").
                      (Kurzform: -flp[n])
                      Es sind dieselben Parameter wie für die Konsolenprotokollierung
                      verfügbar. Einige zusätzliche Parameter:
-                        LogFile: Pfad der Protokolldatei, in die das 
+                        LogFile: Pfad der Protokolldatei, in die das
                             Buildprotokoll geschrieben wird.
-                        Append: Gibt an, ob das Buildprotokoll erweitert oder 
+                        Append: Gibt an, ob das Buildprotokoll erweitert oder
                             oder überschrieben wird. Mit diesem Schalter
                             wird das Buildprotokoll an die Protokolldatei angefügt;
-                            Ohne diesen Schalter wird der Inhalt 
-                            der vorhandenen Protokolldatei überschrieben. 
+                            Ohne diesen Schalter wird der Inhalt
+                            der vorhandenen Protokolldatei überschrieben.
                             Standardmäßig wird die Protokolldatei nicht erweitert.
-                        Encoding: Gibt die Codierung der Datei an, 
+                        Encoding: Gibt die Codierung der Datei an,
                             z. B. UTF-8, Unicode oder ASCII.
                      Die Standardeinstellung für "verbosity" ist "Detailed".
                      Beispiele:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -927,7 +935,7 @@ Beispiel:
         <target state="translated">  -nodeReuse:&lt;Parameter&gt;
                      Aktiviert oder deaktiviert die Wiederverwendung von MSBuild-Knoten.
                      Die Parameter lauten:
-                     True: Knoten bleiben nach dem Abschluss der Erstellung 
+                     True: Knoten bleiben nach dem Abschluss der Erstellung
                      erhalten und werden bei folgenden Erstellungen wiederverwendet (Standardeinstellung).
                      False: Knoten bleiben nach dem Abschluss der Erstellung nicht erhalten.
                      (Kurzform: -nr)
@@ -1024,11 +1032,12 @@ Beispiel:
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: Der Wert für das Isolieren von Projekten ist nicht gültig. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: Der Wert für das Isolieren von Projekten ist nicht gültig. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 061121dec63..bf8d89e1c84 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,7 +150,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      Hace que MSBuild compile cada proyecto en aislamiento.
 
                      Este es un modo de MSBuild más restrictivo ya que requiere
@@ -648,11 +657,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;archivoCaché&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;archivoCaché&gt;...
                      Lista de archivos de caché de entrada, separados por punto y coma, de la que MSBuild
                      leerá los resultados de la compilación.
                      Si se establece esta opción, se activan también las compilaciones aisladas (-isolate).
@@ -667,10 +675,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[archivo-de-caché]
+        <target state="needs-review-translation">  -outputResultsCache:[archivo-de-caché]
                      Archivo de caché de salida donde MSBuild escribe
                      el contenido de las memorias caché de resultados
                      de compilación cuando esta acaba.
@@ -748,8 +756,8 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;extensiones&gt;
-                     Lista de extensiones que se omiten al determinar el 
-                     archivo del proyecto que se va a compilar. Use el carácter de 
+                     Lista de extensiones que se omiten al determinar el
+                     archivo del proyecto que se va a compilar. Use el carácter de
                      punto y coma o coma para separar varias extensiones.
                     (Forma corta: -ignore)
                      Ejemplo:
@@ -900,9 +908,9 @@
                             sobrescribirá el archivo de registro. Si se establece el
                             modificador, se adjunta el registro de compilación al archivo de registro;
                             Si no se especifica el modificador, se sobrescribe
-                            el contenido del archivo de registro existente. 
+                            el contenido del archivo de registro existente.
                             El valor predeterminado es adjuntar el archivo de registro.
-                        Encoding: especifica la codificación del archivo, 
+                        Encoding: especifica la codificación del archivo,
                             por ejemplo, UTF-8, Unicode o ASCII
                      El nivel de detalle predeterminado es Detailed.
                      Ejemplos:
@@ -1033,11 +1041,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: El valor de los proyectos aislados no es válido. {0}.</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: El valor de los proyectos aislados no es válido. {0}.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index cbe9a27f313..572e704317d 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,7 +150,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      Force MSBuild à générer chaque projet de manière isolée.
 
                      Ce mode de MSBuild est plus restrictif car il nécessite
@@ -644,11 +653,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;fichierCache&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;fichierCache&gt;...
          Liste de fichiers cache d'entrée séparés par des points-virgules, à
          partir desquels MSBuild va lire les résultats de la build.
          Ce paramètre active également les builds isolées (-isolate).
@@ -663,10 +671,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[cacheFile]
+        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
                      Fichier cache de sortie dans lequel MSBuild écrit le contenu de
                      ses caches de résultats de la build à la fin de la build.
                      Ce paramètre active également les builds isolées (-isolate).
@@ -1024,11 +1032,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: La valeur d’isolation des projets n'est pas valide. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: La valeur d’isolation des projets n'est pas valide. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1752,7 +1761,7 @@ fois plus petit que le journal
         <target state="translated">  -profileEvaluation:&lt;fichier&gt;
          Profile l'évaluation MSBuild et écrit le résultat
          dans le fichier spécifié. Si l'extension du fichier spécifié
-         est '.md', le résultat est généré au format Markdown. 
+         est '.md', le résultat est généré au format Markdown.
          Sinon, un fichier de valeurs séparées par des tabulations est généré.
     </target>
         <note />
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index c222fdf2e2e..d97eee21a68 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -131,9 +131,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -142,9 +151,9 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      Fa in modo che MSBuild compili ogni progetto in modalità
-                     isolamento. 
+                     isolamento.
 
                      Si tratta di una modalità più restrittiva di
                      MSBuild perché richiede che il grafico del progetto sia
@@ -348,7 +357,7 @@ Esempio:
                      separatamente.
 
                      Qualsiasi file di risposta denominato "msbuild.rsp" viene usato
-                     automaticamente dai percorsi seguenti: 
+                     automaticamente dai percorsi seguenti:
                      (1) la directory di msbuild.exe
                      (2) la directory della prima compilazione di soluzione o progetto
 </target>
@@ -654,11 +663,10 @@ Esempio:
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;fileCache&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;fileCache&gt;...
                      Elenco di file di cache di input delimitati da punto e virgola da cui MSBuild
                      leggerà i risultati della compilazione.
                      Se si imposta questa opzione, si attivano anche le compilazioni isolate (-isolate).
@@ -673,10 +681,10 @@ Esempio:
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[fileCache]
+        <target state="needs-review-translation">  -outputResultsCache:[fileCache]
                      File di cache di output in cui MSBuild scriverà il contenuto delle
                      cache dei risultati della compilazione al termine della compilazione.
                      Se si imposta questa opzione, si attivano anche le compilazioni isolate (-isolate).
@@ -1038,11 +1046,12 @@ Esempio:
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: il valore di isolateProjects non è valido. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: il valore di isolateProjects non è valido. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index b43a24ea5b0..c590ae60203 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,7 +150,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      MSBuild は、各プロジェクトを分離してビルドします。
 
                      これは MSBuild のより制限的なモードです。
@@ -205,7 +214,7 @@
     </source>
         <target state="translated">  -targets[:file]
                      使用可能なターゲットの一覧を、実際のビルド処理を
-                     実行せずに出力します。既定では、出力はコンソール 
+                     実行せずに出力します。既定では、出力はコンソール
                      ウィンドウに書き込まれます。出力ファイルへのパスを
                      指定した場合は、代わりにそのファイルが使用されます。
                      (短い形式:-ts)
@@ -644,11 +653,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
                      MSBuild がビルド結果を読み込む、入力キャッシュ ファイルの
                      セミコロンで区切られたリスト。
                      これを設定すると、分離されたビルド (-isolate) も有効になります。
@@ -663,10 +671,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[cacheFile]
+        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
                      MSBuild がビルドの最後にビルド結果キャッシュの
                      内容を書き込む出力キャッシュ ファイル。
                      設定すると、分離されたビルドも有効になります (-isolate)。
@@ -1024,11 +1032,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: Isolate projects 値が無効です。{0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: Isolate projects 値が無効です。{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1691,7 +1700,7 @@
                      (Short form: -r)
     </source>
         <target state="translated">  -restore[:True|False]
-                     他のターゲットをビルドする前に Restore 
+                     他のターゲットをビルドする前に Restore
                      という名前のターゲットを実行し、これらのターゲットのビルドが
                      最新の復元ビルド ロジックを使用するようにします。
                      これは、パッケージ ツリーでパッケージをビルド
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 212687577a1..e136d34da21 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -116,12 +116,12 @@
                      value that comes from a response file.
     </source>
         <target state="translated">  -interactive[:True|False]
-                     빌드의 작업이 사용자와 상호 작용할 수 
-                     있음을 나타냅니다. 상호 작용이 필요하지 
-                     않은 자동화된 시나리오에서는 이 인수를 
+                     빌드의 작업이 사용자와 상호 작용할 수
+                     있음을 나타냅니다. 상호 작용이 필요하지
+                     않은 자동화된 시나리오에서는 이 인수를
                      사용하지 마세요.
                      -interactive를 지정하는 것은 -interactive:true를
-                     지정하는 것과 같습니다. 매개 변수를 
+                     지정하는 것과 같습니다. 매개 변수를
                      사용하여 지시 파일에서 가져오는 값을 재정의합니다.
     </target>
         <note>
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,12 +150,12 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      MSBuild가 격리 모드에서 각 프로젝트를 빌드하도록 합니다.
 
-                     이 모드는 프로젝트 그래프가 평가 시간에 정적으로 
-                     검색 가능해야 하므로 더 제한적인 MSBuild 모드이나, 
-                     대규모 프로젝트를 빌드할 경우 예약을 개선하고 
+                     이 모드는 프로젝트 그래프가 평가 시간에 정적으로
+                     검색 가능해야 하므로 더 제한적인 MSBuild 모드이나,
+                     대규모 프로젝트를 빌드할 경우 예약을 개선하고
                      메모리 오버헤드를 줄일 수 있습니다.
                      (약식: -isolate)
 
@@ -173,9 +182,9 @@
         <target state="translated">  -graphBuild[:True|False]
                      MSBuild가 프로젝트 그래프를 생성 및 빌드하도록 합니다.
 
-                     그래프 생성에는 종속성을 형성하기 위한 프로젝트 
-                     참조 식별이 관련됩니다. 해당 그래프 빌드에는 프로젝트 
-                     참조를 참조하는 프로젝트 전에 프로젝트 참조를 
+                     그래프 생성에는 종속성을 형성하기 위한 프로젝트
+                     참조 식별이 관련됩니다. 해당 그래프 빌드에는 프로젝트
+                     참조를 참조하는 프로젝트 전에 프로젝트 참조를
                      빌드하는 시도가 관련되며, 이는 기존 MSBuild
                      예약과 다릅니다.
                      (약식: -graph)
@@ -229,7 +238,7 @@
         <target state="translated">  -lowPriority[:True|False]
                      MSBuild가 낮은 프로세스 우선 순위로 실행됩니다.
 
-                     -lowPriority를 지정하는 것은 
+                     -lowPriority를 지정하는 것은
                      -lowPriority:True를 지정하는 것과 같습니다.
                      (약식: -low)
     </target>
@@ -333,11 +342,11 @@
                      (1) the directory of msbuild.exe
                      (2) the directory of the first project or solution built
 </source>
-        <target state="translated">  @&lt;file&gt;            텍스트 파일에서 명령줄 설정을 삽입합니다. 
-                     여러 지시 파일을 지정하려면 각 지시 파일을 개별적으로 
+        <target state="translated">  @&lt;file&gt;            텍스트 파일에서 명령줄 설정을 삽입합니다.
+                     여러 지시 파일을 지정하려면 각 지시 파일을 개별적으로
                      지정합니다.
 
-                     "msbuild.rsp"라는 지시 파일이 다음 위치에서 
+                     "msbuild.rsp"라는 지시 파일이 다음 위치에서
                      자동으로 사용됩니다.
                      (1) msbuild.exe의 디렉터리
                      (2) 빌드된 첫 번째 프로젝트 또는 솔루션의 디렉터리
@@ -374,8 +383,8 @@
                      Example:
                        -target:Resources;Compile
 </source>
-        <target state="translated">  -target:&lt;targets&gt;  이 프로젝트에서 대상을 빌드합니다. 세미콜론 또는 쉼표를 사용하여 
-                     여러 대상을 구분하거나, 각 대상을 
+        <target state="translated">  -target:&lt;targets&gt;  이 프로젝트에서 대상을 빌드합니다. 세미콜론 또는 쉼표를 사용하여
+                     여러 대상을 구분하거나, 각 대상을
                      개별적으로 지정합니다. (약식: -t)
                      예:
                        -target:Resources;Compile
@@ -397,9 +406,9 @@
                      Example:
                        -property:WarningLevel=2;OutDir=bin\Debug\
 </source>
-        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  프로젝트 수준 속성을 설정하거나 재정의합니다. &lt;n&gt;은 
-                     속성 이름이고 &lt;v&gt;는 속성 값입니다. 
-                     세미콜론 또는 쉼표를 사용하여 여러 속성을 구분하거나, 
+        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  프로젝트 수준 속성을 설정하거나 재정의합니다. &lt;n&gt;은
+                     속성 이름이고 &lt;v&gt;는 속성 값입니다.
+                     세미콜론 또는 쉼표를 사용하여 여러 속성을 구분하거나,
                      각 속성을 개별적으로 지정합니다. (약식: -p)
                      예:
                        -property:WarningLevel=2;OutDir=bin\Debug\
@@ -584,10 +593,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate          기본 스키마를 기준으로 프로젝트의 유효성을 검사합니다. 
+        <target state="translated">  -validate          기본 스키마를 기준으로 프로젝트의 유효성을 검사합니다.
                      (약식: -val)
 
-  -validate:&lt;schema&gt; 지정된 스키마를 기준으로 프로젝트의 유효성을 검사합니다. 
+  -validate:&lt;schema&gt; 지정된 스키마를 기준으로 프로젝트의 유효성을 검사합니다.
                      (약식: -val)
                      예:
                        -validate:MyExtendedBuildSchema.xsd
@@ -644,12 +653,11 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     MSBuild가 빌드 결과를 읽는 소스 입력 캐시 파일의 
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
+                     MSBuild가 빌드 결과를 읽는 소스 입력 캐시 파일의
                      세미콜론으로 구분된 목록입니다.
                      이 스위치를 설정하면 격리된 빌드(-isolate)도 켜집니다.
                      (약식: -irc)
@@ -663,10 +671,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[cacheFile]
+        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
                      MSBuild에서 빌드 마지막에 빌드 결과 캐시의
                      콘텐츠를 쓰는 출력 캐시 파일입니다.
                      설정하면 격리된 빌드에서도 설정됩니다(-isolate).
@@ -739,8 +747,8 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;extensions&gt;
-                     빌드할 프로젝트 파일을 결정할 때 
-                     무시할 확장 목록입니다. 여러 확장을 구분하는 데는 
+                     빌드할 프로젝트 파일을 결정할 때
+                     무시할 확장 목록입니다. 여러 확장을 구분하는 데는
                      세미콜론 또는 쉼표를 사용합니다.
                      (약식: -ignore)
                      예:
@@ -766,7 +774,7 @@
    </source>
         <target state="translated">  -toolsVersion:&lt;version&gt;
                      빌드 중에 사용할 MSBuild 도구 세트(작업, 대상 등)의 버전입니다.
-                     이 버전은 개별 프로젝트에서 지정한 버전을 
+                     이 버전은 개별 프로젝트에서 지정한 버전을
                      재정의합니다. (약식:
                      -tv)
                      예:
@@ -795,9 +803,9 @@
                      파일은 현재 디렉터리에 있고
                      "msbuild[n].log"로 이름이 지정되어 있습니다. 모든 노드의 이벤트는 단일 로그로
                      결합됩니다. 파일의 위치 및 fileLogger의
-                     다른 매개 변수는 "-fileLoggerParameters[n]" 스위치를 
+                     다른 매개 변수는 "-fileLoggerParameters[n]" 스위치를
                      추가하여 지정할 수 있습니다.
-                     "n"은 1-9 사이의 숫자일 수 있으며 최대 10개의 
+                     "n"은 1-9 사이의 숫자일 수 있으며 최대 10개의
                      파일 로거가 추가될 수 있습니다. (약식: -fl[n])
     </target>
         <note>
@@ -824,16 +832,16 @@
                      create a log file for each node.
     </source>
         <target state="translated">  -distributedFileLogger
-                     MSBuild 노드당 로그 파일 하나씩, 여러 로그 파일에 빌드 출력을 
-                     기록합니다. 해당 파일의 초기 위치는 
-                     현재 디렉터리입니다. 기본적으로 해당 파일을 
-                     "MSBuild&lt;nodeid&gt;.log"라고 합니다. 파일 위치 및 fileLogger의 기타 매개 변수는 
-                     "-fileLoggerParameters" 스위치를 추가해서 
+                     MSBuild 노드당 로그 파일 하나씩, 여러 로그 파일에 빌드 출력을
+                     기록합니다. 해당 파일의 초기 위치는
+                     현재 디렉터리입니다. 기본적으로 해당 파일을
+                     "MSBuild&lt;nodeid&gt;.log"라고 합니다. 파일 위치 및 fileLogger의 기타 매개 변수는
+                     "-fileLoggerParameters" 스위치를 추가해서
                      지정할 수 있습니다.
 
-                     로그 파일 이름이 fileLoggerParameters 스위치를 통해 설정되면 
-                     배포된 로거가 fileName을 템플릿으로 사용하고 
-                     노드 ID를 이 fileName에 추가하여 
+                     로그 파일 이름이 fileLoggerParameters 스위치를 통해 설정되면
+                     배포된 로거가 fileName을 템플릿으로 사용하고
+                     노드 ID를 이 fileName에 추가하여
                      각 노드의 로그 파일을 만듭니다.
     </target>
         <note>
@@ -877,20 +885,20 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parameters&gt;
                      파일 로거의 추가 매개 변수를 제공합니다.
-                     이 스위치가 있다는 것은 
+                     이 스위치가 있다는 것은
                      해당 fileLogger[n] 스위치를 의미합니다.
                      "n"(있는 경우)은 1~9의 숫자일 수 있습니다.
-                     -fileLoggerParameters는 배포된 파일 로거에서도 
+                     -fileLoggerParameters는 배포된 파일 로거에서도
                      사용됩니다. -distributedFileLogger에 대한 설명을 참조하세요.
                      (약식: -flp[n])
                      콘솔 로거용으로 나열된 동일한 매개 변수를 사용할 수 있습니다.
                      다음과 같은 몇 가지 추가 매개 변수를 사용할 수 있습니다.
-                        LogFile--빌드 로그가 기록되는 
+                        LogFile--빌드 로그가 기록되는
                             로그 파일의 경로입니다.
-                        Append--빌드 로그가 로그 파일에 추가되는지, 
-                            아니면 로그 파일을 덮어쓰는지 여부를 결정합니다. 
+                        Append--빌드 로그가 로그 파일에 추가되는지,
+                            아니면 로그 파일을 덮어쓰는지 여부를 결정합니다.
                             스위치를 설정하면 빌드 로그가 로그 파일에 추가됩니다.
-                            스위치를 설정하지 않으면 기존 로그 파일의 
+                            스위치를 설정하지 않으면 기존 로그 파일의
                             콘텐츠를 덮어씁니다.
                             기본값은 로그 파일에 추가하지 않는 것입니다.
                         Encoding--파일의 인코딩을 지정합니다
@@ -927,7 +935,7 @@
         <target state="translated">  -nodeReuse:&lt;parameters&gt;
                      MSBuild 노드를 다시 사용하거나 다시 사용하지 않도록 설정합니다.
                      매개 변수는 다음가 같습니다.
-                     True --빌드 완료 후 노드가 유지되고 
+                     True --빌드 완료 후 노드가 유지되고
                             후속 빌드에서 다시 사용됩니다(기본값).
                      False--빌드 완료 후 노드가 유지되지 않습니다.
                      (약식: -nr)
@@ -1024,11 +1032,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: 프로젝트 격리 값이 유효하지 않습니다. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: 프로젝트 격리 값이 유효하지 않습니다. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1692,10 +1701,10 @@
     </source>
         <target state="translated">  -restore[:True|False]
                      다른 대상을 빌드하기 전에 Restore라는 대상을
-                     실행하고 이러한 대상의 빌드에 최신 복원된 
-                     빌드 논리가 사용되는지 확인합니다. 
-                     프로젝트 트리를 빌드하기 전에 
-                     프로젝트 트리에서 패키지를 복원해야 하는 
+                     실행하고 이러한 대상의 빌드에 최신 복원된
+                     빌드 논리가 사용되는지 확인합니다.
+                     프로젝트 트리를 빌드하기 전에
+                     프로젝트 트리에서 패키지를 복원해야 하는
                      경우에 유용합니다. -restore를 지정하는 것은
                      -restore:True를 지정하는 것과 동일합니다. 이 매개 변수를 사용하여
                      지시 파일에서 가져오는 값을 재정의할 수 있습니다.
@@ -1733,7 +1742,7 @@
     </source>
         <target state="translated">  -profileEvaluation:&lt;file&gt;
                      MSBuild 평가를 프로파일링하고 결과를 지정된 파일에 기록합니다.
-                     지정된 파일의 확장명이 '.md'이면 
+                     지정된 파일의 확장명이 '.md'이면
                      결과가 Markdown 형식으로 생성됩니다.
                      그렇지 않으면 탭으로 구분된 파일이 생성됩니다.
     </target>
@@ -1752,9 +1761,9 @@
                        -restoreProperty:IsRestore=true;MyProperty=value
     </source>
         <target state="translated">  -restoreProperty:&lt;n&gt;=&lt;v&gt;
-                     복원하는 동안 프로젝트 수준 속성만 설정하거나 
-                     재정의하고, -property 인수로 지정된 속성을 
-                     사용하지 않습니다. &lt;n&gt;은 속성 이름이고 
+                     복원하는 동안 프로젝트 수준 속성만 설정하거나
+                     재정의하고, -property 인수로 지정된 속성을
+                     사용하지 않습니다. &lt;n&gt;은 속성 이름이고
                      &lt;v&gt;는 속성 값입니다.
                      세미콜론 또는 쉼표를 사용하여 여러 속성을 구분하거나,
                      각 속성을 개별적으로 지정합니다.
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index b25931898c2..acd8432703f 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -122,7 +122,7 @@
                      interakcyjność nie jest oczekiwana.
                      Podanie parametru -interactive jest równoznaczne
                      z podaniem parametru -interactive:true. Użyj tego
-                     parametru, aby przesłonić wartość pochodzącą z pliku 
+                     parametru, aby przesłonić wartość pochodzącą z pliku
                      odpowiedzi.
     </target>
         <note>
@@ -131,9 +131,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -142,8 +151,8 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
-                     Powoduje, że program MSBuild kompiluje każdy projekt                        
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
+                     Powoduje, że program MSBuild kompiluje każdy projekt
                      w sposób izolowany.
 
                      Jest to bardziej restrykcyjny tryb programu MSBuild, ponieważ
@@ -175,7 +184,7 @@
                      This flag is experimental and may not work as intended.
     </source>
         <target state="translated">  -graphBuild[:True|False]
-                     Powoduje, że program MSBuild tworzy i kompiluje graf                 
+                     Powoduje, że program MSBuild tworzy i kompiluje graf
                      projektu.
 
                      Tworzenie grafu obejmuje identyfikowanie odwołań do
@@ -275,7 +284,7 @@
     </source>
         <target state="translated">
  -warnNotAsError[:code[;code2]]
- Lista kodów ostrzeżeń, które mają być traktowane jako błędy. 
+ Lista kodów ostrzeżeń, które mają być traktowane jako błędy.
  Rozdziel średnik lub przecinek
  wiele kodów ostrzeżeń. Nie ma żadnego efektu, jeśli przełącznik -warnaserror
                      switch is not set.
@@ -345,7 +354,7 @@
                      osobno.
 
                      Wszelkie pliki odpowiedzi o nazwie „msbuild.rsp” będą automatycznie
-                     wykorzystywane z następujących lokalizacji: 
+                     wykorzystywane z następujących lokalizacji:
                      (1) katalog programu msbuild.exe
                      (2) katalog pierwszej kompilacji projektu lub rozwiązania
 </target>
@@ -654,11 +663,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;plik pamięci podręcznej&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;plik pamięci podręcznej&gt;...
                      Rozdzielana średnikami lista wejściowych plików pamięci podręcznej, z których program MSBuild
                      będzie odczytywać wyniki kompilacji.
                      Ustawienie tej opcji włącza też kompilacje izolowane (-isolate).
@@ -673,10 +681,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[plik pamięci podręcznej]
+        <target state="needs-review-translation">  -outputResultsCache:[plik pamięci podręcznej]
                      Plik pamięci podręcznej, w którym program MSBuild zapisze zawartość
                      swoich pamięci podręcznych wyników kompilacji po zakończeniu kompilacji.
                      Ustawienie tej opcji włącza też kompilacje izolowane (-isolate).
@@ -898,7 +906,7 @@
                      Dostępne są parametry takie same, jak podane dla rejestratora
                      konsoli. Dostępne są również dodatkowe parametry:
                        LogFile — ścieżka do pliku dziennika, w którym będzie
-                                 zapisywany dziennik kompilacji. 
+                                 zapisywany dziennik kompilacji.
                        Append — określa, czy plik dziennika kompilacji zostanie
                                 dołączony do pliku dziennika, czy go zastąpi.
                                 Ustawienie tego przełącznika powoduje dołączenie dziennika kompilacji
@@ -912,8 +920,8 @@
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1036,11 +1044,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: Wartość projektów izolacji jest nieprawidłowa. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: Wartość projektów izolacji jest nieprawidłowa. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1704,10 +1713,10 @@ dzienników                     tekstowych i wykorzystać w innych narzędziach
     </source>
         <target state="translated">  -restore[:True|False]
                      Uruchamia element docelowy o nazwie Restore przed skompilowaniem
-                     innych elementów docelowych i zapewnia, że kompilacja tych 
-                     elementów docelowych korzysta z najnowszej logiki przywróconej 
-                     kompilacji. Jest to przydatne, gdy drzewo projektu wymaga 
-                     przywrócenia pakietów przed ich skompilowaniem. Podanie parametru 
+                     innych elementów docelowych i zapewnia, że kompilacja tych
+                     elementów docelowych korzysta z najnowszej logiki przywróconej
+                     kompilacji. Jest to przydatne, gdy drzewo projektu wymaga
+                     przywrócenia pakietów przed ich skompilowaniem. Podanie parametru
                      -restore jest równoznaczne z podaniem parametru -restore:True.
                      Za pomocą tego parametru można przesłonić wartość pochodzącą
                      z pliku odpowiedzi.
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 690d79cd062..8ef4d8c30d2 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -131,9 +131,18 @@ arquivo de resposta.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -142,8 +151,8 @@ arquivo de resposta.
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
-                     Faz o MSBuild compilar cada projeto 
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
+                     Faz o MSBuild compilar cada projeto
 isoladamente.
                      Esse é um modo mais restritivo do MSBuild, pois requer
                      que o gráfico do projeto seja estatisticamente detectável no
@@ -609,10 +618,10 @@ isoladamente.
                      MSBuild will use up to the number of processors on the
                      computer. (Short form: -m[:n])
       </source>
-        <target state="translated">  -maxCpuCount[:n] Especifica o número máximo de processos simultâneos a serem 
+        <target state="translated">  -maxCpuCount[:n] Especifica o número máximo de processos simultâneos a serem
                      compilados. Se a opção não for usada, o valor padrão
                      usado será 1. Se a opção for usada sem um valor, o
-                     MSBuild usará o número de processadores do 
+                     MSBuild usará o número de processadores do
                      computador. (Forma abreviada: -m[:n])
       </target>
         <note>
@@ -630,7 +639,7 @@ isoladamente.
         <target state="translated">Exemplos:
 
         MSBuild MyApp.sln -t:Rebuild -p:Configuration=Release
-        MSBuild MyApp.csproj -t:Clean 
+        MSBuild MyApp.csproj -t:Clean
                              -p:Configuration=Debug;TargetFrameworkVersion=v3.5
     </target>
         <note>
@@ -645,11 +654,10 @@ isoladamente.
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
                      Lista separada por ponto e vírgula de arquivos de cache de entrada dos quais o MSBuild
                      lerá os resultados do build.
                      A definição dessa opção também habilita os builds isolados (-isolate).
@@ -664,10 +672,10 @@ isoladamente.
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[cacheFile]
+        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
                      Arquivo de cache de saída no qual o MSBuild gravará o conteúdo
                      dos caches de resultado do build no final do build.
                      A configuração dessa opção também habilita builds isolado (-isolate).
@@ -793,12 +801,12 @@ isoladamente.
                      10 file loggers to be attached. (Short form: -fl[n])
     </source>
         <target state="translated">  -fileLogger[n] Registra a saída do build em um arquivo. Por padrão,
-                     o arquivo está no diretório atual e tem o nome 
+                     o arquivo está no diretório atual e tem o nome
                      "msbuild[n].log". Os eventos de todos os nós são combinados em
                      um único log. A localização do arquivo e outros
-                     parâmetros do fileLogger pode ser especificada por meio 
+                     parâmetros do fileLogger pode ser especificada por meio
                      do acréscimo da opção "-fileLoggerParameters[n]".
-                     "n", se presente, pode ser um dígito de 1 a 9, permitindo que até 
+                     "n", se presente, pode ser um dígito de 1 a 9, permitindo que até
                      10 agentes de arquivo sejam anexados. (Forma abreviada: -fl[n])
     </target>
         <note>
@@ -951,14 +959,14 @@ isoladamente.
                      Example:
                        -pp:out.txt
     </source>
-        <target state="translated">  -preprocess[:arquivo] 
+        <target state="translated">  -preprocess[:arquivo]
                      Cria um arquivo de projeto único e agregado
                      embutindo todos os arquivos que poderiam ser importados durante um
                      build, com seus limites marcados. Isso pode ser
                      útil para descobrir quais arquivos são importados,
                      de qual localização e como contribuirão para
                      o build. Por padrão, a saída é gravada na
-                     janela do console. Se o caminho de um arquivo de saída 
+                     janela do console. Se o caminho de um arquivo de saída
                      for fornecido, ele será usado.
                      (Forma abreviada: -pp)
                      Exemplo:
@@ -1025,11 +1033,12 @@ isoladamente.
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: O valor de projetos isolados não é válido. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: O valor de projetos isolados não é válido. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1538,7 +1547,7 @@ isoladamente.
                        -warnAsError:MSB4130
 
                      Quando um aviso for tratado como um erro, o destino continuará
-                     a ser executado como se ele fosse um aviso, mas o 
+                     a ser executado como se ele fosse um aviso, mas o
                      build geral falhará.
     </target>
         <note>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 3e778b63862..252b68b4885 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -129,9 +129,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -140,7 +149,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      Сообщает MSBuild, что нужно собирать каждый проект по отдельности.
 
                      Это более строгий режим MSBuild, так как он требует,
@@ -643,11 +652,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;файл_кэша&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;файл_кэша&gt;...
                      Разделенный точкам с запятой список входных файлов кэша, откуда MSBuild
                      будет считывать результаты.
                      Задание этого параметра также включает изолированные сборки (-isolate).
@@ -662,10 +670,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[файл_кэша]
+        <target state="needs-review-translation">  -outputResultsCache:[файл_кэша]
                      Выходной файл кэша, где MSBuild будет записывать содержимое
                      результата кэша сборки в конце.
                      При задании этого параметра также включаются изолированные сборки (-isolate).
@@ -1023,11 +1031,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: значение изолирования проектов является недопустимым. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: значение изолирования проектов является недопустимым. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index acbff27d93c..4ff9206f999 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -120,7 +120,7 @@
                      izin verildiğini gösterir.  Etkileşimin beklenmediği
                      otomatik bir senaryoda bu bağımsız değişkeni
                      kullanmayın.
-                     -interactive değerinin belirtilmesi, -interactive:true 
+                     -interactive değerinin belirtilmesi, -interactive:true
                      değerinin belirtilmesiyle aynıdır.  Parametreyi, yanıt
                      dosyasından gelen bir değeri geçersiz kılmak için kullanın.
     </target>
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,7 +150,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      MSBuild tarafından her projenin yalıtılmış olarak oluşturulmasına yol açar.
 
                      Bu mod, değerlendirme sırasında proje grafiğinin
@@ -397,7 +406,7 @@
                      Example:
                        -property:WarningLevel=2;OutDir=bin\Debug\
 </source>
-        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  Bu proje düzeyi özellikleri ayarlayın veya geçersiz kılın. &lt;n&gt; 
+        <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  Bu proje düzeyi özellikleri ayarlayın veya geçersiz kılın. &lt;n&gt;
                      özelliğin adı ve &lt;v&gt; özelliğin değeridir. Birden çok
                      özelliği birbirinden ayırmak için noktalı virgül veya virgül
                      kullanın veya her özelliği ayrı ayrı belirtin. (Kısa biçim: -p)
@@ -438,7 +447,7 @@
                      &lt;günlükçü derlemesi&gt; söz dizimi şöyledir:
                        {&lt;derleme adı&gt;[,&lt;strong name&gt;] | &lt;derleme dosyası&gt;}
                      Günlükçü seçenekleri, MSBuild'in günlükçüyü oluşturma biçimini belirtir.
-                     &lt;günlükçü parametreleri &gt; isteğe bağlıdır ve tam olarak 
+                     &lt;günlükçü parametreleri &gt; isteğe bağlıdır ve tam olarak
                      yazdığınız şekliyle günlükçüye geçirilir. (Kısa biçim: -l)
                      Örnekler:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -644,11 +653,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;önbellekDosyası&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;önbellekDosyası&gt;...
                      MSBuild'in derleme sonuçlarını okuyacağı giriş
                      önbellek dosyalarının noktalı virgülle ayrılmış listesi.
                      Ayarlandığında yalıtılmış derlemeler de açılır (-isolate).
@@ -663,10 +671,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[önbellekDosyası]
+        <target state="needs-review-translation">  -outputResultsCache:[önbellekDosyası]
                      MSBuild’in derleme sonunda derleme sonucu önbelleklerinin
                      içeriğini yazacağı çıkış önbellek dosyası.
                      Bu açıldığında yalıtılmış derlemeler (-isolate) de açılır.
@@ -739,9 +747,9 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;uzantılar&gt;
-                     Hangi proje dosyasının oluşturulacağı belirlenirken 
-                     yoksayılacak uzantıların listesi. Birden çok uzantıyı 
-                     birbirinden ayırmak için noktalı virgül veya 
+                     Hangi proje dosyasının oluşturulacağı belirlenirken
+                     yoksayılacak uzantıların listesi. Birden çok uzantıyı
+                     birbirinden ayırmak için noktalı virgül veya
                      virgül kullanın.
                      (Kısa biçim: -ignore)
                      Örnek:
@@ -767,8 +775,8 @@
    </source>
         <target state="translated">  -toolsVersion:&lt;sürüm&gt;
                      Derleme sırasında kullanılacak MSBuild Araç Kümesinin
-                     (görevler, hedefler vb.) sürümü. Bu sürüm, tek tek projelerde 
-                     belirtilen sürümleri geçersiz kılar. (Kısa biçim: 
+                     (görevler, hedefler vb.) sürümü. Bu sürüm, tek tek projelerde
+                     belirtilen sürümleri geçersiz kılar. (Kısa biçim:
                      -tv)
                      Örnek:
                        -toolsVersion:3.5
@@ -827,14 +835,14 @@
         <target state="translated">  -distributedFileLogger
                      Derleme çıkışını, her MSBuild düğümü için bir günlük
                      dosyası olmak üzere birden çok günlük dosyasına kaydeder. Bu
-                     dosyaların ilk konumu geçerli dizindir. Dosyaların 
-                     varsayılan adı "MSBuild&lt;düğümkimliği&gt;.log"dur. 
-                     Dosyaların konumu ve fileLogger'ın diğer parametreleri 
+                     dosyaların ilk konumu geçerli dizindir. Dosyaların
+                     varsayılan adı "MSBuild&lt;düğümkimliği&gt;.log"dur.
+                     Dosyaların konumu ve fileLogger'ın diğer parametreleri
                      "/fileLoggerParameters" anahtarının eklenmesi yoluyla
                      belirtilebilir.
 
                      Günlük dosyası adı fileLoggerParameters anahtarı
-                     aracılığıyla ayarlanırsa dağıtılmış günlükçü fileName 
+                     aracılığıyla ayarlanırsa dağıtılmış günlükçü fileName
                      değerini şablon olarak kullanıp her düğümün günlük dosyasını
                      oluşturmak için bu fileName değerine düğüm kimliğini ekler.
     </target>
@@ -879,32 +887,32 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parametreler&gt;
                      Dosya günlükçüleri için ek parametreler sağlar.
-                     Bu anahtarın olması karşılık gelen -fileLogger[n] 
+                     Bu anahtarın olması karşılık gelen -fileLogger[n]
                      anahtarının olduğu anlamına gelir.
                      "n" varsa, 1-9 arasında bir rakam olabilir.
-                     Dağıtılmış dosya günlükçüleri varsa -fileLoggerParameters 
-                     bunlar tarafından da kullanılır; -distributedFileLogger 
+                     Dağıtılmış dosya günlükçüleri varsa -fileLoggerParameters
+                     bunlar tarafından da kullanılır; -distributedFileLogger
                      açıklamasına bakın.
                      (Kısa biçim: -flp[n])
-                     Konsol günlükçüsü için listelenenlerle aynı parametreler 
+                     Konsol günlükçüsü için listelenenlerle aynı parametreler
                      kullanılabilir. Kullanılabilecek bazı ek parametreler:
-                        LogFile--Oluşturma günlüğünün yazılacağı günlük 
+                        LogFile--Oluşturma günlüğünün yazılacağı günlük
                             dosyasının yolu.
-                        Append--Derleme günlüğünün gün dosyasının sonuna mı 
-                            ekleneceğini yoksa üzerine mi yazılacağını 
-                            belirler. Anahtar ayarlandığında oluşturma günlüğü 
-                            dosyanın sonuna eklenir. Anahtar ayarlanmadığında 
-                            varolan günlük dosyasının üzerine yazılır. 
+                        Append--Derleme günlüğünün gün dosyasının sonuna mı
+                            ekleneceğini yoksa üzerine mi yazılacağını
+                            belirler. Anahtar ayarlandığında oluşturma günlüğü
+                            dosyanın sonuna eklenir. Anahtar ayarlanmadığında
+                            varolan günlük dosyasının üzerine yazılır.
                             Varsayılan: günlük dosyasının sonuna eklenmez.
-                        Encoding--Dosyanın kodlamasını belirtir; örneğin, 
+                        Encoding--Dosyanın kodlamasını belirtir; örneğin,
                             UTF-8, Unicode veya ASCII
                      Varsayılan ayrıntı düzeyi ayarı Detailed'dır.
                      Örnekler:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1028,11 +1036,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: Projeleri yalıtma değeri geçerli değil. {0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: Projeleri yalıtma değeri geçerli değil. {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index ac8ff48e194..a5ec18908f5 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,7 +150,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      使 MSBuild 独立生成每个项目。
 
                      这是 MSBuild 更具限制性的模式，因为它要求
@@ -584,10 +593,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate     依据默认架构验证项目。(缩写: 
+        <target state="translated">  -validate     依据默认架构验证项目。(缩写:
            -val)
 
- -validate:&lt;schema&gt; 依据指定的架构验证项目。(缩写: 
+ -validate:&lt;schema&gt; 依据指定的架构验证项目。(缩写:
            -val)
            示例:
             -validate:MyExtendedBuildSchema.xsd
@@ -644,11 +653,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;cacheFile&gt;...
                      输入缓存文件的分号分隔列表，MSBuild
                      将从这些文件中读取生成结果。
                      设置此列表还将打开分隔的生成(-isolate)。
@@ -663,10 +671,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[cacheFile]
+        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
                      输出缓存文件，MSBuild 将在
                      生成结束时写入其生成结果缓存的内容。
                      设置它也会打开隔离的生成 (-isolate).
@@ -767,7 +775,7 @@
         <target state="translated">  -toolsversion:&lt;version&gt;
            要在生成过程中使用的 MSBuild 工具集
            (任务、目标等)的版本。此版本将重写
-           各个项目指定的版本。(缩写: 
+           各个项目指定的版本。(缩写:
            -tv)
            示例:
             -toolsversion:3.5
@@ -823,17 +831,17 @@
                      template and append the node id to this fileName to
                      create a log file for each node.
     </source>
-        <target state="translated">  -distributedFileLogger                            
+        <target state="translated">  -distributedFileLogger
            将生成输出记录到多个日志文件，每个 MSBuild 节点
            一个日志文件。这些文件的初始位置为
            当前目录。默认情况下，这些文件名为
            “MSBuild&lt;nodeid&gt;.log”。可通过添加
-           “-fileLoggerParameters”开关来指定 
+           “-fileLoggerParameters”开关来指定
            这些文件的位置和 fileLogger 的其他参数。
 
            如果日志文件名是通过 fileLoggerParameters
            开关设置的，分布式记录器将使用 fileName 作为
-           模板并将节点 ID 附加到此 fileName 
+           模板并将节点 ID 附加到此 fileName
            以便为每个节点创建一个日志文件。
     </target>
         <note>
@@ -875,12 +883,12 @@
                        -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </source>
-        <target state="translated">  -fileloggerparameters[n]:&lt;parameters&gt;                
+        <target state="translated">  -fileloggerparameters[n]:&lt;parameters&gt;
            为文件记录器提供任何额外的参数。
            存在此开关意味着
            存在对应的 -filelogger[n] 开关。
           “n”(如果存在)可以为 1-9 的数字。
-           任何分布式文件记录器也可以使用 
+           任何分布式文件记录器也可以使用
            -fileloggerparameters，具体可参阅 -distributedFileLogger 的说明。
            (缩写: -flp[n])
            为控制台记录器列出的相同参数
@@ -900,8 +908,8 @@
             -fileLoggerParameters:LogFile=MyLog.log;Append;
                       Verbosity=diagnostic;Encoding=UTF-8
 
-            -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-            -flp1:warningsonly;logfile=msbuild.wrn 
+            -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+            -flp1:warningsonly;logfile=msbuild.wrn
             -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1024,11 +1032,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: 独立项目值无效。{0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: 独立项目值无效。{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index b2f5a5a0110..521bc7fb13b 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -130,9 +130,18 @@
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_35_IsolateProjectsSwitch">
-        <source>  -isolateProjects[:True|False]
+        <source>  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      Causes MSBuild to build each project in isolation.
 
+                     When set to "MessageUponIsolationViolation" (or its short
+                     form "Message"), only the results from top-level targets
+                     are serialized if the -outputResultsCache switch is
+                     supplied. This is to mitigate the chances of an
+                     isolation-violating target on a dependency project using
+                     incorrect state due to its dependency on a cached target
+                     whose side effects would not be taken into account.
+                     (For example, the definition of a property.)
+
                      This is a more restrictive mode of MSBuild as it requires
                      that the project graph be statically discoverable at
                      evaluation time, but can improve scheduling and reduce
@@ -141,7 +150,7 @@
 
                      This flag is experimental and may not work as intended.
     </source>
-        <target state="translated">  -isolateProjects[:True|False]
+        <target state="needs-review-translation">  -isolateProjects[:True|False]
                      引發 MSBuild 獨立建置各個專案。
 
                      這是限制度較高的 MSBuild 模式，因為
@@ -644,11 +653,10 @@
       <trans-unit id="HelpMessage_InputCachesFiles">
         <source>  -inputResultsCaches:&lt;cacheFile&gt;...
                      Semicolon separated list of input cache files that MSBuild
-                     will read build results from.
-                     Setting this also turns on isolated builds (-isolate).
-                     (short form: -irc)
+                     will read build results from. If -isolateProjects is set
+                     to False, this sets it to True. (short form: -irc)
    </source>
-        <target state="translated">  -inputResultsCaches:&lt;快取檔案&gt;...
+        <target state="needs-review-translation">  -inputResultsCaches:&lt;快取檔案&gt;...
                      以分號分隔的輸入快取檔案
                       (MSBuild 將會從此檔案讀取建置結果) 清單。
                      設定此項目也會開啟隔離式建置 (-isolate)。
@@ -663,10 +671,10 @@
         <source>  -outputResultsCache:[cacheFile]
                      Output cache file where MSBuild will write the contents of
                      its build result caches at the end of the build.
-                     Setting this also turns on isolated builds (-isolate).
+                     If -isolateProjects is set to False, this sets it to True.
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:[cacheFile]
+        <target state="needs-review-translation">  -outputResultsCache:[cacheFile]
                      MSBuild 要在組建結束時寫入
                      其組建結果快取內容的目標輸出快取檔案。
                      設定此項也會開啟隔離組建 (-isolate)。
@@ -766,8 +774,8 @@
    </source>
         <target state="translated">  -toolsversion:&lt;版本&gt;
                      建置期間所使用的 MSBuild 工具組 (工作、目標等)
-                      版本。此版本將會覆寫 
-                     個別專案所指定的版本。(簡短形式: 
+                      版本。此版本將會覆寫
+                     個別專案所指定的版本。(簡短形式:
                      -tv)
                      範例:
                        -toolsVersion:3.5
@@ -1024,11 +1032,12 @@
       </trans-unit>
       <trans-unit id="InvalidIsolateProjectsValue">
         <source>MSBUILD : error MSB1056: Isolate projects value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1056: 獨立式專案值無效。{0}</target>
+        <target state="needs-review-translation">MSBUILD : error MSB1056: 獨立式專案值無效。{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1056: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      This error is shown when a user specifies a value for the -isolateProjects parameter that is not equivalent
+      to Boolean.TrueString, nameof(ProjectIsolationMode.MessageUponIsolationViolation), or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index cbfae02ba52..92d64fc8401 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -701,7 +701,7 @@ public static ExitType Execute(
                 ProfilerLogger profilerLogger = null;
                 bool enableProfiler = false;
                 bool interactive = false;
-                bool isolateProjects = false;
+                ProjectIsolationMode isolateProjects = ProjectIsolationMode.False;
                 GraphBuildOptions graphBuildOptions = null;
                 bool lowPriority = false;
                 string[] inputResultsCaches = null;
@@ -1118,7 +1118,7 @@ internal static bool BuildProject(
             ProfilerLogger profilerLogger,
             bool enableProfiler,
             bool interactive,
-            bool isolateProjects,
+            ProjectIsolationMode isolateProjects,
             GraphBuildOptions graphBuildOptions,
             bool lowPriority,
             string[] inputResultsCaches,
@@ -1289,7 +1289,7 @@ internal static bool BuildProject(
                     parameters.WarningsNotAsErrors = warningsNotAsErrors;
                     parameters.WarningsAsMessages = warningsAsMessages;
                     parameters.Interactive = interactive;
-                    parameters.IsolateProjects = isolateProjects;
+                    parameters.ProjectIsolationMode = isolateProjects;
                     parameters.InputResultsCacheFiles = inputResultsCaches;
                     parameters.OutputResultsCacheFile = outputResultsCache;
 
@@ -2210,7 +2210,7 @@ private static bool ProcessCommandLineSwitches(
             ref ProfilerLogger profilerLogger,
             ref bool enableProfiler,
             ref Dictionary<string, string> restoreProperties,
-            ref bool isolateProjects,
+            ref ProjectIsolationMode isolateProjects,
             ref GraphBuildOptions graphBuild,
             ref string[] inputResultsCaches,
             ref string outputResultsCache,
@@ -2385,7 +2385,7 @@ private static bool ProcessCommandLineSwitches(
 
                     if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.IsolateProjects))
                     {
-                        isolateProjects = ProcessBooleanSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.IsolateProjects], defaultValue: true, resourceName: "InvalidIsolateProjectsValue");
+                        isolateProjects = ProcessIsolateProjectsSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.IsolateProjects]);
                     }
 
                     if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.GraphBuild))
@@ -2526,6 +2526,39 @@ private static bool WarningsAsErrorsSwitchIsEmpty(CommandLineSwitches commandLin
             return indexOfColon < 0 || indexOfColon == val.Length - 1;
         }
 
+        internal static ProjectIsolationMode ProcessIsolateProjectsSwitch(string[] parameters)
+        {
+
+            // Before /isolate had parameters, it was treated as a boolean switch.
+            // Preserve that in case anyone is using /isolate:{false|true}
+            if (parameters.Length == 1 && bool.TryParse(parameters[0], out bool boolValue))
+            {
+                return boolValue ? ProjectIsolationMode.True : ProjectIsolationMode.False;
+            }
+
+            ProjectIsolationMode isolateProjects = ProjectIsolationMode.True;
+            foreach (string parameter in parameters)
+            {
+                if (string.IsNullOrWhiteSpace(parameter))
+                {
+                    continue;
+                }
+
+                string trimmedParameter = parameter.Trim();
+                if (trimmedParameter.Equals(nameof(ProjectIsolationMode.MessageUponIsolationViolation), StringComparison.OrdinalIgnoreCase)
+                    || trimmedParameter.Equals("Message", StringComparison.OrdinalIgnoreCase))
+                {
+                    isolateProjects = ProjectIsolationMode.MessageUponIsolationViolation;
+                }
+                else
+                {
+                    CommandLineSwitchException.Throw("InvalidIsolateProjectsValue", parameter);
+                }
+            }
+
+            return isolateProjects;
+        }
+
         internal static GraphBuildOptions ProcessGraphBuildSwitch(string[] parameters)
         {
             var options = new GraphBuildOptions();
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index ac61dc8380c..68d24c68b48 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1360,7 +1360,11 @@ public static BuildResult BuildProjectContentUsingBuildManager(string content, M
             }
         }
 
-        public static BuildResult BuildProjectFileUsingBuildManager(string projectFile, MockLogger logger = null, BuildParameters parameters = null)
+        public static BuildResult BuildProjectFileUsingBuildManager(
+            string projectFile,
+            MockLogger logger = null,
+            BuildParameters parameters = null,
+            IList<string> targetsToBuild = null)
         {
             using (var buildManager = new BuildManager())
             {
@@ -1377,7 +1381,7 @@ public static BuildResult BuildProjectFileUsingBuildManager(string projectFile,
                     projectFile,
                     new Dictionary<string, string>(),
                     MSBuildConstants.CurrentToolsVersion,
-                    Array.Empty<string>(),
+                    targetsToBuild?.ToArray() ?? Array.Empty<string>(),
                     null);
 
                 var result = buildManager.Build(
diff --git a/src/StringTools/InternableString.Simple.cs b/src/StringTools/InternableString.Simple.cs
index cffe45afc46..57789ab0700 100644
--- a/src/StringTools/InternableString.Simple.cs
+++ b/src/StringTools/InternableString.Simple.cs
@@ -200,29 +200,45 @@ public override unsafe string ToString()
         /// <returns>A stable hashcode of the string represented by this instance.</returns>
         public override int GetHashCode()
         {
-            int hashCode = 5381;
+            uint hash = (5381 << 16) + 5381;
+            bool isOddIndex = false;
 
             if (_firstString != null)
             {
                 foreach (char ch in _firstString)
                 {
-                    unchecked
-                    {
-                        hashCode = hashCode * 33 ^ ch;
-                    }
+                    hash = HashOneCharacter(hash, ch, isOddIndex);
+                    isOddIndex = !isOddIndex;
                 }
             }
             else if (_builder != null)
             {
                 for (int i = 0; i < _builder.Length; i++)
                 {
-                    unchecked
-                    {
-                        hashCode = hashCode * 33 ^ _builder[i];
-                    }
+                    hash = HashOneCharacter(hash, _builder[i], isOddIndex);
+                    isOddIndex = !isOddIndex;
                 }
             }
-            return hashCode;
+            return (int)hash;
+        }
+
+        /// <summary>
+        /// A helper to hash one character.
+        /// </summary>
+        /// <param name="hash">The running hash code.</param>
+        /// <param name="ch">The character to hash.</param>
+        /// <param name="isOddIndex">True if the index of the character in the string is odd.</param>
+        /// <returns></returns>
+        private static uint HashOneCharacter(uint hash, char ch, bool isOddIndex)
+        {
+            if (isOddIndex)
+            {
+                // The hash code was rotated for the previous character, just xor.
+                return hash ^ ((uint)ch << 16);
+            }
+
+            uint rotatedHash = (hash << 5) | (hash >> (32 - 5));
+            return (rotatedHash + hash) ^ ch;
         }
     }
 }
diff --git a/src/Tasks/Microsoft.Managed.After.targets b/src/Tasks/Microsoft.Managed.After.targets
index 48264892122..fc33d41e1c4 100644
--- a/src/Tasks/Microsoft.Managed.After.targets
+++ b/src/Tasks/Microsoft.Managed.After.targets
@@ -41,11 +41,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <_MainReferenceTargetForBuild Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTargetForBuild>
     <_MainReferenceTargetForBuild Condition="'$(_MainReferenceTargetForBuild)' == ''">GetTargetPath</_MainReferenceTargetForBuild>
 
-    <ProjectReferenceTargetsForBuildInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>
-    <ProjectReferenceTargetsForBuild>$(_MainReferenceTargetForBuild);GetNativeManifest;$(_RecursiveTargetForContentCopying);GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
+    <ProjectReferenceTargetsForBuild>$(_MainReferenceTargetForBuild);GetNativeManifest;$(_RecursiveTargetForContentCopying);$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
 
-    <ProjectReferenceTargetsForCleanInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForCleanInOuterBuild)</ProjectReferenceTargetsForCleanInOuterBuild>
-    <ProjectReferenceTargetsForClean>Clean;GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
+    <ProjectReferenceTargetsForClean>Clean;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
 
     <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
 
@@ -59,11 +57,21 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
     <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' " OuterBuild="true" />
+    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" />
     <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuild)" Condition=" '$(ProjectReferenceTargetsForBuild)' != '' " />
-
+    
     <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForCleanInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' " OuterBuild="true" />
+    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" />
     <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForClean)" Condition=" '$(ProjectReferenceTargetsForClean)' != '' " />
 
+    <!--
+     Note: SkipNonexistentTargets="true" on the following three items means that an outer build node's call to its existent GetTargetFrameworks target will fail if its inner build nodes don't define GetTargetFrameworksWithPlatformForSingleTargetFrameworks.
+     This is necessary since the P2P protocol cannot express the targets called from the outer build to the inner build.
+     -->
+    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" />
+    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" />
+    <ProjectReferenceTargets Include="Rebuild" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" />
+
     <ProjectReferenceTargets Include="Rebuild" Targets="$(ProjectReferenceTargetsForRebuild)" Condition=" '$(ProjectReferenceTargetsForRebuild)' != '' " />
 
     <ProjectReferenceTargets Include="Publish" Targets="$(ProjectReferenceTargetsForPublish)" Condition=" '$(ProjectReferenceTargetsForPublish)' != '' " />
diff --git a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
index f46e35ee4e3..ff9c8243fea 100644
--- a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
+++ b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
@@ -22,6 +22,11 @@ internal static string ProcessorArchitectureIntToString()
                 NativeMethodsShared.ProcessorArchitectures.IA64 => ProcessorArchitecture.IA64,
                 NativeMethodsShared.ProcessorArchitectures.ARM => ProcessorArchitecture.ARM,
                 NativeMethodsShared.ProcessorArchitectures.ARM64 => ProcessorArchitecture.ARM64,
+                NativeMethodsShared.ProcessorArchitectures.WASM => ProcessorArchitecture.WASM,
+                NativeMethodsShared.ProcessorArchitectures.S390X => ProcessorArchitecture.S390X,
+                NativeMethodsShared.ProcessorArchitectures.LOONGARCH64 => ProcessorArchitecture.LOONGARCH64,
+                NativeMethodsShared.ProcessorArchitectures.ARMV6 => ProcessorArchitecture.ARMV6,
+                NativeMethodsShared.ProcessorArchitectures.PPC64LE => ProcessorArchitecture.PPC64LE,
                 // unknown architecture? return null
                 _ => null,
             };
@@ -37,6 +42,11 @@ public void ValidateProcessorArchitectureStrings()
             ProcessorArchitecture.MSIL.ShouldBe("MSIL"); // "MSIL ProcessorArchitecture isn't correct"
             ProcessorArchitecture.ARM.ShouldBe("ARM"); // "ARM ProcessorArchitecture isn't correct"
             ProcessorArchitecture.ARM64.ShouldBe("ARM64"); // "ARM ProcessorArchitecture isn't correct"
+            ProcessorArchitecture.WASM.ShouldBe("WASM"); // "WASM ProcessorArchitecture isn't correct"
+            ProcessorArchitecture.S390X.ShouldBe("S390X"); // "S390X ProcessorArchitecture isn't correct"
+            ProcessorArchitecture.LOONGARCH64.ShouldBe("LOONGARCH64"); // "LOONGARCH64 ProcessorArchitecture isn't correct"
+            ProcessorArchitecture.ARMV6.ShouldBe("ARMV6"); // "ARMV6 ProcessorArchitecture isn't correct"
+            ProcessorArchitecture.PPC64LE.ShouldBe("PPC64LE"); // "PPC64LE ProcessorArchitecture isn't correct"
         }
 
         [Fact]
diff --git a/src/Utilities/ProcessorArchitecture.cs b/src/Utilities/ProcessorArchitecture.cs
index 962ef126ff0..88946934b37 100644
--- a/src/Utilities/ProcessorArchitecture.cs
+++ b/src/Utilities/ProcessorArchitecture.cs
@@ -45,6 +45,31 @@ public static class ProcessorArchitecture
         [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "ARM64", Justification = "This is the correct casing for ProcessorArchitecture")]
         public const string ARM64 = nameof(ARM64);
 
+        /// <summary>
+        /// Represents the WebAssembly platform.
+        /// </summary>
+        public const string WASM = nameof(WASM);
+
+        /// <summary>
+        /// Represents the S390x processor architecture.
+        /// </summary>
+        public const string S390X = nameof(S390X);
+
+        /// <summary>
+        /// Represents the LoongAarch64 processor architecture.
+        /// </summary>
+        public const string LOONGARCH64 = nameof(LOONGARCH64);
+
+        /// <summary>
+        /// Represents the 32-bit ARMv6 processor architecture.
+        /// </summary>
+        public const string ARMV6 = nameof(ARMV6);
+
+        /// <summary>
+        /// Represents the PowerPC 64-bit (little-endian) processor architecture.
+        /// </summary>
+        public const string PPC64LE = nameof(PPC64LE);
+
         /// <summary>
         /// Lazy-initted property for getting the architecture of the currently running process
         /// </summary>
@@ -63,6 +88,11 @@ private static string GetCurrentProcessArchitecture()
                 NativeMethodsShared.ProcessorArchitectures.IA64 => IA64,
                 NativeMethodsShared.ProcessorArchitectures.ARM => ARM,
                 NativeMethodsShared.ProcessorArchitectures.ARM64 => ARM64,
+                NativeMethodsShared.ProcessorArchitectures.WASM => WASM,
+                NativeMethodsShared.ProcessorArchitectures.S390X => S390X,
+                NativeMethodsShared.ProcessorArchitectures.LOONGARCH64 => LOONGARCH64,
+                NativeMethodsShared.ProcessorArchitectures.ARMV6 => ARMV6,
+                NativeMethodsShared.ProcessorArchitectures.PPC64LE => PPC64LE,
                 // unknown architecture? return null
                 _ => null,
             };
