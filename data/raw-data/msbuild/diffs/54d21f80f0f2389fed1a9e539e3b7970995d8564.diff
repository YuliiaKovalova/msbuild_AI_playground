diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 958198fbb12..079258236b7 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -10,8 +10,11 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
+using Microsoft.CodeAnalysis.CSharp.Syntax;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -110,10 +113,15 @@ public void UpdatingReferencesIsBidirectional()
                 var projectInstance = new Project().CreateProjectInstance();
                 var node = new ProjectGraphNode(projectInstance);
                 var reference1 = new ProjectGraphNode(projectInstance);
+                var referenceItem1 = new ProjectItemInstance(projectInstance, "Ref1", "path1", "file1");
+
                 var reference2 = new ProjectGraphNode(projectInstance);
+                var referenceItem2 = new ProjectItemInstance(projectInstance, "Ref2", "path2", "file2");
+
+                var edges = new GraphBuilder.GraphEdges();
 
-                node.AddProjectReference(reference1);
-                node.AddProjectReference(reference2);
+                node.AddProjectReference(reference1, referenceItem1, edges);
+                node.AddProjectReference(reference2, referenceItem2, edges);
 
                 node.ProjectReferences.ShouldBeEquivalentTo(new []{reference1, reference2});
                 node.ReferencingProjects.ShouldBeEmpty();
@@ -124,7 +132,12 @@ public void UpdatingReferencesIsBidirectional()
                 reference2.ReferencingProjects.ShouldBeEquivalentTo(new[] {node});
                 reference2.ProjectReferences.ShouldBeEmpty();
 
-                node.RemoveReferences();
+                edges[(node, reference1)].ShouldBe(referenceItem1);
+                edges[(node, reference2)].ShouldBe(referenceItem2);
+
+                edges.Count.ShouldBe(2);
+
+                node.RemoveReferences(edges);
 
                 node.ProjectReferences.ShouldBeEmpty();
                 node.ReferencingProjects.ShouldBeEmpty();
@@ -134,6 +147,32 @@ public void UpdatingReferencesIsBidirectional()
 
                 reference2.ProjectReferences.ShouldBeEmpty();
                 reference2.ReferencingProjects.ShouldBeEmpty();
+
+                edges.Count.ShouldBe(0);
+            }
+        }
+
+        [Fact]
+        public void FirstEdgeWinsWhenMultipleEdgesPointToSameReference()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var projectInstance = new Project().CreateProjectInstance();
+                var node = new ProjectGraphNode(projectInstance);
+                var reference1 = new ProjectGraphNode(projectInstance);
+                var referenceItem1 = new ProjectItemInstance(projectInstance, "Ref1", "path1", "file1");
+                var referenceItem2 = new ProjectItemInstance(projectInstance, "Ref2", "path1", "file1");
+
+                var edges = new GraphBuilder.GraphEdges();
+
+                node.AddProjectReference(reference1, referenceItem1, edges);
+
+                // add same reference but via a different edge
+                node.AddProjectReference(reference1, referenceItem2, edges);
+
+                edges.Count.ShouldBe(1);
+
+                edges[(node, reference1)].ShouldBe(referenceItem1);
             }
         }
 
@@ -799,8 +838,8 @@ public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()
                 targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
                 var root = GetFirstNodeWithProjectNumber(projectGraph, 1);
 
-                var outerBuild = GetNodesWithProjectNumber(projectGraph, 2).First(IsOuterBuild);
-                var innerBuilds = GetNodesWithProjectNumber(projectGraph, 2).Where(IsInnerBuild).ToArray();
+                var outerBuild = GetOuterBuild(projectGraph, 2);
+                var innerBuilds = GetInnerBuilds(projectGraph, 2).ToArray();
 
                 targetLists[root].ShouldBe(new[] { "A" });
                 targetLists[outerBuild].ShouldBe(OuterBuildTargets);
@@ -812,6 +851,78 @@ public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()
             }
         }
 
+        [Fact]
+        public void GetTargetListsDoesNotUseTargetsMetadataOnInnerBuildsFromRootOuterBuilds()
+        {
+            var projectReferenceTargetsProtocol =
+$@"<ItemGroup>
+     <ProjectReferenceTargets Include='A' Targets='{MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker};A;AInner' />
+     <ProjectReferenceTargets Include='A' Targets='{MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker};A;AOuter' OuterBuild='true' />
+   </ItemGroup>";
+
+            var entryProject = CreateProjectFile(
+                env: _env,
+                projectNumber: 1,
+                projectReferences: null,
+                projectReferenceTargets: null,
+                defaultTargets: "D1",
+                extraContent: MultitargetingSpecification +
+                              projectReferenceTargetsProtocol +
+$@"
+<ItemGroup>
+    <ProjectReference Include='2.proj' Targets='T2' />
+</ItemGroup>
+"
+                ).Path;
+            CreateProjectFile(
+                env: _env,
+                projectNumber: 2,
+                projectReferences: null,
+                projectReferenceTargets: null,
+                defaultTargets: "D2",
+                extraContent: projectReferenceTargetsProtocol +
+$@"
+<ItemGroup>
+    <ProjectReference Include='3.proj' Targets='T3' />
+</ItemGroup>
+");
+            CreateProjectFile(
+                env: _env,
+                projectNumber: 3,
+                projectReferences: null,
+                projectReferenceTargets: null,
+                defaultTargets: "D3",
+                extraContent: MultitargetingSpecification + projectReferenceTargetsProtocol);
+
+            var graph = new ProjectGraph(entryProject);
+
+            var dot = graph.ToDot();
+
+            var rootOuterBuild = GetOuterBuild(graph, 1);
+            var nonRootOuterBuild = GetOuterBuild(graph, 3);
+
+            AssertOuterBuildAsRoot(rootOuterBuild, graph);
+            AssertOuterBuildAsNonRoot(nonRootOuterBuild, graph);
+
+            var targetLists = graph.GetTargetLists(new[] {"A"});
+
+            targetLists[rootOuterBuild].ShouldBe(new []{"A"});
+
+            foreach (var innerBuild in GetInnerBuilds(graph, 1))
+            {
+                targetLists[innerBuild].ShouldBe(new []{"D1", "A", "AOuter", "AInner"});
+            }
+
+            targetLists[GetFirstNodeWithProjectNumber(graph, 2)].ShouldBe(new []{"T2", "A", "AOuter", "AInner"});
+
+            targetLists[nonRootOuterBuild].ShouldBe(new []{"T3", "A", "AOuter"});
+
+            foreach (var innerBuild in GetInnerBuilds(graph, 3))
+            {
+                targetLists[innerBuild].ShouldBe(new []{"T3", "A", "AOuter", "AInner"});
+            }
+        }
+
         [Fact]
         public void GetTargetListsForComplexMultitargetingGraph()
         {
@@ -909,9 +1020,9 @@ public void GetTargetListsForComplexMultitargetingGraph()
 
             void AssertMultitargetingNode(int projectNumber, ProjectGraph projectGraph, IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists, string[] outerBuildTargets, string[] nonOuterBuildTargets)
             {
-                targetLists[GetNodesWithProjectNumber(projectGraph, projectNumber).First(IsOuterBuild)].ShouldBe(outerBuildTargets);
+                targetLists[GetOuterBuild(projectGraph, projectNumber)].ShouldBe(outerBuildTargets);
 
-                foreach (var innerBuild in GetNodesWithProjectNumber(projectGraph, projectNumber).Where(IsInnerBuild))
+                foreach (var innerBuild in GetInnerBuilds(projectGraph, projectNumber))
                 {
                     targetLists[innerBuild].ShouldBe(nonOuterBuildTargets);
                 }
@@ -994,6 +1105,61 @@ public void GetTargetListsDefaultComplexPropagation()
             }
         }
 
+        [Fact]
+        public void GetTargetsListProjectReferenceTargetsOrDefaultComplexPropagation()
+        {
+            var referenceItem = @"
+<ItemGroup>
+    <ProjectReference Include='{0}.proj' Targets='{1}' />
+</ItemGroup>
+";
+
+            using (var env = TestEnvironment.Create())
+            {
+                var entryProject = CreateProjectFile(
+                    env: env,
+                    projectNumber: 1,
+                    projectReferences: new[] {2, 3, 4},
+                    projectReferenceTargets: new Dictionary<string, string[]> {{"Build", new[] {"Build"}}});
+                CreateProjectFile(
+                    env: env,
+                    projectNumber: 2,
+                    projectReferences: null,
+                    projectReferenceTargets:
+                        new Dictionary<string, string[]> {{"Build", new[] {MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker, "T2"}}},
+                    defaultTargets: null,
+                    extraContent: referenceItem.Format("5", "T51"));
+                CreateProjectFile(
+                    env: env,
+                    projectNumber: 3,
+                    projectReferences: null,
+                    projectReferenceTargets:
+                        new Dictionary<string, string[]> {{"Build", new[] {MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker, "T3"}}},
+                    defaultTargets: null,
+                    extraContent: referenceItem.Format("5", "T51;T53;T54"));
+                CreateProjectFile(
+                    env: env,
+                    projectNumber: 4,
+                    projectReferences: null,
+                    projectReferenceTargets:
+                        new Dictionary<string, string[]> {{"Build", new[] {MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker, "T4"}}},
+                    defaultTargets: null,
+                    extraContent: referenceItem.Format("5", ""));
+                CreateProjectFile(env: env, projectNumber: 5, projectReferences: null, projectReferenceTargets: null, defaultTargets: "D51;D52");
+
+                var projectGraph = new ProjectGraph(entryProjectFile: entryProject.Path);
+                projectGraph.ProjectNodes.Count.ShouldBe(expected: 5);
+
+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(entryProjectTargets: null);
+                targetLists.Count.ShouldBe(expected: projectGraph.ProjectNodes.Count);
+                targetLists[key: GetFirstNodeWithProjectNumber(graph: projectGraph, projectNum: 1)].ShouldBe(expected: new[] { "Build" });
+                targetLists[key: GetFirstNodeWithProjectNumber(graph: projectGraph, projectNum: 2)].ShouldBe(expected: new[] { "Build" });
+                targetLists[key: GetFirstNodeWithProjectNumber(graph: projectGraph, projectNum: 3)].ShouldBe(expected: new[] { "Build" });
+                targetLists[key: GetFirstNodeWithProjectNumber(graph: projectGraph, projectNum: 4)].ShouldBe(expected: new[] { "Build" });
+                targetLists[key: GetFirstNodeWithProjectNumber(graph: projectGraph, projectNum: 5)].ShouldBe(expected: new[] { "T51", "T2", "T53", "T54", "T3", "D51", "D52", "T4" });
+            }
+        }
+
         public static IEnumerable<object[]> Graphs
         {
             get
@@ -1199,7 +1365,11 @@ public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)
             Regex.Matches(dot,"label").Count.ShouldBe(graph.ProjectNodes.Count);
         }
 
-        private static void AssertOuterBuildAsRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null, int expectedInnerBuildCount = 2)
+        private static void AssertOuterBuildAsRoot(
+            ProjectGraphNode outerBuild,
+            ProjectGraph graph,
+            Dictionary<string, string> additionalGlobalProperties = null,
+            int expectedInnerBuildCount = 2)
         {
             additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
 
@@ -1211,10 +1381,20 @@ private static void AssertOuterBuildAsRoot(ProjectGraphNode outerBuild, Dictiona
             foreach (var innerBuild in outerBuild.ProjectReferences)
             {
                 AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);
+
+                var edge = graph.TestOnly_Edges[(outerBuild, innerBuild)];
+                edge.DirectMetadataCount.ShouldBe(1);
+
+                var expectedPropertiesMetadata = $"{InnerBuildPropertyName}={innerBuild.ProjectInstance.GlobalProperties[InnerBuildPropertyName]}";
+                edge.GetMetadata("Properties").EvaluatedValue.ShouldBe(expectedPropertiesMetadata);
             }
         }
 
-        private static void AssertOuterBuildAsNonRoot(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties = null, int expectedInnerBuildCount = 2)
+        private static void AssertOuterBuildAsNonRoot(
+            ProjectGraphNode outerBuild,
+            ProjectGraph graph,
+            Dictionary<string, string> additionalGlobalProperties = null,
+            int expectedInnerBuildCount = 2)
         {
             additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
 
@@ -1239,6 +1419,13 @@ private static void AssertOuterBuildAsNonRoot(ProjectGraphNode outerBuild, Dicti
 
                     innerBuild.ReferencingProjects.ShouldContain(outerBuildReferencer);
                     innerBuild.ReferencingProjects.ShouldNotContain(outerBuild);
+
+                    graph.TestOnly_Edges.TestOnly_HasEdge((outerBuild, innerBuild)).ShouldBeFalse();
+
+                    var edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencer, outerBuild)];
+                    var edgeToInnerBuild = graph.TestOnly_Edges[(outerBuildReferencer, innerBuild)];
+
+                    edgeToOuterBuild.ShouldBe(edgeToInnerBuild);
                 }
             }
         }
@@ -1314,7 +1501,78 @@ public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()
             
             var outerBuild = graph.GraphRoots.First();
 
-            AssertOuterBuildAsRoot(outerBuild);
+            AssertOuterBuildAsRoot(outerBuild, graph);
+        }
+
+        [Fact]
+        public void OuterBuildAsNonRootShouldNotReferenceInnerBuilds()
+        {
+            var entryProject = CreateProjectFile(
+                env: _env,
+                projectNumber: 1,
+                projectReferences: new[] { 2 }).Path;
+            CreateProjectFile(
+                env: _env,
+                projectNumber: 2,
+                projectReferences: null,
+                projectReferenceTargets: null,
+                defaultTargets: null,
+                extraContent: MultitargetingSpecification);
+
+
+            var graph = new ProjectGraph(entryProject);
+
+            var dot = graph.ToDot();
+
+            graph.ProjectNodes.Count.ShouldBe(4);
+
+            var outerBuild = GetOuterBuild(graph, 2);
+
+            AssertOuterBuildAsNonRoot(outerBuild, graph);
+        }
+
+        [Fact]
+        public void InnerBuildsFromNonRootOuterBuildInheritEdgesToOuterBuild()
+        {
+            var entryProject = CreateProjectFile(
+                env: _env,
+                projectNumber: 1,
+                projectReferences: null,
+                projectReferenceTargets: null,
+                defaultTargets: null,
+                extraContent: @"
+<ItemGroup>
+    <ProjectReference Include='2.proj' Foo='Bar' />
+</ItemGroup>"
+                ).Path;
+            CreateProjectFile(
+                env: _env,
+                projectNumber: 2,
+                projectReferences: null,
+                projectReferenceTargets: null,
+                defaultTargets: null,
+                extraContent: MultitargetingSpecification);
+
+
+            var graph = new ProjectGraph(entryProject);
+
+            var dot = graph.ToDot();
+
+            graph.ProjectNodes.Count.ShouldBe(4);
+
+            var outerBuild = GetOuterBuild(graph, 2);
+
+            AssertOuterBuildAsNonRoot(outerBuild, graph);
+
+            var outerBuildReferencingNode = GetFirstNodeWithProjectNumber(graph, 1);
+
+            var edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencingNode, GetOuterBuild(graph, 2))];
+
+            foreach (var innerBuild in GetInnerBuilds(graph, 2))
+            {
+                graph.TestOnly_Edges[(outerBuildReferencingNode, innerBuild)].ShouldBe(edgeToOuterBuild);
+                edgeToOuterBuild.GetMetadataValue("Foo").ShouldBe("Bar");
+            }
         }
 
         [Fact]
@@ -1335,11 +1593,11 @@ public void DuplicatedInnerBuildMonikersShouldGetDeduplicated()
 
             graph.ProjectNodes.Count.ShouldBe(4);
 
-            var rootOuterBuild = GetNodesWithProjectNumber(graph, 1).First(IsOuterBuild);
-            var nonRootOuterBuild = GetNodesWithProjectNumber(graph, 2).First(IsOuterBuild);
+            var rootOuterBuild = GetOuterBuild(graph, 1);
+            var nonRootOuterBuild = GetOuterBuild(graph, 2);
 
-            AssertOuterBuildAsRoot(rootOuterBuild, null, 1);
-            AssertOuterBuildAsNonRoot(nonRootOuterBuild, null, 1);
+            AssertOuterBuildAsRoot(rootOuterBuild, graph, null, 1);
+            AssertOuterBuildAsNonRoot(nonRootOuterBuild, graph, null, 1);
         }
 
         [Fact]
@@ -1354,7 +1612,7 @@ public void ReferenceOfMultitargetingProjectShouldNotInheritInnerBuildSpecificGl
 
             graph.ProjectNodes.Count.ShouldBe(4);
 
-            AssertOuterBuildAsRoot(graph.GraphRoots.First());
+            AssertOuterBuildAsRoot(graph.GraphRoots.First(), graph);
 
             var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);
 
@@ -1422,8 +1680,8 @@ public void NonMultitargetingProjectsAreCompatibleWithMultitargetingProjects()
 
             graph.ProjectNodes.Count.ShouldBe(8);
 
-            AssertOuterBuildAsRoot(graph.GraphRoots.First());
-            AssertOuterBuildAsNonRoot(GetNodesWithProjectNumber(graph, 4).First(IsOuterBuild));
+            AssertOuterBuildAsRoot(graph.GraphRoots.First(), graph);
+            AssertOuterBuildAsNonRoot(GetOuterBuild(graph, 4), graph);
 
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 2));
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 3));
@@ -1449,9 +1707,9 @@ public void InnerBuildsCanHaveSeparateReferences()
 
             graph.ProjectNodes.Count.ShouldBe(11);
 
-            AssertOuterBuildAsRoot(graph.GraphRoots.First());
-            AssertOuterBuildAsNonRoot(GetNodesWithProjectNumber(graph, 2).First(IsOuterBuild));
-            AssertOuterBuildAsNonRoot(GetNodesWithProjectNumber(graph, 4).First(IsOuterBuild));
+            AssertOuterBuildAsRoot(graph.GraphRoots.First(), graph);
+            AssertOuterBuildAsNonRoot(GetOuterBuild(graph, 2), graph);
+            AssertOuterBuildAsNonRoot(GetOuterBuild(graph, 2), graph);
 
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 3));
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 5));
@@ -1491,7 +1749,7 @@ public void InnerBuildProducedByOuterBuildCanBeReferencedByAnotherNode()
 
             var outerBuild = graph.GraphRoots.First(IsOuterBuild);
 
-            AssertOuterBuildAsRoot(outerBuild, additionalGlobalProperties);
+            AssertOuterBuildAsRoot(outerBuild, graph, additionalGlobalProperties);
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 2), additionalGlobalProperties);
 
             var referencedInnerBuild = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstance.GetPropertyValue(InnerBuildPropertyName) == "a");
@@ -1567,17 +1825,17 @@ public void InnerBuildsProducedByOuterBuildsCanBeReferencedByOtherInnerBuilds()
 
             graph.ProjectNodes.Count.ShouldBe(5);
 
-            var outerBuild1 = GetNodesWithProjectNumber(graph, 1).First(IsOuterBuild);
+            var outerBuild1 = GetOuterBuild(graph, 1);
 
-            AssertOuterBuildAsRoot(outerBuild1, additionalGlobalProperties);
+            AssertOuterBuildAsRoot(outerBuild1, graph, additionalGlobalProperties);
 
             var innerBuild1WithReferenceToInnerBuild2 = outerBuild1.ProjectReferences.FirstOrDefault(n => IsInnerBuild(n) && n.ProjectInstance.GlobalProperties[InnerBuildPropertyName] == "a");
             innerBuild1WithReferenceToInnerBuild2.ShouldNotBeNull();
 
-            var outerBuild2 = GetNodesWithProjectNumber(graph, 2).FirstOrDefault(IsOuterBuild);
+            var outerBuild2 = GetOuterBuild(graph, 2);
             outerBuild2.ShouldNotBeNull();
 
-            var innerBuild2 = GetNodesWithProjectNumber(graph, 2).FirstOrDefault(IsInnerBuild);
+            var innerBuild2 = GetInnerBuilds(graph, 2).FirstOrDefault();
             innerBuild2.ShouldNotBeNull();
 
             innerBuild2.ProjectInstance.GlobalProperties[InnerBuildPropertyName].ShouldBe("a");
@@ -1706,6 +1964,31 @@ public void UserValuesForIsGraphBuildGlobalPropertyShouldBePreserved()
             }
         }
 
+        private static ProjectGraphNode GetOuterBuild(ProjectGraph graph, int projectNumber)
+        {
+            return GetNodesWithProjectNumber(graph, projectNumber).FirstOrDefault(IsOuterBuild);
+        }
+
+        private static IReadOnlyCollection<ProjectGraphNode> GetInnerBuilds(ProjectGraph graph, int projectNumber)
+        {
+            var outerBuild = GetOuterBuild(graph, projectNumber);
+
+            if (outerBuild == null)
+            {
+                return ImmutableArray<ProjectGraphNode>.Empty;
+            }
+            else
+            {
+                var innerBuilds = GetNodesWithProjectNumber(graph, projectNumber)
+                    .Where(p => IsInnerBuild(p) && p.ProjectInstance.FullPath.Equals(outerBuild.ProjectInstance.FullPath))
+                    .ToArray();
+
+                innerBuilds.ShouldNotBeEmpty();
+
+                return innerBuilds;
+            }
+        }
+
         private static ProjectGraphNode GetFirstNodeWithProjectNumber(ProjectGraph graph, int projectNum) => GetNodesWithProjectNumber(graph, projectNum).First();
 
         private static IEnumerable<ProjectGraphNode> GetNodesWithProjectNumber(ProjectGraph graph, int projectNum)
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 7836361b517..d28025a8f36 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -18,7 +18,7 @@ namespace Microsoft.Build.Experimental.Graph
 {
     internal class GraphBuilder
     {
-        private readonly ProjectInterpretation _projectInterpretation;
+        private ProjectInterpretation ProjectInterpretation { get; }
 
         public IReadOnlyCollection<ProjectGraphNode> ProjectNodes { get; private set; }
 
@@ -26,9 +26,11 @@ internal class GraphBuilder
 
         public IReadOnlyCollection<ProjectGraphNode> EntryPointNodes { get; private set; }
 
+        public GraphEdges Edges { get; private set; }
+
         public GraphBuilder(ProjectInterpretation projectInterpretation)
         {
-            _projectInterpretation = projectInterpretation;
+            ProjectInterpretation = projectInterpretation;
         }
 
         public void BuildGraph(
@@ -53,13 +55,15 @@ ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory
                 projectCollection,
                 tasksInProgress,
                 projectInstanceFactory,
-                _projectInterpretation,
+                ProjectInterpretation,
                 allParsedProjects,
                 out var exceptions))
             {
-                CreateEdgesAndDetectCycles(entryPointConfigurationMetadata, _projectInterpretation, allParsedProjects);
+                Edges = new GraphEdges();
+
+                CreateEdgesAndDetectCycles(entryPointConfigurationMetadata, ProjectInterpretation, allParsedProjects, Edges);
 
-                _projectInterpretation.PostProcess(allParsedProjects);
+                ProjectInterpretation.PostProcess(allParsedProjects, this);
 
                 EntryPointNodes = entryPointConfigurationMetadata.Select(e => allParsedProjects[e]).ToList();
                 RootNodes = GetGraphRoots(EntryPointNodes);
@@ -120,7 +124,8 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo
         private void CreateEdgesAndDetectCycles(
             List<ConfigurationMetadata> entryPointConfigurationMetadata,
             ProjectInterpretation sdkInfo,
-            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects)
+            ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allParsedProjects,
+            GraphEdges edges)
         {
             var nodeStates = new Dictionary<ProjectGraphNode, NodeVisitationState>();
 
@@ -149,7 +154,7 @@ private void CreateEdgesAndDetectCycles(
             {
                 nodeState[node] = NodeVisitationState.InProcess;
 
-                foreach (var referenceConfig in sdkInfo.GetReferences(node.ProjectInstance))
+                foreach (var (referenceConfig, projectReferenceItem) in sdkInfo.GetReferences(node.ProjectInstance))
                 {
                     var referenceNode = allParsedProjects[referenceConfig];
 
@@ -199,8 +204,7 @@ private void CreateEdgesAndDetectCycles(
                         }
                     }
 
-                    var parsedProjectReference = allParsedProjects[referenceConfig];
-                    node.AddProjectReference(parsedProjectReference);
+                    node.AddProjectReference(referenceNode, projectReferenceItem, edges);
                 }
 
                 nodeState[node] = NodeVisitationState.Processed;
@@ -260,7 +264,7 @@ private bool FindGraphNodes(
                         {
                             var parsedProject = CreateNewNode(projectToEvaluate, projectCollection, projectInstanceFactory, allParsedProjects);
 
-                            foreach (var referenceConfig in projectInterpretation.GetReferences(parsedProject.ProjectInstance))
+                            foreach (var (referenceConfig, _) in projectInterpretation.GetReferences(parsedProject.ProjectInstance))
                             {
                                 /*todo: fix the following double check-then-act concurrency bug: one thread can pass the two checks, loose context,
                              meanwhile another thread passes the same checks with the same data and inserts its reference. The initial thread regains context
@@ -353,6 +357,35 @@ private static PropertyDictionary<ProjectPropertyInstance> CreatePropertyDiction
             return propertyDictionary;
         }
 
+        internal class GraphEdges
+        {
+            private ConcurrentDictionary<(ProjectGraphNode, ProjectGraphNode), ProjectItemInstance> ReferenceItems =
+                new ConcurrentDictionary<(ProjectGraphNode, ProjectGraphNode), ProjectItemInstance>();
+
+            internal int Count => ReferenceItems.Count;
+
+            public ProjectItemInstance this[(ProjectGraphNode node, ProjectGraphNode reference) key]
+            {
+                get
+                {
+                    ErrorUtilities.VerifyThrow(ReferenceItems.ContainsKey(key), "All requested keys should exist");
+                    return ReferenceItems[key];
+                }
+
+                // First edge wins, in accordance with vanilla msbuild behaviour when multiple msbuild tasks call into the same logical project
+                set => ReferenceItems.TryAdd(key, value);
+            }
+
+            public void RemoveEdge((ProjectGraphNode node, ProjectGraphNode reference) key)
+            {
+                ErrorUtilities.VerifyThrow(ReferenceItems.ContainsKey(key), "All requested keys should exist");
+
+                ReferenceItems.TryRemove(key, out _);
+            }
+
+            internal bool TestOnly_HasEdge((ProjectGraphNode node, ProjectGraphNode reference) key) => ReferenceItems.ContainsKey(key);
+        }
+
         private enum NodeVisitationState
         {
             // the project has been evaluated and its project references are being processed
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index 8afe9868bd5..aec5b9042e5 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -51,6 +51,10 @@ public delegate ProjectInstance ProjectInstanceFactoryFunc(
 
         private readonly Lazy<IReadOnlyCollection<ProjectGraphNode>> _projectNodesTopologicallySorted;
 
+        private GraphBuilder.GraphEdges Edges { get; }
+
+        internal GraphBuilder.GraphEdges TestOnly_Edges => Edges;
+
         /// <summary>
         ///     Gets the project nodes representing the entry points.
         /// </summary>
@@ -323,6 +327,7 @@ public ProjectGraph(
             EntryPointNodes = graphBuilder.EntryPointNodes;
             GraphRoots = graphBuilder.RootNodes;
             ProjectNodes = graphBuilder.ProjectNodes;
+            Edges = graphBuilder.Edges;
 
             _projectNodesTopologicallySorted = new Lazy<IReadOnlyCollection<ProjectGraphNode>>(() => TopologicalSort(GraphRoots, ProjectNodes));
         }
@@ -455,13 +460,18 @@ public IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> GetTargetLis
                 var targetsToPropagate = ProjectInterpretation.TargetsToPropagate.FromProjectAndEntryTargets(node.ProjectInstance, requestedTargets);
 
                 // Queue the project references for visitation, if the edge hasn't already been traversed.
-                foreach (var projectReference in node.ProjectReferences)
+                foreach (var referenceNode in node.ProjectReferences)
                 {
-                    var applicableTargets = targetsToPropagate.GetApplicableTargetsForReference(projectReference.ProjectInstance);
+                    var applicableTargets = targetsToPropagate.GetApplicableTargetsForReference(referenceNode.ProjectInstance);
+
+                    var expandedTargets = ExpandDefaultTargets(
+                        applicableTargets,
+                        referenceNode.ProjectInstance.DefaultTargets,
+                        Edges[(node, referenceNode)]);
 
                     var projectReferenceEdge = new ProjectGraphBuildRequest(
-                        projectReference,
-                        ExpandDefaultTargets(applicableTargets, projectReference.ProjectInstance.DefaultTargets));
+                        referenceNode,
+                        expandedTargets);
 
                     if (encounteredEdges.Add(projectReferenceEdge))
                     {
@@ -506,7 +516,7 @@ public IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> GetTargetLis
             return targetLists;
         }
 
-        private static ImmutableList<string> ExpandDefaultTargets(ImmutableList<string> targets, List<string> defaultTargets)
+        private static ImmutableList<string> ExpandDefaultTargets(ImmutableList<string> targets, List<string> defaultTargets, ProjectItemInstance graphEdge)
         {
             var i = 0;
             while (i < targets.Count)
@@ -518,6 +528,20 @@ private static ImmutableList<string> ExpandDefaultTargets(ImmutableList<string>
                         .InsertRange(i, defaultTargets);
                     i += defaultTargets.Count;
                 }
+                else if (targets[i].Equals(MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker, StringComparison.OrdinalIgnoreCase))
+                {
+                    var targetsString = graphEdge.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
+
+                    var expandedTargets = string.IsNullOrEmpty(targetsString)
+                        ? defaultTargets
+                        : ExpressionShredder.SplitSemiColonSeparatedList(targetsString).ToList();
+
+                    targets = targets
+                        .RemoveAt(i)
+                        .InsertRange(i, expandedTargets);
+
+                    i += defaultTargets.Count;
+                }
                 else
                 {
                     i++;
diff --git a/src/Build/Graph/ProjectGraphNode.cs b/src/Build/Graph/ProjectGraphNode.cs
index 9c6d4ee2d98..eb5b051e2e8 100644
--- a/src/Build/Graph/ProjectGraphNode.cs
+++ b/src/Build/Graph/ProjectGraphNode.cs
@@ -37,18 +37,23 @@ internal ProjectGraphNode(ProjectInstance projectInstance)
         /// </summary>
         public ProjectInstance ProjectInstance { get; }
 
-        internal void AddProjectReference(ProjectGraphNode reference)
+        internal void AddProjectReference(ProjectGraphNode reference, ProjectItemInstance projectReferenceItem, GraphBuilder.GraphEdges edges)
         {
             _projectReferences.Add(reference);
             reference._referencingProjects.Add(this);
+
+            // First edge wins, in accordance with vanilla msbuild behaviour when multiple msbuild tasks call into the same logical project
+            edges[(this, reference)] = projectReferenceItem;
         }
 
-        internal void RemoveReferences()
+        internal void RemoveReferences(GraphBuilder.GraphEdges edges)
         {
             foreach (var reference in _projectReferences)
             {
                 ErrorUtilities.VerifyThrow(reference._referencingProjects.Contains(this), "references should point the nodes referencing them");
                 reference._referencingProjects.Remove(this);
+
+                edges.RemoveEdge((this, reference));
             }
 
             _projectReferences.Clear();
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index ac985f259ba..606e774a98a 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -41,48 +41,48 @@ internal enum ProjectType
             OuterBuild, InnerBuild, NonMultitargeting
         }
 
-        public IEnumerable<ConfigurationMetadata> GetReferences(ProjectInstance requesterInstance)
+        public IEnumerable<(ConfigurationMetadata referenceConfiguration, ProjectItemInstance projectReferenceItem)> GetReferences(ProjectInstance requesterInstance)
         {
-            IEnumerable<ProjectItemInstance> references;
+            IEnumerable<ProjectItemInstance> projectReferenceItems;
             IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;
 
             switch (GetProjectType(requesterInstance))
             {
                 case ProjectType.OuterBuild:
-                    references = GetInnerBuildReferences(requesterInstance);
+                    projectReferenceItems = GetInnerBuildReferences(requesterInstance);
                     break;
                 case ProjectType.InnerBuild:
                     globalPropertiesModifiers = ModifierForNonMultitargetingNodes.Add((parts, reference) => parts.AddPropertyToUndefine(GetInnerBuildPropertyName(requesterInstance)));
-                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);
+                    projectReferenceItems = requesterInstance.GetItems(ItemTypeNames.ProjectReference);
                     break;
                 case ProjectType.NonMultitargeting:
                     globalPropertiesModifiers = ModifierForNonMultitargetingNodes;
-                    references = requesterInstance.GetItems(ItemTypeNames.ProjectReference);
+                    projectReferenceItems = requesterInstance.GetItems(ItemTypeNames.ProjectReference);
                     break;
                 default:
                     throw new ArgumentOutOfRangeException();
             }
 
-            foreach (var projectReference in references)
+            foreach (var projectReferenceItem in projectReferenceItems)
             {
-                if (!String.IsNullOrEmpty(projectReference.GetMetadataValue(ToolsVersionMetadataName)))
+                if (!String.IsNullOrEmpty(projectReferenceItem.GetMetadataValue(ToolsVersionMetadataName)))
                 {
                     throw new InvalidOperationException(
                         String.Format(
                             CultureInfo.InvariantCulture,
                             ResourceUtilities.GetResourceString(
                                 "ProjectGraphDoesNotSupportProjectReferenceWithToolset"),
-                            projectReference.EvaluatedInclude,
+                            projectReferenceItem.EvaluatedInclude,
                             requesterInstance.FullPath));
                 }
 
-                var projectReferenceFullPath = projectReference.GetMetadataValue(FullPathMetadataName);
+                var projectReferenceFullPath = projectReferenceItem.GetMetadataValue(FullPathMetadataName);
 
-                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReference, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);
+                var referenceGlobalProperties = GetGlobalPropertiesForItem(projectReferenceItem, requesterInstance.GlobalPropertiesDictionary, globalPropertiesModifiers);
 
                 var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);
 
-                yield return referenceConfig;
+                yield return (referenceConfig, projectReferenceItem);
             }
         }
 
@@ -115,7 +115,12 @@ internal static ProjectType GetProjectType(ProjectInstance project)
                     : ProjectType.NonMultitargeting;
         }
 
-        public void PostProcess(ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allNodes)
+        /// <summary>
+        /// To avoid calling nuget at graph construction time, the graph is initially constructed with outer build nodes referencing inner build nodes.
+        /// However, at build time, for non root outer builds, the inner builds are NOT referenced by the outer build, but by the nodes referencing the
+        /// outer build. Change the graph to mimic this behaviour.
+        /// </summary>
+        public void PostProcess(ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> allNodes, GraphBuilder graphBuilder)
         {
             foreach (var nodeKvp in allNodes)
             {
@@ -125,13 +130,19 @@ public void PostProcess(ConcurrentDictionary<ConfigurationMetadata, ProjectGraph
                 {
                     foreach (var innerBuild in outerBuild.ProjectReferences)
                     {
-                        foreach (var referencingProject in outerBuild.ReferencingProjects)
+                        foreach (var outerBuildReferencingProject in outerBuild.ReferencingProjects)
                         {
-                            referencingProject.AddProjectReference(innerBuild);
+                            // Which edge should be used to connect the outerBuildReferencingProject to the inner builds?
+                            // Decided to use the outerBuildBuildReferencingProject -> outerBuild edge in order to preserve any extra metadata
+                            // information that may be present on the edge, like the "Targets" metadata which specifies what
+                            // targets to call on the references.
+                            var newInnerBuildEdge = graphBuilder.Edges[(outerBuildReferencingProject, outerBuild)];
+
+                            outerBuildReferencingProject.AddProjectReference(innerBuild, newInnerBuildEdge, graphBuilder.Edges);
                         }
                     }
 
-                    outerBuild.RemoveReferences();
+                    outerBuild.RemoveReferences(graphBuilder.Edges);
                 }
             }
         }
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 71b3f4d9538..312814279f9 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -83,6 +83,12 @@ internal static class MSBuildConstants
         /// Symbol used in ProjectReferenceTarget items to represent default targets
         /// </summary>
         internal const string DefaultTargetsMarker = ".default";
+
+        /// <summary>
+        /// Symbol used in ProjectReferenceTarget items to represent targets specified on the ProjectReference item
+        /// with fallback to default targets if the ProjectReference item has no targets specified.
+        /// </summary>
+        internal const string ProjectReferenceTargetsOrDefaultTargetsMarker = ".projectReferenceTargetsOrDefaultTargets";
 		
 		// One-time allocations to avoid implicit allocations for Split(), Trim().
         internal static readonly char[] SemicolonChar = { ';' };
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index ea00789ec36..6bc7ec24cc4 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1112,6 +1112,13 @@ internal static string FormatProjectContentsWithItemGroupFragment(string fragmen
     /// </summary>
     internal static partial class Helpers
     {
+        internal static string Format(this string s, params object[] formatItems)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(s, nameof(s));
+
+            return string.Format(s, formatItems);
+        }
+
         internal static string GetOSPlatformAsString()
         {
             var currentPlatformString = string.Empty;
diff --git a/src/Tasks/Microsoft.Managed.targets b/src/Tasks/Microsoft.Managed.targets
index 54cccb091c1..5e81b324d25 100644
--- a/src/Tasks/Microsoft.Managed.targets
+++ b/src/Tasks/Microsoft.Managed.targets
@@ -41,7 +41,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   -->
   <PropertyGroup>
     <ProjectReferenceTargetsForBuildInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>
-    <ProjectReferenceTargetsForBuild>.default;GetNativeManifest;GetCopyToOutputDirectoryItems;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
+    <ProjectReferenceTargetsForBuild>.projectReferenceTargetsOrDefaultTargets;GetNativeManifest;GetCopyToOutputDirectoryItems;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
 
     <ProjectReferenceTargetsForCleanInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForCleanInOuterBuild)</ProjectReferenceTargetsForCleanInOuterBuild>
     <ProjectReferenceTargetsForClean>Clean;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
