diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
index 7a67734775b..7b06c3e66aa 100644
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
@@ -215,6 +215,19 @@ public partial interface ICancelableTask : Microsoft.Build.Framework.ITask
     {
         void Cancel();
     }
+    public partial class TaskExecutionContext
+    {
+        public TaskExecutionContext(string startupDirectory, Dictionary<string, string> buildProcessEnvironment, CultureInfo culture, CultureInfo uiCulture) { throw null; }
+
+        public string StartupDirectory { get; }
+        public Dictionary<string, string> BuildProcessEnvironment { get; }
+        public CultureInfo Culture { get; }
+        public CultureInfo UICulture { get; }
+    }
+    public partial interface IConcurrentTask
+    {
+        void ConfigureForConcurrentExecution(TaskExecutionContext executionContext);
+    }     
     public partial interface IEventRedirector
     {
         void ForwardEvent(Microsoft.Build.Framework.BuildEventArgs buildEvent);
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
index 9e3004af4bb..6f74604e62f 100644
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
@@ -215,6 +215,19 @@ public partial interface ICancelableTask : Microsoft.Build.Framework.ITask
     {
         void Cancel();
     }
+    public partial class TaskExecutionContext
+    {
+        public TaskExecutionContext(string startupDirectory, Dictionary<string, string> buildProcessEnvironment, CultureInfo culture, CultureInfo uiCulture) { throw null; }
+
+        public string StartupDirectory { get; }
+        public Dictionary<string, string> BuildProcessEnvironment { get; }
+        public CultureInfo Culture { get; }
+        public CultureInfo UICulture { get; }
+    }
+    public partial interface IConcurrentTask
+    {
+        void ConfigureForConcurrentExecution(TaskExecutionContext executionContext);
+    }    
     public partial interface IEventRedirector
     {
         void ForwardEvent(Microsoft.Build.Framework.BuildEventArgs buildEvent);
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 501d9ddbbc8..5bc6989f65b 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -295,7 +295,7 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
         /// </summary>
         private string GetProcessesToIgnoreKey(Handshake hostHandshake, int nodeProcessId)
         {
-            return hostHandshake.ToString() + "|" + nodeProcessId.ToString(CultureInfo.InvariantCulture);
+            return $"{hostHandshake.ToString()}|{nodeProcessId}";
         }
 
 #if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index ef746ed27d7..a13368a2972 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -506,7 +506,8 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
 
             // Start the new process.  We pass in a node mode with a node number of 2, to indicate that we
             // want to start up an MSBuild task host node.
-            string commandLineArgs = $" /nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} ";
+            bool isRarService = (hostContext & HandshakeOptions.RarService) != 0;
+            string commandLineArgs = $" /nologo /nodemode:{(isRarService ? 3 : 2)} /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} ";
 
             string msbuildLocation = GetMSBuildLocationFromHostContext(hostContext);
 
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index 802539f6077..33490f3f831 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -346,7 +346,7 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
                 // if we don't have any task host parameters specified on either the using task or the 
                 // task invocation, then we will run in-proc UNLESS "TaskHostFactory" is explicitly specified
                 // as the task factory.  
-                useTaskFactory = _taskHostFactoryExplicitlyRequested;
+                useTaskFactory = _taskHostFactoryExplicitlyRequested || _taskName == "Microsoft.Build.Tasks.ResolveAssemblyReference";
             }
 
             if (useTaskFactory)
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 07f716a438f..1b1028a5b43 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -279,6 +279,10 @@ public bool Execute()
                 lock (_taskHostLock)
                 {
                     _requiredContext = CommunicationsUtilities.GetHandshakeOptions(taskHost: true, taskHostParameters: _taskHostParameters);
+                    if (_taskType.Type.Name == "ResolveAssemblyReference")
+                    {
+                        _requiredContext |= HandshakeOptions.RarService;
+                    }
                     _connectedToTaskHost = _taskHostProvider.AcquireAndSetUpHost(_requiredContext, this, this, hostConfiguration);
                 }
 
diff --git a/src/Framework/TaskExecutionContext.cs b/src/Framework/TaskExecutionContext.cs
new file mode 100644
index 00000000000..d6cb69307b3
--- /dev/null
+++ b/src/Framework/TaskExecutionContext.cs
@@ -0,0 +1,30 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.Collections.Generic;
+using System.Globalization;
+
+namespace Microsoft.Build.Framework
+{
+    public class TaskExecutionContext
+    {
+        public TaskExecutionContext(string startupDirectory, Dictionary<string, string> buildProcessEnvironment, CultureInfo culture, CultureInfo uiCulture)
+        {
+            StartupDirectory = startupDirectory;
+            BuildProcessEnvironment = buildProcessEnvironment;
+            Culture = culture;
+            UICulture = uiCulture;
+        }
+
+        public string StartupDirectory { get; }
+        public Dictionary<string, string> BuildProcessEnvironment { get; }
+        public CultureInfo Culture { get; }
+        public CultureInfo UICulture { get; }
+    }
+
+    // TODO: move to own file
+    public interface IConcurrentTask
+    {
+        void ConfigureForConcurrentExecution(TaskExecutionContext executionContext);
+    }
+}
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 7d990720a96..b09871fedb2 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -187,6 +187,8 @@
     </Compile>
     <Compile Include="NodeEndpointOutOfProcTaskHost.cs" />
     <Compile Include="LogMessagePacket.cs" />
+    <Compile Include="NodeEndpointRarTaskHost.cs" />
+    <Compile Include="RarServiceTaskHostNode .cs" />
     <Compile Include="ProjectSchemaValidationHandler.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/MSBuild/NodeEndpointRarTaskHost.cs b/src/MSBuild/NodeEndpointRarTaskHost.cs
new file mode 100644
index 00000000000..3cbb0494227
--- /dev/null
+++ b/src/MSBuild/NodeEndpointRarTaskHost.cs
@@ -0,0 +1,28 @@
+﻿using Microsoft.Build.BackEnd;
+using Microsoft.Build.Internal;
+
+namespace Microsoft.Build.CommandLine
+{
+    /// <summary>
+    /// This is an implementation of INodeEndpoint for the out-of-proc nodes.  It acts only as a client.
+    /// </summary>
+    internal class NodeEndpointRarTaskHost : NodeEndpointOutOfProcBase
+    {
+        /// <summary>
+        /// Instantiates an endpoint to act as a client
+        /// </summary>
+        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
+        internal NodeEndpointRarTaskHost(string pipeName)
+        {
+            InternalConstruct(pipeName, multiClient: true);
+        }
+
+        /// <summary>
+        /// Returns the host handshake for this node endpoint
+        /// </summary>
+        protected override Handshake GetHandshake()
+        {
+            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true) | HandshakeOptions.RarService);
+        }
+    }
+}
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
index b1f085e2da1..2f5b386c4a8 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
@@ -88,6 +88,7 @@ internal bool CancelPending
         /// <param name="taskColumn">The column in the project file where the task invocation is located.</param>
         /// <param name="appDomainSetup">The AppDomainSetup that we want to use to launch our AppDomainIsolated tasks</param>
         /// <param name="taskParams">Parameters that will be passed to the task when created</param>
+        /// <param name="taskExecutionContext"></param>
         /// <returns>Task completion result showing success, failure or if there was a crash</returns>
         internal OutOfProcTaskHostTaskResult ExecuteTask
             (
@@ -97,10 +98,11 @@ internal OutOfProcTaskHostTaskResult ExecuteTask
                 string taskFile,
                 int taskLine,
                 int taskColumn,
-#if FEATURE_APPDOMAIN
+    #if FEATURE_APPDOMAIN
                 AppDomainSetup appDomainSetup,
-#endif
-                IDictionary<string, TaskParameter> taskParams
+    #endif
+                IDictionary<string, TaskParameter> taskParams,
+                TaskExecutionContext taskExecutionContext
             )
         {
             buildEngine = oopTaskHostNode;
@@ -167,7 +169,8 @@ IDictionary<string, TaskParameter> taskParams
 #if FEATURE_APPDOMAIN
                     appDomainSetup,
 #endif
-                    taskParams);
+                    taskParams,
+                    taskExecutionContext);
             }
 
             return taskResult;
@@ -236,7 +239,8 @@ IDictionary<string, TaskParameter> taskParams
 #if FEATURE_APPDOMAIN
                                                 appDomainSetup,
 #endif
-                                                taskParams
+                                                taskParams,
+                                                null
                                             );
                     }
                     catch (Exception e)
@@ -296,10 +300,11 @@ private OutOfProcTaskHostTaskResult InstantiateAndExecuteTask
                 string taskFile,
                 int taskLine,
                 int taskColumn,
-#if FEATURE_APPDOMAIN
+        #if FEATURE_APPDOMAIN
                 AppDomainSetup appDomainSetup,
-#endif
-                IDictionary<string, TaskParameter> taskParams
+        #endif
+                IDictionary<string, TaskParameter> taskParams,
+                TaskExecutionContext taskExecutionContext
             )
         {
 #if FEATURE_APPDOMAIN
@@ -379,6 +384,12 @@ IDictionary<string, TaskParameter> taskParams
                 }
             }
 
+            // TODO: ESCAPE HATCH here
+            if (wrappedTask is IConcurrentTask concurrentTask)
+            {
+                concurrentTask.ConfigureForConcurrentExecution(taskExecutionContext);
+            }
+
             bool success = false;
             try
             {
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index e7604d0970b..6d282964d4c 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -829,7 +829,8 @@ private void RunTask(object state)
 #if FEATURE_APPDOMAIN
                     taskConfiguration.AppDomainSetup,
 #endif
-                    taskParams
+                    taskParams,
+                    null
                 );
             }
             catch (Exception e)
diff --git a/src/MSBuild/RarServiceTaskHostNode .cs b/src/MSBuild/RarServiceTaskHostNode .cs
new file mode 100644
index 00000000000..3b8cf315710
--- /dev/null
+++ b/src/MSBuild/RarServiceTaskHostNode .cs	
@@ -0,0 +1,1251 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections;
+using System.Collections.Concurrent;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Globalization;
+using System.Linq;
+using System.Threading;
+using System.Reflection;
+
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
+#if FEATURE_APPDOMAIN
+using System.Runtime.Remoting;
+#endif
+
+namespace Microsoft.Build.CommandLine
+{
+    /// <summary>
+    /// This class represents an implementation of INode for RAR service out-of-proc node for hosting 'resolve assembly reference' tasks.
+    /// </summary>
+    internal class RarServiceTaskHostNode :
+#if FEATURE_APPDOMAIN
+        MarshalByRefObject, 
+#endif
+        INodePacketFactory, INodePacketHandler,
+#if CLR2COMPATIBILITY
+        IBuildEngine3
+#else
+        IBuildEngine7
+#endif
+    {
+        /// <summary>
+        /// Keeps a record of all environment variables that, on startup of the task host, have a different
+        /// value from those that are passed to the task host in the configuration packet for the first task.  
+        /// These environments are assumed to be effectively identical, so the only difference between the 
+        /// two sets of values should be any environment variables that differ between e.g. a 32-bit and a 64-bit 
+        /// process.  Those are the variables that this dictionary should store.  
+        /// 
+        /// - The key into the dictionary is the name of the environment variable. 
+        /// - The Key of the KeyValuePair is the value of the variable in the parent process -- the value that we 
+        ///   wish to ensure is replaced by whatever the correct value in our current process is. 
+        /// - The Value of the KeyValuePair is the value of the variable in the current process -- the value that 
+        ///   we wish to replay the Key value with in the environment that we receive from the parent before 
+        ///   applying it to the current process. 
+        ///   
+        /// Note that either value in the KeyValuePair can be null, as it is completely possible to have an 
+        /// environment variable that is set in 32-bit processes but not in 64-bit, or vice versa.  
+        /// 
+        /// This dictionary must be static because otherwise, if a node is sitting around waiting for reuse, it will
+        /// have inherited the environment from the previous build, and any differences between the two will be seen 
+        /// as "legitimate".  There is no way for us to know what the differences between the startup environment of 
+        /// the previous build and the environment of the first task run in the task host in this build -- so we 
+        /// must assume that the 4ish system environment variables that this is really meant to catch haven't 
+        /// somehow magically changed between two builds spaced no more than 15 minutes apart.  
+        /// </summary>
+        private static IDictionary<string, KeyValuePair<string, string>> s_mismatchedEnvironmentValues;
+
+        /// <summary>
+        /// backing queue used to control creating concurrent RAR service clients (requests)
+        /// </summary>
+        private static BlockingCollection<bool> s_waitForConcurrentClient = new ();
+
+        /// <summary>
+        /// The endpoint used to talk to the host.
+        /// </summary>
+        private NodeEndpointRarTaskHost _nodeEndpoint;
+
+        /// <summary>
+        /// The packet factory.
+        /// </summary>
+        private NodePacketFactory _packetFactory;
+
+        /// <summary>
+        /// The event which is set when we receive packets.
+        /// </summary>
+        private AutoResetEvent _packetReceivedEvent;
+
+        /// <summary>
+        /// The queue of packets we have received but which have not yet been processed.
+        /// </summary>
+        private Queue<INodePacket> _receivedPackets;
+
+        /// <summary>
+        /// The current configuration for this task host.
+        /// </summary>
+        private TaskHostConfiguration _currentConfiguration;
+
+        /// <summary>
+        /// The saved environment for the process.
+        /// </summary>
+        private IDictionary<string, string> _savedEnvironment;
+
+        /// <summary>
+        /// The event which is set when we should shut down.
+        /// </summary>
+        private ManualResetEvent _shutdownEvent;
+
+        /// <summary>
+        /// The reason we are shutting down.
+        /// </summary>
+        private NodeEngineShutdownReason _shutdownReason;
+
+        /// <summary>
+        /// We set this flag to track a currently executing task
+        /// </summary>
+        private bool _isTaskExecuting;
+
+        /// <summary>
+        /// The event which is set when a task has completed.  
+        /// </summary>
+        private AutoResetEvent _taskCompleteEvent;
+
+        /// <summary>
+        /// Packet containing all the information relating to the 
+        /// completed state of the task.  
+        /// </summary>
+        private TaskHostTaskComplete _taskCompletePacket;
+
+        /// <summary>
+        /// Object used to synchronize access to taskCompletePacket
+        /// </summary>
+        private Object _taskCompleteLock = new Object();
+
+        /// <summary>
+        /// The event which is set when a task is cancelled
+        /// </summary>
+        private ManualResetEvent _taskCancelledEvent;
+
+        /// <summary>
+        /// The thread currently executing user task in the TaskRunner
+        /// </summary>
+        private Thread _taskRunnerThread;
+
+        /// <summary>
+        /// This is the wrapper for the user task to be executed.
+        /// We are providing a wrapper to create a possibility of executing the task in a separate AppDomain
+        /// </summary>
+        private OutOfProcTaskAppDomainWrapper _taskWrapper;
+
+        /// <summary>
+        /// Flag indicating if we should debug communications or not.
+        /// </summary>
+        private bool _debugCommunications;
+
+        /// <summary>
+        /// Flag indicating whether we should modify the environment based on any differences we find between that of the 
+        /// task host at startup and the environment passed to us in our initial task configuration packet.  
+        /// </summary>
+        private bool _updateEnvironment;
+
+        /// <summary>
+        /// An interim step between MSBuildTaskHostDoNotUpdateEnvironment=1 and the default update behavior:  go ahead and 
+        /// do all the updates that we would otherwise have done by default, but log any updates that are made (at low 
+        /// importance) so that the user is aware.  
+        /// </summary>
+        private bool _updateEnvironmentAndLog;
+
+#if !CLR2COMPATIBILITY
+        /// <summary>
+        /// The task object cache.
+        /// </summary>
+        private RegisteredTaskObjectCacheBase _registeredTaskObjectCache;
+#endif
+
+        /// <summary>
+        /// Constructor.
+        /// </summary>
+        public RarServiceTaskHostNode()
+        {
+            // We don't know what the current build thinks this variable should be until RunTask(), but as a fallback in case there are 
+            // communications before we get the configuration set up, just go with what was already in the environment from when this node
+            // was initially launched. 
+            _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
+
+            _receivedPackets = new Queue<INodePacket>();
+
+            // These WaitHandles are disposed in HandleShutDown()
+            _packetReceivedEvent = new AutoResetEvent(false);
+            _shutdownEvent = new ManualResetEvent(false);
+            _taskCompleteEvent = new AutoResetEvent(false);
+            _taskCancelledEvent = new ManualResetEvent(false);
+
+            _packetFactory = new NodePacketFactory();
+
+            INodePacketFactory thisINodePacketFactory = (INodePacketFactory)this;
+
+            thisINodePacketFactory.RegisterPacketHandler(NodePacketType.TaskHostConfiguration, TaskHostConfiguration.FactoryForDeserialization, this);
+            thisINodePacketFactory.RegisterPacketHandler(NodePacketType.TaskHostTaskCancelled, TaskHostTaskCancelled.FactoryForDeserialization, this);
+            thisINodePacketFactory.RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);
+        }
+
+        #region IBuildEngine Implementation (Properties)
+
+        /// <summary>
+        /// Returns the value of ContinueOnError for the currently executing task. 
+        /// </summary>
+        public bool ContinueOnError
+        {
+            get
+            {
+                ErrorUtilities.VerifyThrow(_currentConfiguration != null, "We should never have a null configuration during a BuildEngine callback!");
+                return _currentConfiguration.ContinueOnError;
+            }
+        }
+
+        /// <summary>
+        /// Returns the line number of the location in the project file of the currently executing task. 
+        /// </summary>
+        public int LineNumberOfTaskNode
+        {
+            get
+            {
+                ErrorUtilities.VerifyThrow(_currentConfiguration != null, "We should never have a null configuration during a BuildEngine callback!");
+                return _currentConfiguration.LineNumberOfTask;
+            }
+        }
+
+        /// <summary>
+        /// Returns the column number of the location in the project file of the currently executing task. 
+        /// </summary>
+        public int ColumnNumberOfTaskNode
+        {
+            get
+            {
+                ErrorUtilities.VerifyThrow(_currentConfiguration != null, "We should never have a null configuration during a BuildEngine callback!");
+                return _currentConfiguration.ColumnNumberOfTask;
+            }
+        }
+
+        /// <summary>
+        /// Returns the project file of the currently executing task. 
+        /// </summary>
+        public string ProjectFileOfTaskNode
+        {
+            get
+            {
+                ErrorUtilities.VerifyThrow(_currentConfiguration != null, "We should never have a null configuration during a BuildEngine callback!");
+                return _currentConfiguration.ProjectFileOfTask;
+            }
+        }
+
+        #endregion // IBuildEngine Implementation (Properties)
+
+        #region IBuildEngine2 Implementation (Properties)
+
+        /// <summary>
+        /// Stub implementation of IBuildEngine2.IsRunningMultipleNodes.  The task host does not support this sort of 
+        /// IBuildEngine callback, so error. 
+        /// </summary>
+        public bool IsRunningMultipleNodes
+        {
+            get
+            {
+                LogErrorFromResource("BuildEngineCallbacksInTaskHostUnsupported");
+                return false;
+            }
+        }
+
+        #endregion // IBuildEngine2 Implementation (Properties)
+
+        #region IBuildEngine7 Implementation
+        /// <summary>
+        /// Enables or disables emitting a default error when a task fails without logging errors
+        /// </summary>
+        public bool AllowFailureWithoutError { get; set; } = false;
+        #endregion
+
+        #region IBuildEngine Implementation (Methods)
+
+        /// <summary>
+        /// Sends the provided error back to the parent node to be logged, tagging it with 
+        /// the parent node's ID so that, as far as anyone is concerned, it might as well have 
+        /// just come from the parent node to begin with. 
+        /// </summary>
+        public void LogErrorEvent(BuildErrorEventArgs e)
+        {
+            SendBuildEvent(e);
+        }
+
+        /// <summary>
+        /// Sends the provided warning back to the parent node to be logged, tagging it with 
+        /// the parent node's ID so that, as far as anyone is concerned, it might as well have 
+        /// just come from the parent node to begin with. 
+        /// </summary>
+        public void LogWarningEvent(BuildWarningEventArgs e)
+        {
+            SendBuildEvent(e);
+        }
+
+        /// <summary>
+        /// Sends the provided message back to the parent node to be logged, tagging it with 
+        /// the parent node's ID so that, as far as anyone is concerned, it might as well have 
+        /// just come from the parent node to begin with. 
+        /// </summary>
+        public void LogMessageEvent(BuildMessageEventArgs e)
+        {
+            SendBuildEvent(e);
+        }
+
+        /// <summary>
+        /// Sends the provided custom event back to the parent node to be logged, tagging it with 
+        /// the parent node's ID so that, as far as anyone is concerned, it might as well have 
+        /// just come from the parent node to begin with. 
+        /// </summary>
+        public void LogCustomEvent(CustomBuildEventArgs e)
+        {
+            SendBuildEvent(e);
+        }
+
+        /// <summary>
+        /// Stub implementation of IBuildEngine.BuildProjectFile.  The task host does not support IBuildEngine 
+        /// callbacks for the purposes of building projects, so error.  
+        /// </summary>
+        public bool BuildProjectFile(string projectFileName, string[] targetNames, IDictionary globalProperties, IDictionary targetOutputs)
+        {
+            LogErrorFromResource("BuildEngineCallbacksInTaskHostUnsupported");
+            return false;
+        }
+
+        #endregion // IBuildEngine Implementation (Methods)
+
+        #region IBuildEngine2 Implementation (Methods)
+
+        /// <summary>
+        /// Stub implementation of IBuildEngine2.BuildProjectFile.  The task host does not support IBuildEngine 
+        /// callbacks for the purposes of building projects, so error.  
+        /// </summary>
+        public bool BuildProjectFile(string projectFileName, string[] targetNames, IDictionary globalProperties, IDictionary targetOutputs, string toolsVersion)
+        {
+            LogErrorFromResource("BuildEngineCallbacksInTaskHostUnsupported");
+            return false;
+        }
+
+        /// <summary>
+        /// Stub implementation of IBuildEngine2.BuildProjectFilesInParallel.  The task host does not support IBuildEngine 
+        /// callbacks for the purposes of building projects, so error.  
+        /// </summary>
+        public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IDictionary[] targetOutputsPerProject, string[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion)
+        {
+            LogErrorFromResource("BuildEngineCallbacksInTaskHostUnsupported");
+            return false;
+        }
+
+        #endregion // IBuildEngine2 Implementation (Methods)
+
+        #region IBuildEngine3 Implementation
+
+        /// <summary>
+        /// Stub implementation of IBuildEngine3.BuildProjectFilesInParallel.  The task host does not support IBuildEngine 
+        /// callbacks for the purposes of building projects, so error.  
+        /// </summary>
+        public BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IList<string>[] removeGlobalProperties, string[] toolsVersion, bool returnTargetOutputs)
+        {
+            LogErrorFromResource("BuildEngineCallbacksInTaskHostUnsupported");
+            return new BuildEngineResult(false, null);
+        }
+
+        /// <summary>
+        /// Stub implementation of IBuildEngine3.Yield.  The task host does not support yielding, so just go ahead and silently
+        /// return, letting the task continue. 
+        /// </summary>
+        public void Yield()
+        {
+            return;
+        }
+
+        /// <summary>
+        /// Stub implementation of IBuildEngine3.Reacquire. The task host does not support yielding, so just go ahead and silently 
+        /// return, letting the task continue. 
+        /// </summary>
+        public void Reacquire()
+        {
+            return;
+        }
+
+        #endregion // IBuildEngine3 Implementation
+
+#if !CLR2COMPATIBILITY
+        #region IBuildEngine4 Implementation
+
+        /// <summary>
+        /// Registers an object with the system that will be disposed of at some specified time
+        /// in the future.
+        /// </summary>
+        /// <param name="key">The key used to retrieve the object.</param>
+        /// <param name="obj">The object to be held for later disposal.</param>
+        /// <param name="lifetime">The lifetime of the object.</param>
+        /// <param name="allowEarlyCollection">The object may be disposed earlier that the requested time if
+        /// MSBuild needs to reclaim memory.</param>
+        public void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection)
+        {
+            _registeredTaskObjectCache.RegisterTaskObject(key, obj, lifetime, allowEarlyCollection);
+        }
+
+        /// <summary>
+        /// Retrieves a previously registered task object stored with the specified key.
+        /// </summary>
+        /// <param name="key">The key used to retrieve the object.</param>
+        /// <param name="lifetime">The lifetime of the object.</param>
+        /// <returns>
+        /// The registered object, or null is there is no object registered under that key or the object
+        /// has been discarded through early collection.
+        /// </returns>
+        public object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime)
+        {
+            return _registeredTaskObjectCache.GetRegisteredTaskObject(key, lifetime);
+        }
+
+        /// <summary>
+        /// Unregisters a previously-registered task object.
+        /// </summary>
+        /// <param name="key">The key used to retrieve the object.</param>
+        /// <param name="lifetime">The lifetime of the object.</param>
+        /// <returns>
+        /// The registered object, or null is there is no object registered under that key or the object
+        /// has been discarded through early collection.
+        /// </returns>
+        public object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime lifetime)
+        {
+            return _registeredTaskObjectCache.UnregisterTaskObject(key, lifetime);
+        }
+
+        #endregion
+
+        #region IBuildEngine5 Implementation
+
+        /// <summary>
+        /// Logs a telemetry event.
+        /// </summary>
+        /// <param name="eventName">The event name.</param>
+        /// <param name="properties">The list of properties associated with the event.</param>
+        public void LogTelemetry(string eventName, IDictionary<string, string> properties)
+        {
+            SendBuildEvent(new TelemetryEventArgs
+            {
+                EventName = eventName,
+                Properties = properties == null ? new Dictionary<string, string>() : new Dictionary<string, string>(properties),
+            });
+        }
+
+        #endregion
+
+        #region IBuildEngine6 Implementation
+
+        /// <summary>
+        /// Gets the global properties for the current project.
+        /// </summary>
+        /// <returns>An <see cref="IReadOnlyDictionary{String, String}" /> containing the global properties of the current project.</returns>
+        public IReadOnlyDictionary<string, string> GetGlobalProperties()
+        {
+            return new Dictionary<string, string>(_currentConfiguration.GlobalProperties);
+        }
+
+        #endregion
+#endif
+
+        #region INodePacketFactory Members
+
+        /// <summary>
+        /// Registers the specified handler for a particular packet type.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="factory">The factory for packets of the specified type.</param>
+        /// <param name="handler">The handler to be called when packets of the specified type are received.</param>
+        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)
+        {
+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);
+        }
+
+        /// <summary>
+        /// Unregisters a packet handler.
+        /// </summary>
+        /// <param name="packetType">The packet type.</param>
+        public void UnregisterPacketHandler(NodePacketType packetType)
+        {
+            _packetFactory.UnregisterPacketHandler(packetType);
+        }
+
+        /// <summary>
+        /// Takes a serializer, deserializes the packet and routes it to the appropriate handler.
+        /// </summary>
+        /// <param name="nodeId">The node from which the packet was received.</param>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
+        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        {
+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
+        }
+
+        /// <summary>
+        /// Routes the specified packet
+        /// </summary>
+        /// <param name="nodeId">The node from which the packet was received.</param>
+        /// <param name="packet">The packet to route.</param>
+        public void RoutePacket(int nodeId, INodePacket packet)
+        {
+            _packetFactory.RoutePacket(nodeId, packet);
+        }
+
+        #endregion // INodePacketFactory Members
+
+        #region INodePacketHandler Members
+
+        /// <summary>
+        /// This method is invoked by the NodePacketRouter when a packet is received and is intended for
+        /// this recipient.
+        /// </summary>
+        /// <param name="node">The node from which the packet was received.</param>
+        /// <param name="packet">The packet.</param>
+        public void PacketReceived(int node, INodePacket packet)
+        {
+            lock (_receivedPackets)
+            {
+                _receivedPackets.Enqueue(packet);
+                _packetReceivedEvent.Set();
+            }
+        }
+
+        #endregion // INodePacketHandler Members
+
+        #region INode Members
+
+        public static NodeEngineShutdownReason RunMultiClient(int maxClients, out Exception shutdownException)
+        {
+            // Option A
+            const int minListenCapacity = 2;
+            int currentCapacity = 0;
+
+            // initiate with two waiting clients
+            for (int i = 0; i < minListenCapacity; i++)
+            {
+                s_waitForConcurrentClient.Add(true);
+            }
+
+            // run draining queue
+            foreach (var _ in s_waitForConcurrentClient.GetConsumingEnumerable())
+            {
+                System.Threading.Tasks.Task.Run(() =>
+                {
+                    // TODO: block when max clients is reached
+
+                    Interlocked.Increment(ref currentCapacity);
+
+                    var rarTaskHost = new RarServiceTaskHostNode();
+                    var shutdownReason = rarTaskHost.Run(out var rarTaskHostShutdownException);
+
+                    Interlocked.Decrement(ref currentCapacity);
+                    // TODO: somehow react to shutdownException and unexpected shutdownReason, maybe log unexpected somewhere?
+                });
+
+                // TODO: how to do graceful node termination?
+            }
+
+            throw new NotImplementedException();
+
+            // Option B
+            // create list of N instances when N is concurrency level
+            //var clients = Enumerable.Range(0, maxClients).Select(_ =>
+            //    System.Threading.Tasks.Task.Run(() =>
+            //    {
+            //        RarServiceTaskHostNode rarTaskHost;
+            //        NodeEngineShutdownReason rarTaskHostShutdownReason;
+            //        Exception rarTaskHostShutdownException;
+
+            //        do
+            //        {
+            //            rarTaskHost = new RarServiceTaskHostNode();
+            //            rarTaskHostShutdownReason = rarTaskHost.Run(out rarTaskHostShutdownException);
+            //        } while (rarTaskHostShutdownReason == NodeEngineShutdownReason.ConnectionFailed || rarTaskHostShutdownReason == NodeEngineShutdownReason.BuildCompleteReuse);
+
+            //        return (TaskHost: rarTaskHost, shutdownReason: rarTaskHostShutdownReason, shutdownException: rarTaskHostShutdownException);
+            //    })).ToArray();
+            //// wait for them all to be finished
+            //System.Threading.Tasks.Task.WaitAll(clients.Cast<System.Threading.Tasks.Task>().ToArray());
+            //// aggregate exceptions
+            //var exceptions = clients.Where(c => c.Result.shutdownException != null).Select(c => c.Result.shutdownException).ToArray();
+            //if (exceptions.Length > 0)
+            //{
+            //    shutdownException = new AggregateException(exceptions);
+            //    return NodeEngineShutdownReason.Error;
+            //}
+            //else
+            //{
+            //    shutdownException = null;
+            //    return NodeEngineShutdownReason.BuildCompleteReuse;
+            //}
+        }
+
+        /// <summary>
+        /// Starts up the node and processes messages until the node is requested to shut down.
+        /// </summary>
+        /// <param name="isRar">True if we are hosting RAR node</param>
+        /// <param name="shutdownException">The exception which caused shutdown, if any.</param>
+        /// <returns>The reason for shutting down.</returns>
+        public NodeEngineShutdownReason Run(out Exception shutdownException)
+        {
+#if !CLR2COMPATIBILITY
+            _registeredTaskObjectCache = new RegisteredTaskObjectCacheBase();
+#endif
+            shutdownException = null;
+
+            // Snapshot the current environment
+            _savedEnvironment = CommunicationsUtilities.GetEnvironmentVariables();
+
+            string pipeName = "MSBuild" + Process.GetCurrentProcess().Id;
+
+            _nodeEndpoint = new NodeEndpointRarTaskHost(pipeName/*, multiConnections: true*/);
+            _nodeEndpoint.OnLinkStatusChanged += new LinkStatusChangedDelegate(OnLinkStatusChanged);
+            _nodeEndpoint.Listen(this);
+
+            WaitHandle[] waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent, _taskCompleteEvent, _taskCancelledEvent };
+
+            while (true)
+            {
+                int index = WaitHandle.WaitAny(waitHandles);
+                switch (index)
+                {
+                    case 0: // shutdownEvent
+                        NodeEngineShutdownReason shutdownReason = HandleShutdown();
+                        return shutdownReason;
+
+                    case 1: // packetReceivedEvent
+                        INodePacket packet = null;
+
+                        int packetCount = _receivedPackets.Count;
+
+                        while (packetCount > 0)
+                        {
+                            lock (_receivedPackets)
+                            {
+                                if (_receivedPackets.Count > 0)
+                                {
+                                    packet = _receivedPackets.Dequeue();
+                                }
+                                else
+                                {
+                                    break;
+                                }
+                            }
+
+                            if (packet != null)
+                            {
+                                HandlePacket(packet);
+                            }
+                        }
+
+                        break;
+                    case 2: // taskCompleteEvent
+                        CompleteTask();
+                        break;
+                    case 3: // taskCancelledEvent
+                        CancelTask();
+                        break;
+                }
+            }
+
+            // UNREACHABLE
+        }
+        #endregion
+
+        /// <summary>
+        /// Dispatches the packet to the correct handler.
+        /// </summary>
+        private void HandlePacket(INodePacket packet)
+        {
+            switch (packet.Type)
+            {
+                case NodePacketType.TaskHostConfiguration:
+                    HandleTaskHostConfiguration(packet as TaskHostConfiguration);
+                    break;
+                case NodePacketType.TaskHostTaskCancelled:
+                    _taskCancelledEvent.Set();
+                    break;
+                case NodePacketType.NodeBuildComplete:
+                    HandleNodeBuildComplete(packet as NodeBuildComplete);
+                    break;
+            }
+        }
+
+        /// <summary>
+        /// Configure the task host according to the information received in the 
+        /// configuration packet
+        /// </summary>
+        private void HandleTaskHostConfiguration(TaskHostConfiguration taskHostConfiguration)
+        {
+            ErrorUtilities.VerifyThrow(!_isTaskExecuting, "Why are we getting a TaskHostConfiguration packet while we're still executing a task?");
+            _currentConfiguration = taskHostConfiguration;
+
+            // Kick off the task running thread.
+            _taskRunnerThread = new Thread(new ParameterizedThreadStart(RunTask));
+            _taskRunnerThread.Name = "Task runner for task " + taskHostConfiguration.TaskName;
+            _taskRunnerThread.Start(taskHostConfiguration);
+        }
+
+        /// <summary>
+        /// The task has been completed
+        /// </summary>
+        private void CompleteTask()
+        {
+            ErrorUtilities.VerifyThrow(!_isTaskExecuting, "The task should be done executing before CompleteTask.");
+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
+            {
+                TaskHostTaskComplete taskCompletePacketToSend;
+
+                lock (_taskCompleteLock)
+                {
+                    ErrorUtilities.VerifyThrowInternalNull(_taskCompletePacket, "taskCompletePacket");
+                    taskCompletePacketToSend = _taskCompletePacket;
+                    _taskCompletePacket = null;
+                }
+
+                _nodeEndpoint.SendData(taskCompletePacketToSend);
+            }
+
+            _currentConfiguration = null;
+
+            // If the task has been canceled, the event will still be set.  
+            // If so, now that we've completed the task, we want to shut down 
+            // this node -- with no reuse, since we don't know whether the 
+            // task we canceled left the node in a good state or not. 
+            if (_taskCancelledEvent.WaitOne(0))
+            {
+                _shutdownReason = NodeEngineShutdownReason.BuildComplete;
+                _shutdownEvent.Set();
+            }
+        }
+
+        /// <summary>
+        /// This task has been cancelled. Attempt to cancel the task
+        /// </summary>
+        private void CancelTask()
+        {
+            // If the task is an ICancellable task in CLR4 we will call it here and wait for it to complete
+            // Otherwise it's a classic ITask.
+
+            // Store in a local to avoid a race
+            var wrapper = _taskWrapper;
+            if (wrapper?.CancelTask() == false)
+            {
+                // Create a possibility for the task to be aborted if the user really wants it dropped dead asap
+                if (Environment.GetEnvironmentVariable("MSBUILDTASKHOSTABORTTASKONCANCEL") == "1")
+                {
+                    // Don't bother aborting the task if it has passed the actual user task Execute()
+                    // It means we're already in the process of shutting down - Wait for the taskCompleteEvent to be set instead.
+                    if (_isTaskExecuting)
+                    {
+#if FEATURE_THREAD_ABORT
+                        // The thread will be terminated crudely so our environment may be trashed but it's ok since we are 
+                        // shutting down ASAP.
+                        _taskRunnerThread.Abort();
+#endif
+                    }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Handles the NodeBuildComplete packet.
+        /// </summary>
+        private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)
+        {
+            ErrorUtilities.VerifyThrow(!_isTaskExecuting, "We should never have a task in the process of executing when we receive NodeBuildComplete.");
+
+            _shutdownReason = buildComplete.PrepareForReuse ? NodeEngineShutdownReason.BuildCompleteReuse : NodeEngineShutdownReason.BuildComplete;
+            _shutdownEvent.Set();
+        }
+
+        /// <summary>
+        /// Perform necessary actions to shut down the node.
+        /// </summary>
+        private NodeEngineShutdownReason HandleShutdown()
+        {
+            // Wait for the RunTask task runner thread before shutting down so that we can cleanly dispose all WaitHandles.
+            _taskRunnerThread?.Join();
+
+            if (_debugCommunications)
+            {
+                using (StreamWriter writer = File.CreateText(String.Format(CultureInfo.CurrentCulture, Path.Combine(Path.GetTempPath(), @"MSBuild_NodeShutdown_{0}.txt"), Process.GetCurrentProcess().Id)))
+                {
+                    writer.WriteLine("Node shutting down with reason {0}.", _shutdownReason);
+                }
+            }
+
+#if !CLR2COMPATIBILITY
+            _registeredTaskObjectCache.DisposeCacheObjects(RegisteredTaskObjectLifetime.Build);
+            _registeredTaskObjectCache = null;
+#endif
+
+            // On Windows, a process holds a handle to the current directory,
+            // so reset it away from a user-requested folder that may get deleted.
+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);
+
+            // Restore the original environment.
+            CommunicationsUtilities.SetEnvironment(_savedEnvironment);
+
+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
+            {
+                // Notify the BuildManager that we are done.
+                _nodeEndpoint.SendData(new NodeShutdown(_shutdownReason == NodeEngineShutdownReason.Error ? NodeShutdownReason.Error : NodeShutdownReason.Requested));
+
+                // Flush all packets to the pipe and close it down.  This blocks until the shutdown is complete.
+                _nodeEndpoint.OnLinkStatusChanged -= new LinkStatusChangedDelegate(OnLinkStatusChanged);
+            }
+
+            _nodeEndpoint.Disconnect();
+
+            // Dispose these WaitHandles
+#if CLR2COMPATIBILITY
+            _packetReceivedEvent.Close();
+            _shutdownEvent.Close();
+            _taskCompleteEvent.Close();
+            _taskCancelledEvent.Close();
+#else
+            _packetReceivedEvent.Dispose();
+            _shutdownEvent.Dispose();
+            _taskCompleteEvent.Dispose();
+            _taskCancelledEvent.Dispose();
+#endif
+
+            return _shutdownReason;
+        }
+
+        /// <summary>
+        /// Event handler for the node endpoint's LinkStatusChanged event.
+        /// </summary>
+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)
+        {
+            switch (status)
+            {
+                case LinkStatus.ConnectionFailed:
+                case LinkStatus.Failed:
+                    // connection fail - unexpected but could happen if handshake fails for any reason
+                    // in such case we need to start new client as LinkStatus.Active has not been reached
+                    s_waitForConcurrentClient.Add(false);
+
+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;
+                    _shutdownEvent.Set();
+                    break;
+
+                case LinkStatus.Inactive:
+                    break;
+
+                case LinkStatus.Active:
+                    // start listen to another incoming connection
+                    s_waitForConcurrentClient.Add(true);
+                    break;
+
+                default:
+                    break;
+            }
+        }
+
+        /// <summary>
+        /// Task runner method
+        /// </summary>
+        private void RunTask(object state)
+        {
+            _isTaskExecuting = true;
+            OutOfProcTaskHostTaskResult taskResult = null;
+            TaskHostConfiguration taskConfiguration = state as TaskHostConfiguration;
+            IDictionary<string, TaskParameter> taskParams = taskConfiguration.TaskParameters;
+
+            // We only really know the values of these variables for sure once we see what we received from our parent 
+            // environment -- otherwise if this was a completely new build, we could lose out on expected environment 
+            // variables.  
+            _debugCommunications = taskConfiguration.BuildProcessEnvironment.ContainsValueAndIsEqual("MSBUILDDEBUGCOMM", "1", StringComparison.OrdinalIgnoreCase);
+            _updateEnvironment = !taskConfiguration.BuildProcessEnvironment.ContainsValueAndIsEqual("MSBuildTaskHostDoNotUpdateEnvironment", "1", StringComparison.OrdinalIgnoreCase);
+            _updateEnvironmentAndLog = taskConfiguration.BuildProcessEnvironment.ContainsValueAndIsEqual("MSBuildTaskHostUpdateEnvironmentAndLog", "1", StringComparison.OrdinalIgnoreCase);
+
+            try
+            {
+                // TODO: delete eventually
+                // Change to the startup directory
+                NativeMethodsShared.SetCurrentDirectory(taskConfiguration.StartupDirectory);
+
+                if (_updateEnvironment)
+                {
+                    // TODO: delete eventually
+                    InitializeMismatchedEnvironmentTable(taskConfiguration.BuildProcessEnvironment);
+                }
+
+                // Now set the new environment
+                // TODO: delete eventually
+                SetTaskHostEnvironment(taskConfiguration.BuildProcessEnvironment);
+
+                // Set culture
+                Thread.CurrentThread.CurrentCulture = taskConfiguration.Culture;
+                Thread.CurrentThread.CurrentUICulture = taskConfiguration.UICulture;
+
+                string taskName = taskConfiguration.TaskName;
+                string taskLocation = taskConfiguration.TaskLocation;
+
+                // We will not create an appdomain now because of a bug
+                // As a fix, we will create the class directly without wrapping it in a domain
+                _taskWrapper = new OutOfProcTaskAppDomainWrapper();
+
+                taskResult = _taskWrapper.ExecuteTask
+                (
+                    this as IBuildEngine,
+                    taskName,
+                    taskLocation,
+                    taskConfiguration.ProjectFileOfTask,
+                    taskConfiguration.LineNumberOfTask,
+                    taskConfiguration.ColumnNumberOfTask,
+#if FEATURE_APPDOMAIN
+                    taskConfiguration.AppDomainSetup,
+#endif
+                    taskParams,
+                    new TaskExecutionContext(taskConfiguration.StartupDirectory, taskConfiguration.BuildProcessEnvironment, taskConfiguration.Culture, taskConfiguration.UICulture)
+                );
+            }
+            catch (Exception e)
+            {
+                if (e is ThreadAbortException)
+                {
+                    // This thread was aborted as part of Cancellation, we will return a failure task result
+                    taskResult = new OutOfProcTaskHostTaskResult(TaskCompleteType.Failure);
+                }
+                else
+                if (ExceptionHandling.IsCriticalException(e))
+                {
+                    throw;
+                }
+                else
+                {
+                    taskResult = new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringExecution, e);
+                }
+            }
+            finally
+            {
+                try
+                {
+                    _isTaskExecuting = false;
+
+                    IDictionary<string, string> currentEnvironment = CommunicationsUtilities.GetEnvironmentVariables();
+                    currentEnvironment = UpdateEnvironmentForMainNode(currentEnvironment);
+
+                    if (taskResult == null)
+                    {
+                        taskResult = new OutOfProcTaskHostTaskResult(TaskCompleteType.Failure);
+                    }
+
+                    lock (_taskCompleteLock)
+                    {
+                        _taskCompletePacket = new TaskHostTaskComplete
+                                                    (
+                                                        taskResult,
+                                                        currentEnvironment
+                                                    );
+                    }
+
+#if FEATURE_APPDOMAIN
+                    foreach (TaskParameter param in taskParams.Values)
+                    {
+                        // Tell remoting to forget connections to the parameter
+                        RemotingServices.Disconnect(param);
+                    }
+#endif
+
+                    // Restore the original clean environment
+                    CommunicationsUtilities.SetEnvironment(_savedEnvironment);
+                }
+                catch (Exception e)
+                {
+                    lock (_taskCompleteLock)
+                    {
+                        // Create a minimal taskCompletePacket to carry the exception so that the TaskHostTask does not hang while waiting
+                        _taskCompletePacket = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedAfterExecution, e), null);
+                    }
+                }
+                finally
+                {
+                    // Call CleanupTask to unload any domains and other necessary cleanup in the taskWrapper
+                    _taskWrapper.CleanupTask();
+
+                    // The task has now fully completed executing
+                    _taskCompleteEvent.Set();
+                }
+            }
+        }
+
+        /// <summary>
+        /// Set the environment for the task host -- includes possibly munging the given 
+        /// environment somewhat to account for expected environment differences between, 
+        /// e.g. parent processes and task hosts of different bitnesses. 
+        /// </summary>
+        private void SetTaskHostEnvironment(IDictionary<string, string> environment)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(s_mismatchedEnvironmentValues, "mismatchedEnvironmentValues");
+            IDictionary<string, string> updatedEnvironment = null;
+
+            if (_updateEnvironment)
+            {
+                foreach (string variable in s_mismatchedEnvironmentValues.Keys)
+                {
+                    string oldValue = s_mismatchedEnvironmentValues[variable].Key;
+                    string newValue = s_mismatchedEnvironmentValues[variable].Value;
+
+                    // We don't check the return value, because having the variable not exist == be 
+                    // null is perfectly valid, and mismatchedEnvironmentValues stores those values
+                    // as null as well, so the String.Equals should still return that they are equal.
+                    string environmentValue = null;
+                    environment.TryGetValue(variable, out environmentValue);
+
+                    if (String.Equals(environmentValue, oldValue, StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (updatedEnvironment == null)
+                        {
+                            if (_updateEnvironmentAndLog)
+                            {
+                                LogMessageFromResource(MessageImportance.Low, "ModifyingTaskHostEnvironmentHeader");
+                            }
+
+                            updatedEnvironment = new Dictionary<string, string>(environment, StringComparer.OrdinalIgnoreCase);
+                        }
+
+                        if (newValue != null)
+                        {
+                            if (_updateEnvironmentAndLog)
+                            {
+                                LogMessageFromResource(MessageImportance.Low, "ModifyingTaskHostEnvironmentVariable", variable, newValue, environmentValue ?? String.Empty);
+                            }
+
+                            updatedEnvironment[variable] = newValue;
+                        }
+                        else
+                        {
+                            updatedEnvironment.Remove(variable);
+                        }
+                    }
+                }
+            }
+
+            // if it's still null here, there were no changes necessary -- so just 
+            // set it to what was already passed in. 
+            if (updatedEnvironment == null)
+            {
+                updatedEnvironment = environment;
+            }
+
+            CommunicationsUtilities.SetEnvironment(updatedEnvironment);
+        }
+
+        /// <summary>
+        /// Given the environment of the task host at the end of task execution, make sure that any 
+        /// processor-specific variables have been re-applied in the correct form for the main node, 
+        /// so that when we pass this dictionary back to the main node, all it should have to do 
+        /// is just set it.  
+        /// </summary>
+        private IDictionary<string, string> UpdateEnvironmentForMainNode(IDictionary<string, string> environment)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(s_mismatchedEnvironmentValues, "mismatchedEnvironmentValues");
+            IDictionary<string, string> updatedEnvironment = null;
+
+            if (_updateEnvironment)
+            {
+                foreach (string variable in s_mismatchedEnvironmentValues.Keys)
+                {
+                    // Since this is munging the property list for returning to the parent process, 
+                    // then the value we wish to replace is the one that is in this process, and the 
+                    // replacement value is the one that originally came from the parent process, 
+                    // instead of the other way around.
+                    string oldValue = s_mismatchedEnvironmentValues[variable].Value;
+                    string newValue = s_mismatchedEnvironmentValues[variable].Key;
+
+                    // We don't check the return value, because having the variable not exist == be 
+                    // null is perfectly valid, and mismatchedEnvironmentValues stores those values
+                    // as null as well, so the String.Equals should still return that they are equal.
+                    string environmentValue = null;
+                    environment.TryGetValue(variable, out environmentValue);
+
+                    if (String.Equals(environmentValue, oldValue, StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (updatedEnvironment == null)
+                        {
+                            updatedEnvironment = new Dictionary<string, string>(environment, StringComparer.OrdinalIgnoreCase);
+                        }
+
+                        if (newValue != null)
+                        {
+                            updatedEnvironment[variable] = newValue;
+                        }
+                        else
+                        {
+                            updatedEnvironment.Remove(variable);
+                        }
+                    }
+                }
+            }
+
+            // if it's still null here, there were no changes necessary -- so just 
+            // set it to what was already passed in. 
+            if (updatedEnvironment == null)
+            {
+                updatedEnvironment = environment;
+            }
+
+            return updatedEnvironment;
+        }
+
+        /// <summary>
+        /// Make sure the mismatchedEnvironmentValues table has been populated.  Note that this should 
+        /// only do actual work on the very first run of a task in the task host -- otherwise, it should 
+        /// already have been populated. 
+        /// </summary>
+        private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> environment)
+        {
+            if (s_mismatchedEnvironmentValues == null)
+            {
+                // This is the first time that we have received a TaskHostConfiguration packet, so we 
+                // need to construct the mismatched environment table based on our current environment 
+                // (assumed to be effectively identical to startup) and the environment we were given
+                // via the task host configuration, assumed to be effectively identical to the startup 
+                // environment of the task host, given that the configuration packet is sent immediately
+                // after the node is launched.  
+                s_mismatchedEnvironmentValues = new Dictionary<string, KeyValuePair<string, string>>(StringComparer.OrdinalIgnoreCase);
+
+                foreach (string variable in _savedEnvironment.Keys)
+                {
+                    string oldValue = _savedEnvironment[variable];
+                    string newValue;
+                    if (!environment.TryGetValue(variable, out newValue))
+                    {
+                        s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(null, oldValue);
+                    }
+                    else
+                    {
+                        if (!String.Equals(oldValue, newValue, StringComparison.OrdinalIgnoreCase))
+                        {
+                            s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, oldValue);
+                        }
+                    }
+                }
+
+                foreach (string variable in environment.Keys)
+                {
+                    string newValue = environment[variable];
+                    string oldValue;
+                    if (!_savedEnvironment.TryGetValue(variable, out oldValue))
+                    {
+                        s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, null);
+                    }
+                    else
+                    {
+                        if (!String.Equals(oldValue, newValue, StringComparison.OrdinalIgnoreCase))
+                        {
+                            s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, oldValue);
+                        }
+                    }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Sends the requested packet across to the main node. 
+        /// </summary>
+        private void SendBuildEvent(BuildEventArgs e)
+        {
+            if (_nodeEndpoint?.LinkStatus == LinkStatus.Active)
+            {
+                if (!e.GetType().GetTypeInfo().IsSerializable)
+                {
+                    // log a warning and bail.  This will end up re-calling SendBuildEvent, but we know for a fact
+                    // that the warning that we constructed is serializable, so everything should be good.  
+                    LogWarningFromResource("ExpectedEventToBeSerializable", e.GetType().Name);
+                    return;
+                }
+
+                _nodeEndpoint.SendData(new LogMessagePacket(new KeyValuePair<int, BuildEventArgs>(_currentConfiguration.NodeId, e)));
+            }
+        }
+
+        /// <summary>
+        /// Generates the message event corresponding to a particular resource string and set of args
+        /// </summary>
+        private void LogMessageFromResource(MessageImportance importance, string messageResource, params object[] messageArgs)
+        {
+            ErrorUtilities.VerifyThrow(_currentConfiguration != null, "We should never have a null configuration when we're trying to log messages!");
+
+            // Using the CLR 2 build event because this class is shared between MSBuildTaskHost.exe (CLR2) and MSBuild.exe (CLR4+)
+            BuildMessageEventArgs message = new BuildMessageEventArgs
+                                                (
+                                                    ResourceUtilities.FormatString(AssemblyResources.GetString(messageResource), messageArgs),
+                                                    null,
+                                                    _currentConfiguration.TaskName,
+                                                    importance
+                                                );
+
+            LogMessageEvent(message);
+        }
+
+        /// <summary>
+        /// Generates the error event corresponding to a particular resource string and set of args
+        /// </summary>
+        private void LogWarningFromResource(string messageResource, params object[] messageArgs)
+        {
+            ErrorUtilities.VerifyThrow(_currentConfiguration != null, "We should never have a null configuration when we're trying to log warnings!");
+
+            // Using the CLR 2 build event because this class is shared between MSBuildTaskHost.exe (CLR2) and MSBuild.exe (CLR4+)
+            BuildWarningEventArgs warning = new BuildWarningEventArgs
+                                                (
+                                                    null,
+                                                    null,
+                                                    ProjectFileOfTaskNode,
+                                                    LineNumberOfTaskNode,
+                                                    ColumnNumberOfTaskNode,
+                                                    0,
+                                                    0,
+                                                    ResourceUtilities.FormatString(AssemblyResources.GetString(messageResource), messageArgs),
+                                                    null,
+                                                    _currentConfiguration.TaskName
+                                                );
+
+            LogWarningEvent(warning);
+        }
+
+        /// <summary>
+        /// Generates the error event corresponding to a particular resource string and set of args
+        /// </summary>
+        private void LogErrorFromResource(string messageResource)
+        {
+            ErrorUtilities.VerifyThrow(_currentConfiguration != null, "We should never have a null configuration when we're trying to log errors!");
+
+            // Using the CLR 2 build event because this class is shared between MSBuildTaskHost.exe (CLR2) and MSBuild.exe (CLR4+)
+            BuildErrorEventArgs error = new BuildErrorEventArgs
+                                                (
+                                                    null,
+                                                    null,
+                                                    ProjectFileOfTaskNode,
+                                                    LineNumberOfTaskNode,
+                                                    ColumnNumberOfTaskNode,
+                                                    0,
+                                                    0,
+                                                    AssemblyResources.GetString(messageResource),
+                                                    null,
+                                                    _currentConfiguration.TaskName
+                                                );
+
+            LogErrorEvent(error);
+        }
+    }
+}
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 7891c7923dd..78a9ffbbe62 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -2654,6 +2654,10 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)
                         OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();
                         shutdownReason = node.Run(out nodeException);
                     }
+                    else if (nodeModeNumber == 3)
+                    {
+                        shutdownReason = RarServiceTaskHostNode.RunMultiClient(100, out nodeException);
+                    }
                     else
                     {
                         CommandLineSwitchException.Throw("InvalidNodeNumberValue", nodeModeNumber.ToString());
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 0437fdcbb36..edf4ec79a30 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -45,6 +45,9 @@
     <Compile Include="..\Framework\BuildEngineResult.cs">
       <Link>BuildEngineResult.cs</Link>
     </Compile>
+    <Compile Include="..\Framework\TaskExecutionContext.cs">
+      <Link>BuildEngineResult.cs</Link>
+    </Compile>
     <Compile Include="..\Framework\IBuildEngine3.cs">
       <Link>IBuildEngine3.cs</Link>
     </Compile>
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 26859071fc0..63c98ed19fe 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -56,7 +56,12 @@ internal enum HandshakeOptions
         /// <summary>
         /// Building with administrator privileges
         /// </summary>
-        Administrator = 32
+        Administrator = 32,
+
+        /// <summary>
+        /// RAR service
+        /// </summary>
+        RarService = 64
     }
 
     internal readonly struct Handshake
@@ -90,7 +95,7 @@ internal Handshake(HandshakeOptions nodeType)
         // This is used as a key, so it does not need to be human readable.
         public override string ToString()
         {
-            return String.Format("{0} {1} {2} {3} {4} {5} {6}", options, salt, fileVersionMajor, fileVersionMinor, fileVersionBuild, fileVersionPrivate, sessionId);
+            return $"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}";
         }
 
         internal int[] RetrieveHandshakeComponents()
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index c58bc449a1c..5dee5fd1ef2 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -185,11 +185,12 @@ public void SendData(INodePacket packet)
 
 #region Construction
 
-        /// <summary>
-        /// Instantiates an endpoint to act as a client
-        /// </summary>
-        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
-        internal void InternalConstruct(string pipeName)
+/// <summary>
+/// Instantiates an endpoint to act as a client
+/// </summary>
+/// <param name="pipeName">The name of the pipe to which we should connect.</param>
+/// <param name="multiClient"></param>
+internal void InternalConstruct(string pipeName, bool multiClient = false)
         {
             ErrorUtilities.VerifyThrowArgumentLength(pipeName, nameof(pipeName));
 
@@ -213,7 +214,7 @@ internal void InternalConstruct(string pipeName)
                 // SIDs or the client will reject this server.  This is used to avoid attacks where a
                 // hacked server creates a less restricted pipe in an attempt to lure us into using it and 
                 // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)
-                PipeAccessRule rule = new PipeAccessRule(identifier, PipeAccessRights.ReadWrite, AccessControlType.Allow);
+                PipeAccessRule rule = new PipeAccessRule(identifier, PipeAccessRights.ReadWrite | PipeAccessRights.CreateNewInstance, AccessControlType.Allow);
                 security.AddAccessRule(rule);
                 security.SetOwner(identifier);
 
@@ -221,7 +222,7 @@ internal void InternalConstruct(string pipeName)
                     (
                     pipeName,
                     PipeDirection.InOut,
-                    1, // Only allow one connection at a time.
+                    multiClient ? -1 : 1, // Only allow one connection at a time or unlimited for multi client
                     PipeTransmissionMode.Byte,
                     PipeOptions.Asynchronous | PipeOptions.WriteThrough,
                     PipeBufferSize, // Default input buffer
@@ -237,13 +238,13 @@ internal void InternalConstruct(string pipeName)
                     (
                     pipeName,
                     PipeDirection.InOut,
-                    1, // Only allow one connection at a time.
+                    multiClient ? -1 : 1, // Only allow one connection at a time or unlimited for multi client
                     PipeTransmissionMode.Byte,
                     PipeOptions.Asynchronous | PipeOptions.WriteThrough,
                     PipeBufferSize, // Default input buffer
                     PipeBufferSize  // Default output buffer
                 );
-             }
+            }
         }
 
 #endregion
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index d03366aa29a..0f9c4e2f9be 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -27,7 +27,7 @@ namespace Microsoft.Build.Tasks
     /// Given a list of assemblyFiles, determine the closure of all assemblyFiles that
     /// depend on those assemblyFiles including second and nth-order dependencies too.
     /// </summary>
-    public class ResolveAssemblyReference : TaskExtension
+    public class ResolveAssemblyReference : TaskExtension, IConcurrentTask
     {
         /// <summary>
         /// key assembly used to trigger inclusion of facade references.
@@ -891,6 +891,12 @@ public ITaskItem[] SuggestedRedirects
         /// </summary>
         private List<ITaskItem> _filesWritten = new List<ITaskItem>();
 
+        /// <summary>
+        /// Execution context used when task is supposed to run concurrently in multiple threads.
+        /// If null hosting process do not run this task concurrently and set it execution context on process level.
+        /// </summary>
+        private TaskExecutionContext _concurrencyExecutionContext;
+
         /// <summary>
         /// The names of all files written to disk.
         /// </summary>
@@ -3041,5 +3047,10 @@ public override bool Execute()
         }
 
         #endregion
+
+        void IConcurrentTask.ConfigureForConcurrentExecution(TaskExecutionContext executionContext)
+        {
+            _concurrencyExecutionContext = executionContext;
+        }
     }
 }
