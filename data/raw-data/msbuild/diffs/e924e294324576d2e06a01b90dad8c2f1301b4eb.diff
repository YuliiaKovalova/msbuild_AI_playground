diff --git a/.editorconfig b/.editorconfig
index 9d03bd30636..b8e856dc62d 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -193,3 +193,7 @@ indent_size = 2
 end_of_line = lf
 [*.{cmd, bat}]
 end_of_line = crlf
+
+[src/**/*.{cs,vb}]
+# IDE0005: Remove unnecessary usings/imports
+dotnet_diagnostic.IDE0005.severity = warning
diff --git a/.github/CODE_OF_CONDUCT.md b/.github/CODE_OF_CONDUCT.md
index 6684a497cb9..91d2e404ff1 100644
--- a/.github/CODE_OF_CONDUCT.md
+++ b/.github/CODE_OF_CONDUCT.md
@@ -1,3 +1,6 @@
 # Code of Conduct
 
-This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.
+This project has adopted the code of conduct defined by the Contributor Covenant
+to clarify expected behavior in our community.
+
+For more information, see the [.NET Foundation Code of Conduct](https://dotnetfoundation.org/code-of-conduct).
\ No newline at end of file
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 844fec05dbb..df5f8f2bc6d 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -103,6 +103,12 @@ jobs:
     inputs:
       filename: 'eng/cibuild.cmd'
       arguments: '-configuration Release -test'
+  - task: RichCodeNavIndexer@0
+    displayName: RichCodeNav Upload
+    inputs:
+      languages: 'csharp'
+    continueOnError: true
+    condition: succeeded()
   - task: PublishTestResults@2
     displayName: Publish .NET Framework Test Results
     inputs:
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index a706deeb393..ef8f9b7cb82 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -43,7 +43,7 @@ stages:
     - name: VisualStudio.MajorVersion
       value: 16
     - name: VisualStudio.ChannelName
-      value: 'int.master'
+      value: 'int.main'
     - name: VisualStudio.DropName
       value: Products/$(System.TeamProject)/$(Build.Repository.Name)/$(Build.SourceBranchName)/$(Build.BuildNumber)
 
@@ -76,7 +76,6 @@ stages:
     - task: ms-vseng.MicroBuildTasks.32f78468-e895-4f47-962c-58a699361df8.MicroBuildSwixPlugin@1
       inputs:
         dropName: $(VisualStudio.DropName)
-        feedSource: 'https://devdiv-test.pkgs.visualstudio.com/_packaging/MicroBuildToolset/nuget/v3/index.json'
 
     - script: eng/CIBuild.cmd
                 -configuration $(BuildConfiguration)
@@ -172,7 +171,7 @@ stages:
       condition: succeeded()
 
     # Archive NuGet packages to DevOps.
-    # Publish our NuPkgs as an artifact. The name of this artifact must be PackageArtifacts as the 
+    # Publish our NuPkgs as an artifact. The name of this artifact must be PackageArtifacts as the
     # arcade templates depend on the name.
     - task: PublishBuildArtifacts@1
       displayName: 'Publish Artifact: packages'
diff --git a/MSBuild.Dev.sln b/MSBuild.Dev.sln
index 8fc92510fca..395bc1d6691 100644
--- a/MSBuild.Dev.sln
+++ b/MSBuild.Dev.sln
@@ -5,8 +5,8 @@ VisualStudioVersion = 15.0.27004.2009
 MinimumVisualStudioVersion = 10.0.40219.1
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{4900B3B8-4310-4D5B-B1F7-2FDF9199765F}"
 	ProjectSection(SolutionItems) = preProject
-		..\NuGet.Config = ..\NuGet.Config
-		..\targets\xunit.runner.json = ..\targets\xunit.runner.json
+		NuGet.Config = NuGet.Config
+		src\Shared\UnitTests\xunit.runner.json = src\Shared\UnitTests\xunit.runner.json
 	EndProjectSection
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build", "src\Build\Microsoft.Build.csproj", "{69BE05E2-CBDA-4D27-9733-44E12B0F5627}"
diff --git a/MSBuild.sln b/MSBuild.sln
index 2dd92702cdb..966817afd12 100644
--- a/MSBuild.sln
+++ b/MSBuild.sln
@@ -1,12 +1,12 @@
 ﻿
 Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio 15
-VisualStudioVersion = 15.0.27004.2009
+# Visual Studio Version 16
+VisualStudioVersion = 16.0.30320.27
 MinimumVisualStudioVersion = 10.0.40219.1
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{4900B3B8-4310-4D5B-B1F7-2FDF9199765F}"
 	ProjectSection(SolutionItems) = preProject
-		..\NuGet.Config = ..\NuGet.Config
-		..\targets\xunit.runner.json = ..\targets\xunit.runner.json
+		NuGet.Config = NuGet.Config
+		src\Shared\UnitTests\xunit.runner.json = src\Shared\UnitTests\xunit.runner.json
 	EndProjectSection
 EndProject
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Samples", "Samples", "{760FF85D-8BEB-4992-8095-A9678F88FD47}"
@@ -65,6 +65,8 @@ Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MSBuild.Engine.Corext", "sr
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MSBuild.Bootstrap", "src\MSBuild.Bootstrap\MSBuild.Bootstrap.csproj", "{CEAEE4FE-9298-443B-AFC5-0F72472484B6}"
 EndProject
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.UnGAC", "src\Package\Microsoft.Build.UnGAC\Microsoft.Build.UnGAC.csproj", "{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -834,6 +836,36 @@ Global
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|x64.ActiveCfg = Debug|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|x64.Build.0 = Debug|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|x86.Build.0 = Debug|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|Any CPU.Build.0 = Release|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|x64.ActiveCfg = Release|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|x64.Build.0 = Release|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|x86.ActiveCfg = Release|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|x86.Build.0 = Release|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x64.Build.0 = Release-MONO|x64
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
@@ -850,6 +882,7 @@ Global
 		{16DBDF17-3E0E-4140-989A-B42638126A40} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
 		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F} = {9BAD9352-DEFB-45E5-B8A4-4816B9B22A33}
 	EndGlobalSection
 	GlobalSection(ExtensibilityGlobals) = postSolution
 		SolutionGuid = {F948D667-14E3-4F98-BA50-3F3C948BF4C2}
diff --git a/NuGet.config b/NuGet.config
index 5e45df013f4..cda7383f71e 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -10,4 +10,5 @@
     <add key="roslyn-tools" value="https://dotnet.myget.org/F/roslyn-tools/api/v3/index.json" />
     <add key="dotnet-tools" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json" />
   </packageSources>
+  <disabledPackageSources />
 </configuration>
diff --git a/README.md b/README.md
index b81b6c6c627..799a130a51b 100644
--- a/README.md
+++ b/README.md
@@ -6,11 +6,15 @@ For more information on MSBuild, see the [MSBuild documentation](https://docs.mi
 
 ### Build Status
 
-The current development branch is `master`. Changes in `master` will go into a future update of MSBuild, which will release with Visual Studio 16.8 and a corresponding version of the .NET Core SDK.
+The current development branch is `master`. Changes in `master` will go into a future update of MSBuild, which will release with Visual Studio 16.9 and a corresponding version of the .NET Core SDK.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=master)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=master)
 
-We have forked for MSBuild 16.7 in the branch [`vs16.7`](https://github.com/Microsoft/msbuild/tree/vs16.7). Changes to that branch need special approval.
+We have forked for MSBuild 16.8 in the branch [`vs16.8`](https://github.com/Microsoft/msbuild/tree/vs16.8). Changes to that branch need special approval.
+
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.8)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.8)
+
+MSBuild 16.7 builds from the branch [`vs16.7`](https://github.com/Microsoft/msbuild/tree/vs16.7). Only high-priority bugfixes will be considered for servicing 16.7.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.7)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.7)
 
@@ -53,10 +57,6 @@ MSBuild can be run on Unix systems that support .NET Core. Set-up instructions c
 
 You can turn on localized builds via the `/p:LocalizedBuild=true` command line argument. For more information on localized builds and how to make contributions to MSBuild's translations, see our [localization documentation](documentation/wiki/Localization.md)
 
-## How to Engage, Contribute and Provide Feedback
-
-This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.
-
 #### Getting Started
 
 Before you contribute, please read through the contributing and developer guides to get an idea of what kinds of pull requests we accept.
diff --git a/documentation/Deploy-MSBuild.md b/documentation/Deploy-MSBuild.md
new file mode 100644
index 00000000000..80e1e7d2b84
--- /dev/null
+++ b/documentation/Deploy-MSBuild.md
@@ -0,0 +1,24 @@
+# Deploying Just-Built MSBuild
+
+## Visual Studio
+
+[Deploy-MSBuild](https://github.com/dotnet/msbuild/blob/deploy-msbuild/scripts/Deploy-MSBuild.ps1) is a way to conveniently take private bits and install them into Visual Studio (VS) for testing. To use it:
+
+- If you haven't already, clone [MSBuild](https://github.com/dotnet/msbuild) and make the changes you want.
+- Build MSBuild with the changes you want using `build.cmd /p:CreateBootstrap=true`.
+- In an administrator powershell window, navigate to the msbuild folder.
+- Run `scripts\Deploy-MSBuild.ps1 -destination {destination} -configuration {configuration}`.
+  - Specify the Bin folder of MSBuild in your VS install as the destination. This is somewhere like `"C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin"`.
+  - Make sure the `{configuration}` you pass to the deploy script matches the one you gave to `build.cmd` (this is `Debug` by default).
+
+The Deploy-MSBuild script creates backups of the relevant MSBuild binaries, then copies the new binaries in their place.
+
+⚠ CAUTION: If you overwrite the MSBuild in Visual Studio you can break Visual Studio. That in turn can prevent you from building MSBuild to fix your bug! The deploy script makes backups by default which you may need to manually copy back over.
+
+### Crossing machines
+
+If you cannot build or cannot deploy MSBuild on the same machine on which you wish to use the updated version of VS, build and deploy to an empty folder instead. Then, manually make a backup of the files in that folder and overwrite them in the VS install of choice.
+
+## .NET (Core) SDK
+
+Deploy-MSBuild can also patch a .NET (Core) SDK installation. Pass the `-runtime Core` argument to `Deploy-MSBuild.ps1` to ensure that it selects .NET Core MSBuild.
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index a95842eb107..f464ca17374 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -54,9 +54,13 @@ These targets are all defined in `Microsoft.Common.targets` and are defined in M
 If implementing a project with an “outer” (determine what properties to pass to the real build) and “inner” (fully specified) build, only `GetTargetFrameworkProperties` is required in the “outer” build. The other targets listed can be “inner” build only.
 
 * `GetTargetFrameworks` tells referencing projects what options are available to the build.
-  * It returns an item with metadata `TargetFrameworks` indicating what TargetFrameworks are available in the project, as well as boolean metadata `HasSingleTargetFramework` and `IsRidAgnostic`.
+  * It returns an item with the following metadata:
+    * `TargetFrameworks` indicating what TargetFrameworks are available in the project
+    * `TargetFrameworkMonikers` and `TargetPlatformMonikers` indicating what framework / platform the `TargetFrameworks` map to.  This is to support implicitly setting the target platform version (for example inferring that `net5.0-windows` means the same as `net5.0-windows7.0`) as well as treating the `TargetFramework` values [as aliases](https://github.com/NuGet/Home/issues/5154)
+    * Boolean metadata for `HasSingleTargetFramework` and `IsRidAgnostic`.
+  * The `GetReferenceNearestTargetFrameworkTask` (provided by NuGet) is responsible for selecting the best matching `TargetFramework` of the referenced project
   * This target is _optional_. If not present, the reference will be built with no additional properties.
-  * **New** in MSBuild 15.5.
+  * **New** in MSBuild 15.5.  (`TargetFrameworkMonikers` and `TargetPlatformMonikers` metadata is new in MSBuild 16.8)
 * `GetTargetFrameworkProperties` determines what properties should be passed to the “main” target for a given `ReferringTargetFramework`.
   * **Deprecated** in MSBuild 15.5.
   * New for MSBuild 15/Visual Studio 2017. Supports the cross-targeting feature allowing a project to have multiple `TargetFrameworks`.
diff --git a/documentation/specs/static-graph.md b/documentation/specs/static-graph.md
index 8b899667790..240db807df2 100644
--- a/documentation/specs/static-graph.md
+++ b/documentation/specs/static-graph.md
@@ -1,6 +1,13 @@
+# Static Graph
+
 - [Static Graph](#static-graph)
-  - [Overview](#overview)
-    - [Motivations](#motivations)
+  - [What is static graph for?](#what-is-static-graph-for)
+    - [Weakness of the old model: project-level scheduling](#weakness-of-the-old-model-project-level-scheduling)
+    - [Weakness of the old model: incrementality](#weakness-of-the-old-model-incrementality)
+    - [Weakness of the old model: caching and distributability](#weakness-of-the-old-model-caching-and-distributability)
+  - [What is static graph?](#what-is-static-graph)
+  - [Design documentation](#design-documentation)
+    - [Design goals](#design-goals)
   - [Project Graph](#project-graph)
     - [Build dimensions](#build-dimensions)
       - [Multitargeting](#multitargeting)
@@ -19,12 +26,83 @@
     - [Detours](#detours)
     - [Isolation requirement](#isolation-requirement)
     - [Tool servers](#tool-servers)
+  - [Examples](#examples)
 
-# Static Graph
+## What is static graph for?
+
+As a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent. MSBuild's static graph features are intended to ameliorate these weaknesses while remaining as compatible as possible with existing projects and SDKs.
+
+MSBuild projects can refer to other projects by using the `MSBuild` task to execute targets in another project and return values. In `Microsoft.Common.targets`, `ProjectReference` items are transformed into `MSBuild` task executions in order to provide a user-friendly interface: "reference the output of these projects".
+
+### Weakness of the old model: project-level scheduling
+
+Because references to other projects aren't known until a target in the referencing project calls the `MSBuild` task, the MSBuild engine cannot start working on building referenced projects until the referencing project yields. For example, if project `A` depended on `B`, `C`, and `D` and was being built with more-than-3 way parallelism, an ideal build would run `B`, `C`, and `D` in parallel with the parts of `A` that could execute before the references were available.
+
+Today, the order of operations of this build are:
+
+1. `A` completes evaluation and starts building, doing isolated work until it gets to `ResolveProjectReferences`.
+1. In parallel, `B`, `C`, and `D` run the requested targets.
+1. `A` resumes building and completes.
+
+With graph-aware scheduling, this becomes:
+
+1. `A`, `B`, `C`, and `D` evaluate in parallel.
+1. `B`, `C`, and `D` build to completion in parallel.
+1. `A` builds, and instantly gets cached results for the `MSBuild` task calls in `ResolveProjectReferences`
+
+### Weakness of the old model: incrementality
+
+[Incremental build](https://docs.microsoft.com/visualstudio/msbuild/incremental-builds) (that is, "redo only the parts of the build that would produce different outputs compared to the last build") is the most powerful tool to reduce build times and increase developer inner-loop speed.
+
+MSBuild supports incremental builds by allowing a target to be skipped if the target's outputs are up to date with its inputs. This allows tools like the compiler to be skipped when possible. But since the incrementality is at the target level, MSBuild must fully evaluate the project and walk through all targets, running those that are out of date or that don't specify inputs and outputs.
+
+Consider a simple solution with a library and an application that depends on the library. Suppose you build, then make a change in the application's source code, then build again.
+
+The second build will:
+
+1. Build the library project, skipping all targets that define inputs and outputs.
+1. Build the application project.
+
+But using higher-level knowledge, we can see a more-optimal build:
+
+1. Skip everything involving the library project, because _none_ of its inputs have changed.
+1. Build only the application project.
+
+Visual Studio offers a ["fast up-to-date check"](https://github.com/dotnet/project-system/blob/cd275918ef9f181f6efab96715a91db7aabec832/docs/up-to-date-check.md) system that gets closer to the latter, but MSBuild itself does not.
+
+### Weakness of the old model: caching and distributability
+
+For very large builds, including many Microsoft products, the fact that MSBuild can build in parallel only on a single machine is a major impediment, even if incrementality is addressed.
+
+Ideally, a build could span multiple computers, and each could use results generated on another machine as inputs to its own build projects. In addition, if all of a project's inputs remain unchanged, the system would ideally reuse the outputs of the project, even if they were built long ago on another computer.
+
+Microsoft has an internal build system, [CloudBuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), that supports this and has proven that it is effective, but is heuristic-based and requires maintenance.
+
+MSBuild static graph features make it easier to implement a system like CloudBuild by building operations like graph construction and output caching into MSBuild itself.
+
+## What is static graph?
+
+MSBuild's static graph extends the MSBuild engine and APIs with new functionality to improve on these weaknesses:
+
+- The ability to [construct a directed acyclic graph of MSBuild projects](#project-graph) given an entry point (solution or project).
+- The ability to consider that graph when scheduling projects for build.
+- The ability to cache MSBuild's internal build results (metadata about outputs, not the outputs themselves) across build invocations.
+- The ability to [enforce restrictions on builds](#isolated-builds) to ensure that the graph is correct and complete.
+
+Static graph functionality can be used in three ways:
+
+- On the command line with `-graph` (and equivalent API).
+  - This gets the scheduling improvements for well-specified projects, but allows underspecified projects to complete without error.
+- On the command line with `-graph -isolate` (and equivalent API).
+  - This gets the scheduling improvements and also enforces that the graph is correct and complete. In this mode, MSBuild will produce an error if there is an `MSBuild` task invocation that was not known to the graph ahead of time.
+- As part of a higher-order build system that uses [single project isolated builds](#single-project-isolated-builds) to provide caching and/or distribution on top of the built-in functionality. The only known implementation of this system is Microsoft-internal currently.
+
+"Correct and complete" here means that the static graph can be used to accurately predict all targets that need to be built for all projects in the graph, and all of the references between projects. This is required for the higher-order build system scenario, because an unknown reference couldn't be satisfied at runtime (as it is in regular MSBuild and `-graph` with no `-isolate` scenarios).
 
-## Overview
+## Design documentation
+
+### Design goals
 
-### Motivations
 - Stock projects can build with "project-level build" and if clean onboard to MS internal build engines with cache/distribution
 - Stock projects will be "project-level build" clean.
 - Add determinism to MSBuild w.r.t. project dependencies. Today MSBuild discovers projects just in time, as it finds MSBuild tasks. This means there’s no guarantee that the same graph is produced two executions in a row, other than hopefully sane project files. With the static graph, you’d know the shape of the build graph before the build starts.
@@ -76,10 +154,10 @@ Multitargeting supporting SDKs MUST implement the following properties and seman
 - Node edges
   - When project A references multitargeting project B, and B is identified as an outer build, the graph node for project A will reference both the outer build of B, and all the inner builds of B. The edges to the inner builds are speculative, as at build time only one inner build gets referenced. However, the graph cannot know at evaluation time which inner build will get chosen.
   - When multitargeting project B is a root, then the outer build node for B will reference the inner builds of B.
-  - For multitargeting projects, the `ProjectReference` item gets applied only to inner builds. An outer build cannot have its own distinct `ProjectReference`s, it is the inner builds that reference other project files, not the outer build. This constraint might get relaxed in the future via additional configuration, to allow outer build specific references. 
+  - For multitargeting projects, the `ProjectReference` item gets applied only to inner builds. An outer build cannot have its own distinct `ProjectReference`s, it is the inner builds that reference other project files, not the outer build. This constraint might get relaxed in the future via additional configuration, to allow outer build specific references.
 
 These specific rules represent the minimal rules required to represent multitargeting in `Microsoft.Net.Sdk`. As we adopt SDKs whose multitargeting complexity that cannot be expressed with the above rules, we'll extend the rules.
-For example, `InnerBuildProperty` could become `InnerBuildProperties` for SDKs where there's multiple multitargeting global properties. 
+For example, `InnerBuildProperty` could become `InnerBuildProperties` for SDKs where there's multiple multitargeting global properties.
 
 For example, here is a trimmed down `Microsoft.Net.Sdk` multitargeting project:
 ```xml
@@ -315,7 +393,7 @@ These incremental builds can even be extended to multiple projects by keeping a
 <!-- workflow -->
 Single project builds can be achieved by providing MSBuild with input and output cache files.
 
-The input cache files contain the cached results of all of the current project's references. This way, when the current project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. The engine, instead of executing these tasks, will serve them from the provided input caches. 
+The input cache files contain the cached results of all of the current project's references. This way, when the current project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. The engine, instead of executing these tasks, will serve them from the provided input caches.
 
 The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.
 The output cache file can be ommited in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.
@@ -345,7 +423,7 @@ Output cache file constraints:
 
 #### APIs
 Caches are provided via [BuildParameters](https://github.com/Microsoft/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). They are applied in `BuildManager.BeginBuild`
-#### Command line 
+#### Command line
 Caches are provided to MSBuild.exe via the multi value `/inputResultsCaches` and the single value `/outputResultsCache`.
 
 ## I/O Tracking
@@ -381,3 +459,78 @@ To support this scenario, a new MSBuild Task API could be introduced which allow
 Similarly for a theoretical server mode for MSBuild, MSBuild would need to report its own I/O rather than the higher-order build engine detouring the process externally. For example, if the higher-order build engine connected to an existing running MSBuild process to make build requests, it could not detour that process and so MSBuild would need to report all I/O done as part of a particular build request.
 
 **OPEN ISSUE:** As described above in an open issue, tool servers are the only scenario which would not be supportable by just externally detouring the MSBuild process. The amount of investment required to enable tool servers is quite high and spans across multiple codebases: MSBuild needs to detour itself, MSBuild need to expose a new Tasks API, the `Csc` task needs to opt into that API, and the higher-order build engine needs to opt-in to MSBuild reporting its own I/O, as well as detecting that the feature is supported in the version of MSBuild it's using. Tool servers may add substantial performance gain, but the investment is also substantial.
+
+## Examples
+
+To illustrate the difference between `-graph` and `-graph -isolate`, consider these two projects, which are minimal except for a new target in the referenced project that is consumed in the referencing project.
+
+`Referenced\Referenced.csproj`:
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <PropertyGroup>
+    <TargetFramework>netcoreapp3.1</TargetFramework>
+    <UnusualOutput>Configuration\Unusual.txt</UnusualOutput>
+  </PropertyGroup>
+
+  <Target Name="UnusualThing" Returns="$(UnusualOutput)" />
+</Project>
+```
+
+`Referencing\Referencing.csproj`:
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <PropertyGroup>
+    <TargetFramework>netcoreapp3.1</TargetFramework>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <ProjectReference Include="..\Referenced\Referenced.csproj" />
+  </ItemGroup>
+
+  <Target Name="GetUnusualThing" BeforeTargets="BeforeBuild">
+    <MSBuild Projects="..\Referenced\Referenced.csproj"
+             Targets="UnusualThing">
+      <Output TaskParameter="TargetOutputs"
+              ItemName="Content" />
+    </MSBuild>
+  </Target>
+</Project>
+```
+
+This project can successfully build with `-graph`
+
+```sh-session
+$ dotnet msbuild Referencing\Referencing.csproj -graph
+"Static graph loaded in 0.253 seconds: 2 nodes, 1 edges"
+  Referenced -> S:\Referenced\bin\Debug\netcoreapp3.1\Referenced.dll
+  Referencing -> S:\Referencing\bin\Debug\netcoreapp3.1\Referencing.dll
+```
+
+But fails with `-graph -isolate`
+
+```sh-session
+$ dotnet msbuild Referencing\Referencing.csproj -graph -isolate
+"Static graph loaded in 0.255 seconds: 2 nodes, 1 edges"
+  Referenced -> S:\Referenced\bin\Debug\netcoreapp3.1\Referenced.dll
+S:\Referencing\Referencing.csproj(12,5): error : MSB4252: Project "S:\Referencing\Referencing.csproj" with global properties
+S:\Referencing\Referencing.csproj(12,5): error :     (IsGraphBuild=true)
+S:\Referencing\Referencing.csproj(12,5): error :     is building project "S:\Referenced\Referenced.csproj" with global properties
+S:\Referencing\Referencing.csproj(12,5): error :     (IsGraphBuild=true)
+S:\Referencing\Referencing.csproj(12,5): error :     with the (UnusualThing) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+S:\Referencing\Referencing.csproj(12,5): error :     - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "S:\Referencing\Referencing.csproj"
+S:\Referencing\Referencing.csproj(12,5): error :     - the reference was called with global properties that do not match the static graph inferred nodes
+S:\Referencing\Referencing.csproj(12,5): error :     - the reference was not explicitly specified as a ProjectReference item in project "S:\Referencing\Referencing.csproj"
+S:\Referencing\Referencing.csproj(12,5): error :
+```
+
+This part of the error is the problem here:
+
+> the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "S:\Referencing\Referencing.csproj"
+
+This is unacceptable in an isolated build because it means that the cached outputs of `Referenced.csproj` will be incomplete: they won't have the results of the `GetUnusualThing` target, because it's nonstandandard (and thus not one of the "well understood to be called on `ProjectReference`s targets that are handled by default).
+
+TODO: write docs for SDK authors/build engineers on how to teach the graph about this sort of thing.
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
index 398d4d1780f..f269670e0ef 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
@@ -44,4 +44,4 @@ To build projects using the MSBuild binaries from the repository, you first need
 
 Now, just point `dotnet ./artifacts/bin/bootstrap/netcoreapp2.1/MSBuild/MSBuild.dll` at a project file.
 
-Alternatively, if you want to test the msbuild binaries in a more realistic environment, you can overwrite the dotnet CLI msbuild binaries (found under a path like `~/dotnet/sdk/3.0.100-alpha1-009428/`) with the msbuild binaries from the above bootstrap directory. You might have to kill existing `dotnet` processes before doing this. Then, (using the previous dotnet example directory) just point `~/dotnet/dotnet build` at a project file.
+Alternatively, if you want to test the msbuild binaries in a more realistic environment, you can overwrite the dotnet CLI msbuild binaries (found under a path like `~/dotnet/sdk/3.0.100-alpha1-009428/`) with the just-built MSBuild . You might have to kill existing `dotnet` processes before doing this. You can use [`Deploy-MSBuild.ps1 -runtime Core`](../Deploy-MSBuild.md#.NET-(Core)-SDK) to do the copy. Then, (using the previous dotnet example directory) just point `~/dotnet/dotnet build` at a project file.
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
index 625a45a26bf..40caef7e8f9 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
@@ -48,3 +48,7 @@ dependencies (Roslyn compilers, NuGet, etc.) from packages or from your local ma
 from Visual Studio). To produce a bootstrap build, run `.\build.cmd /p:CreateBootstrap=true` from the root of your enlistment.
 
 Now, just point `artifacts\bin\bootstrap\net472\MSBuild\Current\Bin\MSBuild.exe` at a project file.
+
+### Patching Visual Studio
+
+Sometimes it's useful to patch your copy of Visual Studio. You can use the [Deploy-MSBuild script](../Deploy-MSBuild.md) for that.
diff --git a/documentation/wiki/ChangeWaves-Dev.md b/documentation/wiki/ChangeWaves-Dev.md
new file mode 100644
index 00000000000..66d80097213
--- /dev/null
+++ b/documentation/wiki/ChangeWaves-Dev.md
@@ -0,0 +1,96 @@
+⚠ This doc is intended for internal teams.
+
+# What are Change Waves?
+A Change Wave is a set of risky features developed under the same opt-out flag. The purpose of this is to warn developers of risky changes that will become standard functionality down the line. If there's something we think is worth the risk, we found that Change Waves were a good middle ground between making necessary changes and warning customers of what will soon be permanent.
+
+## Why Opt-Out vs. Opt-In?
+Opt-out is a better approach for us because we'd likely get limited feedback when a feature impacts customer builds. When a feature does impact a customer negatively, it's a quick switch to disable and allows time to adapt. The key aspect to Change Waves is that it smooths the transition for customers adapting to risky changes that the MSBuild team feels strongly enough to take.
+
+## How do They Work?
+The opt-out comes in the form of setting the environment variable `MSBuildDisableFeaturesFromVersion` to the Change Wave (or version) that contains the feature you want **disabled**. This version happens to be the version of MSBuild that the features were developed for. See the mapping of change waves to features below.
+
+## Choosing a Change Wave for a New Feature
+This is determined on a case by case basis and should be discussed with the MSBuild team. A safe bet would be to check our [currently active Change Waves](ChangeWaves.md#change-waves-&-associated-features) and pick the version after the latest MSBuild version. This version corresponds to the latest version of Visual Studio.
+
+# Developing With Change Waves in Mind
+For the purpose of providing an example, the rest of this document assumes we're developing a feature for MSBuild version **17.4**.
+
+The Process:
+1. Develop your feature.
+2. [Create the Change Wave](#creating-a-change-wave) (if necessary)
+3. [Condition your feature on that Change Wave](#condition-your-feature-on-a-change-wave)
+4. [Test your feature](#test-your-feature)
+5. [Document it](ChangeWaves.md#change-wave-features)
+6. [Delete the wave as it cycles out](#change-wave-'end-of-lifespan'-procedure)
+
+## Creating a Change Wave
+1. In the `Microsoft.Build` project, open `SharedUtilities\ChangeWaves.cs`.
+2. Add a const string to identify the new wave, following the format:
+```c#
+public const string Wave17_4 = "17.4";
+```
+3. You may need to delete the lowest wave as new waves get added.
+4. Update the AllWaves array appropriately.
+```c#
+public static readonly string[] AllWaves = { Wave16_10, Wave17_0, Wave17_4 };
+```
+
+## Condition Your Feature On A Change Wave
+Surround your feature with the following:
+```c#
+    // If you pass an incorrectly formatted change wave, this will throw.
+    // Use the const Version that was created in the previous step.
+    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+    {
+        <your feature>
+    }
+```
+
+If you need to condition a Task or Target, use the built in `AreFeaturesEnabled` function.
+```xml
+<Target Name="SomeRiskyChange" Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))"">
+<!-- Where '17.4' is the change wave assigned to your feature. -->
+```
+
+## Test Your Feature
+Create tests as you normally would. Include one test with environment variable `MSBuildDisableFeaturesFromVersion` set to `ChangeWaves.Wave17_4`. Set this like so:
+```c#
+TestEnvironment env = TestEnvironment.Create()
+
+env.SetChangeWave(ChangeWaves.Wave17_4);
+```
+When the TestEnvironment is disposed, it handles special logic to properly reset Change Waves for future tests.
+
+**Important!** If you need to build a project to test your feature (say, for tasks or targets), build via `ProjectCollection` in your test.
+
+Example:
+```c#
+using (TestEnvironment env = TestEnvironment.Create())
+{
+    // Important: use the constant here
+    env.SetChangeWave(ChangeWaves.Wave17_4);
+
+    string projectFile = @"
+        <Project>
+            <Target Name='HelloWorld' Condition=""$([MSBuild]::AreFeaturesEnabled('17.4'))"">
+                <Message Text='Hello World!'/>
+            </Target>
+        </Project>";
+
+    TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
+
+    ProjectCollection collection = new ProjectCollection();
+    MockLogger log = new MockLogger();
+    collection.RegisterLogger(log);
+
+    collection.LoadProject(file.Path).Build().ShouldBeTrue();
+    log.AssertLogContains("Hello World!");
+}
+```
+
+## Change Wave 'End-of-Lifespan' Procedure
+These features will eventually become standard functionality. When a change wave rotates out, do the following:
+1. Start by deleting the constant `Wave17_4` that was created in [Creating a Change Wave](#creating-a-change-wave).
+2. Remove `ChangeWave.AreFeaturesEnabled` or `[MSBuild]::AreFeaturesEnabled` conditions surrounding features that were assigned that change wave.
+3. Remove tests associated with ensuring features would not run if this wave were set.
+4. Clear all other issues that arose from deleting the constant.
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
new file mode 100644
index 00000000000..46d1d61b4e5
--- /dev/null
+++ b/documentation/wiki/ChangeWaves.md
@@ -0,0 +1,30 @@
+# What are Change Waves?
+A Change Wave is a set of risky features developed under the same opt-out flag. The purpose of this is to warn developers of "risky" changes that will become standard functionality down the line. If there's something we think is worth the risk, we found that Change Waves were a good middle ground between making necessary changes and warning customers of what will soon be permanent.
+
+## Why Opt-Out vs. Opt-In?
+Opt-out is a better approach for us because we'd likely get limited feedback when a feature impacts customer builds. When a feature does impact a customer negatively, it's a quick switch to disable and allows time to adapt. The key aspect to Change Waves is that it smooths the transition for customers adapting to risky changes that the MSBuild team feels strongly enough to take.
+
+## How do they work?
+The opt-out comes in the form of setting the environment variable `MSBuildDisableFeaturesFromVersion` to the Change Wave (or version) that contains the feature you want **disabled**. This version happens to be the version of MSBuild that the features were developed for. See the mapping of change waves to features below.
+
+## MSBuildDisableFeaturesFromVersion Values & Outcomes
+| `MSBuildDisableFeaturesFromVersion` Value                         | Result        | Receive Warning? |
+| :-------------                                                    | :----------   | :----------: |
+| Unset                                                             | All Change Waves will be enabled, meaning all features behind each Change Wave will be enabled.               | No   |
+| Any valid & current Change Wave (Ex: `16.8`)                      | All features behind Change Wave `16.8` and higher will be disabled.                                           | No   |
+| Invalid Value (Ex: `16.9` when valid waves are `16.8` and `16.10`)| Default to the closest valid value (ascending). Ex: Setting `16.9` will default you to `16.10`.               | No   |
+| Out of Rotation (Ex: `17.1` when the highest wave is `17.0`)      | Clamp to the closest valid value. Ex: `17.1` clamps to `17.0`, and `16.5` clamps to `16.8`                    | Yes  |
+| Invalid Format (Ex: `16x8`, `17_0`, `garbage`)                    | All Change Waves will be enabled, meaning all features behind each Change Wave will be enabled.               | Yes  |
+
+# Change Waves & Associated Features
+
+## Current Rotation of Change Waves
+### 16.8
+- [Enable NoWarn](https://github.com/dotnet/msbuild/pull/5671)
+- [Truncate Target/Task skipped log messages to 1024 chars](https://github.com/dotnet/msbuild/pull/5553)
+- [Don't expand full drive globs with false condition](https://github.com/dotnet/msbuild/pull/5669)
+### 16.10
+- [Error when a property expansion in a condition has whitespace](https://github.com/dotnet/msbuild/pull/5672)
+### 17.0
+
+## Change Waves No Longer In Rotation
diff --git a/documentation/wiki/Providing-Binary-Logs.md b/documentation/wiki/Providing-Binary-Logs.md
index e2aecf85c6b..b9423d5b271 100644
--- a/documentation/wiki/Providing-Binary-Logs.md
+++ b/documentation/wiki/Providing-Binary-Logs.md
@@ -9,3 +9,6 @@ However, you should be aware what type of information is captured in the binary
 You can create a binary log by passing the `-bl` parameter to MSBuild.  You can explore the contents of the generated .binlog file using [MSBuild Structured Log Viewer](http://msbuildlog.com/).
 
 [More details about binary logs](Binary-Log.md)
+
+## Capturing Binary Logs Through Visual Studio
+See [this guide](https://github.com/dotnet/project-system-tools) in the Project System Tools repo for capturing binlogs through Visual Studio.
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index 5e1479fa0c9..b379b227dd6 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -160,6 +160,9 @@
           DestinationFiles="@(FreshlyBuiltRootProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\%(Filename)%(Extension)')" />
     <Copy SourceFiles="@(FreshlyBuiltProjects)"
           DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\%(RecursiveDir)%(Filename)%(Extension)')" />
+    <Copy SourceFiles="@(FreshlyBuiltProjects)"
+          DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\%(RecursiveDir)%(Filename)%(Extension)')" />
+
   </Target>
 
   <Target Name="BootstrapNetCore" DependsOnTargets="CleanBootstrapFolder">
diff --git a/eng/Packages.props b/eng/Packages.props
index a7844e3b8a1..ebd0d0e551f 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -1,17 +1,9 @@
 <Project>
-
-  <PropertyGroup>
-      <NuGetPackageVersion>5.7.0-rtm.6710</NuGetPackageVersion>
-      <NuGetBuildTasksVersion Condition="'$(NuGetBuildTasksVersion)' == ''">$(NuGetPackageVersion)</NuGetBuildTasksVersion>
-      <NuGetCommandsVersion Condition="'$(NuGetCommandsVersion)' == ''">$(NuGetPackageVersion)</NuGetCommandsVersion>
-      <NuGetProtocolVersion Condition="'$(NuGetProtocolVersion)' == ''">$(NuGetPackageVersion)</NuGetProtocolVersion>
-  </PropertyGroup>
-
   <ItemGroup>
     <PackageReference Update="jnm2.ReferenceAssemblies.net35" Version="1.0.1" />
     <PackageReference Update="LargeAddressAware" Version="1.0.3" />
     <PackageReference Update="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
-    <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="3.0.0-beta1-61516-01" />
+    <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
     <PackageReference Update="Microsoft.DotNet.BuildTools.GenAPI" Version="2.1.0-prerelease-02404-02" />
     <PackageReference Update="Microsoft.Extensions.DependencyModel" Version="2.1.0" />
     <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
@@ -25,12 +17,12 @@
     <PackageReference Update="SourceLink.Create.CommandLine" Version="2.1.2" />
     <PackageReference Update="System.CodeDom" Version="4.4.0" />
     <PackageReference Update="System.Collections.Concurrent" Version="4.3.0" />
-    <PackageReference Update="System.Collections.Immutable" Version="1.5.0" />
+    <PackageReference Update="System.Collections.Immutable" Version="5.0.0" />
     <PackageReference Update="System.Diagnostics.TraceSource" Version="4.0.0" />
     <PackageReference Update="System.IO.Compression" Version="4.3.0" />
     <PackageReference Update="System.IO.FileSystem.Primitives" Version="4.3.0" />
     <PackageReference Update="System.Linq.Parallel" Version="4.0.1" />
-    <PackageReference Update="System.Memory" Version="4.5.3" />
+    <PackageReference Update="System.Memory" Version="4.5.4" />
     <PackageReference Update="System.Net.Http" Version="4.3.4" />
     <PackageReference Update="System.Reflection.Metadata" Version="1.6.0" />
     <PackageReference Update="System.Reflection.TypeExtensions" Version="4.1.0" />
diff --git a/eng/Signing.props b/eng/Signing.props
index 83946d7c6e5..8969d795fee 100644
--- a/eng/Signing.props
+++ b/eng/Signing.props
@@ -1,5 +1,5 @@
 <Project>
     <ItemGroup>
-		<ItemsToSign Include="$(VisualStudioSetupOutputPath)DevDivPackages\*.nupkg" />
+		<ItemsToSign Include="$(VisualStudioSetupInsertionPath)Microsoft.Build.UnGAC.exe" />
 	</ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index c2b289fb377..32ddd405d96 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,9 +1,17 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20365.6">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20580.3">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>7cc59275eade471e29b88a797275818b0d513d0f</Sha>
+      <Sha>7ee8c2b620e66b3762d7a5a688dee8238770c86a</Sha>
+    </Dependency>
+    <Dependency Name="NuGet.Build.Tasks" Version="5.9.0-preview.2.6967">
+      <Uri>https://github.com/NuGet/NuGet.Client</Uri>
+      <Sha>a4c9d63bf942f1df1ba9486a87bad2e4b6888488</Sha>
+    </Dependency>
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="">
+      <Uri>https://github.com/dotnet/roslyn</Uri>
+      <Sha />
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index dc29455da17..a3a255f0129 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -15,7 +15,7 @@
     <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
   </PropertyGroup>
   <PropertyGroup>
-    <VersionPrefix>16.8.0</VersionPrefix>
+    <VersionPrefix>16.9.0</VersionPrefix>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -37,6 +37,8 @@
   <!-- Toolset Dependencies -->
   <PropertyGroup>
     <DotNetCliVersion>3.1.100</DotNetCliVersion>
+    <MicrosoftNetCompilersToolsetVersion>3.3.1-beta3-final</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>5.9.0-preview.2.6967</NuGetBuildTasksVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/common/SetupNugetSources.ps1 b/eng/common/SetupNugetSources.ps1
index a8b5280d9dd..83218ad7e72 100644
--- a/eng/common/SetupNugetSources.ps1
+++ b/eng/common/SetupNugetSources.ps1
@@ -11,6 +11,8 @@
 # See example YAML call for this script below. Note the use of the variable `$(dn-bot-dnceng-artifact-feeds-rw)`
 # from the AzureDevOps-Artifact-Feeds-Pats variable group.
 #
+# Any disabledPackageSources entries which start with "darc-int" will be re-enabled as part of this script executing
+#
 #  - task: PowerShell@2
 #    displayName: Setup Private Feeds Credentials
 #    condition: eq(variables['Agent.OS'], 'Windows_NT')
@@ -94,6 +96,15 @@ function InsertMaestroPrivateFeedCredentials($Sources, $Creds, $Username, $Passw
     }
 }
 
+function EnablePrivatePackageSources($DisabledPackageSources) {
+    $maestroPrivateSources = $DisabledPackageSources.SelectNodes("add[contains(@key,'darc-int')]")
+    ForEach ($DisabledPackageSource in $maestroPrivateSources) {
+        Write-Host "`tEnsuring private source '$($DisabledPackageSource.key)' is enabled by deleting it from disabledPackageSource"
+        # Due to https://github.com/NuGet/Home/issues/10291, we must actually remove the disabled entries
+        $DisabledPackageSources.RemoveChild($DisabledPackageSource)
+    }
+}
+
 if (!(Test-Path $ConfigFile -PathType Leaf)) {
   Write-PipelineTelemetryError -Category 'Build' -Message "Eng/common/SetupNugetSources.ps1 returned a non-zero exit code. Couldn't find the NuGet config file: $ConfigFile"
   ExitWithExitCode 1
@@ -123,6 +134,13 @@ if ($creds -eq $null) {
     $doc.DocumentElement.AppendChild($creds) | Out-Null
 }
 
+# Check for disabledPackageSources; we'll enable any darc-int ones we find there
+$disabledSources = $doc.DocumentElement.SelectSingleNode("disabledPackageSources")
+if ($disabledSources -ne $null) {
+    Write-Host "Checking for any darc-int disabled package sources in the disabledPackageSources node"
+    EnablePrivatePackageSources -DisabledPackageSources $disabledSources
+}
+
 $userName = "dn-bot"
 
 # Insert credential nodes for Maestro's private feeds
diff --git a/eng/common/SetupNugetSources.sh b/eng/common/SetupNugetSources.sh
index 4ebb1e5a440..751863d5006 100644
--- a/eng/common/SetupNugetSources.sh
+++ b/eng/common/SetupNugetSources.sh
@@ -13,6 +13,8 @@
 # See example YAML call for this script below. Note the use of the variable `$(dn-bot-dnceng-artifact-feeds-rw)`
 # from the AzureDevOps-Artifact-Feeds-Pats variable group.
 #
+# Any disabledPackageSources entries which start with "darc-int" will be re-enabled as part of this script executing.
+#
 #  - task: Bash@3
 #    displayName: Setup Private Feeds Credentials
 #    inputs:
@@ -63,7 +65,7 @@ if [ "$?" != "0" ]; then
     ConfigNodeHeader="<configuration>"
     PackageSourcesTemplate="${TB}<packageSources>${NL}${TB}</packageSources>"
 
-    sed -i.bak "s|$ConfigNodeHeader|$ConfigNodeHeader${NL}$PackageSourcesTemplate|" NuGet.config
+    sed -i.bak "s|$ConfigNodeHeader|$ConfigNodeHeader${NL}$PackageSourcesTemplate|" $ConfigFile
 fi
 
 # Ensure there is a <packageSourceCredentials>...</packageSourceCredentials> section. 
@@ -74,7 +76,7 @@ if [ "$?" != "0" ]; then
     PackageSourcesNodeFooter="</packageSources>"
     PackageSourceCredentialsTemplate="${TB}<packageSourceCredentials>${NL}${TB}</packageSourceCredentials>"
 
-    sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourcesNodeFooter${NL}$PackageSourceCredentialsTemplate|" NuGet.config
+    sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourcesNodeFooter${NL}$PackageSourceCredentialsTemplate|" $ConfigFile
 fi
 
 PackageSources=()
@@ -146,4 +148,21 @@ for FeedName in ${PackageSources[@]} ; do
 
         sed -i.bak "s|$PackageSourceCredentialsNodeFooter|$NewCredential${NL}$PackageSourceCredentialsNodeFooter|" $ConfigFile
     fi
-done
\ No newline at end of file
+done
+
+# Re-enable any entries in disabledPackageSources where the feed name contains darc-int
+grep -i "<disabledPackageSources>" $ConfigFile
+if [ "$?" == "0" ]; then
+    DisabledDarcIntSources=()
+    echo "Re-enabling any disabled \"darc-int\" package sources in $ConfigFile"
+    DisabledDarcIntSources+=$(grep -oh '"darc-int-[^"]*" value="true"' $ConfigFile  | tr -d '"')
+    for DisabledSourceName in ${DisabledDarcIntSources[@]} ; do
+        if [[ $DisabledSourceName == darc-int* ]]
+            then
+                OldDisableValue="<add key=\"$DisabledSourceName\" value=\"true\" />"
+                NewDisableValue="<!-- Reenabled for build : $DisabledSourceName -->"
+                sed -i.bak "s|$OldDisableValue|$NewDisableValue|" $ConfigFile
+                echo "Neutralized disablePackageSources entry for '$DisabledSourceName'"
+        fi
+    done
+fi
\ No newline at end of file
diff --git a/eng/common/darc-init.sh b/eng/common/darc-init.sh
index 242429bca65..06b65342528 100755
--- a/eng/common/darc-init.sh
+++ b/eng/common/darc-init.sh
@@ -2,8 +2,8 @@
 
 source="${BASH_SOURCE[0]}"
 darcVersion=''
-versionEndpoint="https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16"
-verbosity=m
+versionEndpoint='https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16'
+verbosity='minimal'
 
 while [[ $# > 0 ]]; do
   opt="$(echo "$1" | awk '{print tolower($0)}')"
@@ -20,6 +20,10 @@ while [[ $# > 0 ]]; do
       verbosity=$2
       shift
       ;;
+    --toolpath)
+      toolpath=$2
+      shift
+      ;;
     *)
       echo "Invalid argument: $1"
       usage
@@ -52,17 +56,27 @@ function InstallDarcCli {
   InitializeDotNetCli
   local dotnet_root=$_InitializeDotNetCli
 
-  local uninstall_command=`$dotnet_root/dotnet tool uninstall $darc_cli_package_name -g`
-  local tool_list=$($dotnet_root/dotnet tool list -g)
-  if [[ $tool_list = *$darc_cli_package_name* ]]; then
-    echo $($dotnet_root/dotnet tool uninstall $darc_cli_package_name -g)
+  if [ -z "$toolpath" ]; then
+    local tool_list=$($dotnet_root/dotnet tool list -g)
+    if [[ $tool_list = *$darc_cli_package_name* ]]; then
+      echo $($dotnet_root/dotnet tool uninstall $darc_cli_package_name -g)
+    fi
+  else
+    local tool_list=$($dotnet_root/dotnet tool list --tool-path "$toolpath")
+    if [[ $tool_list = *$darc_cli_package_name* ]]; then
+      echo $($dotnet_root/dotnet tool uninstall $darc_cli_package_name --tool-path "$toolpath")
+    fi
   fi
 
-  local arcadeServicesSource="https://dotnetfeed.blob.core.windows.net/dotnet-core/index.json"
+  local arcadeServicesSource="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json"
 
   echo "Installing Darc CLI version $darcVersion..."
   echo "You may need to restart your command shell if this is the first dotnet tool you have installed."
-  echo $($dotnet_root/dotnet tool install $darc_cli_package_name --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity -g)
+  if [ -z "$toolpath" ]; then
+    echo $($dotnet_root/dotnet tool install $darc_cli_package_name --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity -g)
+  else
+    echo $($dotnet_root/dotnet tool install $darc_cli_package_name --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity --tool-path "$toolpath")
+  fi
 }
 
 InstallDarcCli
diff --git a/eng/common/templates/post-build/post-build.yml b/eng/common/templates/post-build/post-build.yml
index 2d51c1cdbf6..8ad0f9f66c2 100644
--- a/eng/common/templates/post-build/post-build.yml
+++ b/eng/common/templates/post-build/post-build.yml
@@ -367,6 +367,18 @@ stages:
     shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
     symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
 
+- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+  parameters:
+    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+    stageName: 'VS16_9_Publishing'
+    channelName: 'VS 16.9'
+    channelId: 1473
+    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
+    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
+
 - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
   parameters:
     artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index bc228dfdf9f..f50507a06c1 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -329,7 +329,7 @@ function InitializeXCopyMSBuild([string]$packageVersion, [bool]$install) {
     Create-Directory $packageDir
     Write-Host "Downloading $packageName $packageVersion"
     $ProgressPreference = 'SilentlyContinue' # Don't display the console progress UI - it's a huge perf hit
-    Invoke-WebRequest "https://dotnet.myget.org/F/roslyn-tools/api/v2/package/$packageName/$packageVersion/" -OutFile $packagePath
+    Invoke-WebRequest "https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/flat2/$packageName/$packageVersion/$packageName.$packageVersion.nupkg" -OutFile $packagePath
     Unzip $packagePath $packageDir
   }
 
diff --git a/global.json b/global.json
index 1c061d6ea46..f3705522809 100644
--- a/global.json
+++ b/global.json
@@ -12,6 +12,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20365.6"
+    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20580.3"
   }
 }
diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index 4edef43d503..cbc25f139be 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -489,6 +489,18 @@ public GenerateDeploymentManifest() { }
         protected override bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
         protected internal override bool ValidateInputs() { throw null; }
     }
+    public sealed partial class GenerateLauncher : Microsoft.Build.Tasks.TaskExtension
+    {
+        public GenerateLauncher() { }
+        public string AssemblyName { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
+        public string LauncherPath { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem OutputEntryPoint { get { throw null; } set { } }
+        public string OutputPath { get { throw null; } set { } }
+        public string VisualStudioVersion { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public abstract partial class GenerateManifestBase : Microsoft.Build.Utilities.Task
     {
         protected GenerateManifestBase() { }
@@ -497,6 +509,7 @@ protected GenerateManifestBase() { }
         public string Description { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem InputManifest { get { throw null; } set { } }
+        public bool LauncherBasedDeployment { get { throw null; } set { } }
         public int MaxTargetPath { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem OutputManifest { get { throw null; } set { } }
@@ -884,6 +897,8 @@ public ResolveAssemblyReference() { }
         public string AppConfigFile { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
+        public string AssemblyInformationCacheOutputPath { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] AssemblyInformationCachePaths { get { throw null; } set { } }
         public bool AutoUnify { get { throw null; } set { } }
         public string[] CandidateAssemblyFiles { get { throw null; } set { } }
         public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
@@ -999,10 +1014,14 @@ public ResolveKeySource() { }
     public sealed partial class ResolveManifestFiles : Microsoft.Build.Tasks.TaskExtension
     {
         public ResolveManifestFiles() { }
+        public string AssemblyName { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem DeploymentManifestEntryPoint { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] ExtraFiles { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
+        public bool IsSelfContainedPublish { get { throw null; } set { } }
+        public bool IsSingleFilePublish { get { throw null; } set { } }
+        public bool LauncherBasedDeployment { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] ManagedAssemblies { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] NativeAssemblies { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
@@ -1014,9 +1033,11 @@ public ResolveManifestFiles() { }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem[] OutputFiles { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] PublishFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] RuntimePackAssets { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] SatelliteAssemblies { get { throw null; } set { } }
         public bool SigningManifests { get { throw null; } set { } }
         public string TargetCulture { get { throw null; } set { } }
+        public string TargetFrameworkIdentifier { get { throw null; } set { } }
         public string TargetFrameworkVersion { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
@@ -1130,6 +1151,7 @@ public SignFile() { }
         public string CertificateThumbprint { get { throw null; } set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem SigningTarget { get { throw null; } set { } }
+        public string TargetFrameworkIdentifier { get { throw null; } set { } }
         public string TargetFrameworkVersion { get { throw null; } set { } }
         public string TimestampUrl { get { throw null; } set { } }
         public override bool Execute() { throw null; }
@@ -2138,6 +2160,12 @@ public void Clear() { }
         public System.Collections.IEnumerator GetEnumerator() { throw null; }
         public void Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) { }
     }
+    public partial class LauncherBuilder
+    {
+        public LauncherBuilder(string launcherPath) { }
+        public string LauncherPath { get { throw null; } set { } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults Build(string filename, string outputPath) { throw null; }
+    }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
     public abstract partial class Manifest
     {
@@ -2145,6 +2173,8 @@ protected internal Manifest() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity AssemblyIdentity { get { throw null; } set { } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string AssemblyName { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection AssemblyReferences { get { throw null; } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string Description { get { throw null; } set { } }
@@ -2155,6 +2185,8 @@ protected internal Manifest() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public System.IO.Stream InputStream { get { throw null; } set { } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool LauncherBasedDeployment { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection OutputMessages { get { throw null; } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public bool ReadOnly { get { throw null; } set { } }
@@ -2275,6 +2307,7 @@ public static void SignFile(System.Security.Cryptography.X509Certificates.X509Ce
         public static void SignFile(string certPath, System.Security.SecureString certPassword, System.Uri timestampUrl, string path) { }
         public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path) { }
         public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) { }
+        public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier) { }
         public static System.Security.PermissionSet XmlToPermissionSet(System.Xml.XmlElement element) { throw null; }
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index cc3fb5233ef..349308aac70 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -303,6 +303,14 @@ public FindUnderPath() { }
         public bool UpdateToAbsolutePaths { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public sealed partial class FormatUrl : Microsoft.Build.Tasks.TaskExtension
+    {
+        public FormatUrl() { }
+        public string InputUrl { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public string OutputUrl { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public sealed partial class FormatVersion : Microsoft.Build.Tasks.TaskExtension
     {
         public FormatVersion() { }
@@ -375,6 +383,18 @@ public GenerateDeploymentManifest() { }
         protected override bool OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) { throw null; }
         protected internal override bool ValidateInputs() { throw null; }
     }
+    public sealed partial class GenerateLauncher : Microsoft.Build.Tasks.TaskExtension
+    {
+        public GenerateLauncher() { }
+        public string AssemblyName { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
+        public string LauncherPath { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem OutputEntryPoint { get { throw null; } set { } }
+        public string OutputPath { get { throw null; } set { } }
+        public string VisualStudioVersion { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public abstract partial class GenerateManifestBase : Microsoft.Build.Utilities.Task
     {
         protected GenerateManifestBase() { }
@@ -383,6 +403,7 @@ protected GenerateManifestBase() { }
         public string Description { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem InputManifest { get { throw null; } set { } }
+        public bool LauncherBasedDeployment { get { throw null; } set { } }
         public int MaxTargetPath { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem OutputManifest { get { throw null; } set { } }
@@ -621,6 +642,8 @@ public ResolveAssemblyReference() { }
         public string AppConfigFile { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] Assemblies { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
+        public string AssemblyInformationCacheOutputPath { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] AssemblyInformationCachePaths { get { throw null; } set { } }
         public bool AutoUnify { get { throw null; } set { } }
         public string[] CandidateAssemblyFiles { get { throw null; } set { } }
         public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
@@ -736,10 +759,14 @@ public ResolveKeySource() { }
     public sealed partial class ResolveManifestFiles : Microsoft.Build.Tasks.TaskExtension
     {
         public ResolveManifestFiles() { }
+        public string AssemblyName { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem DeploymentManifestEntryPoint { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem EntryPoint { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] ExtraFiles { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] Files { get { throw null; } set { } }
+        public bool IsSelfContainedPublish { get { throw null; } set { } }
+        public bool IsSingleFilePublish { get { throw null; } set { } }
+        public bool LauncherBasedDeployment { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] ManagedAssemblies { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] NativeAssemblies { get { throw null; } set { } }
         [Microsoft.Build.Framework.OutputAttribute]
@@ -751,9 +778,11 @@ public ResolveManifestFiles() { }
         [Microsoft.Build.Framework.OutputAttribute]
         public Microsoft.Build.Framework.ITaskItem[] OutputFiles { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] PublishFiles { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] RuntimePackAssets { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskItem[] SatelliteAssemblies { get { throw null; } set { } }
         public bool SigningManifests { get { throw null; } set { } }
         public string TargetCulture { get { throw null; } set { } }
+        public string TargetFrameworkIdentifier { get { throw null; } set { } }
         public string TargetFrameworkVersion { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
@@ -1765,6 +1794,12 @@ public void Clear() { }
         public System.Collections.IEnumerator GetEnumerator() { throw null; }
         public void Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) { }
     }
+    public partial class LauncherBuilder
+    {
+        public LauncherBuilder(string launcherPath) { }
+        public string LauncherPath { get { throw null; } set { } }
+        public Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults Build(string filename, string outputPath) { throw null; }
+    }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
     public abstract partial class Manifest
     {
@@ -1772,6 +1807,8 @@ protected internal Manifest() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity AssemblyIdentity { get { throw null; } set { } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
+        public string AssemblyName { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection AssemblyReferences { get { throw null; } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public string Description { get { throw null; } set { } }
@@ -1782,6 +1819,8 @@ protected internal Manifest() { }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public System.IO.Stream InputStream { get { throw null; } set { } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
+        public bool LauncherBasedDeployment { get { throw null; } set { } }
+        [System.Xml.Serialization.XmlIgnoreAttribute]
         public Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection OutputMessages { get { throw null; } }
         [System.Xml.Serialization.XmlIgnoreAttribute]
         public bool ReadOnly { get { throw null; } set { } }
@@ -1899,6 +1938,7 @@ public static void SignFile(System.Security.Cryptography.X509Certificates.X509Ce
         public static void SignFile(string certPath, System.Security.SecureString certPassword, System.Uri timestampUrl, string path) { }
         public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path) { }
         public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) { }
+        public static void SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier) { }
     }
     [System.Runtime.InteropServices.ComVisibleAttribute(false)]
     public sealed partial class TrustInfo
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 835cbaf394f..7b5d9ad50bc 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -869,6 +869,7 @@ public partial class EvaluationContext
     {
         internal EvaluationContext() { }
         public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy) { throw null; }
+        public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem) { throw null; }
         public enum SharingPolicy
         {
             Isolated = 1,
@@ -1402,6 +1403,25 @@ public enum TargetResultCode : byte
         Success = (byte)1,
     }
 }
+namespace Microsoft.Build.FileSystem
+{
+    public abstract partial class MSBuildFileSystemBase
+    {
+        protected MSBuildFileSystemBase() { }
+        public abstract bool DirectoryExists(string path);
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
+        public abstract bool FileExists(string path);
+        public abstract bool FileOrDirectoryExists(string path);
+        public abstract System.IO.FileAttributes GetAttributes(string path);
+        public abstract System.IO.Stream GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
+        public abstract System.DateTime GetLastWriteTimeUtc(string path);
+        public abstract System.IO.TextReader ReadFile(string path);
+        public abstract byte[] ReadFileAllBytes(string path);
+        public abstract string ReadFileAllText(string path);
+    }
+}
 namespace Microsoft.Build.Globbing
 {
     public partial class CompositeGlob : Microsoft.Build.Globbing.IMSBuildGlob
@@ -2028,3 +2048,20 @@ public partial struct XmlAttributeLink
         public string Value { get { throw null; } }
     }
 }
+namespace Microsoft.Build.Utilities
+{
+    public partial class ChangeWaves
+    {
+        public static readonly string[] AllWaves;
+        public static readonly System.Version[] AllWavesAsVersion;
+        public const string EnableAllFeatures = "999.999";
+        public const string Wave16_10 = "16.10";
+        public const string Wave16_8 = "16.8";
+        public const string Wave17_0 = "17.0";
+        public ChangeWaves() { }
+        public static string DisabledWave { get { throw null; } set { } }
+        public static bool AreFeaturesEnabled(string wave) { throw null; }
+        public static bool AreFeaturesEnabled(System.Version wave) { throw null; }
+        public static void ResetStateForTests() { }
+    }
+}
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index f659dab2bac..e82b1302b54 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -869,6 +869,7 @@ public partial class EvaluationContext
     {
         internal EvaluationContext() { }
         public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy) { throw null; }
+        public static Microsoft.Build.Evaluation.Context.EvaluationContext Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem) { throw null; }
         public enum SharingPolicy
         {
             Isolated = 1,
@@ -1396,6 +1397,25 @@ public enum TargetResultCode : byte
         Success = (byte)1,
     }
 }
+namespace Microsoft.Build.FileSystem
+{
+    public abstract partial class MSBuildFileSystemBase
+    {
+        protected MSBuildFileSystemBase() { }
+        public abstract bool DirectoryExists(string path);
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
+        public abstract System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern="*", System.IO.SearchOption searchOption=(System.IO.SearchOption)(0));
+        public abstract bool FileExists(string path);
+        public abstract bool FileOrDirectoryExists(string path);
+        public abstract System.IO.FileAttributes GetAttributes(string path);
+        public abstract System.IO.Stream GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
+        public abstract System.DateTime GetLastWriteTimeUtc(string path);
+        public abstract System.IO.TextReader ReadFile(string path);
+        public abstract byte[] ReadFileAllBytes(string path);
+        public abstract string ReadFileAllText(string path);
+    }
+}
 namespace Microsoft.Build.Globbing
 {
     public partial class CompositeGlob : Microsoft.Build.Globbing.IMSBuildGlob
@@ -2022,3 +2042,20 @@ public partial struct XmlAttributeLink
         public string Value { get { throw null; } }
     }
 }
+namespace Microsoft.Build.Utilities
+{
+    public partial class ChangeWaves
+    {
+        public static readonly string[] AllWaves;
+        public static readonly System.Version[] AllWavesAsVersion;
+        public const string EnableAllFeatures = "999.999";
+        public const string Wave16_10 = "16.10";
+        public const string Wave16_8 = "16.8";
+        public const string Wave17_0 = "17.0";
+        public ChangeWaves() { }
+        public static string DisabledWave { get { throw null; } set { } }
+        public static bool AreFeaturesEnabled(string wave) { throw null; }
+        public static bool AreFeaturesEnabled(System.Version wave) { throw null; }
+        public static void ResetStateForTests() { }
+    }
+}
diff --git a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
index 52989661d31..20c6e99646c 100644
--- a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
@@ -3,17 +3,13 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Linq;
-using System.Reflection;
 using System.Text;
 using System.Xml;
 
 using Microsoft.Build.Construction;
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
@@ -3190,9 +3186,7 @@ private static string ComposeExpectedProjectString(string expectedItem)
 </Project>";
             expectedItem = AdjustSpacesForItem(expectedItem);
 
-            expected = ObjectModelHelpers.CleanupFileContents(string.Format(expected, expectedItem));
-
-            return expected;
+            return ObjectModelHelpers.CleanupFileContents(string.Format(expected, expectedItem));
         }
 
         /// <summary>
@@ -3259,18 +3253,17 @@ private static string AdjustSpacesForItem(string expectedItem)
             }
             else
             {
-                sb.AppendLine(itemSpace + splits[0]);
+                sb.Append(itemSpace).AppendLine(splits[0]);
 
                 for (var i = 1; i < splits.Length - 1; i++)
                 {
-                    sb.AppendLine(metadataSpace + splits[i]);
+                    sb.Append(metadataSpace).AppendLine(splits[i]);
                 }
 
-                sb.Append(itemSpace + splits[splits.Length -1]);
+                sb.Append(itemSpace).Append(splits[splits.Length - 1]);
             }
 
-            expectedItem = sb.ToString();
-            return expectedItem;
+            return sb.ToString();
         }
     }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs b/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs
index a9af67129a5..70387ca7c6c 100644
--- a/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ElementLocationPublic_Tests.cs
@@ -2,20 +2,11 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections.Generic;
-using Microsoft.Build.Collections;
 using System;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.UnitTests;
-using Microsoft.Build.Framework;
-using System.Collections;
-using Microsoft.Build.Execution;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Construction;
-using System.Xml;
-using System.IO;
-using System.Linq;
 using System.Reflection;
 using Xunit;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests.Construction
 {
@@ -125,6 +116,8 @@ public void LocationStringsMedley()
 
             string locations = project.Xml.Location.LocationString + "\r\n";
 
+            List<string> attributeLocations = new List<string>(2);
+
             foreach (var element in project.Xml.AllChildren)
             {
                 foreach (var property in element.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance))
@@ -135,7 +128,7 @@ public void LocationStringsMedley()
                         {
                             var values = new List<KeyValuePair<string, ElementLocation>>((ICollection<KeyValuePair<string, ElementLocation>>)property.GetValue(element, null));
 
-                            values.ForEach((value) => locations += value.Key + ":" + value.Value.LocationString + "\r\n");
+                            values.ForEach(value => attributeLocations.Add(value.Key + ":" + value.Value.LocationString));
                         }
                         else
                         {
@@ -194,8 +187,6 @@ public void LocationStringsMedley()
 c:\foo\bar.csproj (23,25)
 c:\foo\bar.csproj (24,32)
 c:\foo\bar.csproj (24,29)
-Text: (26,32)
-Importance: (26,66)
 c:\foo\bar.csproj (26,43)
 c:\foo\bar.csproj (26,25)
 c:\foo\bar.csproj (28,29)
@@ -204,6 +195,9 @@ public void LocationStringsMedley()
 ";
 
             Helpers.VerifyAssertLineByLine(expected, locations);
+
+            // attribute order depends on dictionary internals
+            attributeLocations.ShouldBe(new[] { "Text: (26,32)", "Importance: (26,66)" }, ignoreOrder: true);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.OM.UnitTests/Construction/ProjectChooseElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectChooseElement_Tests.cs
index 35c062c16ed..b94af9ae152 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectChooseElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectChooseElement_Tests.cs
@@ -4,13 +4,11 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
 using System.Text;
 using System.Xml;
 
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Shared;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
diff --git a/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs
index 27d1b837c75..13746b1eed6 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs
@@ -4,13 +4,10 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
-using System.Text;
 using System.Xml;
 
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
diff --git a/src/Build.OM.UnitTests/Construction/ProjectImportGroupElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectImportGroupElement_Tests.cs
index 0859289baef..19989aba62d 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectImportGroupElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectImportGroupElement_Tests.cs
@@ -4,14 +4,8 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
-using System.Text;
 using System.Xml;
-
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Execution;
-using Microsoft.Build.Shared;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemDefinitionElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemDefinitionElement_Tests.cs
index 967f94d76f5..0389131d1ea 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemDefinitionElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemDefinitionElement_Tests.cs
@@ -1,16 +1,11 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
-using System.Text;
 using System.Xml;
 
 using Microsoft.Build.Construction;
 using Microsoft.Build.Exceptions;
-using Microsoft.Build.Shared;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.OM.Construction
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemDefinitionGroupElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemDefinitionGroupElement_Tests.cs
index e88746cad77..197c94939e2 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemDefinitionGroupElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemDefinitionGroupElement_Tests.cs
@@ -1,15 +1,10 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
-using System.Text;
 using System.Xml;
 
 using Microsoft.Build.Construction;
-using Microsoft.Build.Shared;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
index 3f387d1481a..ddcf29d27dc 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemElement_Tests.cs
@@ -2,22 +2,15 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
 using System.Linq;
-using System.Reflection;
-using System.Diagnostics;
-using System.Text;
 using System.Xml;
 
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Shared;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
-using Xunit.Abstractions;
-using Xunit.Sdk;
 
 namespace Microsoft.Build.UnitTests.OM.Construction
 {
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs
index 27a2d84bbb7..9d4ddb0be13 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs
@@ -1,15 +1,10 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
-using System.Text;
 using System.Xml;
 
 using Microsoft.Build.Construction;
-using Microsoft.Build.Shared;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.OM.Construction
diff --git a/src/Build.OM.UnitTests/Construction/ProjectOnErrorElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectOnErrorElement_Tests.cs
index df7fd13eba1..650d52c277b 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectOnErrorElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectOnErrorElement_Tests.cs
@@ -2,14 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
-using System.Text;
 using System.Xml;
 
 using Microsoft.Build.Construction;
-using Microsoft.Build.Shared;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index 86a44b3822f..1ff0a918ab2 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Linq;
 #if FEATURE_SECURITY_PRINCIPAL_WINDOWS
@@ -14,7 +13,6 @@
 using System.Threading;
 using System.Xml;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build.OM.UnitTests/Construction/ProjectUsingTaskElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectUsingTaskElement_Tests.cs
index ecf767ca9f5..aa78c557e38 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectUsingTaskElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectUsingTaskElement_Tests.cs
@@ -2,14 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
-using System.Text;
 using System.Xml;
 
 using Microsoft.Build.Construction;
-using Microsoft.Build.Shared;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index a4e0c79e34e..483adcb954b 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Exceptions;
 using Shouldly;
 using Xunit;
+using System.Text;
 
 namespace Microsoft.Build.UnitTests.Construction
 {
@@ -1067,6 +1068,59 @@ public void ParseProjectConfigurationsInSolutionConfigurations2()
             Assert.Equal(".NET", solution.GetDefaultPlatformName()); // "Default solution platform"
         }
 
+        /// <summary>
+        /// Parse solution file with comments
+        /// </summary>
+        [Fact]
+        public void ParseSolutionWithComments()
+        {
+            const string solutionFileContent = @"
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 16
+                    VisualStudioVersion = 16.0.29123.89
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project('{9A19103F-16F7-4668-BE54-9A1E7A4F7556}') = 'SlnCommentTest', 'SlnCommentTest.csproj', '{00000000-0000-0000-FFFF-FFFFFFFFFFFF}'
+                    EndProject
+                    Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'Solution Items', 'Solution Items', '{054DED3B-B890-4652-B449-839F581E5D86}'
+	                    ProjectSection(SolutionItems) = preProject
+		                    SlnFile.txt = SlnFile.txt
+	                    EndProjectSection
+                    EndProject
+                    Global
+	                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                    Debug|Any CPU = Debug|Any CPU
+		                    Release|Any CPU = Release|Any CPU
+	                    EndGlobalSection
+	                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Release|Any CPU.Build.0 = Release|Any CPU
+	                    EndGlobalSection
+	                    GlobalSection(SolutionProperties) = preSolution
+		                    HideSolutionNode = FALSE
+	                    EndGlobalSection
+	                    GlobalSection(ExtensibilityGlobals) = postSolution
+		                    SolutionGuid = {FFFFFFFF-FFFF-FFFF-0000-000000000000}
+	                    EndGlobalSection
+                    EndGlobal
+                    ";
+
+            StringBuilder stringBuilder = new StringBuilder();
+
+            // Put comment between all lines
+            const string comment = "\t# comment";
+            string[] lines = solutionFileContent.Split(new string[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
+            for (int i = 0; i < lines.Length; i++)
+            {
+                stringBuilder.AppendLine(comment);
+                stringBuilder.AppendLine(lines[i]);
+            }
+            stringBuilder.AppendLine(comment);
+
+            Should.NotThrow(() => ParseSolutionHelper(stringBuilder.ToString()));
+        }
+
         /// <summary>
         /// Helper method to create a SolutionFile object, and call it to parse the SLN file
         /// represented by the string contents passed in.
diff --git a/src/Build.OM.UnitTests/Construction/UsingTaskBodyElement_Tests.cs b/src/Build.OM.UnitTests/Construction/UsingTaskBodyElement_Tests.cs
index f5d78493d6c..443aaf127fd 100644
--- a/src/Build.OM.UnitTests/Construction/UsingTaskBodyElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/UsingTaskBodyElement_Tests.cs
@@ -2,13 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
-using System.Text;
 using System.Xml;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Shared;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
diff --git a/src/Build.OM.UnitTests/Construction/UsingTaskParameterElement_Tests.cs b/src/Build.OM.UnitTests/Construction/UsingTaskParameterElement_Tests.cs
index 21b61ca1df6..684c39aab1a 100644
--- a/src/Build.OM.UnitTests/Construction/UsingTaskParameterElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/UsingTaskParameterElement_Tests.cs
@@ -2,13 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
-using System.Text;
 using System.Xml;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Shared;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
diff --git a/src/Build.OM.UnitTests/Construction/UsingTaskParameterGroup_Tests.cs b/src/Build.OM.UnitTests/Construction/UsingTaskParameterGroup_Tests.cs
index 54ed4b762b7..7504f82a1a5 100644
--- a/src/Build.OM.UnitTests/Construction/UsingTaskParameterGroup_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/UsingTaskParameterGroup_Tests.cs
@@ -2,13 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
-using System.Text;
 using System.Xml;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Shared;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
diff --git a/src/Build.OM.UnitTests/Construction/WhiteSpacePreservation_Tests.cs b/src/Build.OM.UnitTests/Construction/WhiteSpacePreservation_Tests.cs
index 399852e132a..ea7e3549811 100644
--- a/src/Build.OM.UnitTests/Construction/WhiteSpacePreservation_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/WhiteSpacePreservation_Tests.cs
@@ -8,7 +8,6 @@
 using Xunit;
 using System.Linq;
 using System.Text.RegularExpressions;
-using System.Threading;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs b/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs
index ed334a188ea..fed092e5bdc 100644
--- a/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs
@@ -3,13 +3,11 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Linq;
 using System.Xml;
 
 using Microsoft.Build.Construction;
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
diff --git a/src/Build.OM.UnitTests/Definition/EditingElementsReferencedByOrReferences_Tests.cs b/src/Build.OM.UnitTests/Definition/EditingElementsReferencedByOrReferences_Tests.cs
index eb20cbfd593..bb59d52bb6e 100644
--- a/src/Build.OM.UnitTests/Definition/EditingElementsReferencedByOrReferences_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/EditingElementsReferencedByOrReferences_Tests.cs
@@ -3,11 +3,9 @@
 
 using System;
 using System.Collections.Generic;
-using System.Globalization;
 using System.IO;
 using System.Linq;
 using System.Xml;
-using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Xunit;
 
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 3172b22b806..9299381c7ca 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -3,12 +3,10 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Linq;
 using System.Xml;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Engine.UnitTests.Globbing;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -16,7 +14,6 @@
 using Shouldly;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
-using System.Runtime.InteropServices;
 
 namespace Microsoft.Build.UnitTests.OM.Definition
 {
@@ -406,6 +403,34 @@ public void RecursiveDirWithSemicolonSeparatedInclude()
             }
         }
 
+        [Theory]
+        [InlineData(@"<i Condition='false' Include='\**\*.cs'/>")]
+        [InlineData(@"<i Condition='false' Include='/**/*.cs'/>")]
+        [InlineData(@"<i Condition='false' Include='/**\*.cs'/>")]
+        [InlineData(@"<i Condition='false' Include='\**/*.cs'/>")]
+        public void FullFileSystemScanGlobWithFalseCondition(string itemDefinition)
+        {
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(itemDefinition, allItems: false, ignoreCondition: true);
+            items.ShouldBeEmpty();
+        }
+
+        [Theory]
+        [InlineData(@"<i Condition='false' Include='somedir\**\*.cs'/>")]
+        [InlineData(@"<i Condition='false' Include='somedir/**/*.cs'/>")]
+        [InlineData(@"<i Condition='false' Include='somedir/**\*.cs'/>")]
+        [InlineData(@"<i Condition='false' Include='somedir\**/*.cs'/>")]
+        public void PartialFileSystemScanGlobWithFalseCondition(string itemDefinition)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFolder directory = env.CreateFolder(createFolder: true);
+                TransientTestFile file = env.CreateFile(directory, "a.cs", String.Empty);
+
+                IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(itemDefinition.Replace("somedir", directory.Path), allItems: false, ignoreCondition: true);
+                items.ShouldNotBeEmpty();
+            }
+        }
+
         /// <summary>
         /// Basic exclude case
         /// </summary>
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index f85190f0854..9474574afd5 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -4,14 +4,12 @@
 using System;
 using System.Collections.Generic;
 using System.Collections.Immutable;
-using System.Diagnostics;
 using System.IO;
 using System.Linq;
 using System.Text;
 using System.Xml;
 
 using Microsoft.Build.Construction;
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Engine.UnitTests.Globbing;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -2866,7 +2864,7 @@ public void GetItemProvenanceResultsShouldBeInItemElementOrder()
             var sb = new StringBuilder();
             for (int i = 0; i < itemElements; i++)
             {
-                sb.AppendLine($"<i_{i} Include=\"a\"/>");
+                sb.Append("<i_").Append(i).AppendLine(" Include=\"a\"/>");
                 expected.Add(($"i_{i}", Operation.Include, Provenance.StringLiteral, 1));
             }
 
diff --git a/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs b/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs
index d8d066becd4..a269fca7c64 100644
--- a/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs
@@ -8,7 +8,6 @@
 using System.Xml;
 
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Construction;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.OM.Definition
diff --git a/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs
index 708c3b17a4e..d032033dd27 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs
@@ -12,7 +12,6 @@
 
 using Microsoft.Build.Framework;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 using Xunit;
 using Xunit.Abstractions;
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index 0b8fc55697a..e1ddcb897b8 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -14,6 +14,7 @@
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
+using System.Linq;
 
 namespace Microsoft.Build.UnitTests.OM.Instance
 {
@@ -342,6 +343,9 @@ public void ReadMetadata()
             ProjectItemInstance item = GetOneItem(content);
 
             var itemMetadata = Helpers.MakeList(item.Metadata);
+
+            itemMetadata = itemMetadata.OrderBy(pmi => pmi.Name).ToList();
+
             Assert.Equal(2, itemMetadata.Count);
             Assert.Equal("m1", itemMetadata[0].Name);
             Assert.Equal("m2", itemMetadata[1].Name);
diff --git a/src/Build.OM.UnitTests/Instance/ProjectMetadataInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectMetadataInstance_Tests.cs
index 1409e52892a..fa2a87e73a5 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectMetadataInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectMetadataInstance_Tests.cs
@@ -1,8 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Xunit;
diff --git a/src/Build.OM.UnitTests/Instance/ProjectPropertyInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectPropertyInstance_Tests.cs
index d4f864649a8..26363cbe96b 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectPropertyInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectPropertyInstance_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Xunit;
diff --git a/src/Build.OM.UnitTests/LazyFormattedEventArgs_Tests.cs b/src/Build.OM.UnitTests/LazyFormattedEventArgs_Tests.cs
index 99e9a57e6a3..493237ec52c 100644
--- a/src/Build.OM.UnitTests/LazyFormattedEventArgs_Tests.cs
+++ b/src/Build.OM.UnitTests/LazyFormattedEventArgs_Tests.cs
@@ -1,24 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Linq;
-using System.Xml;
-using System.Reflection;
-using System.Collections;
-using System.Collections.Generic;
-using System.Collections.Specialized;
-using System.Text.RegularExpressions;
-
-using Microsoft.Build.Collections;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Execution;
-using Microsoft.Build.BackEnd;
-using Microsoft.Build.Shared;
-using System.Text;
 using System.IO;
-using Microsoft.Build.Internal;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.Framework
diff --git a/src/Build.OM.UnitTests/NugetRestoreTests.cs b/src/Build.OM.UnitTests/NugetRestoreTests.cs
index 64be9580f68..93d56ae6aaf 100644
--- a/src/Build.OM.UnitTests/NugetRestoreTests.cs
+++ b/src/Build.OM.UnitTests/NugetRestoreTests.cs
@@ -1,11 +1,13 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if !DEBUG
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using System.IO;
 using Xunit;
+#endif
 using Xunit.Abstractions;
 
 namespace Microsoft.Build.Engine.OM.UnitTests
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
index b31ffbe17bb..3e9fd6a872f 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/TestCollectionGroup.cs
@@ -4,7 +4,6 @@ namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
     using System;
     using System.Collections.Generic;
-    using System.Runtime.CompilerServices;
     using Microsoft.Build.Evaluation;
     using Xunit;
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
index aa285e5e98f..8ebfe5804bb 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.construction.cs
@@ -9,8 +9,6 @@ namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
     using Microsoft.Build.ObjectModelRemoting;
     using Microsoft.Build.Evaluation;
     using Xunit;
-    using System.Runtime.ExceptionServices;
-    using System.Xml.Schema;
     using System.Collections;
 
     internal class ElementLinkPair<T> : LinkPair<T>
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs
index 4945bbdf4b1..3589801cb5b 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.cs
@@ -6,13 +6,8 @@ namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
     using System.Collections.Generic;
     using System.Linq;
     using Microsoft.Build.Construction;
-    using Microsoft.Build.ObjectModelRemoting;
     using Microsoft.Build.Evaluation;
     using Xunit;
-    using System.Runtime.ExceptionServices;
-    using System.Xml.Schema;
-    using System.Collections;
-    using Microsoft.Build.Framework;
 
     internal enum ObjectType
     {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
index 14ecdd51296..fea0765bb61 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
@@ -2,16 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-    using System;
     using System.Collections.Generic;
     using System.Linq;
-    using Microsoft.Build.Construction;
-    using Microsoft.Build.ObjectModelRemoting;
     using Microsoft.Build.Evaluation;
     using Xunit;
-    using System.Runtime.ExceptionServices;
-    using System.Xml.Schema;
-    using System.Collections;
     using Microsoft.Build.Framework;
 
     internal class ProjectPair : LinkPair<Project>
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
index 25ef9caa625..942348cb23d 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionModify_Tests.cs
@@ -3,22 +3,11 @@
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
     using System;
-    using System.Collections;
     using System.Collections.Generic;
-    using System.Collections.Immutable;
-    using System.IO;
     using System.Linq;
-    using System.Runtime.InteropServices;
-    using System.Text.RegularExpressions;
-    using System.Threading.Tasks;
     using Microsoft.Build.Construction;
     using Microsoft.Build.Evaluation;
-    using Microsoft.Build.Tasks;
-    using Microsoft.Build.UnitTests.OM.Construction;
     using Xunit;
-    using Xunit.Abstractions;
-    using Xunit.NetCore.Extensions;
-    using Xunit.Sdk;
 
     public class LinkedConstructionModify_Tests : IClassFixture<LinkedConstructionModify_Tests.MyTestCollectionGroup>
     {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
index 9be5ab30462..1222d6f9175 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedConstructionReadOnly_Tests.cs
@@ -3,16 +3,9 @@
 
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-    using System;
-    using System.Collections;
-    using System.Collections.Generic;
     using System.Linq;
-    using System.Xml.Schema;
     using Microsoft.Build.Construction;
-    using Microsoft.Build.Evaluation;
     using Xunit;
-    using Xunit.Abstractions;
-    using Xunit.Sdk;
 
     /// <summary>
     /// Most importantly we want to touch implementation to all public method to catch any
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
index 3c225aec6db..707c2fd8e66 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationModify_Tests.cs
@@ -3,17 +3,11 @@
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
     using System;
-    using System.Collections;
     using System.Collections.Generic;
-    using System.Collections.Immutable;
     using System.IO;
     using System.Linq;
-    using System.Text.RegularExpressions;
-    using System.Threading.Tasks;
     using Microsoft.Build.Evaluation;
-    using Microsoft.Build.Tasks;
     using Xunit;
-    using Xunit.Abstractions;
 
     public class LinkedEvaluationModify_Tests : IClassFixture<LinkedEvaluationModify_Tests.MyTestCollectionGroup>
     {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs
index 5792411a2a7..a85eefbec89 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedEvaluationReadOnly_Tests.cs
@@ -3,17 +3,9 @@
 
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-    using System;
-    using System.Collections;
-    using System.Collections.Generic;
     using System.Linq;
-    using System.Xml.Schema;
-    using Microsoft.Build.Construction;
     using Microsoft.Build.Evaluation;
-    using Microsoft.Build.Tasks;
     using Xunit;
-    using Xunit.Abstractions;
-    using Xunit.Sdk;
 
     public class LinkedEvaluationReadOnly_Tests : IClassFixture<LinkedEvaluationReadOnly_Tests.ROTestCollectionGroup>
     {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
index 52face4ec61..1860c67e314 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedProjectCollection_Tests.cs
@@ -3,13 +3,8 @@
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
     using System;
-    using System.Collections.Generic;
-    using System.Collections.Immutable;
     using System.Linq;
-    using System.Text.RegularExpressions;
-    using Microsoft.Build.Evaluation;
     using Xunit;
-    using Xunit.Abstractions;
 
     public class LinkedProjectCollection_Tests : IClassFixture<LinkedProjectCollection_Tests.MyTestCollectionGroup>
     {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
index c92fdd25470..8f1a864574a 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
@@ -3,23 +3,10 @@
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
     using System;
-    using System.Collections;
-    using System.Collections.Generic;
-    using System.Collections.Immutable;
-    using System.IO;
     using System.Linq;
-    using System.Runtime.InteropServices;
-    using System.Text.RegularExpressions;
-    using System.Threading.Tasks;
     using Microsoft.Build.Construction;
     using Microsoft.Build.Evaluation;
-    using Microsoft.Build.ObjectModelRemoting;
-    using Microsoft.Build.Tasks;
-    using Microsoft.Build.UnitTests.OM.Construction;
     using Xunit;
-    using Xunit.Abstractions;
-    using Xunit.NetCore.Extensions;
-    using Xunit.Sdk;
 
     public class LinkedSpecialCasesScenarios : IClassFixture<LinkedSpecialCasesScenarios.MyTestCollectionGroup>
     {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/CollectionsHelpers.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/CollectionsHelpers.cs
index 431d6c8fb0a..3f0f13a0137 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/CollectionsHelpers.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/CollectionsHelpers.cs
@@ -4,7 +4,6 @@
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
     using System;
-    using System.Collections;
     using System.Collections.Generic;
     using Microsoft.Build.Construction;
 
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs
index 8080dd5afc7..26ea393decb 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/MockProjectElementContainerLink.cs
@@ -3,17 +3,9 @@
 
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-    using System;
     using System.Collections.Generic;
-    using System.IO;
     using Microsoft.Build.Construction;
-    using Microsoft.Build.Evaluation;
-    using Microsoft.Build.Evaluation.Context;
-    using Microsoft.Build.Execution;
     using Microsoft.Build.ObjectModelRemoting;
-    using Microsoft.Build.Framework;
-    using Microsoft.Build.Logging;
-    using System.Diagnostics;
 
     internal abstract class MockProjectElementContainerLinkRemoter : MockProjectElementLinkRemoter
     {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs
index 49138cbd4cd..8ede445cd3e 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ConstructionLinkMocks/ProjectElemetExportHelper.cs
@@ -5,10 +5,7 @@ namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
     using System;
     using System.Collections.Generic;
-    using System.Runtime.CompilerServices;
-    using System.Xml;
     using Microsoft.Build.Construction;
-    using Microsoft.Build.ObjectModelRemoting;
 
 
     /// <summary>
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs
index bcc3af4d85b..dd4dcf72f23 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/DirectlyRemotedClasses.cs
@@ -3,17 +3,9 @@
 
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-    using System;
-    using System.Collections.Generic;
-    using System.IO;
     using Microsoft.Build.Construction;
     using Microsoft.Build.Evaluation;
-    using Microsoft.Build.Evaluation.Context;
-    using Microsoft.Build.Execution;
-    using Microsoft.Build.ObjectModelRemoting;
     using Microsoft.Build.Framework;
-    using Microsoft.Build.Logging;
-    using System.Diagnostics;
 
 
     internal static class DirectlyRemotedClasses
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemDefinitionLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemDefinitionLink.cs
index c2b4454054d..25b9fa61b9b 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemDefinitionLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemDefinitionLink.cs
@@ -3,16 +3,9 @@
 
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-    using System;
     using System.Collections.Generic;
-    using System.IO;
-    using Microsoft.Build.Construction;
     using Microsoft.Build.Evaluation;
-    using Microsoft.Build.Evaluation.Context;
-    using Microsoft.Build.Execution;
     using Microsoft.Build.ObjectModelRemoting;
-    using Microsoft.Build.Framework;
-    using Microsoft.Build.Logging;
 
     internal class MockProjectItemDefinitionLinkRemoter : MockLinkRemoter<ProjectItemDefinition>
     {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemLink.cs
index 56e0761d7dd..a4015cb2fb7 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectItemLink.cs
@@ -3,16 +3,10 @@
 
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-    using System;
     using System.Collections.Generic;
-    using System.IO;
     using Microsoft.Build.Construction;
     using Microsoft.Build.Evaluation;
-    using Microsoft.Build.Evaluation.Context;
-    using Microsoft.Build.Execution;
     using Microsoft.Build.ObjectModelRemoting;
-    using Microsoft.Build.Framework;
-    using Microsoft.Build.Logging;
 
     internal class MockProjectItemLinkRemoter : MockLinkRemoter<ProjectItem>
     {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectPropertyLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectPropertyLink.cs
index 4f63a8c8da4..374f44d06bc 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectPropertyLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectPropertyLink.cs
@@ -3,16 +3,9 @@
 
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
-    using System;
-    using System.Collections.Generic;
-    using System.IO;
     using Microsoft.Build.Construction;
     using Microsoft.Build.Evaluation;
-    using Microsoft.Build.Evaluation.Context;
-    using Microsoft.Build.Execution;
     using Microsoft.Build.ObjectModelRemoting;
-    using Microsoft.Build.Framework;
-    using Microsoft.Build.Logging;
 
     internal class MockProjectPropertyLinkRemoter : MockLinkRemoter<ProjectProperty>
     {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
index 60f2ee19e03..95a409f777e 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
@@ -10,9 +10,7 @@ namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
     using System.Xml;
     using Microsoft.Build.Construction;
     using Microsoft.Build.Evaluation;
-    using Microsoft.Build.Framework;
     using Microsoft.Build.ObjectModelRemoting;
-    using Microsoft.Build.Tasks;
     using Xunit;
     using ExportedLinksMap = LinkedObjectsMap<object>;
     using ImportedLinksMap = LinkedObjectsMap<System.UInt32>;
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/LinkedObjectsMap.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/LinkedObjectsMap.cs
index fcdae306284..b4a5223c125 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/LinkedObjectsMap.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/LinkedObjectsMap.cs
@@ -4,9 +4,8 @@
 namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
     using System;
-    using System.Collections;
     using System.Collections.Generic;
-    
+
     internal class LinkedObjectsMap<KeyType> : IDisposable
     {
         private static object Lock { get; } = new object();
diff --git a/src/Build.UnitTests/BackEnd/AssemblyLoadContextTestTasks.cs b/src/Build.UnitTests/BackEnd/AssemblyLoadContextTestTasks.cs
index d8f6cab04c0..e3835a04268 100644
--- a/src/Build.UnitTests/BackEnd/AssemblyLoadContextTestTasks.cs
+++ b/src/Build.UnitTests/BackEnd/AssemblyLoadContextTestTasks.cs
@@ -3,8 +3,6 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
-using System.Collections;
-using System.Collections.Generic;
 
 namespace AssemblyLoadContextTest
 {
diff --git a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
index f32185ac0f1..d49cc341887 100644
--- a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
@@ -2,19 +2,13 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
 using System.Reflection;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Construction;
-
-using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
-using LoggingService = Microsoft.Build.BackEnd.Logging.LoggingService;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
 
diff --git a/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs b/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs
index 5367b5195ad..bd728aee05e 100644
--- a/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs
@@ -4,8 +4,6 @@
 using System;
 using System.IO;
 using System.Xml;
-using System.Collections;
-using System.Text.RegularExpressions;
 
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index 260736f20ef..87c18c4b5b9 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -2,17 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Xml;
-using System.Text;
-using System.Collections;
 using System.Collections.Generic;
-using System.Text.RegularExpressions;
-using System.Threading;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Execution;
 using Microsoft.Build.BackEnd;
 using System.IO;
 using Xunit;
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index f43d6e7718c..cb544f66278 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -1500,7 +1500,7 @@ public void CancelledBuildWithUnexecutedSubmission()
         /// <summary>
         /// A canceled build
         /// </summary>
-        [Fact]
+        [Fact(Timeout = 20_000)]
         public void CancelledBuild()
         {
             string contents = CleanupFileContents(@"
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfigurationResponse_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfigurationResponse_Tests.cs
index c7a9ef0ae6a..ea11fb4ac01 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfigurationResponse_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfigurationResponse_Tests.cs
@@ -1,20 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Xml;
-using System.Text;
-using System.Collections;
-using System.Collections.Generic;
-using System.Text.RegularExpressions;
-using System.Threading;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Execution;
 using Microsoft.Build.BackEnd;
-using System.IO;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.BackEnd
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index 93eeb2927b1..5be64a17d58 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -6,11 +6,6 @@
 using System.IO;
 using System.Linq;
 using System.Xml;
-using System.Text;
-using System.Collections;
-using System.Text.RegularExpressions;
-using System.Threading;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
index 39ea53ed7ed..185e828aae6 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
@@ -3,26 +3,20 @@
 
 using System;
 using System.Xml;
-using System.Text;
-using System.Collections;
 using System.Collections.Generic;
-using System.Text.RegularExpressions;
 using System.IO;
 using System.Threading;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Unittest;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
-    using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
     using NodeLoggingContext = Microsoft.Build.BackEnd.Logging.NodeLoggingContext;
 
     public class BuildRequestEngine_Tests : IDisposable
diff --git a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
index c85104ba7cc..75e018b7cdc 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
diff --git a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
index af9bf647c5d..237fcf00856 100644
--- a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
@@ -10,7 +10,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Unittest;
-using Shouldly;
 using Xunit;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
diff --git a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
index ba2a1b00f57..791db350934 100644
--- a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using System.Linq;
 using Microsoft.Build.BackEnd;
diff --git a/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs b/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs
index 70e9d6597c7..62f686d4657 100644
--- a/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
diff --git a/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs b/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
index 4e788077ae3..e3dc1ff11f7 100644
--- a/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Linq;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
diff --git a/src/Build.UnitTests/BackEnd/ConfigurationMetadata_Tests.cs b/src/Build.UnitTests/BackEnd/ConfigurationMetadata_Tests.cs
index 27b623a71bd..74b8c257d49 100644
--- a/src/Build.UnitTests/BackEnd/ConfigurationMetadata_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ConfigurationMetadata_Tests.cs
@@ -2,15 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Linq;
 using System.Xml;
-using System.Text;
-using System.Collections;
 using System.Collections.Generic;
-using System.Text.RegularExpressions;
-using System.Threading;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
diff --git a/src/Build.UnitTests/BackEnd/CustomTaskHelper.cs b/src/Build.UnitTests/BackEnd/CustomTaskHelper.cs
index ecbf29e118d..fc97d6fc91d 100644
--- a/src/Build.UnitTests/BackEnd/CustomTaskHelper.cs
+++ b/src/Build.UnitTests/BackEnd/CustomTaskHelper.cs
@@ -2,9 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Linq;
 using System.Text;
 using System.Reflection;
 using System.CodeDom.Compiler;
diff --git a/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs b/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs
index 27685adfd74..59580199847 100644
--- a/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
diff --git a/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs b/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
index 3531f223967..3798326b7e2 100644
--- a/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Concurrent;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd.Logging;
diff --git a/src/Build.UnitTests/BackEnd/FailingTask.cs b/src/Build.UnitTests/BackEnd/FailingTask.cs
index c42f912d679..2060a8639c5 100644
--- a/src/Build.UnitTests/BackEnd/FailingTask.cs
+++ b/src/Build.UnitTests/BackEnd/FailingTask.cs
@@ -10,11 +10,14 @@ public class FailingTask : Task
     {
         public override bool Execute()
         {
-            BuildEngine.GetType().GetProperty("AllowFailureWithoutError").SetValue(BuildEngine, EnableDefaultFailure);
+            if (!AllowFailureWithoutError.Equals("Default"))
+            {
+                BuildEngine.GetType().GetProperty("AllowFailureWithoutError").SetValue(BuildEngine, AllowFailureWithoutError.Equals("True"));
+            }
             return false;
         }
 
         [Required]
-        public bool EnableDefaultFailure { get; set; }
+        public string AllowFailureWithoutError { get; set; }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/FullyQualifiedBuildRequest_Tests.cs b/src/Build.UnitTests/BackEnd/FullyQualifiedBuildRequest_Tests.cs
index a1e0755a6b4..4901c0fe91b 100644
--- a/src/Build.UnitTests/BackEnd/FullyQualifiedBuildRequest_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/FullyQualifiedBuildRequest_Tests.cs
@@ -3,12 +3,8 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text.RegularExpressions;
-using System.Threading;
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Evaluation;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.BackEnd
diff --git a/src/Build.UnitTests/BackEnd/ITestTaskHost.cs b/src/Build.UnitTests/BackEnd/ITestTaskHost.cs
index 4ac7fbd3c80..41206a64e15 100644
--- a/src/Build.UnitTests/BackEnd/ITestTaskHost.cs
+++ b/src/Build.UnitTests/BackEnd/ITestTaskHost.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.UnitTests.BackEnd
diff --git a/src/Build.UnitTests/BackEnd/IntegrationTests.cs b/src/Build.UnitTests/BackEnd/IntegrationTests.cs
index c2e88153213..c9550165546 100644
--- a/src/Build.UnitTests/BackEnd/IntegrationTests.cs
+++ b/src/Build.UnitTests/BackEnd/IntegrationTests.cs
@@ -1,8 +1,4 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Text;
-
-namespace Microsoft.Build.Unittest.BackEnd
+﻿namespace Microsoft.Build.Unittest.BackEnd
 {
     class IntegrationTests
     {
diff --git a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
index ff272e8da60..0914d530708 100644
--- a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Linq;
 using System.Xml;
@@ -11,7 +10,6 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Engine.UnitTests.Globbing;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
diff --git a/src/Build.UnitTests/BackEnd/ItemCreationTask.cs b/src/Build.UnitTests/BackEnd/ItemCreationTask.cs
index 13038bd5a2f..67d1764aa55 100644
--- a/src/Build.UnitTests/BackEnd/ItemCreationTask.cs
+++ b/src/Build.UnitTests/BackEnd/ItemCreationTask.cs
@@ -3,8 +3,6 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
-using System.Collections;
-using System.Collections.Generic;
 
 namespace ItemCreationTask
 {
diff --git a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
index 338cc793c8e..a0a2965cc3b 100644
--- a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
@@ -1,11 +1,9 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using Shouldly;
-using System;
 using Xunit;
 using Xunit.Abstractions;
 
diff --git a/src/Build.UnitTests/BackEnd/LoggingServiceFactory_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServiceFactory_Tests.cs
index 22651c729cc..10cf7d2192a 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServiceFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServiceFactory_Tests.cs
@@ -1,8 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd;
 using Xunit;
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index e29c9374f82..9a485cb0d49 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -12,7 +12,6 @@
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.BackEnd;
-using System.IO;
 using System.Threading;
 using System.Reflection;
 using System.Collections.Generic;
diff --git a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
index 697a830562a..aebd6d881a2 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
@@ -239,8 +239,7 @@ public void LogFatalErrorNullException()
             string helpKeyword;
             string resourceName = "FatalTaskError";
             string parameters = "TaskName";
-            string message = null;
-
+            string message;
             GenerateMessageFromExceptionAndResource(null, resourceName, out errorCode, out helpKeyword, out message, parameters);
             ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.LogFatalError(s_buildEventContext, null, fileInfo, resourceName, parameters);
@@ -347,8 +346,7 @@ public void LogFatalTaskError()
             string helpKeyword;
             string resourceName = "FatalTaskError";
             string parameters = "TaskName";
-            string message = null;
-
+            string message;
             GenerateMessageFromExceptionAndResource(exception, resourceName, out errorCode, out helpKeyword, out message, parameters);
             ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.LogFatalTaskError(s_buildEventContext, exception, fileInfo, parameters);
@@ -1381,8 +1379,7 @@ private void TestTargetFinished(string targetName, string projectFile, string pr
         /// <param name="projectFileOfTarget">ProjectFileOfTarget to test</param>
         private void TestTargetStartedEvent(string targetName, string projectFile, string projectFileOfTarget)
         {
-            string message = String.Empty;
-
+            string message;
             if (String.Equals(projectFile, projectFileOfTarget, StringComparison.OrdinalIgnoreCase))
             {
                 message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("TargetStartedProjectEntry", targetName, projectFile);
@@ -1409,7 +1406,7 @@ private void TestTargetStartedEvent(string targetName, string projectFile, strin
         private void TestTargetStartedWithParentTargetEvent(string targetName, string projectFile, string projectFileOfTarget)
         {
             string parentTargetName = "MyParentTarget";
-            string message = String.Empty;
+            string message;
             if (String.Equals(projectFile, projectFileOfTarget, StringComparison.OrdinalIgnoreCase))
             {
                 message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("TargetStartedProjectDepends", targetName, projectFile, parentTargetName);
@@ -1435,7 +1432,7 @@ private void TestTargetStartedWithParentTargetEvent(string targetName, string pr
         /// </summary>
         private void LogProjectStartedTestHelper(string projectFile, string targetNames)
         {
-            string message = string.Empty;
+            string message;
             if (!String.IsNullOrEmpty(targetNames))
             {
                 message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithTargetNames", Path.GetFileName(projectFile), targetNames);
diff --git a/src/Build.UnitTests/BackEnd/Lookup_Tests.cs b/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
index 841222a1f9c..801c8bedb38 100644
--- a/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
@@ -2,18 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
-using System.Xml;
-using System.Threading;
-using System.Diagnostics;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.BackEnd
diff --git a/src/Build.UnitTests/BackEnd/MockHost.cs b/src/Build.UnitTests/BackEnd/MockHost.cs
index 388a44f149a..1d787f19f91 100644
--- a/src/Build.UnitTests/BackEnd/MockHost.cs
+++ b/src/Build.UnitTests/BackEnd/MockHost.cs
@@ -3,9 +3,7 @@
 
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.UnitTests.BackEnd;
 using System;
-using System.Threading;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Engine.UnitTests.BackEnd;
 using Microsoft.Build.Evaluation;
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index b979576b989..27211e3edea 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Logging;
diff --git a/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs b/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
index 5dd66b6e929..8f5590fe5ae 100644
--- a/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
+++ b/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
@@ -3,14 +3,9 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using System.Threading;
-using System.Linq;
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 
 using TargetLoggingContext = Microsoft.Build.BackEnd.Logging.TargetLoggingContext;
@@ -92,7 +87,7 @@ public Task<WorkUnitResult> ExecuteTask(TargetLoggingContext targetLoggingContex
             }
 
             ProjectOnErrorInstance errorTask = task as ProjectOnErrorInstance;
-            if (null != errorTask)
+            if (errorTask != null)
             {
                 ErrorTasks.Add(errorTask);
             }
diff --git a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
index debbfe149e7..4005633d981 100644
--- a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
@@ -2,13 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Xml;
-using System.Text;
-using System.Collections;
 using System.Collections.Generic;
-using System.Text.RegularExpressions;
 using System.Threading;
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Execution;
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index f8940f06ed0..459d835bd25 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -3,7 +3,6 @@
 
 using System;
 using Microsoft.Build.Framework;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
diff --git a/src/Build.UnitTests/BackEnd/OnError_Tests.cs b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
index 8e3442960f5..bbb9ada34e5 100644
--- a/src/Build.UnitTests/BackEnd/OnError_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
@@ -6,8 +6,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
-using System.Threading;
-using System.Collections;
 using System.Xml;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
@@ -563,18 +561,19 @@ public void OutOfOrderOnError()
         }
 
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void ErrorWhenTaskFailsWithoutLoggingErrorEscapeHatch(bool emitError)
+        [InlineData("True")]
+        [InlineData("False")]
+        [InlineData("Default")]
+        public void ErrorWhenTaskFailsWithoutLoggingErrorEscapeHatch(string failureResponse)
         {
             MockLogger logger = ObjectModelHelpers.BuildProjectExpectFailure($@"
 <Project>
     <UsingTask TaskName=""FailingTask"" AssemblyFile=""{Assembly.GetExecutingAssembly().Location}"" />
     <Target Name=""MyTarget"">
-        <FailingTask EnableDefaultFailure=""{emitError}"" />
+        <FailingTask AllowFailureWithoutError=""{failureResponse}"" />
     </Target>
 </Project>");
-            if (emitError)
+            if (!string.Equals(failureResponse, "True"))
             {
                 logger.ErrorCount.ShouldBe(1);
                 logger.Errors.First().Code.ShouldBe("MSB4181");
diff --git a/src/Build.UnitTests/BackEnd/ProcessIdTask.cs b/src/Build.UnitTests/BackEnd/ProcessIdTask.cs
index 71e5379e2ba..0c4acb499d3 100644
--- a/src/Build.UnitTests/BackEnd/ProcessIdTask.cs
+++ b/src/Build.UnitTests/BackEnd/ProcessIdTask.cs
@@ -3,7 +3,6 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
-using System;
 using System.Diagnostics;
 namespace Microsoft.Build.UnitTests
 {
diff --git a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
index 54bc2fa1dfc..42ceffcef27 100644
--- a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
@@ -2,11 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Xml;
-using System.Text;
-using System.Collections;
 using System.Collections.Generic;
-using System.Text.RegularExpressions;
 using System.Threading;
 using System.IO;
 using Microsoft.Build.Framework;
@@ -15,7 +11,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Unittest;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Xunit;
@@ -261,8 +256,7 @@ private BuildRequestConfiguration CreateTestProject(int configId)
             string projectFile = GetTestProjectFile(configId);
             File.WriteAllText(projectFile, projectFileContents.Replace('`', '"'));
 
-            string defaultToolsVersion = null;
-            defaultToolsVersion = FrameworkLocationHelper.PathToDotNetFrameworkV20 == null
+            string defaultToolsVersion = FrameworkLocationHelper.PathToDotNetFrameworkV20 == null
                                       ? ObjectModelHelpers.MSBuildDefaultToolsVersion
                                       : "2.0";
 
@@ -374,7 +368,7 @@ public Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, Buil
                 return Task<BuildResult>.FromResult(result);
             }
 
-            if (null != _newRequests)
+            if (_newRequests != null)
             {
                 string[] projectFiles = new string[_newRequests.Length];
                 PropertyDictionary<ProjectPropertyInstance>[] properties = new PropertyDictionary<ProjectPropertyInstance>[_newRequests.Length];
diff --git a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
index 5500f71f1d6..781db5fb46a 100644
--- a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text.RegularExpressions;
-using System.Threading;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
diff --git a/src/Build.UnitTests/BackEnd/ReturnFailureWithoutLoggingErrorTask.cs b/src/Build.UnitTests/BackEnd/ReturnFailureWithoutLoggingErrorTask.cs
index 8d9b0b8b436..6e417e16dc7 100644
--- a/src/Build.UnitTests/BackEnd/ReturnFailureWithoutLoggingErrorTask.cs
+++ b/src/Build.UnitTests/BackEnd/ReturnFailureWithoutLoggingErrorTask.cs
@@ -1,12 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 namespace Microsoft.Build.UnitTests
 {
     /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
index fd732589b22..dc86010e269 100644
--- a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
@@ -3,16 +3,11 @@
 
 using System;
 using System.Xml;
-using System.Text;
-using System.Collections;
 using System.Collections.Generic;
-using System.Text.RegularExpressions;
-using System.Threading;
 using System.IO;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Evaluation;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
@@ -20,8 +15,6 @@
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
-    using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
-    using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
     using Microsoft.Build.Unittest;
 
     /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
index 59e288501ae..ac3317da212 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
@@ -4,8 +4,6 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
-using System.Runtime.Serialization;
-using System.Threading;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Construction;
@@ -271,6 +269,73 @@ public void SdkResolverLoaderErrorsWhenManifestTargetMissing()
             }
         }
 
+        [Fact]
+        public void SdkResolverLoaderHonorsIncludeDefaultEnvVar()
+        {
+            using (var env = TestEnvironment.Create(_output))
+            {
+                var origIncludeDefault = Environment.GetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER");
+                try
+                {
+                    var testRoot = env.CreateFolder().Path;
+                    Environment.SetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER", "false");
+                    SdkResolverLoader loader = new MockSdkResolverLoader()
+                    {
+                        LoadResolversAction = (resolverPath, loggingContext, location, resolvers) => {
+                            resolvers.Add(new MockSdkResolverWithAssemblyPath(resolverPath));
+                        }
+                    };
+                    IList<SdkResolverBase> resolvers = loader.LoadResolvers(_loggingContext, new MockElementLocation("file"));
+
+                    resolvers.Count.ShouldBe(0);
+                }
+                finally
+                {
+                    Environment.SetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER", origIncludeDefault);
+                }
+            }
+        }
+
+        [Fact]
+        public void SdkResolverLoaderHonorsAdditionalResolversFolder()
+        {
+            using (var env = TestEnvironment.Create(_output))
+            {
+                var origResolversFolder = Environment.GetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER");
+                try
+                {
+                    var testRoot = env.CreateFolder().Path;
+                    var additionalRoot = env.CreateFolder().Path;
+
+                    var resolver1 = "Resolver1";
+                    var resolver1Path = Path.Combine(additionalRoot, resolver1, $"{resolver1}.dll");
+                    Directory.CreateDirectory(Path.Combine(testRoot, resolver1));
+                    File.WriteAllText(Path.Combine(testRoot, resolver1, $"{resolver1}.dll"), string.Empty);
+                    Directory.CreateDirectory(Path.Combine(additionalRoot, resolver1));
+                    File.WriteAllText(resolver1Path, string.Empty);
+                    var resolver2 = "Resolver2";
+                    var resolver2Path = Path.Combine(testRoot, resolver2, $"{resolver2}.dll");
+                    Directory.CreateDirectory(Path.Combine(testRoot, resolver2));
+                    File.WriteAllText(resolver2Path, string.Empty);
+                    var resolver3 = "Resolver3";
+                    var resolver3Path = Path.Combine(additionalRoot, resolver3, $"{resolver3}.dll");
+                    Directory.CreateDirectory(Path.Combine(additionalRoot, resolver3));
+                    File.WriteAllText(resolver3Path, string.Empty);
+
+                    Environment.SetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER", additionalRoot);
+
+                    SdkResolverLoader loader = new SdkResolverLoader();
+                    IList<string> resolvers = loader.FindPotentialSdkResolvers(testRoot, new MockElementLocation("file"));
+
+                    resolvers.ShouldBeSameIgnoringOrder(new[] { resolver1Path, resolver2Path, resolver3Path });
+                }
+                finally
+                {
+                    Environment.SetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER", origResolversFolder);
+                }
+            }
+        }
+
         private class MockSdkResolverThatDoesNotLoad : SdkResolverBase
         {
             public const string ExpectedMessage = "A8BB8B3131D3475D881ACD3AF8D75BD6";
@@ -306,6 +371,25 @@ public override SdkResultBase Resolve(SdkReference sdkReference, SdkResolverCont
             }
         }
 
+        private class MockSdkResolverWithAssemblyPath : SdkResolverBase
+        {
+            public string AssemblyPath;
+
+            public MockSdkResolverWithAssemblyPath(string assemblyPath = "")
+            {
+                AssemblyPath = assemblyPath;
+            }
+
+            public override string Name => nameof(MockSdkResolverWithAssemblyPath);
+
+            public override int Priority => 0;
+
+            public override SdkResultBase Resolve(SdkReference sdkReference, SdkResolverContextBase resolverContext, SdkResultFactoryBase factory)
+            {
+                throw new NotImplementedException();
+            }
+        }
+
         private class MockSdkResolverLoader : SdkResolverLoader
         {
             public Func<string, LoggingContext, ElementLocation, Assembly> LoadResolverAssemblyFunc { get; set; }
@@ -314,6 +398,8 @@ private class MockSdkResolverLoader : SdkResolverLoader
 
             public Func<Assembly, IEnumerable<Type>> GetResolverTypesFunc { get; set; }
 
+            public Action<string, LoggingContext, ElementLocation, List<SdkResolver>> LoadResolversAction { get; set; }
+
             protected override Assembly LoadResolverAssembly(string resolverPath, LoggingContext loggingContext, ElementLocation location)
             {
                 if (LoadResolverAssemblyFunc != null)
@@ -343,6 +429,16 @@ internal override IList<string> FindPotentialSdkResolvers(string rootFolder, Ele
 
                 return base.FindPotentialSdkResolvers(rootFolder, location);
             }
+
+            protected override void LoadResolvers(string resolverPath, LoggingContext loggingContext, ElementLocation location, List<SdkResolver> resolvers)
+            {
+                if (LoadResolversAction != null)
+                {
+                    LoadResolversAction(resolverPath, loggingContext, location, resolvers);
+                    return;
+                }
+                base.LoadResolvers(resolverPath, loggingContext, location, resolvers);
+            }
         }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index 85934d1aa8a..c90d6e8a60c 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.UnitTests;
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Linq;
 using System.Threading.Tasks;
 using Microsoft.Build.Unittest;
@@ -395,10 +394,8 @@ public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersi
             var expectedPath2 = "Second/Path/To/Return/From/Resolver";
 
             var sdk = new SdkReference("foo", "1.0", null);
-
-            Dictionary<string, string> propertiesToAdd = null;
-            Dictionary<string, SdkResultItem> itemsToAdd = null;
-            
+            Dictionary<string, string> propertiesToAdd;
+            Dictionary<string, SdkResultItem> itemsToAdd;
             CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
 
             var resolver = new SdkUtilities.ConfigurableMockSdkResolver(
diff --git a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
index 8fd40d75ddc..562ac26f280 100644
--- a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
@@ -4,22 +4,17 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Unittest;
-using Microsoft.Build.UnitTests.Definition;
 using Shouldly;
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.Xml;
 using Xunit;
 using Xunit.Abstractions;
 using static Microsoft.Build.UnitTests.ObjectModelHelpers;
diff --git a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
index 5af65de88f9..256f673586e 100644
--- a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
@@ -3,12 +3,8 @@
 
 using System;
 using System.Xml;
-using System.Text;
-using System.Collections;
 using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Text.RegularExpressions;
 using System.Threading;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
@@ -922,6 +918,26 @@ public void TestAfterTargetsWithTransitiveFailure()
             result.ResultsByTarget["Build"].AfterTargetsHaveFailed.ShouldBe(true);
         }
 
+        /// <summary>
+        /// Test a project that has a cycle in AfterTargets
+        /// </summary>
+        [Fact]
+        public void TestAfterTargetsWithCycleDoesNotHang()
+        {
+            string projectBody = @"
+<Target Name='Build' AfterTargets='After2' />
+
+<Target Name='After1' AfterTargets='Build' />
+
+<Target Name='After2' AfterTargets='After1' />
+";
+
+            BuildResult result = BuildSimpleProject(projectBody, new string[] { "Build" }, failTaskNumber: int.MaxValue /* no task failure needed here */);
+            result.ResultsByTarget["Build"].ResultCode.ShouldBe(TargetResultCode.Success);
+            result.ResultsByTarget["Build"].AfterTargetsHaveFailed.ShouldBe(false);
+        }
+
+
         /// <summary>
         /// Test after target on a skipped target
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
index 45c3557cb60..9cd1fe75b02 100644
--- a/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetResult_Tests.cs
@@ -2,19 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Xml;
-using System.Text;
-using System.Collections;
-using System.Collections.Generic;
-using System.Text.RegularExpressions;
-using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Unittest;
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Xunit;
 
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index 34522d98c12..1c3da30e0c7 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -3,12 +3,9 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Threading;
 using System.Xml;
-using System.Text;
-using System.Globalization;
 using System.Runtime.InteropServices;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
@@ -19,7 +16,6 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using FILETIME = System.Runtime.InteropServices.ComTypes.FILETIME;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs b/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
index 6c0a6f6b6e7..c0341747d64 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
@@ -5,7 +5,6 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
 using Microsoft.Build.Framework;
 using System.Reflection;
 
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 3fb73caa140..ed6ff1db561 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -19,8 +19,6 @@
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
 using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
 using LegacyThreadingData = Microsoft.Build.Execution.LegacyThreadingData;
-using TargetDotNetFrameworkVersion = Microsoft.Build.Utilities.TargetDotNetFrameworkVersion;
-using ToolLocationHelper = Microsoft.Build.Utilities.ToolLocationHelper;
 using Xunit;
 using Xunit.Abstractions;
 
@@ -859,7 +857,7 @@ private void TestSTATask(bool requireSTA, bool failTask, bool throwException)
             MockLogger logger = new MockLogger();
             logger.AllowTaskCrashes = throwException;
 
-            string taskAssemblyName = null;
+            string taskAssemblyName;
             Project project = CreateSTATestProject(requireSTA, failTask, throwException, out taskAssemblyName);
 
             List<ILogger> loggers = new List<ILogger>();
diff --git a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
index e13787dfe95..62a6e1a3d56 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
@@ -4,9 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Globalization;
 using System.IO;
-using System.Reflection;
 using System.Threading;
 
 
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 5183dfd69b1..897b6a5751f 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -2,13 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 using System;
 using System.Diagnostics;
-using System.Threading;
 using Microsoft.Build.Execution;
 using Microsoft.Build.UnitTests;
-using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
-using Xunit.Abstractions;
 
 namespace Microsoft.Build.Engine.UnitTests.BackEnd
 {
diff --git a/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs
index bcc19f07353..60ad45a978d 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostTaskCancelled_Tests.cs
@@ -1,13 +1,9 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Text;
-using System.Collections.Generic;
-using System.Linq;
-
 using Microsoft.Build.BackEnd;
 using Xunit;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -35,8 +31,7 @@ public void TestTranslation()
 
             ((ITranslatable)cancelled).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskCancelled.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
-
-            TaskHostTaskCancelled deserializedCancelled = packet as TaskHostTaskCancelled;
+            packet.ShouldBeOfType<TaskHostTaskCancelled>();
         }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
index e604a3b4627..b6be946a836 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
 
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
diff --git a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
index 058e83a79dd..3996c7221e8 100644
--- a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
@@ -11,7 +11,6 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Collections;
 using System.Collections;
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Unittest;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using System.Threading.Tasks;
diff --git a/src/Build.UnitTests/BackEnd/TaskItemComparer.cs b/src/Build.UnitTests/BackEnd/TaskItemComparer.cs
index cc128524ac9..61e423692eb 100644
--- a/src/Build.UnitTests/BackEnd/TaskItemComparer.cs
+++ b/src/Build.UnitTests/BackEnd/TaskItemComparer.cs
@@ -1,10 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
index ea5f9abdd9b..ecdfc421d3c 100644
--- a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Linq;
 using System.Reflection;
@@ -19,7 +18,6 @@
 using Microsoft.Build.Shared.FileSystem;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Microsoft.Build.Utilities;
-using Microsoft.CodeAnalysis.BuildTasks;
 using Shouldly;
 using Xunit;
 
@@ -2007,7 +2005,7 @@ private void RetrieveAndValidateRegisteredTaskRecord
                                                             string expectedArchitecture
                                                         )
         {
-            bool retrievedFromCache = false;
+            bool retrievedFromCache;
             var record = registry.GetTaskRegistrationRecord(TestTaskName, null, taskParameters, exactMatchRequired, _targetLoggingContext, _elementLocation, out retrievedFromCache);
 
             if (shouldBeRetrieved)
diff --git a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
index 425cafecbbd..aaf86e1ad25 100644
--- a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
+++ b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
@@ -4,9 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
 using System.IO;
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.UnitTests.BackEnd
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index a797ef0a01c..ec95009bec1 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -1,6 +1,4 @@
 ﻿using System;
-using System.Diagnostics;
-using System.IO;
 using Microsoft.Build.Logging;
 using Xunit;
 using Xunit.Abstractions;
diff --git a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
index 4f351e50bbe..8382f53d95d 100644
--- a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
+++ b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
@@ -1,12 +1,6 @@
 ﻿using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
diff --git a/src/Build.UnitTests/BuildResultUtilities.cs b/src/Build.UnitTests/BuildResultUtilities.cs
index ab0d27d2f17..244fee76119 100644
--- a/src/Build.UnitTests/BuildResultUtilities.cs
+++ b/src/Build.UnitTests/BuildResultUtilities.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
diff --git a/src/Build.UnitTests/ChangeWaves_Tests.cs b/src/Build.UnitTests/ChangeWaves_Tests.cs
new file mode 100644
index 00000000000..4574dee52b8
--- /dev/null
+++ b/src/Build.UnitTests/ChangeWaves_Tests.cs
@@ -0,0 +1,319 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Xunit;
+using Shouldly;
+using Microsoft.Build.Utilities;
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests;
+using Xunit.Abstractions;
+using Microsoft.Build.Evaluation;
+
+namespace Microsoft.Build.Engine.UnitTests
+{
+    sealed public class ChangeWaves_Tests
+    {
+        ITestOutputHelper _output;
+        public ChangeWaves_Tests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        [Theory]
+        [InlineData("16.8")]
+        [InlineData("16.10")]
+        [InlineData("17.0")]
+        [InlineData("25.87")]
+        [InlineData("102.87")]
+        public void EnableAllFeaturesBehindChangeWavesEnablesAllFeaturesBehindChangeWaves(string featureWave)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                env.SetChangeWave(ChangeWaves.EnableAllFeatures);
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+                ChangeWaves.AreFeaturesEnabled(featureWave).ShouldBe(true);
+
+                string projectFile = $"" +
+                    $"<Project>" +
+                        $"<Target Name='HelloWorld' Condition=\"'$(MSBUILDDISABLEFEATURESFROMVERSION)' == '{ChangeWaves.EnableAllFeatures}' and $([MSBuild]::AreFeaturesEnabled('{featureWave}'))\">" +
+                            $"<Message Text='Hello World!'/>" +
+                        $"</Target>" +
+                    $"</Project>";
+
+                TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
+
+                ProjectCollection collection = new ProjectCollection();
+                MockLogger log = new MockLogger();
+                collection.RegisterLogger(log);
+
+                collection.LoadProject(file.Path).Build().ShouldBeTrue();
+                log.AssertLogContains("Hello World!");
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+            }
+        }
+
+        [Theory]
+        [InlineData("16.8")]
+        [InlineData("16.10")]
+        [InlineData("17.0")]
+        [InlineData("27.3")]
+        public void NoChangeWaveSetMeansAllChangeWavesAreEnabled(string featureWave)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                ChangeWaves.AreFeaturesEnabled(featureWave).ShouldBe(true);
+
+                string projectFile = $"" +
+                    $"<Project>" +
+                        $"<Target Name='HelloWorld' Condition=\"'$(MSBUILDDISABLEFEATURESFROMVERSION)' == '{ChangeWaves.EnableAllFeatures}' and $([MSBuild]::AreFeaturesEnabled('{featureWave}'))\">" +
+                            $"<Message Text='Hello World!'/>" +
+                        $"</Target>" +
+                    $"</Project>";
+
+                TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
+
+                ProjectCollection collection = new ProjectCollection();
+                MockLogger log = new MockLogger();
+                collection.RegisterLogger(log);
+
+                collection.LoadProject(file.Path).Build().ShouldBeTrue();
+                log.AssertLogContains("Hello World!");
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+            }
+        }
+
+        [Theory]
+        [InlineData("test")]
+        [InlineData("    ")]
+        [InlineData("")]
+        [InlineData("16-7")]
+        [InlineData("16x7")]
+        [InlineData("16=7")]
+        public void InvalidCallerForIsFeatureEnabledThrows(string waveToCheck)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                env.SetChangeWave("16.8");
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+                Shouldly.Should.Throw<InternalErrorException>(() => ChangeWaves.AreFeaturesEnabled(waveToCheck));
+            }
+        }
+
+        [Theory]
+        [InlineData("test", "16.8")]
+        [InlineData("16_8", "5.7")]
+        [InlineData("16x8", "20.4")]
+        [InlineData("garbage", "18.20")]
+        public void InvalidFormatThrowsWarningAndLeavesFeaturesEnabled(string disableFromWave, string featureWave)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                env.SetChangeWave(disableFromWave);
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+                ChangeWaves.AreFeaturesEnabled(featureWave).ShouldBe(true);
+
+                string projectFile = $"" +
+                    $"<Project>" +
+                        $"<Target Name='HelloWorld' Condition=\"'$(MSBUILDDISABLEFEATURESFROMVERSION)' == '{ChangeWaves.EnableAllFeatures}' and $([MSBuild]::AreFeaturesEnabled('{featureWave}'))\">" +
+                            $"<Message Text='Hello World!'/>" +
+                        $"</Target>" +
+                    $"</Project>";
+
+                TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
+
+                ProjectCollection collection = new ProjectCollection();
+                MockLogger log = new MockLogger();
+                collection.RegisterLogger(log);
+
+                Project p = collection.LoadProject(file.Path);
+                p.Build().ShouldBeTrue();
+
+                log.WarningCount.ShouldBe(1);
+                log.AssertLogContains("invalid format");
+                log.AssertLogContains("Hello World!");
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+            }
+        }
+
+        [Theory]
+        [InlineData("0.8")]
+        [InlineData("4.5")]
+        [InlineData("10.0")]
+        public void VersionTooLowClampsToLowestVersionInRotation(string disableFromWave)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                env.SetChangeWave(disableFromWave);
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                // All waves should be disabled
+                for (int i = 0; i < ChangeWaves.AllWaves.Length; i++)
+                {
+                    ChangeWaves.ResetStateForTests();
+                    string projectFile = $"" +
+                        $"<Project>" +
+                            $"<Target Name='HelloWorld' Condition=\"'$(MSBUILDDISABLEFEATURESFROMVERSION)' == '{ChangeWaves.LowestWave}' and $([MSBuild]::AreFeaturesEnabled('{ChangeWaves.AllWaves[i]}')) == false\">" +
+                                $"<Message Text='Hello World!'/>" +
+                            $"</Target>" +
+                        $"</Project>";
+
+                    TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
+
+                    ProjectCollection collection = new ProjectCollection();
+                    MockLogger log = new MockLogger();
+                    collection.RegisterLogger(log);
+
+                    Project p = collection.LoadProject(file.Path);
+                    p.Build().ShouldBeTrue();
+
+                    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                    log.WarningCount.ShouldBe(1);
+                    log.AssertLogContains("out of rotation");
+                    log.AssertLogContains("Hello World!");
+                }
+
+            }
+        }
+
+        [Theory]
+        [InlineData("100.10")]
+        [InlineData("203.45")]
+        public void VersionTooHighClampsToHighestVersionInRotation(string disableFromWave)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                env.SetChangeWave(disableFromWave);
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                // all waves but the highest should pass
+                for (int i = 0; i < ChangeWaves.AllWaves.Length-1; i++)
+                {
+                    ChangeWaves.ResetStateForTests();
+                    string projectFile = $"" +
+                        $"<Project>" +
+                            $"<Target Name='HelloWorld' Condition=\"'$(MSBUILDDISABLEFEATURESFROMVERSION)' == '{ChangeWaves.HighestWave}' and $([MSBuild]::AreFeaturesEnabled('{ChangeWaves.AllWaves[i]}'))\">" +
+                                $"<Message Text='Hello World!'/>" +
+                            $"</Target>" +
+                        $"</Project>";
+
+                    TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
+
+                    ProjectCollection collection = new ProjectCollection();
+                    MockLogger log = new MockLogger();
+                    collection.RegisterLogger(log);
+
+                    Project p = collection.LoadProject(file.Path);
+                    p.Build().ShouldBeTrue();
+
+                    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                    log.WarningCount.ShouldBe(1);
+                    log.AssertLogContains("out of rotation");
+                    log.AssertLogContains("Hello World!");
+                }
+            }
+        }
+
+        [Fact]
+        public void VersionSetToValidValueButInvalidVersionSetsNextVersion()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                env.SetChangeWave($"{ChangeWaves.LowestWaveAsVersion.Major}.{ChangeWaves.LowestWaveAsVersion.Minor}.{ChangeWaves.LowestWaveAsVersion.Build+1}");
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                // All waves should be disabled
+                    string projectFile = $"" +
+                        $"<Project>" +
+                            $"<Target Name='HelloWorld' Condition=\"'$(MSBUILDDISABLEFEATURESFROMVERSION)' == '{ChangeWaves.AllWaves[1]}' and $([MSBuild]::AreFeaturesEnabled('{ChangeWaves.LowestWave}'))\">" +
+                                $"<Message Text='Hello World!'/>" +
+                            $"</Target>" +
+                        $"</Project>";
+
+                    TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
+
+                    ProjectCollection collection = new ProjectCollection();
+                    MockLogger log = new MockLogger();
+                    collection.RegisterLogger(log);
+
+                    Project p = collection.LoadProject(file.Path);
+                    p.Build().ShouldBeTrue();
+
+                    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+                    log.AssertLogContains("Hello World!");
+
+            }
+        }
+
+        [Fact]
+        public void CorrectlyDetermineEnabledFeatures()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                env.SetChangeWave(ChangeWaves.HighestWave);
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                for (int i = 0; i < ChangeWaves.AllWaves.Length-1; i++)
+                {
+                    ChangeWaves.DisabledWave = null;
+                    ChangeWaves.AreFeaturesEnabled(ChangeWaves.AllWaves[i]).ShouldBe(true);
+
+                    string projectFile = $"" +
+                        $"<Project>" +
+                            $"<Target Name='HelloWorld' Condition=\"$([MSBuild]::AreFeaturesEnabled('{ChangeWaves.AllWaves[i]}'))\">" +
+                                $"<Message Text='Hello World!'/>" +
+                            $"</Target>" +
+                        $"</Project>";
+
+                    TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
+
+                    ProjectCollection collection = new ProjectCollection();
+                    MockLogger log = new MockLogger();
+                    collection.RegisterLogger(log);
+
+                    Project p = collection.LoadProject(file.Path);
+                    p.Build().ShouldBeTrue();
+
+                    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+                    log.AssertLogContains("Hello World!");
+                }
+            }
+        }
+
+        [Fact]
+        public void CorrectlyDetermineDisabledFeatures()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                env.SetChangeWave(ChangeWaves.LowestWave);
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                foreach (string wave in ChangeWaves.AllWaves)
+                {
+                    ChangeWaves.AreFeaturesEnabled(wave).ShouldBeFalse();
+
+                    string projectFile = $"" +
+                        $"<Project>" +
+                            $"<Target Name='HelloWorld' Condition=\"$([MSBuild]::AreFeaturesEnabled('{wave}')) == false\">" +
+                                $"<Message Text='Hello World!'/>" +
+                            $"</Target>" +
+                        $"</Project>";
+
+                    TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
+
+                    ProjectCollection collection = new ProjectCollection();
+                    MockLogger log = new MockLogger();
+                    collection.RegisterLogger(log);
+
+                    Project p = collection.LoadProject(file.Path);
+                    p.Build().ShouldBeTrue();
+
+                    log.AssertLogContains("Hello World!");
+                }
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+            }
+        }
+    }
+}
diff --git a/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs b/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
index 2a56bf4a8c0..85ae11ffcdf 100644
--- a/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
+++ b/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Collections.Generic;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
diff --git a/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs b/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs
index d0e5debefff..63d31dd25bf 100644
--- a/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs
+++ b/src/Build.UnitTests/Collections/MultiDictionary_Tests.cs
@@ -4,12 +4,6 @@
 using System.Collections.Generic;
 using Microsoft.Build.Collections;
 using System;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.UnitTests;
-using System.Collections;
-using Microsoft.Build.Execution;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Construction;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.OM.Collections
diff --git a/src/Build.UnitTests/Collections/OMcollections_tests.cs b/src/Build.UnitTests/Collections/OMcollections_tests.cs
index a2c9c2ac165..4dfcbb75209 100644
--- a/src/Build.UnitTests/Collections/OMcollections_tests.cs
+++ b/src/Build.UnitTests/Collections/OMcollections_tests.cs
@@ -5,13 +5,10 @@
 using Microsoft.Build.Collections;
 using System;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.UnitTests;
-using Microsoft.Build.Framework;
 using System.Collections;
 using System.Linq;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Construction;
 using Microsoft.Build.UnitTests.BackEnd;
 using Shouldly;
 using ObjectModel = System.Collections.ObjectModel;
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 7785cf334ff..0457c2005f2 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -16,7 +16,6 @@
 
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
-using Microsoft.Build.Evaluation;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -1422,10 +1421,9 @@ private void WriteAndValidateProperties(BaseConsoleLogger cl, SimulatedConsole s
             properties.Add("prop1", "val1");
             properties.Add("prop2", "val2");
             properties.Add("pro(p3)", "va%3b%253b%3bl3");
-            string prop1 = string.Empty;
-            string prop2 = string.Empty;
-            string prop3 = string.Empty;
-
+            string prop1;
+            string prop2;
+            string prop3;
             if (cl is SerialConsoleLogger)
             {
                 var propertyList = ((SerialConsoleLogger)cl).ExtractPropertyList(properties);
@@ -1624,7 +1622,7 @@ private void WriteEnvironment(BaseConsoleLogger cl, SimulatedConsole sc, bool ex
             // Being careful not to make locale assumptions here, eg about sorting
             foreach (KeyValuePair<string, string> kvp in _environment)
             {
-                string message = String.Empty;
+                string message;
                 if (cl is ParallelConsoleLogger)
                 {
                     message = String.Format(CultureInfo.CurrentCulture, "{0} = {1}", kvp.Key, kvp.Value);
@@ -1665,12 +1663,12 @@ private void WriteAndValidateItems(BaseConsoleLogger cl, SimulatedConsole sc, bo
 
             items.Add("type(3)", taskItem3);
 
-            string item1type = string.Empty;
-            string item2type = string.Empty;
-            string item3type = string.Empty;
-            string item1spec = string.Empty;
-            string item2spec = string.Empty;
-            string item3spec = string.Empty;
+            string item1type;
+            string item2type;
+            string item3type;
+            string item1spec;
+            string item2spec;
+            string item3spec;
             string item3metadatum = string.Empty;
 
             if (cl is SerialConsoleLogger)
diff --git a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
index dd48d7391e5..505088d7f86 100644
--- a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
+++ b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
@@ -1,14 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
-using Microsoft.Build.Collections;
 using System;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.UnitTests;
-using Microsoft.Build.Framework;
-using System.Collections;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Construction;
@@ -17,7 +10,6 @@
 using System.IO;
 using System.Reflection;
 using Xunit;
-using System.Text;
 using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.UnitTests.Construction
@@ -493,9 +485,7 @@ private string GetLocations(string content, bool readOnly)
                     }
                 }
 
-                locations = locations.Replace(file, "c:\\foo\\bar.csproj");
-
-                return locations;
+                return locations.Replace(file, "c:\\foo\\bar.csproj");
             }
             finally
             {
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index a543f998d48..ea03579a917 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -7,7 +7,6 @@
 using System.IO;
 
 using Microsoft.Build.Construction;
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Shared;
 using Shouldly;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
@@ -1224,6 +1223,49 @@ public void MissingNestedProject()
             Assert.True(false);
         }
 
+        /// <summary>
+        /// Checks whether incorrect nesting found within the solution file is reported MSB5009 error
+        /// with the incorrectly nested project's name and it's GUID
+        /// </summary>
+        [Fact]
+        public void IncorrectlyNestedProjectErrorContainsProjectNameAndGuid()
+        {
+            string solutionFileContents =
+                @"
+                Microsoft Visual Studio Solution File, Format Version 9.00
+                # Visual Studio 2005
+                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'SolutionFolder', 'SolutionFolder', '{5EE89BD0-04E3-4600-9CF2-D083A77A9448}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ConsoleApp1', 'ConsoleApp1\ConsoleApp1.csproj', '{1484A47E-F4C5-4700-B13F-A2BDB6ADD35E}'
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {1484A47E-F4C5-4700-B13F-A2BDB6ADD35E}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {1484A47E-F4C5-4700-B13F-A2BDB6ADD35E}.Release|Any CPU.Build.0 = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                    GlobalSection(NestedProjects) = preSolution
+                        {1484A47E-F4C5-4700-B13F-A2BDB6ADD35E} = {5EE89BD0-04E3-4600-9CF2-D083A77A9448}
+                        {1484A47E-F4C5-4700-B13F-A2BDB6ADD35E} = {5EE89BD0-04E3-4600-9CF2-D083A77A9449}
+                    EndGlobalSection
+                    GlobalSection(ExtensibilityGlobals) = postSolution
+                        SolutionGuid = {AF600A67-B616-453E-9B27-4407D654F66E}
+                    EndGlobalSection
+                EndGlobal
+                ";
+
+            InvalidProjectFileException e = Should.Throw<InvalidProjectFileException>(() => ParseSolutionHelper(solutionFileContents));
+
+            e.ErrorCode.ShouldBe("MSB5009");
+            e.Message.ShouldContain("{1484A47E-F4C5-4700-B13F-A2BDB6ADD35E}");
+            e.Message.ShouldContain("ConsoleApp1");
+        }
 
         /// <summary>
         /// Verifies that we correctly identify solution folders and mercury non-buildable projects both as
@@ -1813,6 +1855,61 @@ public void ParseInvalidSolutionConfigurations3()
             }
            );
         }
+
+        /// <summary>
+        /// Test some invalid cases for solution configuration parsing
+        /// Each project in the solution should end with EndProject.
+        /// If it doesn't then each next project should still be parsed correctly.
+        /// Which means even if a project is missing it's EndProject, next projects are still found and are parsed correctly.
+        /// </summary>
+        [Fact]
+        public void ParseAllProjectsContainedInInvalidSolutionEvenWhenMissingEndProject()
+        {
+            string solutionFileContents =
+                @"
+                Microsoft Visual Studio Solution File, Format Version 9.00
+                # Visual Studio 2005
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary', 'ClassLibrary\ClassLibrary.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
+                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'SomeLowLevelLayerProject', 'Layers\SomeLowLevelLayerProject.csproj', '{E8E75132-67E4-4D6F-9CAE-8DA4C883F419}'
+                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'SomeHighLevelLayerProject', 'Layers\SomeHighLevelLayerProject.csproj', '{D2633E4D-46FF-4C4E-8340-4BC7CDF78615}'
+                Project('{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}') = 'MainApp', 'MainApp\MainApp.vcxproj', '{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}'
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|x86 = Debug|x86
+                        Release|x86 = Release|x86
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|x86.ActiveCfg = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|x86.ActiveCfg = Release|Any CPU
+                        {A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Debug|x86.ActiveCfg = Debug|Any CPU
+                        {A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|x86.ActiveCfg = Release|Any CPU
+                        {E8E75132-67E4-4D6F-9CAE-8DA4C883F419}.Debug|x86.ActiveCfg = Debug|Any CPU
+                        {E8E75132-67E4-4D6F-9CAE-8DA4C883F419}.Release|x86.ActiveCfg = Release|Any CPU
+                        {D2633E4D-46FF-4C4E-8340-4BC7CDF78615}.Debug|x86.ActiveCfg = Debug|Any CPU
+                        {D2633E4D-46FF-4C4E-8340-4BC7CDF78615}.Release|x86.ActiveCfg = Release|Any CPU
+                   EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                ";
+
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+
+            // What is needed to be checked is whether there were still both projects found in the invalid solution file
+            ProjectInSolution classLibraryProject = (ProjectInSolution)solution.ProjectsByGuid["{6185CC21-BE89-448A-B3C0-D1C27112E595}"];
+            ProjectInSolution mainAppProject = (ProjectInSolution)solution.ProjectsByGuid["{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}"];
+            ProjectInSolution lowLevelProject = (ProjectInSolution)solution.ProjectsByGuid["{E8E75132-67E4-4D6F-9CAE-8DA4C883F419}"];
+            ProjectInSolution highLevelProject = (ProjectInSolution)solution.ProjectsByGuid["{D2633E4D-46FF-4C4E-8340-4BC7CDF78615}"];
+            mainAppProject.GetUniqueProjectName().ShouldNotBe(classLibraryProject.GetUniqueProjectName());
+            classLibraryProject.GetUniqueProjectName().ShouldBe("ClassLibrary");
+            mainAppProject.GetUniqueProjectName().ShouldBe("MainApp");
+            lowLevelProject.GetUniqueProjectName().ShouldNotBe(highLevelProject.GetUniqueProjectName());
+            lowLevelProject.GetUniqueProjectName().ShouldBe("SomeLowLevelLayerProject");
+            highLevelProject.GetUniqueProjectName().ShouldBe("SomeHighLevelLayerProject");
+        }
+
         /// <summary>
         /// Make sure the project configurations in solution configurations get parsed correctly
         /// for a simple mixed C#/VC solution
@@ -1971,5 +2068,337 @@ public void ParseProjectConfigurationsInSolutionConfigurations2()
             Assert.Equal("Debug", solution.GetDefaultConfigurationName()); // "Default solution configuration"
             Assert.Equal(".NET", solution.GetDefaultPlatformName()); // "Default solution platform"
         }
+
+        [Fact]
+        public void ParseSolutionFileContainingProjectsWithParentSlnFolder()
+        {
+            string solutionFileContents = @"
+                Microsoft Visual Studio Solution File, Format Version 9.00
+                # Visual Studio 2005
+                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'MySlnFolder', 'MySlnFolder', '{E0F97730-25D2-418A-A7BD-02CAFDC6E470}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'MyPhysicalFolder\Folder1\Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'MyPhysicalFolder\Folder2\Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		        {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		        {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+		        {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		        {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                    GlobalSection(NestedProjects) = preSolution
+                        {FC2889D9-6050-4D2E-B022-979CCFEEAAAC} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
+                        {ED30D4A3-1214-410B-82BB-B61E5A9D05CA} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
+                    EndGlobalSection
+                EndGlobal
+                ";
+
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+
+            ProjectInSolution project1 = (ProjectInSolution)solution.ProjectsByGuid["{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}"];
+            ProjectInSolution project2 = (ProjectInSolution)solution.ProjectsByGuid["{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}"];
+
+            project2.GetUniqueProjectName().ShouldNotBe(project1.GetUniqueProjectName());
+            project1.GetUniqueProjectName().ShouldBe(@"MySlnFolder\Project_Named_With_Dots");
+            project2.GetUniqueProjectName().ShouldBe(@"MySlnFolder\Project_Named_With_Dots_ED30D4A3-1214-410B-82BB-B61E5A9D05CA");
+            project1.GetOriginalProjectName().ShouldBe(@"MySlnFolder\Project.Named.With.Dots");
+            project2.GetOriginalProjectName().ShouldBe(@"MySlnFolder\Project_Named_With_Dots");
+        }
+
+        [Theory]
+        [InlineData(@"
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 15
+                VisualStudioVersion = 15.0.27130.2010
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Global
+	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                Release|Any CPU = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(SolutionProperties) = preSolution
+		                HideSolutionNode = FALSE
+	                EndGlobalSection
+	                GlobalSection(ExtensibilityGlobals) = postSolution
+		                SolutionGuid = {C038ED6B-BFC1-4E50-AE2E-7993F6883D7F}
+	                EndGlobalSection
+                EndGlobal
+                ")]
+        [InlineData(@"
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 15
+                VisualStudioVersion = 15.0.27130.2010
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Global
+	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                Release|Any CPU = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(SolutionProperties) = preSolution
+		                HideSolutionNode = FALSE
+	                EndGlobalSection
+	                GlobalSection(ExtensibilityGlobals) = postSolution
+		                SolutionGuid = {C038ED6B-BFC1-4E50-AE2E-7993F6883D7F}
+	                EndGlobalSection
+                EndGlobal
+                ")]
+        public void ParseSolutionFileContainingProjectsWithSimilarNames_TwoProjects(string solutionFileContents)
+        {
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+
+            ProjectInSolution project1 = (ProjectInSolution)solution.ProjectsByGuid["{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}"];
+            ProjectInSolution project2 = (ProjectInSolution)solution.ProjectsByGuid["{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}"];
+
+            project2.GetUniqueProjectName().ShouldNotBe(project1.GetUniqueProjectName());
+            project1.GetUniqueProjectName().ShouldBe("Project_Named_With_Dots_FC2889D9-6050-4D2E-B022-979CCFEEAAAC");
+            project2.GetUniqueProjectName().ShouldBe("Project_Named_With_Dots");
+            project1.GetOriginalProjectName().ShouldBe("Project.Named.With.Dots");
+            project2.GetOriginalProjectName().ShouldBe("Project_Named_With_Dots");
+        }
+
+        [Theory]
+        [InlineData(@"
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 15
+                VisualStudioVersion = 15.0.27130.2010
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With.Dots', 'Project_Named_With.Dots.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Global
+	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                Release|Any CPU = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(SolutionProperties) = preSolution
+		                HideSolutionNode = FALSE
+	                EndGlobalSection
+	                GlobalSection(ExtensibilityGlobals) = postSolution
+		                SolutionGuid = {C038ED6B-BFC1-4E50-AE2E-7993F6883D7F}
+	                EndGlobalSection
+                EndGlobal
+                ")]
+        [InlineData(@"
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 15
+                VisualStudioVersion = 15.0.27130.2010
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With.Dots', 'Project_Named_With.Dots.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
+                EndProject
+                Global
+	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                Release|Any CPU = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(SolutionProperties) = preSolution
+		                HideSolutionNode = FALSE
+	                EndGlobalSection
+	                GlobalSection(ExtensibilityGlobals) = postSolution
+		                SolutionGuid = {C038ED6B-BFC1-4E50-AE2E-7993F6883D7F}
+	                EndGlobalSection
+                EndGlobal
+                ")]
+        public void ParseSolutionFileContainingProjectsWithSimilarNames_ThreeProjects(string solutionFileContents)
+        {
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+
+            ProjectInSolution project1 = (ProjectInSolution)solution.ProjectsByGuid["{6185CC21-BE89-448A-B3C0-D1C27112E595}"];
+            ProjectInSolution project2 = (ProjectInSolution)solution.ProjectsByGuid["{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}"];
+            ProjectInSolution project3 = (ProjectInSolution)solution.ProjectsByGuid["{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}"];
+
+            project2.GetUniqueProjectName().ShouldNotBe(project1.GetUniqueProjectName());
+            project3.GetUniqueProjectName().ShouldNotBe(project2.GetUniqueProjectName());
+            project3.GetUniqueProjectName().ShouldNotBe(project1.GetUniqueProjectName());
+
+            project1.GetUniqueProjectName().ShouldBe("Project_Named_With_Dots_6185CC21-BE89-448A-B3C0-D1C27112E595");
+            project2.GetUniqueProjectName().ShouldBe("Project_Named_With_Dots_FC2889D9-6050-4D2E-B022-979CCFEEAAAC");
+            project3.GetUniqueProjectName().ShouldBe("Project_Named_With_Dots");
+
+            project1.GetOriginalProjectName().ShouldBe("Project_Named_With.Dots");
+            project2.GetOriginalProjectName().ShouldBe("Project.Named.With.Dots");
+            project3.GetOriginalProjectName().ShouldBe("Project_Named_With_Dots");
+        }
+
+        [Fact]
+        public void ParseSolutionFileContainingProjectsWithSimilarNames_ThreeProjects_OneNormalizedDuplicated()
+        {
+            string solutionFileContents =
+                @"
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 15
+                VisualStudioVersion = 15.0.27130.2010
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
+                EndProject
+                Global
+	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                Release|Any CPU = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(SolutionProperties) = preSolution
+		                HideSolutionNode = FALSE
+	                EndGlobalSection
+	                GlobalSection(ExtensibilityGlobals) = postSolution
+		                SolutionGuid = {C038ED6B-BFC1-4E50-AE2E-7993F6883D7F}
+	                EndGlobalSection
+                EndGlobal
+                ";
+
+            Action parseSolution = () => ParseSolutionHelper(solutionFileContents);
+            var exception = Assert.Throws<InvalidProjectFileException>(parseSolution);
+
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, "SolutionParseDuplicateProject", "Project.Named.With.Dots");
+
+            exception.Message.ShouldStartWith(message);
+        }
+
+        [Fact]
+        public void ParseSolutionFileContainingProjectsWithSimilarNames_ThreeProjects_OneDuplicated()
+        {
+            string solutionFileContents =
+                @"
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 15
+                VisualStudioVersion = 15.0.27130.2010
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
+                EndProject
+                Global
+	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                Release|Any CPU = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(SolutionProperties) = preSolution
+		                HideSolutionNode = FALSE
+	                EndGlobalSection
+	                GlobalSection(ExtensibilityGlobals) = postSolution
+		                SolutionGuid = {C038ED6B-BFC1-4E50-AE2E-7993F6883D7F}
+	                EndGlobalSection
+                EndGlobal
+                ";
+
+            Action parseSolution = () => ParseSolutionHelper(solutionFileContents);
+            var exception = Assert.Throws<InvalidProjectFileException>(parseSolution);
+
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, "SolutionParseDuplicateProject", "Project_Named_With_Dots");
+
+            exception.Message.ShouldStartWith(message);
+        }
+
+        [Fact]
+        public void ParseSolutionFileContainingProjectsWithSimilarNames_FourProjects_OneDuplicated()
+        {
+            string solutionFileContents =
+                @"
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 15
+                VisualStudioVersion = 15.0.27130.2010
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project.Named.With.Dots', 'Project.Named.With.Dots.csproj', '{FC2889D9-6050-4D2E-B022-979CCFEEAAAC}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{ED30D4A3-1214-410B-82BB-B61E5A9D05CA}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With.Dots', 'Project_Named_With.Dots.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
+                EndProject
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Project_Named_With_Dots', 'Project_Named_With_Dots.csproj', '{AD0F3D02-9925-4D57-9DAF-E0A9D936ABDB}'
+                EndProject
+                Global
+	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                Release|Any CPU = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {FC2889D9-6050-4D2E-B022-979CCFEEAAAC}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {ED30D4A3-1214-410B-82BB-B61E5A9D05CA}.Release|Any CPU.Build.0 = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+	                EndGlobalSection
+	                GlobalSection(SolutionProperties) = preSolution
+		                HideSolutionNode = FALSE
+	                EndGlobalSection
+	                GlobalSection(ExtensibilityGlobals) = postSolution
+		                SolutionGuid = {C038ED6B-BFC1-4E50-AE2E-7993F6883D7F}
+	                EndGlobalSection
+                EndGlobal
+                ";
+
+            Action parseSolution = () => ParseSolutionHelper(solutionFileContents);
+            var exception = Assert.Throws<InvalidProjectFileException>(parseSolution);
+
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, "SolutionParseDuplicateProject", "Project_Named_With_Dots");
+
+            exception.Message.ShouldStartWith(message);
+        }
     }
 }
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 89da8a06c20..45b18658d45 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -2,20 +2,14 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Diagnostics;
-using System.Reflection;
-using System.Text;
 using System.IO;
-using System.Xml;
 using System.Linq;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Unittest;
 
 using LoggingService = Microsoft.Build.BackEnd.Logging.LoggingService;
 using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
@@ -114,15 +108,17 @@ public void SolutionFilterFiltersProjects()
                   </Target>
                   </Project>
                     ");
+
+                // Slashes here (and in the .slnf) are hardcoded as backslashes intentionally to support the common case.
                 TransientTestFile solutionFile = testEnvironment.CreateFile(simpleProjectFolder, "SimpleProject.sln",
                     @"
                     Microsoft Visual Studio Solution File, Format Version 12.00
                     # Visual Studio Version 16
                     VisualStudioVersion = 16.0.29326.124
                     MinimumVisualStudioVersion = 10.0.40219.1
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""SimpleProject"", """ + Path.Combine("SimpleProject", "SimpleProject.csproj") + @""", ""{79B5EBA6-5D27-4976-BC31-14422245A59A}""
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""SimpleProject"", ""SimpleProject\SimpleProject.csproj"", ""{79B5EBA6-5D27-4976-BC31-14422245A59A}""
                     EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""ClassLibrary"", """ + Path.Combine("..", "ClassLibrary", "ClassLibrary", "ClassLibrary.csproj") + @""", ""{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}""
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""ClassLibrary"", ""..\ClassLibrary\ClassLibrary\ClassLibrary.csproj"", ""{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}""
                     EndProject
                     Global
                         GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -155,9 +151,9 @@ public void SolutionFilterFiltersProjects()
                     @"
                 {
                   ""solution"": {
-                    ""path"": """ + Path.Combine(".", "SimpleProject", "SimpleProject.sln").Replace("\\", "\\\\") + @""",
+                    ""path"": "".\\SimpleProject\\SimpleProject.sln"",
                     ""projects"": [
-                      """ + Path.Combine("SimpleProject", "SimpleProject.csproj").Replace("\\", "\\\\") + @"""
+                      ""SimpleProject\\SimpleProject.csproj""
                     ]
                     }
                 }
@@ -203,9 +199,8 @@ public void AddNewErrorWarningMessageElement()
             Project project = new Project(projectXml);
 
             project.Build(logger);
-
-            string code = null;
-            string keyword = null;
+            string code;
+            string keyword;
             string text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out code, out keyword, "SolutionParseUnknownProjectType", "proj1.csproj");
 
             // check the error event
@@ -215,9 +210,6 @@ public void AddNewErrorWarningMessageElement()
             Assert.Equal(text, warning.Message);
             Assert.Equal(code, warning.Code);
             Assert.Equal(keyword, warning.HelpKeyword);
-
-            code = null;
-            keyword = null;
             text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out code, out keyword, "SolutionInvalidSolutionConfiguration");
 
             // check the warning event
@@ -227,9 +219,6 @@ public void AddNewErrorWarningMessageElement()
             Assert.Equal(text, error.Message);
             Assert.Equal(code, error.Code);
             Assert.Equal(keyword, error.HelpKeyword);
-
-            code = null;
-            keyword = null;
             text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out code, out keyword, "SolutionVenusProjectNoClean");
 
             // check the message event
@@ -1317,8 +1306,6 @@ public void ToolsVersionOverrideCausesToolsetRedirect()
                     EndGlobalSection
                 EndGlobal
                 ";
-
-            ProjectInstance[] instances = null;
             SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
             bool caughtException = false;
 
@@ -1326,7 +1313,7 @@ public void ToolsVersionOverrideCausesToolsetRedirect()
             {
                 // SolutionProjectGenerator.Generate() is used at build-time, and creates evaluation- and 
                 // execution-model projects; as such it will throw if fed an explicitly invalid toolsversion
-                instances = SolutionProjectGenerator.Generate(solution, null, "invalid", _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, "invalid", _buildEventContext, CreateMockLoggingService());
             }
             catch (InvalidProjectFileException)
             {
@@ -1730,9 +1717,7 @@ public void SolutionGeneratorEscapingProjectFilePaths()
                 EndGlobal
                 ";
 
-            SolutionFile solution = null;
-
-            solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
 
             // Creating a ProjectRootElement shouldn't affect the ProjectCollection at all
             Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
diff --git a/src/Build.UnitTests/Construction/XmlReaderWithoutLocation_Tests.cs b/src/Build.UnitTests/Construction/XmlReaderWithoutLocation_Tests.cs
index ef650454078..16878ee979c 100644
--- a/src/Build.UnitTests/Construction/XmlReaderWithoutLocation_Tests.cs
+++ b/src/Build.UnitTests/Construction/XmlReaderWithoutLocation_Tests.cs
@@ -1,17 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Execution;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Microsoft.Build.UnitTests;
-using Microsoft.Build.UnitTests.BackEnd;
 using System.Xml;
 using System.IO;
 using Xunit;
diff --git a/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs b/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs
index 11f9aeb37d4..55055c61a51 100644
--- a/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs
+++ b/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs
@@ -4,21 +4,13 @@
 using System;
 using System.IO;
 using System.Linq;
-using System.Resources;
 using System.Reflection;
-using System.Collections;
 using System.Collections.Generic;
 using System.Xml;
-using System.Text;
-using System.Globalization;
-
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using System.Threading;
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
@@ -587,13 +579,12 @@ public void ItemDefinitionMetadataCopiedToTaskItem()
             Assert.True(p.ItemDefinitions.ContainsKey("ItemA"));
 
             ProjectInstance pi = p.CreateProjectInstance();
-            ITaskItem noMetaItem = null;
             ITaskItem withMetaItem;
 
             List<ProjectItemDefinitionInstance> itemdefs = new List<ProjectItemDefinitionInstance>();
             itemdefs.Add(pi.ItemDefinitions["ItemA"]);
 
-            noMetaItem = new TaskItem("NoMetaItem", pi.FullPath);
+            ITaskItem noMetaItem = new TaskItem("NoMetaItem", pi.FullPath);
             withMetaItem = new TaskItem("WithMetaItem", "WithMetaItem", null, itemdefs, ".", false, pi.FullPath);
 
             // Copy the metadata on the item with no metadata onto the item with metadata
@@ -623,13 +614,12 @@ public void ItemDefinitionMetadataCopiedToTaskItem2()
             Assert.True(p.ItemDefinitions.ContainsKey("ItemA"));
 
             ProjectInstance pi = p.CreateProjectInstance();
-            ITaskItem noMetaItem = null;
             ITaskItem withMetaItem;
 
             List<ProjectItemDefinitionInstance> itemdefs = new List<ProjectItemDefinitionInstance>();
             itemdefs.Add(pi.ItemDefinitions["ItemA"]);
 
-            noMetaItem = new TaskItem("NoMetaItem", pi.FullPath);
+            ITaskItem noMetaItem = new TaskItem("NoMetaItem", pi.FullPath);
             noMetaItem.SetMetadata("MetaA", "NEWMETA_A");
 
             withMetaItem = new TaskItem("WithMetaItem", "WithMetaItem", null, itemdefs, ".", false, pi.FullPath);
@@ -665,13 +655,12 @@ public void ItemDefinitionMetadataCopiedToTaskItem3()
             Assert.True(p.ItemDefinitions.ContainsKey("ItemA"));
 
             ProjectInstance pi = p.CreateProjectInstance();
-            ITaskItem noMetaItem = null;
             ITaskItem withMetaItem = null;
 
             List<ProjectItemDefinitionInstance> itemdefs = new List<ProjectItemDefinitionInstance>();
             itemdefs.Add(pi.ItemDefinitions["ItemA"]);
 
-            noMetaItem = new TaskItem("NoMetaItem", pi.FullPath);
+            ITaskItem noMetaItem = new TaskItem("NoMetaItem", pi.FullPath);
 
             // No the ideal way to get the first item, but there is no other way since GetItems returns an IEnumerable :(
             foreach (ProjectItemInstance item in pi.GetItems("ItemA"))
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index 9271584b5ff..b9329dad3ba 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -86,6 +86,51 @@ public void SharedContextShouldGetReusedWhereasIsolatedContextShouldNot(Evaluati
             }
         }
 
+        [Fact]
+        public void PassedInFileSystemShouldBeReusedInSharedContext()
+        {
+            var projectFiles = new[]
+            {
+                _env.CreateFile("1.proj", @"<Project> <PropertyGroup Condition=`Exists('1.file')`></PropertyGroup> </Project>".Cleanup()).Path,
+                _env.CreateFile("2.proj", @"<Project> <PropertyGroup Condition=`Exists('2.file')`></PropertyGroup> </Project>".Cleanup()).Path
+            };
+
+            var projectCollection = _env.CreateProjectCollection().Collection;
+            var fileSystem = new Helpers.LoggingFileSystem();
+            var evaluationContext = EvaluationContext.Create(EvaluationContext.SharingPolicy.Shared, fileSystem);
+
+            foreach (var projectFile in projectFiles)
+            {
+                Project.FromFile(
+                    projectFile,
+                    new ProjectOptions
+                    {
+                        ProjectCollection = projectCollection,
+                        EvaluationContext = evaluationContext
+                    }
+                );
+            }
+
+            fileSystem.ExistenceChecks.OrderBy(kvp => kvp.Key)
+                .ShouldBe(
+                    new Dictionary<string, int>
+                    {
+                        {Path.Combine(_env.DefaultTestDirectory.Path, "1.file"), 1},
+                        {Path.Combine(_env.DefaultTestDirectory.Path, "2.file"), 1}
+                    }.OrderBy(kvp => kvp.Key));
+
+            fileSystem.DirectoryEntryExistsCalls.ShouldBe(2);
+        }
+
+        [Fact]
+        public void IsolatedContextShouldNotSupportBeingPassedAFileSystem()
+        {
+            _env.DoNotLaunchDebugger();
+
+            var fileSystem = new Helpers.LoggingFileSystem();
+            Should.Throw<ArgumentException>(() => EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated, fileSystem));
+        }
+
         [Theory]
         [InlineData(EvaluationContext.SharingPolicy.Shared)]
         [InlineData(EvaluationContext.SharingPolicy.Isolated)]
diff --git a/src/Build.UnitTests/Definition/ProjectHelpers.cs b/src/Build.UnitTests/Definition/ProjectHelpers.cs
index 5c104d2bc51..f72243b4eb1 100644
--- a/src/Build.UnitTests/Definition/ProjectHelpers.cs
+++ b/src/Build.UnitTests/Definition/ProjectHelpers.cs
@@ -1,12 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Text;
 using System.Xml;
-using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 
diff --git a/src/Build.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
index 870e231bbec..65b62be1c52 100644
--- a/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
@@ -4,21 +4,9 @@
 using System;
 using System.IO;
 using System.Linq;
-using System.Resources;
-using System.Reflection;
-using System.Collections;
 using System.Collections.Generic;
 using System.Xml;
-using System.Text;
-using System.Globalization;
-
-using Microsoft.Build.BackEnd;
-using Microsoft.Build.Execution;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
-using System.Threading;
-using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using ProjectItemFactory = Microsoft.Build.Evaluation.ProjectItem.ProjectItemFactory;
 using Microsoft.Build.Construction;
 using Xunit;
diff --git a/src/Build.UnitTests/Definition/Project_Internal_Tests.cs b/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
index 1fb2e36627c..66d5409729f 100644
--- a/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
+++ b/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
@@ -3,10 +3,8 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using System.Xml;
 using System.IO;
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
 using Shouldly;
diff --git a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
index be35abeaf4e..f08106527a4 100644
--- a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
@@ -2,9 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Text.RegularExpressions;
 using System.Xml;
@@ -463,10 +461,8 @@ public void CustomToolsVersionIsHonored()
                 Toolset source = p.GetToolset("Current");
                 Toolset potato = new Toolset("potato", source.ToolsPath, ProjectCollection.GlobalProjectCollection, source.ToolsPath);
                 p.AddToolset(potato);
-
-                bool success = false;
                 Project project = p.LoadProject(projectPath, "potato");
-                success = project.Build(mockLogger);
+                bool success = project.Build(mockLogger);
 
                 Assert.True(success);
                 mockLogger.AssertLogContains("[potato]");
@@ -489,15 +485,13 @@ public void ToolsVersionFallbackIfCurrentToolsVersionDoesNotExist()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
-
-            bool success = false;
             Project project = new Project(XmlReader.Create(new StringReader(@"<Project ToolsVersion='4.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Target Name='Foo'>
                     </Target>
                    </Project>")), null /* no global properties */, null /* don't explicitly set the toolsversion */, p);
 
             Assert.Equal("4.0", project.ToolsVersion);
-            success = project.Build(mockLogger);
+            bool success = project.Build(mockLogger);
 
             Assert.True(success);
             mockLogger.AssertLogContains("\"4.0\"");
@@ -636,8 +630,6 @@ public void ToolsVersionFallbackIfCurrentToolsVersionDoesNotExist_CreateProjectI
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
-
-            bool success = false;
             Project project = new Project(XmlReader.Create(new StringReader(@"<Project ToolsVersion='4.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Target Name='Foo'>
                     </Target>
@@ -645,7 +637,7 @@ public void ToolsVersionFallbackIfCurrentToolsVersionDoesNotExist_CreateProjectI
 
             ProjectInstance pi = project.CreateProjectInstance();
             Assert.Equal("4.0", pi.ToolsVersion);
-            success = pi.Build(new ILogger[] { mockLogger });
+            bool success = pi.Build(new ILogger[] { mockLogger });
 
             Assert.True(success);
             mockLogger.AssertLogContains("\"4.0\"");
@@ -790,8 +782,6 @@ public void ToolsVersionFallbackIfCurrentToolsVersionDoesNotExist_ProjectInstanc
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
-
-            bool success = false;
             Project project = new Project(XmlReader.Create(new StringReader(@"<Project ToolsVersion='4.0' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                     <Target Name='Foo'>
                     </Target>
@@ -799,7 +789,7 @@ public void ToolsVersionFallbackIfCurrentToolsVersionDoesNotExist_ProjectInstanc
 
             ProjectInstance pi = new ProjectInstance(project.Xml, null /* no global properties */, null /* don't explicitly set the toolsversion */, p);
             Assert.Equal("4.0", pi.ToolsVersion);
-            success = pi.Build(new ILogger[] { mockLogger });
+            bool success = pi.Build(new ILogger[] { mockLogger });
 
             Assert.True(success);
             mockLogger.AssertLogContains("\"4.0\"");
diff --git a/src/Build.UnitTests/Definition/ToolsetConfigurationReaderTestHelper.cs b/src/Build.UnitTests/Definition/ToolsetConfigurationReaderTestHelper.cs
index adaf84887a7..9299d5c6d87 100644
--- a/src/Build.UnitTests/Definition/ToolsetConfigurationReaderTestHelper.cs
+++ b/src/Build.UnitTests/Definition/ToolsetConfigurationReaderTestHelper.cs
@@ -4,9 +4,7 @@
 using System;
 using System.Configuration;
 using System.IO;
-using System.Threading;
 using Microsoft.Build.Shared;
-using Xunit;
 
 #pragma warning disable 436
 
diff --git a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
index 4c57586b987..db0593111e7 100644
--- a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
@@ -572,9 +572,9 @@ public void ExtensionPathsTest_Basic1()
 
             var reader = GetStandardConfigurationReader();
             Dictionary<string, Toolset> toolsets = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-            reader.ReadToolsets(toolsets, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
+            reader.ReadToolsets(toolsets, new PropertyDictionary<ProjectPropertyInstance>(),
+                                new PropertyDictionary<ProjectPropertyInstance>(), true,
+                                out string msbuildOverrideTasksPath, out string defaultOverrideToolsVersion);
 
             Dictionary<string, ProjectImportPathMatch> pathsTable = toolsets["2.0"].ImportPropertySearchPathsTable;
             if (NativeMethodsShared.IsWindows)
diff --git a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
index d64528ff758..2e44a4239a9 100644
--- a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
@@ -10,7 +10,6 @@
 
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -115,8 +114,8 @@ public void GetToolsetDataFromConfiguration_SectionNotRegisteredInConfigFile()
             ToolsetReader reader = GetStandardConfigurationReader();
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(msbuildOverrideTasksPath);
@@ -159,8 +158,8 @@ public void GetToolsetDataFromConfiguration_Basic()
             ToolsetReader reader = GetStandardConfigurationReader();
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal("c:\\Cat", msbuildOverrideTasksPath);
@@ -202,8 +201,8 @@ public void RelativePathInValue()
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
             pg.Set(ProjectPropertyInstance.Create("DotDotSlash", @".." + Path.DirectorySeparatorChar));
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), pg, true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             string expected1 = Path.GetFullPath(Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, "..", "foo"));
@@ -242,8 +241,8 @@ public void InvalidRelativePath()
 
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             // Don't crash (consistent with invalid absolute path)
@@ -389,8 +388,8 @@ public void GetToolsetDataFromConfiguration_DefaultAttributeNotSpecified()
             ToolsetReader reader = GetStandardConfigurationReader();
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(defaultToolsVersion);
@@ -422,9 +421,10 @@ public void GetToolsetDataFromConfiguration_DefaultToolsetUndefined()
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
+
             // Should not throw
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
         }
 
@@ -445,9 +445,8 @@ public void GetToolsetDataFromConfiguration_MSBuildToolsetsNodeNotPresent()
             ToolsetReader reader = GetStandardConfigurationReader();
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(defaultToolsVersion);
@@ -471,9 +470,8 @@ public void GetToolsetDataFromConfiguration_EmptyMSBuildToolsetsNode()
             ToolsetReader reader = GetStandardConfigurationReader();
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(defaultToolsVersion);
@@ -498,9 +496,10 @@ public void GetToolsetDataFromConfiguration_OnlyDefaultSpecified()
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
+
             // Should not throw
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Empty(values);
@@ -531,9 +530,8 @@ public void GetToolsetDataFromConfiguration_OneToolsVersionNode()
             ToolsetReader reader = GetStandardConfigurationReader();
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal("2.0", defaultToolsVersion);
@@ -730,9 +728,10 @@ public void BlankPropertyValueInConfigFile()
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
+
             //this should not throw ...
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
         }
 #endif
@@ -918,7 +917,7 @@ public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString1()
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
             string msbuildOverrideTasksPath;
-            string defaultOverrideToolsVersion = null;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Empty(values);
@@ -948,7 +947,7 @@ public void GetToolsetDataFromConfiguration_PropertyValueIsEmptyString2()
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
             string msbuildOverrideTasksPath;
-            string defaultOverrideToolsVersion = null;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Single(values);
@@ -980,8 +979,8 @@ public void GetToolsetDataFromConfiguration_XmlEscapedCharacters()
             ToolsetReader reader = GetStandardConfigurationReader();
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), true, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal("2>.0", defaultToolsVersion);
diff --git a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
index fbb71bc7e42..e365cb9265f 100644
--- a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
@@ -82,10 +82,10 @@ public void ReadRegistry_DeletedKey()
             DeleteTestRegistryKey();
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
             Assert.Empty(values);
         }
@@ -103,9 +103,8 @@ public void DefaultValuesInRegistryCreatedBySetup()
             ToolsetReader reader = new ToolsetRegistryReader(new ProjectCollection().EnvironmentProperties, new PropertyDictionary<ProjectPropertyInstance>());  //we don't use the test registry key because we want to verify the install
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             // Check the values in the data
@@ -124,9 +123,10 @@ public void DefaultValueInRegistryDoesNotExist()
 
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
+
             // Should not throw
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(defaultToolsVersion);
@@ -139,9 +139,9 @@ public void DefaultValueInRegistryDoesNotExist()
         public void ReadRegistry_NoSubkeyNoValues()
         {
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Empty(values);
@@ -159,9 +159,9 @@ public void ReadRegistry_NoSubkeysOnlyValues()
             _toolsVersionsRegistryKey.SetValue("Name2", "Value2");
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Empty(values);
@@ -180,10 +180,9 @@ public void ReadRegistry_OnlyOneSubkey()
             key1.SetValue("msbuildtoolspath", xdir);
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(defaultToolsVersion);
@@ -208,10 +207,9 @@ public void ReadRegistry_Basic()
             key2.SetValue("msbuildtoolspath", ydir);
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal(2, values.Count);
@@ -279,10 +277,9 @@ public void ReadRegistry_HasSubToolsets()
             subKey3.SetValue("name5a", "value5a");
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal(2, values.Count);
@@ -328,10 +325,9 @@ public void ReadRegistry_IgnoreSubToolsetSubKeys()
             subSubKey1.SetValue("name2b", "value2b");
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Single(values);
@@ -363,10 +359,9 @@ public void ReadRegistry_SubToolsetOverridesBaseToolsetEntries()
             subKey1.SetValue("name2", "");
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Single(values);
@@ -404,10 +399,9 @@ public void ReadRegistry_UnselectedSubToolsetIsIgnored()
             subKey1.SetValue("name2", "");
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Single(values);
@@ -428,10 +422,9 @@ public void GetDefaultToolsVersionFromRegistry_Basic()
             key1.SetValue("msbuildtoolspath", "c:\\xxx");
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal("tv1", defaultToolsVersion);
@@ -444,10 +437,9 @@ public void GetDefaultToolsVersionFromRegistry_Basic()
         public void GetDefaultToolsVersionFromRegistry_DefaultValueNotSet()
         {
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             string defaultToolsVersion = reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(defaultToolsVersion);
@@ -492,9 +484,8 @@ public void GetOverrideTasksPathFromRegistry_Basic()
 
             ToolsetReader reader = GetStandardRegistryReader();
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal("c:\\Foo", msbuildOverrideTasksPath);
@@ -508,9 +499,8 @@ public void GetOverrideTasksPathFromRegistry_ValueNotSet()
         {
             ToolsetReader reader = GetStandardRegistryReader();
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(msbuildOverrideTasksPath);
@@ -544,9 +534,8 @@ public void GetDefaultOverrideToolsVersionFromRegistry_Basic()
 
             ToolsetReader reader = GetStandardRegistryReader();
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Equal("Current", defaultOverrideToolsVersion);
@@ -560,9 +549,8 @@ public void GetDefaultOverrideToolsVersionFromRegistry_ValueNotSet()
         {
             ToolsetReader reader = GetStandardRegistryReader();
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
-
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
             Assert.Null(defaultOverrideToolsVersion);
@@ -599,11 +587,10 @@ public void ReadToolsets_NoBinPathOrToolsPath()
             key3.SetValue("name3", "value3");
 
             ToolsetReader reader = GetStandardRegistryReader();
-            string msbuildOverrideTasksPath = null;
-            string defaultOverrideToolsVersion = null;
-
             Dictionary<string, Toolset> values = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
 
+            string msbuildOverrideTasksPath;
+            string defaultOverrideToolsVersion;
             //should not throw
             reader.ReadToolsets(values, new PropertyDictionary<ProjectPropertyInstance>(), new PropertyDictionary<ProjectPropertyInstance>(), false, out msbuildOverrideTasksPath, out defaultOverrideToolsVersion);
 
diff --git a/src/Build.UnitTests/EndToEndCondition_Tests.cs b/src/Build.UnitTests/EndToEndCondition_Tests.cs
index 488441d6817..5e8e0d06c8b 100644
--- a/src/Build.UnitTests/EndToEndCondition_Tests.cs
+++ b/src/Build.UnitTests/EndToEndCondition_Tests.cs
@@ -1,14 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
 using Microsoft.Build.Execution;
-using Microsoft.Build.UnitTests;
 
 using Shouldly;
 using Xunit;
diff --git a/src/Build.UnitTests/EscapingInProjects_Tests.cs b/src/Build.UnitTests/EscapingInProjects_Tests.cs
index f476576b44f..e1ad11a9be0 100644
--- a/src/Build.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Build.UnitTests/EscapingInProjects_Tests.cs
@@ -7,8 +7,6 @@
 using System.Linq;
 using System.Reflection;
 
-using Microsoft.Build.UnitTests;
-
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
diff --git a/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs b/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
index c05f8d2b76e..67b0b745de8 100644
--- a/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
@@ -3,10 +3,8 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Linq;
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Shouldly;
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index c144e3651c0..ca20d9c66cb 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -11,7 +11,6 @@
 
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -22,7 +21,6 @@
 using Xunit;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
-using ProjectHelpers = Microsoft.Build.UnitTests.BackEnd.ProjectHelpers;
 
 namespace Microsoft.Build.UnitTests.Evaluation
 {
@@ -4914,7 +4912,6 @@ private void CreateTargetsFileWithMessage(string path, string targetName, string
         /// </summary>
         private void VerifyImportTargetRelativePath(string directory, string directory2, string[] imports)
         {
-            string file0 = null;
             string file1 = null;
             string file2 = null;
             string file3 = null;
@@ -4927,7 +4924,7 @@ private void VerifyImportTargetRelativePath(string directory, string directory2,
                     FileUtilities.DeleteWithoutTrailingBackslash(directory);
                 }
 
-                file0 = Path.Combine(directory, "my.proj");
+                string file0 = Path.Combine(directory, "my.proj");
                 file1 = Path.Combine(directory, "1.targets");
                 file2 = Path.Combine(directory2, "2.targets");
                 file3 = Path.Combine(directory2, "3.cpp.targets");
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 6955698c9c1..48164d9284d 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Globalization;
 using System.IO;
 using System.Linq;
@@ -1489,6 +1488,133 @@ public void ExpandAllIntoStringLeaveEscapedComplex()
                 expander.ExpandIntoStringLeaveEscaped(xmlattribute.Value, ExpanderOptions.ExpandAll, MockElementLocation.Instance));
         }
 
+        /// <summary>
+        /// Exercises ExpandIntoStringAndUnescape and ExpanderOptions.Truncate
+        /// </summary>
+        [Fact]
+        public void ExpandAllIntoStringTruncated()
+        {
+            ProjectInstance project = ProjectHelpers.CreateEmptyProjectInstance();
+            var manySpaces = "".PadLeft(2000);
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            pg.Set(ProjectPropertyInstance.Create("ManySpacesProperty", manySpaces));
+            var itemMetadataTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+            {
+                { "ManySpacesMetadata", manySpaces }
+            };
+            var itemMetadata = new StringMetadataTable(itemMetadataTable);
+            var projectItemGroups = new ItemDictionary<ProjectItemInstance>();
+            var itemGroup = new List<ProjectItemInstance>();
+            for (int i = 0; i < 50; i++)
+            {
+                var item = new ProjectItemInstance(project, "ManyItems", $"ThisIsAFairlyLongFileName_{i}.bmp", project.FullPath);
+                item.SetMetadata("Foo", $"ThisIsAFairlyLongMetadataValue_{i}");
+                itemGroup.Add(item);
+            }
+            var lookup = new Lookup(projectItemGroups, pg);
+            lookup.EnterScope("x");
+            lookup.PopulateWithItems("ManySpacesItem", new []
+            {
+                new ProjectItemInstance (project, "ManySpacesItem", "Foo", project.FullPath),
+                new ProjectItemInstance (project, "ManySpacesItem", manySpaces, project.FullPath),
+                new ProjectItemInstance (project, "ManySpacesItem", "Bar", project.FullPath),
+            });
+            lookup.PopulateWithItems("Exactly1024", new[]
+            {
+                new ProjectItemInstance (project, "Exactly1024", "".PadLeft(1024), project.FullPath),
+                new ProjectItemInstance (project, "Exactly1024", "Foo", project.FullPath),
+            });
+            lookup.PopulateWithItems("ManyItems", itemGroup);
+
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(lookup, lookup, itemMetadata, FileSystems.Default);
+
+            XmlAttribute xmlattribute = (new XmlDocument()).CreateAttribute("dummy");
+            xmlattribute.Value = "'%(ManySpacesMetadata)' != '' and '$(ManySpacesProperty)' != '' and '@(ManySpacesItem)' != '' and '@(Exactly1024)' != '' and '@(ManyItems)' != '' and '@(ManyItems->'%(Foo)')' != '' and '@(ManyItems->'%(Nonexistent)')' != ''";
+
+            var expected =
+                $"'{"",1021}...' != '' and " +
+                $"'{"",1021}...' != '' and " +
+                $"'Foo;{"",1017}...' != '' and " +
+                $"'{"",1024};...' != '' and " +
+                "'ThisIsAFairlyLongFileName_0.bmp;ThisIsAFairlyLongFileName_1.bmp;ThisIsAFairlyLongFileName_2.bmp;...' != '' and " +
+                "'ThisIsAFairlyLongMetadataValue_0;ThisIsAFairlyLongMetadataValue_1;ThisIsAFairlyLongMetadataValue_2;...' != '' and " +
+                $"';;;...' != ''";
+            // NOTE: semicolons in the last part are *weird* because they don't actually mean anything and you get logging like
+            //     Target "Build" skipped, due to false condition; ( '@(I->'%(nonexistent)')' == '' ) was evaluated as ( ';' == '' ).
+            // but that goes back to MSBuild 4.something so I'm codifying it in this test. If you're here because you cleaned it up
+            // and want to fix the test my current opinion is that's fine.
+
+            Assert.Equal(expected, expander.ExpandIntoStringAndUnescape(xmlattribute.Value, ExpanderOptions.ExpandAll | ExpanderOptions.Truncate, MockElementLocation.Instance));
+        }
+
+        /// <summary>
+        /// Exercises ExpandIntoStringAndUnescape and ExpanderOptions.Truncate
+        /// </summary>
+        [Fact]
+        public void ExpandAllIntoStringNotTruncated()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                env.SetChangeWave(ChangeWaves.Wave16_8);
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+                ProjectInstance project = ProjectHelpers.CreateEmptyProjectInstance();
+                var manySpaces = "".PadLeft(2000);
+                var pg = new PropertyDictionary<ProjectPropertyInstance>();
+                pg.Set(ProjectPropertyInstance.Create("ManySpacesProperty", manySpaces));
+                var itemMetadataTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+                {
+                    { "ManySpacesMetadata", manySpaces }
+                };
+                var itemMetadata = new StringMetadataTable(itemMetadataTable);
+                var projectItemGroups = new ItemDictionary<ProjectItemInstance>();
+                var itemGroup = new List<ProjectItemInstance>();
+                StringBuilder longFileName = new StringBuilder();
+                StringBuilder longMetadataName = new StringBuilder();
+                for (int i = 0; i < 50; i++)
+                {
+                    var item = new ProjectItemInstance(project, "ManyItems", $"ThisIsAFairlyLongFileName_{i}.bmp", project.FullPath);
+                    item.SetMetadata("Foo", $"ThisIsAFairlyLongMetadataValue_{i}");
+                    longFileName.Append($"ThisIsAFairlyLongFileName_{i}.bmp" + (i == 49 ? string.Empty : ";"));
+                    longMetadataName.Append($"ThisIsAFairlyLongMetadataValue_{i}" + (i == 49 ? string.Empty : ";"));
+                    itemGroup.Add(item);
+                }
+                var lookup = new Lookup(projectItemGroups, pg);
+                lookup.EnterScope("x");
+                lookup.PopulateWithItems("ManySpacesItem", new[]
+                {
+                    new ProjectItemInstance (project, "ManySpacesItem", "Foo", project.FullPath),
+                    new ProjectItemInstance (project, "ManySpacesItem", manySpaces, project.FullPath),
+                    new ProjectItemInstance (project, "ManySpacesItem", "Bar", project.FullPath),
+                });
+                lookup.PopulateWithItems("Exactly1024", new[]
+                {
+                    new ProjectItemInstance (project, "Exactly1024", "".PadLeft(1024), project.FullPath),
+                    new ProjectItemInstance (project, "Exactly1024", "Foo", project.FullPath),
+                });
+                lookup.PopulateWithItems("ManyItems", itemGroup);
+
+                Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(lookup, lookup, itemMetadata, FileSystems.Default);
+
+                XmlAttribute xmlattribute = (new XmlDocument()).CreateAttribute("dummy");
+                xmlattribute.Value = "'%(ManySpacesMetadata)' != '' and '$(ManySpacesProperty)' != '' and '@(ManySpacesItem)' != '' and '@(Exactly1024)' != '' and '@(ManyItems)' != '' and '@(ManyItems->'%(Foo)')' != '' and '@(ManyItems->'%(Nonexistent)')' != ''";
+
+                var expected =
+                    $"'{"",2000}' != '' and " +
+                    $"'{"",2000}' != '' and " +
+                    $"'Foo;{"",2000};Bar' != '' and " +
+                    $"'{"",1024};Foo' != '' and " +
+                    $"'{longFileName}' != '' and " +
+                    $"'{longMetadataName}' != '' and " +
+                    "';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;' != ''";
+                var actual = expander.ExpandIntoStringAndUnescape(xmlattribute.Value, ExpanderOptions.ExpandAll | ExpanderOptions.Truncate, MockElementLocation.Instance);
+                // NOTE: semicolons in the last part are *weird* because they don't actually mean anything and you get logging like
+                //     Target "Build" skipped, due to false condition; ( '@(I->'%(nonexistent)')' == '' ) was evaluated as ( ';' == '' ).
+                // but that goes back to MSBuild 4.something so I'm codifying it in this test. If you're here because you cleaned it up
+                // and want to fix the test my current opinion is that's fine.
+                actual.ShouldBe(expected);
+            }
+        }
+
         /// <summary>
         /// Exercises ExpandAllIntoString with a string that does not need expanding.
         /// In this case the expanded string should be reference identical to the passed in string.
@@ -3550,6 +3676,41 @@ public void PropertyStringConstructorConsumingItemMetadata(string metadatumName,
             result.ShouldBe(metadatumValue);
         }
 
+        [Fact]
+        public void PropertyFunctionHashCodeSameOnlyIfStringSame()
+        {
+            PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            string[] stringsToHash = {
+                "cat1s",
+                "cat1z",
+                "bat1s",
+                "cut1s",
+                "cat1so",
+                "cats1",
+                "acat1s",
+                "cat12s",
+                "cat1s"
+            };
+            int[] hashes = stringsToHash.Select(toHash =>
+                (int)expander.ExpandPropertiesLeaveTypedAndEscaped($"$([MSBuild]::StableStringHash('{toHash}'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance)
+                ).ToArray();
+            for (int a = 0; a < hashes.Length; a++)
+            {
+                for (int b = a; b < hashes.Length; b++)
+                {
+                    if (stringsToHash[a].Equals(stringsToHash[b]))
+                    {
+                        hashes[a].ShouldBe(hashes[b], "Identical strings should hash to the same value.");
+                    }
+                    else
+                    {
+                        hashes[a].ShouldNotBe(hashes[b], "Different strings should not hash to the same value.");
+                    }
+                }
+            }
+        }
+
         /// <summary>
         /// A whole bunch error check tests
         /// </summary>
@@ -3938,7 +4099,7 @@ public void PropertyFunctionIntrinsicFunctionGetVsInstallRoot()
         {
             string vsInstallRoot = EscapingUtilities.Escape(IntrinsicFunctions.GetVsInstallRoot());
 
-            vsInstallRoot = (vsInstallRoot == null) ? "" : vsInstallRoot;
+            vsInstallRoot ??= "";
 
             TestPropertyFunction("$([Microsoft.Build.Evaluation.IntrinsicFunctions]::GetVsInstallRoot())", "X", "_", vsInstallRoot);
         }
diff --git a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
index 660f95455c2..653a01f2fd3 100644
--- a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
@@ -4,12 +4,8 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Text;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
-using System.Xml;
 using System.Text.RegularExpressions;
 using Xunit;
 
@@ -442,7 +438,7 @@ private void VerifySplitSemiColonSeparatedList(string input, params string[] exp
             var actual = ExpressionShredder.SplitSemiColonSeparatedList(input);
             Console.WriteLine(input);
 
-            if (null == expected)
+            if (expected == null)
             {
                 // passing "null" means you expect an empty array back
                 expected = new string[] { };
diff --git a/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
index cc00152c075..73ba89b0e9b 100644
--- a/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
@@ -3,13 +3,11 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Linq;
 using Microsoft.Build.Evaluation;
 using Xunit;
 using System.Text;
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
@@ -537,7 +535,7 @@ public void LongIncludeChain()
             StringBuilder content = new StringBuilder();
             for (int i = 0; i < INCLUDE_COUNT; i++)
             {
-                content.AppendLine($"<i Include='ItemValue{i}' />");
+                content.Append("<i Include='ItemValue").Append(i).AppendLine("' />");
             }
 
             IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(content.ToString());
diff --git a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
index 8585455ea7f..3f42d9bd664 100644
--- a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
@@ -2,14 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Construction;
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
 using System.Collections.Generic;
 using System.IO;
 using System.Xml;
 using System;
-using Microsoft.Build.Definition;
 using Microsoft.Build.Unittest;
 using Xunit;
 using Microsoft.Build.Framework;
diff --git a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
index ed87a86ab7b..e40e6a6d93a 100644
--- a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
@@ -12,8 +12,6 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Xunit;
 using Xunit.Abstractions;
 
@@ -348,9 +346,8 @@ public void SdkResolverCanReturnMultiplePaths(bool includePropertiesAndItems)
         [Fact]
         public void SdkResolverCanReturnTheSamePropertiesAndItemsMultipleTimes()
         {
-            Dictionary<string, string> propertiesToAdd = null;
-            Dictionary<string, SdkResultItem> itemsToAdd = null;
-
+            Dictionary<string, string> propertiesToAdd;
+            Dictionary<string, SdkResultItem> itemsToAdd;
             CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
 
             var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
diff --git a/src/Build.UnitTests/EventArgsFormatting_Tests.cs b/src/Build.UnitTests/EventArgsFormatting_Tests.cs
index 707f3167238..ad415d35bdd 100644
--- a/src/Build.UnitTests/EventArgsFormatting_Tests.cs
+++ b/src/Build.UnitTests/EventArgsFormatting_Tests.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
diff --git a/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs b/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
index 93667018055..6c0dd4d9db9 100644
--- a/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
+++ b/src/Build.UnitTests/ExpressionTreeExpression_Tests.cs
@@ -425,8 +425,7 @@ public void Dispose()
         public void EvaluateAVarietyOfTrueExpressions(string expression)
         {
             Parser p = new Parser();
-            GenericExpressionNode tree;
-            tree = p.Parse(expression, ParserOptions.AllowAll, ElementLocation.EmptyLocation);
+            GenericExpressionNode tree = p.Parse(expression, ParserOptions.AllowAll, ElementLocation.EmptyLocation);
             ConditionEvaluator.IConditionEvaluationState state =
                 new ConditionEvaluator.ConditionEvaluationState<ProjectPropertyInstance, ProjectItemInstance>
                     (
@@ -452,8 +451,7 @@ public void EvaluateAVarietyOfTrueExpressions(string expression)
         public void EvaluateAVarietyOfFalseExpressions(string expression)
         {
             Parser p = new Parser();
-            GenericExpressionNode tree;
-            tree = p.Parse(expression, ParserOptions.AllowAll, ElementLocation.EmptyLocation);
+            GenericExpressionNode tree = p.Parse(expression, ParserOptions.AllowAll, ElementLocation.EmptyLocation);
             ConditionEvaluator.IConditionEvaluationState state =
                 new ConditionEvaluator.ConditionEvaluationState<ProjectPropertyInstance, ProjectItemInstance>
                     (
diff --git a/src/Build.UnitTests/ExpressionTree_Tests.cs b/src/Build.UnitTests/ExpressionTree_Tests.cs
index 35545538cc8..5124da86a6a 100644
--- a/src/Build.UnitTests/ExpressionTree_Tests.cs
+++ b/src/Build.UnitTests/ExpressionTree_Tests.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Xml;
-using System.Collections.Specialized;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
@@ -344,15 +342,12 @@ public void ConditionedPropertyUpdateTests()
                                        ElementLocation.EmptyLocation,
                                        FileSystems.Default
                                    );
-
-            List<string> properties = null;
-
             AssertParseEvaluate(p, "'0' == '1'", expander, false, state);
             Assert.Empty(conditionedProperties);
 
             AssertParseEvaluate(p, "$(foo) == foo", expander, false, state);
             Assert.Single(conditionedProperties);
-            properties = conditionedProperties["foo"];
+            List<string> properties = conditionedProperties["foo"];
             Assert.Single(properties);
 
             AssertParseEvaluate(p, "'$(foo)' != 'bar'", expander, true, state);
diff --git a/src/Build.UnitTests/FileLogger_Tests.cs b/src/Build.UnitTests/FileLogger_Tests.cs
index 0fefab60bc5..26ec4e89942 100644
--- a/src/Build.UnitTests/FileLogger_Tests.cs
+++ b/src/Build.UnitTests/FileLogger_Tests.cs
@@ -5,10 +5,6 @@
 
 using System;
 using System.IO;
-using System.Collections.Generic;
-using System.Text;
-
-using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
@@ -69,7 +65,7 @@ public void BasicNoExistingFile()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
@@ -92,7 +88,7 @@ public void InvalidFile()
                 }
                 finally
                 {
-                    if (null != log) File.Delete(log);
+                    if (log != null) File.Delete(log);
                 }
             }
            );
@@ -121,7 +117,7 @@ public void SpecificVerbosity()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
@@ -194,7 +190,7 @@ public void InvalidEncoding()
                 }
                 finally
                 {
-                    if (null != log) File.Delete(log);
+                    if (log != null) File.Delete(log);
                 }
             }
            );
@@ -220,7 +216,7 @@ public void ValidEncoding()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
@@ -245,7 +241,7 @@ public void ValidEncoding2()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
@@ -287,7 +283,7 @@ public void BasicExistingFileNoAppend()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
@@ -308,7 +304,7 @@ public void BasicExistingFileAppend()
             }
             finally
             {
-                if (null != log) File.Delete(log);
+                if (log != null) File.Delete(log);
             }
         }
 
diff --git a/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs b/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
index e44014ce596..5c8489fc7b6 100644
--- a/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
+++ b/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
@@ -1,12 +1,6 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using Xunit;
+﻿using Xunit;
 using Shouldly;
 using Microsoft.Build.Shared;
-using System.IO;
 using System.Text.RegularExpressions;
 using System.Globalization;
 
diff --git a/src/Build.UnitTests/FixPathOnUnix_Tests.cs b/src/Build.UnitTests/FixPathOnUnix_Tests.cs
index 95b64b6b128..ed0503e230c 100644
--- a/src/Build.UnitTests/FixPathOnUnix_Tests.cs
+++ b/src/Build.UnitTests/FixPathOnUnix_Tests.cs
@@ -1,5 +1,4 @@
-﻿using System;
-using System.IO;
+﻿using System.IO;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
diff --git a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
index 844c88dc8a8..4bb00a27384 100644
--- a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
+++ b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.IO;
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index 73013170d5e..b5c742d2791 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -526,8 +526,8 @@ internal static TransientTestFile CreateProjectFileWithBuildTargetAndItems(
                         </MSBuild>
                     </Target>");
 
-            sb.Append($@"<ItemGroup>
-                            <i Include='{projectNumber}'/>
+            sb.Append(@"<ItemGroup>
+                            <i Include='").Append(projectNumber).Append(@"'/>
                         </ItemGroup>");
 
             return CreateProjectFile(
diff --git a/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs
index 1611340705b..a887dfb4c42 100644
--- a/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectMetadataInstance_Internal_Tests.cs
@@ -1,11 +1,9 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
 using Microsoft.Build.Execution;
 using System;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Construction;
 using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
 using Microsoft.Build.BackEnd;
diff --git a/src/Build.UnitTests/Instance/ProjectPropertyGroupTaskPropertyInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectPropertyGroupTaskPropertyInstance_Internal_Tests.cs
index fb254332706..15128123a9e 100644
--- a/src/Build.UnitTests/Instance/ProjectPropertyGroupTaskPropertyInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectPropertyGroupTaskPropertyInstance_Internal_Tests.cs
@@ -1,11 +1,9 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Engine.UnitTests.TestComparers;
 using Microsoft.Build.Execution;
-using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
 
diff --git a/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs
index 1f8544a3eb4..fc286c5d9ca 100644
--- a/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectPropertyInstance_Internal_Tests.cs
@@ -1,12 +1,9 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Shared;
 using System;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Construction;
 using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
 using Microsoft.Build.BackEnd;
diff --git a/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs
index 808c0edc4a7..b500df91717 100644
--- a/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Construction;
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index e387e719ad6..50b4dd3b487 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -1,10 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
-using System;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Construction;
 using Microsoft.Build.UnitTests.BackEnd;
diff --git a/src/Build.UnitTests/InternalEngineHelpers.cs b/src/Build.UnitTests/InternalEngineHelpers.cs
index 833539345c7..2a4de9d485d 100644
--- a/src/Build.UnitTests/InternalEngineHelpers.cs
+++ b/src/Build.UnitTests/InternalEngineHelpers.cs
@@ -5,12 +5,9 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation.Context;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using SdkResolverContext = Microsoft.Build.Framework.SdkResolverContext;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
diff --git a/src/Build.UnitTests/LogFormatter_Tests.cs b/src/Build.UnitTests/LogFormatter_Tests.cs
index c57ef4b529d..74d6744d2b0 100644
--- a/src/Build.UnitTests/LogFormatter_Tests.cs
+++ b/src/Build.UnitTests/LogFormatter_Tests.cs
@@ -2,11 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
-using System.Collections;
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd.Logging;
-using System.Text.RegularExpressions;
 using System.Globalization;
 using Xunit;
 
diff --git a/src/Build.UnitTests/LoggerDescription_Tests.cs b/src/Build.UnitTests/LoggerDescription_Tests.cs
index 212f1eb7a07..ceae5ff707c 100644
--- a/src/Build.UnitTests/LoggerDescription_Tests.cs
+++ b/src/Build.UnitTests/LoggerDescription_Tests.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.IO;
 
 using Microsoft.Build.Framework;
@@ -17,38 +15,30 @@ public class LoggerDescription_Tests
         [Fact]
         public void LoggerDescriptionCustomSerialization()
         {
-            string className = "Class";
-            string loggerAssemblyName = "Class";
-            string loggerFileAssembly = null;
-            string loggerSwitchParameters = "Class";
-            LoggerVerbosity verbosity = LoggerVerbosity.Detailed;
+            const string className = "Class";
+            const string loggerAssemblyName = "Class";
+            const string loggerFileAssembly = null;
+            const string loggerSwitchParameters = "Class";
+            const LoggerVerbosity verbosity = LoggerVerbosity.Detailed;
 
             LoggerDescription description = new LoggerDescription(className, loggerAssemblyName, loggerFileAssembly, loggerSwitchParameters, verbosity);
-            MemoryStream stream = new MemoryStream();
-            BinaryWriter writer = new BinaryWriter(stream);
-            BinaryReader reader = new BinaryReader(stream);
-            try
-            {
-                stream.Position = 0;
-                description.WriteToStream(writer);
-                long streamWriteEndPosition = stream.Position;
-                stream.Position = 0;
-                LoggerDescription description2 = new LoggerDescription();
-                description2.CreateFromStream(reader);
-                long streamReadEndPosition = stream.Position;
-                Assert.Equal(streamWriteEndPosition, streamReadEndPosition); // "Stream end positions should be equal"
+            using MemoryStream stream = new MemoryStream();
+            using BinaryWriter writer = new BinaryWriter(stream);
+            using BinaryReader reader = new BinaryReader(stream);
 
-                Assert.Equal(description.Verbosity, description2.Verbosity); // "Expected Verbosity to Match"
-                Assert.Equal(description.LoggerId, description2.LoggerId); // "Expected Verbosity to Match"
-                Assert.Equal(0, string.Compare(description.LoggerSwitchParameters, description2.LoggerSwitchParameters, StringComparison.OrdinalIgnoreCase)); // "Expected LoggerSwitchParameters to Match"
-                Assert.Equal(0, string.Compare(description.Name, description2.Name, StringComparison.OrdinalIgnoreCase)); // "Expected Name to Match"
-            }
-            finally
-            {
-                reader.Dispose();
-                writer = null;
-                stream = null;
-            }
+            stream.Position = 0;
+            description.WriteToStream(writer);
+            long streamWriteEndPosition = stream.Position;
+            stream.Position = 0;
+            LoggerDescription description2 = new LoggerDescription();
+            description2.CreateFromStream(reader);
+            long streamReadEndPosition = stream.Position;
+            Assert.Equal(streamWriteEndPosition, streamReadEndPosition); // "Stream end positions should be equal"
+
+            Assert.Equal(description.Verbosity, description2.Verbosity); // "Expected Verbosity to Match"
+            Assert.Equal(description.LoggerId, description2.LoggerId); // "Expected Verbosity to Match"
+            Assert.Equal(0, string.Compare(description.LoggerSwitchParameters, description2.LoggerSwitchParameters, StringComparison.OrdinalIgnoreCase)); // "Expected LoggerSwitchParameters to Match"
+            Assert.Equal(0, string.Compare(description.Name, description2.Name, StringComparison.OrdinalIgnoreCase)); // "Expected Name to Match"
         }
     }
 }
diff --git a/src/Build.UnitTests/LoggerException_Tests.cs b/src/Build.UnitTests/LoggerException_Tests.cs
index 712a6a1d324..79dafa6e0e3 100644
--- a/src/Build.UnitTests/LoggerException_Tests.cs
+++ b/src/Build.UnitTests/LoggerException_Tests.cs
@@ -5,7 +5,6 @@
 using System.IO;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Exceptions;
-using System.Text.RegularExpressions;
 using Xunit;
 using System.Runtime.Serialization.Formatters.Binary;
 
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index c36a51b66b8..fdeaf730a1b 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -28,8 +28,7 @@
     <ProjectReference Include="..\MSBuild\MSBuild.csproj" />
     <ProjectReference Include="..\MSBuildTaskHost\MSBuildTaskHost.csproj"
                       Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MonoBuild)' != 'true'"
-                      ReferenceOutputAssembly="false"
-                      OutputItemType="Content" />
+                      Aliases="MSBuildTaskHost" />
     <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
@@ -117,6 +116,9 @@
     <Compile Include="..\Shared\UnitTests\TestData\GlobbingTestData.cs">
       <Link>TestData\GlobbingTestData.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\UnitTests\ImmutableDictionary_Tests.cs" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MSBuildRuntimeType)' == 'Full' and '$(MonoBuild)' != 'true'">
+      <Link>ImmutableDictionary_Tests.cs</Link>
+    </Compile>
 
     <None Include="..\Shared\UnitTests\App.config">
       <Link>App.config</Link>
diff --git a/src/Build.UnitTests/MockElementLocation.cs b/src/Build.UnitTests/MockElementLocation.cs
index 84b5b8b41a0..7ea1cd9825f 100644
--- a/src/Build.UnitTests/MockElementLocation.cs
+++ b/src/Build.UnitTests/MockElementLocation.cs
@@ -2,10 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Construction;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Microsoft.Build.BackEnd;
-using System;
 
 namespace Microsoft.Build.UnitTests
 {
diff --git a/src/Build.UnitTests/MockTask.cs b/src/Build.UnitTests/MockTask.cs
index 1a847804828..929243a2859 100644
--- a/src/Build.UnitTests/MockTask.cs
+++ b/src/Build.UnitTests/MockTask.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Framework;
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
-using Xunit;
 
 namespace Microsoft.Build.UnitTests
 {
diff --git a/src/Build.UnitTests/OpportunisticIntern_Tests.cs b/src/Build.UnitTests/OpportunisticIntern_Tests.cs
index fd7f70ba885..c47f751c349 100644
--- a/src/Build.UnitTests/OpportunisticIntern_Tests.cs
+++ b/src/Build.UnitTests/OpportunisticIntern_Tests.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Text;
-using System.IO;
-using Microsoft.Build;
 using Microsoft.Build.Shared;
 using Xunit;
 using Xunit.Abstractions;
diff --git a/src/Build.UnitTests/Parser_Tests.cs b/src/Build.UnitTests/Parser_Tests.cs
index 39109849f2f..3c426bfb38c 100644
--- a/src/Build.UnitTests/Parser_Tests.cs
+++ b/src/Build.UnitTests/Parser_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
 
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
@@ -26,9 +25,7 @@ public void SimpleParseTest()
         {
             Console.WriteLine("SimpleParseTest()");
             Parser p = new Parser();
-            GenericExpressionNode tree;
-
-            tree = p.Parse("$(foo)", ParserOptions.AllowAll, _elementLocation);
+            GenericExpressionNode tree = p.Parse("$(foo)", ParserOptions.AllowAll, _elementLocation);
 
 
             tree = p.Parse("$(foo)=='hello'", ParserOptions.AllowAll, _elementLocation);
@@ -77,9 +74,7 @@ public void ComplexParseTest()
         {
             Console.WriteLine("ComplexParseTest()");
             Parser p = new Parser();
-            GenericExpressionNode tree;
-
-            tree = p.Parse("$(foo)", ParserOptions.AllowAll, _elementLocation);
+            GenericExpressionNode tree = p.Parse("$(foo)", ParserOptions.AllowAll, _elementLocation);
 
 
             tree = p.Parse("($(foo) or $(bar)) and $(baz)", ParserOptions.AllowAll, _elementLocation);
@@ -107,8 +102,7 @@ public void NotParseTest()
         {
             Console.WriteLine("NegationParseTest()");
             Parser p = new Parser();
-            GenericExpressionNode tree;
-            tree = p.Parse("!true", ParserOptions.AllowAll, _elementLocation);
+            GenericExpressionNode tree = p.Parse("!true", ParserOptions.AllowAll, _elementLocation);
 
             tree = p.Parse("!(true)", ParserOptions.AllowAll, _elementLocation);
 
@@ -125,8 +119,7 @@ public void FunctionCallParseTest()
         {
             Console.WriteLine("FunctionCallParseTest()");
             Parser p = new Parser();
-            GenericExpressionNode tree;
-            tree = p.Parse("SimpleFunctionCall()", ParserOptions.AllowAll, _elementLocation);
+            GenericExpressionNode tree = p.Parse("SimpleFunctionCall()", ParserOptions.AllowAll, _elementLocation);
 
             tree = p.Parse("SimpleFunctionCall( 1234 )", ParserOptions.AllowAll, _elementLocation);
             tree = p.Parse("SimpleFunctionCall( true )", ParserOptions.AllowAll, _elementLocation);
@@ -141,9 +134,7 @@ public void ItemListParseTest()
             Console.WriteLine("FunctionCallParseTest()");
             Parser p = new Parser();
             GenericExpressionNode tree;
-            bool fExceptionCaught;
-
-            fExceptionCaught = false;
+            bool fExceptionCaught = false;
             try
             {
                 tree = p.Parse("@(foo) == 'a.cs;b.cs'", ParserOptions.AllowProperties, _elementLocation);
@@ -222,9 +213,7 @@ public void ItemFuncParseTest()
             Console.WriteLine("ItemFuncParseTest()");
 
             Parser p = new Parser();
-            GenericExpressionNode tree;
-
-            tree = p.Parse("@(item->foo('ab'))", 
+            GenericExpressionNode tree = p.Parse("@(item->foo('ab'))", 
                 ParserOptions.AllowProperties | ParserOptions.AllowItemLists, _elementLocation);
             Assert.IsType<StringExpressionNode>(tree);
             Assert.Equal("@(item->foo('ab'))", tree.GetUnexpandedValue(null));
@@ -244,9 +233,7 @@ public void MetadataParseTest()
             Console.WriteLine("FunctionCallParseTest()");
             Parser p = new Parser();
             GenericExpressionNode tree;
-            bool fExceptionCaught;
-
-            fExceptionCaught = false;
+            bool fExceptionCaught = false;
             try
             {
                 tree = p.Parse("%(foo) == 'a.cs;b.cs'", ParserOptions.AllowProperties | ParserOptions.AllowItemLists, _elementLocation);
diff --git a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs b/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
index d1c62096ca6..57924761e84 100644
--- a/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
+++ b/src/Build.UnitTests/ProjectEvaluationFinishedEventArgs_Tests.cs
@@ -6,7 +6,6 @@
 using System.IO;
 using System.Text;
 using System.Xml;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework.Profiler;
diff --git a/src/Build.UnitTests/Scanner_Tests.cs b/src/Build.UnitTests/Scanner_Tests.cs
index a01cb72e605..7843e239d6c 100644
--- a/src/Build.UnitTests/Scanner_Tests.cs
+++ b/src/Build.UnitTests/Scanner_Tests.cs
@@ -5,6 +5,8 @@
 
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Utilities;
+using Shouldly;
 using Xunit;
 
 
@@ -66,11 +68,7 @@ public void ErrorPosition()
         /// <param name="lexer"></param>
         private void AdvanceToScannerError(Scanner lexer)
         {
-            while (true)
-            {
-                if (!lexer.Advance()) break;
-                if (lexer.IsNext(Token.TokenType.EndOfInput)) break;
-            }
+            while (lexer.Advance() && !lexer.IsNext(Token.TokenType.EndOfInput));
         }
 
         /// <summary>
@@ -79,9 +77,7 @@ private void AdvanceToScannerError(Scanner lexer)
         [Fact]
         public void SingleEquals()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("a=b", ParserOptions.AllowProperties);
+            Scanner lexer = new Scanner("a=b", ParserOptions.AllowProperties);
             AdvanceToScannerError(lexer);
             Assert.Equal("IllFormedEqualsInCondition", lexer.GetErrorResource());
             Assert.Equal("b", lexer.UnexpectedlyFound);
@@ -93,9 +89,7 @@ public void SingleEquals()
         [Fact]
         public void IllFormedProperty()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("$(", ParserOptions.AllowProperties);
+            Scanner lexer = new Scanner("$(", ParserOptions.AllowProperties);
             AdvanceToScannerError(lexer);
             Assert.Equal("IllFormedPropertyCloseParenthesisInCondition", lexer.GetErrorResource());
 
@@ -104,15 +98,59 @@ public void IllFormedProperty()
             Assert.Equal("IllFormedPropertyOpenParenthesisInCondition", lexer.GetErrorResource());
         }
 
+        /// <summary>
+        /// Tests the space errors case
+        /// </summary>
+        [Theory]
+        [InlineData("$(x )")]
+        [InlineData("$( x)")]
+        [InlineData("$([MSBuild]::DoSomething($(space ))")]
+        [InlineData("$([MSBuild]::DoSomething($(_space ))")]
+        public void SpaceProperty(string pattern)
+        {
+            Scanner lexer = new Scanner(pattern, ParserOptions.AllowProperties);
+            AdvanceToScannerError(lexer);
+            Assert.Equal("IllFormedPropertySpaceInCondition", lexer.GetErrorResource());
+        }
+
+        /// <summary>
+        /// Tests the space not next to end so no errors case
+        /// </summary>
+        [Theory]
+        [InlineData("$(x.StartsWith( 'y' ))")]
+        [InlineData("$(x.StartsWith ('y'))")]
+        [InlineData("$( x.StartsWith( $(SpacelessProperty) ) )")]
+        [InlineData("$( x.StartsWith( $(_SpacelessProperty) ) )")]
+        [InlineData("$(x.StartsWith('Foo', StringComparison.InvariantCultureIgnoreCase))")]
+        public void SpaceInMiddleOfProperty(string pattern)
+        {
+            Scanner lexer = new Scanner(pattern, ParserOptions.AllowProperties);
+            AdvanceToScannerError(lexer);
+            lexer._errorState.ShouldBeFalse();
+        }
+
+        [Fact]
+        public void SpacePropertyOptOutWave16_10()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            env.SetChangeWave(ChangeWaves.Wave16_10);
+
+            Scanner lexer = new Scanner("$(x )", ParserOptions.AllowProperties);
+            AdvanceToScannerError(lexer);
+            Assert.Null(lexer.UnexpectedlyFound);
+
+            lexer = new Scanner("$( x)", ParserOptions.AllowProperties);
+            AdvanceToScannerError(lexer);
+            Assert.Null(lexer.UnexpectedlyFound);
+        }
+
         /// <summary>
         /// Tests the special errors for "@(" and "@x" and similar cases.
         /// </summary>
         [Fact]
         public void IllFormedItemList()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("@(", ParserOptions.AllowAll);
+            Scanner lexer = new Scanner("@(", ParserOptions.AllowAll);
             AdvanceToScannerError(lexer);
             Assert.Equal("IllFormedItemListCloseParenthesisInCondition", lexer.GetErrorResource());
             Assert.Null(lexer.UnexpectedlyFound);
@@ -150,9 +188,7 @@ public void IllFormedItemList()
         [Fact]
         public void IllFormedQuotedString()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("false or 'abc", ParserOptions.AllowAll);
+            Scanner lexer = new Scanner("false or 'abc", ParserOptions.AllowAll);
             AdvanceToScannerError(lexer);
             Assert.Equal("IllFormedQuotedStringInCondition", lexer.GetErrorResource());
             Assert.Null(lexer.UnexpectedlyFound);
@@ -168,9 +204,7 @@ public void IllFormedQuotedString()
         [Fact]
         public void NumericSingleTokenTests()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("1234", ParserOptions.AllowAll);
+            Scanner lexer = new Scanner("1234", ParserOptions.AllowAll);
             Assert.True(lexer.Advance());
             Assert.True(lexer.IsNext(Token.TokenType.Numeric));
             Assert.Equal(0, String.Compare("1234", lexer.IsNextString()));
@@ -295,9 +329,7 @@ public void SimpleSingleTokenTests()
         [Fact]
         public void StringEdgeTests()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("@(Foo, ' ')", ParserOptions.AllowAll);
+            Scanner lexer = new Scanner("@(Foo, ' ')", ParserOptions.AllowAll);
             Assert.True(lexer.Advance() && lexer.IsNext(Token.TokenType.ItemList));
             Assert.True(lexer.Advance() && lexer.IsNext(Token.TokenType.EndOfInput));
 
@@ -321,9 +353,7 @@ public void StringEdgeTests()
         [Fact]
         public void FunctionTests()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("Foo()", ParserOptions.AllowAll);
+            Scanner lexer = new Scanner("Foo()", ParserOptions.AllowAll);
             Assert.True(lexer.Advance() && lexer.IsNext(Token.TokenType.Function));
             Assert.Equal(0, String.Compare("Foo", lexer.IsNextString()));
             Assert.True(lexer.Advance() && lexer.IsNext(Token.TokenType.LeftParenthesis));
@@ -405,9 +435,7 @@ public void FunctionTests()
         [Fact]
         public void ComplexTests1()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("'String with a $(Property) inside'", ParserOptions.AllowAll);
+            Scanner lexer = new Scanner("'String with a $(Property) inside'", ParserOptions.AllowAll);
             Assert.True(lexer.Advance() && lexer.IsNext(Token.TokenType.String));
             Assert.Equal(0, String.Compare("String with a $(Property) inside", lexer.IsNextString()));
 
@@ -523,9 +551,7 @@ public void WhitespaceTests()
         [Fact]
         public void ItemListTests()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("@(foo)", ParserOptions.AllowProperties);
+            Scanner lexer = new Scanner("@(foo)", ParserOptions.AllowProperties);
             Assert.False(lexer.Advance());
             Assert.Equal(0, String.Compare(lexer.GetErrorResource(), "ItemListNotAllowedInThisConditional"));
 
@@ -545,9 +571,7 @@ public void ItemListTests()
         [Fact]
         public void NegativeTests()
         {
-            Scanner lexer;
-
-            lexer = new Scanner("'$(DEBUG) == true", ParserOptions.AllowAll);
+            Scanner lexer = new Scanner("'$(DEBUG) == true", ParserOptions.AllowAll);
             Assert.False(lexer.Advance());
         }
     }
diff --git a/src/Build.UnitTests/SolutionFileBuilder.cs b/src/Build.UnitTests/SolutionFileBuilder.cs
index 233957ac6c2..2aa973078bd 100644
--- a/src/Build.UnitTests/SolutionFileBuilder.cs
+++ b/src/Build.UnitTests/SolutionFileBuilder.cs
@@ -153,27 +153,27 @@ public string BuildSolution()
 
             foreach (var project in projectInfos.Values)
             {
-                sb.AppendLine($@"
-Project(""{project.ProjectTypeGuid}"") = ""{project.Name}"", ""{project.Path}"", ""{project.Guid}""");
+                sb.Append(@"
+Project(""").Append(project.ProjectTypeGuid).Append(@""") = """).Append(project.Name).Append(@""", """).Append(project.Path).Append(@""", """).Append(project.Guid).AppendLine(@"""");
 
                 if (project.Dependencies.Count > 0 || project.DependencyGuids.Count > 0)
                 {
-                    sb.AppendLine($"\tProjectSection(ProjectDependencies) = postProject");
+                    sb.AppendLine("\tProjectSection(ProjectDependencies) = postProject");
 
                     foreach (var dependency in project.Dependencies)
                     {
-                        sb.AppendLine($"\t\t{dependency.Guid} = {dependency.Guid}");
+                        sb.Append("\t\t").Append(dependency.Guid).Append(" = ").AppendLine(dependency.Guid);
                     }
 
                     foreach (var dependencyGuid in project.DependencyGuids)
                     {
-                        sb.AppendLine($"\t\t{dependencyGuid} = {dependencyGuid}");
+                        sb.Append("\t\t").Append(dependencyGuid).Append(" = ").AppendLine(dependencyGuid);
                     }
 
-                    sb.AppendLine($"\tEndProjectSection");
+                    sb.AppendLine("\tEndProjectSection");
                 }
 
-                sb.AppendLine($@"
+                sb.AppendLine(@"
 EndProject");
             }
 
@@ -183,7 +183,7 @@ public string BuildSolution()
 
             foreach (var solutionConfigurationPlatform in SolutionConfigurationPlatforms)
             {
-                sb.AppendLine($"\t\t{solutionConfigurationPlatform.FullName} = {solutionConfigurationPlatform.FullName}");
+                sb.Append("\t\t").Append(solutionConfigurationPlatform.FullName).Append(" = ").AppendLine(solutionConfigurationPlatform.FullName);
             }
 
             sb.AppendLine("\tEndGlobalSection");
@@ -196,8 +196,8 @@ public string BuildSolution()
                 {
                     var solutionConfiguration = configurationMapping.Key;
                     var projectConfiguration = configurationMapping.Value;
-                    sb.AppendLine($"\t\t{project.Value.Guid}.{solutionConfiguration.FullName}.ActiveCfg = {projectConfiguration.FullName}");
-                    sb.AppendLine($"\t\t{project.Value.Guid}.{solutionConfiguration.FullName}.Build.0 = {projectConfiguration.FullName}");
+                    sb.Append("\t\t").Append(project.Value.Guid).Append('.').Append(solutionConfiguration.FullName).Append(".ActiveCfg = ").AppendLine(projectConfiguration.FullName);
+                    sb.Append("\t\t").Append(project.Value.Guid).Append('.').Append(solutionConfiguration.FullName).Append(".Build.0 = ").AppendLine(projectConfiguration.FullName);
                 }
             }
 
diff --git a/src/Build.UnitTests/TargetsFile_Test.cs b/src/Build.UnitTests/TargetsFile_Test.cs
index 3719fff74ce..3efd05703f6 100644
--- a/src/Build.UnitTests/TargetsFile_Test.cs
+++ b/src/Build.UnitTests/TargetsFile_Test.cs
@@ -919,13 +919,12 @@ public void NoLinkMetadataSynthesisWhenDefinedInProject()
         [Fact]
         public void SynthesizeLinkMetadataForItemsOnWhitelist()
         {
-            string[] files = null;
             string outputPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("N"));
             string directoryToDelete = null;
 
             try
             {
-                files = Helpers.CreateFiles("class1.cs", "File1.txt", "Content1.foo", "a.proj");
+                string[] files = Helpers.CreateFiles("class1.cs", "File1.txt", "Content1.foo", "a.proj");
 
                 directoryToDelete = Path.GetDirectoryName(files[0]);
                 string subProjectDirectory = Path.Combine(Path.GetDirectoryName(files[0]), "SubFolder");
@@ -998,13 +997,12 @@ public void SynthesizeLinkMetadataForItemsOnWhitelist()
         [Fact]
         public void DontSynthesizeLinkMetadataIfPropertyNotSet()
         {
-            string[] files = null;
             string outputPath = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("N"));
             string directoryToDelete = null;
 
             try
             {
-                files = Helpers.CreateFiles("class1.cs", "File1.txt", "Content1.foo", "a.proj");
+                string[] files = Helpers.CreateFiles("class1.cs", "File1.txt", "Content1.foo", "a.proj");
 
                 directoryToDelete = Path.GetDirectoryName(files[0]);
                 string subProjectDirectory = Path.Combine(Path.GetDirectoryName(files[0]), "SubFolder");
diff --git a/src/Build.UnitTests/TestData/ProjectInstanceTestObjects.cs b/src/Build.UnitTests/TestData/ProjectInstanceTestObjects.cs
index c0da58b2809..755ef004019 100644
--- a/src/Build.UnitTests/TestData/ProjectInstanceTestObjects.cs
+++ b/src/Build.UnitTests/TestData/ProjectInstanceTestObjects.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -115,8 +114,8 @@ public static ProjectTaskInstance CreateTargetTask(
             var stringCounter = CounterToString(counter);
 
             var readonlyParameters = parameters != null
-                ? new CopyOnWriteDictionary<string, (string, ElementLocation)>(parameters)
-                : new CopyOnWriteDictionary<string, (string, ElementLocation)>();
+                ? new CopyOnWriteDictionary<(string, ElementLocation)>(parameters)
+                : new CopyOnWriteDictionary<(string, ElementLocation)>();
 
             outputs ??= new List<ProjectTaskInstanceChild>();
 
diff --git a/src/Build.UnitTests/Utilities_Tests.cs b/src/Build.UnitTests/Utilities_Tests.cs
index 2219cc6bb72..7f3f2601bf4 100644
--- a/src/Build.UnitTests/Utilities_Tests.cs
+++ b/src/Build.UnitTests/Utilities_Tests.cs
@@ -21,9 +21,6 @@
 using Xunit;
 using System.Collections.Generic;
 using System.IO;
-using Microsoft.Build.Internal;
-using Shouldly;
-using System.Linq;
 using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index 9f5b6fa7f06..eb56df3a007 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -1,6 +1,5 @@
 ﻿using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.UnitTests;
diff --git a/src/Build/AssemblyInfo.cs b/src/Build/AssemblyInfo.cs
index 33ac06e29d8..5717eb380fb 100644
--- a/src/Build/AssemblyInfo.cs
+++ b/src/Build/AssemblyInfo.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
 using System.Resources;
 using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
@@ -19,9 +18,6 @@
 [assembly: InternalsVisibleTo("Microsoft.Build.Framework.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
-[assembly: InternalsVisibleTo("Microsoft.Build.Engine.Whidbey.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
-[assembly: InternalsVisibleTo("Microsoft.Build.UnitTesting.Targets, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
-[assembly: InternalsVisibleTo("Microsoft.Build.Engine.BackEndUnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.Cop, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 // DO NOT expose Internals to "Microsoft.Build.UnitTests.OM.OrcasCompatibility" as this assembly is supposed to only see public interface
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index c8a2838afbb..0e59f2e1fd6 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -891,7 +891,7 @@ public GraphBuildResult Build(BuildParameters parameters, GraphBuildRequestData
         /// </summary>
         public void ShutdownAllNodes()
         {
-            if (null == _nodeManager)
+            if (_nodeManager == null)
             {
                 _nodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.NodeManager) as INodeManager;
             }
@@ -1971,7 +1971,7 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
                         {
                             NodeInfo createdNode = _nodeManager.CreateNode(GetNodeConfiguration(), response.RequiredNodeType);
 
-                            if (null != createdNode)
+                            if (createdNode != null)
                             {
                                 _noNodesActiveEvent.Reset();
                                 _activeNodes.Add(createdNode.NodeId);
@@ -2142,7 +2142,7 @@ private void CheckAllSubmissionsComplete(BuildRequestDataFlags? flags)
         /// </summary>
         private NodeConfiguration GetNodeConfiguration()
         {
-            if (null == _nodeConfiguration)
+            if (_nodeConfiguration == null)
             {
                 // Get the remote loggers
                 ILoggingService loggingService = ((IBuildComponentHost)this).GetComponent(BuildComponentType.LoggingService) as ILoggingService;
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index eb73dfec6d9..355822a0330 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.Collections.ObjectModel;
 using System.Diagnostics.CodeAnalysis;
-using System.IO;
 using System.Threading;
 using System.Globalization;
 using Microsoft.Build.BackEnd;
@@ -16,7 +15,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Execution
 {
@@ -322,7 +320,7 @@ public bool UseSynchronousLogging
         /// <summary>
         /// Indicates whether to emit a default error if a task returns false without logging an error.
         /// </summary>
-        public bool AllowFailureWithoutError { get; set; } = true;
+        public bool AllowFailureWithoutError { get; set; } = false;
 
         /// <summary>
         /// Gets the environment variables which were set when this build was created.
@@ -395,7 +393,7 @@ public bool ResetCaches
         public bool EnableNodeReuse
         {
             get => _enableNodeReuse;
-            set => _enableNodeReuse = Traits.Instance.DisableNodeReuse ? false : value;
+            set => _enableNodeReuse = Environment.GetEnvironmentVariable("MSBUILDDISABLENODEREUSE") == "1" ? false : value;
         }
 
         /// <summary>
@@ -906,7 +904,7 @@ private void Initialize(PropertyDictionary<ProjectPropertyInstance> environmentP
             ResetCaches = true;
             _toolsetProvider = toolsetProvider;
 
-            if (Traits.Instance.DisableNodeReuse) // For example to disable node reuse within Visual Studio
+            if (Environment.GetEnvironmentVariable("MSBUILDDISABLENODEREUSE") == "1") // For example to disable node reuse within Visual Studio
             {
                 _enableNodeReuse = false;
             }
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmission.cs b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
index d6a02bd3650..3a53fbbf3ee 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmission.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
@@ -200,7 +200,7 @@ private void CheckForCompletion()
                 {
                     _completionEvent.Set();
 
-                    if (null != _completionCallback)
+                    if (_completionCallback != null)
                     {
                         void Callback(object state)
                         {
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 2cf6ea5f8ed..bd5d8815eb6 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -615,7 +615,7 @@ private void BuildRequestEntry_StateChanged(BuildRequestEntry entry, BuildReques
         private void RaiseRequestComplete(BuildRequest request, BuildResult result)
         {
             RequestCompleteDelegate requestComplete = OnRequestComplete;
-            if (null != requestComplete)
+            if (requestComplete != null)
             {
                 TraceEngine("RRC: Reporting result for request {0}({1}) (nr {2}).", request.GlobalRequestId, request.ConfigurationId, request.NodeRequestId);
                 requestComplete(request, result);
@@ -718,7 +718,7 @@ private void EvaluateRequestStates()
 
                     // This request is ready to be built
                     case BuildRequestEntryState.Ready:
-                        if (null == firstReadyEntry)
+                        if (firstReadyEntry == null)
                         {
                             firstReadyEntry = currentEntry;
                         }
@@ -747,9 +747,9 @@ private void EvaluateRequestStates()
             }
 
             // Update current engine status and start the next request, if applicable.
-            if (null == activeEntry)
+            if (activeEntry == null)
             {
-                if (null != firstReadyEntry)
+                if (firstReadyEntry != null)
                 {
                     // We are now active because we have an entry which is building.
                     ChangeStatus(BuildRequestEngineStatus.Active);
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs b/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
index 176c2bd91e2..c7422949516 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
@@ -74,12 +74,12 @@ public FullyQualifiedBuildRequest(
         /// <returns>True if the objects are equivalent, false otherwise.</returns>
         public static bool operator ==(FullyQualifiedBuildRequest left, FullyQualifiedBuildRequest right)
         {
-            if (ReferenceEquals(left, null))
+            if (left is null)
             {
-                return ReferenceEquals(right, null);
+                return right is null;
             }
 
-            return !ReferenceEquals(right, null) && left.InternalEquals(right);
+            return !(right is null) && left.InternalEquals(right);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Caching/ConfigCache.cs b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
index 7fe7868a587..2e695a60aab 100644
--- a/src/Build/BackEnd/Components/Caching/ConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Collections.ObjectModel;
-using System.Text;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd
@@ -207,8 +205,7 @@ public void ClearConfigurations()
         /// <returns>Set if configurations which have been cleared.</returns>
         public List<int> ClearNonExplicitlyLoadedConfigurations()
         {
-            List<int> configurationIdsCleared = null;
-            configurationIdsCleared = new List<int>();
+            List<int> configurationIdsCleared = new List<int>();
 
             Dictionary<int, BuildRequestConfiguration> configurationsToKeep = new Dictionary<int, BuildRequestConfiguration>();
             Dictionary<ConfigurationMetadata, int> configurationIdsByMetadataToKeep = new Dictionary<ConfigurationMetadata, int>();
diff --git a/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs b/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs
index c6c91d88f77..12bc8de169f 100644
--- a/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs
+++ b/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
diff --git a/src/Build/BackEnd/Components/Caching/IConfigCache.cs b/src/Build/BackEnd/Components/Caching/IConfigCache.cs
index 0bdc69b92a8..c60f95c6086 100644
--- a/src/Build/BackEnd/Components/Caching/IConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/IConfigCache.cs
@@ -1,9 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Text;
 
 namespace Microsoft.Build.BackEnd
 {
diff --git a/src/Build/BackEnd/Components/Caching/IPropertyCache.cs b/src/Build/BackEnd/Components/Caching/IPropertyCache.cs
index cf0c095dbe4..fdbab85a251 100644
--- a/src/Build/BackEnd/Components/Caching/IPropertyCache.cs
+++ b/src/Build/BackEnd/Components/Caching/IPropertyCache.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
-using System.Text;
-
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Caching/IResultsCache.cs b/src/Build/BackEnd/Components/Caching/IResultsCache.cs
index 15e9bfb9db8..e78d4e2909d 100644
--- a/src/Build/BackEnd/Components/Caching/IResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/IResultsCache.cs
@@ -1,9 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Text;
 
 using BuildResult = Microsoft.Build.Execution.BuildResult;
 
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index cfbcaff2aeb..a59c7f60914 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -5,8 +5,6 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Collections.Concurrent;
-using System.Diagnostics;
-using System.IO;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
@@ -312,7 +310,7 @@ private static bool CheckResults(BuildResult result, List<string> targets, HashS
             {
                 if (!result.HasResultsForTarget(target) || (result[target].ResultCode == TargetResultCode.Skipped && !skippedResultsAreOK))
                 {
-                    if (null != targetsMissingResults)
+                    if (targetsMissingResults != null)
                     {
                         targetsMissingResults.Add(target);
                         returnValue = false;
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs b/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs
index 3994138b333..4cce5d68aae 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 
 using BuildResult = Microsoft.Build.Execution.BuildResult;
 
diff --git a/src/Build/BackEnd/Components/Communications/INodeManager.cs b/src/Build/BackEnd/Components/Communications/INodeManager.cs
index d0cba349d92..d08a101867f 100644
--- a/src/Build/BackEnd/Components/Communications/INodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/INodeManager.cs
@@ -1,8 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Execution;
 
 namespace Microsoft.Build.BackEnd
diff --git a/src/Build/BackEnd/Components/Communications/INodeProvider.cs b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
index bd2cacc7266..fc7faf679e0 100644
--- a/src/Build/BackEnd/Components/Communications/INodeProvider.cs
+++ b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
-using System.Text;
-
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs b/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs
index 83c02205f23..1f8a521673e 100644
--- a/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs
+++ b/src/Build/BackEnd/Components/Communications/LogMessagePacket.cs
@@ -1,11 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Text;
-using System.IO;
-using System.Reflection;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
index 956a7f080f6..4c2b6d2b8eb 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
@@ -2,11 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.Collections.Concurrent;
-using System.Text;
 using System.Threading;
-using System.Diagnostics;
 using Microsoft.Build.Shared;
 
 using BuildParameters = Microsoft.Build.Execution.BuildParameters;
@@ -252,7 +249,7 @@ internal static EndpointPair CreateInProcEndpoints(EndpointMode mode, IBuildComp
         /// <param name="newStatus">The new status of the endpoint link.</param>
         private void RaiseLinkStatusChanged(LinkStatus newStatus)
         {
-            if (null != OnLinkStatusChanged)
+            if (OnLinkStatusChanged != null)
             {
                 LinkStatusChangedDelegate linkStatusDelegate = OnLinkStatusChanged;
                 linkStatusDelegate(this, newStatus);
@@ -326,8 +323,8 @@ private void EnqueuePacket(INodePacket packet)
         {
             ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
             ErrorUtilities.VerifyThrow(_mode == EndpointMode.Asynchronous, "EndPoint mode is synchronous, should be asynchronous");
-            ErrorUtilities.VerifyThrow(null != _packetQueue, "packetQueue is null");
-            ErrorUtilities.VerifyThrow(null != _packetAvailable, "packetAvailable is null");
+            ErrorUtilities.VerifyThrow(_packetQueue != null, "packetQueue is null");
+            ErrorUtilities.VerifyThrow(_packetAvailable != null, "packetAvailable is null");
 
             _packetQueue.Enqueue(packet);
             _packetAvailable.Set();
@@ -340,10 +337,10 @@ private void InitializeAsyncPacketThread()
         {
             lock (_asyncDataMonitor)
             {
-                ErrorUtilities.VerifyThrow(null == _packetPump, "packetPump != null");
-                ErrorUtilities.VerifyThrow(null == _packetAvailable, "packetAvailable != null");
-                ErrorUtilities.VerifyThrow(null == _terminatePacketPump, "terminatePacketPump != null");
-                ErrorUtilities.VerifyThrow(null == _packetQueue, "packetQueue != null");
+                ErrorUtilities.VerifyThrow(_packetPump == null, "packetPump != null");
+                ErrorUtilities.VerifyThrow(_packetAvailable == null, "packetAvailable != null");
+                ErrorUtilities.VerifyThrow(_terminatePacketPump == null, "terminatePacketPump != null");
+                ErrorUtilities.VerifyThrow(_packetQueue == null, "packetQueue != null");
 
 #if FEATURE_THREAD_CULTURE
                 _packetPump = new Thread(PacketPumpProc);
@@ -377,10 +374,10 @@ private void TerminateAsyncPacketThread()
         {
             lock (_asyncDataMonitor)
             {
-                ErrorUtilities.VerifyThrow(null != _packetPump, "packetPump == null");
-                ErrorUtilities.VerifyThrow(null != _packetAvailable, "packetAvailable == null");
-                ErrorUtilities.VerifyThrow(null != _terminatePacketPump, "terminatePacketPump == null");
-                ErrorUtilities.VerifyThrow(null != _packetQueue, "packetQueue == null");
+                ErrorUtilities.VerifyThrow(_packetPump != null, "packetPump == null");
+                ErrorUtilities.VerifyThrow(_packetAvailable != null, "packetAvailable == null");
+                ErrorUtilities.VerifyThrow(_terminatePacketPump != null, "terminatePacketPump == null");
+                ErrorUtilities.VerifyThrow(_packetQueue != null, "packetQueue == null");
 
                 _terminatePacketPump.Set();
                 if (!_packetPump.Join((int)new TimeSpan(0, 0, BuildParameters.EndpointShutdownTimeout).TotalMilliseconds))
diff --git a/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs b/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
index 7dc94b788c3..9d0c59a201b 100644
--- a/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
@@ -2,14 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Runtime.Serialization;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
-using Microsoft.Build.Shared;
-using BackendNativeMethods = Microsoft.Build.BackEnd.NativeMethods;
 
 namespace Microsoft.Build.BackEnd
 {
diff --git a/src/Build/BackEnd/Components/Communications/NodeInfo.cs b/src/Build/BackEnd/Components/Communications/NodeInfo.cs
index d94cccba51c..fda92dae71e 100644
--- a/src/Build/BackEnd/Components/Communications/NodeInfo.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeInfo.cs
@@ -1,12 +1,9 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Text;
 
 using Microsoft.Build.Execution;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd
 {
diff --git a/src/Build/BackEnd/Components/Communications/NodeManager.cs b/src/Build/BackEnd/Components/Communications/NodeManager.cs
index 602a5d790ec..5a533e05fbb 100644
--- a/src/Build/BackEnd/Components/Communications/NodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeManager.cs
@@ -2,14 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading;
-using System.Diagnostics;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 
 namespace Microsoft.Build.BackEnd
@@ -132,7 +126,7 @@ public NodeInfo CreateNode(NodeConfiguration configuration, NodeAffinity nodeAff
         public void SendData(int node, INodePacket packet)
         {
             // Look up the node provider for this node in the mapping.
-            INodeProvider provider = null;
+            INodeProvider provider;
             if (!_nodeIdToProvider.TryGetValue(node, out provider))
             {
                 ErrorUtilities.ThrowInternalError("Node {0} does not have a provider.", node);
@@ -156,9 +150,7 @@ public void ShutdownConnectedNodes(bool enableReuse)
             }
 
             _nodesShutdown = true;
-
             _inProcNodeProvider?.ShutdownConnectedNodes(enableReuse);
-
             _outOfProcNodeProvider?.ShutdownConnectedNodes(enableReuse);
         }
 
@@ -316,7 +308,7 @@ private void RemoveNodeFromMapping(int nodeId)
         private int AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration nodeConfiguration)
         {
             // If no provider was passed in, we obviously can't create a node.
-            if (null == nodeProvider)
+            if (nodeProvider == null)
             {
                 ErrorUtilities.ThrowInternalError("No node provider provided.");
                 return InvalidNodeId;
@@ -329,8 +321,7 @@ private int AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration node
             }
 
             // Assign a global ID to the node we are about to create.
-            int nodeId = InvalidNodeId;
-
+            int nodeId;
             if (nodeProvider is NodeProviderInProc)
             {
                 nodeId = _inprocNodeId;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 49cca2f7e4d..0081265b99c 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -153,7 +153,7 @@ public void SendData(int nodeId, INodePacket packet)
             ErrorUtilities.VerifyThrowArgumentOutOfRange(nodeId == _inProcNodeId, "node");
             ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
 
-            if (null == _inProcNode)
+            if (_inProcNode == null)
             {
                 return;
             }
@@ -167,7 +167,7 @@ public void SendData(int nodeId, INodePacket packet)
         /// <param name="enableReuse">Flag indicating if the nodes should prepare for reuse.</param>
         public void ShutdownConnectedNodes(bool enableReuse)
         {
-            if (null != _inProcNode)
+            if (_inProcNode != null)
             {
                 _inProcNodeEndpoint.SendData(new NodeBuildComplete(enableReuse));
             }
@@ -333,8 +333,8 @@ static internal IBuildComponent CreateComponent(BuildComponentType type)
         /// </summary>
         private bool InstantiateNode(INodePacketFactory factory)
         {
-            ErrorUtilities.VerifyThrow(null == _inProcNode, "In Proc node already instantiated.");
-            ErrorUtilities.VerifyThrow(null == _inProcNodeEndpoint, "In Proc node endpoint already instantiated.");
+            ErrorUtilities.VerifyThrow(_inProcNode == null, "In Proc node already instantiated.");
+            ErrorUtilities.VerifyThrow(_inProcNodeEndpoint == null, "In Proc node endpoint already instantiated.");
 
             NodeEndpointInProc.EndpointPair endpoints = NodeEndpointInProc.CreateInProcEndpoints(NodeEndpointInProc.EndpointMode.Synchronous, _componentHost);
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index 5fd62ffed9b..11ea72ba505 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -94,7 +94,7 @@ public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration
             Handshake hostHandshake = new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: ComponentHost.BuildParameters.EnableNodeReuse, lowPriority: ComponentHost.BuildParameters.LowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
             NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandshake, NodeContextTerminated);
 
-            if (null != context)
+            if (context != null)
             {
                 _nodeContexts[nodeId] = context;
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index cae8c0b3b5e..e65f614e08e 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -8,11 +8,17 @@
 using System.IO.Pipes;
 using System.Diagnostics;
 using System.Threading;
+#if !FEATURE_APM
 using System.Threading.Tasks;
+#endif
 using System.Runtime.InteropServices;
+#if FEATURE_PIPE_SECURITY
 using System.Security.Principal;
+#endif
 
+#if FEATURE_APM
 using Microsoft.Build.Eventing;
+#endif
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -123,13 +129,13 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
                 // Attempt to connect to the process with the handshake without low priority.
                 Stream nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, false));
 
-                if (null == nodeStream)
+                if (nodeStream == null)
                 {
                     // If we couldn't connect attempt to connect to the process with the handshake including low priority.
                     nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, true));
                 }
 
-                if (null != nodeStream)
+                if (nodeStream != null)
                 {
                     // If we're able to connect to such a process, send a packet requesting its termination
                     CommunicationsUtilities.Trace("Shutting down node with pid = {0}", nodeProcess.Id);
@@ -349,7 +355,7 @@ private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake han
                 int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
                 for (int i = 0; i < handshakeComponents.Length; i++)
                 {
-                    CommunicationsUtilities.Trace("Writing handshake part {0} to pipe {1}", i, pipeName);
+                    CommunicationsUtilities.Trace("Writing handshake part {0} ({1}) to pipe {2}", i, handshakeComponents[i], pipeName);
                     nodeStream.WriteIntForHandshake(handshakeComponents[i]);
                 }
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 887e02b1383..ef746ed27d7 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -453,9 +453,8 @@ internal static string GetMSBuildLocationFromHostContext(HandshakeOptions hostCo
         /// </summary>
         internal bool AcquireAndSetUpHost(HandshakeOptions hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration)
         {
-            NodeContext context = null;
-            bool nodeCreationSucceeded = false;
-
+            NodeContext context;
+            bool nodeCreationSucceeded;
             if (!_nodeContexts.TryGetValue(hostContext, out context))
             {
                 nodeCreationSucceeded = CreateNode(hostContext, factory, handler, configuration);
@@ -530,7 +529,7 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
                                         NodeContextTerminated
                                     );
 
-            if (null != context)
+            if (context != null)
             {
                 _nodeContexts[hostContext] = context;
 
diff --git a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
index 5ec101d68a5..e54ed7f2f70 100644
--- a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
@@ -2,14 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading;
-using System.Diagnostics;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 
 namespace Microsoft.Build.BackEnd
@@ -73,7 +66,6 @@ public void SendData(int node, INodePacket packet)
         public void ShutdownConnectedNodes(bool enableReuse)
         {
             ErrorUtilities.VerifyThrow(!_componentShutdown, "We should never be calling ShutdownNodes after ShutdownComponent has been called");
-
             _outOfProcTaskHostNodeProvider?.ShutdownConnectedNodes(enableReuse);
         }
 
diff --git a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
index 73acbb5cb12..4116039458a 100644
--- a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
+++ b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 using System.Reflection;
-using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.BackEnd
 {
diff --git a/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs b/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
index ef8548220b4..4e6e5be0145 100644
--- a/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
+++ b/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
@@ -1,12 +1,9 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.BackEnd.Logging
 {
diff --git a/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs b/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
index 888ba5a557c..239dccfaf33 100644
--- a/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
@@ -2,16 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Collections.Generic;
 using System.Diagnostics;
-using System.Text;
-using System.Xml;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
-
 namespace Microsoft.Build.BackEnd.Logging
 {
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs b/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
index 7bfc4b0670c..02b143cdc40 100644
--- a/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
+++ b/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
@@ -1,10 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections;
-using System.Text;
-using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/BackEnd/Components/Logging/EventRedirectorToSink.cs b/src/Build/BackEnd/Components/Logging/EventRedirectorToSink.cs
index 9acf4ce93a1..b2817ca1b11 100644
--- a/src/Build/BackEnd/Components/Logging/EventRedirectorToSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventRedirectorToSink.cs
@@ -1,8 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Diagnostics;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 03a62b7cc90..4c321e4a15c 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -4,7 +4,6 @@
 // <summary>Sink which will take in a build event and raise it on its internal event source</summary>
 
 using System;
-using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs b/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs
index a44a9aec7b8..09cc3138399 100644
--- a/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs
+++ b/src/Build/BackEnd/Components/Logging/ForwardingLoggerRecord.cs
@@ -1,10 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 02fdef8be56..d0ba8d88919 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using Microsoft.Build.BackEnd.Components.Logging;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 93cbaff924a..85c95d728d1 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -2,22 +2,15 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Globalization;
-using System.IO;
 using System.Linq;
 using System.Reflection;
-using System.Text;
 using System.Threading;
 using System.Threading.Tasks.Dataflow;
-using Microsoft.Build.BackEnd;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-
-using BuildParameters = Microsoft.Build.Execution.BuildParameters;
 using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
 
@@ -1457,7 +1450,7 @@ private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)
             try
             {
                 INodeLogger nodeLogger = logger as INodeLogger;
-                if (null != nodeLogger)
+                if (nodeLogger != null)
                 {
                     nodeLogger.Initialize(sourceForLogger, _maxCPUCount);
                 }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceFactory.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceFactory.cs
index a7abcc9e64d..dcc4e2f8074 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceFactory.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceFactory.cs
@@ -1,10 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd.Logging
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 4ab21db60f0..aa386336ac3 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -5,13 +5,6 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading;
-using Microsoft.Build.BackEnd;
-using Microsoft.Build.BackEnd.Components.Logging;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
index 5b8a27e6d20..512cba7c0c8 100644
--- a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
@@ -1,10 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 409c75b14be..cfd9089f1bc 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Execution;
 using System.Collections;
diff --git a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
index 25ac7996659..6daf7608f20 100644
--- a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
@@ -3,12 +3,8 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
-using System.Text;
-using System.Xml;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using System.Collections;
diff --git a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
index 184e11c98cf..c953ec6f226 100644
--- a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
@@ -2,14 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Text;
-using System.Xml;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Evaluation;
 
 namespace Microsoft.Build.BackEnd.Logging
 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index f0485c1d0eb..3e676950ea5 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -335,7 +335,7 @@ ElementLocation elementLocation
 
                         // If we didn't find a bucket that matches this item, create a new one, adding
                         // this item to the bucket.
-                        if (null == matchingBucket)
+                        if (matchingBucket == null)
                         {
                             matchingBucket = new ItemBucket(itemListsToBeBatched.Keys, itemMetadataValues, lookup, buckets.Count);
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs b/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs
index 65410102c2d..6d5d8f7d72a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs
@@ -6,7 +6,6 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
-using TaskLoggingContext = Microsoft.Build.BackEnd.Logging.TaskLoggingContext;
 
 #if FEATURE_FILE_TRACKER
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
index c278aa84730..a0de5afca83 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Execution;
 using NodeLoggingContext = Microsoft.Build.BackEnd.Logging.NodeLoggingContext;
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilderCallback.cs b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilderCallback.cs
index 9da14f17e19..63b77897dd5 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilderCallback.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilderCallback.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Collections;
 using System.Threading.Tasks;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilder.cs
index 43fdfcb3dfb..97bd307200d 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilder.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilderCallback.cs b/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilderCallback.cs
index ce3a6243837..dbbc7c2c585 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilderCallback.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilderCallback.cs
@@ -1,11 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
 using System.Threading.Tasks;
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs
index 42f92589922..304989547d4 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTask.cs
@@ -3,17 +3,9 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using System.Xml;
 using System.Reflection;
-using System.Globalization;
-using System.Collections;
-using System.Diagnostics;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.BackEnd.Logging;
 
 namespace Microsoft.Build.BackEnd
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/IntrinsicTaskFactory.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/IntrinsicTaskFactory.cs
index bee415a33f1..0c9b0baec23 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/IntrinsicTaskFactory.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/IntrinsicTaskFactory.cs
@@ -3,9 +3,7 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
 using System.Reflection;
-using System.Text;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 844924e7625..dd1e5009679 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -2,12 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Collections.Immutable;
-using System.Text;
 using System.Linq;
-using System.Runtime.InteropServices;
 using Microsoft.Build.Collections;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
 using Microsoft.Build.Execution;
@@ -15,7 +12,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared.FileSystem;
-using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using ProjectItemInstanceFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory;
 using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
 using TargetLoggingContext = Microsoft.Build.BackEnd.Logging.TargetLoggingContext;
@@ -159,7 +155,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
         {
             // First, collect up the appropriate metadata collections.  We need the one from the item definition, if any, and
             // the one we are using for this batching bucket.
-            ProjectItemDefinitionInstance itemDefinition = null;
+            ProjectItemDefinitionInstance itemDefinition;
             Project.ItemDefinitions.TryGetValue(child.ItemType, out itemDefinition);
 
             // The NestedMetadataTable will handle the aggregation of the different metadata collections
@@ -246,8 +242,7 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                 return;
             }
 
-            List<ProjectItemInstance> itemsToRemove = null;
-
+            List<ProjectItemInstance> itemsToRemove;
             if (matchOnMetadata == null)
             {
                 itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander);
@@ -681,7 +676,7 @@ public string GetEscapedValue(string specifiedItemType, string name)
             public string GetEscapedValueIfPresent(string specifiedItemType, string name)
             {
                 string value = null;
-                if (null == specifiedItemType || specifiedItemType == _itemType)
+                if (specifiedItemType == null || specifiedItemType == _itemType)
                 {
                     // Look in the addTable
                     if (_addTable.TryGetValue(name, out value))
@@ -691,17 +686,17 @@ public string GetEscapedValueIfPresent(string specifiedItemType, string name)
                 }
 
                 // Look in the bucket table
-                if (null != _bucketTable)
+                if (_bucketTable != null)
                 {
                     value = _bucketTable.GetEscapedValueIfPresent(specifiedItemType, name);
-                    if (null != value)
+                    if (value != null)
                     {
                         return value;
                     }
                 }
 
                 // Look in the item definition table
-                if (null != _itemDefinitionTable)
+                if (_itemDefinitionTable != null)
                 {
                     value = _itemDefinitionTable.GetEscapedValueIfPresent(specifiedItemType, name);
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
index 84eaa27f0e7..9aa0bfd4fce 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
-using System.Reflection;
 
 namespace Microsoft.Build.BackEnd
 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index 1c13820a921..bbe8db85caf 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -7,7 +7,6 @@
 using System.IO;
 using System.Threading.Tasks;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
index ed53dcd882b..1779d6ba70f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
@@ -2,12 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Xml;
-using System.Collections;
 using System.Collections.Generic;
-using System.Text;
-using System.Text.RegularExpressions;
-using System.Globalization;
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index 193c6a1f3c0..4d0e7f95812 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -1140,7 +1140,7 @@ public MetadataModification this[string metadataName]
             {
                 get
                 {
-                    MetadataModification modification = null;
+                    MetadataModification modification;
                     if (!_modifications.TryGetValue(metadataName, out modification))
                     {
                         if (_keepOnlySpecified)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 7149abeedfb..00512fc9c9b 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -183,7 +183,7 @@ public void BuildRequest(NodeLoggingContext loggingContext, BuildRequestEntry en
         {
             ErrorUtilities.VerifyThrowArgumentNull(loggingContext, nameof(loggingContext));
             ErrorUtilities.VerifyThrowArgumentNull(entry, nameof(entry));
-            ErrorUtilities.VerifyThrow(null != _componentHost, "Host not set.");
+            ErrorUtilities.VerifyThrow(_componentHost != null, "Host not set.");
             ErrorUtilities.VerifyThrow(_targetBuilder == null, "targetBuilder not null");
             ErrorUtilities.VerifyThrow(_nodeLoggingContext == null, "nodeLoggingContext not null");
             ErrorUtilities.VerifyThrow(_requestEntry == null, "requestEntry not null");
@@ -726,7 +726,7 @@ private async Task BuildAndReport()
             }
             catch (InvalidProjectFileException ex)
             {
-                if (null != _projectLoggingContext)
+                if (_projectLoggingContext != null)
                 {
                     _projectLoggingContext.LogInvalidProjectFileError(ex);
                 }
@@ -764,7 +764,7 @@ private async Task BuildAndReport()
             {
                 _blockType = BlockType.Unblocked;
 
-                if (null != thrownException)
+                if (thrownException != null)
                 {
                     ErrorUtilities.VerifyThrow(result == null, "Result already set when exception was thrown.");
                     result = new BuildResult(_requestEntry.Request, thrownException);
@@ -781,7 +781,7 @@ private async Task BuildAndReport()
         /// </summary>
         private void ReportResultAndCleanUp(BuildResult result)
         {
-            if (null != _projectLoggingContext)
+            if (_projectLoggingContext != null)
             {
                 try
                 {
@@ -916,8 +916,7 @@ private async Task<BuildResult[]> StartNewBuildRequests(FullyQualifiedBuildReque
         /// </summary>
         private BuildResult[] GetResultsForContinuation(FullyQualifiedBuildRequest[] requests, bool isContinue)
         {
-            IDictionary<int, BuildResult> results;
-            results = _continueResults;
+            IDictionary<int, BuildResult> results = _continueResults;
             _continueResults = null;
             if (results == null)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index d105588c94d..834d87e57b2 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -439,7 +439,7 @@ private async Task ProcessTargetStack(ITaskBuilder taskBuilder)
                             }
 
                             // And if we have dependencies to run, push them now.
-                            if (null != dependencies)
+                            if (dependencies != null)
                             {
                                 await PushTargets(dependencies, currentTargetEntry, currentTargetEntry.Lookup, false, false, TargetBuiltReason.DependsOn);
                             }
@@ -777,6 +777,10 @@ private void ComputeAfterTargetFailures(string[] targetNames)
                     var targetsToCheckForAfterTargets = new Queue<string>();
                     targetsToCheckForAfterTargets.Enqueue(targetName);
 
+                    // Set of targets already processed, to break cycles of AfterTargets.
+                    // Initialized lazily when needed below.
+                    HashSet<string> targetsChecked = null;
+
                     while (targetsToCheckForAfterTargets?.Count > 0)
                     {
                         string targetToCheck = targetsToCheckForAfterTargets.Dequeue();
@@ -793,8 +797,16 @@ private void ComputeAfterTargetFailures(string[] targetNames)
                                 break;
                             }
 
-                            // We haven't seen this target yet, add it to the list to check.
-                            targetsToCheckForAfterTargets.Enqueue(afterTarget.TargetName);
+                            targetsChecked ??= new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default)
+                                {
+                                    targetName
+                                };
+
+                            // If we haven't seen this target yet, add it to the list to check.
+                            if (targetsChecked.Add(afterTarget.TargetName))
+                            {
+                                targetsToCheckForAfterTargets.Enqueue(afterTarget.TargetName);
+                            }
                         }
                     }
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index 1a68631a166..e63167fef65 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Threading;
@@ -15,7 +14,6 @@
 using Microsoft.Build.Shared.FileSystem;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
-using MessageImportance = Microsoft.Build.Framework.MessageImportance;
 using ProjectLoggingContext = Microsoft.Build.BackEnd.Logging.ProjectLoggingContext;
 using TargetLoggingContext = Microsoft.Build.BackEnd.Logging.TargetLoggingContext;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
@@ -362,7 +360,7 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 if (!projectLoggingContext.LoggingService.OnlyLogCriticalEvents)
                 {
                     // Expand the expression for the Log.  Since we know the condition evaluated to false, leave unexpandable properties in the condition so as not to cause an error
-                    string expanded = _expander.ExpandIntoStringAndUnescape(_target.Condition, ExpanderOptions.ExpandPropertiesAndItems | ExpanderOptions.LeavePropertiesUnexpandedOnError, _target.ConditionLocation);
+                    string expanded = _expander.ExpandIntoStringAndUnescape(_target.Condition, ExpanderOptions.ExpandPropertiesAndItems | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _target.ConditionLocation);
 
                     // By design: Not building dependencies. This is what NAnt does too.
                     // NOTE: In the original code, this was logged from the target logging context.  However, the target
@@ -546,11 +544,8 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                         // Make sure the Invalid Project error gets logged *before* TargetFinished.  Otherwise,
                         // the log is confusing.
                         targetLoggingContext.LogInvalidProjectFileError(e);
-
                         entryForInference?.LeaveScope();
-
                         entryForExecution?.LeaveScope();
-
                         aggregateResult = aggregateResult.AggregateResult(new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null));
                     }
                     finally
@@ -718,7 +713,7 @@ internal List<TargetSpecification> GetErrorTargets(ProjectLoggingContext project
 
             // If this target never executed (for instance, because one of its dependencies errored) then we need to
             // create a result for this target to report when it gets to the Completed state.
-            if (null == _targetResult)
+            if (_targetResult == null)
             {
                 _targetResult = new TargetResult(Array.Empty<TaskItem>(), new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null));
             }
@@ -747,7 +742,7 @@ internal TargetResult GatherResults()
         /// <param name="lookup">The lookup to enter with.</param>
         internal void EnterLegacyCallTargetScope(Lookup lookup)
         {
-            if (null == _legacyCallTargetScopes)
+            if (_legacyCallTargetScopes == null)
             {
                 _legacyCallTargetScopes = new Stack<Lookup.Scope>();
             }
@@ -783,7 +778,7 @@ internal void MarkForStop()
         /// </summary>
         internal void LeaveLegacyCallTargetScopes()
         {
-            if (null != _legacyCallTargetScopes)
+            if (_legacyCallTargetScopes != null)
             {
                 while (_legacyCallTargetScopes.Count != 0)
                 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
index a2efa711584..4da4b2f8aba 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index f3aff939396..46e86a679c9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 
 using Microsoft.Build.Collections;
@@ -153,24 +152,13 @@ out ItemDictionary<ProjectItemInstance> upToDateTargetInputs
             }
             else
             {
-                ItemVectorPartitionCollection itemVectorsInTargetInputs;
-                ItemVectorPartitionCollection itemVectorTransformsInTargetInputs;
-                Dictionary<string, string> discreteItemsInTargetInputs; // UNDONE: (Refactor) Change to HashSet
-
-                ItemVectorPartitionCollection itemVectorsInTargetOutputs;
-                Dictionary<string, string> discreteItemsInTargetOutputs; // UNDONE: (Refactor) Change to HashSet
-                List<string> targetOutputItemSpecs;
-
                 ParseTargetInputOutputSpecifications(bucket,
-                    out itemVectorsInTargetInputs,
-                    out itemVectorTransformsInTargetInputs,
-                    out discreteItemsInTargetInputs,
-                    out itemVectorsInTargetOutputs,
-                    out discreteItemsInTargetOutputs,
-                    out targetOutputItemSpecs);
-
-                List<string> itemVectorsReferencedInBothTargetInputsAndOutputs = null;
-                List<string> itemVectorsReferencedOnlyInTargetInputs = null;
+                    out ItemVectorPartitionCollection itemVectorsInTargetInputs,
+                    out ItemVectorPartitionCollection itemVectorTransformsInTargetInputs,
+                    out Dictionary<string, string> discreteItemsInTargetInputs,
+                    out ItemVectorPartitionCollection itemVectorsInTargetOutputs,
+                    out Dictionary<string, string> discreteItemsInTargetOutputs,
+                    out List<string> targetOutputItemSpecs);
                 List<string> itemVectorsReferencedOnlyInTargetOutputs = null;
 
                 // if the target has no outputs because the output specification evaluated to empty
@@ -189,8 +177,8 @@ out ItemDictionary<ProjectItemInstance> upToDateTargetInputs
                     // depending on the transform expression, there might be no relation between the results of the transforms; as
                     // a result, input items that are item vector transforms are treated as discrete items
                     DiffHashtables(itemVectorsInTargetInputs, itemVectorsInTargetOutputs,
-                        out itemVectorsReferencedInBothTargetInputsAndOutputs,
-                        out itemVectorsReferencedOnlyInTargetInputs,
+                        out List<string> itemVectorsReferencedInBothTargetInputsAndOutputs,
+                        out List<string> itemVectorsReferencedOnlyInTargetInputs,
                         out itemVectorsReferencedOnlyInTargetOutputs);
 
                     // if there are no item vectors only referenced by output items...
@@ -555,8 +543,7 @@ List<string> targetOutputItemSpecs
                 }
 
                 // if any output item is out-of-date w.r.t. any discrete input item, do a full build
-                DependencyAnalysisLogDetail dependencyAnalysisDetailEntry;
-                bool someOutOfDate = IsAnyOutOfDate(out dependencyAnalysisDetailEntry, _project.Directory, inputs, outputs);
+                bool someOutOfDate = IsAnyOutOfDate(out DependencyAnalysisLogDetail dependencyAnalysisDetailEntry, _project.Directory, inputs, outputs);
 
                 if (someOutOfDate)
                 {
@@ -655,8 +642,7 @@ out ItemDictionary<ProjectItemInstance> upToDateTargetInputs
                             else
                             {
                                 // if any input is newer than any output, do a full build
-                                DependencyAnalysisLogDetail dependencyAnalysisDetailEntry;
-                                bool someOutOfDate = IsAnyOutOfDate(out dependencyAnalysisDetailEntry, _project.Directory, upToDateInputItems, outputItems);
+                                bool someOutOfDate = IsAnyOutOfDate(out DependencyAnalysisLogDetail dependencyAnalysisDetailEntry, _project.Directory, upToDateInputItems, outputItems);
 
                                 if (someOutOfDate)
                                 {
@@ -741,8 +727,6 @@ private DependencyAnalysisResult PerformDependencyAnalysisIfDiscreteOutputs
             List<string> targetOutputItemSpecs
         )
         {
-            DependencyAnalysisResult result = DependencyAnalysisResult.SkipUpToDate;
-
             List<string> targetInputItemSpecs = GetItemSpecsFromItemVectors(itemVectorsInTargetInputs);
             targetInputItemSpecs.AddRange(GetItemSpecsFromItemVectors(itemVectorTransformsInTargetInputs));
             targetInputItemSpecs.AddRange(discreteItemsInTargetInputs.Values);
@@ -761,9 +745,9 @@ List<string> targetOutputItemSpecs
             }
 
             // if any input is newer than any output, do a full build
-            DependencyAnalysisLogDetail dependencyAnalysisDetailEntry;
-            bool someOutOfDate = IsAnyOutOfDate(out dependencyAnalysisDetailEntry, _project.Directory, inputs, outputs);
+            bool someOutOfDate = IsAnyOutOfDate(out DependencyAnalysisLogDetail dependencyAnalysisDetailEntry, _project.Directory, inputs, outputs);
 
+            DependencyAnalysisResult result;
             if (someOutOfDate)
             {
                 _dependencyAnalysisDetail.Add(dependencyAnalysisDetailEntry);
@@ -819,8 +803,7 @@ ElementLocation elementLocation
                 ProjectItemInstanceFactory itemFactory = new ProjectItemInstanceFactory(
                     _project /* no item type specified; use item type of vector itself */);
 
-                bool isTransformExpression;
-                IList<ProjectItemInstance> itemVectorContents = bucket.Expander.ExpandSingleItemVectorExpressionIntoItems(item, itemFactory, ExpanderOptions.ExpandItems, true /* include null entries from transforms */, out isTransformExpression, elementLocation);
+                IList<ProjectItemInstance> itemVectorContents = bucket.Expander.ExpandSingleItemVectorExpressionIntoItems(item, itemFactory, ExpanderOptions.ExpandItems, true /* include null entries from transforms */, out bool isTransformExpression, elementLocation);
 
                 if (itemVectorContents != null)
                 {
@@ -828,11 +811,11 @@ ElementLocation elementLocation
 
                     if (itemVectorContents.Count > 0)
                     {
-                        ItemVectorPartitionCollection itemVectorCollection = null;
 
                         // Expander set the item type it found
                         string itemVectorType = itemFactory.ItemType;
 
+                        ItemVectorPartitionCollection itemVectorCollection;
                         if (itemVectorTransforms == null || !isTransformExpression)
                         {
                             // We either don't want transforms separated out, or this was not a transform.
@@ -1125,11 +1108,9 @@ private void RecordUniqueInputsAndOutputs<T>(IList<T> inputs, IList<T> outputs)
         /// <returns>true, if "input" is newer than "output"</returns>
         private bool IsOutOfDate(string input, string output, string inputItemName, string outputItemName)
         {
-            bool inputDoesNotExist;
-            bool outputDoesNotExist;
             input = EscapingUtilities.UnescapeAll(FileUtilities.FixFilePath(input));
             output = EscapingUtilities.UnescapeAll(FileUtilities.FixFilePath(output));
-            bool outOfDate = (CompareLastWriteTimes(input, output, out inputDoesNotExist, out outputDoesNotExist) == 1) || inputDoesNotExist;
+            bool outOfDate = (CompareLastWriteTimes(input, output, out bool inputDoesNotExist, out bool outputDoesNotExist) == 1) || inputDoesNotExist;
 
             // Only if we are not logging just critical events should we be gathering full details
             if (!_loggingService.OnlyLogCriticalEvents)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 7fe98bde0a3..58a0e6931bc 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -382,9 +382,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
             if (!condition)
             {
                 LogSkippedTask(bucket, howToExecuteTask);
-                taskResult = new WorkUnitResult(WorkUnitResultCode.Skipped, WorkUnitActionCode.Continue, null);
-
-                return taskResult;
+                return new WorkUnitResult(WorkUnitResultCode.Skipped, WorkUnitActionCode.Continue, null);
             }
 
             // Some tests do not provide an actual taskNode; checking if _taskNode == null prevents those tests from failing.
@@ -609,7 +607,7 @@ private void LogSkippedTask(ItemBucket bucket, TaskExecutionMode howToExecuteTas
                     if (!_targetLoggingContext.LoggingService.OnlyLogCriticalEvents)
                     {
                         // Expand the expression for the Log.  Since we know the condition evaluated to false, leave unexpandable properties in the condition so as not to cause an error
-                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError, _targetChildInstance.ConditionLocation);
+                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation);
 
                         // Whilst we are within the processing of the task, we haven't actually started executing it, so
                         // our skip task message needs to be in the context of the target. However any errors should be reported
@@ -940,7 +938,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                 // that is logged as an error. MSBuild tasks are an exception because
                 // errors are not logged directly from them, but the tasks spawned by them.
                 IBuildEngine be = host.TaskInstance.BuildEngine;
-                if (taskReturned && !taskResult && !taskLoggingContext.HasLoggedErrors && (be is TaskHost th ? th.BuildRequestsSucceeded : false) && (be is IBuildEngine7 be7 ? be7.AllowFailureWithoutError : true))
+                if (taskReturned && !taskResult && !taskLoggingContext.HasLoggedErrors && (be is TaskHost th ? th.BuildRequestsSucceeded : false) && (be is IBuildEngine7 be7 ? !be7.AllowFailureWithoutError : true))
                 {
                     if (_continueOnError == ContinueOnError.WarnAndContinue)
                     {
@@ -1181,7 +1179,7 @@ ItemBucket bucket
         {
             string taskParameterAttribute = _taskNode.GetParameter(taskParameterName);
 
-            if (null != taskParameterAttribute)
+            if (taskParameterAttribute != null)
             {
                 ProjectTaskOutputItemInstance taskItemInstance = taskOutputSpecification as ProjectTaskOutputItemInstance;
                 if (taskItemInstance != null)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 3e2f83c917a..8d830c38a0b 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -10,7 +10,6 @@
 using System.Runtime.Remoting;
 #endif
 using System.Threading;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
@@ -674,7 +673,7 @@ public IReadOnlyDictionary<string, string> GetGlobalProperties()
         /// <summary>
         /// Enables or disables emitting a default error when a task fails without logging errors
         /// </summary>
-        public bool AllowFailureWithoutError { get; set; } = true;
+        public bool AllowFailureWithoutError { get; set; } = false;
         #endregion
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Scheduler/IScheduler.cs b/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
index b0a49cc9a32..eb30122e633 100644
--- a/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
@@ -1,9 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Collections.ObjectModel;
 using Microsoft.Build.Execution;
 
 namespace Microsoft.Build.BackEnd
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
index b9dc833cdf9..590cc2c74a9 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
 
diff --git a/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs b/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs
index 037557a4ddc..955e5e070e5 100644
--- a/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs
+++ b/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs
@@ -2,14 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Globalization;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
 
-using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
-
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Scheduler/ScheduleTimeRecord.cs b/src/Build/BackEnd/Components/Scheduler/ScheduleTimeRecord.cs
index 5acdfbe7b06..d17fe5734e2 100644
--- a/src/Build/BackEnd/Components/Scheduler/ScheduleTimeRecord.cs
+++ b/src/Build/BackEnd/Components/Scheduler/ScheduleTimeRecord.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index acd599a952e..0ce340f4828 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Globalization;
@@ -10,7 +9,6 @@
 using System.Linq;
 using System.Text;
 using System.Threading;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -18,7 +16,6 @@
 using BuildAbortedException = Microsoft.Build.Exceptions.BuildAbortedException;
 using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
 using NodeLoggingContext = Microsoft.Build.BackEnd.Logging.NodeLoggingContext;
-using CommunicationsUtilities = Microsoft.Build.Internal.CommunicationsUtilities;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -162,8 +159,6 @@ public Scheduler()
             _forceAffinityOutOfProc = Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") == "1";
             _debugDumpPath = Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
             _schedulingUnlimitedVariable = Environment.GetEnvironmentVariable("MSBUILDSCHEDULINGUNLIMITED");
-            string strNodeLimitOffset = null;
-
             _nodeLimitOffset = 0;
 
             if (!String.IsNullOrEmpty(_schedulingUnlimitedVariable))
@@ -174,8 +169,7 @@ public Scheduler()
             {
                 _schedulingUnlimited = false;
 
-                strNodeLimitOffset = Environment.GetEnvironmentVariable("MSBUILDNODELIMITOFFSET");
-
+                string strNodeLimitOffset = Environment.GetEnvironmentVariable("MSBUILDNODELIMITOFFSET");
                 if (!String.IsNullOrEmpty(strNodeLimitOffset))
                 {
                     _nodeLimitOffset = Int16.Parse(strNodeLimitOffset, CultureInfo.InvariantCulture);
@@ -603,8 +597,6 @@ private void ScheduleUnassignedRequests(List<ScheduleResponse> responses)
 
             // Resume any work available which has already been assigned to specific nodes.
             ResumeRequiredWork(responses);
-
-            int nodesFreeToDoWorkPriorToScheduling = 0;
             HashSet<int> idleNodes = new HashSet<int>();
             foreach (int availableNodeId in _availableNodes.Keys)
             {
@@ -614,7 +606,7 @@ private void ScheduleUnassignedRequests(List<ScheduleResponse> responses)
                 }
             }
 
-            nodesFreeToDoWorkPriorToScheduling = idleNodes.Count;
+            int nodesFreeToDoWorkPriorToScheduling = idleNodes.Count;
 
             // Assign requests to any nodes which are currently idle.
             if (idleNodes.Count > 0 && _schedulingData.UnscheduledRequestsCount > 0)
@@ -1557,7 +1549,7 @@ private void HandleRequestBlockedByNewRequests(SchedulableRequest parentRequest,
                 // directly here.  We COULD simply report these as blocking the parent request and let the scheduler pick them up later when the parent
                 // comes back up as schedulable, but we prefer to send the results back immediately so this request can (potentially) continue uninterrupted.
                 ScheduleResponse response = TrySatisfyRequestFromCache(nodeForResults, request, skippedResultsDoNotCauseCacheMiss: _componentHost.BuildParameters.SkippedResultsDoNotCauseCacheMiss());
-                if (null != response)
+                if (response != null)
                 {
                     TraceScheduler("Request {0} (node request {1}) satisfied from the cache.", request.GlobalRequestId, request.NodeRequestId);
 
@@ -2080,7 +2072,7 @@ private void WriteNodeUtilizationGraph(ILoggingService loggingService, BuildEven
                 currentWork[i] = invalidWorkId;
                 previousWork[i] = invalidWorkId;
                 runningRequests[i] = new HashSet<int>();
-                nodeIndices.Append(String.Format(CultureInfo.InvariantCulture, "{0,-5}   ", indexToAvailableNodeId[i]));
+                nodeIndices.AppendFormat(CultureInfo.InvariantCulture, "{0,-5}   ", indexToAvailableNodeId[i]);
             }
 
             loggingService.LogComment(context, MessageImportance.Normal, "NodeUtilizationHeader", nodeIndices.ToString());
@@ -2205,7 +2197,7 @@ private void WriteNodeUtilizationGraphLine(ILoggingService loggingService, Build
                 }
                 else
                 {
-                    stringBuilder.Append(String.Format(CultureInfo.InvariantCulture, "{0,-5}   ", currentWork[i]));
+                    stringBuilder.AppendFormat(CultureInfo.InvariantCulture, "{0,-5}   ", currentWork[i]);
                     haveNonIdleNode = true;
                 }
             }
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs b/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs
index 1d771cb5a72..43d90a092bf 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
-using System.Text;
 
 namespace Microsoft.Build.BackEnd
 {
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
index 9f026e15fb0..804ac117b8a 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
@@ -3,11 +3,8 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Execution;
 
 namespace Microsoft.Build.BackEnd
 {
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index 7eca22fd71a..c719a51d2df 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -5,13 +5,10 @@
 using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
-using System.Text;
-using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.BackEnd
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index 0c52dddff33..d0ba73f4f8d 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -3,11 +3,9 @@
 
 using Microsoft.Build.BackEnd.Components.Logging;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index 1f9eb065df4..e0d472eea6e 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -20,11 +20,16 @@ internal class SdkResolverLoader
         private readonly CoreClrAssemblyLoader _loader = new CoreClrAssemblyLoader();
 #endif
 
+        private readonly string IncludeDefaultResolver = Environment.GetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER");
+
+        private readonly string AdditionalResolversFolder = Environment.GetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER");
+
         internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
             ElementLocation location)
         {
-            // Always add the default resolver
-            var resolvers = new List<SdkResolver> {new DefaultSdkResolver()};
+            var resolvers = !String.Equals(IncludeDefaultResolver, "false", StringComparison.OrdinalIgnoreCase) ? 
+                new List<SdkResolver> {new DefaultSdkResolver()}
+                : new List<SdkResolver>();
 
             var potentialResolvers = FindPotentialSdkResolvers(
                 Path.Combine(BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32, "SdkResolvers"), location);
@@ -53,12 +58,14 @@ internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder, Elem
         {
             var assembliesList = new List<string>();
 
-            if (string.IsNullOrEmpty(rootFolder) || !FileUtilities.DirectoryExistsNoThrow(rootFolder))
+            if ((string.IsNullOrEmpty(rootFolder) || !FileUtilities.DirectoryExistsNoThrow(rootFolder)) && AdditionalResolversFolder == null)
             {
                 return assembliesList;
             }
 
-            foreach (var subfolder in new DirectoryInfo(rootFolder).GetDirectories())
+            DirectoryInfo[] subfolders = GetSubfolders(rootFolder, AdditionalResolversFolder);
+
+            foreach (var subfolder in subfolders)
             {
                 var assembly = Path.Combine(subfolder.FullName, $"{subfolder.Name}.dll");
                 var manifest = Path.Combine(subfolder.FullName, $"{subfolder.Name}.xml");
@@ -78,6 +85,44 @@ internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder, Elem
             return assembliesList;
         }
 
+        private DirectoryInfo[] GetSubfolders(string rootFolder, string additionalResolversFolder)
+        {
+            DirectoryInfo[] subfolders = null;
+            if (!string.IsNullOrEmpty(rootFolder) && FileUtilities.DirectoryExistsNoThrow(rootFolder))
+            {
+                subfolders = new DirectoryInfo(rootFolder).GetDirectories();
+            }
+
+            if (additionalResolversFolder != null)
+            {
+                var resolversDirInfo = new DirectoryInfo(additionalResolversFolder);
+                if (resolversDirInfo.Exists)
+                {
+                    HashSet<DirectoryInfo> overrideFolders = resolversDirInfo.GetDirectories().ToHashSet(new DirInfoNameComparer());
+                    if (subfolders != null)
+                    {
+                        overrideFolders.UnionWith(subfolders);
+                    }
+                    return overrideFolders.ToArray();
+                }
+            }
+
+            return subfolders;
+        }
+
+        private class DirInfoNameComparer : IEqualityComparer<DirectoryInfo>
+        {
+            public bool Equals(DirectoryInfo first, DirectoryInfo second)
+            {
+                return string.Equals(first.Name, second.Name, StringComparison.OrdinalIgnoreCase);
+            }
+
+            public int GetHashCode(DirectoryInfo value)
+            {
+                return value.Name.GetHashCode();
+            }
+        }
+
         private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFolder, List<string> assembliesList, ElementLocation location)
         {
             if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest)) return false;
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
index 6f9778a9eb8..3f02bac8abc 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResult.cs
@@ -5,7 +5,6 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Runtime.Versioning;
 using SdkReference = Microsoft.Build.Framework.SdkReference;
 using SdkResultBase = Microsoft.Build.Framework.SdkResult;
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/TranslationHelpers.cs b/src/Build/BackEnd/Components/SdkResolution/TranslationHelpers.cs
index 2a518c1b9e2..37ba6eb79d9 100644
--- a/src/Build/BackEnd/Components/SdkResolution/TranslationHelpers.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/TranslationHelpers.cs
@@ -1,9 +1,6 @@
 ﻿using Microsoft.Build.Framework;
 using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.BackEnd.SdkResolution
 {
diff --git a/src/Build/BackEnd/Node/InProcNode.cs b/src/Build/BackEnd/Node/InProcNode.cs
index 580187c97f4..0a5db6abbb2 100644
--- a/src/Build/BackEnd/Node/InProcNode.cs
+++ b/src/Build/BackEnd/Node/InProcNode.cs
@@ -287,7 +287,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
             try
             {
                 // Clean up the engine
-                if (null != _buildRequestEngine && _buildRequestEngine.Status != BuildRequestEngineStatus.Uninitialized)
+                if (_buildRequestEngine != null && _buildRequestEngine.Status != BuildRequestEngineStatus.Uninitialized)
                 {
                     _buildRequestEngine.CleanupForBuild();
                 }
@@ -338,7 +338,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
 
             exception = _shutdownException;
 
-            if (null != _loggingContext)
+            if (_loggingContext != null)
             {
                 _loggingContext.LoggingService.OnLoggingThreadException -= OnLoggingThreadException;
                 _loggingContext = null;
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 4d170a3853c..0ae529953d0 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -424,7 +424,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
             CommunicationsUtilities.Trace("Shutting down with reason: {0}, and exception: {1}.", _shutdownReason, _shutdownException);
 
             // Clean up the engine
-            if (null != _buildRequestEngine && _buildRequestEngine.Status != BuildRequestEngineStatus.Uninitialized)
+            if (_buildRequestEngine != null && _buildRequestEngine.Status != BuildRequestEngineStatus.Uninitialized)
             {
                 _buildRequestEngine.CleanupForBuild();
 
@@ -475,7 +475,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
             try
             {
                 // Shut down logging, which will cause all queued logging messages to be sent.
-                if (null != _loggingContext && null != _loggingService)
+                if (_loggingContext != null && _loggingService != null)
                 {
                     _loggingContext.LogBuildFinished(true);
                     ((IBuildComponent)_loggingService).ShutdownComponent();
@@ -484,7 +484,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
             finally
             {
                 // Shut down logging, which will cause all queued logging messages to be sent.
-                if (null != _loggingContext && null != _loggingService)
+                if (_loggingContext != null && _loggingService != null)
                 {
                     _loggingContext.LoggingService.OnLoggingThreadException -= OnLoggingThreadException;
                     _loggingContext = null;
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index e5d4460efd7..feb27293007 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -10,8 +10,6 @@
 using System.Diagnostics;
 using System.IO;
 using System.Linq;
-using System.Threading;
-using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Globbing;
 using Microsoft.Build.Shared.FileSystem;
@@ -555,9 +553,9 @@ internal int ResultsNodeId
         /// <returns>True if the objects are equivalent, false otherwise.</returns>
         public static bool operator ==(BuildRequestConfiguration left, BuildRequestConfiguration right)
         {
-            if (ReferenceEquals(left, null))
+            if (left is null)
             {
-                if (ReferenceEquals(right, null))
+                if (right is null)
                 {
                     return true;
                 }
@@ -568,7 +566,7 @@ internal int ResultsNodeId
             }
             else
             {
-                if (ReferenceEquals(right, null))
+                if (right is null)
                 {
                     return false;
                 }
@@ -748,7 +746,7 @@ public override string ToString()
         /// <returns>True if they contain the same data, false otherwise</returns>
         public override bool Equals(object obj)
         {
-            if (ReferenceEquals(obj, null))
+            if (obj is null)
             {
                 return false;
             }
@@ -770,7 +768,7 @@ public override bool Equals(object obj)
         /// <returns>True if equal, false otherwise.</returns>
         public bool Equals(BuildRequestConfiguration other)
         {
-            if (ReferenceEquals(other, null))
+            if (other is null)
             {
                 return false;
             }
diff --git a/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs b/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
index 74f3a81a22a..49403b5f032 100644
--- a/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestUnblocker.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index ec0d6b998c9..b5bf9d3706d 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -334,7 +334,7 @@ public BuildResultCode OverallResult
         {
             get
             {
-                if (null != _requestException || _circularDependency || !_baseOverallResult)
+                if (_requestException != null || _circularDependency || !_baseOverallResult)
                 {
                     return BuildResultCode.Failure;
                 }
diff --git a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
index e67a10c96cb..ef92495c45a 100644
--- a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
+++ b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
@@ -119,7 +119,7 @@ public static ConfigurationMetadata FactoryForDeserialization(ITranslator transl
         /// <returns>True if they contain the same data, false otherwise</returns>
         public override bool Equals(object obj)
         {
-            if (ReferenceEquals(obj, null))
+            if (obj is null)
             {
                 return false;
             }
@@ -141,7 +141,7 @@ public override bool Equals(object obj)
         /// <returns>True if equal, false otherwise.</returns>
         public bool Equals(ConfigurationMetadata other)
         {
-            if (ReferenceEquals(other, null))
+            if (other is null)
             {
                 return false;
             }
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index a90150fdfa5..3eb907062e7 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -5,14 +5,12 @@
 using System.Diagnostics;
 using System.IO;
 using System.Globalization;
-using System.IO.Compression;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
-using System.Diagnostics.CodeAnalysis;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Collections;
 
 namespace Microsoft.Build.Execution
 {
@@ -39,7 +37,7 @@ public class TargetResult : ITargetResult, ITranslatable
         /// <summary>
         /// The store of items in this result.
         /// </summary>
-        private ItemsStore _itemsStore;
+        private TaskItem[] _items;
 
         /// <summary>
         /// The context under which these results have been cached.
@@ -55,7 +53,7 @@ internal TargetResult(TaskItem[] items, WorkUnitResult result)
         {
             ErrorUtilities.VerifyThrowArgumentNull(items, nameof(items));
             ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
-            _itemsStore = new ItemsStore(items);
+            _items = items;
             _result = result;
         }
 
@@ -71,7 +69,8 @@ private TargetResult(ITranslator translator)
         /// Returns the exception which aborted this target, if any.
         /// </summary>
         /// <value>The exception which aborted this target, if any.</value>
-        public Exception Exception {
+        public Exception Exception
+        {
             [DebuggerStepThrough]
             get => _result.Exception;
         }
@@ -90,10 +89,7 @@ public ITaskItem[] Items
                 {
                     RetrieveItemsFromCache();
 
-                    // NOTE: If the items in the ItemsStore were compressed, this will decompress them.  If the only purpose to
-                    // getting these items is to check the length, then that is inefficient and we should come up with a better
-                    // way of getting the count (such as another interface method which delegates to the ItemsStore itself.
-                    return _itemsStore.Items;
+                    return _items;
                 }
             }
         }
@@ -217,13 +213,13 @@ internal void CacheItems(int configId, string targetName)
         {
             lock (_result)
             {
-                if (_itemsStore == null)
+                if (_items == null)
                 {
                     // Already cached.
                     return;
                 }
 
-                if (_itemsStore.ItemsCount == 0)
+                if (_items.Length == 0)
                 {
                     // Nothing to cache.
                     return;
@@ -237,8 +233,8 @@ internal void CacheItems(int configId, string targetName)
                 {
                     try
                     {
-                        translator.Translate(ref _itemsStore, ItemsStore.FactoryForDeserialization);
-                        _itemsStore = null;
+                        TranslateItems(translator);
+                        _items = null;
                         _cacheInfo = new CacheInfo(configId, targetName);
                     }
                     finally
@@ -257,7 +253,7 @@ private void InternalTranslate(ITranslator translator)
             translator.Translate(ref _result, WorkUnitResult.FactoryForDeserialization);
             translator.Translate(ref _targetFailureDoesntCauseBuildFailure);
             translator.Translate(ref _afterTargetsHaveFailed);
-            translator.Translate(ref _itemsStore, ItemsStore.FactoryForDeserialization);
+            TranslateItems(translator);
         }
 
         /// <summary>
@@ -267,13 +263,13 @@ private void RetrieveItemsFromCache()
         {
             lock (_result)
             {
-                if (_itemsStore == null)
+                if (_items == null)
                 {
                     ITranslator translator = GetResultsCacheTranslator(_cacheInfo.ConfigId, _cacheInfo.TargetName, TranslationDirection.ReadFromStream);
 
                     try
                     {
-                        translator.Translate(ref _itemsStore, ItemsStore.FactoryForDeserialization);
+                        TranslateItems(translator);
                         _cacheInfo = new CacheInfo();
                     }
                     finally
@@ -284,6 +280,55 @@ private void RetrieveItemsFromCache()
             }
         }
 
+        private void TranslateItems(ITranslator translator)
+        {
+            var itemsCount = _items?.Length ?? 0;
+            translator.Translate(ref itemsCount);
+
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                // We will just calculate a very rough starting buffer size for the memory stream based on the number of items and a
+                // rough guess for an average number of bytes needed to store them.  This doesn't have to be accurate, just
+                // big enough to avoid unnecessary buffer reallocations in most cases.
+                var defaultBufferCapacity = _items.Length * 128;
+                
+                using var itemsStream = new MemoryStream(defaultBufferCapacity);
+                var itemTranslator = BinaryTranslator.GetWriteTranslator(itemsStream);
+
+                // When creating the interner, we use the number of items as the initial size of the collections since the
+                // number of strings will be of the order of the number of items in the collection.  This assumes basically
+                // one unique string per item (frequently a path related to the item) with most of the rest of the metadata
+                // being the same (and thus interning.)  This is a hueristic meant to get us in the ballpark to avoid 
+                // too many reallocations when growing the collections.
+                var interner = new LookasideStringInterner(StringComparer.Ordinal, _items.Length);
+                foreach (TaskItem t in _items)
+                {
+                    t.TranslateWithInterning(itemTranslator, interner);
+                }
+
+                interner.Translate(translator);
+                var buffer = itemsStream.GetBuffer();
+                var bufferSize = (int)itemsStream.Length;
+                translator.Translate(ref buffer, ref bufferSize);
+            }
+            else
+            {
+                var interner = new LookasideStringInterner(translator);
+
+                byte[] buffer = null;
+                translator.Translate(ref buffer);
+                ErrorUtilities.VerifyThrow(buffer != null, "Unexpected null items buffer during translation.");
+
+                using MemoryStream itemsStream = new MemoryStream(buffer, 0, buffer.Length, writable: false, publiclyVisible: true);
+                var itemTranslator = BinaryTranslator.GetReadTranslator(itemsStream, null);
+                _items = new TaskItem[itemsCount];
+                for (int i = 0; i < _items.Length; i++)
+                {
+                    _items[i] = TaskItem.FactoryForDeserialization(itemTranslator, interner);
+                }
+            }
+        }
+
         /// <summary>
         /// Gets the translator for this configuration.
         /// </summary>
@@ -331,238 +376,5 @@ public CacheInfo(int configId, string targetName)
             /// </summary>
             public string TargetName { get; }
         }
-
-        /// <summary>
-        /// The store of items for the target result.  This class is responsible for the serialization of the items collection, which is 
-        /// useful to keep separate as it is where we spend most of our time serializing for large projects, and these are the bits
-        /// we throw out of memory when the cache gets collected.
-        /// </summary>
-        private class ItemsStore : ITranslatable
-        {
-            /// <summary>
-            /// The default compression threshold.
-            /// </summary>
-            private const int DefaultCompressionThreshold = 32;
-
-            /// <summary>
-            /// The count of items we will store before we start using compression.
-            /// </summary>
-            /// <remarks>
-            /// This value was determined empirically by looking at how many items tend to be transmitted for "normal" projects versus the ones
-            /// which benefit from this technique.
-            /// </remarks>
-            private static readonly int s_compressionThreshold;
-
-            /// <summary>
-            /// The compressed set of items, if any.
-            /// </summary>
-            private byte[] _compressedItems;
-
-            /// <summary>
-            /// The count of items, stored here so that we don't have to decompress the items if we are
-            /// only looking at the count.
-            /// </summary>
-            private int _itemsCount;
-
-            /// <summary>
-            /// The items produced by this target.
-            /// </summary>
-            private TaskItem[] _uncompressedItems;
-
-            /// <summary>
-            /// Static constructor.
-            /// </summary>
-            static ItemsStore()
-            {
-                if (Int32.TryParse(Environment.GetEnvironmentVariable("MSBUILDTARGETRESULTCOMPRESSIONTHRESHOLD"), out ItemsStore.s_compressionThreshold))
-                {
-                    if (s_compressionThreshold < 0)
-                    {
-                        s_compressionThreshold = 0;
-                    }
-                }
-                else
-                {
-                    s_compressionThreshold = DefaultCompressionThreshold;
-                }
-            }
-
-            /// <summary>
-            /// Constructor
-            /// </summary>
-            public ItemsStore(TaskItem[] items)
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(items, nameof(items));
-                _uncompressedItems = items;
-                _itemsCount = items.Length;
-            }
-
-            /// <summary>
-            /// Constructor for serialization.
-            /// </summary>
-            private ItemsStore(ITranslator translator)
-            {
-                Translate(translator);
-            }
-
-            /// <summary>
-            /// Gets the count of items.
-            /// </summary>
-            public int ItemsCount => _itemsCount;
-
-            /// <summary>
-            /// Retrieves the items.
-            /// </summary>
-            /// <remarks>
-            /// It's important not to call this method merely to get a count of the items held in the collection.
-            /// Instead use ItemsCount (above) for that.
-            /// </remarks>
-            public TaskItem[] Items
-            {
-                get
-                {
-                    if (_uncompressedItems == null)
-                    {
-                        DecompressItems();
-                    }
-
-                    return _uncompressedItems;
-                }
-            }
-
-            /*
-            /// <summary>
-            /// Throws out the deserialized items.
-            /// </summary>
-            /// <remarks>
-            /// Not presently used, but could be used for a multi-stage caching mechanism which first throws out decompressed items,
-            /// then if more space is needed, starts throwing out the compressed ones.
-            /// </remarks>
-            public void ReleaseItems()
-            {
-                if (_compressedItems == null)
-                {
-                    CompressItems();
-                }
-            }
-            */
-
-            /// <summary>
-            /// Translates an items store.
-            /// </summary>
-            public void Translate(ITranslator translator)
-            {
-                if (_compressedItems == null && translator.Mode == TranslationDirection.WriteToStream)
-                {
-                    CompressItemsIfNecessary();
-                }
-
-                // Note we only translate the serialized buffer (which contains the compressed and interned
-                // representation of the items.)  If the actual items are needed (for instance on child nodes)
-                // then the Items accessor will reconstitute them at the point they are needed.
-                ErrorUtilities.VerifyThrow((translator.Mode == TranslationDirection.ReadFromStream) || ((_compressedItems == null) ^ (_uncompressedItems == null)), "One of the compressed or uncompressed items arrays should be null.");
-                translator.Translate(ref _itemsCount);
-                translator.Translate(ref _compressedItems);
-                translator.TranslateArray(ref _uncompressedItems, TaskItem.FactoryForDeserialization);
-            }
-
-            /// <summary>
-            /// Factory for the serializer.
-            /// </summary>
-            internal static ItemsStore FactoryForDeserialization(ITranslator translator)
-            {
-                return new ItemsStore(translator);
-            }
-
-            /// <summary>
-            /// Compresses the items, but only if we have reached the threshold where it makes sense to do so.
-            /// </summary>
-            private void CompressItemsIfNecessary()
-            {
-                if (_itemsCount > s_compressionThreshold)
-                {
-                    CompressItems();
-                }
-            }
-
-            /// <summary>
-            /// Decompresses the items.
-            /// </summary>
-            private void DecompressItems()
-            {
-                ErrorUtilities.VerifyThrow(_uncompressedItems == null, "Items already decompressed.");
-                using (MemoryStream serializedStream = new MemoryStream(_compressedItems, 0, _compressedItems.Length, writable: false, publiclyVisible: true))
-                {
-                    using (DeflateStream inflateStream = new DeflateStream(serializedStream, CompressionMode.Decompress))
-                    {
-                        ITranslator serializedBufferTranslator = BinaryTranslator.GetReadTranslator(inflateStream, null);
-                        LookasideStringInterner interner = new LookasideStringInterner(serializedBufferTranslator);
-
-                        byte[] buffer = null;
-                        serializedBufferTranslator.Translate(ref buffer);
-                        ErrorUtilities.VerifyThrow(buffer != null, "Unexpected null items buffer during decompression.");
-
-                        using (MemoryStream itemsStream = new MemoryStream(buffer, 0, buffer.Length, writable: false, publiclyVisible: true))
-                        {
-                            ITranslator itemTranslator = BinaryTranslator.GetReadTranslator(itemsStream, null);
-                            _uncompressedItems = new TaskItem[_itemsCount];
-                            for (int i = 0; i < _uncompressedItems.Length; i++)
-                            {
-                                _uncompressedItems[i] = TaskItem.FactoryForDeserialization(itemTranslator, interner);
-                            }
-                        }
-                    }
-                }
-
-                _compressedItems = null;
-            }
-
-            /// <summary>
-            /// Compresses the items.
-            /// </summary>
-            private void CompressItems()
-            {
-                ErrorUtilities.VerifyThrow(_compressedItems == null, "Items already compressed.");
-
-                // We will just calculate a very rough starting buffer size for the memory stream based on the number of items and a
-                // rough guess for an average number of bytes needed to store them compressed.  This doesn't have to be accurate, just
-                // big enough to avoid unnecessary buffer reallocations in most cases.
-                int defaultCompressedBufferCapacity = _uncompressedItems.Length * 64;
-                using (var serializedStream = new MemoryStream(defaultCompressedBufferCapacity))
-                {
-                    using (var deflateStream = new DeflateStream(serializedStream, CompressionMode.Compress))
-                    {
-                        ITranslator serializedBufferTranslator = BinaryTranslator.GetWriteTranslator(deflateStream);
-
-                        // Again, a rough calculation of buffer size, this time for an uncompressed buffer.  We assume compression 
-                        // will give us 2:1, as it's all text.
-                        int defaultUncompressedBufferCapacity = defaultCompressedBufferCapacity * 2;
-                        using (var itemsStream = new MemoryStream(defaultUncompressedBufferCapacity))
-                        {
-                            ITranslator itemTranslator = BinaryTranslator.GetWriteTranslator(itemsStream);
-
-                            // When creating the interner, we use the number of items as the initial size of the collections since the
-                            // number of strings will be of the order of the number of items in the collection.  This assumes basically
-                            // one unique string per item (frequently a path related to the item) with most of the rest of the metadata
-                            // being the same (and thus interning.)  This is a hueristic meant to get us in the ballpark to avoid 
-                            // too many reallocations when growing the collections.
-                            LookasideStringInterner interner = new LookasideStringInterner(StringComparer.Ordinal, _uncompressedItems.Length);
-                            foreach (TaskItem t in _uncompressedItems)
-                            {
-                                t.TranslateWithInterning(itemTranslator, interner);
-                            }
-
-                            interner.Translate(serializedBufferTranslator);
-                            byte[] buffer = itemsStream.ToArray();
-                            serializedBufferTranslator.Translate(ref buffer);
-                        }
-                    }
-
-                    _compressedItems = serializedStream.ToArray();
-                }
-
-                _uncompressedItems = null;
-            }
-        }
     }
 }
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 27ad473350a..2a98b2fdf32 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -294,7 +294,7 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It
             // here. Instead, NDP will try to Load (not LoadFrom!) the task assembly into our AppDomain, and since
             // we originally used LoadFrom, it will fail miserably not knowing where to find it.
             // We need to temporarily subscribe to the AppDomain.AssemblyResolve event to fix it.
-            if (null == _resolver)
+            if (_resolver == null)
             {
                 _resolver = new TaskEngineAssemblyResolver();
                 _resolver.Initialize(_taskFactoryWrapper.TaskFactoryLoadedType.Assembly.AssemblyFile);
@@ -865,19 +865,19 @@ private TaskFactoryWrapper FindTaskInRegistry(IDictionary<string, string> taskId
             if (!_intrinsicTasks.TryGetValue(_taskName, out TaskFactoryWrapper returnClass))
             {
                 returnClass = _projectInstance.TaskRegistry.GetRegisteredTask(_taskName, null, taskIdentityParameters, true /* exact match */, _targetLoggingContext, _taskLocation);
-                if (null == returnClass)
+                if (returnClass == null)
                 {
                     returnClass = _projectInstance.TaskRegistry.GetRegisteredTask(_taskName, null, taskIdentityParameters, false /* fuzzy match */, _targetLoggingContext, _taskLocation);
 
-                    if (null == returnClass)
+                    if (returnClass == null)
                     {
                         returnClass = _projectInstance.TaskRegistry.GetRegisteredTask(_taskName, null, null, true /* exact match */, _targetLoggingContext, _taskLocation);
 
-                        if (null == returnClass)
+                        if (returnClass == null)
                         {
                             returnClass = _projectInstance.TaskRegistry.GetRegisteredTask(_taskName, null, null, false /* fuzzy match */, _targetLoggingContext, _taskLocation);
 
-                            if (null == returnClass)
+                            if (returnClass == null)
                             {
                                 _targetLoggingContext.LogError
                                     (
diff --git a/src/Build/Collections/CopyOnWritePropertyDictionary.cs b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
index 68f6cf3eaef..13fae383355 100644
--- a/src/Build/Collections/CopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
@@ -47,7 +47,7 @@ internal sealed class CopyOnWritePropertyDictionary<T> : IEnumerable<T>, IEquata
         /// <summary>
         /// Backing dictionary
         /// </summary>
-        private readonly CopyOnWriteDictionary<string, T> _properties;
+        private readonly CopyOnWriteDictionary<T> _properties;
 
         /// <summary>
         /// Creates empty dictionary
@@ -55,7 +55,7 @@ internal sealed class CopyOnWritePropertyDictionary<T> : IEnumerable<T>, IEquata
         public CopyOnWritePropertyDictionary()
         {
             // Tracing.Record("New COWD1");
-            _properties = new CopyOnWriteDictionary<string, T>(MSBuildNameIgnoreCaseComparer.Default);
+            _properties = new CopyOnWriteDictionary<T>(MSBuildNameIgnoreCaseComparer.Default);
         }
 
         /// <summary>
@@ -64,7 +64,7 @@ public CopyOnWritePropertyDictionary()
         public CopyOnWritePropertyDictionary(int capacity)
         {
             // Tracing.Record("New COWD2");
-            _properties = new CopyOnWriteDictionary<string, T>(capacity, MSBuildNameIgnoreCaseComparer.Default);
+            _properties = new CopyOnWriteDictionary<T>(capacity, MSBuildNameIgnoreCaseComparer.Default);
         }
 
         /// <summary>
@@ -251,7 +251,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// <returns>True if they are equivalent, false otherwise.</returns>
         public bool Equals(CopyOnWritePropertyDictionary<T> other)
         {
-            if (null == other)
+            if (other == null)
             {
                 return false;
             }
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index f9d871cc8f9..e3c17b24fae 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -264,7 +264,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// <returns>True if they are equivalent, false otherwise.</returns>
         public bool Equals(PropertyDictionary<T> other)
         {
-            if (null == other)
+            if (other == null)
             {
                 return false;
             }
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index 92adb2e2a31..001c7b87f69 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -10,7 +10,6 @@
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
-using System.Text;
 using System.Diagnostics.CodeAnalysis;
 using System.Security;
 using Microsoft.Build.Shared;
diff --git a/src/Build/Construction/ProjectItemElement.cs b/src/Build/Construction/ProjectItemElement.cs
index c0aa80082bd..8e6bbd2ffa8 100644
--- a/src/Build/Construction/ProjectItemElement.cs
+++ b/src/Build/Construction/ProjectItemElement.cs
@@ -10,8 +10,6 @@
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
-using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
diff --git a/src/Build/Construction/ProjectOnErrorElement.cs b/src/Build/Construction/ProjectOnErrorElement.cs
index 628c315dcc9..0dbced91dab 100644
--- a/src/Build/Construction/ProjectOnErrorElement.cs
+++ b/src/Build/Construction/ProjectOnErrorElement.cs
@@ -5,8 +5,6 @@
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
-using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
diff --git a/src/Build/Construction/ProjectOutputElement.cs b/src/Build/Construction/ProjectOutputElement.cs
index 42ef062218a..0df9620ec98 100644
--- a/src/Build/Construction/ProjectOutputElement.cs
+++ b/src/Build/Construction/ProjectOutputElement.cs
@@ -7,8 +7,6 @@
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
-using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
diff --git a/src/Build/Construction/ProjectTaskElement.cs b/src/Build/Construction/ProjectTaskElement.cs
index 424aa432fdf..79b4baa4c66 100644
--- a/src/Build/Construction/ProjectTaskElement.cs
+++ b/src/Build/Construction/ProjectTaskElement.cs
@@ -11,9 +11,6 @@
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
-using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-using System.Collections;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
@@ -35,7 +32,7 @@ internal ProjectTaskElement(ProjectTaskElementLink link)
         /// <summary>
         /// The parameters (excepting condition and continue-on-error)
         /// </summary>
-        private CopyOnWriteDictionary<string, (string, ElementLocation)> _parameters;
+        private CopyOnWriteDictionary<(string, ElementLocation)> _parameters;
 
         /// <summary>
         /// Protection for the parameters cache
@@ -210,7 +207,7 @@ public IEnumerable<KeyValuePair<string, ElementLocation>> ParameterLocations
         /// <summary>
         /// Retrieves a copy of the parameters as used during evaluation.
         /// </summary>
-        internal CopyOnWriteDictionary<string, (string, ElementLocation)> ParametersForEvaluation
+        internal CopyOnWriteDictionary<(string, ElementLocation)> ParametersForEvaluation
         {
             get
             {
@@ -443,7 +440,7 @@ private void EnsureParametersInitialized()
         {
             if (_parameters == null)
             {
-                _parameters = new CopyOnWriteDictionary<string, (string, ElementLocation)>(XmlElement.Attributes.Count, StringComparer.OrdinalIgnoreCase);
+                _parameters = new CopyOnWriteDictionary<(string, ElementLocation)>(XmlElement.Attributes.Count, StringComparer.OrdinalIgnoreCase);
 
                 foreach (XmlAttributeWithLocation attribute in XmlElement.Attributes)
                 {
diff --git a/src/Build/Construction/ProjectUsingTaskElement.cs b/src/Build/Construction/ProjectUsingTaskElement.cs
index b873d63a284..4d8b2358194 100644
--- a/src/Build/Construction/ProjectUsingTaskElement.cs
+++ b/src/Build/Construction/ProjectUsingTaskElement.cs
@@ -7,8 +7,6 @@
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
-using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
diff --git a/src/Build/Construction/ProjectUsingTaskParameterElement.cs b/src/Build/Construction/ProjectUsingTaskParameterElement.cs
index e9b31eeb1ac..bde3344cdfb 100644
--- a/src/Build/Construction/ProjectUsingTaskParameterElement.cs
+++ b/src/Build/Construction/ProjectUsingTaskParameterElement.cs
@@ -6,8 +6,6 @@
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
-using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 9bd2f1723a1..94e72cf546c 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -96,7 +96,8 @@ public sealed class ProjectInSolution
         private string _relativePath;         // Relative from .SLN file.  For example, "WindowsApplication1\WindowsApplication1.csproj"
         private readonly List<string> _dependencies;     // A list of strings representing the Guids of the dependent projects.
         private IReadOnlyList<string> _dependenciesAsReadonly;
-        private string _uniqueProjectName;    // For example, "MySlnFolder\MySubSlnFolder\WindowsApplication1"
+        private string _uniqueProjectName;    // For example, "MySlnFolder\MySubSlnFolder\Windows_Application1"
+        private string _originalProjectName;    // For example, "MySlnFolder\MySubSlnFolder\Windows.Application1"
 
         /// <summary>
         /// The project configuration in given solution configuration
@@ -345,7 +346,7 @@ internal bool CanBeMSBuildProjectFile(out string errorMessage)
         }
 
         /// <summary>
-        /// Find the unique name for this project, e.g. SolutionFolder\SubSolutionFolder\ProjectName
+        /// Find the unique name for this project, e.g. SolutionFolder\SubSolutionFolder\Project_Name
         /// </summary>
         internal string GetUniqueProjectName()
         {
@@ -369,7 +370,7 @@ internal string GetUniqueProjectName()
                         if (!ParentSolution.ProjectsByGuid.TryGetValue(ParentProjectGuid, out ProjectInSolution proj))
                         {
                             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(proj != null, "SubCategoryForSolutionParsingErrors",
-                                new BuildEventFileInfo(ParentSolution.FullPath), "SolutionParseNestedProjectError");
+                                new BuildEventFileInfo(ParentSolution.FullPath), "SolutionParseNestedProjectErrorWithNameAndGuid", ProjectName, ProjectGuid, ParentProjectGuid);
                         }
 
                         uniqueName = proj.GetUniqueProjectName() + "\\";
@@ -383,6 +384,55 @@ internal string GetUniqueProjectName()
             return _uniqueProjectName;
         }
 
+        /// <summary>
+        /// Gets the original project name with the parent project as it is declared in the solution file, e.g. SolutionFolder\SubSolutionFolder\Project.Name
+        /// </summary>
+        internal string GetOriginalProjectName()
+        {
+            if (_originalProjectName == null)
+            {
+                // EtpSubProject and Venus projects have names that are already unique.  No need to prepend the SLN folder.
+                if ((ProjectType == SolutionProjectType.WebProject) || (ProjectType == SolutionProjectType.EtpSubProject))
+                {
+                    _originalProjectName = ProjectName;
+                }
+                else
+                {
+                    // This is "normal" project, which in this context means anything non-Venus and non-EtpSubProject.
+
+                    // If this project has a parent SLN folder, first get the full project name for the SLN folder,
+                    // and tack on trailing backslash.
+                    string projectName = String.Empty;
+
+                    if (ParentProjectGuid != null)
+                    {
+                        if (!ParentSolution.ProjectsByGuid.TryGetValue(ParentProjectGuid, out ProjectInSolution parent))
+                        {
+                            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(parent != null, "SubCategoryForSolutionParsingErrors",
+                                new BuildEventFileInfo(ParentSolution.FullPath), "SolutionParseNestedProjectErrorWithNameAndGuid", ProjectName, ProjectGuid, ParentProjectGuid);
+                        }
+
+                        projectName = parent.GetOriginalProjectName() + "\\";
+                    }
+
+                    // Now tack on our own project name, and cache it in the ProjectInSolution object for future quick access.
+                    _originalProjectName = projectName + ProjectName;
+                }
+            }
+
+            return _originalProjectName;
+        }
+
+        internal string GetProjectGuidWithoutCurlyBrackets()
+        {
+            if (string.IsNullOrEmpty(ProjectGuid))
+            {
+                return null;
+            }
+
+            return ProjectGuid.Trim(new char[] { '{', '}' });
+        }
+
         /// <summary>
         /// Changes the unique name of the project.
         /// </summary>
diff --git a/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs b/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs
index 6d2e01071f5..d5e869cb5eb 100644
--- a/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs
+++ b/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs
@@ -1,8 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Shared;
-
 namespace Microsoft.Build.Construction
 {
     /// <summary>
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index e3f8cd8920f..2ea517136d9 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -81,13 +81,16 @@ public sealed class SolutionFile
         private const string fsProjectGuid = "{F2A71F9B-5D33-465A-A702-920D77279786}";
         private const string dbProjectGuid = "{C8D11400-126E-41CD-887F-60BD40844F9E}";
         private const string wdProjectGuid = "{2CFEAB61-6A3B-4EB8-B523-560B4BEEF521}";
+        private const string synProjectGuid = "{BBD0F5D1-1CC4-42FD-BA4C-A96779C64378}";
         private const string webProjectGuid = "{E24C65DC-7377-472B-9ABA-BC803B73C61A}";
         private const string solutionFolderGuid = "{2150E333-8FDC-42A3-9474-1A3956D46DE8}";
         private const string sharedProjectGuid = "{D954291E-2A0B-460D-934E-DC6B0785DB48}";
 
+        private const char CommentStartChar = '#';
         #endregion
         #region Member data
         private string _solutionFile;                 // Could be absolute or relative path to the .SLN file.
+        private string _solutionFilterFile;          // Could be absolute or relative path to the .SLNF file.
         private HashSet<string> _solutionFilter;     // The project files to include in loading the solution.
         private bool _parsingForConversionOnly;      // Are we parsing this solution to get project reference data during
                                                      // conversion, or in preparation for actually building the solution?
@@ -211,9 +214,12 @@ internal string FullPath
             }
         }
 
-        internal string SolutionFileDirectory { get;
+        internal string SolutionFileDirectory
+        {
+            get;
             // This setter is only used by the unit tests
-            set; }
+            set;
+        }
 
         /// <summary>
         /// For unit-testing only.
@@ -232,7 +238,7 @@ internal string FullPath
 
         internal bool ProjectShouldBuild(string projectFile)
         {
-            return _solutionFilter?.Contains(projectFile) != false;
+            return _solutionFilter?.Contains(FileUtilities.FixFilePath(projectFile)) != false;
         }
 
         /// <summary>
@@ -360,6 +366,7 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
 
         private void ParseSolutionFilter(string solutionFilterFile)
         {
+            _solutionFilterFile = solutionFilterFile;
             try
             {
                 _solutionFile = ParseSolutionFromSolutionFilter(solutionFilterFile, out JsonElement solution);
@@ -377,7 +384,7 @@ private void ParseSolutionFilter(string solutionFilterFile)
                 _solutionFilter = new HashSet<string>(NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
                 foreach (JsonElement project in solution.GetProperty("projects").EnumerateArray())
                 {
-                    _solutionFilter.Add(project.GetString());
+                    _solutionFilter.Add(FileUtilities.FixFilePath(project.GetString()));
                 }
             }
             catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
@@ -400,7 +407,7 @@ internal static string ParseSolutionFromSolutionFilter(string solutionFilterFile
             {
                 JsonDocument text = JsonDocument.Parse(File.ReadAllText(solutionFilterFile));
                 solution = text.RootElement.GetProperty("solution");
-                return Path.GetFullPath(Path.Combine(Path.GetDirectoryName(solutionFilterFile), solution.GetProperty("path").GetString()));
+                return FileUtilities.GetFullPath(solution.GetProperty("path").GetString(), Path.GetDirectoryName(solutionFilterFile));
             }
             catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
             {
@@ -437,8 +444,7 @@ private string ReadLine()
             string line = SolutionReader.ReadLine();
             _currentLineNumber++;
 
-            line = line?.Trim();
-            return line;
+            return line?.Trim();
         }
 
         /// <summary>
@@ -541,7 +547,7 @@ internal void ParseSolution()
                 HashSet<string> projectPaths = new HashSet<string>(_projectsInOrder.Count, NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
                 foreach (ProjectInSolution project in _projectsInOrder)
                 {
-                    projectPaths.Add(project.RelativePath);
+                    projectPaths.Add(FileUtilities.FixFilePath(project.RelativePath));
                 }
                 foreach (string project in _solutionFilter)
                 {
@@ -550,9 +556,9 @@ internal void ParseSolution()
                         ProjectFileErrorUtilities.ThrowInvalidProjectFile
                         (
                             "SubCategoryForSolutionParsingErrors",
-                            new BuildEventFileInfo(project),
+                            new BuildEventFileInfo(FileUtilities.GetFullPath(project, Path.GetDirectoryName(_solutionFile))),
                             "SolutionFilterFilterContainsProjectNotInSolution",
-                            _solutionFilter,
+                            _solutionFilterFile,
                             project,
                             _solutionFile
                         );
@@ -566,7 +572,8 @@ internal void ParseSolution()
             }
 
             // Cache the unique name of each project, and check that we don't have any duplicates.
-            var projectsByUniqueName = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+            var projectsByUniqueName = new Dictionary<string, ProjectInSolution>(StringComparer.OrdinalIgnoreCase);
+            var projectsByOriginalName = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             foreach (ProjectInSolution proj in _projectsInOrder)
             {
@@ -601,14 +608,47 @@ internal void ParseSolution()
                     }
                 }
 
-                // Update the hash table with this unique name
-                bool didntAlreadyExist = projectsByUniqueName.Add(uniqueName);
+                // Detect collision caused by unique name's normalization
+                if (projectsByUniqueName.ContainsKey(uniqueName))
+                {
+                    // Did normalization occur in the current project?
+                    if (uniqueName != proj.ProjectName)
+                    {
+                        // Generates a new unique name
+                        string tempUniqueName = $"{uniqueName}_{proj.GetProjectGuidWithoutCurlyBrackets()}";
+                        proj.UpdateUniqueProjectName(tempUniqueName);
+                        uniqueName = tempUniqueName;
+                    }
+                    // Did normalization occur in a previous project?
+                    else if (uniqueName != projectsByUniqueName[uniqueName].ProjectName)
+                    {
+                        var projTemp = projectsByUniqueName[uniqueName];
+
+                        // Generates a new unique name
+                        string tempUniqueName = $"{uniqueName}_{projTemp.GetProjectGuidWithoutCurlyBrackets()}";
+                        projTemp.UpdateUniqueProjectName(tempUniqueName);
+
+                        projectsByUniqueName.Remove(uniqueName);
+                        projectsByUniqueName.Add(tempUniqueName, projTemp);
+                    }
+                }
+
+                bool uniqueNameExists = projectsByUniqueName.ContainsKey(uniqueName);
+
+                // Add the unique name (if it does not exist) to the hash table 
+                if (!uniqueNameExists)
+                {
+                    projectsByUniqueName.Add(uniqueName, proj);
+                }
+
+                bool didntAlreadyExist = !uniqueNameExists && projectsByOriginalName.Add(proj.GetOriginalProjectName());
+
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
                     didntAlreadyExist,
                     "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(FullPath),
                     "SolutionParseDuplicateProject",
-                    uniqueName);
+                    uniqueNameExists ? uniqueName : proj.ProjectName);
             }
         } // ParseSolutionFile()
 
@@ -790,6 +830,19 @@ private void ParseProject(string firstLine)
                         line = ReadLine();
                     }
                 }
+                else if (line.StartsWith("Project(", StringComparison.Ordinal))
+                {
+                    // Another Project spotted instead of EndProject for the current one - solution file is malformed
+                    string warning = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out _, out _, "Shared.InvalidProjectFile",
+                        _solutionFile, proj.ProjectName);
+                    SolutionParserWarnings.Add(warning);
+
+                    // The line with new project is already read and we can't go one line back - we have no choice but to recursively parse spotted project
+                    ParseProject(line);
+
+                    // We're not waiting for the EndProject for malformed project, so we carry on
+                    break;
+                }
             }
 
             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(line != null, "SubCategoryForSolutionParsingErrors",
@@ -1230,7 +1283,8 @@ ProjectInSolution proj
                 (String.Equals(projectTypeGuid, cpsFsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
                 (String.Equals(projectTypeGuid, fsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
                 (String.Equals(projectTypeGuid, dbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
-                (String.Equals(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase)))
+                (String.Equals(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, synProjectGuid, StringComparison.OrdinalIgnoreCase)))
             {
                 proj.ProjectType = SolutionProjectType.KnownToBeMSBuildFormat;
             }
@@ -1290,7 +1344,8 @@ internal void ParseNestedProjects()
                     break;
                 }
 
-                if (String.IsNullOrWhiteSpace(str))
+                // Ignore empty line or comment
+                if (String.IsNullOrWhiteSpace(str) || str[0] == CommentStartChar)
                 {
                     continue;
                 }
@@ -1337,7 +1392,8 @@ internal void ParseSolutionConfigurations()
                     break;
                 }
 
-                if (String.IsNullOrWhiteSpace(str))
+                // Ignore empty line or comment
+                if (String.IsNullOrWhiteSpace(str) || str[0] == CommentStartChar)
                 {
                     continue;
                 }
@@ -1402,7 +1458,8 @@ internal Dictionary<string, string> ParseProjectConfigurations()
                     break;
                 }
 
-                if (String.IsNullOrWhiteSpace(str))
+                // Ignore empty line or comment
+                if (String.IsNullOrWhiteSpace(str) || str[0] == CommentStartChar)
                 {
                     continue;
                 }
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 92ae9194072..e935b5cc18d 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -1420,7 +1420,7 @@ private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject,
 
                     // Update our big condition string to include this configuration.
                     conditionDescribingValidConfigurations.Append(" or ");
-                    conditionDescribingValidConfigurations.Append(String.Format(CultureInfo.InvariantCulture, "('$(AspNetConfiguration)' == '{0}')", EscapingUtilities.Escape(configurationName)));
+                    conditionDescribingValidConfigurations.AppendFormat(CultureInfo.InvariantCulture, "('$(AspNetConfiguration)' == '{0}')", EscapingUtilities.Escape(configurationName));
                 }
 
                 StringBuilder referenceItemName = new StringBuilder(GenerateSafePropertyName(project, "References"));
diff --git a/src/Build/Definition/BuiltInMetadata.cs b/src/Build/Definition/BuiltInMetadata.cs
index 70175de8f36..6f9a3b9ee82 100644
--- a/src/Build/Definition/BuiltInMetadata.cs
+++ b/src/Build/Definition/BuiltInMetadata.cs
@@ -3,11 +3,8 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Internal;
-using Microsoft.Build.Collections;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -76,8 +73,7 @@ internal static string GetMetadataValueEscaped(string currentDirectory, string e
             // This is an assert, not a VerifyThrow, because the caller should already have done this check, and it's slow/hot.
             Debug.Assert(FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name));
 
-            string value = null;
-
+            string value;
             if (String.Equals(name, FileUtilities.ItemSpecModifiers.RecursiveDir, StringComparison.OrdinalIgnoreCase))
             {
                 value = GetRecursiveDirValue(evaluatedIncludeBeforeWildcardExpansionEscaped, evaluatedIncludeEscaped);
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 8d0d6ff412e..8d48735d241 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -32,7 +32,6 @@
 using EvaluationItemSpec = Microsoft.Build.Evaluation.ItemSpec<Microsoft.Build.Evaluation.ProjectProperty, Microsoft.Build.Evaluation.ProjectItem>;
 using EvaluationItemExpressionFragment = Microsoft.Build.Evaluation.ItemSpec<Microsoft.Build.Evaluation.ProjectProperty, Microsoft.Build.Evaluation.ProjectItem>.ItemExpressionFragment;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
-using System.Data.OleDb;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -60,7 +59,7 @@ public class Project : ILinkableObject
         private static readonly char[] s_invalidGlobChars = FileUtilities.InvalidFileNameChars.Where(c => c != '*' && c != '?' && c!= '/' && c != '\\' && c != ':').ToArray();
 
         /// <summary>
-        /// Context to log messages and events in
+        /// Context to log messages and events in.
         /// </summary>
         private static readonly BuildEventContext s_buildEventContext = new BuildEventContext(0 /* node ID */, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
 
@@ -157,7 +156,7 @@ public Project(ProjectCollection projectCollection, NewProjectFileOptions newPro
         /// Project will be added to the specified project collection when it is named.
         /// </summary>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         public Project(IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection)
             : this(ProjectRootElement.Create(projectCollection, DefaultNewProjectTemplateOptions), globalProperties, toolsVersion, projectCollection)
@@ -170,7 +169,7 @@ public Project(IDictionary<string, string> globalProperties, string toolsVersion
         /// Project will be added to the specified project collection when it is named.
         /// </summary>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         /// <param name="newProjectFileOptions">The <see cref="NewProjectFileOptions"/> to use for the new project.</param>
         public Project(IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, NewProjectFileOptions newProjectFileOptions)
@@ -185,7 +184,7 @@ public Project(IDictionary<string, string> globalProperties, string toolsVersion
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xml">ProjectRootElement to use</param>
+        /// <param name="xml">ProjectRootElement to use.</param>
         public Project(ProjectRootElement xml)
             : this(xml, null, null)
         {
@@ -198,9 +197,9 @@ public Project(ProjectRootElement xml)
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xml">ProjectRootElement to use</param>
+        /// <param name="xml">ProjectRootElement to use.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         public Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion)
             : this(xml, globalProperties, toolsVersion, ProjectCollection.GlobalProjectCollection)
         {
@@ -213,9 +212,9 @@ public Project(ProjectRootElement xml, IDictionary<string, string> globalPropert
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xml">ProjectRootElement to use</param>
+        /// <param name="xml">ProjectRootElement to use.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         public Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection)
             : this(xml, globalProperties, toolsVersion, projectCollection, ProjectLoadSettings.Default)
@@ -229,9 +228,9 @@ public Project(ProjectRootElement xml, IDictionary<string, string> globalPropert
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xml">ProjectRootElement to use</param>
+        /// <param name="xml">ProjectRootElement to use.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
         public Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
@@ -246,9 +245,9 @@ public Project(ProjectRootElement xml, IDictionary<string, string> globalPropert
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xml">ProjectRootElement to use</param>
+        /// <param name="xml">ProjectRootElement to use.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
@@ -277,7 +276,7 @@ private Project(ProjectRootElement xml, IDictionary<string, string> globalProper
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xmlReader">Xml reader to read project from</param>
+        /// <param name="xmlReader">Xml reader to read project from.</param>
         public Project(XmlReader xmlReader)
             : this(xmlReader, null, null)
         {
@@ -290,9 +289,9 @@ public Project(XmlReader xmlReader)
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xmlReader">Xml reader to read project from</param>
+        /// <param name="xmlReader">Xml reader to read project from.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion)
             : this(xmlReader, globalProperties, toolsVersion, ProjectCollection.GlobalProjectCollection)
         {
@@ -305,9 +304,9 @@ public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xmlReader">Xml reader to read project from</param>
+        /// <param name="xmlReader">Xml reader to read project from.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection)
             : this(xmlReader, globalProperties, toolsVersion, projectCollection, ProjectLoadSettings.Default)
@@ -321,9 +320,9 @@ public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xmlReader">Xml reader to read project from</param>
+        /// <param name="xmlReader">Xml reader to read project from.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
         public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
@@ -338,9 +337,9 @@ public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xmlReader">Xml reader to read project from</param>
+        /// <param name="xmlReader">Xml reader to read project from.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The load settings for this project.</param>
@@ -397,7 +396,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// May throw IO-related exceptions.
         /// </summary>
-        /// <param name="projectFile">The project file</param>
+        /// <param name="projectFile">The project file.</param>
         /// <param name="globalProperties">The global properties. May be null.</param>
         /// <param name="toolsVersion">The tools version. May be null.</param>
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
@@ -414,7 +413,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// May throw IO-related exceptions.
         /// </summary>
-        /// <param name="projectFile">The project file</param>
+        /// <param name="projectFile">The project file.</param>
         /// <param name="globalProperties">The global properties. May be null.</param>
         /// <param name="toolsVersion">The tools version. May be null.</param>
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
@@ -432,7 +431,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// May throw IO-related exceptions.
         /// </summary>
-        /// <param name="projectFile">The project file</param>
+        /// <param name="projectFile">The project file.</param>
         /// <param name="globalProperties">The global properties. May be null.</param>
         /// <param name="toolsVersion">The tools version. May be null.</param>
         /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
@@ -562,7 +561,7 @@ private enum BuildEnabledSetting
 
         /// <summary>
         /// The backing Xml project.
-        /// Can never be null
+        /// Can never be null.
         /// </summary>
         /// <remarks>
         /// There is no setter here as that doesn't make sense. If you have a new ProjectRootElement, evaluate it into a new Project.
@@ -595,7 +594,7 @@ private enum BuildEnabledSetting
         /// </summary>
         /// <comments>
         /// data.ItemTypes is a KeyCollection, so it doesn't need any
-        /// additional read-only protection
+        /// additional read-only protection.
         /// </comments>
         public ICollection<string> ItemTypes => implementation.ItemTypes;
 
@@ -625,12 +624,12 @@ private enum BuildEnabledSetting
 
         /// <summary>
         /// Read-only dictionary of item definitions in this project.
-        /// Keyed by item type
+        /// Keyed by item type.
         /// </summary>
         public IDictionary<string, ProjectItemDefinition> ItemDefinitions => implementation.ItemDefinitions;
 
         /// <summary>
-        /// Items in this project, ordered within groups of item types
+        /// Items in this project, ordered within groups of item types.
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Justification = "This is a reasonable choice. API review approved")]
         public ICollection<ProjectItem> Items => implementation.Items;
@@ -806,12 +805,12 @@ public bool IsBuildEnabled
         public int LastEvaluationId => implementation.LastEvaluationId;
 
         /// <summary>
-        /// List of names of the properties that, while global, are still treated as overridable
+        /// List of names of the properties that, while global, are still treated as overridable.
         /// </summary>
         internal ISet<string> GlobalPropertiesToTreatAsLocal => implementationInternal.GlobalPropertiesToTreatAsLocal;
 
         /// <summary>
-        /// The logging service used for evaluation errors
+        /// The logging service used for evaluation errors.
         /// </summary>
         internal ILoggingService LoggingService => ProjectCollection.LoggingService;
 
@@ -862,7 +861,7 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinition item)
         ///GlobResult(glob: "*.txt", exclude=[]),
         ///GlobResult(glob: "*.a", exclude=[]),
         ///GlobResult(glob: "*.cs", exclude=["bar"])
-        ///]
+        ///].
         /// </example>
         /// <remarks>
         /// <see cref="GlobResult.MsBuildGlob"/> is a <see cref="IMSBuildGlob"/> that combines all globs in the include element and ignores
@@ -884,11 +883,11 @@ public List<GlobResult> GetAllGlobs()
         }
 
         /// <summary>
-        /// See <see cref="GetAllGlobs()"/>
+        /// See <see cref="GetAllGlobs()"/>.
         /// </summary>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
-        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
         /// </param>
         public List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext)
         {
@@ -896,21 +895,21 @@ public List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext)
         }
 
         /// <summary>
-        /// Overload of <see cref="GetAllGlobs()"/>
+        /// Overload of <see cref="GetAllGlobs()"/>.
         /// </summary>
-        /// <param name="itemType">Confine search to item elements of this type</param>
+        /// <param name="itemType">Confine search to item elements of this type.</param>
         public List<GlobResult> GetAllGlobs(string itemType)
         {
             return implementation.GetAllGlobs(itemType, null);
         }
 
         /// <summary>
-        /// See <see cref="GetAllGlobs(string)"/>
+        /// See <see cref="GetAllGlobs(string)"/>.
         /// </summary>
-        /// <param name="itemType">type of the item</param>
+        /// <param name="itemType">Type of the item.</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
-        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
         /// </param>
         public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluationContext)
         {
@@ -921,11 +920,11 @@ public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluatio
         /// Finds all the item elements in the logical project with itemspecs that match the given string:
         /// - elements that would include (or exclude) the string
         /// - elements that would update the string (not yet implemented)
-        /// - elements that would remove the string (not yet implemented)
+        /// - elements that would remove the string (not yet implemented).
         /// </summary>
         ///
         /// <example>
-        /// The following snippet shows what <c>GetItemProvenance("a.cs")</c> returns for various item elements
+        /// The following snippet shows what <c>GetItemProvenance("a.cs")</c> returns for various item elements.
         /// <code>
         /// <A Include="a.cs;*.cs"/> // Occurrences:2; Operation: Include; Provenance: StringLiteral | Glob
         /// <B Include="*.cs" Exclude="a.cs"/> // Occurrences: 1; Operation: Exclude; Provenance: StringLiteral
@@ -956,7 +955,7 @@ public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluatio
         /// This API and its return types are prone to change.
         /// </remarks>
         ///
-        /// <param name="itemToMatch">The string to perform matching against</param>
+        /// <param name="itemToMatch">The string to perform matching against.</param>
         ///
         /// <returns>
         /// A list of <see cref="ProvenanceResult"/>, sorted in project evaluation order.
@@ -967,12 +966,12 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch)
         }
 
         /// <summary>
-        /// See <see cref="GetItemProvenance(string)"/>
+        /// See <see cref="GetItemProvenance(string)"/>.
         /// </summary>
-        /// <param name="itemToMatch">The string to perform matching against</param>
+        /// <param name="itemToMatch">The string to perform matching against.</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
-        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
         /// </param>
         public List<ProvenanceResult> GetItemProvenance(string itemToMatch, EvaluationContext evaluationContext)
         {
@@ -980,23 +979,23 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch, EvaluationCo
         }
 
         /// <summary>
-        /// Overload of <see cref="GetItemProvenance(string)"/>
+        /// Overload of <see cref="GetItemProvenance(string)"/>.
         /// </summary>
-        /// <param name="itemToMatch">The string to perform matching against</param>
-        /// <param name="itemType">The item type to constrain the search in</param>
+        /// <param name="itemToMatch">The string to perform matching against.</param>
+        /// <param name="itemType">The item type to constrain the search in.</param>
         public List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType)
         {
             return GetItemProvenance(itemToMatch, itemType, null);
         }
 
         /// <summary>
-        /// See <see cref="GetItemProvenance(string, string)"/>
+        /// See <see cref="GetItemProvenance(string, string)"/>.
         /// </summary>
-        /// <param name="itemToMatch">The string to perform matching against</param>
-        /// <param name="itemType">The type of the item to perform matching against</param>
+        /// <param name="itemToMatch">The string to perform matching against.</param>
+        /// <param name="itemType">The type of the item to perform matching against.</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
-        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
         /// </param>
         public List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType, EvaluationContext evaluationContext)
         {
@@ -1004,7 +1003,7 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemT
         }
 
         /// <summary>
-        /// Overload of <see cref="GetItemProvenance(string)"/>
+        /// Overload of <see cref="GetItemProvenance(string)"/>.
         /// </summary>
         /// <param name="item">
         /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
@@ -1017,7 +1016,7 @@ public List<ProvenanceResult> GetItemProvenance(ProjectItem item)
         }
 
         /// <summary>
-        /// See <see cref="GetItemProvenance(ProjectItem)"/>
+        /// See <see cref="GetItemProvenance(ProjectItem)"/>.
         /// </summary>
         /// <param name="item">
         /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
@@ -1026,7 +1025,7 @@ public List<ProvenanceResult> GetItemProvenance(ProjectItem item)
         /// </param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
-        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
         /// </param>
         public List<ProvenanceResult> GetItemProvenance(ProjectItem item, EvaluationContext evaluationContext)
         {
@@ -1065,7 +1064,7 @@ public static string GetMetadataValueEscaped(ProjectItemDefinition item, string
         }
 
         /// <summary>
-        /// Get the escaped value of the provided property
+        /// Get the escaped value of the provided property.
         /// </summary>
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IProperty is an internal interface; this is less confusing to outside customers. ")]
         public static string GetPropertyValueEscaped(ProjectProperty property)
@@ -1087,7 +1086,7 @@ public IEnumerable<ProjectElement> GetLogicalProject()
 
         /// <summary>
         /// Get any property in the project that has the specified name,
-        /// otherwise returns null
+        /// otherwise returns null.
         /// </summary>
         [DebuggerStepThrough]
         public ProjectProperty GetProperty(string name)
@@ -1318,7 +1317,7 @@ public string ExpandString(string unexpandedValue)
         /// This instance can be used to build independently.
         /// Before creating the instance, this will reevaluate the project if necessary, so it will not be dirty.
         /// </summary>
-        /// <returns>the created project instance</returns>
+        /// <returns>The created project instance.</returns>
         public ProjectInstance CreateProjectInstance()
         {
             return CreateProjectInstance(ProjectInstanceSettings.None, null);
@@ -1331,19 +1330,19 @@ public ProjectInstance CreateProjectInstance()
         /// The instance is immutable; none of the objects that form it can be modified. This makes it safe to
         /// access concurrently from multiple threads.
         /// </summary>
-        /// <param name="settings">The project instance creation settings</param>
-        /// <returns>the created project instance</returns>
+        /// <param name="settings">The project instance creation settings.</param>
+        /// <returns>the created project instance.</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings)
         {
             return CreateProjectInstance(settings, null);
         }
 
         /// <summary>
-        /// See <see cref="CreateProjectInstance(ProjectInstanceSettings)"/>
+        /// See <see cref="CreateProjectInstance(ProjectInstanceSettings)"/>.
         /// </summary>
-        /// <param name="settings">The project instance creation settings</param>
-        /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
-        /// <returns>the created project instance</returns>
+        /// <param name="settings">The project instance creation settings.</param>
+        /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
+        /// <returns>the created project instance.</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext)
         {
             return implementation.CreateProjectInstance(settings, evaluationContext);
@@ -1374,9 +1373,9 @@ public void ReevaluateIfNecessary()
         }
 
         /// <summary>
-        /// See <see cref="ReevaluateIfNecessary()"/>
+        /// See <see cref="ReevaluateIfNecessary()"/>.
         /// </summary>
-        /// <param name="evaluationContext">The <see cref="EvaluationContext"/> to use. See <see cref="EvaluationContext"/></param>
+        /// <param name="evaluationContext">The <see cref="EvaluationContext"/> to use. See <see cref="EvaluationContext"/>.</param>
         public void ReevaluateIfNecessary(EvaluationContext evaluationContext)
         {
             implementation.ReevaluateIfNecessary(evaluationContext);
@@ -1442,6 +1441,7 @@ public void SaveLogicalProject(TextWriter writer)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build()
         {
             return Build((string[])null);
@@ -1454,6 +1454,8 @@ public bool Build()
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="logger">Logger to use.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(ILogger logger)
         {
             var loggers = new List<ILogger>(1) { logger };
@@ -1467,6 +1469,8 @@ public bool Build(ILogger logger)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="loggers">List of loggers.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(IEnumerable<ILogger> loggers)
         {
             return Build((string[])null, loggers, null);
@@ -1479,6 +1483,9 @@ public bool Build(IEnumerable<ILogger> loggers)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="loggers">List of loggers.</param>
+        /// <param name="remoteLoggers">Remote loggers for multi proc logging.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
             return Build((string[])null, loggers, remoteLoggers);
@@ -1491,6 +1498,8 @@ public bool Build(IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerReco
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="target">Target to build.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string target)
         {
             return Build(target, null, null);
@@ -1503,6 +1512,9 @@ public bool Build(string target)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="target">Target to build.</param>
+        /// <param name="loggers">List of loggers.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string target, IEnumerable<ILogger> loggers)
         {
             return Build(target, loggers, null);
@@ -1515,6 +1527,10 @@ public bool Build(string target, IEnumerable<ILogger> loggers)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="target">Target to build.</param>
+        /// <param name="loggers">List of loggers.</param>
+        /// <param name="remoteLoggers">Remote loggers for multi proc logging.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string target, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
             // targets may be null, but not an entry within it
@@ -1530,6 +1546,8 @@ public bool Build(string target, IEnumerable<ILogger> loggers, IEnumerable<Forwa
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="targets">Targets to build.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string[] targets)
         {
             return Build(targets, null, null);
@@ -1543,6 +1561,9 @@ public bool Build(string[] targets)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="targets">Targets to build.</param>
+        /// <param name="loggers">List of loggers.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string[] targets, IEnumerable<ILogger> loggers)
         {
             return Build(targets, loggers, null);
@@ -1556,18 +1577,23 @@ public bool Build(string[] targets, IEnumerable<ILogger> loggers)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="targets">Targets to build.</param>
+        /// <param name="loggers">List of loggers.</param>
+        /// <param name="remoteLoggers">Remote loggers for multi proc logging.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
             return Build(targets, loggers, remoteLoggers, null);
         }
 
         /// <summary>
-        /// See <see cref="Build(string[], IEnumerable&lt;ILogger&gt;, IEnumerable&lt;ForwardingLoggerRecord&gt;)"/>
+        /// See <see cref="Build(string[], IEnumerable&lt;ILogger&gt;, IEnumerable&lt;ForwardingLoggerRecord&gt;)"/>.
         /// </summary>
-        /// <param name="targets"></param>
-        /// <param name="loggers"></param>
-        /// <param name="remoteLoggers"></param>
-        /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+        /// <param name="targets">Targets to build.</param>
+        /// <param name="loggers">List of loggers.</param>
+        /// <param name="remoteLoggers">Remote loggers for multi proc logging.</param>
+        /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext)
         {
             return implementation.Build(targets, loggers, remoteLoggers, evaluationContext);
@@ -1744,7 +1770,7 @@ internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml
         }
 
         /// <summary>
-        /// Internal project evaluation implementation
+        /// Internal project evaluation implementation.
         /// </summary>
         private class ProjectImpl : ProjectLink, IProjectLinkInternal
         {
@@ -1799,13 +1825,13 @@ private class ProjectImpl : ProjectLink, IProjectLinkInternal
             /// <summary>
             ///
             /// </summary>
-            /// <param name="owner">The owning project object</param>
-            /// <param name="xml">ProjectRootElement to use</param>
+            /// <param name="owner">The owning project object.</param>
+            /// <param name="xml">ProjectRootElement to use.</param>
             /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-            /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+            /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
             /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
             public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
@@ -1823,13 +1849,13 @@ public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, st
             /// Throws InvalidProjectFileException if the evaluation fails.
             /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
             /// </summary>
-            /// <param name="owner">The owning project object</param>
-            /// <param name="xmlReader">Xml reader to read project from</param>
+            /// <param name="owner">The owning project object.</param>
+            /// <param name="xmlReader">Xml reader to read project from.</param>
             /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-            /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+            /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
             /// <param name="loadSettings">The load settings for this project.</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
             public ProjectImpl(Project owner, XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(xmlReader, nameof(xmlReader));
@@ -1858,13 +1884,13 @@ public ProjectImpl(Project owner, XmlReader xmlReader, IDictionary<string, strin
             /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
             /// May throw IO-related exceptions.
             /// </summary>
-            /// <param name="owner">The owning project object</param>
-            /// <param name="projectFile">The project file</param>
+            /// <param name="owner">The owning project object.</param>
+            /// <param name="projectFile">The project file.</param>
             /// <param name="globalProperties">The global properties. May be null.</param>
             /// <param name="toolsVersion">The tools version. May be null.</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
             /// <param name="loadSettings">The load settings for this project.</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
             public ProjectImpl(Project owner, string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
@@ -1956,7 +1982,7 @@ public bool IsZombified
 
             /// <summary>
             /// The backing Xml project.
-            /// Can never be null
+            /// Can never be null.
             /// </summary>
             /// <remarks>
             /// There is no setter here as that doesn't make sense. If you have a new ProjectRootElement, evaluate it into a new Project.
@@ -2064,7 +2090,7 @@ public override IDictionary<string, string> GlobalProperties
             /// </summary>
             /// <comments>
             /// data.ItemTypes is a KeyCollection, so it doesn't need any
-            /// additional read-only protection
+            /// additional read-only protection.
             /// </comments>
             public override ICollection<string> ItemTypes => _data.ItemTypes;
 
@@ -2106,12 +2132,12 @@ public override IDictionary<string, List<string>> ConditionedProperties
 
             /// <summary>
             /// Read-only dictionary of item definitions in this project.
-            /// Keyed by item type
+            /// Keyed by item type.
             /// </summary>
             public override IDictionary<string, ProjectItemDefinition> ItemDefinitions => _data.ItemDefinitions;
 
             /// <summary>
-            /// Items in this project, ordered within groups of item types
+            /// Items in this project, ordered within groups of item types.
             /// </summary>
             [SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Justification = "This is a reasonable choice. API review approved")]
             public override ICollection<ProjectItem> Items => new ReadOnlyCollection<ProjectItem>(_data.Items);
@@ -2388,21 +2414,21 @@ public override bool IsBuildEnabled
             public override int LastEvaluationId => _data.EvaluationId;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable
+            /// List of names of the properties that, while global, are still treated as overridable.
             /// </summary>
             public ISet<string> GlobalPropertiesToTreatAsLocal => _data.GlobalPropertiesToTreatAsLocal;
 
             /// <summary>
-            /// The logging service used for evaluation errors
+            /// The logging service used for evaluation errors.
             /// </summary>
             internal ILoggingService LoggingService => ProjectCollection.LoggingService;
 
             /// <summary>
-            /// See <see cref="ProjectLink.GetAllGlobs(EvaluationContext)"/>
+            /// See <see cref="ProjectLink.GetAllGlobs(EvaluationContext)"/>.
             /// </summary>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
-            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
             /// </param>
             public override List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext)
             {
@@ -2410,12 +2436,12 @@ public override List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.GetAllGlobs(string, EvaluationContext)"/>
+            /// See <see cref="ProjectLink.GetAllGlobs(string, EvaluationContext)"/>.
             /// </summary>
             /// <param name="itemType">The type of items to return.</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
-            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
             /// </param>
             public override List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluationContext)
             {
@@ -2591,12 +2617,12 @@ private void CacheInformationFromRemoveItem(ProjectItemElement itemElement, Dict
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.GetItemProvenance(string, EvaluationContext)"/>
+            /// See <see cref="ProjectLink.GetItemProvenance(string, EvaluationContext)"/>.
             /// </summary>
-            /// <param name="itemToMatch">The string to perform matching against</param>
+            /// <param name="itemToMatch">The string to perform matching against.</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
-            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
             /// </param>
             public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, EvaluationContext evaluationContext)
             {
@@ -2604,13 +2630,13 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, Eva
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.GetItemProvenance(string, string, EvaluationContext)"/>
+            /// See <see cref="ProjectLink.GetItemProvenance(string, string, EvaluationContext)"/>.
             /// </summary>
-            /// <param name="itemToMatch">The string to perform matching against</param>
+            /// <param name="itemToMatch">The string to perform matching against.</param>
             /// <param name="itemType">The type of items to return.</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
-            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
             /// </param>
             public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType, EvaluationContext evaluationContext)
             {
@@ -2618,7 +2644,7 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, str
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.GetItemProvenance(ProjectItem, EvaluationContext)"/>
+            /// See <see cref="ProjectLink.GetItemProvenance(ProjectItem, EvaluationContext)"/>.
             /// </summary>
             /// /// <param name="item"> 
             /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
@@ -2627,7 +2653,7 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, str
             /// </param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
-            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
             /// </param>
             public override List<ProvenanceResult> GetItemProvenance(ProjectItem item, EvaluationContext evaluationContext)
             {
@@ -2700,47 +2726,25 @@ private List<ProvenanceResult> GetItemProvenance(string itemToMatch, IEnumerable
                     .ToList();
             }
 
+            // TODO: cache result?
             private ProvenanceResult ComputeProvenanceResult(string itemToMatch, ProjectItemElement itemElement)
             {
                 ProvenanceResult SingleItemSpecProvenance(string itemSpec, IElementLocation elementLocation, Operation operation)
                 {
-                    if (elementLocation == null)
+                    if (elementLocation != null && !string.IsNullOrEmpty(itemSpec))
                     {
-                        return null;
-                    }
-
-                    var matchOccurrences = ItemMatchesInItemSpecString(itemToMatch, itemSpec, elementLocation, itemElement.ContainingProject.DirectoryPath, _data.Expander, out Provenance provenance);
-                    if (matchOccurrences > 0)
-                    {
-                        return new ProvenanceResult(itemElement, operation, provenance, matchOccurrences);
+                        EvaluationItemSpec expandedItemSpec = new EvaluationItemSpec(itemSpec, _data.Expander, elementLocation, itemElement.ContainingProject.DirectoryPath, expandProperties: true);
+                        int matchOccurrences = ItemMatchesInItemSpec(itemToMatch, expandedItemSpec, out Provenance provenance);
+                        return matchOccurrences > 0 ? new ProvenanceResult(itemElement, operation, provenance, matchOccurrences) : null;
                     }
 
                     return null;
                 }
 
-                var includeResult = SingleItemSpecProvenance(itemElement.Include, itemElement.IncludeLocation, Operation.Include);
-                if (includeResult != null)
-                {
-                    var excludeResult = SingleItemSpecProvenance(itemElement.Exclude, itemElement.ExcludeLocation, Operation.Exclude);
-                    if (excludeResult != null)
-                    {
-                        return excludeResult;
-                    }
-
-                    if (includeResult != null)
-                    {
-                        return includeResult;
-                    }
-                }
-
-                var result = SingleItemSpecProvenance(itemElement.Update, itemElement.UpdateLocation, Operation.Update);
-                if (result != null)
-                {
-                    return result;
-                }
-
-                result = SingleItemSpecProvenance(itemElement.Remove, itemElement.RemoveLocation, Operation.Remove);
-                return result;
+                ProvenanceResult result = SingleItemSpecProvenance(itemElement.Include, itemElement.IncludeLocation, Operation.Include);
+                return result == null ?
+                    SingleItemSpecProvenance(itemElement.Update, itemElement.UpdateLocation, Operation.Update) ?? SingleItemSpecProvenance(itemElement.Remove, itemElement.RemoveLocation, Operation.Remove) :
+                    SingleItemSpecProvenance(itemElement.Exclude, itemElement.ExcludeLocation, Operation.Exclude) ?? result;
             }
 
             /// <summary>
@@ -2748,29 +2752,8 @@ ProvenanceResult SingleItemSpecProvenance(string itemSpec, IElementLocation elem
             ///     - we have no proper AST and interpreter for itemspecs that we can do analysis on
             ///     - GetItemProvenance needs to have correct counts for exclude strings (as correct as it can get while doing it after evaluation)
             ///
-            /// The temporary hack is to use the expander to expand the strings, and if any property or item references were encountered, return Provenance.Inconclusive
+            /// The temporary hack is to use the expander to expand the strings, and if any property or item references were encountered, return Provenance.Inconclusive.
             /// </summary>
-            private static int ItemMatchesInItemSpecString(string itemToMatch, string itemSpec, IElementLocation elementLocation, string projectDirectory, Expander<ProjectProperty, ProjectItem> expander, out Provenance provenance)
-            {
-                if (string.IsNullOrEmpty(itemSpec))
-                {
-                    provenance = Provenance.Undefined;
-                    return 0;
-                }
-
-                // expand the properties
-                var expandedItemSpec = new EvaluationItemSpec(itemSpec, expander, elementLocation, projectDirectory, expandProperties: true);
-                var numberOfMatches = ItemMatchesInItemSpec(itemToMatch, expandedItemSpec, out provenance);
-
-                // Result is inconclusive if properties are present
-                if (itemSpec.Contains("$("))
-                {
-                    provenance |= Provenance.Inconclusive;
-                }
-
-                return numberOfMatches;
-            }
-
             private static int ItemMatchesInItemSpec(string itemToMatch, EvaluationItemSpec itemSpec, out Provenance provenance)
             {
                 provenance = Provenance.Undefined;
@@ -2794,6 +2777,12 @@ private static int ItemMatchesInItemSpec(string itemToMatch, EvaluationItemSpec
                     {
                         ErrorUtilities.ThrowInternalErrorUnreachable();
                     }
+
+                    // Result is inconclusive if properties are present
+                    if (itemSpec.ItemSpecString.Contains("$("))
+                    {
+                        provenance |= Provenance.Inconclusive;
+                    }
                 }
 
                 return occurrences;
@@ -2834,7 +2823,7 @@ public override IEnumerable<ProjectElement> GetLogicalProject()
 
             /// <summary>
             /// Get any property in the project that has the specified name,
-            /// otherwise returns null
+            /// otherwise returns null.
             /// </summary>
             [DebuggerStepThrough]
             public override ProjectProperty GetProperty(string name)
@@ -3214,10 +3203,10 @@ public override string ExpandString(string unexpandedValue)
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.CreateProjectInstance(ProjectInstanceSettings, EvaluationContext)"/>
+            /// See <see cref="ProjectLink.CreateProjectInstance(ProjectInstanceSettings, EvaluationContext)"/>.
             /// </summary>
-            /// <param name="settings">Project instance creation settings</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+            /// <param name="settings">Project instance creation settings.</param>
+            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
             /// <returns></returns>
             public override ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext)
             {
@@ -3245,9 +3234,9 @@ public override void MarkDirty()
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.ReevaluateIfNecessary"/>
+            /// See <see cref="ProjectLink.ReevaluateIfNecessary"/>.
             /// </summary>
-            /// <param name="evaluationContext">The <see cref="EvaluationContext"/> to use. See <see cref="EvaluationContext"/></param>
+            /// <param name="evaluationContext">The <see cref="EvaluationContext"/> to use. See <see cref="EvaluationContext"/>.</param>
             public override void ReevaluateIfNecessary(EvaluationContext evaluationContext)
             {
                 ReevaluateIfNecessary(LoggingService, evaluationContext);
@@ -3269,12 +3258,12 @@ public override void SaveLogicalProject(TextWriter writer)
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.Build"/>
+            /// See <see cref="ProjectLink.Build"/>.
             /// </summary>
-            /// <param name="targets">targets to build</param>
-            /// <param name="loggers">List of loggers</param>
-            /// <param name="remoteLoggers">remote loggers for multi proc logging</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+            /// <param name="targets">Targets to build.</param>
+            /// <param name="loggers">List of loggers.</param>
+            /// <param name="remoteLoggers">Remote loggers for multi proc logging.</param>
+            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
             public override bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext)
             {
                 if (!IsBuildEnabled)
@@ -3941,7 +3930,7 @@ internal class Data : IItemProvider<ProjectItem>, IPropertyProvider<ProjectPrope
             private static WeakReference<RetrievableEntryHashSet<ProjectTargetInstance>> s_typicalTargetsCollection;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable
+            /// List of names of the properties that, while global, are still treated as overridable.
             /// </summary>
             private ISet<string> _globalPropertiesToTreatAsLocal;
 
@@ -3961,14 +3950,14 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Whether evaluation should collect items ignoring condition,
             /// as well as items respecting condition; and collect
-            /// conditioned properties, as well as regular properties
+            /// conditioned properties, as well as regular properties.
             /// </summary>
             public bool ShouldEvaluateForDesignTime => true;
 
             public bool CanEvaluateElementsWithFalseConditions { get; }
 
             /// <summary>
-            /// Collection of all evaluated item definitions, one per item-type
+            /// Collection of all evaluated item definitions, one per item-type.
             /// </summary>
             IEnumerable<ProjectItemDefinition> IEvaluatorData<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.ItemDefinitionsEnumerable => ItemDefinitions.Values;
 
@@ -3992,7 +3981,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => this.Project.ProjectCollection.EnvironmentProperties;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable
+            /// List of names of the properties that, while global, are still treated as overridable.
             /// </summary>
             public ISet<string> GlobalPropertiesToTreatAsLocal => _globalPropertiesToTreatAsLocal ?? (_globalPropertiesToTreatAsLocal =
                                                                       new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default));
@@ -4084,12 +4073,12 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             public int EvaluationId { get; set; } = BuildEventContext.InvalidEvaluationId;
 
             /// <summary>
-            /// The root directory for this project
+            /// The root directory for this project.
             /// </summary>
             public string Directory => Project.DirectoryPath;
 
             /// <summary>
-            /// Registry of usingtasks, for build
+            /// Registry of usingtasks, for build.
             /// </summary>
             public TaskRegistry TaskRegistry { get; set; }
 
@@ -4099,7 +4088,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// </summary>
             /// <comments>
             /// item.ItemTypes is a KeyCollection, so it doesn't need any
-            /// additional read-only protection
+            /// additional read-only protection.
             /// </comments>
             public ICollection<string> ItemTypes => Items.ItemTypes;
 
@@ -4143,17 +4132,17 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             internal bool HasUnsavedChanges { get; set; }
 
             /// <summary>
-            /// Collection of all evaluated item definitions, one per item-type
+            /// Collection of all evaluated item definitions, one per item-type.
             /// </summary>
             internal RetrievableEntryHashSet<ProjectItemDefinition> ItemDefinitions { get; private set; }
 
             /// <summary>
-            /// Project that owns this data
+            /// Project that owns this data.
             /// </summary>
             internal Project Project { get; }
 
             /// <summary>
-            /// Targets in the project, used to build
+            /// Targets in the project, used to build.
             /// </summary>
             internal RetrievableEntryHashSet<ProjectTargetInstance> Targets { get; set; }
 
@@ -4170,7 +4159,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             internal List<ResolvedImport> ImportClosureWithDuplicates { get; private set; }
 
             /// <summary>
-            /// The toolsversion that was originally specified on the project's root element
+            /// The toolsversion that was originally specified on the project's root element.
             /// </summary>
             internal string OriginalProjectToolsVersion { get; private set; }
 
@@ -4298,7 +4287,7 @@ public void AddItem(ProjectItem item)
             }
 
             /// <summary>
-            /// Adds a new item to the collection of all items ignoring condition
+            /// Adds a new item to the collection of all items ignoring condition.
             /// </summary>
             public void AddItemIgnoringCondition(ProjectItem item)
             {
@@ -4342,7 +4331,7 @@ public void AddToAllEvaluatedItemsList(ProjectItem item)
             }
 
             /// <summary>
-            /// Adds a new item definition
+            /// Adds a new item definition.
             /// </summary>
             public IItemDefinition<ProjectMetadata> AddItemDefinition(string itemType)
             {
@@ -4482,7 +4471,7 @@ public ICollection<ProjectItem> GetItems(string itemType)
             #region IPropertyProvider<ProjectProperty> Members
 
             /// <summary>
-            /// Returns the property with the specified name or null if it was not present
+            /// Returns the property with the specified name or null if it was not present.
             /// </summary>
             /// <param name="name">The property name.</param>
             /// <returns>The property.</returns>
@@ -4492,7 +4481,7 @@ public ProjectProperty GetProperty(string name)
             }
 
             /// <summary>
-            /// Returns the property with the specified name or null if it was not present
+            /// Returns the property with the specified name or null if it was not present.
             /// </summary>
             /// <returns>The property.</returns>
             public ProjectProperty GetProperty(string name, int startIndex, int endIndex)
@@ -4593,7 +4582,7 @@ public class GlobResult
         public IEnumerable<string> Removes { get; set; }
 
         /// <summary>
-        /// Constructor
+        /// Constructor.
         /// </summary>
         public GlobResult(ProjectItemElement itemElement, IEnumerable<string> includeGlobStrings, IMSBuildGlob globWithGaps, IEnumerable<string> excludeFragmentStrings, IEnumerable<string> removeFragmentStrings)
         {
@@ -4635,7 +4624,7 @@ public enum Provenance
     }
 
     /// <summary>
-    /// Enum that specifies how an item element references an item
+    /// Enum that specifies how an item element references an item.
     /// </summary>
     public enum Operation
     {
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 4b9c602b48b..5ef5fdfe6e8 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -26,8 +26,6 @@
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using LoggerMode = Microsoft.Build.BackEnd.Logging.LoggerMode;
 using ObjectModel = System.Collections.ObjectModel;
-using System.Data.OleDb;
-using System.Runtime.CompilerServices;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -875,11 +873,11 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
                     // This is only done once, when the project collection is created. Any subsequent
                     // environment changes will be ignored. Child nodes will be passed this set
                     // of properties in their build parameters.
-                    if (null == _environmentProperties)
+                    if (_environmentProperties == null)
                     {
                         using (_locker.EnterWriteLock())
                         {
-                            if (null == _environmentProperties)
+                            if (_environmentProperties == null)
                             {
                                 _environmentProperties = Utilities.GetEnvironmentProperties();
                             }
diff --git a/src/Build/Definition/ProjectCollectionChangedEventArgs.cs b/src/Build/Definition/ProjectCollectionChangedEventArgs.cs
index 86208a35694..ffee5a19f7c 100644
--- a/src/Build/Definition/ProjectCollectionChangedEventArgs.cs
+++ b/src/Build/Definition/ProjectCollectionChangedEventArgs.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 
 namespace Microsoft.Build.Evaluation
 {
diff --git a/src/Build/Definition/ProjectImportPathMatch.cs b/src/Build/Definition/ProjectImportPathMatch.cs
index 1d0d5c8495c..f31d63fb957 100644
--- a/src/Build/Definition/ProjectImportPathMatch.cs
+++ b/src/Build/Definition/ProjectImportPathMatch.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index 048d9dbddde..220cd07daba 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -4,12 +4,10 @@
 using System.Diagnostics;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Execution;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 using System.Collections.Generic;
 using System;
-using System.Collections;
 using System.Diagnostics.CodeAnalysis;
 using System.Linq;
 using Microsoft.Build.Shared.FileSystem;
@@ -321,7 +319,7 @@ internal ICollection<ProjectMetadata> MetadataCollection
                 RetrievableEntryHashSet<ProjectMetadata> allMetadata = new RetrievableEntryHashSet<ProjectMetadata>(MSBuildNameIgnoreCaseComparer.Default);
 
                 // Lowest priority: regular item definitions
-                ProjectItemDefinition itemDefinition = null;
+                ProjectItemDefinition itemDefinition;
                 if (_project.ItemDefinitions.TryGetValue(ItemType, out itemDefinition))
                 {
                     foreach (ProjectMetadata metadataFromDefinition in itemDefinition.Metadata)
@@ -344,7 +342,7 @@ internal ICollection<ProjectMetadata> MetadataCollection
                 }
 
                 // Finally any direct metadata win.
-                if (null != _directMetadata)
+                if (_directMetadata != null)
                 {
                     foreach (ProjectMetadata metadatum in _directMetadata)
                     {
@@ -452,7 +450,7 @@ public bool HasMetadata(string name)
             }
 
             ProjectMetadata metadatum = GetItemDefinitionMetadata(name);
-            if (null != metadatum)
+            if (metadatum != null)
             {
                 return true;
             }
@@ -488,13 +486,13 @@ string IItem.GetMetadataValueEscaped(string name)
             {
                 ProjectMetadata metadatum = GetItemDefinitionMetadata(name);
 
-                if (null != metadatum && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
+                if (metadatum != null && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
                 {
                     Expander<ProjectProperty, ProjectItem> expander = new Expander<ProjectProperty, ProjectItem>(null, null, new BuiltInMetadataTable(this), FileSystems.Default);
 
                     value = expander.ExpandIntoStringLeaveEscaped(metadatum.EvaluatedValueEscaped, ExpanderOptions.ExpandBuiltInMetadata, metadatum.Location);
                 }
-                else if (null != metadatum)
+                else if (metadatum != null)
                 {
                     return metadatum.EvaluatedValueEscaped;
                 }
@@ -633,7 +631,7 @@ public bool RemoveMetadata(string name)
             Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
             ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
-            ProjectMetadata metadatum = (_directMetadata == null) ? null : _directMetadata[name];
+            ProjectMetadata metadatum = _directMetadata?[name];
 
             if (metadatum == null)
             {
diff --git a/src/Build/Definition/ProjectItemDefinition.cs b/src/Build/Definition/ProjectItemDefinition.cs
index b05aa0bd826..35fc50b2d08 100644
--- a/src/Build/Definition/ProjectItemDefinition.cs
+++ b/src/Build/Definition/ProjectItemDefinition.cs
@@ -5,7 +5,6 @@
 using System.Diagnostics.CodeAnalysis;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Execution;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 using System.Collections.Generic;
@@ -119,7 +118,7 @@ string IKeyed.Key
         [DebuggerStepThrough]
         public ProjectMetadata GetMetadata(string name)
         {
-            return Link != null ? Link.GetMetadata(name) : (_metadata == null) ? null : _metadata[name];
+            return Link != null ? Link.GetMetadata(name) : _metadata?[name];
         }
 
         /// <summary>
diff --git a/src/Build/Definition/ProjectMetadata.cs b/src/Build/Definition/ProjectMetadata.cs
index 3b6b9285233..7bf9f740605 100644
--- a/src/Build/Definition/ProjectMetadata.cs
+++ b/src/Build/Definition/ProjectMetadata.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Diagnostics;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index 86006ce707a..518babfb2d6 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -5,8 +5,6 @@
 using System.Diagnostics;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Execution;
-using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
 
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
@@ -49,7 +47,7 @@ internal ProjectProperty(Project project, string evaluatedValueEscaped)
             _evaluatedValueEscaped = evaluatedValueEscaped;
         }
 
-        internal virtual string EvaluatedValueEscapedIntenral => _evaluatedValueEscaped;
+        internal virtual string EvaluatedValueEscapedInternal => _evaluatedValueEscaped;
 
         /// <summary>
         /// Name of the property.
@@ -79,7 +77,7 @@ public string EvaluatedValue
         {
             [DebuggerStepThrough]
             get
-            { return EscapingUtilities.UnescapeAll(EvaluatedValueEscapedIntenral); }
+            { return EscapingUtilities.UnescapeAll(EvaluatedValueEscapedInternal); }
         }
 
         /// <summary>
@@ -94,7 +92,7 @@ public string EvaluatedValue
         string IProperty.EvaluatedValueEscaped
         {
             [DebuggerStepThrough]
-            get => EvaluatedValueEscapedIntenral;
+            get => EvaluatedValueEscapedInternal;
         }
 
         /// <summary>
@@ -201,7 +199,7 @@ string IKeyed.Key
         string IValued.EscapedValue
         {
             [DebuggerStepThrough]
-            get => EvaluatedValueEscapedIntenral;
+            get => EvaluatedValueEscapedInternal;
         }
 
         #region IEquatable<ProjectProperty> Members
@@ -218,14 +216,14 @@ bool IEquatable<ProjectProperty>.Equals(ProjectProperty other)
                 return true;
             }
 
-            if (null == other)
+            if (other == null)
             {
                 return false;
             }
 
             return _project == other._project &&
                    Xml == other.Xml &&
-                   EvaluatedValueEscapedIntenral == other.EvaluatedValueEscapedIntenral &&
+                   EvaluatedValueEscapedInternal == other.EvaluatedValueEscapedInternal &&
                    Name == other.Name;
         }
 
diff --git a/src/Build/Definition/SubToolset.cs b/src/Build/Definition/SubToolset.cs
index 66578f1baa2..3f27dc905ac 100644
--- a/src/Build/Definition/SubToolset.cs
+++ b/src/Build/Definition/SubToolset.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index 411beb3a741..fc08972debb 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -253,7 +253,7 @@ public Toolset(string toolsVersion, string toolsPath, IDictionary<string, string
             : this(toolsVersion, toolsPath, null, projectCollection.EnvironmentProperties, projectCollection.GlobalPropertiesCollection, subToolsets, msbuildOverrideTasksPath, defaultOverrideToolsVersion: null)
         {
             _properties = new PropertyDictionary<ProjectPropertyInstance>();
-            if (null != buildProperties)
+            if (buildProperties != null)
             {
                 foreach (KeyValuePair<string, string> keyValuePair in buildProperties)
                 {
@@ -701,7 +701,7 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingServic
 
             try
             {
-                if (null != getFiles)
+                if (getFiles != null)
                 {
                     defaultTasksFiles = getFiles(searchPath, taskPattern);
                 }
@@ -764,21 +764,18 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingServic
         /// </summary>
         internal string GenerateSubToolsetVersion(PropertyDictionary<ProjectPropertyInstance> overrideGlobalProperties)
         {
-            ProjectPropertyInstance subToolsetProperty = null;
-            string visualStudioVersion = null;
             if (overrideGlobalProperties != null)
             {
-                subToolsetProperty = overrideGlobalProperties[Constants.SubToolsetVersionPropertyName];
+                ProjectPropertyInstance subToolsetProperty = overrideGlobalProperties[Constants.SubToolsetVersionPropertyName];
 
                 if (subToolsetProperty != null)
                 {
-                    visualStudioVersion = subToolsetProperty.EvaluatedValue;
-                    return visualStudioVersion;
+                    return subToolsetProperty.EvaluatedValue;
                 }
             }
 
-            visualStudioVersion = GenerateSubToolsetVersion(0 /* don't care about solution version */);
-            return visualStudioVersion;
+            /* don't care about solution version */
+            return GenerateSubToolsetVersion(0);
         }
 
         /// <summary>
@@ -851,14 +848,13 @@ internal TaskRegistry GetTaskRegistry(ILoggingService loggingServices, BuildEven
         /// </summary>
         internal string GenerateSubToolsetVersionUsingVisualStudioVersion(IDictionary<string, string> overrideGlobalProperties, int visualStudioVersionFromSolution)
         {
-            string visualStudioVersion = null;
+            string visualStudioVersion;
             if (overrideGlobalProperties != null && overrideGlobalProperties.TryGetValue(Constants.SubToolsetVersionPropertyName, out visualStudioVersion))
             {
                 return visualStudioVersion;
             }
 
-            visualStudioVersion = GenerateSubToolsetVersion(visualStudioVersionFromSolution);
-            return visualStudioVersion;
+            return GenerateSubToolsetVersion(visualStudioVersionFromSolution);
         }
 
         /// <summary>
@@ -1001,7 +997,7 @@ private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventCo
                         {
                             if (Path.IsPathRooted(_overrideTasksPath))
                             {
-                                if (null != _directoryExists)
+                                if (_directoryExists != null)
                                 {
                                     overrideDirectoryExists = _directoryExists(_overrideTasksPath);
                                 }
@@ -1067,7 +1063,7 @@ private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingSer
                     {
                         ProjectUsingTaskElement usingTask = elementXml as ProjectUsingTaskElement;
 
-                        if (null == usingTask)
+                        if (usingTask == null)
                         {
                             ProjectErrorUtilities.ThrowInvalidProject
                                 (
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 1977f876ec0..52128c04fa6 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Configuration;
-using System.IO;
 using System.Linq;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -119,7 +118,7 @@ private ToolsetConfigurationSection ConfigurationSection
         {
             get
             {
-                if (null == _configurationSection && !_configurationReadAttempted)
+                if (_configurationSection == null && !_configurationReadAttempted)
                 {
                     try
                     {
@@ -216,9 +215,7 @@ protected override Dictionary<string, ProjectImportPathMatch> GetProjectImportSe
                 return kindToPathsCache;
             }
 
-            kindToPathsCache = ComputeDistinctListOfSearchPaths(propertyCollection);
-
-            return kindToPathsCache;
+            return ComputeDistinctListOfSearchPaths(propertyCollection);
         }
 
         /// <summary>
diff --git a/src/Build/Definition/ToolsetLocalReader.cs b/src/Build/Definition/ToolsetLocalReader.cs
index f383bcb0825..9669ae466b9 100644
--- a/src/Build/Definition/ToolsetLocalReader.cs
+++ b/src/Build/Definition/ToolsetLocalReader.cs
@@ -5,11 +5,8 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
-using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Evaluation
 {
diff --git a/src/Build/Definition/ToolsetPropertyDefinition.cs b/src/Build/Definition/ToolsetPropertyDefinition.cs
index 356e311b827..b21273d5aa1 100644
--- a/src/Build/Definition/ToolsetPropertyDefinition.cs
+++ b/src/Build/Definition/ToolsetPropertyDefinition.cs
@@ -1,10 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
 using System.Diagnostics;
-using System.Text;
 
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
 using Microsoft.Build.Shared;
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 3c140fc14b9..3bcf77e90aa 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -4,7 +4,6 @@
 using System;
 using System.IO;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Linq;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Shared;
@@ -509,7 +508,7 @@ bool accumulateProperties
             try
             {
                 var importSearchPathsTable = GetProjectImportSearchPathsTable(toolsVersion.Name, NativeMethodsShared.GetOSNameForExtensionsPath());
-                toolset = new Toolset(toolsVersion.Name, toolsPath == null ? binPath : toolsPath, properties, _environmentProperties, globalProperties, subToolsets, MSBuildOverrideTasksPath, DefaultOverrideToolsVersion, importSearchPathsTable);
+                toolset = new Toolset(toolsVersion.Name, toolsPath ?? binPath, properties, _environmentProperties, globalProperties, subToolsets, MSBuildOverrideTasksPath, DefaultOverrideToolsVersion, importSearchPathsTable);
             }
             catch (ArgumentException e)
             {
diff --git a/src/Build/ElementLocation/ElementLocation.cs b/src/Build/ElementLocation/ElementLocation.cs
index 64c0845539c..3b5a286956a 100644
--- a/src/Build/ElementLocation/ElementLocation.cs
+++ b/src/Build/ElementLocation/ElementLocation.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Shared;
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using System;
@@ -209,7 +208,7 @@ internal static ElementLocation Create(string file, int line, int column)
         /// </summary>
         private static string GetLocationString(string file, int line, int column)
         {
-            string locationString = String.Empty;
+            string locationString;
             if (line != 0 && column != 0)
             {
                 locationString = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("FileLocation", file, line, column);
diff --git a/src/Build/ElementLocation/RegistryLocation.cs b/src/Build/ElementLocation/RegistryLocation.cs
index 3e37a72f01c..d6577196d97 100644
--- a/src/Build/ElementLocation/RegistryLocation.cs
+++ b/src/Build/ElementLocation/RegistryLocation.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Shared;
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using System;
 
diff --git a/src/Build/ElementLocation/XmlAttributeWithLocation.cs b/src/Build/ElementLocation/XmlAttributeWithLocation.cs
index 25c540f1a32..25820d1d1bb 100644
--- a/src/Build/ElementLocation/XmlAttributeWithLocation.cs
+++ b/src/Build/ElementLocation/XmlAttributeWithLocation.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Shared;
 using System;
 using System.Xml;
 using System.Diagnostics;
diff --git a/src/Build/ElementLocation/XmlElementWithLocation.cs b/src/Build/ElementLocation/XmlElementWithLocation.cs
index da25514a148..7da601d28b2 100644
--- a/src/Build/ElementLocation/XmlElementWithLocation.cs
+++ b/src/Build/ElementLocation/XmlElementWithLocation.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Shared;
 using System;
 using System.Xml;
 using System.Diagnostics;
@@ -151,7 +150,7 @@ internal ElementLocation GetAttributeLocation(string name)
         {
             XmlAttributeWithLocation attributeWithLocation = GetAttributeWithLocation(name);
 
-            return (attributeWithLocation != null) ? attributeWithLocation.Location : null;
+            return attributeWithLocation?.Location;
         }
     }
 }
diff --git a/src/Build/ElementLocation/XmlNameTableThreadSafe.cs b/src/Build/ElementLocation/XmlNameTableThreadSafe.cs
index d82b5595075..ac593ced2b8 100644
--- a/src/Build/ElementLocation/XmlNameTableThreadSafe.cs
+++ b/src/Build/ElementLocation/XmlNameTableThreadSafe.cs
@@ -1,11 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Shared;
 using System;
 using System.Xml;
-using System.Diagnostics;
-using System.Threading;
 
 namespace Microsoft.Build.Construction
 {
diff --git a/src/Build/Errors/InvalidProjectFileException.cs b/src/Build/Errors/InvalidProjectFileException.cs
index e051cb42772..ce0835ec396 100644
--- a/src/Build/Errors/InvalidProjectFileException.cs
+++ b/src/Build/Errors/InvalidProjectFileException.cs
@@ -2,15 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Xml;
 using System.Runtime.Serialization;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
 
 using Microsoft.Build.Shared;
-using Microsoft.Build.Evaluation;
 
 namespace Microsoft.Build.Exceptions
 {
@@ -196,7 +193,7 @@ Exception innerException
             {
                 string fullPath = FileUtilities.GetFullPathNoThrow(projectFile);
 
-                projectFile = (fullPath == null) ? projectFile : fullPath;
+                projectFile = fullPath ?? projectFile;
             }
 
             file = projectFile;
diff --git a/src/Build/Errors/InvalidToolsetDefinitionException.cs b/src/Build/Errors/InvalidToolsetDefinitionException.cs
index d638be88d6f..79354ecd57d 100644
--- a/src/Build/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Build/Errors/InvalidToolsetDefinitionException.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
 
 using Microsoft.Build.Shared;
 using System.Runtime.Serialization;
diff --git a/src/Build/Errors/RegistryException.cs b/src/Build/Errors/RegistryException.cs
index c792b526c6a..d1b86501d33 100644
--- a/src/Build/Errors/RegistryException.cs
+++ b/src/Build/Errors/RegistryException.cs
@@ -2,11 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
 using System.Runtime.Serialization;
 
-using Microsoft.Build.Shared;
-
 namespace Microsoft.Build.Exceptions
 {
     /// <summary>
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 87e5b423c79..8eb493e6398 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -13,7 +13,6 @@ namespace Microsoft.Build.Evaluation
     using BuildEventContext = Microsoft.Build.Framework.BuildEventContext;
     using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
     using ElementLocation = Microsoft.Build.Construction.ElementLocation;
-    using Microsoft.Build.Execution;
     using Microsoft.Build.Shared;
     using Microsoft.Build.Shared.FileSystem;
 
diff --git a/src/Build/Evaluation/Conditionals/CharacterUtilities.cs b/src/Build/Evaluation/Conditionals/CharacterUtilities.cs
index 71d2979c053..277036eac9d 100644
--- a/src/Build/Evaluation/Conditionals/CharacterUtilities.cs
+++ b/src/Build/Evaluation/Conditionals/CharacterUtilities.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Text;
-
 namespace Microsoft.Build.Evaluation
 {
     internal static class CharacterUtilities
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index 6854357124e..d4862fec251 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
 using System;
 
 using Microsoft.Build.Shared;
diff --git a/src/Build/Evaluation/Conditionals/GreaterThanExpressionNode.cs b/src/Build/Evaluation/Conditionals/GreaterThanExpressionNode.cs
index c901bdd8a05..6749b70b166 100644
--- a/src/Build/Evaluation/Conditionals/GreaterThanExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GreaterThanExpressionNode.cs
@@ -1,12 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
 using System;
-
-using Microsoft.Build.Shared;
 using System.Diagnostics;
 
 namespace Microsoft.Build.Evaluation
diff --git a/src/Build/Evaluation/Conditionals/IItem.cs b/src/Build/Evaluation/Conditionals/IItem.cs
index 06d09f20047..c59074f73f1 100644
--- a/src/Build/Evaluation/Conditionals/IItem.cs
+++ b/src/Build/Evaluation/Conditionals/IItem.cs
@@ -1,10 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 
 namespace Microsoft.Build.Evaluation
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index 0f4d3c0aa4a..6a457794da3 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -1,11 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System;
-
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Evaluation
diff --git a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
index ce5df805850..0bd30600cbf 100644
--- a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
 using System;
 
 using Microsoft.Build.Shared;
diff --git a/src/Build/Evaluation/Conditionals/OperandExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperandExpressionNode.cs
index f7b42422605..35ecbb065f4 100644
--- a/src/Build/Evaluation/Conditionals/OperandExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperandExpressionNode.cs
@@ -1,13 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System;
-
-using Microsoft.Build.Shared;
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/Parser.cs b/src/Build/Evaluation/Conditionals/Parser.cs
index 3255b2b6d8a..ac231b18964 100644
--- a/src/Build/Evaluation/Conditionals/Parser.cs
+++ b/src/Build/Evaluation/Conditionals/Parser.cs
@@ -174,7 +174,7 @@ private GenericExpressionNode ExprPrime(string expression, GenericExpressionNode
         private GenericExpressionNode BooleanTerm(string expression)
         {
             GenericExpressionNode node = RelationalExpr(expression);
-            if (null == node)
+            if (node == null)
             {
                 errorPosition = _lexer.GetErrorPosition();
                 ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
@@ -196,7 +196,7 @@ private GenericExpressionNode BooleanTermPrime(string expression, GenericExpress
             else if (Same(expression, Token.TokenType.And))
             {
                 GenericExpressionNode rhs = RelationalExpr(expression);
-                if (null == rhs)
+                if (rhs == null)
                 {
                     errorPosition = _lexer.GetErrorPosition();
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
@@ -218,7 +218,7 @@ private GenericExpressionNode RelationalExpr(string expression)
         {
             {
                 GenericExpressionNode lhs = Factor(expression);
-                if (null == lhs)
+                if (lhs == null)
                 {
                     errorPosition = _lexer.GetErrorPosition();
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
@@ -382,7 +382,7 @@ private bool Same(string expression, Token.TokenType token)
                 if (!_lexer.Advance())
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    if (null != _lexer.UnexpectedlyFound)
+                    if (_lexer.UnexpectedlyFound != null)
                     {
                         ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, _lexer.GetErrorResource(), expression, errorPosition, _lexer.UnexpectedlyFound);
                     }
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index 70b0ad7bbac..5d24ea0949b 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -6,6 +6,7 @@
 using System.Diagnostics;
 
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -26,7 +27,7 @@ internal sealed class Scanner
         private string _expression;
         private int _parsePoint;
         private Token _lookahead;
-        private bool _errorState;
+        internal bool _errorState;
         private int _errorPosition;
         // What we found instead of what we were looking for
         private string _unexpectedlyFound = null;
@@ -283,8 +284,17 @@ private string ParsePropertyOrItemMetadata()
                 return null;
             }
 
-            _parsePoint = ScanForPropertyExpressionEnd(_expression, _parsePoint++);
+            var result = ScanForPropertyExpressionEnd(_expression, _parsePoint++, out int indexResult);
+            if (!result)
+            {
+                _errorState = true;
+                _errorPosition = indexResult;
+                _errorResource = "IllFormedPropertySpaceInCondition";
+                _unexpectedlyFound = Convert.ToString(_expression[indexResult], CultureInfo.InvariantCulture);
+                return null;
+            }
 
+            _parsePoint = indexResult;
             // Maybe we need to generate an error for invalid characters in property/metadata name?
             // For now, just wait and let the property/metadata evaluation handle the error case.
             if (_parsePoint >= _expression.Length)
@@ -303,10 +313,17 @@ private string ParsePropertyOrItemMetadata()
         /// <summary>
         /// Scan for the end of the property expression
         /// </summary>
-        private static int ScanForPropertyExpressionEnd(string expression, int index)
+        /// <param name="expression">property expression to parse</param>
+        /// <param name="index">current index to start from</param>
+        /// <param name="indexResult">If successful, the index corresponds to the end of the property expression.
+        /// In case of scan failure, it is the error position index.</param>
+        /// <returns>result indicating whether or not the scan was successful.</returns>
+        private static bool ScanForPropertyExpressionEnd(string expression, int index, out int indexResult)
         {
             int nestLevel = 0;
-
+            bool whitespaceFound = false;
+            bool nonIdentifierCharacterFound = false;
+            indexResult = -1;
             unsafe
             {
                 fixed (char* pchar = expression)
@@ -322,13 +339,37 @@ private static int ScanForPropertyExpressionEnd(string expression, int index)
                         {
                             nestLevel--;
                         }
+                        else if (char.IsWhiteSpace(character))
+                        {
+                            whitespaceFound = true;
+                            indexResult = index;
+                        }
+                        else if (!XmlUtilities.IsValidSubsequentElementNameCharacter(character))
+                        {
+                            nonIdentifierCharacterFound = true;
+                        }
+
+                        if (character == '$' && index < expression.Length - 1 && pchar[index + 1] == '(')
+                        {
+                            if (!ScanForPropertyExpressionEnd(expression, index + 1, out index))
+                            {
+                                indexResult = index;
+                                return false;
+                            }
+                        }
 
                         // We have reached the end of the parenthesis nesting
                         // this should be the end of the property expression
                         // If it is not then the calling code will determine that
                         if (nestLevel == 0)
                         {
-                            return index;
+                            if (whitespaceFound && !nonIdentifierCharacterFound && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))
+                            {
+                                return false;
+                            }
+
+                            indexResult = index;
+                            return true;
                         }
                         else
                         {
@@ -337,7 +378,8 @@ private static int ScanForPropertyExpressionEnd(string expression, int index)
                     }
                 }
             }
-            return index;
+            indexResult = index;
+            return true;
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Context/EvaluationContext.cs b/src/Build/Evaluation/Context/EvaluationContext.cs
index 07a36f6d034..633dd5404da 100644
--- a/src/Build/Evaluation/Context/EvaluationContext.cs
+++ b/src/Build/Evaluation/Context/EvaluationContext.cs
@@ -6,6 +6,7 @@
 using System.Collections.Immutable;
 using System.Threading;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.FileSystem;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -17,13 +18,20 @@ namespace Microsoft.Build.Evaluation.Context
     ///     evaluations).
     ///     The caller should throw away the context when the environment changes (IO, environment variables, SDK resolution
     ///     inputs, etc).
-    ///     This class and it's closure needs to be thread safe since API users can do evaluations in parallel.
+    ///     This class and its closure needs to be thread safe since API users can do evaluations in parallel.
     /// </summary>
     public class EvaluationContext
     {
         public enum SharingPolicy
         {
+            /// <summary>
+            /// Instructs the <see cref="EvaluationContext"/> to reuse state between the different project evaluations that use it.
+            /// </summary>
             Shared,
+
+            /// <summary>
+            /// Instructs the <see cref="EvaluationContext"/> not to reuse state between the different project evaluations that use it.
+            /// </summary>
             Isolated
         }
 
@@ -40,15 +48,21 @@ public enum SharingPolicy
         /// <summary>
         /// Key to file entry list. Example usages: cache glob expansion and intermediary directory expansions during glob expansion.
         /// </summary>
-        internal ConcurrentDictionary<string, ImmutableArray<string>> FileEntryExpansionCache { get; }
+        private ConcurrentDictionary<string, ImmutableArray<string>> FileEntryExpansionCache { get; }
 
-        internal EvaluationContext(SharingPolicy policy)
+        private EvaluationContext(SharingPolicy policy, IFileSystem fileSystem)
         {
+            // Unsupported case: isolated context with non null file system.
+            // Isolated means caches aren't reused, but the given file system might cache.
+            ErrorUtilities.VerifyThrowArgument(
+                policy == SharingPolicy.Shared || fileSystem == null,
+                "IsolatedContextDoesNotSupportFileSystem");
+
             Policy = policy;
 
             SdkResolverService = new CachingSdkResolverService();
             FileEntryExpansionCache = new ConcurrentDictionary<string, ImmutableArray<string>>();
-            FileSystem = new CachingFileSystemWrapper(FileSystems.Default);
+            FileSystem = fileSystem ?? new CachingFileSystemWrapper(FileSystems.Default);
             EngineFileUtilities = new EngineFileUtilities(new FileMatcher(FileSystem, FileEntryExpansionCache));
         }
 
@@ -57,7 +71,28 @@ internal EvaluationContext(SharingPolicy policy)
         /// </summary>
         public static EvaluationContext Create(SharingPolicy policy)
         {
-            var context = new EvaluationContext(policy);
+            
+            // ReSharper disable once IntroduceOptionalParameters.Global
+            // do not remove this method to avoid breaking binary compatibility
+            return Create(policy, fileSystem: null);
+        }
+
+        /// <summary>
+        ///     Factory for <see cref="EvaluationContext" />
+        /// </summary>
+        /// <param name="policy"> The <see cref="SharingPolicy"/> to use.</param>
+        /// <param name="fileSystem">The <see cref="IFileSystem"/> to use.
+        ///     This parameter is compatible only with <see cref="SharingPolicy.Shared"/>.
+        ///     The method throws if a file system is used with <see cref="SharingPolicy.Isolated"/>.
+        ///     The reasoning is that <see cref="SharingPolicy.Isolated"/> means not reusing any caches between evaluations,
+        ///     and the passed in <paramref name="fileSystem"/> might cache state.
+        /// </param>
+        public static EvaluationContext Create(SharingPolicy policy, MSBuildFileSystemBase fileSystem)
+        {
+            var context = new EvaluationContext(
+                policy,
+                fileSystem == null ? null : new MSBuildFileSystemAdapter(fileSystem));
+
             TestOnlyHookOnCreate?.Invoke(context);
 
             return context;
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 1653a461e2e..e385eece4e5 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -397,7 +397,7 @@ private static ProjectTaskInstance ReadTaskElement(ProjectTaskElement taskElemen
                 }
                 else
                 {
-                    ProjectTaskOutputPropertyInstance outputItem = new ProjectTaskOutputPropertyInstance
+                    ProjectTaskOutputPropertyInstance outputProperty = new ProjectTaskOutputPropertyInstance
                         (
                         output.PropertyName,
                         output.TaskParameter,
@@ -408,7 +408,7 @@ private static ProjectTaskInstance ReadTaskElement(ProjectTaskElement taskElemen
                         output.ConditionLocation
                         );
 
-                    taskOutputs.Add(outputItem);
+                    taskOutputs.Add(outputProperty);
                 }
             }
 
@@ -456,28 +456,21 @@ private static ProjectItemGroupTaskInstance ReadItemGroupUnderTargetElement(Proj
 
             foreach (ProjectItemElement itemElement in itemGroupElement.Items)
             {
-                List<ProjectItemGroupTaskMetadataInstance> metadata = null;
+                List<ProjectItemGroupTaskMetadataInstance> metadata = itemElement.Metadata.Count > 0 ? new List<ProjectItemGroupTaskMetadataInstance>() : null;
 
                 foreach (ProjectMetadataElement metadataElement in itemElement.Metadata)
                 {
-                    if (metadata == null)
-                    {
-                        metadata = new List<ProjectItemGroupTaskMetadataInstance>();
-                    }
-
-                    ProjectItemGroupTaskMetadataInstance metadatum = new ProjectItemGroupTaskMetadataInstance
+                    metadata.Add(new ProjectItemGroupTaskMetadataInstance
                         (
                         metadataElement.Name,
                         metadataElement.Value,
                         metadataElement.Condition,
                         metadataElement.Location,
                         metadataElement.ConditionLocation
-                        );
-
-                    metadata.Add(metadatum);
+                        ));
                 }
 
-                ProjectItemGroupTaskItemInstance item = new ProjectItemGroupTaskItemInstance
+                items.Add(new ProjectItemGroupTaskItemInstance
                     (
                     itemElement.ItemType,
                     itemElement.Include,
@@ -500,9 +493,7 @@ private static ProjectItemGroupTaskInstance ReadItemGroupUnderTargetElement(Proj
                     itemElement.KeepDuplicatesLocation,
                     itemElement.ConditionLocation,
                     metadata
-                    );
-
-                items.Add(item);
+                    ));
             }
 
             ProjectItemGroupTaskInstance itemGroup = new ProjectItemGroupTaskInstance(itemGroupElement.Condition, itemGroupElement.Location, itemGroupElement.ConditionLocation, items);
@@ -523,47 +514,24 @@ private static ProjectTargetInstance ReadNewTargetElement(ProjectTargetElement t
             {
                 using (evaluationProfiler.TrackElement(targetChildElement))
                 {
-                    ProjectTaskElement task = targetChildElement as ProjectTaskElement;
-
-                    if (task != null)
-                    {
-                        ProjectTaskInstance taskInstance = ReadTaskElement(task);
-
-                        targetChildren.Add(taskInstance);
-                        continue;
-                    }
-
-                    ProjectPropertyGroupElement propertyGroup = targetChildElement as ProjectPropertyGroupElement;
-
-                    if (propertyGroup != null)
-                    {
-                        ProjectPropertyGroupTaskInstance propertyGroupInstance = ReadPropertyGroupUnderTargetElement(propertyGroup);
-
-                        targetChildren.Add(propertyGroupInstance);
-                        continue;
-                    }
-
-                    ProjectItemGroupElement itemGroup = targetChildElement as ProjectItemGroupElement;
-
-                    if (itemGroup != null)
-                    {
-                        ProjectItemGroupTaskInstance itemGroupInstance = ReadItemGroupUnderTargetElement(itemGroup);
-
-                        targetChildren.Add(itemGroupInstance);
-                        continue;
-                    }
-
-                    ProjectOnErrorElement onError = targetChildElement as ProjectOnErrorElement;
-
-                    if (onError != null)
+                    switch (targetChildElement)
                     {
-                        ProjectOnErrorInstance onErrorInstance = ReadOnErrorElement(onError);
-
-                        targetOnErrorChildren.Add(onErrorInstance);
-                        continue;
+                        case ProjectTaskElement task:
+                            targetChildren.Add(ReadTaskElement(task));
+                            break;
+                        case ProjectPropertyGroupElement propertyGroup:
+                            targetChildren.Add(ReadPropertyGroupUnderTargetElement(propertyGroup));
+                            break;
+                        case ProjectItemGroupElement itemGroup:
+                            targetChildren.Add(ReadItemGroupUnderTargetElement(itemGroup));
+                            break;
+                        case ProjectOnErrorElement onError:
+                            targetOnErrorChildren.Add(ReadOnErrorElement(onError));
+                            break;
+                        default:
+                            ErrorUtilities.ThrowInternalError("Unexpected child");
+                            break;
                     }
-
-                    ErrorUtilities.ThrowInternalError("Unexpected child");
                 }
             }
 
@@ -616,7 +584,7 @@ private void Evaluate()
 
                 _logProjectImportedEvents = Traits.Instance.EscapeHatches.LogProjectImports;
 
-                ICollection<P> globalProperties;
+                int globalPropertiesCount;
 
                 using (_evaluationProfiler.TrackPass(EvaluationPass.InitialProperties))
                 {
@@ -626,7 +594,7 @@ private void Evaluate()
                     AddBuiltInProperties();
                     AddEnvironmentProperties();
                     AddToolsetProperties();
-                    globalProperties = AddGlobalProperties();
+                    globalPropertiesCount = AddGlobalProperties();
 
                     if (_interactive)
                     {
@@ -652,7 +620,7 @@ private void Evaluate()
                 List<string> initialTargets = new List<string>(_initialTargetsList.Count);
                 foreach (var initialTarget in _initialTargetsList)
                 {
-                    initialTargets.Add(EscapingUtilities.UnescapeAll(initialTarget.Trim()));
+                    initialTargets.Add(EscapingUtilities.UnescapeAll(initialTarget, trim: true));
                 }
 
                 _data.InitialTargets = initialTargets;
@@ -789,7 +757,7 @@ private void Evaluate()
 
                             string line = new string('#', 100) + "\n";
 
-                            string output = String.Format(CultureInfo.CurrentUICulture, "###: MSBUILD: Evaluating or reevaluating project {0} with {1} global properties and {2} tools version, child count {3}, CurrentSolutionConfigurationContents hash {4} other properties:\n{5}", _projectRootElement.FullPath, globalProperties.Count, _data.Toolset.ToolsVersion, _projectRootElement.Count, hash, propertyDump);
+                            string output = String.Format(CultureInfo.CurrentUICulture, "###: MSBUILD: Evaluating or reevaluating project {0} with {1} global properties and {2} tools version, child count {3}, CurrentSolutionConfigurationContents hash {4} other properties:\n{5}", _projectRootElement.FullPath, globalPropertiesCount, _data.Toolset.ToolsVersion, _projectRootElement.Count, hash, propertyDump);
 
                             Trace.WriteLine(line + output + line);
                         }
@@ -847,92 +815,47 @@ private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)
 
                 foreach (ProjectElement element in currentProjectOrImport.Children)
                 {
-                    ProjectPropertyGroupElement propertyGroup = element as ProjectPropertyGroupElement;
-
-                    if (propertyGroup != null)
-                    {
-                        EvaluatePropertyGroupElement(propertyGroup);
-                        continue;
-                    }
-
-                    ProjectItemGroupElement itemGroup = element as ProjectItemGroupElement;
-
-                    if (itemGroup != null)
-                    {
-                        _itemGroupElements.Add(itemGroup);
-
-                        continue;
-                    }
-
-                    ProjectItemDefinitionGroupElement itemDefinitionGroup = element as ProjectItemDefinitionGroupElement;
-
-                    if (itemDefinitionGroup != null)
-                    {
-                        _itemDefinitionGroupElements.Add(itemDefinitionGroup);
-
-                        continue;
-                    }
-
-                    ProjectTargetElement target = element as ProjectTargetElement;
-
-                    if (target != null)
+                    switch (element)
                     {
-                        if (_projectSupportsReturnsAttribute.ContainsKey(currentProjectOrImport))
-                        {
-                            _projectSupportsReturnsAttribute[currentProjectOrImport] |= (target.Returns != null);
-                        }
-                        else
-                        {
-                            _projectSupportsReturnsAttribute[currentProjectOrImport] = (target.Returns != null);
-                        }
-
-                        _targetElements.Add(target);
-
-                        continue;
-                    }
-
-                    ProjectImportElement import = element as ProjectImportElement;
-                    if (import != null)
-                    {
-                        EvaluateImportElement(currentProjectOrImport.DirectoryPath, import);
-                        continue;
-                    }
-
-                    ProjectImportGroupElement importGroup = element as ProjectImportGroupElement;
-
-                    if (importGroup != null)
-                    {
-                        EvaluateImportGroupElement(currentProjectOrImport.DirectoryPath, importGroup);
-                        continue;
-                    }
-
-                    ProjectUsingTaskElement usingTask = element as ProjectUsingTaskElement;
-
-                    if (usingTask != null)
-                    {
-                        _usingTaskElements.Add(new Pair<string, ProjectUsingTaskElement>(currentProjectOrImport.DirectoryPath, usingTask));
-                        continue;
-                    }
-
-                    ProjectChooseElement choose = element as ProjectChooseElement;
-
-                    if (choose != null)
-                    {
-                        EvaluateChooseElement(choose);
-                        continue;
-                    }
-
-                    if (element is ProjectExtensionsElement)
-                    {
-                        continue;
-                    }
-
-                    if (element is ProjectSdkElement)
-                    {
-                        continue; // This case is handled by implicit imports.
+                        case ProjectPropertyGroupElement propertyGroup:
+                            EvaluatePropertyGroupElement(propertyGroup);
+                            break;
+                        case ProjectItemGroupElement itemGroup:
+                            _itemGroupElements.Add(itemGroup);
+                            break;
+                        case ProjectItemDefinitionGroupElement itemDefinitionGroup:
+                            _itemDefinitionGroupElements.Add(itemDefinitionGroup);
+                            break;
+                        case ProjectTargetElement target:
+                            if (_projectSupportsReturnsAttribute.ContainsKey(currentProjectOrImport))
+                            {
+                                _projectSupportsReturnsAttribute[currentProjectOrImport] |= (target.Returns != null);
+                            }
+                            else
+                            {
+                                _projectSupportsReturnsAttribute[currentProjectOrImport] = (target.Returns != null);
+                            }
+                            _targetElements.Add(target);
+                            break;
+                        case ProjectImportElement import:
+                            EvaluateImportElement(currentProjectOrImport.DirectoryPath, import);
+                            break;
+                        case ProjectImportGroupElement importGroup:
+                            EvaluateImportGroupElement(currentProjectOrImport.DirectoryPath, importGroup);
+                            break;
+                        case ProjectUsingTaskElement usingTask:
+                            _usingTaskElements.Add(new Pair<string, ProjectUsingTaskElement>(currentProjectOrImport.DirectoryPath, usingTask));
+                            break;
+                        case ProjectChooseElement choose:
+                            EvaluateChooseElement(choose);
+                            break;
+                        case ProjectExtensionsElement extension:
+                        case ProjectSdkElement sdk: // This case is handled by implicit imports.
+                            break;
+                        default:
+                            ErrorUtilities.ThrowInternalError("Unexpected child type");
+                            break;
                     }
-
-                    ErrorUtilities.ThrowInternalError("Unexpected child type");
                 }
 
                 // Evaluate the "bottom" implicit imports as if they were the last entry in the file.
@@ -964,7 +887,7 @@ private void UpdateDefaultTargets(ProjectRootElement currentProjectOrImport)
 
                     for (int i = 0; i < temp.Count; i++)
                     {
-                        string target = EscapingUtilities.UnescapeAll(temp[i].Trim());
+                        string target = EscapingUtilities.UnescapeAll(temp[i], trim: true);
                         if (target.Length > 0)
                         {
                             _data.DefaultTargets ??= new List<string>(temp.Count);
@@ -1053,15 +976,8 @@ private void EvaluateUsingTaskElement(string directoryOfImportingFile, ProjectUs
         /// </summary>
         private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList<ProjectTargetElement> activeTargetsByEvaluationOrder, Dictionary<string, LinkedListNode<ProjectTargetElement>> activeTargets)
         {
-            ProjectTargetInstance targetInstance = null;
-
             // If we already have read a target instance for this element, use that. 
-            targetInstance = targetElement.TargetInstance;
-
-            if (targetInstance == null)
-            {
-                targetInstance = ReadNewTargetElement(targetElement, _projectSupportsReturnsAttribute[(ProjectRootElement)targetElement.Parent], _evaluationProfiler);
-            }
+            ProjectTargetInstance targetInstance = targetElement.TargetInstance ?? ReadNewTargetElement(targetElement, _projectSupportsReturnsAttribute[(ProjectRootElement)targetElement.Parent], _evaluationProfiler);
 
             string targetName = targetElement.Name;
             ProjectTargetInstance otherTarget = _data.GetTarget(targetName);
@@ -1070,8 +986,7 @@ private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList<Pr
                 _evaluationLoggingContext.LogComment(MessageImportance.Low, "OverridingTarget", otherTarget.Name, otherTarget.Location.File, targetName, targetElement.Location.File);
             }
 
-            LinkedListNode<ProjectTargetElement> node;
-            if (activeTargets.TryGetValue(targetName, out node))
+            if (activeTargets.TryGetValue(targetName, out LinkedListNode<ProjectTargetElement> node))
             {
                 activeTargetsByEvaluationOrder.Remove(node);
             }
@@ -1094,7 +1009,7 @@ private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement,
 
                 if (activeTargets.ContainsKey(unescapedBeforeTarget))
                 {
-                    List<TargetSpecification> beforeTargetsForTarget = null;
+                    List<TargetSpecification> beforeTargetsForTarget;
                     if (!targetsWhichRunBeforeByTarget.TryGetValue(unescapedBeforeTarget, out beforeTargetsForTarget))
                     {
                         beforeTargetsForTarget = new List<TargetSpecification>();
@@ -1117,7 +1032,7 @@ private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement,
 
                 if (activeTargets.ContainsKey(unescapedAfterTarget))
                 {
-                    List<TargetSpecification> afterTargetsForTarget = null;
+                    List<TargetSpecification> afterTargetsForTarget;
                     if (!targetsWhichRunAfterByTarget.TryGetValue(unescapedAfterTarget, out afterTargetsForTarget))
                     {
                         afterTargetsForTarget = new List<TargetSpecification>();
@@ -1135,109 +1050,112 @@ private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement,
             }
         }
 
+        private void ValidateChangeWaveState()
+        {
+            if (ChangeWaves.ConversionState == ChangeWaveConversionState.NotConvertedYet)
+            {
+                ChangeWaves.ApplyChangeWave();
+            }
+
+            switch (ChangeWaves.ConversionState)
+            {
+                case ChangeWaveConversionState.InvalidFormat:
+                    _evaluationLoggingContext.LogWarning("", new BuildEventFileInfo(""), "ChangeWave_InvalidFormat", Traits.Instance.MSBuildDisableFeaturesFromVersion);
+                    break;
+                case ChangeWaveConversionState.OutOfRotation:
+                    _evaluationLoggingContext.LogWarning("", new BuildEventFileInfo(""), "ChangeWave_OutOfRotation", ChangeWaves.DisabledWave, Traits.Instance.MSBuildDisableFeaturesFromVersion);
+                    break;
+            }
+        }
+
         /// <summary>
         /// Set the built-in properties, most of which are read-only
         /// </summary>
-        private ICollection<P> AddBuiltInProperties()
+        private void AddBuiltInProperties()
         {
             string startupDirectory = BuildParameters.StartupDirectory;
 
-            List<P> builtInProperties = new List<P>(19);
+            SetBuiltInProperty(ReservedPropertyNames.toolsVersion, _data.Toolset.ToolsVersion);
+            SetBuiltInProperty(ReservedPropertyNames.toolsPath, _data.Toolset.ToolsPath);
+            SetBuiltInProperty(ReservedPropertyNames.binPath, _data.Toolset.ToolsPath);
+            SetBuiltInProperty(ReservedPropertyNames.startupDirectory, startupDirectory);
+            SetBuiltInProperty(ReservedPropertyNames.buildNodeCount, _maxNodeCount.ToString(CultureInfo.CurrentCulture));
+            SetBuiltInProperty(ReservedPropertyNames.programFiles32, FrameworkLocationHelper.programFiles32);
+            SetBuiltInProperty(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion);
+            SetBuiltInProperty(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild);
 
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.toolsVersion, _data.Toolset.ToolsVersion));
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.toolsPath, _data.Toolset.ToolsPath));
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.binPath, _data.Toolset.ToolsPath));
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.startupDirectory, startupDirectory));
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.buildNodeCount, _maxNodeCount.ToString(CultureInfo.CurrentCulture)));
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.programFiles32, FrameworkLocationHelper.programFiles32));
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion));
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild));
+            ValidateChangeWaveState();
+
+            SetBuiltInProperty(ReservedPropertyNames.msbuilddisablefeaturesfromversion, ChangeWaves.DisabledWave);
 
             // Fake OS env variables when not on Windows
             if (!NativeMethodsShared.IsWindows)
             {
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.osName, NativeMethodsShared.OSName));
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.frameworkToolsRoot, NativeMethodsShared.FrameworkBasePath));
+                SetBuiltInProperty(ReservedPropertyNames.osName, NativeMethodsShared.OSName);
+                SetBuiltInProperty(ReservedPropertyNames.frameworkToolsRoot, NativeMethodsShared.FrameworkBasePath);
             }
 
 #if RUNTIME_TYPE_NETCORE
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType, "Core"));
+            SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType, "Core");
 #elif MONO
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType,
-                                                        NativeMethodsShared.IsMono ? "Mono" : "Full"));
+            SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType,
+                                                        NativeMethodsShared.IsMono ? "Mono" : "Full");
 #else
-            builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType, "Full"));
+            SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType, "Full");
 #endif
 
             if (String.IsNullOrEmpty(_projectRootElement.FullPath))
             {
-                // If this is an un-saved project, this is as far as we can go
-                if (String.IsNullOrEmpty(_projectRootElement.DirectoryPath))
-                {
-                    builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectDirectory, startupDirectory));
-                }
-                else
-                {
+                SetBuiltInProperty(ReservedPropertyNames.projectDirectory, String.IsNullOrEmpty(_projectRootElement.DirectoryPath) ?
+                    // If this is an un-saved project, this is as far as we can go
+                    startupDirectory :
                     // Solution files based on the old OM end up here.  But they do have a location, which is where the solution was loaded from.
                     // We need to set this here otherwise we can't locate any projects the solution refers to.
-                    builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectDirectory, _projectRootElement.DirectoryPath));
-                }
+                    _projectRootElement.DirectoryPath);
             }
             else
             {
                 // Add the MSBuildProjectXXXXX properties, but not the MSBuildFileXXXX ones. Those
                 // vary according to the file they're evaluated in, so they have to be dealt with
                 // specially in the Expander.
-                string projectFile = EscapingUtilities.Escape(Path.GetFileName(_projectRootElement.FullPath));
                 string projectFileWithoutExtension = EscapingUtilities.Escape(Path.GetFileNameWithoutExtension(_projectRootElement.FullPath));
                 string projectExtension = EscapingUtilities.Escape(Path.GetExtension(_projectRootElement.FullPath));
-                string projectFullPath = EscapingUtilities.Escape(_projectRootElement.FullPath);
+                string projectFile = projectFileWithoutExtension + projectExtension;
                 string projectDirectory = EscapingUtilities.Escape(_projectRootElement.DirectoryPath);
+                string projectFullPath = Path.Combine(projectDirectory, projectFile);
 
                 int rootLength = Path.GetPathRoot(projectDirectory).Length;
-                string projectDirectoryNoRoot = projectDirectory.Substring(rootLength);
-                projectDirectoryNoRoot = FileUtilities.EnsureNoTrailingSlash(projectDirectoryNoRoot);
-                projectDirectoryNoRoot = EscapingUtilities.Escape(FileUtilities.EnsureNoLeadingSlash(projectDirectoryNoRoot));
+                string projectDirectoryNoRoot = FileUtilities.EnsureNoLeadingOrTrailingSlash(projectDirectory, rootLength);
 
                 // ReservedPropertyNames.projectDefaultTargets is already set
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectFile, projectFile));
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectName, projectFileWithoutExtension));
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectExtension, projectExtension));
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectFullPath, projectFullPath));
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectDirectory, projectDirectory));
-                builtInProperties.Add(SetBuiltInProperty(ReservedPropertyNames.projectDirectoryNoRoot, projectDirectoryNoRoot));
+                SetBuiltInProperty(ReservedPropertyNames.projectFile, projectFile);
+                SetBuiltInProperty(ReservedPropertyNames.projectName, projectFileWithoutExtension);
+                SetBuiltInProperty(ReservedPropertyNames.projectExtension, projectExtension);
+                SetBuiltInProperty(ReservedPropertyNames.projectFullPath, projectFullPath);
+                SetBuiltInProperty(ReservedPropertyNames.projectDirectory, projectDirectory);
+                SetBuiltInProperty(ReservedPropertyNames.projectDirectoryNoRoot, projectDirectoryNoRoot);
             }
-
-            return builtInProperties;
         }
 
         /// <summary>
         /// Pull in all the environment into our property bag
         /// </summary>
-        private ICollection<P> AddEnvironmentProperties()
+        private void AddEnvironmentProperties()
         {
-            List<P> environmentPropertiesList = new List<P>(_environmentProperties.Count);
-
             foreach (ProjectPropertyInstance environmentProperty in _environmentProperties)
             {
-                P property = _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, isGlobalProperty: false, mayBeReserved: false, isEnvironmentVariable: true);
-                environmentPropertiesList.Add(property);
+                _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, isGlobalProperty: false, mayBeReserved: false, isEnvironmentVariable: true);
             }
-
-            return environmentPropertiesList;
         }
 
         /// <summary>
         /// Put all the toolset's properties into our property bag
         /// </summary>
-        private ICollection<P> AddToolsetProperties()
+        private void AddToolsetProperties()
         {
-            List<P> toolsetProperties = new List<P>(_data.Toolset.Properties.Count);
-
             foreach (ProjectPropertyInstance toolsetProperty in _data.Toolset.Properties.Values)
             {
-                P property = _data.SetProperty(toolsetProperty.Name, ((IProperty)toolsetProperty).EvaluatedValueEscaped, false /* NOT global property */, false /* may NOT be a reserved name */);
-                toolsetProperties.Add(property);
+                _data.SetProperty(toolsetProperty.Name, ((IProperty)toolsetProperty).EvaluatedValueEscaped, false /* NOT global property */, false /* may NOT be a reserved name */);
             }
 
             if (_data.SubToolsetVersion == null)
@@ -1246,55 +1164,46 @@ private ICollection<P> AddToolsetProperties()
                 // is most likely not a subtoolset now, we need to add VisualStudioVersion if its not already a property.
                 if (!_data.Properties.Contains(Constants.VisualStudioVersionPropertyName))
                 {
-                    P subToolsetVersionProperty = _data.SetProperty(Constants.VisualStudioVersionPropertyName, MSBuildConstants.CurrentVisualStudioVersion, false /* NOT global property */, false /* may NOT be a reserved name */);
-                    toolsetProperties.Add(subToolsetVersionProperty);
+                    _data.SetProperty(Constants.VisualStudioVersionPropertyName, MSBuildConstants.CurrentVisualStudioVersion, false /* NOT global property */, false /* may NOT be a reserved name */);
                 }
             }
             else
             {
-                SubToolset subToolset = null;
-
                 // Make the subtoolset version itself available as a property -- but only if it's not already set. 
                 // Because some people may be depending on this value even if there isn't a matching sub-toolset,
                 // set the property even if there is no matching sub-toolset.  
                 if (!_data.Properties.Contains(Constants.SubToolsetVersionPropertyName))
                 {
-                    P subToolsetVersionProperty = _data.SetProperty(Constants.SubToolsetVersionPropertyName, _data.SubToolsetVersion, false /* NOT global property */, false /* may NOT be a reserved name */);
-                    toolsetProperties.Add(subToolsetVersionProperty);
+                     _data.SetProperty(Constants.SubToolsetVersionPropertyName, _data.SubToolsetVersion, false /* NOT global property */, false /* may NOT be a reserved name */);
                 }
 
-                if (_data.Toolset.SubToolsets.TryGetValue(_data.SubToolsetVersion, out subToolset))
+                if (_data.Toolset.SubToolsets.TryGetValue(_data.SubToolsetVersion, out SubToolset subToolset))
                 {
                     foreach (ProjectPropertyInstance subToolsetProperty in subToolset.Properties.Values)
                     {
-                        P property = _data.SetProperty(subToolsetProperty.Name, ((IProperty)subToolsetProperty).EvaluatedValueEscaped, false /* NOT global property */, false /* may NOT be a reserved name */);
-                        toolsetProperties.Add(property);
+                        _data.SetProperty(subToolsetProperty.Name, ((IProperty)subToolsetProperty).EvaluatedValueEscaped, false /* NOT global property */, false /* may NOT be a reserved name */);
                     }
                 }
             }
 
-            return toolsetProperties;
         }
 
         /// <summary>
         /// Put all the global properties into our property bag
         /// </summary>
-        private ICollection<P> AddGlobalProperties()
+        private int AddGlobalProperties()
         {
             if (_data.GlobalPropertiesDictionary == null)
             {
-                return Array.Empty<P>();
+                return 0;
             }
 
-            List<P> globalProperties = new List<P>(_data.GlobalPropertiesDictionary.Count);
-
             foreach (ProjectPropertyInstance globalProperty in _data.GlobalPropertiesDictionary)
             {
-                P property = _data.SetProperty(globalProperty.Name, ((IProperty)globalProperty).EvaluatedValueEscaped, true /* IS global property */, false /* may NOT be a reserved name */);
-                globalProperties.Add(property);
+                _data.SetProperty(globalProperty.Name, ((IProperty)globalProperty).EvaluatedValueEscaped, true /* IS global property */, false /* may NOT be a reserved name */);
             }
 
-            return globalProperties;
+            return _data.GlobalPropertiesDictionary.Count;
         }
 
         /// <summary>
@@ -1344,7 +1253,7 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
                 if (evaluatedValue.Length > 0 && _expander.WarnForUninitializedProperties)
                 {
                     // Is the property we are currently setting in the list of properties which have been used but not initialized
-                    IElementLocation elementWhichUsedProperty = null;
+                    IElementLocation elementWhichUsedProperty;
                     bool isPropertyInList = _expander.UsedUninitializedProperties.Properties.TryGetValue(propertyElement.Name, out elementWhichUsedProperty);
 
                     if (isPropertyInList)
@@ -1542,31 +1451,21 @@ private bool EvaluateWhenOrOtherwiseChildren(IEnumerable<ProjectElement> childre
             {
                 using (_evaluationProfiler.TrackElement(element))
                 {
-                    ProjectPropertyGroupElement propertyGroup = element as ProjectPropertyGroupElement;
-
-                    if (propertyGroup != null)
+                    switch (element)
                     {
-                        EvaluatePropertyGroupElement(propertyGroup);
-                        continue;
+                        case ProjectPropertyGroupElement propertyGroup:
+                            EvaluatePropertyGroupElement(propertyGroup);
+                            break;
+                        case ProjectItemGroupElement itemGroup:
+                            _itemGroupElements.Add(itemGroup);
+                            break;
+                        case ProjectChooseElement choose:
+                            EvaluateChooseElement(choose);
+                            break;
+                        default:
+                            ErrorUtilities.ThrowInternalError("Unexpected child type");
+                            break;
                     }
-
-                    ProjectItemGroupElement itemGroup = element as ProjectItemGroupElement;
-
-                    if (itemGroup != null)
-                    {
-                        _itemGroupElements.Add(itemGroup);
-                        continue;
-                    }
-
-                    ProjectChooseElement choose = element as ProjectChooseElement;
-
-                    if (choose != null)
-                    {
-                        EvaluateChooseElement(choose);
-                        continue;
-                    }
-
-                    ErrorUtilities.ThrowInternalError("Unexpected child type");
                 }
             }
 
@@ -1754,7 +1653,7 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                 if (_logProjectImportedEvents)
                 {
                     // Expand the expression for the Log.  Since we know the condition evaluated to false, leave unexpandable properties in the condition so as not to cause an error
-                    string expanded = _expander.ExpandIntoStringAndUnescape(importElement.Condition, ExpanderOptions.ExpandProperties | ExpanderOptions.LeavePropertiesUnexpandedOnError, importElement.ConditionLocation);
+                    string expanded = _expander.ExpandIntoStringAndUnescape(importElement.Condition, ExpanderOptions.ExpandProperties | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, importElement.ConditionLocation);
 
                     ProjectImportedEventArgs eventArgs = new ProjectImportedEventArgs(
                         importElement.Location.Line,
@@ -2554,7 +2453,7 @@ private static string StringifyList(IList<string> strings)
                     sb.Append(", ");
                 }
 
-                sb.Append($"\"{strings[i]}\"");
+                sb.Append('\"').Append(strings[i]).Append('\"');
             }
 
             if (strings.Count > 1)
@@ -2562,7 +2461,7 @@ private static string StringifyList(IList<string> strings)
                 sb.Append(" and ");
             }
 
-            sb.Append($"\"{strings[strings.Count - 1]}\"");
+            sb.Append('\"').Append(strings[strings.Count - 1]).Append('\"');
 
             return sb.ToString();
         }
@@ -2573,7 +2472,7 @@ private void SetAllProjectsProperty()
             {
                 P oldValue = _data.GetProperty(Constants.MSBuildAllProjectsPropertyName);
                 string streamImports = string.Join(";", _streamImports.ToArray());
-                P newValue = _data.SetProperty(
+                _data.SetProperty(
                     Constants.MSBuildAllProjectsPropertyName,
                     oldValue == null
                         ? $"{_lastModifiedProject.FullPath}{streamImports}"
diff --git a/src/Build/Evaluation/EvaluatorMetadataTable.cs b/src/Build/Evaluation/EvaluatorMetadataTable.cs
index 93647383577..caab55331b3 100644
--- a/src/Build/Evaluation/EvaluatorMetadataTable.cs
+++ b/src/Build/Evaluation/EvaluatorMetadataTable.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Collections;
 
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 30c990a8e5a..d933594e66b 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -5,15 +5,12 @@
 using System.Collections;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
 using System.Linq;
-using System.Linq.Expressions;
 using System.Reflection;
 using System.Runtime.CompilerServices;
-using System.Text;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
@@ -81,6 +78,11 @@ internal enum ExpanderOptions
         /// </remarks>
         LeavePropertiesUnexpandedOnError = 0x20,
 
+        /// <summary>
+        /// When an expansion occurs, truncate it to Expander.DefaultTruncationCharacterLimit or Expander.DefaultTruncationItemLimit.
+        /// </summary>
+        Truncate = 0x40,
+
         /// <summary>
         /// Expand only properties and then item lists
         /// </summary>
@@ -113,19 +115,29 @@ internal enum ExpanderOptions
     /// Requires the caller to have previously provided the necessary material for the expansion requested.
     /// For example, if the caller requests ExpanderOptions.ExpandItems, the Expander will throw if it was not given items.
     /// </remarks>
-    /// <typeparam name="P">Type of the properties used</typeparam>
+    /// <typeparam name="P">Type of the properties used.</typeparam>
     /// <typeparam name="I">Type of the items used.</typeparam>
     internal class Expander<P, I>
         where P : class, IProperty
         where I : class, IItem
     {
+        /// <summary>
+        /// A limit for truncating string expansions within an evaluated Condition. Properties, item metadata, or item groups will be truncated to N characters such as 'N...'.
+        /// Enabled by ExpanderOptions.Truncate.
+        /// </summary>
+        private const int CharacterLimitPerExpansion = 1024;
+        /// <summary>
+        /// A limit for truncating string expansions for item groups within an evaluated Condition. N items will be evaluated such as 'A;B;C;...'.
+        /// Enabled by ExpanderOptions.Truncate.
+        /// </summary>
+        private const int ItemLimitPerExpansion = 3;
         private static readonly char[] s_singleQuoteChar = { '\'' };
         private static readonly char[] s_backtickChar = { '`' };
         private static readonly char[] s_doubleQuoteChar = { '"' };
 
         /// <summary>
         /// Those characters which indicate that an expression may contain expandable
-        /// expressions
+        /// expressions.
         /// </summary>
         private static char[] s_expandableChars = { '$', '%', '@' };
 
@@ -136,22 +148,22 @@ internal class Expander<P, I>
         private static CompareInfo s_invariantCompareInfo = CultureInfo.InvariantCulture.CompareInfo;
 
         /// <summary>
-        /// Properties to draw on for expansion
+        /// Properties to draw on for expansion.
         /// </summary>
         private IPropertyProvider<P> _properties;
 
         /// <summary>
-        /// Items to draw on for expansion
+        /// Items to draw on for expansion.
         /// </summary>
         private IItemProvider<I> _items;
 
         /// <summary>
-        /// Metadata to draw on for expansion
+        /// Metadata to draw on for expansion.
         /// </summary>
         private IMetadataTable _metadata;
 
         /// <summary>
-        /// Set of properties which are null during expansion
+        /// Set of properties which are null during expansion.
         /// </summary>
         private UsedUninitializedProperties _usedUninitializedProperties;
 
@@ -220,7 +232,7 @@ internal UsedUninitializedProperties UsedUninitializedProperties
 
         /// <summary>
         /// Tests to see if the expression may contain expandable expressions, i.e.
-        /// contains $, % or @
+        /// contains $, % or @.
         /// </summary>
         internal static bool ExpressionMayContainExpandableExpressions(string expression)
         {
@@ -248,9 +260,7 @@ internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions o
         {
             string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation);
 
-            result = (result == null) ? null : EscapingUtilities.UnescapeAll(result);
-
-            return result;
+            return (result == null) ? null : EscapingUtilities.UnescapeAll(result);
         }
 
         /// <summary>
@@ -279,7 +289,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
 
         /// <summary>
         /// Used only for unit tests. Expands the property expression (including any metadata expressions) and returns
-        /// the result typed (i.e. not converted into a string if the result is a function return)
+        /// the result typed (i.e. not converted into a string if the result is a function return).
         /// </summary>
         internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
@@ -327,7 +337,7 @@ internal IList<TaskItem> ExpandIntoTaskItemsLeaveEscaped(string expression, Expa
         /// Use this form when the result is going to be processed further, for example by matching against the file system,
         /// so literals must be distinguished, and you promise to unescape after that.
         /// </summary>
-        /// <typeparam name="T">Type of items to return</typeparam>
+        /// <typeparam name="T">Type of items to return.</typeparam>
         internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory<I, T> itemFactory, ExpanderOptions options, IElementLocation elementLocation)
             where T : class, IItem
         {
@@ -400,7 +410,7 @@ internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory
         /// Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not 
         /// have an item type set on it, it will be given the item type of the item vector to use.
         /// </summary>
-        /// <typeparam name="T">Type of the items that should be returned</typeparam>
+        /// <typeparam name="T">Type of the items that should be returned.</typeparam>
         internal IList<T> ExpandSingleItemVectorExpressionIntoItems<T>(string expression, IItemFactory<I, T> itemFactory, ExpanderOptions options, bool includeNullItems, out bool isTransformExpression, IElementLocation elementLocation)
             where T : class, IItem
         {
@@ -443,7 +453,7 @@ internal bool ExpandExpressionCapture(
         }
 
         /// <summary>
-        /// Returns true if the supplied string contains a valid property name
+        /// Returns true if the supplied string contains a valid property name.
         /// </summary>
         private static bool IsValidPropertyName(string propertyName)
         {
@@ -463,6 +473,14 @@ private static bool IsValidPropertyName(string propertyName)
             return true;
         }
 
+        /// <summary>
+        /// Returns true if ExpanderOptions.Truncate is set and EscapeHatches.DoNotTruncateConditions is not set.
+        /// </summary>
+        private static bool IsTruncationEnabled(ExpanderOptions options)
+        {
+            return (options & ExpanderOptions.Truncate) != 0 && !Traits.Instance.EscapeHatches.DoNotTruncateConditions && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_8);
+        }
+
         /// <summary>
         /// Scan for the closing bracket that matches the one we've already skipped;
         /// essentially, pushes and pops on a stack of parentheses to do this.
@@ -471,8 +489,8 @@ private static bool IsValidPropertyName(string propertyName)
         /// </summary>
         private static int ScanForClosingParenthesis(string expression, int index)
         {
-            bool potentialPropertyFunction = false;
-            bool potentialRegistryFunction = false;
+            bool potentialPropertyFunction;
+            bool potentialRegistryFunction;
             return ScanForClosingParenthesis(expression, index, out potentialPropertyFunction, out potentialRegistryFunction);
         }
 
@@ -482,7 +500,7 @@ private static int ScanForClosingParenthesis(string expression, int index)
         /// Takes the expression and the index to start at.
         /// Returns the index of the matching parenthesis, or -1 if it was not found.
         /// Also returns flags to indicate if a propertyfunction or registry property is likely
-        /// to be found in the expression
+        /// to be found in the expression.
         /// </summary>
         private static int ScanForClosingParenthesis(string expression, int index, out bool potentialPropertyFunction, out bool potentialRegistryFunction)
         {
@@ -540,7 +558,7 @@ private static int ScanForClosingParenthesis(string expression, int index, out b
         }
 
         /// <summary>
-        /// Skip all characters until we find the matching quote character
+        /// Skip all characters until we find the matching quote character.
         /// </summary>
         private static int ScanForClosingQuote(char quoteChar, string expression, int index)
         {
@@ -566,7 +584,7 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in
 
         /// <summary>
         /// Add the argument in the StringBuilder to the arguments list, handling nulls
-        /// appropriately
+        /// appropriately.
         /// </summary>
         private static void AddArgument(List<string> arguments, ReuseableStringBuilder argumentBuilder)
         {
@@ -701,12 +719,12 @@ private static class MetadataExpander
         {
             /// <summary>
             /// Expands all embedded item metadata in the given string, using the bucketed items.
-            /// Metadata may be qualified, like %(Compile.WarningLevel), or unqualified, like %(Compile)
+            /// Metadata may be qualified, like %(Compile.WarningLevel), or unqualified, like %(Compile).
             /// </summary>
-            /// <param name="expression">The expression containing item metadata references</param>
-            /// <param name="metadata"></param>
-            /// <param name="options"></param>
-            /// <param name="elementLocation"></param>
+            /// <param name="expression">The expression containing item metadata references.</param>
+            /// <param name="metadata">The metadata to be expanded.</param>
+            /// <param name="options">Used to specify what to expand.</param>
+            /// <param name="elementLocation">The location information for error reporting purposes.</param>
             /// <returns>The string with item metadata expanded in-place, escaped.</returns>
             internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTable metadata, ExpanderOptions options, IElementLocation elementLocation)
             {
@@ -717,11 +735,6 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                         return expression;
                     }
 
-                    if (expression.Length == 0)
-                    {
-                        return expression;
-                    }
-
                     ErrorUtilities.VerifyThrow(metadata != null, "Cannot expand metadata without providing metadata");
 
                     // PERF NOTE: Regex matching is expensive, so if the string doesn't contain any item metadata references, just bail
@@ -827,7 +840,7 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
             private class MetadataMatchEvaluator
             {
                 /// <summary>
-                /// Source of the metadata
+                /// Source of the metadata.
                 /// </summary>
                 private IMetadataTable _metadata;
 
@@ -837,12 +850,12 @@ private class MetadataMatchEvaluator
                 private ExpanderOptions _options;
 
                 /// <summary>
-                /// Constructor taking a source of metadata
+                /// Constructor taking a source of metadata.
                 /// </summary>
                 internal MetadataMatchEvaluator(IMetadataTable metadata, ExpanderOptions options)
                 {
                     _metadata = metadata;
-                    _options = (options & ExpanderOptions.ExpandMetadata);
+                    _options = options & (ExpanderOptions.ExpandMetadata | ExpanderOptions.Truncate);
 
                     ErrorUtilities.VerifyThrow(options != ExpanderOptions.Invalid, "Must be expanding metadata of some kind");
                 }
@@ -874,6 +887,10 @@ internal string ExpandSingleMetadata(Match itemMetadataMatch)
                         )
                     {
                         metadataValue = _metadata.GetEscapedValue(itemType, metadataName);
+                        if (IsTruncationEnabled(_options) && metadataValue.Length > CharacterLimitPerExpansion)
+                        {
+                            metadataValue = metadataValue.Substring(0, CharacterLimitPerExpansion - 3) + "...";
+                        }
                     }
 
                     return metadataValue;
@@ -882,13 +899,13 @@ internal string ExpandSingleMetadata(Match itemMetadataMatch)
         }
 
         /// <summary>
-        /// Expands property expressions, like $(Configuration) and $(Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation)
+        /// Expands property expressions, like $(Configuration) and $(Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation).
         /// </summary>
         /// <remarks>
         /// This is a private nested class, exposed only through the Expander class.
         /// That allows it to hide its private methods even from Expander.
         /// </remarks>
-        /// <typeparam name="T">Type of the properties used to expand the expression</typeparam>
+        /// <typeparam name="T">Type of the properties used to expand the expression.</typeparam>
         private static class PropertyExpander<T>
             where T : class, IProperty
         {
@@ -996,8 +1013,6 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         results.Add(lastResult);
                     }
 
-                    bool tryExtractPropertyFunction = false;
-                    bool tryExtractRegistryFunction = false;
 
                     // Append the result with the portion of the expression up to
                     // (but not including) the "$(", and advance the sourceIndex pointer.
@@ -1011,8 +1026,8 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         results.Add(expression.Substring(sourceIndex, propertyStartIndex - sourceIndex));
                     }
 
-                    sourceIndex = propertyStartIndex;
-
+                    bool tryExtractPropertyFunction;
+                    bool tryExtractRegistryFunction;
                     // Following the "$(" we need to locate the matching ')'
                     // Scan for the matching closing bracket, skipping any nested ones
                     // This is a very complete, fast validation of parenthesis matching including for nested
@@ -1039,7 +1054,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         string propertyBody;
 
                         // A property value of null will indicate that we're calling a static function on a type
-                        object propertyValue = null;
+                        object propertyValue;
 
                         // Compat: $() should return String.Empty
                         if (propertyStartIndex + 2 == propertyEndIndex)
@@ -1090,6 +1105,15 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                             propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties);
                         }
 
+                        if (IsTruncationEnabled(options) && propertyValue != null)
+                        {
+                            var value = propertyValue.ToString();
+                            if (value.Length > CharacterLimitPerExpansion)
+                            {
+                                propertyValue = value.Substring(0, CharacterLimitPerExpansion - 3) + "...";
+                            }
+                        }
+
                         // Record our result, and advance
                         // our sourceIndex pointer to the character just after the closing
                         // parenthesis.
@@ -1152,7 +1176,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
             }
 
             /// <summary>
-            /// Expand the body of the property, including any functions that it may contain
+            /// Expand the body of the property, including any functions that it may contain.
             /// </summary>
             internal static object ExpandPropertyBody(
                 string propertyBody,
@@ -1272,7 +1296,7 @@ internal static object ExpandPropertyBody(
             /// <summary>
             /// Convert the object into an MSBuild friendly string
             /// Arrays are supported.
-            /// Will not return NULL
+            /// Will not return NULL.
             /// </summary>
             internal static string ConvertToString(object valueToConvert)
             {
@@ -1347,7 +1371,7 @@ internal static string ConvertToString(object valueToConvert)
             }
 
             /// <summary>
-            /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo)
+            /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
             private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)
             {
@@ -1355,7 +1379,7 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
             }
 
             /// <summary>
-            /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo)
+            /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
             private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)
             {
@@ -1455,10 +1479,7 @@ private static object ExpandMSBuildThisFileProperty(string propertyName, IElemen
                 {
                     string directory = Path.GetDirectoryName(elementLocation.File);
                     int rootLength = Path.GetPathRoot(directory).Length;
-                    string directoryNoRoot = directory.Substring(rootLength);
-                    directoryNoRoot = FileUtilities.EnsureTrailingSlash(directoryNoRoot);
-                    directoryNoRoot = FileUtilities.EnsureNoLeadingSlash(directoryNoRoot);
-                    value = directoryNoRoot;
+                    value = FileUtilities.EnsureTrailingNoLeadingSlash(directory, rootLength);
                 }
 
                 return value;
@@ -1527,7 +1548,7 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
 
                         object valueFromRegistry = Registry.GetValue(registryKeyName, valueName, null /* default if key or value name is not found */);
 
-                        if (null != valueFromRegistry)
+                        if (valueFromRegistry != null)
                         {
                             // Convert the result to a string that is reasonable for MSBuild
                             result = ConvertToString(valueFromRegistry);
@@ -1597,7 +1618,7 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
         /// 
         ///     "my list: @(files -> 'temp\%(Filename).xml', ' ')   expands to string      "my list: temp\a.xml temp\b.xml"
         /// 
-        ///     "my list: @(files->'')                              expands to string      "my list: ;"
+        ///     "my list: @(files->'')                              expands to string      "my list: ;".
         /// </summary>
         /// <remarks>
         /// This is a private nested class, exposed only through the Expander class.
@@ -1606,9 +1627,9 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
         private static class ItemExpander
         {
             /// <summary>
-            /// Execute the list of transform functions
+            /// Execute the list of transform functions.
             /// </summary>
-            /// <typeparam name="S">class, IItem</typeparam>
+            /// <typeparam name="S">class, IItem.</typeparam>
             internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expander, bool includeNullEntries, Stack<TransformFunction<S>> transformFunctionStack, IEnumerable<Pair<string, S>> itemsOfType)
                 where S : class, IItem
             {
@@ -1655,8 +1676,8 @@ internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expande
             /// Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not 
             /// have an item type set on it, it will be given the item type of the item vector to use.
             /// </summary>
-            /// <typeparam name="S">Type of the items provided by the item source used for expansion</typeparam>
-            /// <typeparam name="T">Type of the items that should be returned</typeparam>
+            /// <typeparam name="S">Type of the items provided by the item source used for expansion.</typeparam>
+            /// <typeparam name="T">Type of the items that should be returned.</typeparam>
             internal static IList<T> ExpandSingleItemVectorExpressionIntoItems<S, T>(
                     Expander<P, I> expander, string expression, IItemProvider<S> items, IItemFactory<S, T> itemFactory, ExpanderOptions options,
                     bool includeNullEntries, out bool isTransformExpression, IElementLocation elementLocation)
@@ -1683,8 +1704,7 @@ internal static ExpressionShredder.ItemExpressionCapture ExpandSingleItemVectorE
                     return null;
                 }
 
-                List<ExpressionShredder.ItemExpressionCapture> matches = null;
-
+                List<ExpressionShredder.ItemExpressionCapture> matches;
                 if (s_invariantCompareInfo.IndexOf(expression, '@') == -1)
                 {
                     return null;
@@ -1718,8 +1738,6 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
                 where T : class, IItem
             {
                 ErrorUtilities.VerifyThrow(items != null, "Cannot expand items without providing items");
-
-                IList<T> result = null;
                 isTransformExpression = false;
                 bool brokeEarlyNonEmpty;
 
@@ -1732,6 +1750,8 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
                     itemFactory.ItemType = expressionCapture.ItemType;
                 }
 
+
+                IList<T> result;
                 if (expressionCapture.Separator != null)
                 {
                     // Reference contains a separator, for example @(Compile, ';').
@@ -1812,15 +1832,15 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
             /// Item1 represents the item string, escaped
             /// Item2 represents the original item.
             /// 
-            /// Item1 differs from Item2's string when it is coming from a transform
+            /// Item1 differs from Item2's string when it is coming from a transform.
             /// 
             /// </param>
-            /// <param name="expander">The expander whose state will be used to expand any transforms</param>
-            /// <param name="expressionCapture">The <see cref="ExpandSingleItemVectorExpressionIntoExpressionCapture"/> representing the structure of an item expression</param>
-            /// <param name="evaluatedItems"><see cref="IItemProvider{T}"/> to provide the inital items (which may get subsequently transformed, if <paramref name="expressionCapture"/> is a transform expression)></param>
-            /// <param name="elementLocation">Location of the xml element containing the <paramref name="expressionCapture"/></param>
-            /// <param name="options">expander options</param>
-            /// <param name="includeNullEntries">Wether to include items that evaluated to empty / null</param>
+            /// <param name="expander">The expander whose state will be used to expand any transforms.</param>
+            /// <param name="expressionCapture">The <see cref="ExpandSingleItemVectorExpressionIntoExpressionCapture"/> representing the structure of an item expression.</param>
+            /// <param name="evaluatedItems"><see cref="IItemProvider{T}"/> to provide the inital items (which may get subsequently transformed, if <paramref name="expressionCapture"/> is a transform expression)>.</param>
+            /// <param name="elementLocation">Location of the xml element containing the <paramref name="expressionCapture"/>.</param>
+            /// <param name="options">expander options.</param>
+            /// <param name="includeNullEntries">Wether to include items that evaluated to empty / null.</param>
             internal static bool ExpandExpressionCapture<S>(
                 Expander<P, I> expander,
                 ExpressionShredder.ItemExpressionCapture expressionCapture,
@@ -1903,11 +1923,11 @@ out List<Pair<string, S>> itemsFromCapture
             /// If the expression is empty, returns empty string.
             /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
             /// </summary>
-            /// <typeparam name="T">Type of the items provided</typeparam>
+            /// <typeparam name="T">Type of the items provided.</typeparam>
             internal static string ExpandItemVectorsIntoString<T>(Expander<P, I> expander, string expression, IItemProvider<T> items, ExpanderOptions options, IElementLocation elementLocation)
                 where T : class, IItem
             {
-                if (((options & ExpanderOptions.ExpandItems) == 0) || (expression.Length == 0))
+                if ((options & ExpanderOptions.ExpandItems) == 0 || expression.Length == 0)
                 {
                     return expression;
                 }
@@ -1956,9 +1976,9 @@ internal static string ExpandItemVectorsIntoString<T>(Expander<P, I> expander, s
             }
 
             /// <summary>
-            /// Prepare the stack of transforms that will be executed on a given set of items
+            /// Prepare the stack of transforms that will be executed on a given set of items.
             /// </summary>
-            /// <typeparam name="S">class, IItem</typeparam>
+            /// <typeparam name="S">class, IItem.</typeparam>
             private static Stack<TransformFunction<S>> PrepareTransformStackFromMatch<S>(IElementLocation elementLocation, ExpressionShredder.ItemExpressionCapture match)
                 where S : class, IItem
             {
@@ -2002,7 +2022,7 @@ private static Stack<TransformFunction<S>> PrepareTransformStackFromMatch<S>(IEl
             /// Expand the match provided into a string, and append that to the provided string builder.
             /// Returns true if ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and so it broke out early.
             /// </summary>
-            /// <typeparam name="S">Type of source items</typeparam>
+            /// <typeparam name="S">Type of source items.</typeparam>
             private static bool ExpandExpressionCaptureIntoStringBuilder<S>(
                 Expander<P, I> expander,
                 ExpressionShredder.ItemExpressionCapture capture,
@@ -2022,9 +2042,32 @@ ExpanderOptions options
                     return true;
                 }
 
+                int startLength = builder.Length;
+                bool truncate = IsTruncationEnabled(options);
+
                 // if the capture.Separator is not null, then ExpandExpressionCapture would have joined the items using that separator itself
-                foreach (var item in itemsFromCapture)
+                for (int i = 0; i < itemsFromCapture.Count; i++)
                 {
+                    var item = itemsFromCapture[i];
+                    if (truncate)
+                    {
+                        if (i >= ItemLimitPerExpansion)
+                        {
+                            builder.Append("...");
+                            return false;
+                        }
+                        int currentLength = builder.Length - startLength;
+                        if (!string.IsNullOrEmpty(item.Key) && currentLength + item.Key.Length > CharacterLimitPerExpansion)
+                        {
+                            int truncateIndex = CharacterLimitPerExpansion - currentLength - 3;
+                            if (truncateIndex > 0)
+                            {
+                                builder.Append(item.Key, 0, truncateIndex);
+                            }
+                            builder.Append("...");
+                            return false;
+                        }
+                    }
                     builder.Append(item.Key);
                     builder.Append(';');
                 }
@@ -2037,26 +2080,26 @@ ExpanderOptions options
             }
 
             /// <summary>
-            /// The set of functions that called during an item transformation, e.g. @(CLCompile->ContainsMetadata('MetaName', 'metaValue'))
+            /// The set of functions that called during an item transformation, e.g. @(CLCompile->ContainsMetadata('MetaName', 'metaValue')).
             /// </summary>
-            /// <typeparam name="S">class, IItem</typeparam>
+            /// <typeparam name="S">class, IItem.</typeparam>
             internal static class IntrinsicItemFunctions<S>
                 where S : class, IItem
             {
                 /// <summary>
-                /// A cache of previously created item function delegates
+                /// A cache of previously created item function delegates.
                 /// </summary>
                 private static ConcurrentDictionary<string, ItemTransformFunction> s_transformFunctionDelegateCache = new ConcurrentDictionary<string, ItemTransformFunction>(StringComparer.OrdinalIgnoreCase);
 
                 /// <summary>
                 /// Delegate that represents the signature of all item transformation functions
-                /// This is used to support calling the functions by name
+                /// This is used to support calling the functions by name.
                 /// </summary>
                 public delegate IEnumerable<Pair<string, S>> ItemTransformFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments);
 
                 /// <summary>
                 /// Get a delegate to the given item transformation function by supplying the name and the
-                /// Item type that should be used
+                /// Item type that should be used.
                 /// </summary>
                 internal static ItemTransformFunction GetItemTransformFunction(IElementLocation elementLocation, string functionName, Type itemType)
                 {
@@ -2113,7 +2156,7 @@ internal static ItemTransformFunction GetItemTransformFunction(IElementLocation
 
                 /// <summary>
                 /// Create an enumerator from a base IEnumerable of items into an enumerable
-                /// of transformation result which includes the new itemspec and the base item
+                /// of transformation result which includes the new itemspec and the base item.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S> itemsOfType)
                 {
@@ -2140,7 +2183,7 @@ var resultantItem in
                 }
 
                 /// <summary>
-                /// Intrinsic function that returns the number of items in the list
+                /// Intrinsic function that returns the number of items in the list.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Count(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2149,7 +2192,7 @@ internal static IEnumerable<Pair<string, S>> Count(Expander<P, I> expander, IEle
 
                 /// <summary>
                 /// Intrinsic function that returns the specified built-in modifer value of the items in itemsOfType
-                /// Tuple is {current item include, item under transformation}
+                /// Tuple is {current item include, item under transformation}.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2366,8 +2409,7 @@ internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expand
                             continue;
                         }
 
-                        string directoryName = null;
-
+                        string directoryName;
                         if (!directoryNameTable.TryGetValue(item.Key, out directoryName))
                         {
                             // Unescape as we are passing to the file system
@@ -2417,7 +2459,7 @@ internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expand
                 }
 
                 /// <summary>
-                /// Intrinsic function that returns the contents of the metadata in specified in argument[0]
+                /// Intrinsic function that returns the contents of the metadata in specified in argument[0].
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2474,7 +2516,7 @@ internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, I
 
                 /// <summary>
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
-                /// Using a case sensitive comparison
+                /// Using a case sensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> DistinctWithCase(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2483,7 +2525,7 @@ internal static IEnumerable<Pair<string, S>> DistinctWithCase(Expander<P, I> exp
 
                 /// <summary>
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
-                /// Using a case insensitive comparison
+                /// Using a case insensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Distinct(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2492,7 +2534,7 @@ internal static IEnumerable<Pair<string, S>> Distinct(Expander<P, I> expander, I
 
                 /// <summary>
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
-                /// Using a case insensitive comparison
+                /// Using a case insensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> DistinctWithComparer(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments, StringComparer comparer)
                 {
@@ -2525,7 +2567,7 @@ internal static IEnumerable<Pair<string, S>> Reverse(Expander<P, I> expander, IE
                 }
 
                 /// <summary>
-                /// Intrinsic function that transforms expressions like the %(foo) in @(Compile->'%(foo)')
+                /// Intrinsic function that transforms expressions like the %(foo) in @(Compile->'%(foo)').
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2565,7 +2607,7 @@ internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expa
 
                 /// <summary>
                 /// Intrinsic function that transforms expressions by invoking methods of System.String on the itemspec
-                /// of the item in the pipeline
+                /// of the item in the pipeline.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
                     Expander<P, I> expander,
@@ -2607,7 +2649,7 @@ internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
                 }
 
                 /// <summary>
-                /// Intrinsic function that returns the items from itemsOfType with their metadata cleared, i.e. only the itemspec is retained
+                /// Intrinsic function that returns the items from itemsOfType with their metadata cleared, i.e. only the itemspec is retained.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2624,7 +2666,7 @@ internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expand
 
                 /// <summary>
                 /// Intrinsic function that returns only those items that have a not-blank value for the metadata specified
-                /// Using a case insensitive comparison
+                /// Using a case insensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2661,7 +2703,7 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
 
                 /// <summary>
                 /// Intrinsic function that returns only those items have the given metadata value
-                /// Using a case insensitive comparison
+                /// Using a case insensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2697,7 +2739,7 @@ internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> ex
 
                 /// <summary>
                 /// Intrinsic function that returns a boolean to indicate if any of the items have the given metadata value
-                /// Using a case insensitive comparison
+                /// Using a case insensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2748,34 +2790,34 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
             }
 
             /// <summary>
-            /// Represents all the components of a transform function, including the ability to execute it 
+            /// Represents all the components of a transform function, including the ability to execute it. 
             /// </summary>
-            /// <typeparam name="S">class, IItem</typeparam>
+            /// <typeparam name="S">class, IItem.</typeparam>
             internal class TransformFunction<S>
                 where S : class, IItem
             {
                 /// <summary>
-                /// The delegate that points to the transform function
+                /// The delegate that points to the transform function.
                 /// </summary>
                 private IntrinsicItemFunctions<S>.ItemTransformFunction _transform;
 
                 /// <summary>
-                /// Arguments to pass to the transform function as parsed out of the project file
+                /// Arguments to pass to the transform function as parsed out of the project file.
                 /// </summary>
                 private string[] _arguments;
 
                 /// <summary>
-                /// The element location of the transform expression
+                /// The element location of the transform expression.
                 /// </summary>
                 private IElementLocation _elementLocation;
 
                 /// <summary>
-                /// The name of the function that this class will call
+                /// The name of the function that this class will call.
                 /// </summary>
                 private string _functionName;
 
                 /// <summary>
-                /// TransformFunction constructor
+                /// TransformFunction constructor.
                 /// </summary>
                 public TransformFunction(IElementLocation elementLocation, string functionName, IntrinsicItemFunctions<S>.ItemTransformFunction transform, string[] arguments)
                 {
@@ -2786,7 +2828,7 @@ public TransformFunction(IElementLocation elementLocation, string functionName,
                 }
 
                 /// <summary>
-                /// Arguments to pass to the transform function as parsed out of the project file
+                /// Arguments to pass to the transform function as parsed out of the project file.
                 /// </summary>
                 public string[] Arguments
                 {
@@ -2794,7 +2836,7 @@ public string[] Arguments
                 }
 
                 /// <summary>
-                /// The element location of the transform expression
+                /// The element location of the transform expression.
                 /// </summary>
                 public IElementLocation ElementLocation
                 {
@@ -2802,7 +2844,7 @@ public IElementLocation ElementLocation
                 }
 
                 /// <summary>
-                /// Execute this transform function with the arguments contained within this TransformFunction instance
+                /// Execute this transform function with the arguments contained within this TransformFunction instance.
                 /// </summary>
                 public IEnumerable<Pair<string, S>> Execute(Expander<P, I> expander, bool includeNullEntries, IEnumerable<Pair<string, S>> itemsOfType)
                 {
@@ -2818,22 +2860,22 @@ public IEnumerable<Pair<string, S>> Execute(Expander<P, I> expander, bool includ
             private class MetadataMatchEvaluator
             {
                 /// <summary>
-                /// The current ItemSpec of the item being matched
+                /// The current ItemSpec of the item being matched.
                 /// </summary>
                 private string _itemSpec;
 
                 /// <summary>
-                /// Item used as the source of metadata
+                /// Item used as the source of metadata.
                 /// </summary>
                 private IItem _sourceOfMetadata;
 
                 /// <summary>
-                /// Location of the match
+                /// Location of the match.
                 /// </summary>
                 private IElementLocation _elementLocation;
 
                 /// <summary>
-                /// Constructor
+                /// Constructor.
                 /// </summary>
                 internal MetadataMatchEvaluator(string itemSpec, IItem sourceOfMetadata, IElementLocation elementLocation)
                 {
@@ -2845,7 +2887,7 @@ internal MetadataMatchEvaluator(string itemSpec, IItem sourceOfMetadata, IElemen
                 /// <summary>
                 /// Expands the metadata in the match provided into a string result.
                 /// The match is expected to be the content of a transform.
-                /// For example, representing "%(Filename.obj)" in the original expression "@(Compile->'%(Filename.obj)')"
+                /// For example, representing "%(Filename.obj)" in the original expression "@(Compile->'%(Filename.obj)')".
                 /// </summary>
                 internal string GetMetadataValueFromMatch(Match match)
                 {
@@ -2906,7 +2948,7 @@ private static class RegularExpressions
             internal const string NameGroup = "NAME";
 
             /// <summary>
-            /// Name of the group matching the prefix on a metadata expression, for example "Compile." in "%(Compile.Object)"
+            /// Name of the group matching the prefix on a metadata expression, for example "Compile." in "%(Compile.Object)".
             /// </summary>
             internal const string ItemSpecificationGroup = "ITEM_SPECIFICATION";
 
@@ -2916,9 +2958,9 @@ private static class RegularExpressions
             internal const string ItemTypeGroup = "ITEM_TYPE";
 
             /// <summary>
-            /// regular expression used to match item metadata references outside of item vector transforms
+            /// regular expression used to match item metadata references outside of item vector transforms.
             /// </summary>
-            /// <remarks>PERF WARNING: this Regex is complex and tends to run slowly</remarks>
+            /// <remarks>PERF WARNING: this Regex is complex and tends to run slowly.</remarks>
             internal static readonly Lazy<Regex> NonTransformItemMetadataPattern = new Lazy<Regex>(
                 () => new Regex
                     (
@@ -2937,12 +2979,12 @@ private static class RegularExpressions
             private const string ItemMetadataSpecification = @"%\(\s* (?<ITEM_SPECIFICATION>(?<ITEM_TYPE>" + ProjectWriter.itemTypeOrMetadataNameSpecification + @")\s*\.\s*)? (?<NAME>" + ProjectWriter.itemTypeOrMetadataNameSpecification + @") \s*\)";
 
             /// <summary>
-            /// description of an item vector with a transform, left hand side 
+            /// description of an item vector with a transform, left hand side. 
             /// </summary> 
             private const string ItemVectorWithTransformLHS = @"@\(\s*" + ProjectWriter.itemTypeOrMetadataNameSpecification + @"\s*->\s*'[^']*";
 
             /// <summary>
-            /// description of an item vector with a transform, right hand side 
+            /// description of an item vector with a transform, right hand side. 
             /// </summary> 
             private const string ItemVectorWithTransformRHS = @"[^']*'(\s*,\s*'[^']*')?\s*\)";
 
@@ -2955,37 +2997,37 @@ private struct FunctionBuilder<T>
             where T : class, IProperty
         {
             /// <summary>
-            /// The type of this function's receiver
+            /// The type of this function's receiver.
             /// </summary>
             public Type ReceiverType { get; set; }
 
             /// <summary>
-            /// The name of the function
+            /// The name of the function.
             /// </summary>
             public string Name { get; set; }
 
             /// <summary>
-            /// The arguments for the function
+            /// The arguments for the function.
             /// </summary>
             public string[] Arguments { get; set; }
 
             /// <summary>
-            /// The expression that this function is part of
+            /// The expression that this function is part of.
             /// </summary>
             public string Expression { get; set; }
 
             /// <summary>
-            /// The property name that this function is applied on
+            /// The property name that this function is applied on.
             /// </summary>
             public string Receiver { get; set; }
 
             /// <summary>
-            /// The binding flags that will be used during invocation of this function
+            /// The binding flags that will be used during invocation of this function.
             /// </summary>
             public BindingFlags BindingFlags { get; set; }
 
             /// <summary>
-            /// The remainder of the body once the function and arguments have been extracted
+            /// The remainder of the body once the function and arguments have been extracted.
             /// </summary>
             public string Remainder { get; set; }
 
@@ -3014,44 +3056,44 @@ internal Function<T> Build()
 
         /// <summary>
         /// This class represents the function as extracted from an expression
-        /// It is also responsible for executing the function
+        /// It is also responsible for executing the function.
         /// </summary>
-        /// <typeparam name="T">Type of the properties used to expand the expression</typeparam>
+        /// <typeparam name="T">Type of the properties used to expand the expression.</typeparam>
         private class Function<T>
             where T : class, IProperty
         {
             /// <summary>
-            /// The type of this function's receiver
+            /// The type of this function's receiver.
             /// </summary>
             private Type _receiverType;
 
             /// <summary>
-            /// The name of the function
+            /// The name of the function.
             /// </summary>
             private string _methodMethodName;
 
             /// <summary>
-            /// The arguments for the function
+            /// The arguments for the function.
             /// </summary>
             private string[] _arguments;
 
             /// <summary>
-            /// The expression that this function is part of
+            /// The expression that this function is part of.
             /// </summary>
             private string _expression;
 
             /// <summary>
-            /// The property name that this function is applied on
+            /// The property name that this function is applied on.
             /// </summary>
             private string _receiver;
 
             /// <summary>
-            /// The binding flags that will be used during invocation of this function
+            /// The binding flags that will be used during invocation of this function.
             /// </summary>
             private BindingFlags _bindingFlags;
 
             /// <summary>
-            /// The remainder of the body once the function and arguments have been extracted
+            /// The remainder of the body once the function and arguments have been extracted.
             /// </summary>
             private string _remainder;
 
@@ -3063,7 +3105,7 @@ private class Function<T>
             private IFileSystem _fileSystem;
 
             /// <summary>
-            /// Construct a function that will be executed during property evaluation
+            /// Construct a function that will be executed during property evaluation.
             /// </summary>
             internal Function(
                 Type receiverType,
@@ -3100,7 +3142,7 @@ internal Function(
             /// This accessor is used by the Expander
             /// Examples of expression root:
             ///     [System.Diagnostics.Process]::Start
-            ///     SomeMSBuildProperty
+            ///     SomeMSBuildProperty.
             /// </summary>
             internal string Receiver
             {
@@ -3108,7 +3150,7 @@ internal string Receiver
             }
 
             /// <summary>
-            /// Extract the function details from the given property function expression
+            /// Extract the function details from the given property function expression.
             /// </summary>
             internal static Function<T> ExtractPropertyFunction(
                 string expressionFunction,
@@ -3232,7 +3274,7 @@ internal static Function<T> ExtractPropertyFunction(
             }
 
             /// <summary>
-            /// Execute the function on the given instance
+            /// Execute the function on the given instance.
             /// </summary>
             internal object Execute(object objectInstance, IPropertyProvider<T> properties, ExpanderOptions options, IElementLocation elementLocation)
             {
@@ -3469,12 +3511,12 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
             /// bad for debugging experience and has a performance cost.
             /// A typical binding operation with exception can take ~1.500 ms; this call is ~0.050 ms
             /// (rough numbers just for comparison).
-            /// See https://github.com/Microsoft/msbuild/issues/2217
+            /// See https://github.com/Microsoft/msbuild/issues/2217.
             /// </summary>
-            /// <param name="returnVal">The value returned from the function call</param>
-            /// <param name="objectInstance">Object that the function is called on</param>
-            /// <param name="args">arguments</param>
-            /// <returns>True if the well known function call binding was successful</returns>
+            /// <param name="returnVal">The value returned from the function call.</param>
+            /// <param name="objectInstance">Object that the function is called on.</param>
+            /// <param name="args">arguments.</param>
+            /// <returns>True if the well known function call binding was successful.</returns>
             private bool TryExecuteWellKnownFunction(out object returnVal, object objectInstance, object[] args)
             {
                 returnVal = null;
@@ -3964,6 +4006,22 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.StableStringHash), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.StableStringHash(arg0);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.AreFeaturesEnabled), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.AreFeaturesEnabled(arg0);
+                                return true;
+                            }
+                        }
                     }
                     else if (_receiverType == typeof(Path))
                     {
@@ -4408,8 +4466,8 @@ private void LogFunctionCall(string fileName, object objectInstance, object[] ar
             /// <summary>
             /// Given a type name and method name, try to resolve the type.
             /// </summary>
-            /// <param name="typeName">May be full name or assembly qualified name</param>
-            /// <param name="simpleMethodName">simple name of the method</param>
+            /// <param name="typeName">May be full name or assembly qualified name.</param>
+            /// <param name="simpleMethodName">simple name of the method.</param>
             /// <returns></returns>
             private static Type GetTypeForStaticMethod(string typeName, string simpleMethodName)
             {
@@ -4499,13 +4557,12 @@ private static Type GetTypeForStaticMethod(string typeName, string simpleMethodN
             }
 
             /// <summary>
-            /// Gets the specified type using the namespace to guess the assembly that its in
+            /// Gets the specified type using the namespace to guess the assembly that its in.
             /// </summary>
             private static Type GetTypeFromAssemblyUsingNamespace(string typeName)
             {
                 string baseName = typeName;
                 int assemblyNameEnd = baseName.Length;
-                Type foundType = null;
 
                 // If the string has no dot, or is nothing but a dot, we have no
                 // namespace to look for, so we can't help.
@@ -4520,7 +4577,7 @@ private static Type GetTypeFromAssemblyUsingNamespace(string typeName)
                     string candidateAssemblyName = baseName.Substring(0, assemblyNameEnd);
 
                     // Try to load the assembly with the computed name
-                    foundType = GetTypeFromAssembly(typeName, candidateAssemblyName);
+                    Type foundType = GetTypeFromAssembly(typeName, candidateAssemblyName);
 
                     if (foundType != null)
                     {
@@ -4540,7 +4597,7 @@ private static Type GetTypeFromAssemblyUsingNamespace(string typeName)
             }
 
             /// <summary>
-            /// Get the specified type from the assembly partial name supplied
+            /// Get the specified type from the assembly partial name supplied.
             /// </summary>
             [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Reflection.Assembly.LoadWithPartialName", Justification = "Necessary since we don't have the full assembly name. ")]
             private static Type GetTypeFromAssembly(string typeName, string candidateAssemblyName)
@@ -4579,7 +4636,7 @@ private static Type GetTypeFromAssembly(string typeName, string candidateAssembl
 
             /// <summary>
             /// Extracts the name, arguments, binding flags, and invocation type for an indexer
-            /// Also extracts the remainder of the expression that is not part of this indexer
+            /// Also extracts the remainder of the expression that is not part of this indexer.
             /// </summary>
             private static void ConstructIndexerFunction(string expressionFunction, IElementLocation elementLocation, object propertyValue, int methodStartIndex, int indexerEndIndex, ref FunctionBuilder<T> functionBuilder)
             {
@@ -4622,7 +4679,7 @@ private static void ConstructIndexerFunction(string expressionFunction, IElement
 
             /// <summary>
             /// Extracts the name, arguments, binding flags, and invocation type for a static or instance function.
-            /// Also extracts the remainder of the expression that is not part of this function
+            /// Also extracts the remainder of the expression that is not part of this function.
             /// </summary>
             private static void ConstructFunction(IElementLocation elementLocation, string expressionFunction, int argumentStartIndex, int methodStartIndex, ref FunctionBuilder<T> functionBuilder)
             {
@@ -4645,8 +4702,6 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                 // There are arguments that need to be passed to the function
                 if (argumentStartIndex > -1 && !expressionSubstringAsSpan.Contains(".".AsSpan(), StringComparison.OrdinalIgnoreCase))
                 {
-                    string argumentsContent;
-
                     // separate the function and the arguments
                     functionName = expressionSubstringAsSpan.Trim();
 
@@ -4667,16 +4722,15 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                     // It may be that there are '()' but no actual arguments content
                     if (argumentStartIndex == expressionFunction.Length - 1)
                     {
-                        argumentsContent = String.Empty;
                         functionArguments = Array.Empty<string>();
                     }
                     else
                     {
                         // we have content within the '()' so let's extract and deal with it
-                        argumentsContent = expressionFunction.Substring(argumentStartIndex, argumentsEndIndex - argumentStartIndex);
+                        string argumentsContent = expressionFunction.Substring(argumentStartIndex, argumentsEndIndex - argumentStartIndex);
 
                         // If there are no arguments, then just create an empty array
-                        if (String.IsNullOrEmpty(argumentsContent))
+                        if (string.IsNullOrEmpty(argumentsContent))
                         {
                             functionArguments = Array.Empty<string>();
                         }
@@ -4736,7 +4790,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
 
             /// <summary>
             /// Coerce the arguments according to the parameter types
-            /// Will only return null if the coercion didn't work due to an InvalidCastException
+            /// Will only return null if the coercion didn't work due to an InvalidCastException.
             /// </summary>
             private static object[] CoerceArguments(object[] args, ParameterInfo[] parameters)
             {
@@ -4896,9 +4950,6 @@ private static bool IsStaticMethodAvailable(Type receiverType, string methodName
             /// </summary>
             private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object objectInstance /* null unless instance method */, object[] args, bool isConstructor)
             {
-                ParameterInfo[] parameters = null;
-                MethodBase[] members = null;
-                MethodBase memberInfo = null;
 
                 // First let's try for a method where all arguments are strings..
                 Type[] types = new Type[_arguments.Length];
@@ -4907,6 +4958,7 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
                     types[n] = typeof(string);
                 }
 
+                MethodBase memberInfo;
                 if (isConstructor)
                 {
                     memberInfo = _receiverType.GetConstructor(bindingFlags, null, types, null);
@@ -4920,6 +4972,7 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
                 // search for a method with the right number of arguments
                 if (memberInfo == null)
                 {
+                    MethodBase[] members;
                     // Gather all methods that may match
                     if (isConstructor)
                     {
@@ -4930,22 +4983,21 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
                         members = _receiverType.GetMethods(bindingFlags);
                     }
 
-                    // Try to find a method with the right name, number of arguments and
-                    // compatible argument types
-                    object[] coercedArguments = null;
                     foreach (MethodBase member in members)
                     {
-                        parameters = member.GetParameters();
+                        ParameterInfo[] parameters = member.GetParameters();
 
                         // Simple match on name and number of params, we will be case insensitive
                         if (parameters.Length == _arguments.Length)
                         {
                             if (isConstructor || String.Equals(member.Name, _methodMethodName, StringComparison.OrdinalIgnoreCase))
                             {
+                                // Try to find a method with the right name, number of arguments and
+                                // compatible argument types
                                 // we have a match on the name and argument number
                                 // now let's try to coerce the arguments we have
                                 // into the arguments on the matching method
-                                coercedArguments = CoerceArguments(args, parameters);
+                                object[] coercedArguments = CoerceArguments(args, parameters);
 
                                 if (coercedArguments != null)
                                 {
@@ -4989,12 +5041,12 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
     }
 
     /// <summary>
-    /// This class wraps information about properties which have been used before they are initialized 
+    /// This class wraps information about properties which have been used before they are initialized. 
     /// </summary>
     internal class UsedUninitializedProperties
     {
         /// <summary>
-        /// This class wraps information about properties which have been used before they are initialized
+        /// This class wraps information about properties which have been used before they are initialized.
         /// </summary>
         internal UsedUninitializedProperties()
         {
@@ -5002,7 +5054,7 @@ internal UsedUninitializedProperties()
         }
 
         /// <summary>
-        /// Hash set of properties which have been used before being initialized
+        /// Hash set of properties which have been used before being initialized.
         /// </summary>
         internal IDictionary<string, IElementLocation> Properties
         {
@@ -5020,7 +5072,7 @@ internal bool Warn
         }
 
         /// <summary>
-        ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property
+        ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property.
         /// </summary>
         internal string CurrentlyEvaluatingPropertyElementName
         {
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index a4b4bb26288..aa5f8b40442 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -2,13 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
-using System.Diagnostics;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System.Collections.Generic;
 using Microsoft.Build.Collections;
@@ -127,10 +123,8 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
                 if (Sink(expression, ref i, end, '@', '('))
                 {
                     List<ItemExpressionCapture> transformExpressions = null;
-                    string itemName = null;
                     string separator = null;
                     int separatorStart = -1;
-                    int separatorLength = -1;
 
                     // Start of a possible item list expression
 
@@ -164,7 +158,7 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
                     string name = expression.Substring(startOfName, i - startOfName);
 
                     // return the item that we're working with
-                    itemName = name;
+                    string itemName = name;
 
                     SinkWhitespace(expression, ref i);
                     bool transformOrFunctionFound = true;
@@ -235,8 +229,7 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
                         }
 
                         separatorStart = i - startPoint;
-                        separatorLength = closingQuote - i;
-                        separator = expression.Substring(i, separatorLength);
+                        separator = expression.Substring(i, closingQuote - i);
 
                         i = closingQuote + 1;
                     }
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index e64817750e8..af0265b01d3 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -3,9 +3,7 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.BackEnd;
diff --git a/src/Build/Evaluation/IItem.cs b/src/Build/Evaluation/IItem.cs
index 12bc4903d6b..197cd8389e6 100644
--- a/src/Build/Evaluation/IItem.cs
+++ b/src/Build/Evaluation/IItem.cs
@@ -1,11 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Construction;
 
 namespace Microsoft.Build.Evaluation
 {
diff --git a/src/Build/Evaluation/IItemDefinition.cs b/src/Build/Evaluation/IItemDefinition.cs
index b7e170f0520..c9d41bf5453 100644
--- a/src/Build/Evaluation/IItemDefinition.cs
+++ b/src/Build/Evaluation/IItemDefinition.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Construction;
 
 namespace Microsoft.Build.Evaluation
diff --git a/src/Build/Evaluation/IItemFactory.cs b/src/Build/Evaluation/IItemFactory.cs
index f1476be816d..bcd3b91211f 100644
--- a/src/Build/Evaluation/IItemFactory.cs
+++ b/src/Build/Evaluation/IItemFactory.cs
@@ -1,9 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/Evaluation/IItemProvider.cs b/src/Build/Evaluation/IItemProvider.cs
index 17ff4aca42f..2bd826a481a 100644
--- a/src/Build/Evaluation/IItemProvider.cs
+++ b/src/Build/Evaluation/IItemProvider.cs
@@ -1,10 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Text;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Evaluation
 {
diff --git a/src/Build/Evaluation/IMetadataTable.cs b/src/Build/Evaluation/IMetadataTable.cs
index 8b8c8b2f97a..5f95f3a8f08 100644
--- a/src/Build/Evaluation/IMetadataTable.cs
+++ b/src/Build/Evaluation/IMetadataTable.cs
@@ -1,12 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Shared;
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
diff --git a/src/Build/Evaluation/IMetadatum.cs b/src/Build/Evaluation/IMetadatum.cs
index 20cd3bf6354..aa828e835ad 100644
--- a/src/Build/Evaluation/IMetadatum.cs
+++ b/src/Build/Evaluation/IMetadatum.cs
@@ -1,12 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Construction;
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
diff --git a/src/Build/Evaluation/IProperty.cs b/src/Build/Evaluation/IProperty.cs
index 33fdf1c7ca7..bdaedfcaff7 100644
--- a/src/Build/Evaluation/IProperty.cs
+++ b/src/Build/Evaluation/IProperty.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Collections;
 
 namespace Microsoft.Build.Evaluation
diff --git a/src/Build/Evaluation/IPropertyProvider.cs b/src/Build/Evaluation/IPropertyProvider.cs
index def155159ee..6b293c4c108 100644
--- a/src/Build/Evaluation/IPropertyProvider.cs
+++ b/src/Build/Evaluation/IPropertyProvider.cs
@@ -1,10 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
diff --git a/src/Build/Evaluation/IToolsetProvider.cs b/src/Build/Evaluation/IToolsetProvider.cs
index 2d9d3640a14..46bbb505063 100644
--- a/src/Build/Evaluation/IToolsetProvider.cs
+++ b/src/Build/Evaluation/IToolsetProvider.cs
@@ -1,10 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 
 namespace Microsoft.Build.Evaluation
 {
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index d0143d1560d..7bdedf62916 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -347,6 +347,14 @@ internal static string ValueOrDefault(string conditionValue, string defaultValue
             }
         }
 
+        ///<summary>
+        /// Hash the string independent of bitness and target framework.
+        /// </summary>
+        internal static int StableStringHash(string toHash)
+        {
+            return CommunicationsUtilities.GetHashCode(toHash);
+        }
+
         /// <summary>
         /// Returns true if a task host exists that can service the requested runtime and architecture
         /// values, and false otherwise.
@@ -506,6 +514,11 @@ internal static string GetTargetPlatformVersion(string tfm, int versionPartCount
             return NuGetFramework.Value.GetTargetPlatformVersion(tfm, versionPartCount);
         }
 
+        internal static bool AreFeaturesEnabled(string wave)
+        {
+            return string.IsNullOrEmpty(wave) ? false : ChangeWaves.AreFeaturesEnabled(wave);
+        }
+
         public static string GetCurrentToolsDirectory()
         {
             return BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 165407a7f02..ba38ae601d5 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -4,11 +4,9 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Runtime.InteropServices.WindowsRuntime;
 using Microsoft.Build.Globbing;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.EscapingStringExtensions;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -419,19 +417,17 @@ internal abstract class ItemSpecFragment
         protected string ProjectDirectory { get; }
 
         // not a Lazy to reduce memory
-        private FileSpecMatcherTester FileMatcher
+        private ref FileSpecMatcherTester FileMatcher
         {
             get
             {
-                if (_fileMatcherInitialized)
+                if (!_fileMatcherInitialized)
                 {
-                    return _fileMatcher;
+                    _fileMatcher = CreateFileSpecMatcher();
+                    _fileMatcherInitialized = true;
                 }
 
-                _fileMatcher = CreateFileSpecMatcher();
-                _fileMatcherInitialized = true;
-
-                return _fileMatcher;
+                return ref _fileMatcher;
             }
         }
 
@@ -475,7 +471,7 @@ public virtual IMSBuildGlob ToMSBuildGlob()
 
         protected virtual IMSBuildGlob CreateMsBuildGlob()
         {
-            return MSBuildGlob.Parse(ProjectDirectory, TextFragment.Unescape());
+            return MSBuildGlob.Parse(ProjectDirectory, EscapingUtilities.UnescapeAll(TextFragment));
         }
 
         private FileSpecMatcherTester CreateFileSpecMatcher()
@@ -498,5 +494,14 @@ public GlobFragment(string textFragment, string projectDirectory)
             : base(textFragment, projectDirectory)
         {
         }
+
+        /// <summary>
+        /// True if TextFragment starts with /**/ or a variation thereof with backslashes.
+        /// </summary>
+        public bool IsFullFileSystemScan => TextFragment.Length >= 4
+            && FileUtilities.IsAnySlash(TextFragment[0])
+            && TextFragment[1] == '*'
+            && TextFragment[2] == '*'
+            && FileUtilities.IsAnySlash(TextFragment[3]);
     }
 }
diff --git a/src/Build/Evaluation/ItemsAndMetadataPair.cs b/src/Build/Evaluation/ItemsAndMetadataPair.cs
index 68ab439b18b..5e9841d34e1 100644
--- a/src/Build/Evaluation/ItemsAndMetadataPair.cs
+++ b/src/Build/Evaluation/ItemsAndMetadataPair.cs
@@ -1,11 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Evaluation
 {
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index 528b2d85cbd..233156392bd 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -5,6 +5,7 @@
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 using System;
 using System.Collections.Generic;
 using System.Collections.Immutable;
@@ -89,34 +90,40 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
                     }
                     else if (fragment is GlobFragment globFragment)
                     {
-                        string glob = globFragment.TextFragment;
-
-                        if (excludePatternsForGlobs == null)
-                        {
-                            excludePatternsForGlobs = BuildExcludePatternsForGlobs(globsToIgnore, excludePatterns);
-                        }
-
-                        string[] includeSplitFilesEscaped;
-                        if (MSBuildEventSource.Log.IsEnabled())
-                        {
-                            MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
-                        }
-                        using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
-                        {
-                            includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
-                                _rootDirectory,
-                                glob,
-                                excludePatternsForGlobs
-                            );
-                        }
-                        if (MSBuildEventSource.Log.IsEnabled())
-                        {
-                            MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
-                        }
-
-                        foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
+                        // If this item is behind a false condition and represents a full drive/filesystem scan, expanding it is
+                        // almost certainly undesired. It should be skipped to avoid evaluation taking an excessive amount of time.
+                        bool skipGlob = !_conditionResult && globFragment.IsFullFileSystemScan && !Traits.Instance.EscapeHatches.AlwaysEvaluateDangerousGlobs && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_8);
+                        if (!skipGlob)
                         {
-                            itemsToAdd.Add(_itemFactory.CreateItem(includeSplitFileEscaped, glob, _itemElement.ContainingProject.FullPath));
+                            string glob = globFragment.TextFragment;
+
+                            if (excludePatternsForGlobs == null)
+                            {
+                                excludePatternsForGlobs = BuildExcludePatternsForGlobs(globsToIgnore, excludePatterns);
+                            }
+
+                            string[] includeSplitFilesEscaped;
+                            if (MSBuildEventSource.Log.IsEnabled())
+                            {
+                                MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
+                            }
+                            using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
+                            {
+                                includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
+                                    _rootDirectory,
+                                    glob,
+                                    excludePatternsForGlobs
+                                );
+                            }
+                            if (MSBuildEventSource.Log.IsEnabled())
+                            {
+                                MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
+                            }
+
+                            foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
+                            {
+                                itemsToAdd.Add(_itemFactory.CreateItem(includeSplitFileEscaped, glob, _itemElement.ContainingProject.FullPath));
+                            }
                         }
                     }
                     else
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index 00df64e8270..546ef225a4e 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Construction;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 using System.Collections.Immutable;
 using System.Linq;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 58b2d1d661f..64df2a7402f 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -59,18 +59,14 @@ public LazyItemEvaluator(IEvaluatorData<P, I, M, D> data, IItemFactory<I, I> ite
 
         private ImmutableList<I> GetItems(string itemType)
         {
-            LazyItemList itemList = GetItemList(itemType);
-            if (itemList == null)
-            {
-                return ImmutableList<I>.Empty;
-            }
-
-            return itemList.GetMatchedItems(ImmutableHashSet<string>.Empty);
+            return _itemLists.TryGetValue(itemType, out LazyItemList itemList) ?
+                itemList.GetMatchedItems(ImmutableHashSet<string>.Empty) :
+                ImmutableList<I>.Empty;
         }
 
         public bool EvaluateConditionWithCurrentState(ProjectElement element, ExpanderOptions expanderOptions, ParserOptions parserOptions)
         {
-            return EvaluateCondition(element, expanderOptions, parserOptions, _expander, this);
+            return EvaluateCondition(element.Condition, element, expanderOptions, parserOptions, _expander, this);
         }
 
         private static bool EvaluateCondition(
@@ -108,17 +104,6 @@ LazyItemEvaluator<P, I, M, D> lazyEvaluator
             }
         }
 
-        private static bool EvaluateCondition(
-            ProjectElement element,
-            ExpanderOptions expanderOptions,
-            ParserOptions parserOptions,
-            Expander<P, I> expander,
-            LazyItemEvaluator<P, I, M, D> lazyEvaluator
-            )
-        {
-            return EvaluateCondition(element.Condition, element, expanderOptions, parserOptions, expander, lazyEvaluator);
-        }
-
         /// <summary>
         /// COMPAT: Whidbey used the "current project file/targets" directory for evaluating Import and PropertyGroup conditions
         /// Orcas broke this by using the current root project file for all conditions
@@ -417,21 +402,13 @@ public OperationBuilderWithMetadata(ProjectItemElement itemElement, bool conditi
 
         private void AddReferencedItemList(string itemType, IDictionary<string, LazyItemList> referencedItemLists)
         {
-            var itemList = GetItemList(itemType);
-            if (itemList != null)
+            if (_itemLists.TryGetValue(itemType, out LazyItemList itemList))
             {
                 itemList.MarkAsReferenced();
                 referencedItemLists[itemType] = itemList;
             }
         }
 
-        private LazyItemList GetItemList(string itemType)
-        {
-            LazyItemList ret;
-            _itemLists.TryGetValue(itemType, out ret);
-            return ret;
-        }
-
         public IEnumerable<ItemData> GetAllItemsDeferred()
         {
             return _itemLists.Values.SelectMany(itemList => itemList.GetItemData(ImmutableHashSet<string>.Empty))
@@ -459,7 +436,7 @@ public void ProcessItemElement(string rootDirectory, ProjectItemElement itemElem
                 ErrorUtilities.ThrowInternalErrorUnreachable();
             }
 
-            LazyItemList previousItemList = GetItemList(itemElement.ItemType);
+            _itemLists.TryGetValue(itemElement.ItemType, out LazyItemList previousItemList);
             LazyItemList newList = new LazyItemList(previousItemList, operation);
             _itemLists[itemElement.ItemType] = newList;
         }
diff --git a/src/Build/Evaluation/MetadataReference.cs b/src/Build/Evaluation/MetadataReference.cs
index 09e40bfb52d..0bb7ce0fbf0 100644
--- a/src/Build/Evaluation/MetadataReference.cs
+++ b/src/Build/Evaluation/MetadataReference.cs
@@ -1,12 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
diff --git a/src/Build/Evaluation/Preprocessor.cs b/src/Build/Evaluation/Preprocessor.cs
index 794e709cefb..104bcba8a2c 100644
--- a/src/Build/Evaluation/Preprocessor.cs
+++ b/src/Build/Evaluation/Preprocessor.cs
@@ -3,15 +3,10 @@
 
 using System;
 using System.Collections.Generic;
-using System.IO;
 using System.Linq;
-using System.Text;
 using System.Xml;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Internal;
-using Microsoft.Build.Collections;
 
 namespace Microsoft.Build.Evaluation
 {
diff --git a/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs b/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs
index 4d47f224e34..555aef21810 100644
--- a/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs
+++ b/src/Build/Evaluation/Profiler/EvaluationLocationTabSeparatedPrettyPrinter.cs
@@ -36,9 +36,7 @@ protected override string NormalizeExpression(string description, EvaluationLoca
             }
 
             // Swap tabs for spaces, so we don't mess up the TSV format
-            text = text.Replace(Separator, " ");
-
-            return text;
+            return text.Replace(Separator, " ");
         }
     }
 }
diff --git a/src/Build/Evaluation/ProjectChangedEventArgs.cs b/src/Build/Evaluation/ProjectChangedEventArgs.cs
index 3504098b754..7683617b1bb 100644
--- a/src/Build/Evaluation/ProjectChangedEventArgs.cs
+++ b/src/Build/Evaluation/ProjectChangedEventArgs.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Evaluation
diff --git a/src/Build/Evaluation/ProjectStringCache.cs b/src/Build/Evaluation/ProjectStringCache.cs
index 3413404d5aa..699964700c6 100644
--- a/src/Build/Evaluation/ProjectStringCache.cs
+++ b/src/Build/Evaluation/ProjectStringCache.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
 using System.Xml;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
diff --git a/src/Build/Evaluation/StringMetadataTable.cs b/src/Build/Evaluation/StringMetadataTable.cs
index 2cd255fc62d..0064888281c 100644
--- a/src/Build/Evaluation/StringMetadataTable.cs
+++ b/src/Build/Evaluation/StringMetadataTable.cs
@@ -3,9 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -73,7 +70,7 @@ public string GetEscapedValueIfPresent(string itemType, string name)
                 key = itemType + "." + name;
             }
 
-            string value = null;
+            string value;
             _metadata.TryGetValue(key, out value);
 
             return value;
diff --git a/src/Build/FileSystem/MSBuildFileSystemAdapter.cs b/src/Build/FileSystem/MSBuildFileSystemAdapter.cs
new file mode 100644
index 00000000000..4c69284d955
--- /dev/null
+++ b/src/Build/FileSystem/MSBuildFileSystemAdapter.cs
@@ -0,0 +1,54 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Shared.FileSystem;
+
+namespace Microsoft.Build.FileSystem
+{
+     internal class MSBuildFileSystemAdapter : IFileSystem
+    {
+        private readonly MSBuildFileSystemBase _msbuildFileSystem;
+        public MSBuildFileSystemAdapter(MSBuildFileSystemBase msbuildFileSystem)
+        {
+            _msbuildFileSystem = msbuildFileSystem;
+        }
+        public TextReader ReadFile(string path) => _msbuildFileSystem.ReadFile(path);
+
+        public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share) => _msbuildFileSystem.GetFileStream(path, mode, access, share);
+
+        public string ReadFileAllText(string path) => _msbuildFileSystem.ReadFileAllText(path);
+
+        public byte[] ReadFileAllBytes(string path) => _msbuildFileSystem.ReadFileAllBytes(path);
+
+        public IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            return _msbuildFileSystem.EnumerateFiles(path, searchPattern, searchOption);
+        }
+
+        public IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            return _msbuildFileSystem.EnumerateDirectories(path, searchPattern, searchOption);
+        }
+
+        public IEnumerable<string> EnumerateFileSystemEntries(
+            string path,
+            string searchPattern = "*",
+            SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            return _msbuildFileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+        }
+
+        public FileAttributes GetAttributes(string path) => _msbuildFileSystem.GetAttributes(path);
+
+        public DateTime GetLastWriteTimeUtc(string path) => _msbuildFileSystem.GetLastWriteTimeUtc(path);
+
+        public bool DirectoryExists(string path) => _msbuildFileSystem.DirectoryExists(path);
+
+        public bool FileExists(string path) => _msbuildFileSystem.FileExists(path);
+
+        public bool DirectoryEntryExists(string path) => _msbuildFileSystem.FileOrDirectoryExists(path);
+    }
+}
diff --git a/src/Build/FileSystem/MSBuildFileSystemBase.cs b/src/Build/FileSystem/MSBuildFileSystemBase.cs
new file mode 100644
index 00000000000..5383e717a9b
--- /dev/null
+++ b/src/Build/FileSystem/MSBuildFileSystemBase.cs
@@ -0,0 +1,79 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+
+namespace Microsoft.Build.FileSystem
+{
+    /// <summary>
+    /// Abstracts away some file system operations.
+    ///
+    /// Implementations:
+    /// - must be thread safe
+    /// - may cache some or all the calls.
+    /// </summary>
+    public abstract class MSBuildFileSystemBase
+    {
+        /// <summary>
+        /// Use this for var sr = new StreamReader(path)
+        /// </summary>
+        public abstract TextReader ReadFile(string path);
+
+        /// <summary>
+        /// Use this for new FileStream(path, mode, access, share)
+        /// </summary>
+        public abstract Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
+
+        /// <summary>
+        /// Use this for File.ReadAllText(path)
+        /// </summary>
+        public abstract string ReadFileAllText(string path);
+
+        /// <summary>
+        /// Use this for File.ReadAllBytes(path)
+        /// </summary>
+        public abstract byte[] ReadFileAllBytes(string path);
+
+        /// <summary>
+        /// Use this for Directory.EnumerateFiles(path, pattern, option)
+        /// </summary>
+        public abstract IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly);
+
+        /// <summary>
+        /// Use this for Directory.EnumerateFolders(path, pattern, option)
+        /// </summary>
+        public abstract IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly);
+
+        /// <summary>
+        /// Use this for Directory.EnumerateFileSystemEntries(path, pattern, option)
+        /// </summary>
+        public abstract IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly);
+
+        /// <summary>
+        /// Use this for File.GetAttributes()
+        /// </summary>
+        public abstract FileAttributes GetAttributes(string path);
+
+        /// <summary>
+        /// Use this for File.GetLastWriteTimeUtc(path)
+        /// </summary>
+        public abstract DateTime GetLastWriteTimeUtc(string path);
+
+        /// <summary>
+        /// Use this for Directory.Exists(path)
+        /// </summary>
+        public abstract bool DirectoryExists(string path);
+
+        /// <summary>
+        /// Use this for File.Exists(path)
+        /// </summary>
+        public abstract bool FileExists(string path);
+
+        /// <summary>
+        /// Use this for File.Exists(path) || Directory.Exists(path)
+        /// </summary>
+        public abstract bool FileOrDirectoryExists(string path);
+    }
+}
diff --git a/src/Build/FxCopExclusions/Microsoft.Build.Suppressions.cs b/src/Build/FxCopExclusions/Microsoft.Build.Suppressions.cs
index e1e53eb1890..00cd81357fe 100644
--- a/src/Build/FxCopExclusions/Microsoft.Build.Suppressions.cs
+++ b/src/Build/FxCopExclusions/Microsoft.Build.Suppressions.cs
@@ -5,8 +5,6 @@
 // Add module level suppressions to this file to have them suppressed in the assembly
 //
 
-using System.Diagnostics.CodeAnalysis;
-
 #if CODE_ANALYSIS
 [module: SuppressMessage("Microsoft.Design","CA1020:AvoidNamespacesWithFewTypes", Scope="namespace", Target="Microsoft.Build.Debugging", Justification="This deserves its own namespace")]
 [module: SuppressMessage("Microsoft.Naming", "CA1703:ResourceStringsShouldBeSpelledCorrectly", Scope="resource", Target="Microsoft.Build.Strings.resources", MessageId="itemname", Justification="itemname is spelled correctly")]
diff --git a/src/Build/Globbing/IMSBuildGlob.cs b/src/Build/Globbing/IMSBuildGlob.cs
index 4276935f9cc..59e630fd225 100644
--- a/src/Build/Globbing/IMSBuildGlob.cs
+++ b/src/Build/Globbing/IMSBuildGlob.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-
-using System.Collections.Generic;
-
 namespace Microsoft.Build.Globbing
 {
     /// <summary>
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index b411f73aed9..6eb35e81b52 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -238,9 +238,7 @@ private static string NormalizeTheFixedDirectoryPartAgainstTheGlobRoot(string fi
             // concatenate the glob parent to the fixed dir part
             var parentedFixedPart = Path.Combine(globRoot, fixedDirPart);
             var normalizedFixedPart = FileUtilities.GetFullPathNoThrow(parentedFixedPart);
-            normalizedFixedPart = normalizedFixedPart.WithTrailingSlash();
-
-            return normalizedFixedPart;
+            return normalizedFixedPart.WithTrailingSlash();
         }
 
         /// <summary>
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 92d4aa212c9..69bb676cedc 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -575,8 +575,7 @@ internal static string FormatCircularDependencyError(List<string> projectsInCycl
                 if (i != 0)
                 {
                     errorMessage.Append(projectsInCycle[i])
-                        .Append(" ->")
-                        .AppendLine();
+                        .AppendLine(" ->");
                 }
                 else
                 {
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index a7f9ce4b7ae..74939362600 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -501,13 +501,13 @@ internal string ToDot(Func<ProjectGraphNode, string> nodeIdProvider)
                     node.ProjectInstance.GlobalProperties.OrderBy(kvp => kvp.Key)
                         .Select(kvp => $"{kvp.Key}={kvp.Value}"));
 
-                sb.AppendLine($"\t{nodeId} [label=<{nodeName}<br/>{globalPropertiesString}>]");
+                sb.Append('\t').Append(nodeId).Append(" [label=<").Append(nodeName).Append("<br/>").Append(globalPropertiesString).AppendLine(">]");
 
                 foreach (var reference in node.ProjectReferences)
                 {
                     var referenceId = nodeIds.GetOrAdd(reference, (n, idProvider) => idProvider(n), nodeIdProvider);
 
-                    sb.AppendLine($"\t{nodeId} -> {referenceId}");
+                    sb.Append('\t').Append(nodeId).Append(" -> ").AppendLine(referenceId);
                 }
             }
 
@@ -762,7 +762,7 @@ public bool Equals(ProjectGraphBuildRequest other)
 
             public override bool Equals(object obj)
             {
-                return !ReferenceEquals(null, obj) && obj is ProjectGraphBuildRequest graphNodeWithTargets && Equals(graphNodeWithTargets);
+                return !(obj is null) && obj is ProjectGraphBuildRequest graphNodeWithTargets && Equals(graphNodeWithTargets);
             }
 
             public override int GetHashCode()
diff --git a/src/Build/Instance/HostServices.cs b/src/Build/Instance/HostServices.cs
index 7fac009baa2..98c03f1fe7a 100644
--- a/src/Build/Instance/HostServices.cs
+++ b/src/Build/Instance/HostServices.cs
@@ -5,9 +5,7 @@
 using Microsoft.Build.Framework;
 using System.Collections.Generic;
 using System;
-using System.Collections;
 using System.Diagnostics;
-using System.Runtime.InteropServices.ComTypes;
 using System.Runtime.InteropServices;
 using System.Linq;
 using Microsoft.Build.BackEnd;
@@ -283,8 +281,7 @@ private NodeAffinity GetNodeAffinity(string projectFile, out bool isExplicit)
             // Now see if a specific affinity has been provided.
             if (_projectAffinities != null)
             {
-                NodeAffinity affinity = NodeAffinity.Any;
-
+                NodeAffinity affinity;
                 if (_projectAffinities.TryGetValue(projectFile, out affinity))
                 {
                     isExplicit = true;
diff --git a/src/Build/Instance/IRunningObjectTableWrapper.cs b/src/Build/Instance/IRunningObjectTableWrapper.cs
index 6f91a5408b6..5a3929bb13e 100644
--- a/src/Build/Instance/IRunningObjectTableWrapper.cs
+++ b/src/Build/Instance/IRunningObjectTableWrapper.cs
@@ -1,8 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-
 namespace Microsoft.Build.Execution
 {
     internal interface IRunningObjectTableWrapper
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 343a1c4988d..2f372f2bf35 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -10,7 +10,6 @@
 using System.IO;
 using System.Linq;
 using System.Runtime.CompilerServices;
-using System.Text.Json;
 using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
@@ -2215,7 +2214,7 @@ internal bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<
         {
             VerifyThrowNotImmutable();
 
-            if (null == targets)
+            if (targets == null)
             {
                 targets = Array.Empty<string>();
             }
@@ -2603,7 +2602,7 @@ private void Initialize(
             ErrorUtilities.VerifyThrowArgumentNull(buildParameters, nameof(buildParameters));
 
             _directory = xml.DirectoryPath;
-            _projectFileLocation = (xml.ProjectFileLocation != null) ? xml.ProjectFileLocation : ElementLocation.EmptyLocation;
+            _projectFileLocation = xml.ProjectFileLocation ?? ElementLocation.EmptyLocation;
             _properties = new PropertyDictionary<ProjectPropertyInstance>();
             _items = new ItemDictionary<ProjectItemInstance>();
             _actualTargets = new RetrievableEntryHashSet<ProjectTargetInstance>(StringComparer.OrdinalIgnoreCase);
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index 5b9476f71ed..7bc187939e1 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -142,7 +142,7 @@ string IKeyed.Key
         [DebuggerStepThrough]
         public ProjectMetadataInstance GetMetadata(string name)
         {
-            return (_metadata == null) ? null : _metadata[name];
+            return _metadata?[name];
         }
 
         #region IMetadataTable Members
diff --git a/src/Build/Instance/ProjectItemGroupTaskInstance.cs b/src/Build/Instance/ProjectItemGroupTaskInstance.cs
index a814b2c41c4..d22ea579d84 100644
--- a/src/Build/Instance/ProjectItemGroupTaskInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskInstance.cs
@@ -1,13 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Evaluation;
 
 using Microsoft.Build.Construction;
 
diff --git a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
index dc80b36a405..77ef8bbf6c8 100644
--- a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
@@ -1,13 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Evaluation;
 
 using Microsoft.Build.Construction;
 
diff --git a/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs b/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs
index d8b5f0de745..f414ad75367 100644
--- a/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskMetadataInstance.cs
@@ -1,13 +1,9 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
 using System.Diagnostics;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Evaluation;
 
 using Microsoft.Build.Construction;
 
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 5b660346849..d91f248d264 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -6,7 +6,6 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
-using System.Globalization;
 using System.Linq;
 using System.IO;
 
@@ -708,7 +707,7 @@ private void CommonConstructor(ProjectInstance projectToUse, string itemTypeToUs
             _taskItem = new TaskItem(
                                         includeEscaped,
                                         includeBeforeWildcardExpansionEscaped,
-                                        (directMetadata == null) ? null : directMetadata.DeepClone(), // copy on write!
+                                        directMetadata?.DeepClone(), // copy on write!
                                         inheritedItemDefinitions,
                                         _project.Directory,
                                         _project.IsImmutable,
@@ -1114,7 +1113,7 @@ internal CopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollecti
             /// <summary>
             /// This allows an explicit typecast from a "TaskItem" to a "string", returning the ItemSpec for this item.
             /// </summary>
-            public static explicit operator string (TaskItem that)
+            public static explicit operator string(TaskItem that)
             {
                 return that._includeEscaped;
             }
@@ -1127,11 +1126,11 @@ public static explicit operator string (TaskItem that)
             /// <returns>True if the items are equivalent, false otherwise.</returns>
             public static bool operator ==(TaskItem left, TaskItem right)
             {
-                if (!Object.ReferenceEquals(left, null))
+                if (!(left is null))
                 {
                     return left.Equals(right);
                 }
-                else if (!Object.ReferenceEquals(right, null))
+                else if (!(right is null))
                 {
                     return right.Equals(left);
                 }
@@ -1241,9 +1240,7 @@ public string GetMetadataEscaped(string metadataName)
                     ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
                 }
 
-                string value = null;
-                ProjectMetadataInstance metadatum = null;
-
+                ProjectMetadataInstance metadatum;
                 if (_directMetadata != null)
                 {
                     metadatum = _directMetadata[metadataName];
@@ -1255,21 +1252,19 @@ public string GetMetadataEscaped(string metadataName)
 
                 metadatum = GetItemDefinitionMetadata(metadataName);
 
-                if (null != metadatum && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
+                if (metadatum != null && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
                 {
                     Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(null, null, new BuiltInMetadataTable(null, this), FileSystems.Default);
 
                     // We don't have a location to use, but this is very unlikely to error
-                    value = expander.ExpandIntoStringLeaveEscaped(metadatum.EvaluatedValueEscaped, ExpanderOptions.ExpandBuiltInMetadata, ElementLocation.EmptyLocation);
-
-                    return value;
+                    return expander.ExpandIntoStringLeaveEscaped(metadatum.EvaluatedValueEscaped, ExpanderOptions.ExpandBuiltInMetadata, ElementLocation.EmptyLocation);
                 }
-                else if (null != metadatum)
+                else if (metadatum != null)
                 {
                     return metadatum.EvaluatedValueEscaped;
                 }
 
-                value = GetBuiltInMetadataEscaped(metadataName);
+                string value = GetBuiltInMetadataEscaped(metadataName);
 
                 return value ?? String.Empty;
             }
@@ -1495,7 +1490,7 @@ public override bool Equals(object obj)
             /// <returns>True if the items are equivalent, false otherwise.</returns>
             public bool Equals(TaskItem other)
             {
-                if (Object.ReferenceEquals(other, null))
+                if (other is null)
                 {
                     return false;
                 }
@@ -1596,16 +1591,32 @@ internal static TaskItem FactoryForDeserialization(ITranslator translator, Looka
                 return new TaskItem(translator, interner);
             }
 
+            private void WriteInternString(ITranslator translator, LookasideStringInterner interner, ref string str)
+            {
+                var key = interner.Intern(str);
+                translator.Writer.Write(key);
+            }
+            
+            private void ReadInternString(ITranslator translator, LookasideStringInterner interner, ref string str)
+            {
+                var val = translator.Reader.ReadInt32();
+                str = interner.GetString(val);
+            }
+
             /// <summary>
             /// Reads or writes the task item to the translator using an interner for metadata.
             /// </summary>
             internal void TranslateWithInterning(ITranslator translator, LookasideStringInterner interner)
             {
+                translator.Translate(ref _itemDefinitions, ProjectItemDefinitionInstance.FactoryForDeserialization);
+                translator.Translate(ref _isImmutable);
                 translator.Translate(ref _includeEscaped);
-                translator.Translate(ref _includeBeforeWildcardExpansionEscaped);
 
                 if (translator.Mode == TranslationDirection.WriteToStream)
                 {
+                    WriteInternString(translator, interner, ref _includeBeforeWildcardExpansionEscaped);
+                    WriteInternString(translator, interner, ref _definingFileEscaped);
+
                     CopyOnWritePropertyDictionary<ProjectMetadataInstance> temp = MetadataCollection;
 
                     // Intern the metadata
@@ -1624,6 +1635,8 @@ internal void TranslateWithInterning(ITranslator translator, LookasideStringInte
                 }
                 else
                 {
+                    ReadInternString(translator, interner, ref _includeBeforeWildcardExpansionEscaped);
+                    ReadInternString(translator, interner, ref _definingFileEscaped);
                     if (translator.TranslateNullable(_directMetadata))
                     {
                         int count = translator.Reader.ReadInt32();
@@ -1763,7 +1776,6 @@ private string GetBuiltInMetadataEscaped(string name)
             /// </summary>
             private ProjectMetadataInstance GetItemDefinitionMetadata(string metadataName)
             {
-                ProjectMetadataInstance metadataFromDefinition = null;
 
                 // Check any inherited item definition metadata first. It's more like
                 // direct metadata, but we didn't want to copy the tables.
@@ -1771,7 +1783,7 @@ private ProjectMetadataInstance GetItemDefinitionMetadata(string metadataName)
                 {
                     foreach (ProjectItemDefinitionInstance itemDefinition in _itemDefinitions)
                     {
-                        metadataFromDefinition = itemDefinition.GetMetadata(metadataName);
+                        ProjectMetadataInstance metadataFromDefinition = itemDefinition.GetMetadata(metadataName);
 
                         if (metadataFromDefinition != null)
                         {
diff --git a/src/Build/Instance/ProjectMetadataInstance.cs b/src/Build/Instance/ProjectMetadataInstance.cs
index a328df08dde..3e02154592c 100644
--- a/src/Build/Instance/ProjectMetadataInstance.cs
+++ b/src/Build/Instance/ProjectMetadataInstance.cs
@@ -6,8 +6,6 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Construction;
 using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.Execution
diff --git a/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs b/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs
index 63aff591bec..d899bf7eeb8 100644
--- a/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs
+++ b/src/Build/Instance/ProjectPropertyGroupTaskInstance.cs
@@ -1,13 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Evaluation;
 
 using Microsoft.Build.Construction;
 
diff --git a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
index 1a7e37876dd..33e254f876c 100644
--- a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
@@ -1,13 +1,9 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
 using System.Diagnostics;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Evaluation;
 
 using Microsoft.Build.Construction;
 
diff --git a/src/Build/Instance/ProjectTargetInstanceChild.cs b/src/Build/Instance/ProjectTargetInstanceChild.cs
index 75e91f66fe8..8c4a36af614 100644
--- a/src/Build/Instance/ProjectTargetInstanceChild.cs
+++ b/src/Build/Instance/ProjectTargetInstanceChild.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/Instance/ProjectTaskInstance.cs b/src/Build/Instance/ProjectTaskInstance.cs
index 963f55f9601..a0a02703e15 100644
--- a/src/Build/Instance/ProjectTaskInstance.cs
+++ b/src/Build/Instance/ProjectTaskInstance.cs
@@ -53,7 +53,7 @@ public sealed class ProjectTaskInstance : ProjectTargetInstanceChild, ITranslata
         /// Unordered set of task parameter names and unevaluated values.
         /// This is a dead, read-only collection.
         /// </summary>
-        private CopyOnWriteDictionary<string, (string, ElementLocation)> _parameters;
+        private CopyOnWriteDictionary<(string, ElementLocation)> _parameters;
 
         /// <summary>
         /// Output properties and items below this task. This is an ordered collection
@@ -138,7 +138,7 @@ string msbuildArchitecture
             continueOnError,
             msbuildRuntime,
             msbuildArchitecture,
-            new CopyOnWriteDictionary<string, (string, ElementLocation)>(8, StringComparer.OrdinalIgnoreCase),
+            new CopyOnWriteDictionary<(string, ElementLocation)>(8, StringComparer.OrdinalIgnoreCase),
             new List<ProjectTaskInstanceChild>(),
             location,
             condition == string.Empty ? null : ElementLocation.EmptyLocation,
@@ -155,7 +155,7 @@ internal ProjectTaskInstance
             string continueOnError,
             string msbuildRuntime,
             string msbuildArchitecture,
-            CopyOnWriteDictionary<string, (string, ElementLocation)> parameters,
+            CopyOnWriteDictionary<(string, ElementLocation)> parameters,
             List<ProjectTaskInstanceChild> outputs,
             ElementLocation location,
             ElementLocation conditionLocation,
@@ -382,11 +382,11 @@ void ITranslatable.Translate(ITranslator translator)
                 ref localParameters,
                 ParametersKeyTranslator,
                 ParametersValueTranslator,
-                count => new CopyOnWriteDictionary<string, (string, ElementLocation)>(count));
+                count => new CopyOnWriteDictionary<(string, ElementLocation)>(count));
 
             if (translator.Mode == TranslationDirection.ReadFromStream && localParameters != null)
             {
-                _parameters = (CopyOnWriteDictionary<string, (string, ElementLocation)>) localParameters;
+                _parameters = (CopyOnWriteDictionary<(string, ElementLocation)>) localParameters;
             }
         }
 
diff --git a/src/Build/Instance/ProjectTaskOutputItemInstance.cs b/src/Build/Instance/ProjectTaskOutputItemInstance.cs
index 7bbaa1fee33..c979bcbca24 100644
--- a/src/Build/Instance/ProjectTaskOutputItemInstance.cs
+++ b/src/Build/Instance/ProjectTaskOutputItemInstance.cs
@@ -1,9 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 using Microsoft.Build.Construction;
diff --git a/src/Build/Instance/ReflectableTaskPropertyInfo.cs b/src/Build/Instance/ReflectableTaskPropertyInfo.cs
index 4ffcff5b0ac..93e9594b6ed 100644
--- a/src/Build/Instance/ReflectableTaskPropertyInfo.cs
+++ b/src/Build/Instance/ReflectableTaskPropertyInfo.cs
@@ -2,10 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.Linq;
 using System.Reflection;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/Instance/RunningObjectTable.cs b/src/Build/Instance/RunningObjectTable.cs
index 1789c4ce73d..976ccde9eb0 100644
--- a/src/Build/Instance/RunningObjectTable.cs
+++ b/src/Build/Instance/RunningObjectTable.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Runtime.InteropServices;
 using System.Runtime.InteropServices.ComTypes;
 using System.Threading;
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index 14ecd85edfa..802539f6077 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -413,20 +413,11 @@ internal bool TaskNameCreatableByFactory(string taskName, IDictionary<string, st
                 return false;
             }
 
-            // Parameters match, so now we check to see if the task exists. 
-            LoadedType taskClass = null;
             try
             {
                 ErrorUtilities.VerifyThrowArgumentLength(taskName, "TaskName");
-                taskClass = _typeLoader.ReflectionOnlyLoad(taskName, _loadedType.Assembly);
-                if (taskClass != null)
-                {
-                    return true;
-                }
-                else
-                {
-                    return false;
-                }
+                // Parameters match, so now we check to see if the task exists. 
+                return _typeLoader.ReflectionOnlyLoad(taskName, _loadedType.Assembly) != null;
             }
             catch (TargetInvocationException e)
             {
@@ -477,7 +468,7 @@ private static void VerifyThrowIdentityParametersValid(IDictionary<string, strin
             // validate the task factory parameters
             if (identityParameters?.Count > 0)
             {
-                string runtime = null;
+                string runtime;
                 if (identityParameters.TryGetValue(XMakeAttributes.runtime, out runtime))
                 {
                     if (!XMakeAttributes.IsValidMSBuildRuntimeValue(runtime))
@@ -497,7 +488,7 @@ private static void VerifyThrowIdentityParametersValid(IDictionary<string, strin
                     }
                 }
 
-                string architecture = null;
+                string architecture;
                 if (identityParameters.TryGetValue(XMakeAttributes.architecture, out architecture))
                 {
                     if (!XMakeAttributes.IsValidMSBuildArchitectureValue(architecture))
@@ -531,17 +522,16 @@ private static bool TaskIdentityParametersMatchFactory(IDictionary<string, strin
                 return true;
             }
 
-            string taskRuntime = null;
-            string taskArchitecture = null;
-            string usingTaskRuntime = null;
-            string usingTaskArchitecture = null;
-
+            string taskArchitecture;
+            string taskRuntime;
             taskIdentityParameters.TryGetValue(XMakeAttributes.runtime, out taskRuntime);
+            string usingTaskRuntime;
             factoryIdentityParameters.TryGetValue(XMakeAttributes.runtime, out usingTaskRuntime);
 
             if (XMakeAttributes.RuntimeValuesMatch(taskRuntime, usingTaskRuntime))
             {
                 taskIdentityParameters.TryGetValue(XMakeAttributes.architecture, out taskArchitecture);
+                string usingTaskArchitecture;
                 factoryIdentityParameters.TryGetValue(XMakeAttributes.architecture, out usingTaskArchitecture);
 
                 if (XMakeAttributes.ArchitectureValuesMatch(taskArchitecture, usingTaskArchitecture))
@@ -562,9 +552,6 @@ private static bool TaskIdentityParametersMatchFactory(IDictionary<string, strin
         private static IDictionary<string, string> MergeTaskFactoryParameterSets(IDictionary<string, string> factoryIdentityParameters, IDictionary<string, string> taskIdentityParameters)
         {
             IDictionary<string, string> mergedParameters = null;
-            string mergedRuntime = null;
-            string mergedArchitecture = null;
-
             if (factoryIdentityParameters == null || factoryIdentityParameters.Count == 0)
             {
                 mergedParameters = new Dictionary<string, string>(taskIdentityParameters, StringComparer.OrdinalIgnoreCase);
@@ -574,6 +561,8 @@ private static IDictionary<string, string> MergeTaskFactoryParameterSets(IDictio
                 mergedParameters = new Dictionary<string, string>(factoryIdentityParameters, StringComparer.OrdinalIgnoreCase);
             }
 
+            string mergedRuntime;
+            string mergedArchitecture;
             if (mergedParameters != null)
             {
                 mergedParameters.TryGetValue(XMakeAttributes.runtime, out mergedRuntime);
@@ -584,14 +573,11 @@ private static IDictionary<string, string> MergeTaskFactoryParameterSets(IDictio
             }
             else
             {
-                string taskRuntime = null;
-                string taskArchitecture = null;
-                string usingTaskRuntime = null;
-                string usingTaskArchitecture = null;
-
                 mergedParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
+                string taskRuntime;
                 taskIdentityParameters.TryGetValue(XMakeAttributes.runtime, out taskRuntime);
+                string usingTaskRuntime;
                 factoryIdentityParameters.TryGetValue(XMakeAttributes.runtime, out usingTaskRuntime);
 
                 if (!XMakeAttributes.TryMergeRuntimeValues(taskRuntime, usingTaskRuntime, out mergedRuntime))
@@ -603,7 +589,9 @@ private static IDictionary<string, string> MergeTaskFactoryParameterSets(IDictio
                     mergedParameters.Add(XMakeAttributes.runtime, mergedRuntime);
                 }
 
+                string taskArchitecture;
                 taskIdentityParameters.TryGetValue(XMakeAttributes.architecture, out taskArchitecture);
+                string usingTaskArchitecture;
                 factoryIdentityParameters.TryGetValue(XMakeAttributes.architecture, out usingTaskArchitecture);
 
                 if (!XMakeAttributes.TryMergeArchitectureValues(taskArchitecture, usingTaskArchitecture, out mergedArchitecture))
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 68410eb19ac..07f716a438f 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -5,13 +5,10 @@
 using System.Collections.Generic;
 using System.Collections.Concurrent;
 using System.Diagnostics;
-using System.Linq;
 using System.Reflection;
 using System.Threading;
-using System.Text;
 
 using Microsoft.Build.Exceptions;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -464,7 +461,6 @@ private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplet
                 }
                 else
                 {
-                    exceptionMessage = "TaskInstantiationFailureError";
                     exceptionMessageArgs = new string[] { _taskType.Type.Name,
                         AssemblyUtilities.GetAssemblyLocation(_taskType.Type.GetTypeInfo().Assembly),
                         string.Empty };
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 01f54c607b6..ef40362e4eb 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -198,7 +198,7 @@ internal IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> TaskReg
         {
             get
             {
-                if (null == _taskRegistrations)
+                if (_taskRegistrations == null)
                 {
                     _taskRegistrations = CreateRegisteredTaskDictionary();
                 }
@@ -409,7 +409,7 @@ ElementLocation elementLocation
         )
         {
             TaskFactoryWrapper taskFactory = null;
-            bool retrievedFromCache = false;
+            bool retrievedFromCache;
 
             // If there are no usingtask tags in the project don't bother caching or looking for tasks locally
             RegisteredTaskRecord record = GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
@@ -851,7 +851,6 @@ public int GetHashCode(RegisteredTaskIdentity obj)
                     }
 
                     int nameHash = String.IsNullOrEmpty(obj.Name) ? 0 : StringComparer.OrdinalIgnoreCase.GetHashCode(obj.Name);
-                    int paramHash = 0;
 
                     // Since equality for the exact comparer depends on the exact values of the parameters, 
                     // we need our hash code to depend on them as well. However, for fuzzy matches, we just 
@@ -865,6 +864,7 @@ public int GetHashCode(RegisteredTaskIdentity obj)
                         obj.TaskIdentityParameters.TryGetValue(XMakeAttributes.architecture, out architecture);
                     }
 
+                    int paramHash;
                     if (_exactMatchRequired)
                     {
                         int runtimeHash = runtime == null ? 0 : StringComparer.OrdinalIgnoreCase.GetHashCode(runtime);
@@ -913,8 +913,7 @@ private static bool IdentityParametersMatch(IDictionary<string, string> x, IDict
                         // make sure that each parameter value matches as well 
                         foreach (KeyValuePair<string, string> param in x)
                         {
-                            string value = null;
-
+                            string value;
                             if (y.TryGetValue(param.Key, out value))
                             {
                                 if (!String.Equals(param.Value, value, StringComparison.OrdinalIgnoreCase))
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
index 22bc39ace76..264eba384ca 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
@@ -53,9 +53,7 @@ public void Replay(string sourceFilePath, CancellationToken cancellationToken)
                         return;
                     }
 
-                    BuildEventArgs instance = null;
-
-                    instance = reader.Read();
+                    BuildEventArgs instance = reader.Read();
                     if (instance == null)
                     {
                         break;
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index adbb3ba25c9..8af5b386041 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -1,12 +1,8 @@
 ﻿using System;
-using System.Diagnostics;
 using System.IO;
 using System.IO.Compression;
-using System.Linq;
-using System.Reflection;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Logging
@@ -124,7 +120,7 @@ public void Initialize(IEventSource eventSource)
 
                 if (CollectProjectImports != ProjectImportsCollectionMode.None)
                 {
-                    projectImportsCollector = new ProjectImportsCollector(FilePath);
+                    projectImportsCollector = new ProjectImportsCollector(FilePath, CollectProjectImports == ProjectImportsCollectionMode.ZipFile);
                 }
 
                 if (eventSource is IEventSource3 eventSource3)
@@ -175,20 +171,11 @@ public void Shutdown()
 
             if (projectImportsCollector != null)
             {
-                projectImportsCollector.Close();
-
                 if (CollectProjectImports == ProjectImportsCollectionMode.Embed)
                 {
-                    var archiveFilePath = projectImportsCollector.ArchiveFilePath;
-
-                    // It is possible that the archive couldn't be created for some reason.
-                    // Only embed it if it actually exists.
-                    if (FileSystems.Default.FileExists(archiveFilePath))
-                    {
-                        eventArgsWriter.WriteBlob(BinaryLogRecordKind.ProjectImportArchive, File.ReadAllBytes(archiveFilePath));
-                        File.Delete(archiveFilePath);
-                    }
+                    eventArgsWriter.WriteBlob(BinaryLogRecordKind.ProjectImportArchive, projectImportsCollector.GetAllBytes());
                 }
+                projectImportsCollector.Close();
 
                 projectImportsCollector = null;
             }
diff --git a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
index 2951f99c69d..59553953c79 100644
--- a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
+++ b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
@@ -15,10 +15,30 @@ namespace Microsoft.Build.Logging
     /// </summary>
     internal class ProjectImportsCollector
     {
-        private FileStream _fileStream;
+        private Stream _stream;
+        public byte[] GetAllBytes()
+        {
+            if (_stream == null)
+            {
+                return Array.Empty<byte>();
+            }
+            else if (ArchiveFilePath == null)
+            {
+                var stream = _stream as MemoryStream;
+                // Before we can use the zip archive, it must be closed.
+                Close(false);
+                return stream.ToArray();
+            }
+            else
+            {
+                Close();
+                return File.ReadAllBytes(ArchiveFilePath);
+            }
+        }
+
         private ZipArchive _zipArchive;
 
-        public string ArchiveFilePath { get; set; }
+        private string ArchiveFilePath { get; set; }
 
         /// <summary>
         /// Avoid visiting each file more than once.
@@ -28,29 +48,35 @@ internal class ProjectImportsCollector
         // this will form a chain of file write tasks, running sequentially on a background thread
         private Task _currentTask = Task.CompletedTask;
 
-        public ProjectImportsCollector(string logFilePath, string sourcesArchiveExtension = ".ProjectImports.zip")
+        public ProjectImportsCollector(string logFilePath, bool createFile, string sourcesArchiveExtension = ".ProjectImports.zip")
         {
-            ArchiveFilePath = Path.ChangeExtension(logFilePath, sourcesArchiveExtension);
-
             try
             {
-                _fileStream = new FileStream(ArchiveFilePath, FileMode.Create, FileAccess.ReadWrite, FileShare.Delete);
-                _zipArchive = new ZipArchive(_fileStream, ZipArchiveMode.Create);
+                if (createFile)
+                {
+                    ArchiveFilePath = Path.ChangeExtension(logFilePath, sourcesArchiveExtension);
+                    _stream = new FileStream(ArchiveFilePath, FileMode.Create, FileAccess.ReadWrite, FileShare.Delete);
+                }
+                else
+                {
+                    _stream = new MemoryStream();
+                }
+                _zipArchive = new ZipArchive(_stream, ZipArchiveMode.Create, true);
             }
             catch
             {
                 // For some reason we weren't able to create a file for the archive.
                 // Disable the file collector.
-                _fileStream = null;
+                _stream = null;
                 _zipArchive = null;
             }
         }
 
         public void AddFile(string filePath)
         {
-            if (filePath != null && _fileStream != null)
+            if (filePath != null && _stream != null)
             {
-                lock (_fileStream)
+                lock (_stream)
                 {
                     // enqueue the task to add a file and return quickly
                     // to avoid holding up the current thread
@@ -70,9 +96,9 @@ public void AddFile(string filePath)
 
         public void AddFileFromMemory(string filePath, string data)
         {
-            if (filePath != null && data != null && _fileStream != null)
+            if (filePath != null && data != null && _stream != null)
             {
-                lock (_fileStream)
+                lock (_stream)
                 {
                     // enqueue the task to add a file and return quickly
                     // to avoid holding up the current thread
@@ -169,7 +195,7 @@ private static string CalculateArchivePath(string filePath)
             return archivePath;
         }
 
-        public void Close()
+        public void Close(bool closeStream = true)
         {
             // wait for all pending file writes to complete
             _currentTask.Wait();
@@ -180,10 +206,10 @@ public void Close()
                 _zipArchive = null;
             }
 
-            if (_fileStream != null)
+            if (closeStream && (_stream != null))
             {
-                _fileStream.Dispose();
-                _fileStream = null;
+                _stream.Dispose();
+                _stream = null;
             }
         }
     }
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index b865a4764b0..3af25e3ce19 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -2,11 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Text;
-using System.Collections;
-using System.Diagnostics;
-using System.Globalization;
-using System.IO;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
diff --git a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index 0a05b230dd4..d530bd07264 100644
--- a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Text;
 using System.Collections.Generic;
 
 using Microsoft.Build.Framework;
@@ -105,9 +103,7 @@ private void ParseParameters()
         {
             if (_loggerParameters != null)
             {
-                string[] parameterComponents;
-
-                parameterComponents = _loggerParameters.Split(s_parameterDelimiters);
+                string[] parameterComponents = _loggerParameters.Split(s_parameterDelimiters);
                 for (int param = 0; param < parameterComponents.Length; param++)
                 {
                     if (parameterComponents[param].Length > 0)
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index 9fcbb94836e..c64e5f2fd85 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Text;
 using System.IO;
 
 using Microsoft.Build.Framework;
@@ -43,9 +41,7 @@ private void ParseFileLoggerParameters()
         {
             if (this.Parameters != null)
             {
-                string[] parameterComponents;
-
-                parameterComponents = this.Parameters.Split(s_fileLoggerParameterDelimiters);
+                string[] parameterComponents = this.Parameters.Split(s_fileLoggerParameterDelimiters);
                 for (int param = 0; param < parameterComponents.Length; param++)
                 {
                     if (parameterComponents[param].Length > 0)
diff --git a/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs b/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs
index 3c2a187c427..7160c103006 100644
--- a/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs
+++ b/src/Build/Logging/EvaluationLocationIdAgnosticComparer.cs
@@ -36,13 +36,13 @@ public bool Equals(EvaluationLocation x, EvaluationLocation y)
         public int GetHashCode(EvaluationLocation obj)
         {
             var hashCode = 1198539463;
-            hashCode = (hashCode * -1521134295) + obj.EvaluationPass.GetHashCode();
+            hashCode = (hashCode * -1521134295) + EqualityComparer<EvaluationPass>.Default.GetHashCode(obj.EvaluationPass);
             hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(obj.EvaluationPassDescription);
             hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(obj.File);
             hashCode = (hashCode * -1521134295) + EqualityComparer<int?>.Default.GetHashCode(obj.Line);
             hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(obj.ElementName);
             hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(obj.ElementDescription);
-            hashCode = (hashCode * -1521134295) + obj.Kind.GetHashCode();
+            hashCode = (hashCode * -1521134295) + EqualityComparer<EvaluationLocationKind>.Default.GetHashCode(obj.Kind);
             return hashCode;
         }
     }
diff --git a/src/Build/Logging/LogFormatter.cs b/src/Build/Logging/LogFormatter.cs
index bd3c78c65a8..85d9e4dc31c 100644
--- a/src/Build/Logging/LogFormatter.cs
+++ b/src/Build/Logging/LogFormatter.cs
@@ -2,13 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Diagnostics;
-using System.Text;
-using System.IO;
-using Microsoft.Build.Framework;
 using System.Globalization;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd.Logging
 {
diff --git a/src/Build/Logging/LoggerDescription.cs b/src/Build/Logging/LoggerDescription.cs
index 79e0aa1e95e..f50a53d0e68 100644
--- a/src/Build/Logging/LoggerDescription.cs
+++ b/src/Build/Logging/LoggerDescription.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Reflection;
-using System.Text;
 using System.IO;
 
 using Microsoft.Build.Framework;
diff --git a/src/Build/Logging/NullCentralLogger.cs b/src/Build/Logging/NullCentralLogger.cs
index 9e65359edac..b2101e63bc6 100644
--- a/src/Build/Logging/NullCentralLogger.cs
+++ b/src/Build/Logging/NullCentralLogger.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 63c613092ef..2a74ec78a0d 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -4,11 +4,8 @@
 using System;
 using System.Text;
 using System.Collections;
-using System.Diagnostics;
 using System.Globalization;
-using System.IO;
 using System.Collections.Generic;
-using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -530,12 +527,12 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                 {
                     DisplayDeferredProjectStartedEvent(e.BuildEventContext);
                 }
-                if (null != e.Properties)
+                if (e.Properties != null)
                 {
                     WriteProperties(e, e.Properties);
                 }
 
-                if (null != e.Items)
+                if (e.Items != null)
                 {
                     WriteItems(e, e.Items);
                 }
@@ -602,10 +599,8 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
                         // In the project finished message the targets which were built and the project which was built
                         // should be shown
                         string targets = startedEvent.TargetNames;
-
-                        string projectName = string.Empty;
-
-                        projectName = startedEvent.ProjectFile == null ? string.Empty : startedEvent.ProjectFile;
+                        string projectName = startedEvent.ProjectFile ?? string.Empty;
+                        
                         // Show which targets were built as part of this project
                         if (string.IsNullOrEmpty(targets))
                         {
@@ -1103,7 +1098,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                        && IsVerbosityAtLeast(LoggerVerbosity.Normal)
                     )
                 {
-                    List<BuildMessageEventArgs> messageList = null;
+                    List<BuildMessageEventArgs> messageList;
                     if (_deferredMessages.ContainsKey(e.BuildEventContext))
                     {
                         messageList = _deferredMessages[e.BuildEventContext];
@@ -1239,7 +1234,7 @@ private void PrintTargetNamePerMessage(BuildMessageEventArgs e, bool lightenText
                 string targetName = string.Empty;
 
                 // Does the context (Project, Node, Context, Target, NOT task) of the previous event match the current message
-                bool contextAreEqual = s_compareContextNodeIdTargetId.Equals(currentBuildEventContext, _lastDisplayedBuildEventContext == null ? null : _lastDisplayedBuildEventContext);
+                bool contextAreEqual = s_compareContextNodeIdTargetId.Equals(currentBuildEventContext, _lastDisplayedBuildEventContext);
 
                 TargetStartedEventMinimumFields targetStartedEvent = null;
                 // If the previous event does not have the same target context information, the target name needs to be printed to the console
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index 1b4f6b8111c..9e25d8e62e7 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -3,13 +3,8 @@
 
 using System;
 using System.Collections.Generic;
-using System.Collections;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using System.IO;
-using System.Diagnostics;
-using System.Threading;
 using System.Globalization;
 
 namespace Microsoft.Build.BackEnd.Logging
@@ -50,7 +45,7 @@ internal void AddProjectStartedEvent(ProjectStartedEventArgs e, bool requireTime
                 if (!_projectStartedEvents.ContainsKey(e.BuildEventContext))
                 {
                     int projectTargetKeyLocal = 1;
-                    int projectIncrementKeyLocal = 1;
+                    int projectIncrementKeyLocal;
                     // If we haven't seen this project before (by full path) then
                     // allocate a new key for it and save it away
                     if (!_projectKey.ContainsKey(e.ProjectFile))
@@ -569,7 +564,7 @@ internal class ErrorWarningSummaryDictionaryKey
         internal ErrorWarningSummaryDictionaryKey(BuildEventContext entryPoint, string targetName)
         {
             _entryPointContext = entryPoint;
-            _targetName = targetName == null ? string.Empty : targetName;
+            _targetName = targetName ?? string.Empty;
         }
         #endregion
 
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 0bd9705967d..50dd953d5e3 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -3,11 +3,7 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using System.Collections;
-using System.IO;
-using System.Globalization;
-using System.Diagnostics;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -265,13 +261,13 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
 
             if (Verbosity == LoggerVerbosity.Diagnostic && showItemAndPropertyList)
             {
-                if (null != e.Properties)
+                if (e.Properties != null)
                 {
                     var propertyList = ExtractPropertyList(e.Properties);
                     WriteProperties(propertyList);
                 }
 
-                if (null != e.Items)
+                if (e.Items != null)
                 {
                     SortedList itemList = ExtractItemList(e.Items);
                     WriteItems(itemList);
@@ -533,7 +529,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                     setColor(ConsoleColor.DarkGray);
                 }
 
-                string nonNullMessage = null;
+                string nonNullMessage;
 
                 // Include file information if present.
                 if (e.File != null)
@@ -543,7 +539,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                 else
                 {
                     // null messages are ok -- treat as blank line
-                    nonNullMessage = (e.Message == null) ? String.Empty : e.Message;
+                    nonNullMessage = e.Message ?? String.Empty;
                 }
 
                 WriteLinePretty(nonNullMessage);
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 85e42c6a9b6..491e8712871 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -55,6 +55,9 @@
   </ItemGroup>
 
   <ItemGroup>
+    <Compile Include="..\Shared\ChangeWaves.cs">
+      <Link>SharedUtilities\ChangeWaves.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\EncodingUtilities.cs">
       <Link>SharedUtilities\EncodingUtilities.cs</Link>
     </Compile>
@@ -158,6 +161,7 @@
     <Compile Include="BackEnd\Components\Caching\ConfigCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
+    <Compile Include="FileSystem\MSBuildFileSystemBase.cs" />
     <Compile Include="Utilities\NuGetFrameworkWrapper.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectUsingTaskParameterElementLink.cs" />
     <Compile Include="ObjectModelRemoting\ExternalProjectsProvider.cs" />
@@ -264,6 +268,7 @@
     <Compile Include="Evaluation\LazyItemEvaluator.ItemFactoryWrapper.cs" />
     <Compile Include="Evaluation\LazyItemEvaluator.RemoveOperation.cs" />
     <Compile Include="Evaluation\MetadataReference.cs" />
+    <Compile Include="FileSystem\MSBuildFileSystemAdapter.cs" />
     <Compile Include="Graph\ProjectGraphEntryPoint.cs" />
     <Compile Include="Graph\ProjectGraph.cs" />
     <Compile Include="Graph\ProjectGraphNode.cs" />
@@ -697,9 +702,6 @@
     <Compile Include="..\Shared\ExceptionHandling.cs">
       <Link>SharedUtilities\ExceptionHandling.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\EscapingStringExtensions\EscapingStringExtensions.cs">
-      <Link>SharedUtilities\EscapingStringExtensions\EscapingStringExtensions.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\FileMatcher.cs">
       <Link>SharedUtilities\FileMatcher.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
index ee5c1263f3a..74fac4edbe2 100644
--- a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
+++ b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
@@ -68,7 +68,7 @@ public abstract class ProjectPropertyLink
         /// </summary>
         public static string GetEvaluatedValueEscaped(ProjectProperty property)
         {
-            return property.EvaluatedValueEscapedIntenral;
+            return property.EvaluatedValueEscapedInternal;
         }
     }
 }
diff --git a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
index 98ce259b750..2312e0d8be1 100644
--- a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
+++ b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
@@ -308,7 +308,7 @@ public override string UnevaluatedValue
 
             public override bool IsImported => Link.IsImported;
 
-            internal override string EvaluatedValueEscapedIntenral => Link.EvaluatedIncludeEscaped;
+            internal override string EvaluatedValueEscapedInternal => Link.EvaluatedIncludeEscaped;
         }
         #endregion
     }
diff --git a/src/Build/Resources/Constants.cs b/src/Build/Resources/Constants.cs
index 6f2353241c9..8d03cf5a8a2 100644
--- a/src/Build/Resources/Constants.cs
+++ b/src/Build/Resources/Constants.cs
@@ -55,6 +55,7 @@ internal static class ReservedPropertyNames
         internal const string osName = "OS";
         internal const string frameworkToolsRoot = "MSBuildFrameworkToolsRoot";
         internal const string interactive = "MSBuildInteractive";
+        internal const string msbuilddisablefeaturesfromversion = "MSBuildDisableFeaturesFromVersion";
 
         /// <summary>
         /// Lookup for reserved property names. Intentionally do not include MSBuildExtensionsPath* or MSBuildUserExtensionsPath in this list.  We need tasks to be able to override those.
@@ -86,7 +87,8 @@ internal static class ReservedPropertyNames
             programFiles32,
             assemblyVersion,
             version,
-            interactive
+            interactive,
+            msbuilddisablefeaturesfromversion,
         };
 
         /// <summary>
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 113593b7d91..dca9e8d751f 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -313,6 +313,18 @@
        t2.targets and t2.targets tries to import t1.targets, then it results in a circular dependency.
     </comment>
   </data>
+  <data name="ChangeWave_InvalidFormat" xml:space="preserve">
+    <value>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</value>
+    <comment>
+       Value should be of the format: xx.yy
+    </comment>
+  </data>
+  <data name="ChangeWave_OutOfRotation" xml:space="preserve">
+    <value>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</value>
+    <comment>
+       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
+    </comment>
+  </data>
   <data name="SearchPathsForMSBuildExtensionsPath" xml:space="preserve">
     <value>Search paths being used for {0} are {1}</value>
   </data>
@@ -478,6 +490,10 @@
     <value>MSB4110: Expected a property at position {1} in condition "{0}". Did you forget the opening parenthesis after the '$'? To use a literal '$', use '%24' instead.</value>
     <comment>{StrBegin="MSB4110: "}</comment>
   </data>
+  <data name="IllFormedPropertySpaceInCondition" xml:space="preserve">
+    <value>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</value>
+    <comment>{StrBegin="MSB4259: "}</comment>
+  </data>
   <data name="IllFormedQuotedStringInCondition" xml:space="preserve">
     <value>MSB4101: Expected a closing quote after position {1} in condition "{0}".</value>
     <comment>{StrBegin="MSB4101: "}</comment>
@@ -1831,4 +1847,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="StaticGraphConstructionMetrics" xml:space="preserve">
     <value>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</value>
   </data>
-</root>
\ No newline at end of file
+  <data name="IsolatedContextDoesNotSupportFileSystem" xml:space="preserve">
+    <value>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</value>
+  </data>
+</root>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 370654db138..0ba84491cde 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -61,6 +61,20 @@
         <note>{StrBegin="MSB4248: "}UE: This message is shown when metadata cannot be expanded in an expression for some reason e.g. trying to apply
     %(RootDir) to an item-spec that's not a valid path would result in this error.
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_InvalidFormat">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
+        <target state="translated">Proměnná prostředí MSBUILDDISABLEFEATURESFROMVERSION je nastavená na neplatný formát. Povolují se všechny verze vlny změn. Zadaná hodnota: {0}</target>
+        <note>
+       Value should be of the format: xx.yy
+    </note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_OutOfRotation">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
+        <target state="translated">Proměnná prostředí MSBUILDDISABLEFEATURESFROMVERSION je nastavená na verzi, která je mimo rotaci. Nastavuje se výchozí verze vlny změn: {0}. Zadaná hodnota: {1}</target>
+        <note>
+       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
+    </note>
       </trans-unit>
       <trans-unit id="CircularDependencyInProjectGraph">
         <source>MSB4251: There is a circular dependency involving the following projects: {0}</source>
@@ -90,6 +104,11 @@
         <target state="translated">MSB4258: Při zápisu do výstupních souborů mezipaměti pro výsledky v cestě {0} byla zjištěna chyba: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="IllFormedPropertySpaceInCondition">
+        <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
+        <target state="new">MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</target>
+        <note>{StrBegin="MSB4259: "}</note>
+      </trans-unit>
       <trans-unit id="InputCacheFilesDoNotExist">
         <source>MSB4255: The following input result cache files do not exist: "{0}"</source>
         <target state="translated">MSB4255: Následující vstupní soubory mezipaměti pro výsledky neexistují: {0}</target>
@@ -100,6 +119,11 @@
         <target state="translated">Řetězec verze nemá správný formát.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="translated">Objekty EvaluationContext vytvořené pomocí SharingPolicy.Isolated nepodporují předávání souborového systému MSBuildFileSystemBase.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Podrobnost protokolování je nastavená na: {0}.</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 16260f7b5f5..180fd26527c 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -61,6 +61,20 @@
         <note>{StrBegin="MSB4248: "}UE: This message is shown when metadata cannot be expanded in an expression for some reason e.g. trying to apply
     %(RootDir) to an item-spec that's not a valid path would result in this error.
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_InvalidFormat">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
+        <target state="translated">Die Umgebungsvariable MSBUILDDISABLEFEATURESFROMVERSION ist auf ein ungültiges Format festgelegt. Alle Änderungszyklusversionen werden aktiviert. Eingegebener Wert: {0}.</target>
+        <note>
+       Value should be of the format: xx.yy
+    </note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_OutOfRotation">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
+        <target state="translated">Die Umgebungsvariable MSBUILDDISABLEFEATURESFROMVERSION ist auf eine nicht rotierende Version festgelegt und wird standardmäßig auf die Änderungszyklusversion gesetzt: {0}. Eingegebener Wert: {1}.</target>
+        <note>
+       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
+    </note>
       </trans-unit>
       <trans-unit id="CircularDependencyInProjectGraph">
         <source>MSB4251: There is a circular dependency involving the following projects: {0}</source>
@@ -90,6 +104,11 @@
         <target state="translated">MSB4258: Beim Schreiben der Cachedatei für Ausgabeergebnisse im Pfad "{0}" wurde ein Fehler festgestellt: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="IllFormedPropertySpaceInCondition">
+        <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
+        <target state="new">MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</target>
+        <note>{StrBegin="MSB4259: "}</note>
+      </trans-unit>
       <trans-unit id="InputCacheFilesDoNotExist">
         <source>MSB4255: The following input result cache files do not exist: "{0}"</source>
         <target state="translated">MSB4255: Die folgenden Cachedateien für Eingabeergebnisse sind nicht vorhanden: "{0}"</target>
@@ -100,6 +119,11 @@
         <target state="translated">Die Versionszeichenfolge liegt nicht im richtigen Format vor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="translated">"Die Übergabe eines MSBuildFileSystemBase-Dateisystems wird von EvaluationContext-Objekten, die mit SharingPolicy.Isolated erstellt wurden, nicht unterstützt."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Die Ausführlichkeit der Protokollierung ist auf "{0}" festgelegt.</target>
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index aa60e39687a..6bc335b4f99 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -61,6 +61,20 @@
         <note>{StrBegin="MSB4248: "}UE: This message is shown when metadata cannot be expanded in an expression for some reason e.g. trying to apply
     %(RootDir) to an item-spec that's not a valid path would result in this error.
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_InvalidFormat">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
+        <target state="new">Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</target>
+        <note>
+       Value should be of the format: xx.yy
+    </note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_OutOfRotation">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
+        <target state="new">Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</target>
+        <note>
+       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
+    </note>
       </trans-unit>
       <trans-unit id="CircularDependencyInProjectGraph">
         <source>MSB4251: There is a circular dependency involving the following projects: {0}</source>
@@ -90,6 +104,11 @@
         <target state="new">MSB4258: Writing output result cache file in path "{0}" encountered an error: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="IllFormedPropertySpaceInCondition">
+        <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
+        <target state="new">MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</target>
+        <note>{StrBegin="MSB4259: "}</note>
+      </trans-unit>
       <trans-unit id="InputCacheFilesDoNotExist">
         <source>MSB4255: The following input result cache files do not exist: "{0}"</source>
         <target state="new">MSB4255: The following input result cache files do not exist: "{0}"</target>
@@ -100,6 +119,11 @@
         <target state="new">Version string was not in a correct format.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="new">Logging verbosity is set to: {0}.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 0662b364837..a709c0ee4b3 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -61,6 +61,20 @@
         <note>{StrBegin="MSB4248: "}UE: This message is shown when metadata cannot be expanded in an expression for some reason e.g. trying to apply
     %(RootDir) to an item-spec that's not a valid path would result in this error.
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_InvalidFormat">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
+        <target state="translated">La variable de entorno MSBUILDDISABLEFEATURESFROMVERSION está establecida en un formato no válido. Habilitando todas las versiones de lanzamiento de cambios. Valor especificado: {0}.</target>
+        <note>
+       Value should be of the format: xx.yy
+    </note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_OutOfRotation">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
+        <target state="translated">La variable de entorno MSBUILDDISABLEFEATURESFROMVERSION está establecida en una versión no incluida en la rotación. Se va a cambiar a la versión de lanzamiento de cambios de forma predeterminada: {0}. Valor especificado: {1}.</target>
+        <note>
+       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
+    </note>
       </trans-unit>
       <trans-unit id="CircularDependencyInProjectGraph">
         <source>MSB4251: There is a circular dependency involving the following projects: {0}</source>
@@ -90,6 +104,11 @@
         <target state="translated">MSB4258: Error al escribir el archivo de caché de resultados de salida en la ruta de acceso "{0}": {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="IllFormedPropertySpaceInCondition">
+        <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
+        <target state="new">MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</target>
+        <note>{StrBegin="MSB4259: "}</note>
+      </trans-unit>
       <trans-unit id="InputCacheFilesDoNotExist">
         <source>MSB4255: The following input result cache files do not exist: "{0}"</source>
         <target state="translated">MSB4255: Los siguientes archivos de caché de resultados de entrada no existen: "{0}"</target>
@@ -100,6 +119,11 @@
         <target state="translated">La cadena de versión no tenía el formato correcto.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="translated">"Los objetos EvaluationContext creados con SharingPolicy.Isolated no admiten que se les pase un sistema de archivos MSBuildFileSystemBase".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">El nivel de detalle de registro está establecido en {0}.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 0c7c314d134..7ff10c46252 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -61,6 +61,20 @@
         <note>{StrBegin="MSB4248: "}UE: This message is shown when metadata cannot be expanded in an expression for some reason e.g. trying to apply
     %(RootDir) to an item-spec that's not a valid path would result in this error.
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_InvalidFormat">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
+        <target state="translated">La variable d'environnement MSBUILDDISABLEFEATURESFROMVERSION a un format non valide. Activation de toutes les versions des vagues de changements. Valeur entrée : {0}.</target>
+        <note>
+       Value should be of the format: xx.yy
+    </note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_OutOfRotation">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
+        <target state="translated">La variable d'environnement MSBUILDDISABLEFEATURESFROMVERSION a une valeur correspondant à une version hors rotation. Utilisation par défaut de la vague de changements version {0}. Valeur entrée : {1}.</target>
+        <note>
+       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
+    </note>
       </trans-unit>
       <trans-unit id="CircularDependencyInProjectGraph">
         <source>MSB4251: There is a circular dependency involving the following projects: {0}</source>
@@ -90,6 +104,11 @@
         <target state="translated">MSB4258: L'écriture du fichier cache des résultats de sortie dans le chemin "{0}" a rencontré une erreur : {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="IllFormedPropertySpaceInCondition">
+        <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
+        <target state="new">MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</target>
+        <note>{StrBegin="MSB4259: "}</note>
+      </trans-unit>
       <trans-unit id="InputCacheFilesDoNotExist">
         <source>MSB4255: The following input result cache files do not exist: "{0}"</source>
         <target state="translated">MSB4255: Les fichiers cache des résultats d'entrée suivants n'existent pas : "{0}"</target>
@@ -100,6 +119,11 @@
         <target state="translated">La chaîne de version n'était pas au format approprié.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="translated">"Les objets EvaluationContext créés avec SharingPolicy.Isolated ne prennent pas en charge le passage d'un système de fichiers MSBuildFileSystemBase."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">La verbosité de la journalisation a la valeur {0}.</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index bea41fb0d0e..04dd42ad112 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -61,6 +61,20 @@
         <note>{StrBegin="MSB4248: "}UE: This message is shown when metadata cannot be expanded in an expression for some reason e.g. trying to apply
     %(RootDir) to an item-spec that's not a valid path would result in this error.
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_InvalidFormat">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
+        <target state="translated">La variabile di ambiente MSBUILDDISABLEFEATURESFROMVERSION è impostata su un formato non valido. Verranno abilitate tutte le versioni con flussi di modifiche. Valore immesso: {0}.</target>
+        <note>
+       Value should be of the format: xx.yy
+    </note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_OutOfRotation">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
+        <target state="translated">La variabile di ambiente MSBUILDDISABLEFEATURESFROMVERSION è impostata su una versione esclusa dalla rotazione. Per impostazione predefinita, verrà usata la versione con flussi di modifiche: {0}. Valore immesso: {1}.</target>
+        <note>
+       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
+    </note>
       </trans-unit>
       <trans-unit id="CircularDependencyInProjectGraph">
         <source>MSB4251: There is a circular dependency involving the following projects: {0}</source>
@@ -90,6 +104,11 @@
         <target state="translated">MSB4258: durante la scrittura del file della cache dei risultati di output nel percorso "{0}" è stato rilevato un errore: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="IllFormedPropertySpaceInCondition">
+        <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
+        <target state="new">MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</target>
+        <note>{StrBegin="MSB4259: "}</note>
+      </trans-unit>
       <trans-unit id="InputCacheFilesDoNotExist">
         <source>MSB4255: The following input result cache files do not exist: "{0}"</source>
         <target state="translated">MSB4255: i file della cache dei risultati di input seguenti non esistono: "{0}"</target>
@@ -100,6 +119,11 @@
         <target state="translated">Il formato della stringa di versione non è corretto.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="translated">"Agli oggetti EvaluationContext creati con SharingPolicy.Isolated non è possibile passare un file system MSBuildFileSystemBase."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Il livello di dettaglio della registrazione è impostato su: {0}.</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index bdb2273039f..4094bff8c9c 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -61,6 +61,20 @@
         <note>{StrBegin="MSB4248: "}UE: This message is shown when metadata cannot be expanded in an expression for some reason e.g. trying to apply
     %(RootDir) to an item-spec that's not a valid path would result in this error.
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_InvalidFormat">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
+        <target state="translated">環境変数 MSBUILDDISABLEFEATURESFROMVERSION が無効な形式に設定されています。すべての Change Wave バージョンを有効にしています。入力された値: {0}。</target>
+        <note>
+       Value should be of the format: xx.yy
+    </note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_OutOfRotation">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
+        <target state="translated">環境変数 MSBUILDDISABLEFEATURESFROMVERSION が、ローテーションから外れているバージョンに設定されています。Change Wave バージョンを既定値にしています: {0}。入力された値: {1}。</target>
+        <note>
+       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
+    </note>
       </trans-unit>
       <trans-unit id="CircularDependencyInProjectGraph">
         <source>MSB4251: There is a circular dependency involving the following projects: {0}</source>
@@ -90,6 +104,11 @@
         <target state="translated">MSB4258: パス "{0}" の出力結果キャッシュ ファイルに書き込む処理でエラーが発生しました: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="IllFormedPropertySpaceInCondition">
+        <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
+        <target state="new">MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</target>
+        <note>{StrBegin="MSB4259: "}</note>
+      </trans-unit>
       <trans-unit id="InputCacheFilesDoNotExist">
         <source>MSB4255: The following input result cache files do not exist: "{0}"</source>
         <target state="translated">MSB4255: 以下の入力結果キャッシュ ファイルが存在しません: "{0}"</target>
@@ -100,6 +119,11 @@
         <target state="translated">バージョン文字列の形式が正しくありません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="translated">"SharingPolicy.Isolated を指定して作成された EvaluationContext オブジェクトに MSBuildFileSystemBase ファイル システムを渡すことはサポートされていません。"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">ログの詳細度は次のように設定されています: {0}。</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 1abe7974cd6..24d6b5e663d 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -61,6 +61,20 @@
         <note>{StrBegin="MSB4248: "}UE: This message is shown when metadata cannot be expanded in an expression for some reason e.g. trying to apply
     %(RootDir) to an item-spec that's not a valid path would result in this error.
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_InvalidFormat">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
+        <target state="translated">환경 변수 MSBUILDDISABLEFEATURESFROMVERSION이 잘못된 형식으로 설정되어 있습니다. 모든 변경 웨이브 버전을 사용하도록 설정합니다. 입력한 값: {0}.</target>
+        <note>
+       Value should be of the format: xx.yy
+    </note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_OutOfRotation">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
+        <target state="translated">환경 변수 MSBUILDDISABLEFEATURESFROMVERSION이 순환되지 않는 버전으로 설정되어 있습니다. 변경 웨이브 버전으로 기본값 설정: {0}. 입력한 값: {1}.</target>
+        <note>
+       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
+    </note>
       </trans-unit>
       <trans-unit id="CircularDependencyInProjectGraph">
         <source>MSB4251: There is a circular dependency involving the following projects: {0}</source>
@@ -90,6 +104,11 @@
         <target state="translated">MSB4258: "{0}" 경로에서 출력 결과 캐시 파일을 쓰는 중 오류가 발생했습니다. {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="IllFormedPropertySpaceInCondition">
+        <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
+        <target state="new">MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</target>
+        <note>{StrBegin="MSB4259: "}</note>
+      </trans-unit>
       <trans-unit id="InputCacheFilesDoNotExist">
         <source>MSB4255: The following input result cache files do not exist: "{0}"</source>
         <target state="translated">MSB4255: 다음 입력 결과 캐시 파일이 존재하지 않습니다. "{0}"</target>
@@ -100,6 +119,11 @@
         <target state="translated">버전 문자열의 형식이 잘못되었습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="translated">"SharingPolicy.Isolated로 만든 EvaluationContext 개체는 MSBuildFileSystemBase 파일 시스템 전달을 지원하지 않습니다."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">로깅의 세부 정보 표시가 {0}(으)로 설정되었습니다.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 5890ec6a05e..3c70b202bfb 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -61,6 +61,20 @@
         <note>{StrBegin="MSB4248: "}UE: This message is shown when metadata cannot be expanded in an expression for some reason e.g. trying to apply
     %(RootDir) to an item-spec that's not a valid path would result in this error.
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_InvalidFormat">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
+        <target state="translated">Zmienna środowiskowa MSBUILDDISABLEFEATURESFROMVERSION ma nieprawidłowy format. Zostaną włączone wszystkie wersje fali zmian. Wprowadzona wartość: {0}.</target>
+        <note>
+       Value should be of the format: xx.yy
+    </note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_OutOfRotation">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
+        <target state="translated">Zmienna środowiskowa MSBUILDDISABLEFEATURESFROMVERSION ma ustawioną wersję, która została wycofana z użycia. Domyślnie zostanie użyta fala zmian w wersji: {0}. Wprowadzona wartość: {1}.</target>
+        <note>
+       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
+    </note>
       </trans-unit>
       <trans-unit id="CircularDependencyInProjectGraph">
         <source>MSB4251: There is a circular dependency involving the following projects: {0}</source>
@@ -90,6 +104,11 @@
         <target state="translated">MSB4258: Podczas zapisywania pliku wyjściowej pamięci podręcznej wyników w ścieżce „{0}” wystąpił błąd: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="IllFormedPropertySpaceInCondition">
+        <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
+        <target state="new">MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</target>
+        <note>{StrBegin="MSB4259: "}</note>
+      </trans-unit>
       <trans-unit id="InputCacheFilesDoNotExist">
         <source>MSB4255: The following input result cache files do not exist: "{0}"</source>
         <target state="translated">MSB4255: Następujące pliki wejściowej pamięci podręcznej wyników nie istnieją: „{0}”</target>
@@ -100,6 +119,11 @@
         <target state="translated">Nieprawidłowy format ciągu wersji.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="translated">„Obiekty EvaluationContext utworzone za pomocą elementu SharingPolicy.Isolated nie obsługują przekazywania za pomocą systemu plików MSBuildFileSystemBase.”</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Szczegółowość rejestrowania została ustawiona na: {0}.</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 12ef60ca544..f08a2edb3de 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -61,6 +61,20 @@
         <note>{StrBegin="MSB4248: "}UE: This message is shown when metadata cannot be expanded in an expression for some reason e.g. trying to apply
     %(RootDir) to an item-spec that's not a valid path would result in this error.
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_InvalidFormat">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
+        <target state="translated">A variável de ambiente MSBUILDDISABLEFEATURESFROMVERSION está definida com um formato inválido. Habilitando todas as versões do ciclo de alterações. Valor inserido: {0}.</target>
+        <note>
+       Value should be of the format: xx.yy
+    </note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_OutOfRotation">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
+        <target state="translated">A variável de ambiente MSBUILDDISABLEFEATURESFROMVERSION está definida como uma versão fora de rotação. Usando como padrão a versão do Ciclo de Alterações: {0}. Valor inserido: {1}.</target>
+        <note>
+       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
+    </note>
       </trans-unit>
       <trans-unit id="CircularDependencyInProjectGraph">
         <source>MSB4251: There is a circular dependency involving the following projects: {0}</source>
@@ -90,6 +104,11 @@
         <target state="translated">MSB4258: a gravação do arquivo de cache do resultado de saída no caminho "{0}" encontrou um erro: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="IllFormedPropertySpaceInCondition">
+        <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
+        <target state="new">MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</target>
+        <note>{StrBegin="MSB4259: "}</note>
+      </trans-unit>
       <trans-unit id="InputCacheFilesDoNotExist">
         <source>MSB4255: The following input result cache files do not exist: "{0}"</source>
         <target state="translated">MSB4255: os arquivos de cache do resultado de entrada a seguir não existem: "{0}"</target>
@@ -100,6 +119,11 @@
         <target state="translated">A cadeia de caracteres de versão não estava em um formato correto.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="translated">"Os objetos EvaluationContext criados com SharingPolicy.Isolable não são compatíveis com o recebimento de um sistema de arquivos MSBuildFileSystemBase."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">O detalhamento do log está definido como: {0}.</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 62e4d151553..f86dc394210 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -61,6 +61,20 @@
         <note>{StrBegin="MSB4248: "}UE: This message is shown when metadata cannot be expanded in an expression for some reason e.g. trying to apply
     %(RootDir) to an item-spec that's not a valid path would result in this error.
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_InvalidFormat">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
+        <target state="translated">Для переменной среды MSBUILDDISABLEFEATURESFROMVERSION задан недопустимый формат. Все версии наборов рискованных изменений будут включены. Введенное значение: {0}.</target>
+        <note>
+       Value should be of the format: xx.yy
+    </note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_OutOfRotation">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
+        <target state="translated">Для переменной среды MSBUILDDISABLEFEATURESFROMVERSION задана версия, которая исключена из ротации. Будет использована версия набора рискованных изменений по умолчанию: {0}. Введенное значение: {1}.</target>
+        <note>
+       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
+    </note>
       </trans-unit>
       <trans-unit id="CircularDependencyInProjectGraph">
         <source>MSB4251: There is a circular dependency involving the following projects: {0}</source>
@@ -90,6 +104,11 @@
         <target state="translated">MSB4258: произошла ошибка при записи выходного файла кэша результатов в пути "{0}": {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="IllFormedPropertySpaceInCondition">
+        <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
+        <target state="new">MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</target>
+        <note>{StrBegin="MSB4259: "}</note>
+      </trans-unit>
       <trans-unit id="InputCacheFilesDoNotExist">
         <source>MSB4255: The following input result cache files do not exist: "{0}"</source>
         <target state="translated">MSB4255: следующие входные файлы кэша результатов не существуют: "{0}"</target>
@@ -100,6 +119,11 @@
         <target state="translated">Строка версии имела неверный формат.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="translated">"Объекты EvaluationContext, созданные с помощью SharingPolicy.Isolated, не поддерживают передачу в файловую систему MSBuildFileSystemBase."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Уровень детализации журнала: {0}.</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index bda67583870..0b05d4f062a 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -61,6 +61,20 @@
         <note>{StrBegin="MSB4248: "}UE: This message is shown when metadata cannot be expanded in an expression for some reason e.g. trying to apply
     %(RootDir) to an item-spec that's not a valid path would result in this error.
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_InvalidFormat">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
+        <target state="translated">MSBUILDDISABLEFEATURESFROMVERSION adlı ortam değişkeni geçersiz bir biçime ayarlandı. Tüm değişiklik dalgası sürümleri etkinleştiriliyor. Girilen değer: {0}.</target>
+        <note>
+       Value should be of the format: xx.yy
+    </note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_OutOfRotation">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
+        <target state="translated">MSBUILDDISABLEFEATURESFROMVERSION ortam değişkeni, dönüş dışı bir sürüme ayarlandı. Varsayılan Değişiklik Dalgası sürümüne dönülüyor: {0}. Girilen değer: {1}.</target>
+        <note>
+       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
+    </note>
       </trans-unit>
       <trans-unit id="CircularDependencyInProjectGraph">
         <source>MSB4251: There is a circular dependency involving the following projects: {0}</source>
@@ -90,6 +104,11 @@
         <target state="translated">MSB4258: Çıkış sonucu önbellek dosyası "{0}" yoluna yazılırken bir hatayla karşılaşıldı: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="IllFormedPropertySpaceInCondition">
+        <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
+        <target state="new">MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</target>
+        <note>{StrBegin="MSB4259: "}</note>
+      </trans-unit>
       <trans-unit id="InputCacheFilesDoNotExist">
         <source>MSB4255: The following input result cache files do not exist: "{0}"</source>
         <target state="translated">MSB4255: Şu giriş sonucu önbellek dosyaları mevcut değil: "{0}"</target>
@@ -100,6 +119,11 @@
         <target state="translated">Sürüm dizesi doğru biçimde değildi.</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="translated">"SharingPolicy.Isolated ile oluşturulan EvaluationContext nesneleri bir MSBuildFileSystemBase dosya sisteminin geçirilmesini desteklemez."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">Günlük kaydı ayrıntı düzeyi {0} olarak ayarlandı.</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 2c1cb8e965d..8e6abc60fe5 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -61,6 +61,20 @@
         <note>{StrBegin="MSB4248: "}UE: This message is shown when metadata cannot be expanded in an expression for some reason e.g. trying to apply
     %(RootDir) to an item-spec that's not a valid path would result in this error.
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_InvalidFormat">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
+        <target state="translated">设置的环境变量 MSBUILDDISABLEFEATURESFROMVERSION 格式无效。正在启用所有更改批次版本。输入的值: {0}。</target>
+        <note>
+       Value should be of the format: xx.yy
+    </note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_OutOfRotation">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
+        <target state="translated">设置的环境变量 MSBUILDDISABLEFEATURESFROMVERSION 版本不在轮换范围内。默认为“更改批次”版本: {0}。输入的值: {1}。</target>
+        <note>
+       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
+    </note>
       </trans-unit>
       <trans-unit id="CircularDependencyInProjectGraph">
         <source>MSB4251: There is a circular dependency involving the following projects: {0}</source>
@@ -90,6 +104,11 @@
         <target state="translated">MSB4258: 从路径“{0}”写入输出结果缓存文件时遇到错误: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="IllFormedPropertySpaceInCondition">
+        <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
+        <target state="new">MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</target>
+        <note>{StrBegin="MSB4259: "}</note>
+      </trans-unit>
       <trans-unit id="InputCacheFilesDoNotExist">
         <source>MSB4255: The following input result cache files do not exist: "{0}"</source>
         <target state="translated">MSB4255: 以下输入结果缓存文件不存在:“{0}”</target>
@@ -100,6 +119,11 @@
         <target state="translated">版本字符串的格式不正确。</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="translated">“使用 SharingPolicy.Isolated 创建的 EvaluationContext 对象不支持通过 MSBuildFileSystemBase 文件系统传递。”</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">日志记录详细程度设置为: {0}。</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 43d0c4ce594..148f027f4d5 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -61,6 +61,20 @@
         <note>{StrBegin="MSB4248: "}UE: This message is shown when metadata cannot be expanded in an expression for some reason e.g. trying to apply
     %(RootDir) to an item-spec that's not a valid path would result in this error.
     LOCALIZATION: "{1}" is a localized message explaining the problem.</note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_InvalidFormat">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}.</source>
+        <target state="translated">環境變數 MSBUILDDISABLEFEATURESFROMVERSION 設定的格式無效。正在啟用所有變更波浪版本。輸入的值: {0}。</target>
+        <note>
+       Value should be of the format: xx.yy
+    </note>
+      </trans-unit>
+      <trans-unit id="ChangeWave_OutOfRotation">
+        <source>Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}.</source>
+        <target state="translated">環境變數 MSBUILDDISABLEFEATURESFROMVERSION 已設為無法旋轉的版本。預設為變更波浪版本: {0}。輸入的值: {1}。</target>
+        <note>
+       Refer to https://github.com/dotnet/msbuild/tree/master/documentation/wiki/ChangeWaves.md to see what the current Change Waves are.
+    </note>
       </trans-unit>
       <trans-unit id="CircularDependencyInProjectGraph">
         <source>MSB4251: There is a circular dependency involving the following projects: {0}</source>
@@ -90,6 +104,11 @@
         <target state="translated">MSB4258: 在路徑 "{0}" 中寫入輸出結果快取檔案發生錯誤: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="IllFormedPropertySpaceInCondition">
+        <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
+        <target state="new">MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</target>
+        <note>{StrBegin="MSB4259: "}</note>
+      </trans-unit>
       <trans-unit id="InputCacheFilesDoNotExist">
         <source>MSB4255: The following input result cache files do not exist: "{0}"</source>
         <target state="translated">MSB4255: 下列輸入結果快取檔案不存在: "{0}"</target>
@@ -100,6 +119,11 @@
         <target state="translated">版本字串格式不正確。</target>
         <note />
       </trans-unit>
+      <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
+        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
+        <target state="translated">"使用 SharingPolicy.Isolated 建立的 EvaluationContext 物件不支援以 MSBuildFileSystemBase 檔案系統傳遞。"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
         <source>Logging verbosity is set to: {0}.</source>
         <target state="translated">記錄詳細程度設定為: {0}。</target>
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index b3c15748810..509be5de918 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Collections.Immutable;
 using System.IO;
 using System.Linq;
 using Microsoft.Build.Shared;
@@ -167,7 +166,7 @@ private string[] GetFileList
                 // Unescape before handing it to the filesystem.
                 var directoryUnescaped = EscapingUtilities.UnescapeAll(directoryEscaped);
                 var filespecUnescaped = EscapingUtilities.UnescapeAll(filespecEscaped);
-                var excludeSpecsUnescaped = excludeSpecsEscaped.Where(IsValidExclude).Select(EscapingUtilities.UnescapeAll).ToList();
+                var excludeSpecsUnescaped = excludeSpecsEscaped.Where(IsValidExclude).Select(i => EscapingUtilities.UnescapeAll(i)).ToList();
 
                 // Get the list of actual files which match the filespec.  Put
                 // the list into a string array.  If the filespec started out
diff --git a/src/Build/Utilities/FileSpecMatchTester.cs b/src/Build/Utilities/FileSpecMatchTester.cs
index 2aa18bbb14e..b98a5152ff9 100644
--- a/src/Build/Utilities/FileSpecMatchTester.cs
+++ b/src/Build/Utilities/FileSpecMatchTester.cs
@@ -2,15 +2,13 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.EscapingStringExtensions;
-using System;
 using System.Diagnostics;
 using System.IO;
 using System.Text.RegularExpressions;
 
 namespace Microsoft.Build.Internal
 {
-    internal struct FileSpecMatcherTester
+    internal readonly struct FileSpecMatcherTester
     {
         private readonly string _currentDirectory;
         private readonly string _unescapedFileSpec;
@@ -27,7 +25,7 @@ private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec,
 
         public static FileSpecMatcherTester Parse(string currentDirectory, string fileSpec)
         {
-            string unescapedFileSpec = fileSpec.Unescape();
+            string unescapedFileSpec = EscapingUtilities.UnescapeAll(fileSpec);
             Regex regex = EngineFileUtilities.FilespecHasWildcards(fileSpec) ? CreateRegex(unescapedFileSpec, currentDirectory) : null;
 
             return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, regex);
@@ -53,16 +51,11 @@ public bool IsMatch(string fileToMatch)
         // todo: glob rooting knowledge partially duplicated with MSBuildGlob.Parse and FileMatcher.ComputeFileEnumerationCacheKey
         private static Regex CreateRegex(string unescapedFileSpec, string currentDirectory)
         {
-            Regex regex = null;
-            string fixedDirPart = null;
-            string wildcardDirectoryPart = null;
-            string filenamePart = null;
-
             FileMatcher.Default.SplitFileSpec(
-                unescapedFileSpec,
-                out fixedDirPart,
-                out wildcardDirectoryPart,
-                out filenamePart);
+            unescapedFileSpec,
+            out string fixedDirPart,
+            out string wildcardDirectoryPart,
+            out string filenamePart);
 
             if (FileUtilities.PathIsInvalid(fixedDirPart))
             {
@@ -77,16 +70,13 @@ private static Regex CreateRegex(string unescapedFileSpec, string currentDirecto
 
             normalizedFixedDirPart = FileUtilities.EnsureTrailingSlash(normalizedFixedDirPart);
 
-            var recombinedFileSpec = string.Join("", normalizedFixedDirPart, wildcardDirectoryPart, filenamePart);
-
-            bool isRecursive;
-            bool isLegal;
+            var recombinedFileSpec = string.Concat(normalizedFixedDirPart, wildcardDirectoryPart, filenamePart);
 
             FileMatcher.Default.GetFileSpecInfoWithRegexObject(
                 recombinedFileSpec,
-                out regex,
-                out isRecursive,
-                out isLegal);
+                out Regex regex,
+                out bool _,
+                out bool isLegal);
 
             return isLegal ? regex : null;
         }
diff --git a/src/Build/Utilities/RegistryKeyWrapper.cs b/src/Build/Utilities/RegistryKeyWrapper.cs
index 6aefdb6e990..5db9a22e37c 100644
--- a/src/Build/Utilities/RegistryKeyWrapper.cs
+++ b/src/Build/Utilities/RegistryKeyWrapper.cs
@@ -202,7 +202,7 @@ public virtual RegistryKeyWrapper OpenSubKey(string name)
         /// <returns></returns>
         public virtual bool Exists()
         {
-            return null != WrappedKey;
+            return WrappedKey != null;
         }
 
         /// <summary>
diff --git a/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs b/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs
index feb295da600..c139c1366fd 100644
--- a/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.XmlElementChildIterator.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Xml;
 using Microsoft.Build.Construction;
 using System.Diagnostics;
diff --git a/src/Build/Xml/XmlReaderExtension.cs b/src/Build/Xml/XmlReaderExtension.cs
index 9a6b8a3898a..4bf4944e94c 100644
--- a/src/Build/Xml/XmlReaderExtension.cs
+++ b/src/Build/Xml/XmlReaderExtension.cs
@@ -1,10 +1,6 @@
 ﻿using System;
-using System.Diagnostics;
 using System.IO;
-using System.Linq;
-using System.Reflection;
 using System.Text;
-using System.Threading;
 using System.Xml;
 using Microsoft.Build.Shared;
 
@@ -79,12 +75,11 @@ private static XmlReader GetXmlReader(string file, StreamReader input, bool load
         {
             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();
 
-            XmlReader reader;
-
+            
             // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes
             // of attribute text, specifically newline removal.
             // https://github.com/Microsoft/msbuild/issues/4210
-            reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };
+            XmlReader reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };
 
             reader.Read();
             encoding = input.CurrentEncoding;
diff --git a/src/Deprecated/Conversion/AdditionalOptionsParser.cs b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
index 3bcc7bd9bf8..1695918ddb2 100644
--- a/src/Deprecated/Conversion/AdditionalOptionsParser.cs
+++ b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
@@ -208,14 +208,13 @@ ProjectPropertyGroupElement configPropertyGroup
         )
         {
             // Trivial case
-            if (null == additionalOptionsValue)
+            if (additionalOptionsValue == null)
             {
                 return;
             }
 
             // Tokenize the additional options first
-            string[] compSwitchList;
-            compSwitchList = TokenizeAdditionalOptionsValue(additionalOptionsValue);
+            string[] compSwitchList = TokenizeAdditionalOptionsValue(additionalOptionsValue);
 
             // Extract the switch arguments
             foreach (string compSwitch in compSwitchList)
@@ -301,7 +300,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
                 }
             }
             // No no... we arent dealing with the correct switchInfo
-            if (null == matchedID)
+            if (matchedID == null)
             {
                 return false;
             }
@@ -326,7 +325,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
                             switchVal = false;
                         }
                     }
-                    if (null != switchVal)
+                    if (switchVal != null)
                     {
                         compSwitchInfo.SwitchValue = switchVal;
                     }
@@ -341,7 +340,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
                     {
                         switchVal = compSwitch.Substring(matchedID.Length);
                     }
-                    if (null != switchVal)
+                    if (switchVal != null)
                     {
                         compSwitchInfo.SwitchValue = switchVal;
                     }
@@ -353,7 +352,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
 
                 case SwitchValueType.SVT_MultiString:
                     Debug.Assert(
-                        null != compSwitchInfo.SwitchValue,
+                        compSwitchInfo.SwitchValue != null,
                         "Non null switch value expected for a multistring switch: " + matchedID
                     );
 
@@ -361,7 +360,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
                     {
                         switchVal = compSwitch.Substring(matchedID.Length);
                     }
-                    if (null != switchVal)
+                    if (switchVal != null)
                     {
                         ((StringBuilder)(compSwitchInfo.SwitchValue)).Append(switchVal);
                         ((StringBuilder)(compSwitchInfo.SwitchValue)).Append(";");
@@ -399,7 +398,7 @@ private void PopulatePropertyGroup(ProjectPropertyGroupElement configPropertyGro
                 switch (compSwitchInfo.SwitchValueType)
                 {
                     case SwitchValueType.SVT_Boolean:
-                        if (null != compSwitchInfo.SwitchValue)
+                        if (compSwitchInfo.SwitchValue != null)
                         {
                             configPropertyGroup.AddProperty(
                                 propertyName,
@@ -409,7 +408,7 @@ private void PopulatePropertyGroup(ProjectPropertyGroupElement configPropertyGro
                     break;
 
                     case SwitchValueType.SVT_String:
-                        if (null != compSwitchInfo.SwitchValue)
+                        if (compSwitchInfo.SwitchValue != null)
                         {
                             configPropertyGroup.AddProperty(
                                 propertyName,
@@ -419,7 +418,7 @@ private void PopulatePropertyGroup(ProjectPropertyGroupElement configPropertyGro
                     break;
 
                     case SwitchValueType.SVT_MultiString:
-                        Debug.Assert(null != compSwitchInfo.SwitchValue, "Expected non null value for multistring switch");
+                        Debug.Assert(compSwitchInfo.SwitchValue != null, "Expected non null value for multistring switch");
                         if (0 != ((StringBuilder)(compSwitchInfo.SwitchValue)).Length)
                         {
                             configPropertyGroup.AddProperty(
diff --git a/src/Deprecated/Conversion/AssemblyInfo.cs b/src/Deprecated/Conversion/AssemblyInfo.cs
index 146f3ef3bd8..e9b874dd1c5 100644
--- a/src/Deprecated/Conversion/AssemblyInfo.cs
+++ b/src/Deprecated/Conversion/AssemblyInfo.cs
@@ -3,21 +3,19 @@
 
 using System;
 using System.Security.Permissions;
-using System.Reflection;
 using System.Resources;
 using System.Runtime.InteropServices;
 using System.Runtime.CompilerServices;
 
 #pragma warning disable 618
-[assembly: SecurityPermission (SecurityAction.RequestMinimum, Flags = SecurityPermissionFlag.Execution)]
+[assembly: SecurityPermission(SecurityAction.RequestMinimum, Flags = SecurityPermissionFlag.Execution)]
 #pragma warning restore 618
 
 // This is the assembly-level GUID, and the GUID for the TypeLib associated with
 // this assembly.  We should specify this explicitly, as opposed to letting 
 // tlbexp just pick whatever it wants.
-[assembly: GuidAttribute ("634AFA8F-4271-4e2c-9525-D0B75DAA821A")]
+[assembly: GuidAttribute("634AFA8F-4271-4e2c-9525-D0B75DAA821A")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
-[assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Whidbey.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 
 // This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly, 
 // so that we don't run into known security issues with loading libraries from unsafe locations 
diff --git a/src/Deprecated/Conversion/Constants.cs b/src/Deprecated/Conversion/Constants.cs
index caa808a7efb..a757f51f37c 100644
--- a/src/Deprecated/Conversion/Constants.cs
+++ b/src/Deprecated/Conversion/Constants.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Conversion
diff --git a/src/Deprecated/Conversion/FxCopExclusions/Microsoft.Build.Conversion.Suppressions.cs b/src/Deprecated/Conversion/FxCopExclusions/Microsoft.Build.Conversion.Suppressions.cs
index a1c52dcd4c3..6fccf7578e9 100644
--- a/src/Deprecated/Conversion/FxCopExclusions/Microsoft.Build.Conversion.Suppressions.cs
+++ b/src/Deprecated/Conversion/FxCopExclusions/Microsoft.Build.Conversion.Suppressions.cs
@@ -5,7 +5,6 @@
 // To Use:
 // Add module level suppressions to this file to have them suppressed in the assembly
 //
-using System.Diagnostics.CodeAnalysis;
 
 #if CODE_ANALYSIS
 [module: SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="0", Scope="module", Target="microsoft.build.conversion.v12.0.dll", Justification="Already shipped for several versions with a name like this")]
diff --git a/src/Deprecated/Conversion/OldVSProjectFileReader.cs b/src/Deprecated/Conversion/OldVSProjectFileReader.cs
index 7ca6b1169e9..cbfce91cf0b 100644
--- a/src/Deprecated/Conversion/OldVSProjectFileReader.cs
+++ b/src/Deprecated/Conversion/OldVSProjectFileReader.cs
@@ -5,8 +5,6 @@
 using System.IO;
 using System.Text;
 using System.Text.RegularExpressions;
-using System.Xml;
-using System.Globalization;
 
 using error = Microsoft.Build.Shared.ErrorUtilities;
 
@@ -554,9 +552,9 @@ int indexOfAmpersand
 
             StringBuilder replacedString = new StringBuilder();
 
-            replacedString.Append(originalString.Substring(0, indexOfAmpersand));
+            replacedString.Append(originalString, 0, indexOfAmpersand);
             replacedString.Append("&amp;");
-            replacedString.Append(originalString.Substring(indexOfAmpersand + 1));
+            replacedString.Append(originalString, indexOfAmpersand + 1, originalString.Length - indexOfAmpersand + 1);
 
             return replacedString.ToString();
         }
diff --git a/src/Deprecated/Conversion/ProjectFileConverter.cs b/src/Deprecated/Conversion/ProjectFileConverter.cs
index 291c7c5607a..6877edb8f72 100644
--- a/src/Deprecated/Conversion/ProjectFileConverter.cs
+++ b/src/Deprecated/Conversion/ProjectFileConverter.cs
@@ -6,10 +6,7 @@
 using System.IO;
 using System.Globalization;
 using System.Reflection;
-using System.Resources;
 using System.Xml;
-using System.Text;
-using System.Security;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
 using System.Text.RegularExpressions;
@@ -1156,7 +1153,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
             ProjectItemElement newFSharpCoreItem = null;
             string targetFSharpCoreVersionValue = null;
 
-            var hintPathValue = fsharpCoreItem != null ? fsharpCoreItem.Metadata.FirstOrDefault(metadata => metadata.Name == HintPath) : null;
+            var hintPathValue = fsharpCoreItem?.Metadata.FirstOrDefault(metadata => metadata.Name == HintPath);
             if (hintPathValue != null)
             {
                 if (equals(hintPathValue.Value, Dev11PortableFSharpCoreLocation))
@@ -2582,7 +2579,6 @@ ProjectItemGroupElement referencesItemGroup
         /// <returns></returns>
         private static ProjectItemElement ConvertClassicComReference(XmlElementWithLocation referenceElement, ProjectItemGroupElement referencesItemGroup, string referenceName)
         {
-            ProjectItemElement newReferenceItem;
             // This is a classic COM reference.
 
             // This gets added as a new XMake item of type "COMReference".
@@ -2615,8 +2611,7 @@ private static ProjectItemElement ConvertClassicComReference(XmlElementWithLocat
             referenceElement.RemoveAttribute(VSProjectAttributes.name);
 
             // Add a new item to XMake of type "COMReference".
-            newReferenceItem = referencesItemGroup.AddItem(XMakeProjectStrings.comReference, ProjectCollection.Escape(referenceName));
-            return newReferenceItem;
+            return referencesItemGroup.AddItem(XMakeProjectStrings.comReference, ProjectCollection.Escape(referenceName));
         }
 
         /// <summary>
@@ -2629,9 +2624,7 @@ private static ProjectItemElement ConvertClassicComReference(XmlElementWithLocat
         /// <returns></returns>
         private ProjectItemElement ConvertProjectToProjectReference(XmlElementWithLocation referenceElement, ProjectItemGroupElement referencesItemGroup, string referenceName, ref string referencedProjectGuid)
         {
-            ProjectItemElement newReferenceItem;
             // This is a project-to-project reference.
-
             // This gets added as a new XMake item of type "ProjectReference".
             // The "Include" attribute should be the relative path from the
             // current project to the referenced project file.  For example,
@@ -2687,9 +2680,8 @@ private ProjectItemElement ConvertProjectToProjectReference(XmlElementWithLocati
             // Add a new item to XMake of type "ProjectReference".  If we were able to find
             // the relative path to the project, use it for the "Include", otherwise just use
             // the project name.
-            string value = (pathToReferencedProject != null) ? pathToReferencedProject : referenceName;
-            newReferenceItem = referencesItemGroup.AddItem(XMakeProjectStrings.projectReference, ProjectCollection.Escape(value));
-            return newReferenceItem;
+            string value = pathToReferencedProject ?? referenceName;
+            return referencesItemGroup.AddItem(XMakeProjectStrings.projectReference, ProjectCollection.Escape(value));
         }
 
         /// <summary>
@@ -2701,7 +2693,6 @@ private ProjectItemElement ConvertProjectToProjectReference(XmlElementWithLocati
         /// <returns></returns>
         private ProjectItemElement ConvertAssemblyReference(XmlElementWithLocation referenceElement, ProjectItemGroupElement referencesItemGroup, string referenceName)
         {
-            ProjectItemElement newReferenceItem;
             // This is a regular .NET assembly reference.
 
             // This gets added as a new XMake item of type "Reference".  The "Include"
@@ -2758,8 +2749,7 @@ private ProjectItemElement ConvertAssemblyReference(XmlElementWithLocation refer
                 }
             }
 
-            newReferenceItem = referencesItemGroup.AddItem(XMakeProjectStrings.reference, ProjectCollection.Escape(assemblyName));
-            return newReferenceItem;
+            return referencesItemGroup.AddItem(XMakeProjectStrings.reference, ProjectCollection.Escape(assemblyName));
         }
 
         /// <summary>
@@ -2850,9 +2840,7 @@ internal static string RelativePathTo(string from, string to)
 
             // The URI class returns forward slashes instead of backslashes.  Replace
             // them now, and return the final path.
-            result = result.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
-
-            return result;
+            return result.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
         }
 
         /// <summary>
@@ -3345,8 +3333,7 @@ private bool IsFilePresentButEmpty(string relPath, string linkPath)
                 return false;
             }
 
-            long length = 0;
-
+            long length;
             try
             {
                 FileInfo fi = new FileInfo(path);
diff --git a/src/Deprecated/Engine/AssemblyInfo.cs b/src/Deprecated/Engine/AssemblyInfo.cs
index 6852956726b..f01f747da28 100644
--- a/src/Deprecated/Engine/AssemblyInfo.cs
+++ b/src/Deprecated/Engine/AssemblyInfo.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
 using System.Resources;
 using System.Security.Permissions;
 using System.Runtime.CompilerServices;
@@ -14,9 +13,7 @@
 [assembly: InternalsVisibleTo("Microsoft.Build.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Engine.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Framework.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
-[assembly: InternalsVisibleTo("Microsoft.Build.Engine.Whidbey.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.Cop, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
-[assembly: InternalsVisibleTo("Microsoft.Build.UnitTesting.Targets, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 
 [assembly: CLSCompliant(true)]
 
diff --git a/src/Deprecated/Engine/Caching/BuildItemCacheEntry.cs b/src/Deprecated/Engine/Caching/BuildItemCacheEntry.cs
index e113806d971..328c08e2393 100644
--- a/src/Deprecated/Engine/Caching/BuildItemCacheEntry.cs
+++ b/src/Deprecated/Engine/Caching/BuildItemCacheEntry.cs
@@ -2,14 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
-using System.Diagnostics;
 using System.Collections;
 using System.IO;
 
-using Microsoft.Build.Framework;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Caching/BuildResultCacheEntry.cs b/src/Deprecated/Engine/Caching/BuildResultCacheEntry.cs
index 21d4a041643..268d491019f 100644
--- a/src/Deprecated/Engine/Caching/BuildResultCacheEntry.cs
+++ b/src/Deprecated/Engine/Caching/BuildResultCacheEntry.cs
@@ -1,13 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using System.IO;
 
-using Microsoft.Build.Framework;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Caching/CacheEntry.cs b/src/Deprecated/Engine/Caching/CacheEntry.cs
index e773dbfa5c7..42300b27188 100644
--- a/src/Deprecated/Engine/Caching/CacheEntry.cs
+++ b/src/Deprecated/Engine/Caching/CacheEntry.cs
@@ -1,9 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using System.IO;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Caching/CacheEntryCustomSerializer.cs b/src/Deprecated/Engine/Caching/CacheEntryCustomSerializer.cs
index 8df7c4bcba8..2538722be84 100644
--- a/src/Deprecated/Engine/Caching/CacheEntryCustomSerializer.cs
+++ b/src/Deprecated/Engine/Caching/CacheEntryCustomSerializer.cs
@@ -2,11 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.IO;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Caching/PropertyCacheEntry.cs b/src/Deprecated/Engine/Caching/PropertyCacheEntry.cs
index 18c49cb8fbf..319ecfb9bb5 100644
--- a/src/Deprecated/Engine/Caching/PropertyCacheEntry.cs
+++ b/src/Deprecated/Engine/Caching/PropertyCacheEntry.cs
@@ -1,9 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using System.IO;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Choose/Choose.cs b/src/Deprecated/Engine/Choose/Choose.cs
index b26f269b905..ae079cf01bf 100644
--- a/src/Deprecated/Engine/Choose/Choose.cs
+++ b/src/Deprecated/Engine/Choose/Choose.cs
@@ -1,10 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
- using System;
 using System.Xml;
 using System.Collections;
-using System.Globalization;
 
 using Microsoft.Build.BuildEngine.Shared;
 
diff --git a/src/Deprecated/Engine/Choose/GroupEnumeratorHelper.cs b/src/Deprecated/Engine/Choose/GroupEnumeratorHelper.cs
index 535e5f5e2f3..70360f67a3d 100644
--- a/src/Deprecated/Engine/Choose/GroupEnumeratorHelper.cs
+++ b/src/Deprecated/Engine/Choose/GroupEnumeratorHelper.cs
@@ -1,13 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Data;
-using System.Xml;
 using System.Collections;
-using System.Collections.Generic;
-
-using Microsoft.Build.BuildEngine.Shared;
 
 using error = Microsoft.Build.BuildEngine.Shared.ErrorUtilities;
 
diff --git a/src/Deprecated/Engine/Choose/GroupingCollection.cs b/src/Deprecated/Engine/Choose/GroupingCollection.cs
index 5624527929b..89ebe3363b9 100644
--- a/src/Deprecated/Engine/Choose/GroupingCollection.cs
+++ b/src/Deprecated/Engine/Choose/GroupingCollection.cs
@@ -2,10 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Data;
-using System.Xml;
 using System.Collections;
-using System.Globalization;
 
 using Microsoft.Build.BuildEngine.Shared;
 
diff --git a/src/Deprecated/Engine/Choose/When.cs b/src/Deprecated/Engine/Choose/When.cs
index de9263754cc..83f85fc5505 100644
--- a/src/Deprecated/Engine/Choose/When.cs
+++ b/src/Deprecated/Engine/Choose/When.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Collections;
 using System.Xml;
-using System.IO;
-using System.Globalization;
 
 using Microsoft.Build.BuildEngine.Shared;
 
diff --git a/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs b/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
index 19e9699cb73..9ca7eca684f 100644
--- a/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
+++ b/src/Deprecated/Engine/Collections/CopyOnWriteHashtable.cs
@@ -3,10 +3,6 @@
 
 using System;
 using System.Collections;
-using System.Security.Permissions;
-using System.Diagnostics;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Collections/DualQueue.cs b/src/Deprecated/Engine/Collections/DualQueue.cs
index 4b2922481f4..37448774e8f 100644
--- a/src/Deprecated/Engine/Collections/DualQueue.cs
+++ b/src/Deprecated/Engine/Collections/DualQueue.cs
@@ -1,14 +1,9 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Threading;
-using System.Collections;
 using System.Collections.Generic;
 
-using Microsoft.Build.Framework;
-using Microsoft.Build.BuildEngine.Shared;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Collections/HashTableUtility.cs b/src/Deprecated/Engine/Collections/HashTableUtility.cs
index bc8cb392cc1..a7783f95ab3 100644
--- a/src/Deprecated/Engine/Collections/HashTableUtility.cs
+++ b/src/Deprecated/Engine/Collections/HashTableUtility.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Globalization;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/Conditionals/AndExpressionNode.cs b/src/Deprecated/Engine/Conditionals/AndExpressionNode.cs
index 09abc7b7f5a..c9b35383e35 100644
--- a/src/Deprecated/Engine/Conditionals/AndExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/AndExpressionNode.cs
@@ -1,12 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System;
-using System.Xml;
-
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Conditionals/CharacterUtilities.cs b/src/Deprecated/Engine/Conditionals/CharacterUtilities.cs
index 872e0aa59e0..6689ce4f3c3 100644
--- a/src/Deprecated/Engine/Conditionals/CharacterUtilities.cs
+++ b/src/Deprecated/Engine/Conditionals/CharacterUtilities.cs
@@ -1,9 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Text;
-
 namespace Microsoft.Build.BuildEngine
 {
     internal static class CharacterUtilities
diff --git a/src/Deprecated/Engine/Conditionals/ConditionEvaluationState.cs b/src/Deprecated/Engine/Conditionals/ConditionEvaluationState.cs
index 147acd50970..2f646f295ef 100644
--- a/src/Deprecated/Engine/Conditionals/ConditionEvaluationState.cs
+++ b/src/Deprecated/Engine/Conditionals/ConditionEvaluationState.cs
@@ -1,10 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections;
 using System.Xml;
-using System.Text;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/Conditionals/EqualExpressionNode.cs b/src/Deprecated/Engine/Conditionals/EqualExpressionNode.cs
index 72655c8b8af..d30805cb481 100644
--- a/src/Deprecated/Engine/Conditionals/EqualExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/EqualExpressionNode.cs
@@ -1,13 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
 using System;
 
-using Microsoft.Build.BuildEngine.Shared;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
index 1d284c647e0..d8fb84eae17 100644
--- a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
@@ -3,13 +3,8 @@
 
 using System.Collections;
 using System.Collections.Generic;
-using System.Globalization;
 using System.IO;
 using System;
-using System.Text;
-using System.Xml;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs b/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs
index f9348be8d67..a62a6101d19 100644
--- a/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/GenericExpressionNode.cs
@@ -1,12 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System.Xml;
-using System;
-
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Conditionals/GreaterThanExpressionNode.cs b/src/Deprecated/Engine/Conditionals/GreaterThanExpressionNode.cs
index 091f25b81c4..28f132bf6c5 100644
--- a/src/Deprecated/Engine/Conditionals/GreaterThanExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/GreaterThanExpressionNode.cs
@@ -1,13 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System;
-
-using Microsoft.Build.BuildEngine.Shared;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Conditionals/GreaterThanOrEqualExpressionNode.cs b/src/Deprecated/Engine/Conditionals/GreaterThanOrEqualExpressionNode.cs
index 69eef4a42bc..bb4590e74ed 100644
--- a/src/Deprecated/Engine/Conditionals/GreaterThanOrEqualExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/GreaterThanOrEqualExpressionNode.cs
@@ -1,13 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System;
-
-using Microsoft.Build.BuildEngine.Shared;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Conditionals/LessThanExpressionNode.cs b/src/Deprecated/Engine/Conditionals/LessThanExpressionNode.cs
index e4d8c777cc3..9b54d6840f5 100644
--- a/src/Deprecated/Engine/Conditionals/LessThanExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/LessThanExpressionNode.cs
@@ -1,13 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System;
-
-using Microsoft.Build.BuildEngine.Shared;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Conditionals/LessThanOrEqualExpressionNode.cs b/src/Deprecated/Engine/Conditionals/LessThanOrEqualExpressionNode.cs
index 13a6cb36eb6..90133e282c7 100644
--- a/src/Deprecated/Engine/Conditionals/LessThanOrEqualExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/LessThanOrEqualExpressionNode.cs
@@ -1,13 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System;
-
-using Microsoft.Build.BuildEngine.Shared;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Conditionals/MultipleComparisonExpressionNode.cs b/src/Deprecated/Engine/Conditionals/MultipleComparisonExpressionNode.cs
index abd42bb3384..3f5ee4dbc44 100644
--- a/src/Deprecated/Engine/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/MultipleComparisonExpressionNode.cs
@@ -1,12 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System;
-using System.Xml;
-
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Conditionals/NotEqualExpressionNode.cs b/src/Deprecated/Engine/Conditionals/NotEqualExpressionNode.cs
index adec7777c5d..9204d9932c9 100644
--- a/src/Deprecated/Engine/Conditionals/NotEqualExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/NotEqualExpressionNode.cs
@@ -1,13 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
 using System;
 
-using Microsoft.Build.BuildEngine.Shared;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Conditionals/NotExpressionNode.cs b/src/Deprecated/Engine/Conditionals/NotExpressionNode.cs
index c1aff8443f2..8086c4ad34b 100644
--- a/src/Deprecated/Engine/Conditionals/NotExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/NotExpressionNode.cs
@@ -1,14 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System;
-using System.Xml;
-
-using Microsoft.Build.BuildEngine.Shared;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Conditionals/NumericComparisonExpressionNode.cs b/src/Deprecated/Engine/Conditionals/NumericComparisonExpressionNode.cs
index ea56f3db77d..6333997c111 100644
--- a/src/Deprecated/Engine/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/NumericComparisonExpressionNode.cs
@@ -1,12 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System;
-using System.Xml;
-
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Conditionals/NumericExpressionNode.cs b/src/Deprecated/Engine/Conditionals/NumericExpressionNode.cs
index f62b30462f9..4bde8c03e91 100644
--- a/src/Deprecated/Engine/Conditionals/NumericExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/NumericExpressionNode.cs
@@ -1,12 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System;
-using System.Xml;
-
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Conditionals/OperandExpressionNode.cs b/src/Deprecated/Engine/Conditionals/OperandExpressionNode.cs
index e8ccd569c96..452223044c8 100644
--- a/src/Deprecated/Engine/Conditionals/OperandExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/OperandExpressionNode.cs
@@ -1,14 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System.Xml;
-using System;
-
-using Microsoft.Build.BuildEngine.Shared;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs b/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
index df182d5140b..0fa3f8ca0c2 100644
--- a/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
@@ -1,12 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System.Xml;
-using System;
-
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Conditionals/OrExpressionNode.cs b/src/Deprecated/Engine/Conditionals/OrExpressionNode.cs
index 28135f08e7e..5d564a32faa 100644
--- a/src/Deprecated/Engine/Conditionals/OrExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/OrExpressionNode.cs
@@ -1,12 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System;
-using System.Xml;
-
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Conditionals/Parser.cs b/src/Deprecated/Engine/Conditionals/Parser.cs
index f42eecf7285..e428728b559 100644
--- a/src/Deprecated/Engine/Conditionals/Parser.cs
+++ b/src/Deprecated/Engine/Conditionals/Parser.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Globalization;
 using System.Collections;
 using System.Xml;
 using System;
@@ -176,7 +175,7 @@ private GenericExpressionNode ExprPrime(string expression, GenericExpressionNode
         private GenericExpressionNode BooleanTerm(string expression)
         {
             GenericExpressionNode node = RelationalExpr(expression);
-            if (null == node)
+            if (node == null)
             {
                 errorPosition = lexer.GetErrorPosition();
                 ProjectErrorUtilities.VerifyThrowInvalidProject(false, this.conditionAttribute, "UnexpectedTokenInCondition", expression, lexer.IsNextString(), errorPosition);
@@ -198,7 +197,7 @@ private GenericExpressionNode BooleanTermPrime(string expression, GenericExpress
             else if (Same(expression, Token.TokenType.And))
             {
                 GenericExpressionNode rhs = RelationalExpr(expression);
-                if (null == rhs)
+                if (rhs == null)
                 {
                     errorPosition = lexer.GetErrorPosition();
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, this.conditionAttribute, "UnexpectedTokenInCondition", expression, lexer.IsNextString(), errorPosition);
@@ -220,7 +219,7 @@ private GenericExpressionNode RelationalExpr(string expression)
         {
          {
                 GenericExpressionNode lhs = Factor(expression);
-                if (null == lhs)
+                if (lhs == null)
                 {
                     errorPosition = lexer.GetErrorPosition();
                     ProjectErrorUtilities.VerifyThrowInvalidProject(false, this.conditionAttribute, "UnexpectedTokenInCondition", expression, lexer.IsNextString(), errorPosition);
@@ -382,7 +381,7 @@ private bool Same(string expression, Token.TokenType token)
                 if (!lexer.Advance())
                 {
                     errorPosition = lexer.GetErrorPosition();
-                    if (null != lexer.UnexpectedlyFound)
+                    if (lexer.UnexpectedlyFound != null)
                     {
                         ProjectErrorUtilities.VerifyThrowInvalidProject(false, this.conditionAttribute, lexer.GetErrorResource(), expression, errorPosition, lexer.UnexpectedlyFound);
                     }
diff --git a/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs b/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
index 14542e15990..b5493eae3b2 100644
--- a/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/StringExpressionNode.cs
@@ -1,12 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System;
-using System.Xml;
-
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Engine/BatchingEngine.cs b/src/Deprecated/Engine/Engine/BatchingEngine.cs
index f7665e917bc..f4cb0ac6e47 100644
--- a/src/Deprecated/Engine/Engine/BatchingEngine.cs
+++ b/src/Deprecated/Engine/Engine/BatchingEngine.cs
@@ -4,9 +4,6 @@
 using System;
 using System.Xml;
 using System.Collections;
-using System.Globalization;
-using System.Text;
-using System.Text.RegularExpressions;
 
 using Microsoft.Build.BuildEngine.Shared;
 using System.Collections.Generic;
@@ -337,7 +334,7 @@ Dictionary<string, MetadataReference> consumedMetadataReferences
 
                         // If we didn't find a bucket that matches this item, create a new one, adding
                         // this item to the bucket.
-                        if (null == matchingBucket)
+                        if (matchingBucket == null)
                         {
                             matchingBucket = new ItemBucket(itemListsToBeBatched.Keys, itemMetadataValues, lookup, buckets.Count);
 
diff --git a/src/Deprecated/Engine/Engine/BuildRequest.cs b/src/Deprecated/Engine/Engine/BuildRequest.cs
index c91a2a92fff..de90df06466 100644
--- a/src/Deprecated/Engine/Engine/BuildRequest.cs
+++ b/src/Deprecated/Engine/Engine/BuildRequest.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Diagnostics;
 using System.Collections;
-using System.Collections.Generic;
 using System.Text;
 using System.IO;
 
diff --git a/src/Deprecated/Engine/Engine/BuildResult.cs b/src/Deprecated/Engine/Engine/BuildResult.cs
index a76383ad0e9..05a39f10452 100644
--- a/src/Deprecated/Engine/Engine/BuildResult.cs
+++ b/src/Deprecated/Engine/Engine/BuildResult.cs
@@ -3,10 +3,7 @@
 
 using System;
 using System.Collections;
-using System.Text;
 using System.IO;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
@@ -232,7 +229,7 @@ internal int TaskTime
         internal void ConvertToTaskItems()
         {
             // If outputsByTarget was null then we dont have to re-create anything as nothing was passed over
-            if (null != outputsByTarget)
+            if (outputsByTarget != null)
             {
                 string[] keys = new string[outputsByTarget.Count];
                 outputsByTarget.Keys.CopyTo(keys, 0);
diff --git a/src/Deprecated/Engine/Engine/BuildTask.cs b/src/Deprecated/Engine/Engine/BuildTask.cs
index b7f2b14a0d4..908d29e9aad 100644
--- a/src/Deprecated/Engine/Engine/BuildTask.cs
+++ b/src/Deprecated/Engine/Engine/BuildTask.cs
@@ -3,12 +3,7 @@
 
 using System;
 using System.Xml;
-using System.Diagnostics;
 using System.Collections;
-using System.IO;
-using System.Text;
-using System.Text.RegularExpressions;
-using System.Globalization;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
@@ -365,13 +360,9 @@ string attributeName
             error.VerifyThrowInvalidOperation(this.taskElement != null,
                 "CannotUseParameters");
 
-            string attributeValue;
-
             // If this is a persisted Task, grab the attribute directly from the
             // task element.
-            attributeValue = taskElement.GetAttribute(attributeName);
-
-            return (attributeValue == null) ? String.Empty : attributeValue;
+            return taskElement.GetAttribute(attributeName) ?? string.Empty;
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Engine/CacheManager.cs b/src/Deprecated/Engine/Engine/CacheManager.cs
index 894d4a82ae8..472b3125dbb 100644
--- a/src/Deprecated/Engine/Engine/CacheManager.cs
+++ b/src/Deprecated/Engine/Engine/CacheManager.cs
@@ -4,10 +4,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Text;
-
-using Microsoft.Build.Framework;
-using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/Engine/CacheScope.cs b/src/Deprecated/Engine/Engine/CacheScope.cs
index 3dd9a9b1350..ffec30b70b4 100644
--- a/src/Deprecated/Engine/Engine/CacheScope.cs
+++ b/src/Deprecated/Engine/Engine/CacheScope.cs
@@ -3,11 +3,7 @@
 
 using System;
 using System.Collections;
-using System.Collections.Generic;
-using System.Text;
 using System.Threading;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 using System.Globalization;
 
@@ -249,11 +245,11 @@ internal void AddCacheEntryForBuildResults(BuildResult buildResult)
                     ErrorUtilities.VerifyThrow(!buildResult.EvaluationResult || (buildResult.InitialTargets != null 
                                                && buildResult.DefaultTargets != null), 
                                                "Expect initial targets to be non-null for successful builds");
-                    string defaultTargets = buildResult.DefaultTargets == null ? String.Empty : buildResult.DefaultTargets;
+                    string defaultTargets = buildResult.DefaultTargets ?? String.Empty;
                     PropertyCacheEntry defaultTargetsCacheEntry = new PropertyCacheEntry(Constants.defaultTargetCacheName, defaultTargets);
                     AddCacheEntryInternal(defaultTargetsCacheEntry);
 
-                    string initialTargets = buildResult.InitialTargets == null ? String.Empty : buildResult.InitialTargets;
+                    string initialTargets = buildResult.InitialTargets ?? String.Empty;
                     PropertyCacheEntry initialTargetsCacheEntry = new PropertyCacheEntry(Constants.initialTargetCacheName, initialTargets );
                     AddCacheEntryInternal(initialTargetsCacheEntry);
                 }
diff --git a/src/Deprecated/Engine/Engine/Engine.cs b/src/Deprecated/Engine/Engine/Engine.cs
index 8be455810e7..fa138a85c81 100644
--- a/src/Deprecated/Engine/Engine/Engine.cs
+++ b/src/Deprecated/Engine/Engine/Engine.cs
@@ -4,13 +4,10 @@
 using System;
 using System.IO;
 using System.Xml;
-using System.Security;
 using System.Diagnostics;
-using System.Resources;
 using System.Collections;
 using System.Collections.Generic;
 using System.Reflection;
-using System.Text.RegularExpressions;
 using System.Globalization;
 using System.Threading;
 
@@ -357,7 +354,7 @@ ToolsetDefinitionLocations locations
             // is null, because it is a value type
 
             this.startupDirectory = Environment.CurrentDirectory;
-            this.engineGlobalProperties = globalProperties == null ? new BuildPropertyGroup() : globalProperties;
+            this.engineGlobalProperties = globalProperties ?? new BuildPropertyGroup();
             this.environmentProperties = new BuildPropertyGroup();
             this.toolsetStateMap = new Dictionary<string, ToolsetState>(StringComparer.OrdinalIgnoreCase);
             this.toolsets = new ToolsetCollection(this);
@@ -452,7 +449,7 @@ private void InitializeLocalNodeProvider(ToolsetDefinitionLocations locations)
             {
                 LocalNodeProvider localNodeProvider = new LocalNodeProvider();
 
-                string configuration = string.Empty;
+                string configuration;
                 if (localNodeProviderParameters.EndsWith(";", StringComparison.OrdinalIgnoreCase))
                 {
                     configuration = localNodeProviderParameters + "maxcpucount=" + Convert.ToString(numberOfCpus, CultureInfo.InvariantCulture);
@@ -581,8 +578,7 @@ public static Version Version
             {
                 if (engineVersion == null)
                 {
-                    string msbuildPath = null;
-
+                    string msbuildPath;
                     try
                     {
                         // Get the file version from the currently executing assembly.
@@ -1421,8 +1417,8 @@ string newFullFileName
         {
             ErrorUtilities.VerifyThrow(project.IsLoadedByHost, "This method can only be called for projects loaded by the host.");
 
-            oldFullFileName = (oldFullFileName == null) ? String.Empty : oldFullFileName;
-            newFullFileName = (newFullFileName == null) ? String.Empty : newFullFileName;
+            oldFullFileName = oldFullFileName ?? String.Empty;
+            newFullFileName = newFullFileName ?? String.Empty;
             if (oldFullFileName == newFullFileName)
             {
                 // Nothing to do, since this really isn't a rename.
@@ -1634,7 +1630,7 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
                     (terminatingBuildRequest == null || !terminatingBuildRequest.BuildCompleted)
                   )
             {
-                int eventType = 0;
+                int eventType;
 
                 // See if we have anything to do without waiting on the handles which is expensive 
                 // for kernel mode objects.
@@ -2081,7 +2077,7 @@ private void StartRootProjectBuild(BuildRequest buildRequest, Project project)
                 // There should be no projects in the ProjectManager with the same full path, global properties and tools version
                 // as any of the loaded projects.  If there are, something went badly awry, because
                 // we were supposed to have deleted them after the last build.
-                ErrorUtilities.VerifyThrow(null == this.cacheOfBuildingProjects.GetProject(loadedProject.FullFileName, loadedProject.GlobalProperties, loadedProject.ToolsVersion),
+                ErrorUtilities.VerifyThrow(this.cacheOfBuildingProjects.GetProject(loadedProject.FullFileName, loadedProject.GlobalProperties, loadedProject.ToolsVersion) == null,
                     "Project shouldn't be in ProjectManager already.");
 
                 // Add the loaded project to the list of projects being built, just
@@ -2525,11 +2521,10 @@ BuildRequest buildRequest
                 {
                     // There's no cached result: we have to build it. Figure out which node to build it on.
                     Project matchingProjectCurrentlyLoaded = null;
-                    Project projectCurrentlyLoaded = null;
-
+                    
                     // See if we have a project loaded by the host already that matches the full path, in the
                     // list of projects which were loaded at the beginning of the build.
-                    projectCurrentlyLoaded = (Project)this.projectsLoadedByHost[projectFileInfo.FullName];
+                    Project projectCurrentlyLoaded = (Project)this.projectsLoadedByHost[projectFileInfo.FullName];
 
                     if (projectCurrentlyLoaded != null)
                     {
@@ -2548,7 +2543,7 @@ BuildRequest buildRequest
                     }
 
                     // Decide to build the project on either the current node or remote node
-                    string toolsVersionToUse = buildRequest.ToolsetVersion == null ? DefaultToolsVersion : buildRequest.ToolsetVersion;
+                    string toolsVersionToUse = buildRequest.ToolsetVersion ?? DefaultToolsVersion;
 
                     // If a matching project is currently loaded, we will build locally.
                     bool isLocal = (matchingProjectCurrentlyLoaded != null);
@@ -2790,7 +2785,7 @@ bool toolsVersionPeekedFromProjectFile
                 // Check if the project has been previously unloaded due to a user request during the current build
                 // In this case reloaded a project is an error because we can't ensure a consistent state of the reloaded project
                 // and the cached resulted of the original
-                string toolsVersionToUse = toolsVersion == null ? DefaultToolsVersion : toolsVersion;
+                string toolsVersionToUse = toolsVersion ?? DefaultToolsVersion;
                 if (this.cacheOfBuildingProjects.HasProjectBeenLoaded(projectFullPath, globalPropertiesToUse, toolsVersionToUse))
                 {
                     string joinedNames = ResourceUtilities.FormatResourceString("DefaultTargets");
diff --git a/src/Deprecated/Engine/Engine/EngineCallback.cs b/src/Deprecated/Engine/Engine/EngineCallback.cs
index 9745331612b..f63605391cc 100644
--- a/src/Deprecated/Engine/Engine/EngineCallback.cs
+++ b/src/Deprecated/Engine/Engine/EngineCallback.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Text;
-using System.Threading;
 using System.Xml;
 using System.Globalization;
 
diff --git a/src/Deprecated/Engine/Engine/EngineCommand.cs b/src/Deprecated/Engine/Engine/EngineCommand.cs
index 47df3d53ec9..64b56703376 100644
--- a/src/Deprecated/Engine/Engine/EngineCommand.cs
+++ b/src/Deprecated/Engine/Engine/EngineCommand.cs
@@ -2,11 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Collections;
-using System.Text;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
index 10109162531..c7648ee9523 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
@@ -4,8 +4,6 @@
 using System;
 using System.IO;
 using System.Collections;
-using System.Collections.Generic;
-using System.Text;
 using System.Threading;
 
 using Microsoft.Build.Framework;
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs b/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
index fbf4ed120dd..75bf624038a 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
@@ -2,17 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.IO;
-using System.Text;
 using System.Threading;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
-using error = Microsoft.Build.BuildEngine.Shared.ErrorUtilities;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
@@ -62,7 +57,7 @@ override internal bool ProcessPostedLoggingEvents()
             lastFlushTime = DateTime.Now.Ticks;
 
             // Process all the events posted with a logger Id
-            NodeLoggingEvent nodeLoggingEvent = null;
+            NodeLoggingEvent nodeLoggingEvent;
 
             // We may get a single event for multiple messages
             while ((nodeLoggingEvent = loggingQueueOfNodeEvents.Dequeue()) != null)
@@ -89,7 +84,7 @@ override internal bool ProcessPostedLoggingEvents()
             }
 
             // Process all the events in that have been already posted
-            BuildEventArgs buildEventArgs = null;
+            BuildEventArgs buildEventArgs;
 
             // We may get a single event for multiple messages
             while ((buildEventArgs = loggingQueueOfBuildEvents.Dequeue()) != null)
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs b/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs
index 358df18a978..da04f14f2d0 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServicesOutProc.cs
@@ -2,13 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Text;
 using System.Threading;
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/Engine/EngineProxy.cs b/src/Deprecated/Engine/Engine/EngineProxy.cs
index d32e8382aeb..9ce4307122e 100644
--- a/src/Deprecated/Engine/Engine/EngineProxy.cs
+++ b/src/Deprecated/Engine/Engine/EngineProxy.cs
@@ -4,12 +4,8 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Security.Permissions;
-using System.Xml;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
-using System.Globalization;
-using System.Threading;
 using System.Runtime.Remoting.Lifetime;
 using System.Runtime.Remoting;
 
diff --git a/src/Deprecated/Engine/Engine/EventRedirector.cs b/src/Deprecated/Engine/Engine/EventRedirector.cs
index 1b609016391..e54678cb3c2 100644
--- a/src/Deprecated/Engine/Engine/EventRedirector.cs
+++ b/src/Deprecated/Engine/Engine/EventRedirector.cs
@@ -1,8 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
diff --git a/src/Deprecated/Engine/Engine/ExecutionContext.cs b/src/Deprecated/Engine/Engine/ExecutionContext.cs
index 82caf10663e..d6fbbbf9a4c 100644
--- a/src/Deprecated/Engine/Engine/ExecutionContext.cs
+++ b/src/Deprecated/Engine/Engine/ExecutionContext.cs
@@ -1,12 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-
 using Microsoft.Build.Framework;
-using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/Engine/Expander.cs b/src/Deprecated/Engine/Engine/Expander.cs
index 169294a877d..2cd7ba7bcd4 100644
--- a/src/Deprecated/Engine/Engine/Expander.cs
+++ b/src/Deprecated/Engine/Engine/Expander.cs
@@ -13,7 +13,6 @@
 using System.IO;
 using System.Security;
 using System.Globalization;
-using System.Diagnostics;
 using System.Reflection;
 
 namespace Microsoft.Build.BuildEngine
@@ -464,8 +463,6 @@ XmlNode expressionNode
             // any more.
             while (propertyStartIndex != -1)
             {
-                bool tryExtractPropertyFunction = false;
-                bool tryExtractRegistryFunction = false;
 
                 // Append the targetString with the portion of the sourceString up to
                 // (but not including) the "$(", and advance the sourceIndex pointer.
@@ -473,8 +470,9 @@ XmlNode expressionNode
                 {
                     results.Add(expression.Substring(sourceIndex, propertyStartIndex - sourceIndex));
                 }
-                sourceIndex = propertyStartIndex;
 
+                bool tryExtractPropertyFunction;
+                bool tryExtractRegistryFunction;
                 // Following the "$(" we need to locate the matching ')'
                 // Scan for the matching closing bracket, skipping any nested ones
                 // This is a very complete, fast validation of parenthesis matching including for nested
@@ -655,8 +653,8 @@ private static string ConvertToString(object valueToConvert)
         /// </summary>
         private static int ScanForClosingParenthesis(string expression, int index)
         {
-            bool potentialPropertyFunction = false;
-            bool potentialRegistryFunction = false;
+            bool potentialPropertyFunction;
+            bool potentialRegistryFunction;
             return ScanForClosingParenthesis(expression, index, out potentialPropertyFunction, out potentialRegistryFunction);
         }
 
@@ -907,7 +905,7 @@ private string ExpandRegistryValue(string registryExpression, XmlNode node)
                     object valueFromRegistry = Registry.GetValue(registryKeyName,
                                                                  valueName,
                                                                  null /* default if key or value name is not found */);
-                    if (null != valueFromRegistry)
+                    if (valueFromRegistry != null)
                     {
                         // Convert the result to a string that is reasonable for MSBuild
                         result = ConvertToString(valueFromRegistry);
@@ -1042,7 +1040,7 @@ public static Function ExtractPropertyFunction(string expressionFunction, object
                 // First we'll see if there is a static function being called
                 // A static method is the content that follows the last "::", the rest being
                 // the type
-                int methodStartIndex = -1;
+                int methodStartIndex;
 
                 // This is a static method call
                 if (expressionRoot[0] == '[')
@@ -1129,8 +1127,6 @@ public static Function ExtractPropertyFunction(string expressionFunction, object
             /// </summary>
             public object Execute(Expander expander, object objectInstance, BuildPropertyGroup properties, ExpanderOptions options)
             {
-                object functionResult = String.Empty;
-
                 object[] args = null;
 
                 try
@@ -1190,7 +1186,8 @@ public object Execute(Expander expander, object objectInstance, BuildPropertyGro
                         // change the type of the final unescaped string into the destination
                         args[0] = Convert.ChangeType(args[0], objectInstance.GetType(), CultureInfo.InvariantCulture);
                     }
-                    
+
+                    object functionResult;
                     // If we've been asked for and instance to be constructed, then we
                     // need to locate an appropriate constructor and invoke it
                     if (String.Equals("new", this.name, StringComparison.OrdinalIgnoreCase))
@@ -1429,20 +1426,15 @@ private static Type GetTypeFromAssemblyUsingNamespace(string typeName)
             {
                 string baseName = typeName;
                 int assemblyNameEnd = baseName.LastIndexOf('.');
-                Type foundType = null;
-
                 ErrorUtilities.VerifyThrow(assemblyNameEnd > 0, "Invalid typename: {0}", typeName);
 
                 // We will work our way up the namespace looking for an assembly that matches
                 while (assemblyNameEnd > 0)
                 {
-                    string candidateAssemblyName = null;
-
-                    candidateAssemblyName = baseName.Substring(0, assemblyNameEnd);
+                    string candidateAssemblyName = baseName.Substring(0, assemblyNameEnd);
 
                     // Try to load the assembly with the computed name
-                    foundType = GetTypeFromAssembly(typeName, candidateAssemblyName);
-
+                    Type foundType = GetTypeFromAssembly(typeName, candidateAssemblyName);
                     if (foundType != null)
                     {
                         // We have a match, so get the type from that assembly
@@ -1525,7 +1517,6 @@ private static Function ConstructFunction(string expressionFunction, string expr
                     // It may be that there are '()' but no actual arguments content
                     if (argumentStartIndex == expressionFunction.Length - 1)
                     {
-                        argumentsContent = String.Empty;
                         functionArguments = new string[0];
                     }
                     else
@@ -1610,7 +1601,7 @@ private static string[] ExtractFunctionArguments(string expressionFunction, stri
 
                         ProjectErrorUtilities.VerifyThrowInvalidProject(n != 0, null, "InvalidFunctionPropertyExpression", expressionFunction, String.Empty);
 
-                        argumentBuilder.Append(argumentsContent.Substring(nestedPropertyStart, (n - nestedPropertyStart) + 1));
+                        argumentBuilder.Append(argumentsContent, nestedPropertyStart, (n - nestedPropertyStart) + 1);
                     }
                     else if (argumentsContent[n] == '`' || argumentsContent[n] == '"' || argumentsContent[n] == '\'')
                     {
@@ -1621,7 +1612,7 @@ private static string[] ExtractFunctionArguments(string expressionFunction, stri
 
                         ProjectErrorUtilities.VerifyThrowInvalidProject(n != 0, null, "InvalidFunctionPropertyExpression", expressionFunction, String.Empty);
 
-                        argumentBuilder.Append(argumentsContent.Substring(quoteStart, (n - quoteStart) + 1));
+                        argumentBuilder.Append(argumentsContent, quoteStart, (n - quoteStart) + 1);
                     }
                     else if (argumentsContent[n] == ',')
                     {
@@ -1783,9 +1774,6 @@ private bool IsStaticMethodAvailable(Type objectType, string methodName)
             /// </summary>
             private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object objectInstance /* null unless instance method */, object[] args, bool isConstructor)
             {
-                ParameterInfo[] parameters = null;
-                MethodBase[] members = null;
-                MethodBase memberInfo = null;
 
                 // First let's try for a method where all arguments are strings..
                 Type[] types = new Type[arguments.Length];
@@ -1794,6 +1782,7 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
                     types[n] = typeof(string);
                 }
 
+                MethodBase memberInfo;
                 if (isConstructor)
                 {
                     memberInfo = objectType.GetConstructor(bindingFlags, null, types, null);
@@ -1807,6 +1796,7 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
                 // search for a method with the right number of arguments
                 if (memberInfo == null)
                 {
+                    MethodBase[] members;
                     // Gather all methods that may match
                     if (isConstructor)
                     {
@@ -1817,22 +1807,21 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
                         members = objectType.GetMethods(bindingFlags);
                     }
 
-                    // Try to find a method with the right name, number of arguments and
-                    // compatible argument types
-                    object[] coercedArguments = null;
                     foreach (MethodBase member in members)
                     {
-                        parameters = member.GetParameters();
+                        ParameterInfo[] parameters = member.GetParameters();
 
                         // Simple match on name and number of params, we will be case insensitive
                         if (parameters.Length == this.arguments.Length)
                         {
                             if (isConstructor || String.Equals(member.Name, this.name, StringComparison.OrdinalIgnoreCase))
                             {
+                                // Try to find a method with the right name, number of arguments and
+                                // compatible argument types
                                 // we have a match on the name and argument number
                                 // now let's try to coerce the arguments we have
                                 // into the arguments on the matching method
-                                coercedArguments = CoerceArguments(args, parameters);
+                                object[] coercedArguments = CoerceArguments(args, parameters);
 
                                 if (coercedArguments != null)
                                 {
diff --git a/src/Deprecated/Engine/Engine/IEngineCallback.cs b/src/Deprecated/Engine/Engine/IEngineCallback.cs
index e1a864d72af..7b538f15464 100644
--- a/src/Deprecated/Engine/Engine/IEngineCallback.cs
+++ b/src/Deprecated/Engine/Engine/IEngineCallback.cs
@@ -2,10 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
-
-using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/Engine/IItemPropertyGrouping.cs b/src/Deprecated/Engine/Engine/IItemPropertyGrouping.cs
index 230582514df..27d940ac092 100644
--- a/src/Deprecated/Engine/Engine/IItemPropertyGrouping.cs
+++ b/src/Deprecated/Engine/Engine/IItemPropertyGrouping.cs
@@ -1,8 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Engine/INodeDescription.cs b/src/Deprecated/Engine/Engine/INodeDescription.cs
index 184fb19773c..24d190e456c 100644
--- a/src/Deprecated/Engine/Engine/INodeDescription.cs
+++ b/src/Deprecated/Engine/Engine/INodeDescription.cs
@@ -1,10 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-
 namespace Microsoft.Build.BuildEngine
 {
     internal interface INodeDescription
diff --git a/src/Deprecated/Engine/Engine/INodeProvider.cs b/src/Deprecated/Engine/Engine/INodeProvider.cs
index 8c697114e72..ae288add6b7 100644
--- a/src/Deprecated/Engine/Engine/INodeProvider.cs
+++ b/src/Deprecated/Engine/Engine/INodeProvider.cs
@@ -1,8 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Engine/ITaskRegistry.cs b/src/Deprecated/Engine/Engine/ITaskRegistry.cs
index d44da3343bf..0a7f26c1198 100644
--- a/src/Deprecated/Engine/Engine/ITaskRegistry.cs
+++ b/src/Deprecated/Engine/Engine/ITaskRegistry.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Xml;
 using Microsoft.Build.BuildEngine.Shared;
 using Microsoft.Build.Framework;
diff --git a/src/Deprecated/Engine/Engine/Import.cs b/src/Deprecated/Engine/Engine/Import.cs
index 456143d39f9..ba22f096800 100644
--- a/src/Deprecated/Engine/Engine/Import.cs
+++ b/src/Deprecated/Engine/Engine/Import.cs
@@ -1,9 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Xml;
 
 using Microsoft.Build.BuildEngine.Shared;
@@ -60,7 +57,7 @@ public string ProjectPath
         {
             get 
             { 
-                return (this.projectPathAttribute != null) ? this.projectPathAttribute.Value : null; 
+                return this.projectPathAttribute?.Value; 
             }
             set
             {
@@ -99,7 +96,7 @@ public string Condition
         {
             get 
             { 
-                return (this.conditionAttribute != null) ? this.conditionAttribute.Value : null; 
+                return this.conditionAttribute?.Value; 
             }
             set
             {
diff --git a/src/Deprecated/Engine/Engine/ImportCollection.cs b/src/Deprecated/Engine/Engine/ImportCollection.cs
index 65aca2c1ea2..e67db1d68c2 100644
--- a/src/Deprecated/Engine/Engine/ImportCollection.cs
+++ b/src/Deprecated/Engine/Engine/ImportCollection.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Collections;
-using System.Collections.Generic;
-using System.Text;
 
 using Microsoft.Build.BuildEngine.Shared;
 using System.Xml;
diff --git a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
index f5bab0f2fa2..4cc32723604 100644
--- a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
+++ b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.BuildEngine.Shared;
 using Microsoft.Win32;
 using System.IO;
diff --git a/src/Deprecated/Engine/Engine/ItemBucket.cs b/src/Deprecated/Engine/Engine/ItemBucket.cs
index e6eb052ce43..56faf58e576 100644
--- a/src/Deprecated/Engine/Engine/ItemBucket.cs
+++ b/src/Deprecated/Engine/Engine/ItemBucket.cs
@@ -2,12 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Xml;
 using System.Collections;
 using System.Collections.Generic;
-using System.Text;
-using System.Text.RegularExpressions;
-using System.Globalization;
 
 using Microsoft.Build.BuildEngine.Shared;
 
diff --git a/src/Deprecated/Engine/Engine/Node.cs b/src/Deprecated/Engine/Engine/Node.cs
index 5881de4307c..5a5ff319324 100644
--- a/src/Deprecated/Engine/Engine/Node.cs
+++ b/src/Deprecated/Engine/Engine/Node.cs
@@ -5,14 +5,10 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
-using System.Security.Permissions;
-using System.Text;
 using System.Threading;
-using System.Xml;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
-using System.Diagnostics;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
index 092f9dc3858..e13682f60aa 100644
--- a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
+++ b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.IO;
 using System.Reflection;
 using System.Runtime.Serialization.Formatters.Binary;
diff --git a/src/Deprecated/Engine/Engine/NodeManager.cs b/src/Deprecated/Engine/Engine/NodeManager.cs
index f153dc7e0cf..c963d35e73c 100644
--- a/src/Deprecated/Engine/Engine/NodeManager.cs
+++ b/src/Deprecated/Engine/Engine/NodeManager.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 using System.Threading;
 
diff --git a/src/Deprecated/Engine/Engine/NodeRequestMapping.cs b/src/Deprecated/Engine/Engine/NodeRequestMapping.cs
index e4677b33dbe..f72938b9b08 100644
--- a/src/Deprecated/Engine/Engine/NodeRequestMapping.cs
+++ b/src/Deprecated/Engine/Engine/NodeRequestMapping.cs
@@ -1,11 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Engine/Project.cs b/src/Deprecated/Engine/Engine/Project.cs
index 51fd26bc82b..fa38a06859d 100644
--- a/src/Deprecated/Engine/Engine/Project.cs
+++ b/src/Deprecated/Engine/Engine/Project.cs
@@ -3,19 +3,12 @@
 
 using System;
 using System.Xml;
-using System.Xml.Schema;
 using System.Security;
-using System.Diagnostics;
 using System.Collections;
 using System.Collections.Generic;
 using System.Collections.Specialized;
 using System.IO;
-using System.Reflection;
-using System.Security.Permissions;
-using System.Resources;
 using System.Text;
-using System.Text.RegularExpressions;
-using System.Threading;
 using System.Globalization;
 #if (!STANDALONEBUILD)
 using Microsoft.Internal.Performance;
@@ -426,7 +419,7 @@ string toolsVersion
                 // If the toolsVersion is null, we will use the value specified in
                 // the Project element's ToolsVersion attribute, or else the default if that
                 // attribute is not present.
-                if (null != toolsVersion)
+                if (toolsVersion != null)
                 {
                     this.ToolsVersion = toolsVersion;
                 }
@@ -1416,7 +1409,7 @@ public string GetEvaluatedProperty(string propertyName)
 
             // Project system needs to know the difference between a property not existing,
             // a property that is set to empty string.
-            return (property == null) ? null : property.FinalValue;
+            return property?.FinalValue;
         }
 
         /// <summary>
@@ -3414,7 +3407,7 @@ internal void CalculateNextActionForProjectContext(ProjectBuildState buildContex
                 recalculateAction = false;
 
                 // Check if there is a dependent target
-                Target currentTarget = null;
+                Target currentTarget;
                 if (buildContext.NameOfBlockingTarget != null)
                 {
                     currentTarget = GetTargetForName(buildContext.NameOfBlockingTarget);
@@ -3477,7 +3470,7 @@ internal void CalculateNextActionForProjectContext(ProjectBuildState buildContex
 
         private void ExecuteNextActionForProjectContext(ProjectBuildState buildContext, bool initialCall)
         {
-            Target nextTarget = null;
+            Target nextTarget;
             if (buildContext.NameOfBlockingTarget != null)
             {
                 // Notify the next target in depends on/on error stack
@@ -3973,7 +3966,7 @@ bool importedProject
                         case XMakeElements.projectExtensions:
                             if (!importedProject)
                             {
-                                ProjectErrorUtilities.VerifyThrowInvalidProject(null == this.projectExtensionsNode, childElement,
+                                ProjectErrorUtilities.VerifyThrowInvalidProject(this.projectExtensionsNode == null, childElement,
                                     "DuplicateProjectExtensions");
                                 this.projectExtensionsNode = childElement;
 
diff --git a/src/Deprecated/Engine/Engine/ProjectBuildState.cs b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
index 5f1aadea672..676ba8a9af5 100644
--- a/src/Deprecated/Engine/Engine/ProjectBuildState.cs
+++ b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
@@ -5,7 +5,6 @@
 using System.Diagnostics;
 using System.Collections.Generic;
 using System.Collections;
-using System.Text;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
diff --git a/src/Deprecated/Engine/Engine/ProjectManager.cs b/src/Deprecated/Engine/Engine/ProjectManager.cs
index ba497699405..8a19e03eafb 100644
--- a/src/Deprecated/Engine/Engine/ProjectManager.cs
+++ b/src/Deprecated/Engine/Engine/ProjectManager.cs
@@ -6,7 +6,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Text;
 
 using Microsoft.Build.BuildEngine.Shared;
 
diff --git a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
index 1f2265708cb..b0a635794c7 100644
--- a/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
+++ b/src/Deprecated/Engine/Engine/RegistryKeyWrapper.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Globalization;
 using System.IO;
 using System.Security;
 
@@ -179,7 +177,7 @@ public virtual RegistryKeyWrapper OpenSubKey(string name)
         /// <returns></returns>
         public virtual bool Exists()
         {
-            return null != WrappedKey;
+            return WrappedKey != null;
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Engine/RequestRoutingContext.cs b/src/Deprecated/Engine/Engine/RequestRoutingContext.cs
index 16c21dfc777..aa5287fde18 100644
--- a/src/Deprecated/Engine/Engine/RequestRoutingContext.cs
+++ b/src/Deprecated/Engine/Engine/RequestRoutingContext.cs
@@ -1,10 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
diff --git a/src/Deprecated/Engine/Engine/Router.cs b/src/Deprecated/Engine/Engine/Router.cs
index 651b7a8ed9e..52150867a2e 100644
--- a/src/Deprecated/Engine/Engine/Router.cs
+++ b/src/Deprecated/Engine/Engine/Router.cs
@@ -1,16 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Text;
-using System.Xml;
-using System.Diagnostics;
-
-using Microsoft.Build.Framework;
-using Microsoft.Build.BuildEngine.Shared;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Engine/Scheduler.cs b/src/Deprecated/Engine/Engine/Scheduler.cs
index d2a36cab2cf..110e2dbbf84 100644
--- a/src/Deprecated/Engine/Engine/Scheduler.cs
+++ b/src/Deprecated/Engine/Engine/Scheduler.cs
@@ -2,12 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Text;
-using System.Xml;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Engine/SchedulerRecord.cs b/src/Deprecated/Engine/Engine/SchedulerRecord.cs
index d0215904cf4..b97261cb00a 100644
--- a/src/Deprecated/Engine/Engine/SchedulerRecord.cs
+++ b/src/Deprecated/Engine/Engine/SchedulerRecord.cs
@@ -1,14 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using System.Diagnostics; // For the debugger attribute
-using System.Text;
-
-
-using Microsoft.Build.Framework;
-using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/Engine/Target.cs b/src/Deprecated/Engine/Engine/Target.cs
index a2d907153ba..73cd4911687 100644
--- a/src/Deprecated/Engine/Engine/Target.cs
+++ b/src/Deprecated/Engine/Engine/Target.cs
@@ -6,7 +6,6 @@
 using System.Diagnostics;       // for debugger display attribute
 using System.Collections;
 using System.Collections.Generic;
-using System.Globalization;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
@@ -698,8 +697,6 @@ internal void ContinueBuild( ProjectBuildState buildContext, TaskExecutionContex
         /// <returns>true, if successful</returns>
         internal bool ExecuteOneTask(XmlElement taskNode, ITaskHost hostObject)
         {
-            bool taskExecutedSuccessfully = false;
-
             string projectFileOfTaskNode = XmlUtilities.GetXmlNodeFile(taskNode, parentProject.FullFileName);
             BuildEventContext targetBuildEventContext = new BuildEventContext
                                 (
@@ -713,14 +710,11 @@ internal bool ExecuteOneTask(XmlElement taskNode, ITaskHost hostObject)
             TaskExecutionModule taskExecutionModule = parentEngine.NodeManager.TaskExecutionModule;
             TaskEngine taskEngine = new TaskEngine(taskNode, hostObject, parentProject.FullFileName, projectFileOfTaskNode, parentEngine.LoggingServices, handleId, taskExecutionModule, targetBuildEventContext);
 
-            taskExecutedSuccessfully =
-                taskEngine.ExecuteTask
+            return taskEngine.ExecuteTask
                 (
                     TaskExecutionMode.ExecuteTaskAndGatherOutputs,
                     new Lookup(parentProject.evaluatedItemsByName, parentProject.evaluatedProperties, ParentProject.ItemDefinitionLibrary)
                 );
-
-            return taskExecutedSuccessfully;
         }
 
         /// <summary>
@@ -750,7 +744,6 @@ internal XmlAttribute SetOrRemoveTargetAttribute
             string attributeValue
             )
         {
-            XmlAttribute updatedAttribute = null;
             // If this Target object is not actually represented by a 
             // <Target> element in the parentProject.file, then do not allow
             // the caller to set the condition.
@@ -759,7 +752,7 @@ string attributeValue
             // If this item was imported from another parentProject. we don't allow modifying it.
             error.VerifyThrowInvalidOperation(!this.importedFromAnotherProject, "CannotModifyImportedProjects");
 
-            updatedAttribute = ProjectXmlUtilities.SetOrRemoveAttribute(this.targetElement, attributeName, attributeValue);
+            XmlAttribute updatedAttribute = ProjectXmlUtilities.SetOrRemoveAttribute(targetElement, attributeName, attributeValue);
 
             // Mark the project dirty after an attribute has been updated
             this.MarkTargetAsDirty();
diff --git a/src/Deprecated/Engine/Engine/TargetCollection.cs b/src/Deprecated/Engine/Engine/TargetCollection.cs
index d7aedf2f70d..bed5d8f9b23 100644
--- a/src/Deprecated/Engine/Engine/TargetCollection.cs
+++ b/src/Deprecated/Engine/Engine/TargetCollection.cs
@@ -2,10 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Data;
 using System.Xml;
 using System.Collections;
-using System.Globalization;
 
 #if (!STANDALONEBUILD)
 using Microsoft.Internal.Performance;
diff --git a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
index 1b8deddab72..71fefcb6bb9 100644
--- a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
+++ b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
@@ -9,7 +9,6 @@
 using System.Diagnostics;
 using System.Text.RegularExpressions;
 using System.Text;
-using System.Threading;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
@@ -254,9 +253,8 @@ out Hashtable upToDateTargetInputs
                     // Log the target inputs & outputs
                     if (!loggingService.OnlyLogCriticalEvents)
                     {
-                        string inputs = null;
-                        string outputs = null;
-
+                        string inputs;
+                        string outputs;
                         // Extract the unique inputs and outputs gatheres during TLDA
                         ExtractUniqueInputsAndOutputs(out inputs, out outputs);
 
@@ -780,8 +778,7 @@ out Hashtable discreteItems
                 BuildItemGroup itemVectorContents = bucket.Expander.ExpandSingleItemListExpressionIntoItemsLeaveEscaped(item, attributeContainingItems, out itemVectorMatch);
                 if (itemVectorContents != null)
                 {
-                    Hashtable itemVectorCollection = null;
-
+                    Hashtable itemVectorCollection;
                     if ((itemVectorTransforms == null) ||
                         (itemVectorMatch.Groups["TRANSFORM_SPECIFICATION"].Length == 0))
                     {
@@ -923,7 +920,7 @@ internal static bool IsAnyOutOfDate(out DependencyAnalysisLogDetail dependencyAn
 
             string oldestOutput = EscapingUtilities.UnescapeAll((string)outputs[0]);
 
-            FileInfo oldestOutputInfo = null;
+            FileInfo oldestOutputInfo;
             try
             {
                 string oldestOutputFullPath = Path.Combine(projectDirectory, oldestOutput);
@@ -951,7 +948,7 @@ internal static bool IsAnyOutOfDate(out DependencyAnalysisLogDetail dependencyAn
             {
                 string candidateOutput = EscapingUtilities.UnescapeAll((string)outputs[i]);
 
-                FileInfo candidateOutputInfo = null;
+                FileInfo candidateOutputInfo;
                 try
                 {
                     string candidateOutputFullPath = Path.Combine(projectDirectory, candidateOutput);
@@ -1141,7 +1138,7 @@ private int CompareLastWriteTimes(string path1, string path2, out bool path1Does
             ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(path1) && !string.IsNullOrEmpty(path2),
                 "Need to specify paths to compare.");
 
-            FileInfo path1Info = null;
+            FileInfo path1Info;
             try
             {
                 path1 = Path.Combine(projectDirectory, path1);
@@ -1156,7 +1153,7 @@ private int CompareLastWriteTimes(string path1, string path2, out bool path1Does
                 path1Info = null;
             }
 
-            FileInfo path2Info = null;
+            FileInfo path2Info;
             try
             {
                 path2 = Path.Combine(projectDirectory, path2);
diff --git a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
index bbe2920c9ea..937cd28b801 100644
--- a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
+++ b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
@@ -533,9 +533,6 @@ private void InitializeForRunningSingleTargetBatch()
             ErrorUtilities.VerifyThrow(inProgressBuildState == InProgressBuildState.RunningTasks, "Wrong state");
             // Check if the current task number is valid
             ErrorUtilities.VerifyThrow(currentBucket < buckets.Count, "No buckets left");
-
-            Hashtable changedTargetInputs = null;
-            Hashtable upToDateTargetInputs = null;
             howToBuild = DependencyAnalysisResult.FullBuild;
             ItemBucket bucket = (ItemBucket)buckets[currentBucket];
 
@@ -555,6 +552,9 @@ private void InitializeForRunningSingleTargetBatch()
 
             // Figure out how we should build the target
             TargetDependencyAnalyzer dependencyAnalyzer = new TargetDependencyAnalyzer(parentProject.ProjectDirectory, targetClass, parentEngine.LoggingServices, targetBuildEventContext);
+
+            Hashtable changedTargetInputs;
+            Hashtable upToDateTargetInputs;
             howToBuild = dependencyAnalyzer.PerformDependencyAnalysis(bucket, out changedTargetInputs, out upToDateTargetInputs);
 
             targetBuildSuccessful = true;
diff --git a/src/Deprecated/Engine/Engine/TaskEngine.cs b/src/Deprecated/Engine/Engine/TaskEngine.cs
index 17bf6ea3be6..5f0e47a7c76 100644
--- a/src/Deprecated/Engine/Engine/TaskEngine.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngine.cs
@@ -2,19 +2,16 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 using System.Xml;
 using System.Text;
 using System.Reflection;
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Text.RegularExpressions;
 using System.Globalization;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
-using System.Runtime.Remoting;
 
 namespace Microsoft.Build.BuildEngine
 {
@@ -203,7 +200,7 @@ private AppDomain PrepareAppDomain()
             // here. Instead, NDP will try to Load (not LoadFrom!) the task assembly into our AppDomain, and since
             // we originally used LoadFrom, it will fail miserably not knowing where to find it.
             // We need to temporarily subscribe to the AppDomain.AssemblyResolve event to fix it.
-            if (null == resolver)
+            if (resolver == null)
             {
                 resolver = new TaskEngineAssemblyResolver();
                 resolver.Initialize(TaskClass.Assembly.AssemblyFile);
@@ -416,13 +413,9 @@ private bool ExecuteBucket(EngineProxy engineProxy, ItemBucket bucket, int bucke
                         parentProjectFullFileName,
                         projectFileOfTaskNode,
                         taskResult);
-
-                    task = null;
-
                     if (taskAppDomain != null)
                     {
                         AppDomain.Unload(taskAppDomain);
-                        taskAppDomain = null;
                     }
                 }
             }
@@ -503,9 +496,8 @@ private ITask InstantiateTask(AppDomain taskAppDomain)
 
                     task = (ITask)taskAppDomain.CreateInstanceFromAndUnwrap(TaskClass.Assembly.AssemblyFile, TaskClass.Type.FullName);
 
-                    Type taskType = null;
-                    // this will force evaluation of the task class type and try to load the task assembly
-                    taskType = task.GetType();
+                                        // this will force evaluation of the task class type and try to load the task assembly
+                    Type taskType = task.GetType();
 
                     // If the types don't match, we have a problem. It means that our AppDomain was able to load
                     // a task assembly using Load, and loaded a different one. I don't see any other choice than
@@ -1586,8 +1578,8 @@ object parameterValue
         /// </summary>
         private BuildEventFileInfo CreateBuildEventFileInfoForTask()
         {
-            int lineNumber = 0;
-            int columnNumber = 0;
+            int lineNumber;
+            int columnNumber;
             parentModule.GetLineColumnOfXmlNode(handleId, out lineNumber, out columnNumber);
             return new BuildEventFileInfo(projectFileOfTaskNode, lineNumber, columnNumber);
         }
diff --git a/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs b/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs
index 1f014fc5526..297ecefa3ea 100644
--- a/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs
@@ -5,8 +5,6 @@
 using System.IO;
 using System.Reflection;
 using System.Diagnostics;
-using System.Globalization;
-using System.Security.Permissions;
 
 using Microsoft.Build.BuildEngine.Shared;
 
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionContext.cs b/src/Deprecated/Engine/Engine/TaskExecutionContext.cs
index 4962df3ab57..9851e8c6df9 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionContext.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionContext.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Xml;
 
 using Microsoft.Build.Framework;
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
index 2cd991a8f43..54915eebb4d 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
@@ -203,8 +203,7 @@ BuildEventContext taskContext
                 bool remoteNode = false;
                 for (int r = 0; r < projectFileNames.Length; r++)
                 {
-                    string fullProjectName = projectFileNames[r] != null ?
-                       projectFileNames[r] : "null";
+                    string fullProjectName = projectFileNames[r] ?? "null";
                     Console.WriteLine("RemoteNode: " + remoteNode + " Project " + fullProjectName + " T:" + targetName + " NodeProdyId# " + handleId + " Time " + DateTime.Now.ToLongTimeString());
                     if (globalPropertiesPerProject[r] != null)
                     {
@@ -318,7 +317,6 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
             else
             {
                 int currentRequestIndex = 0; // Which build request is being processed
-                int numberOfRequestsToSend = 0; // How many buildRequests are going to be sent based on the number of buildRequests remaining and the build request batch size.
 
                 // Arrays that will be used to partion the buildRequests array when sending batches of builds requests at a time.
                 BuildRequest[] wrapperArrayBreadthFirst = new BuildRequest[batchRequestSize];
@@ -335,7 +333,7 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
                     if (breadthFirstTraversal)
                     {
                         // Figure out how many requests to send, either the full batch size or only part of a batch
-                        numberOfRequestsToSend = (buildRequests.Length - currentRequestIndex) <batchRequestSize ? (buildRequests.Length - currentRequestIndex) : batchRequestSize;
+                        int numberOfRequestsToSend = (buildRequests.Length - currentRequestIndex) < batchRequestSize ? (buildRequests.Length - currentRequestIndex) : batchRequestSize;
 
                         // Initialize the wrapper array to how many requests are going to be sent
                         if (numberOfRequestsToSend != wrapperArrayBreadthFirst.Length)
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionState.cs b/src/Deprecated/Engine/Engine/TaskExecutionState.cs
index 63920dac6c3..4ed1e6d3854 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionState.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionState.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Collections.Generic;
 using System.IO;
 using System.Text;
 using System.Xml;
@@ -158,14 +156,10 @@ virtual internal void ExecuteTask()
                 // been built by the task
                 if ((howToExecuteTask & TaskExecutionMode.InferOutputsOnly) != TaskExecutionMode.Invalid)
                 {
-                    bool targetInferenceSuccessful = false;
-
-                    targetInferenceSuccessful =
-                       TaskEngineExecuteTask
-                        (   taskEngine,
-                            TaskExecutionMode.InferOutputsOnly,
-                            lookupForInference
-                        );
+                    bool targetInferenceSuccessful = TaskEngineExecuteTask
+                        (taskEngine,
+                         TaskExecutionMode.InferOutputsOnly,
+                         lookupForInference);
 
                     ErrorUtilities.VerifyThrow(targetInferenceSuccessful, "A task engine should never fail to infer its task's up-to-date outputs.");
                 }
diff --git a/src/Deprecated/Engine/Engine/TaskOutput.cs b/src/Deprecated/Engine/Engine/TaskOutput.cs
index 3989f6c560d..472c259da4f 100644
--- a/src/Deprecated/Engine/Engine/TaskOutput.cs
+++ b/src/Deprecated/Engine/Engine/TaskOutput.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Xml;
 
 using Microsoft.Build.BuildEngine.Shared;
diff --git a/src/Deprecated/Engine/Engine/TaskRegistry.cs b/src/Deprecated/Engine/Engine/TaskRegistry.cs
index 47758b2a47e..b1c83181b4b 100644
--- a/src/Deprecated/Engine/Engine/TaskRegistry.cs
+++ b/src/Deprecated/Engine/Engine/TaskRegistry.cs
@@ -4,11 +4,8 @@
 using System;
 using System.IO;
 using System.Xml;
-using System.Security;
 using System.Reflection;
 using System.Collections;
-using System.Diagnostics;
-using System.Globalization;
 
 using Microsoft.Build.BuildEngine.Shared;
 using Microsoft.Build.Framework;
diff --git a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
index 1e02d208ea9..37efbc5c0c2 100644
--- a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
+++ b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
@@ -4,10 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Text;
 using System.Threading;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Engine/ToolsetCollection.cs b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
index c9025f7c3f6..f269f8f34a0 100644
--- a/src/Deprecated/Engine/Engine/ToolsetCollection.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Collections.ObjectModel;
 
 using Microsoft.Build.BuildEngine.Shared;
 
diff --git a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
index 42aedf3fcaf..a1d7e31e005 100644
--- a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
@@ -4,11 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Configuration;
-using System.IO;
-using System.Text;
 using error = Microsoft.Build.BuildEngine.Shared.ErrorUtilities;
-using System.Globalization;
-using System.Reflection;
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
@@ -77,7 +73,7 @@ protected override string DefaultToolsVersion
         {
             get
             {
-                return ConfigurationSection == null ? null : ConfigurationSection.Default;
+                return ConfigurationSection?.Default;
             }
         }
 
@@ -131,7 +127,7 @@ private ToolsetConfigurationSection ConfigurationSection
         {
             get
             {
-                if (null == configurationSection && !configurationReadAttempted)
+                if (configurationSection == null && !configurationReadAttempted)
                 {
                     try
                     {
@@ -148,7 +144,7 @@ private ToolsetConfigurationSection ConfigurationSection
                         // If section definition is not present and section is also not present, this value is null
                         // If the section definition is not present and section is present, then this value is null
 
-                        if (null != configuration)
+                        if (configuration != null)
                         {
                             configurationSection = configuration.GetSection("msbuildToolsets") as ToolsetConfigurationSection;
                         }
diff --git a/src/Deprecated/Engine/Engine/ToolsetReader.cs b/src/Deprecated/Engine/Engine/ToolsetReader.cs
index fbeecd62a08..ba52d9732a2 100644
--- a/src/Deprecated/Engine/Engine/ToolsetReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetReader.cs
@@ -4,8 +4,6 @@
 using System;
 using System.IO;
 using System.Collections.Generic;
-
-using Microsoft.Build.BuildEngine;
 using Microsoft.Build.BuildEngine.Shared;
 using error = Microsoft.Build.BuildEngine.Shared.ErrorUtilities;
 
@@ -132,11 +130,9 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
             // The ordering here is important because the configuration file should have greater precedence
             // than the registry
             string defaultToolsVersionFromRegistry = null;
-
-            ToolsetRegistryReader registryReaderToUse = null;
             if ((locations & ToolsetDefinitionLocations.Registry) == ToolsetDefinitionLocations.Registry)
             {
-                registryReaderToUse = registryReader == null ? new ToolsetRegistryReader() : registryReader;
+                ToolsetRegistryReader registryReaderToUse = registryReader ?? new ToolsetRegistryReader();
                 // We do not accumulate properties when reading them from the registry, because the order
                 // in which values are returned to us is essentially random: so we disallow one property
                 // in the registry to refer to another also in the registry
@@ -145,8 +141,6 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
             }
 
             string defaultToolsVersionFromConfiguration = null;
-
-            ToolsetConfigurationReader configurationReaderToUse = null;
             if ((locations & ToolsetDefinitionLocations.ConfigurationFile) == ToolsetDefinitionLocations.ConfigurationFile)
             {
                 if (configurationReader == null && ConfigurationFileMayHaveToolsets())
@@ -159,7 +153,7 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
 
                 if (configurationReader != null)
                 {
-                    configurationReaderToUse = configurationReader == null ? new ToolsetConfigurationReader() : configurationReader;
+                    ToolsetConfigurationReader configurationReaderToUse = configurationReader ?? new ToolsetConfigurationReader();
                     // Accumulation of properties is okay in the config file because it's deterministically ordered
                     defaultToolsVersionFromConfiguration =
                         configurationReaderToUse.ReadToolsets(toolsets, globalProperties, initialProperties, true /* accumulate properties */);
@@ -391,7 +385,7 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
 
             try
             {
-                toolset = new Toolset(toolsVersion.Name, toolsPath == null ? binPath : toolsPath, properties);
+                toolset = new Toolset(toolsVersion.Name, toolsPath ?? binPath, properties);
             }
             catch (ArgumentException e)
             {
diff --git a/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs b/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
index 075f4754872..4935eaea24e 100644
--- a/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
@@ -1,13 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Win32;
-using System;
 using System.Collections.Generic;
-using System.IO;
-using System.Security;
-
-using Microsoft.Build.BuildEngine.Shared;
 using error = Microsoft.Build.BuildEngine.Shared.ErrorUtilities;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Engine/ToolsetState.cs b/src/Deprecated/Engine/Engine/ToolsetState.cs
index 062a0ef03e6..15436e47e88 100644
--- a/src/Deprecated/Engine/Engine/ToolsetState.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetState.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.IO;
-using System.Text;
 using System.Xml;
 
 using Microsoft.Build.Framework;
diff --git a/src/Deprecated/Engine/Engine/UsingTask.cs b/src/Deprecated/Engine/Engine/UsingTask.cs
index 0ce6469a9cc..84dfde06690 100644
--- a/src/Deprecated/Engine/Engine/UsingTask.cs
+++ b/src/Deprecated/Engine/Engine/UsingTask.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Xml;
 
 using Microsoft.Build.BuildEngine.Shared;
@@ -37,7 +35,7 @@ public bool IsImported
         /// <owner>LukaszG</owner>
         public string TaskName
         {
-            get { return (this.taskNameAttribute != null) ? this.taskNameAttribute.Value : null; }
+            get { return this.taskNameAttribute?.Value; }
         }
 
         /// <summary>
@@ -56,7 +54,7 @@ internal XmlAttribute TaskNameAttribute
         /// <owner>LukaszG</owner>
         public string AssemblyName
         {
-            get { return (this.assemblyNameAttribute != null) ? this.assemblyNameAttribute.Value : null; }
+            get { return this.assemblyNameAttribute?.Value; }
         }
 
         /// <summary>
@@ -75,7 +73,7 @@ internal XmlAttribute AssemblyNameAttribute
         /// <owner>LukaszG</owner>
         public string AssemblyFile
         {
-            get { return (this.assemblyFileAttribute != null) ? this.assemblyFileAttribute.Value : null; }
+            get { return this.assemblyFileAttribute?.Value; }
         }
 
         /// <summary>
@@ -94,7 +92,7 @@ internal XmlAttribute AssemblyFileAttribute
         /// <owner>LukaszG</owner>
         public string Condition
         {
-            get { return (this.conditionAttribute != null) ? this.conditionAttribute.Value : null; }
+            get { return this.conditionAttribute?.Value; }
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Engine/UsingTaskCollection.cs b/src/Deprecated/Engine/Engine/UsingTaskCollection.cs
index 6e4697d8c9e..a19c668c3b8 100644
--- a/src/Deprecated/Engine/Engine/UsingTaskCollection.cs
+++ b/src/Deprecated/Engine/Engine/UsingTaskCollection.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Collections;
-using System.Collections.Generic;
-using System.Text;
 
 using Microsoft.Build.BuildEngine.Shared;
 
diff --git a/src/Deprecated/Engine/Engine/Utilities.cs b/src/Deprecated/Engine/Engine/Utilities.cs
index ce453502b25..6f7cb535570 100644
--- a/src/Deprecated/Engine/Engine/Utilities.cs
+++ b/src/Deprecated/Engine/Engine/Utilities.cs
@@ -3,18 +3,10 @@
 
 using System;
 using System.Xml;
-using System.Diagnostics;
 using System.Collections;
 using System.Collections.Generic;
 using System.Collections.Specialized;
-using System.IO;
-using System.Text;
 using System.Text.RegularExpressions;
-using System.Globalization;
-using System.Xml.Serialization;
-using System.Security;
-using System.Security.Policy;
-using System.Security.Permissions;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
diff --git a/src/Deprecated/Engine/Engine/XmlSearcher.cs b/src/Deprecated/Engine/Engine/XmlSearcher.cs
index c2ffefb6f1f..94cb2516e44 100644
--- a/src/Deprecated/Engine/Engine/XmlSearcher.cs
+++ b/src/Deprecated/Engine/Engine/XmlSearcher.cs
@@ -4,7 +4,6 @@
 using System;
 using System.IO;
 using System.Xml;
-using System.Collections;
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
index 7e24aef9654..4c458782833 100644
--- a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
 
 using Microsoft.Build.BuildEngine.Shared;
 using System.Runtime.Serialization;
diff --git a/src/Deprecated/Engine/Errors/RegistryException.cs b/src/Deprecated/Engine/Errors/RegistryException.cs
index 01e6dfad5ac..822064f0f61 100644
--- a/src/Deprecated/Engine/Errors/RegistryException.cs
+++ b/src/Deprecated/Engine/Errors/RegistryException.cs
@@ -2,11 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
 using System.Runtime.Serialization;
 
-using Microsoft.Build.BuildEngine.Shared;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Introspector/Introspector.cs b/src/Deprecated/Engine/Introspector/Introspector.cs
index 1946f84a967..a4c0f0cfc87 100644
--- a/src/Deprecated/Engine/Introspector/Introspector.cs
+++ b/src/Deprecated/Engine/Introspector/Introspector.cs
@@ -6,9 +6,7 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
-using System.Collections;
 using System.Threading;
-using System.Diagnostics;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/Introspector/NodeStatus.cs b/src/Deprecated/Engine/Introspector/NodeStatus.cs
index 72665029a69..f615afc8dc9 100644
--- a/src/Deprecated/Engine/Introspector/NodeStatus.cs
+++ b/src/Deprecated/Engine/Introspector/NodeStatus.cs
@@ -2,13 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
 using System.Runtime.Serialization.Formatters.Binary;
 
-using Microsoft.Build.Framework;
-using Microsoft.Build.BuildEngine.Shared;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
index eb9feec1cf0..114ac3532b9 100644
--- a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
+++ b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
@@ -2,12 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Text;
 using System.IO;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
@@ -59,7 +55,7 @@ string projectName
         /// </summary>
         private void ProcessBuildContext(EngineCallback engineCallback, ProjectBuildState buildContext, Target target)
         {
-            BuildRequest parentRequest = null;
+            BuildRequest parentRequest;
             TargetIdWrapper parentName = FindParentTarget(engineCallback, buildContext, target, out parentRequest);
 
             if (parentName != null)
@@ -266,7 +262,7 @@ internal bool CheckBuildContextForParentMatch
             ProjectBuildState projectBuildState
         )
         {
-            BuildRequest parentRequest = null;
+            BuildRequest parentRequest;
             TargetInProgessState.TargetIdWrapper parentName =
                 FindParentTarget(engineCallback, projectBuildState, target, out parentRequest);
 
diff --git a/src/Deprecated/Engine/Items/BuildItem.cs b/src/Deprecated/Engine/Items/BuildItem.cs
index 553e5117a97..00d9a385ae0 100644
--- a/src/Deprecated/Engine/Items/BuildItem.cs
+++ b/src/Deprecated/Engine/Items/BuildItem.cs
@@ -7,10 +7,6 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
-using System.Text;
-using System.Security;
-using System.Globalization;
-using System.Text.RegularExpressions;
 
 #if (!STANDALONEBUILD)
 using Microsoft.Internal.Performance;
@@ -953,9 +949,7 @@ internal bool IsBackedUp
         internal IDictionary CloneCustomMetadata() 
         {
             IDictionary result = (IDictionary)this.evaluatedCustomMetadata.Clone();
-            result = MergeDefaultMetadata(result);
-
-            return result; 
+            return MergeDefaultMetadata(result);
         }
 
         /// <summary>
@@ -1248,8 +1242,7 @@ public bool HasMetadata(string metadataName)
         /// <exception cref="InvalidOperationException">Thrown when the requested metadata is not applicable to the item.</exception>
         public string GetMetadata(string metadataName)
         {
-            string metadataValue = null;
-
+            string metadataValue;
             if (FileUtilities.IsItemSpecModifier(metadataName))
             {
                 // BUGBUG VSWhidbey 377466.  If this method is being called directly by an OM
@@ -1274,7 +1267,7 @@ public string GetMetadata(string metadataName)
                 metadataValue = GetDefaultMetadataValue(metadataName);
             } 
 
-            return (metadataValue == null) ? String.Empty : metadataValue;
+            return metadataValue ?? String.Empty;
         }
 
         /// <summary>
@@ -1299,8 +1292,7 @@ public string GetEvaluatedMetadata(string metadataName)
         /// <exception cref="InvalidOperationException">Thrown when the requested attribute is not applicable to the item.</exception>
         internal string GetEvaluatedMetadataEscaped(string metadataName)
         {
-            string metadataValue = null;
-
+            string metadataValue;
             if (FileUtilities.IsItemSpecModifier(metadataName))
             {
                 // BUGBUG VSWhidbey 377466.  If this method is being called directly by an OM
@@ -1325,7 +1317,7 @@ internal string GetEvaluatedMetadataEscaped(string metadataName)
                 metadataValue = GetDefaultMetadataValue(metadataName);
             }              
 
-            return (metadataValue == null) ? String.Empty : metadataValue;
+            return metadataValue ?? String.Empty;
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Items/BuildItemGroup.cs b/src/Deprecated/Engine/Items/BuildItemGroup.cs
index a8ce9e29aac..82f439c644b 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroup.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroup.cs
@@ -5,13 +5,9 @@
 using System.Xml;
 using System.Collections;
 using System.Collections.Generic;
-using System.IO;
-using System.Text;
-using System.Globalization;
 using System.Diagnostics;
 
 using Microsoft.Build.BuildEngine.Shared;
-using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs b/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs
index 37f2223d36c..703772c70db 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs
@@ -2,12 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Data;
-using System.Xml;
 using System.Collections;
 
-using Microsoft.Build.BuildEngine.Shared;
-
 using error = Microsoft.Build.BuildEngine.Shared.ErrorUtilities;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs b/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs
index cff73d8f934..fa015ebcc36 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroupProxy.cs
@@ -1,11 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Collections;
-using Microsoft.Build.BuildEngine;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs b/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs
index d632df67c55..87cb6e68e47 100644
--- a/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs
+++ b/src/Deprecated/Engine/Items/ItemDefinitionLibrary.cs
@@ -3,12 +3,10 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using System.Xml;
 using Microsoft.Build.BuildEngine.Shared;
 using MetadataDictionary = System.Collections.Generic.Dictionary<string, string>;
 using ItemDefinitionsDictionary = System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<string, string>>;
-using System.Collections;
 
 namespace Microsoft.Build.BuildEngine
 {
@@ -241,9 +239,9 @@ private void EvaluateItemDefinitionElement(XmlElement itemDefinitionElement, Bui
 
                 XmlAttribute conditionAttribute = ProjectXmlUtilities.GetConditionAttribute(itemDefinitionElement, /* sole attribute */ true);
                 string condition = ProjectXmlUtilities.GetAttributeValue(conditionAttribute);
-
-                MetadataDictionary metadataDictionary = null;
                 string itemType = itemDefinitionElement.Name;
+
+                MetadataDictionary metadataDictionary;
                 itemDefinitionsDictionary.TryGetValue(itemType, out metadataDictionary);
 
                 Expander expander = new Expander(properties, itemType, metadataDictionary);
@@ -274,9 +272,9 @@ private void EvaluateItemDefinitionChildElement(XmlElement itemDefinitionChildEl
 
                 XmlAttribute conditionAttribute = ProjectXmlUtilities.GetConditionAttribute(itemDefinitionChildElement, /* sole attribute */ true);
                 string condition = ProjectXmlUtilities.GetAttributeValue(conditionAttribute);
-
-                MetadataDictionary metadataDictionary = null;
                 string itemType = itemDefinitionChildElement.ParentNode.Name;
+
+                MetadataDictionary metadataDictionary;
                 itemDefinitionsDictionary.TryGetValue(itemType, out metadataDictionary);
 
                 Expander expander = new Expander(properties, itemType, metadataDictionary);
diff --git a/src/Deprecated/Engine/Items/ItemExpander.cs b/src/Deprecated/Engine/Items/ItemExpander.cs
index 8bbdbcfba35..dd60744cfc3 100644
--- a/src/Deprecated/Engine/Items/ItemExpander.cs
+++ b/src/Deprecated/Engine/Items/ItemExpander.cs
@@ -2,13 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 using System.Xml;
-using System.Collections;
-using System.Diagnostics;
 using System.Text.RegularExpressions;
 using System.Text;
-using System.Globalization;
 
 using Microsoft.Build.BuildEngine.Shared;
 
@@ -186,7 +182,6 @@ internal static BuildItemGroup ItemizeItemVector
             out Match itemVectorMatch
         )
         {
-            itemVectorMatch = null;
             BuildItemGroup items = null;
 
             itemVectorMatch = GetItemVectorMatches(itemVectorExpression);
diff --git a/src/Deprecated/Engine/Items/TaskItem.cs b/src/Deprecated/Engine/Items/TaskItem.cs
index 9b2f69fda41..a5a53f4da5c 100644
--- a/src/Deprecated/Engine/Items/TaskItem.cs
+++ b/src/Deprecated/Engine/Items/TaskItem.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Collections;
 using System.Security;
-using System.Security.Permissions;
-using System.Diagnostics;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
diff --git a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
index cc741b9b68b..1ead6244ab7 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
@@ -3,10 +3,6 @@
 
 using System;
 using System.Collections;
-using System.Security.Permissions;
-using System.Diagnostics;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 using System.Collections.Generic;
 
diff --git a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
index 459aedf5f15..0b219cc6f5f 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
@@ -4,11 +4,8 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.BuildEngine.Shared;
-using System.Diagnostics;
 using System.Threading;
-using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs b/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
index 689bbaaab8e..01f0f7a78e2 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalCallDescriptor.cs
@@ -2,14 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.Collections;
-using System.Text;
 using System.Threading;
 using System.IO;
 using System.Runtime.Serialization.Formatters.Binary;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
@@ -475,7 +471,7 @@ internal void CreateFromStream(BinaryReader reader, Hashtable loggingTypeCache)
 
             for (int i = 0; i < numberOfNodeEvents; i++)
             {
-                NodeLoggingEvent e = null;
+                NodeLoggingEvent e;
                 if (reader.ReadByte() == 0)
                 {
                     e = new NodeLoggingEvent();
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNode.cs b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
index ec12224520f..c883962ece7 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNode.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
@@ -3,12 +3,9 @@
 
 using System;
 using System.Collections;
-using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
 using System.Threading;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 using System.Security.AccessControl;
 
@@ -170,7 +167,7 @@ void StopCommunicationThreads()
         /// <returns>True if events created successfully and false otherwise</returns>
         private static bool CreateGlobalEvents(int nodeNumber)
         {
-            bool createdNew = false;
+            bool createdNew;
             if (NativeMethods.IsUserAdministrator())
             {
                 EventWaitHandleSecurity mSec = new EventWaitHandleSecurity();
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs
index 3c0d967fd5d..000446c6fc1 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs
@@ -3,13 +3,7 @@
 
 using System;
 using System.Collections;
-using System.Collections.Generic;
-using System.Security.Permissions;
-using System.Text;
 using System.Threading;
-using System.Xml;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs
index 8d634635004..506cd32a483 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeInfo.cs
@@ -1,14 +1,9 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Text;
 using System.Threading;
 
-using Microsoft.Build.Framework;
-using Microsoft.Build.BuildEngine.Shared;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
@@ -213,7 +208,7 @@ private void ReserveNextAvailableNodeNumber(int currentNodeNumber)
         {
             while (nodeReserveHandle == null)
             {
-                bool createdNew = false;
+                bool createdNew;
                 nodeReserveHandle = 
                     new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeReserveEventName(currentNodeNumber), out createdNew);
                 if (!createdNew)
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
index fef67684cef..07cc648695e 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
@@ -5,12 +5,9 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Text;
 using System.Threading;
 using System.Globalization;
 using System.IO;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 using System.Runtime.InteropServices;
 
@@ -41,8 +38,7 @@ string startupDirectory
             if (configuration != null)
             {
                 // Split out the parameter sets based on ;
-                string[] parameters;
-                parameters = configuration.Split(parameterDelimiters);
+                string[] parameters = configuration.Split(parameterDelimiters);
                 // Go through each of the parameter name value pairs and split them appart
                 for (int param = 0; param < parameters.Length; param++)
                 {
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs
index aed8912e2b5..f1b17e6902e 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeProviderGlobalNames.cs
@@ -1,18 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Reflection;
 
-using System.Collections;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.IO;
-using System.Threading;
-
-using Microsoft.Build.Framework;
-using Microsoft.Build.BuildEngine.Shared;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
@@ -150,12 +140,9 @@ static internal string NodeOutputMemoryName(int nodeNumber)
         /// </summary>
         static private void InitializeGlobalNamePostFixValues()
         {
-            string engineVersion = null;
-            string accountTypePostfix = null;
-            string usernamePostFix = null;
             AssemblyName name = new AssemblyName(Assembly.GetExecutingAssembly().FullName);
-            engineVersion = name.Version.ToString();
-
+            string engineVersion = name.Version.ToString();
+            string accountTypePostfix;
             if (NativeMethods.IsUserAdministrator())
             {
                 accountTypePostfix = "Admin";
@@ -165,7 +152,7 @@ static private void InitializeGlobalNamePostFixValues()
                 accountTypePostfix = "NotAdmin";
             }
             // As per the msdn docs for WindowsIdentity.Name Property The logon name is in the form DOMAIN\USERNAME. so replace the \ so it is not confused as a path
-            usernamePostFix = System.Security.Principal.WindowsIdentity.GetCurrent().Name.Replace("\\", "_");
+            string usernamePostFix = System.Security.Principal.WindowsIdentity.GetCurrent().Name.Replace("\\", "_");
 
             nodePostfix = engineVersion + accountTypePostfix + usernamePostFix;
         }
diff --git a/src/Deprecated/Engine/LocalProvider/NativeMethods.cs b/src/Deprecated/Engine/LocalProvider/NativeMethods.cs
index c9a573e2814..d2be3516f56 100644
--- a/src/Deprecated/Engine/LocalProvider/NativeMethods.cs
+++ b/src/Deprecated/Engine/LocalProvider/NativeMethods.cs
@@ -67,15 +67,12 @@ internal static bool IsUserAdministrator()
         {
             int SECURITY_BUILTIN_DOMAIN_RID = 0x00000020;
             int DOMAIN_ALIAS_RID_ADMINS  = 0x00000220;
-            bool bRet = false;
-
-            IntPtr psidRidGroup = NullPtr;
             IntPtr pNtAuthority = Marshal.AllocHGlobal(6);
             Marshal.WriteInt32(pNtAuthority, 0, 0);
             Marshal.WriteByte(pNtAuthority, 4, 0);
             Marshal.WriteByte(pNtAuthority, 5, 5);
-
-            bRet = AllocateAndInitializeSid(pNtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, out psidRidGroup);
+            IntPtr psidRidGroup;
+            bool bRet = AllocateAndInitializeSid(pNtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, out psidRidGroup);
             try
             {
                 if (bRet)
diff --git a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
index 47f1f7c65af..30bb926fc11 100644
--- a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
+++ b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
@@ -4,16 +4,12 @@
 using System;
 using System.IO;
 using System.Collections;
-using System.Collections.Generic;
 using System.Diagnostics;
-using System.Runtime.Serialization;
 using System.Runtime.Serialization.Formatters.Binary;
 using System.Runtime.InteropServices;
 using System.Threading;
 
 using Microsoft.Win32.SafeHandles;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
@@ -699,8 +695,6 @@ internal IList Read()
         {
             ErrorUtilities.VerifyThrow(type == SharedMemoryType.ReadOnly, "Should only be calling Read from a readonly shared memory object");
             ArrayList objectsRead = null;
-            int objectId = -1;
-
             lock (readLock)
             {
                 if (NumberOfUnreadBatches > 0)
@@ -735,6 +729,7 @@ internal IList Read()
                     {
                         objectsRead = new ArrayList();
 
+                        int objectId;
                         // Deserialize the object in the read stream to a LocalCallDescriptor. The objectId
                         // is the "ObjectType" which was written to the head of the object when written to the memory stream.
                         // It describes which kind of object was serialized
diff --git a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
index f551930bcf8..bc9f6226b04 100644
--- a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
@@ -113,9 +112,7 @@ public void ParseParameters()
         {
             if (loggerParameters != null)
             {
-                string[] parameterComponents;
-
-                parameterComponents = loggerParameters.Split(parameterDelimiters);
+                string[] parameterComponents = loggerParameters.Split(parameterDelimiters);
                 for (int param = 0; param < parameterComponents.Length; param++)
                 {
                     if (parameterComponents[param].Length > 0)
@@ -175,7 +172,7 @@ public int Compare(Object a, Object b)
         internal string IndentString(string s, int indent)
         {
             // It's possible the event has a null message
-            if (null == s)
+            if (s == null)
             {
                 s = String.Empty;
             }
diff --git a/src/Deprecated/Engine/Logging/ConsoleLogger.cs b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
index 28772e3dbd5..e772b01690a 100644
--- a/src/Deprecated/Engine/Logging/ConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
@@ -2,11 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Text;
-using System.Collections;
-using System.Diagnostics;
-using System.Globalization;
-using System.IO;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index 35960ad131e..f9f56bff848 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Text;
 using System.Collections.Generic;
 
 using Microsoft.Build.Framework;
@@ -100,9 +98,7 @@ private void ParseParameters()
         {
             if (loggerParameters != null)
             {
-                string[] parameterComponents;
-
-                parameterComponents = loggerParameters.Split(parameterDelimiters);
+                string[] parameterComponents = loggerParameters.Split(parameterDelimiters);
                 for (int param = 0; param < parameterComponents.Length; param++)
                 {
                     if (parameterComponents[param].Length > 0)
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
index aa20ca20733..7955a4fed44 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Text;
 using System.IO;
 
 using Microsoft.Build.Framework;
@@ -40,9 +38,7 @@ private void ParseFileLoggerParameters()
         {
             if (this.Parameters != null)
             {
-                string[] parameterComponents;
-
-                parameterComponents = this.Parameters.Split(fileLoggerParameterDelimiters);
+                string[] parameterComponents = this.Parameters.Split(fileLoggerParameterDelimiters);
                 for (int param = 0; param < parameterComponents.Length; param++)
                 {
                     if (parameterComponents[param].Length > 0)
diff --git a/src/Deprecated/Engine/Logging/FileLogger.cs b/src/Deprecated/Engine/Logging/FileLogger.cs
index 1b36ffbd976..e6c767ac775 100644
--- a/src/Deprecated/Engine/Logging/FileLogger.cs
+++ b/src/Deprecated/Engine/Logging/FileLogger.cs
@@ -2,10 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.Text;
 using System.IO;
-using System.Globalization;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
@@ -157,9 +155,7 @@ private void ParseFileLoggerParameters()
         {
             if (this.Parameters != null)
             {
-                string[] parameterComponents;
-
-                parameterComponents = this.Parameters.Split(fileLoggerParameterDelimiters);
+                string[] parameterComponents = this.Parameters.Split(fileLoggerParameterDelimiters);
                 for (int param = 0; param < parameterComponents.Length; param++)
                 {
                     if (parameterComponents[param].Length > 0)
diff --git a/src/Deprecated/Engine/Logging/LogFormatter.cs b/src/Deprecated/Engine/Logging/LogFormatter.cs
index 137049a753f..104ddd98f57 100644
--- a/src/Deprecated/Engine/Logging/LogFormatter.cs
+++ b/src/Deprecated/Engine/Logging/LogFormatter.cs
@@ -2,10 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Text;
-using System.IO;
-using Microsoft.Build.Framework;
 using System.Globalization;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Logging/LoggerDescription.cs b/src/Deprecated/Engine/Logging/LoggerDescription.cs
index 88330bd342e..4550081d3e9 100644
--- a/src/Deprecated/Engine/Logging/LoggerDescription.cs
+++ b/src/Deprecated/Engine/Logging/LoggerDescription.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Reflection;
-using System.Text;
 using System.IO;
 
 using Microsoft.Build.Framework;
diff --git a/src/Deprecated/Engine/Logging/NullCentralLogger.cs b/src/Deprecated/Engine/Logging/NullCentralLogger.cs
index 7e187e96839..d6eaf88b342 100644
--- a/src/Deprecated/Engine/Logging/NullCentralLogger.cs
+++ b/src/Deprecated/Engine/Logging/NullCentralLogger.cs
@@ -1,9 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 9b8ebaae388..180d133c560 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -6,7 +6,6 @@
 using System.Collections;
 using System.Diagnostics;
 using System.Globalization;
-using System.IO;
 using System.Collections.Generic;
 
 using Microsoft.Build.Framework;
@@ -499,12 +498,12 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                 {
                     DisplayDeferredProjectStartedEvent(e.BuildEventContext);
                 }
-                if (null != e.Properties)
+                if (e.Properties != null)
                 {
                     WriteProperties(e, e.Properties);          
                 }
 
-                if (null != e.Items)
+                if (e.Items != null)
                 {
                     WriteItems(e, e.Items);
                 }
@@ -547,10 +546,8 @@ public override void ProjectFinishedHandler(object sender, ProjectFinishedEventA
                         // In the project finished message the targets which were built and the project which was built
                         // should be shown
                         string targets = startedEvent.TargetNames;
-
-                        string projectName = string.Empty;
-
-                        projectName = startedEvent.ProjectFile == null ? string.Empty : startedEvent.ProjectFile;
+                        string projectName = startedEvent.ProjectFile ?? string.Empty;
+                        
                         // Show which targets were built as part of this project
                         if (string.IsNullOrEmpty(targets))
                         {
@@ -966,7 +963,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                        && IsVerbosityAtLeast(LoggerVerbosity.Normal)
                     )
                 {
-                    List<BuildMessageEventArgs> messageList = null;
+                    List<BuildMessageEventArgs> messageList;
                     if (deferredMessages.ContainsKey(e.BuildEventContext))
                     {
                         messageList = deferredMessages[e.BuildEventContext];
@@ -1012,7 +1009,7 @@ private void DisplayDeferredStartedEvents(BuildEventContext e)
         /// </summary>
         private void PrintMessage(BuildMessageEventArgs e, bool lightenText)
         {
-            string nonNullMessage = (e.Message == null) ? String.Empty : e.Message;
+            string nonNullMessage = e.Message ?? String.Empty;
             int prefixAdjustment = 0;
 
             if (e.BuildEventContext.TaskId != BuildEventContext.InvalidTaskId)
@@ -1063,7 +1060,7 @@ private void PrintTargetNamePerMessage(BuildMessageEventArgs e, bool lightenText
                 string targetName = string.Empty;
 
                 // Does the context (Project, Node, Context, Target, NOT task) of the previous event match the current message
-                bool contextAreEqual = compareContextNodeIdTargetId.Equals(currentBuildEventContext, lastDisplayedBuildEventContext == null ? null : lastDisplayedBuildEventContext);
+                bool contextAreEqual = compareContextNodeIdTargetId.Equals(currentBuildEventContext, lastDisplayedBuildEventContext ?? null);
 
                 TargetStartedEventMinimumFields targetStartedEvent = null;
                 // If the previous event does not have the same target context information, the target name needs to be printed to the console
@@ -1231,9 +1228,9 @@ private void DisplayDeferredTargetStartedEvent(BuildEventContext e)
                
                 ProjectStartedEventMinimumFields startedEvent = buildEventManager.GetProjectStartedEvent(e);
                 ErrorUtilities.VerifyThrow(startedEvent != null, "Project Started should not be null in deferred target started");
-                string currentProjectFile = startedEvent.ProjectFile == null ? string.Empty : startedEvent.ProjectFile;
+                string currentProjectFile = startedEvent.ProjectFile ?? string.Empty;
 
-                string targetName = null;
+                string targetName;
                 if (IsVerbosityAtLeast(LoggerVerbosity.Diagnostic) || showEventId)
                 {
                    targetName = ResourceUtilities.FormatResourceString("TargetMessageWithId", targetStartedEvent.TargetName, targetStartedEvent.ProjectBuildEventContext.TargetId);
@@ -1281,8 +1278,8 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                         DisplayDeferredStartedEvents(parentStartedEvent.ProjectBuildEventContext);
                     }
 
-                    string current = projectStartedEvent.ProjectFile == null ? string.Empty : projectStartedEvent.ProjectFile;
-                    string previous = parentStartedEvent == null ? null : parentStartedEvent.ProjectFile;
+                    string current = projectStartedEvent.ProjectFile ?? string.Empty;
+                    string previous = parentStartedEvent?.ProjectFile;
                     string targetNames = projectStartedEvent.TargetNames;
 
                     // Log 0-based node id's, where 0 is the parent. This is a little unnatural for the reader,
@@ -1292,7 +1289,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                     {
                         WriteLinePrefix(projectStartedEvent.FullProjectKey, projectStartedEvent.TimeStamp, false);
                         setColor(ConsoleColor.Cyan);
-                        string message = string.Empty;
+                        string message;
                         if (string.IsNullOrEmpty(targetNames))
                         {
                             message = ResourceUtilities.FormatResourceString("ProjectStartedTopLevelProjectWithDefaultTargets", current, currentProjectNodeId);
@@ -1371,8 +1368,7 @@ private void WriteLinePrefix(string key, DateTime eventTimeStamp, bool isMessage
                 context = LogFormatter.FormatLogTimeStamp(eventTimeStamp);
             }
 
-            string prefixString = string.Empty;
-
+            string prefixString;
             if (!isMessagePrefix || IsVerbosityAtLeast(LoggerVerbosity.Detailed))
             {
                 prefixString = ResourceUtilities.FormatResourceString("BuildEventContext", context, key) + ">";
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index dda28a81fd3..8470aca7630 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -3,13 +3,8 @@
 
 using System;
 using System.Collections.Generic;
-using System.Collections;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
-using System.IO;
-using System.Diagnostics;
-using System.Threading;
 using System.Globalization;
 
 namespace Microsoft.Build.BuildEngine
@@ -50,7 +45,7 @@ internal void AddProjectStartedEvent(ProjectStartedEventArgs e)
                 if (!projectStartedEvents.ContainsKey(e.BuildEventContext))
                 {
                     int projectTargetKeyLocal = 1;
-                    int projectIncrementKeyLocal = 1;
+                    int projectIncrementKeyLocal;
                     // If we haven't seen this project before (by full path) then
                     // allocate a new key for it and save it away
                     if (!projectKey.ContainsKey(e.ProjectFile))
@@ -533,7 +528,7 @@ internal class ErrorWarningSummaryDictionaryKey
         internal ErrorWarningSummaryDictionaryKey(BuildEventContext entryPoint, string targetName)
         {
             this.entryPointContext = entryPoint;
-            this.targetName = targetName == null ? string.Empty : targetName;
+            this.targetName = targetName ?? string.Empty;
         }
         #endregion
 
diff --git a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
index b9f0f7fd091..7fc7d154a32 100644
--- a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
@@ -2,11 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Collections;
-using System.IO;
-using System.Globalization;
 using System.Diagnostics;
 
 using Microsoft.Build.Framework;
@@ -267,13 +263,13 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
 
             if (Verbosity == LoggerVerbosity.Diagnostic && showItemAndPropertyList)
             {
-                if (null != e.Properties)
+                if (e.Properties != null)
                 {
                     ArrayList propertyList = ExtractPropertyList(e.Properties);
                     WriteProperties(propertyList);
                 }
 
-                if (null != e.Items)
+                if (e.Items != null)
                 {
                     SortedList itemList = ExtractItemList(e.Items);
                     WriteItems(itemList);
@@ -529,7 +525,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                 }
 
                 // null messages are ok -- treat as blank line
-                string nonNullMessage = (e.Message == null) ? String.Empty : e.Message;
+                string nonNullMessage = e.Message ?? String.Empty;
 
                 WriteLinePretty(nonNullMessage);
 
diff --git a/src/Deprecated/Engine/Properties/BuildProperty.cs b/src/Deprecated/Engine/Properties/BuildProperty.cs
index f50d45e32fa..5f09f69875c 100644
--- a/src/Deprecated/Engine/Properties/BuildProperty.cs
+++ b/src/Deprecated/Engine/Properties/BuildProperty.cs
@@ -3,9 +3,7 @@
 
 using System;
 using System.Xml;
-using System.Collections;
 using System.Diagnostics;
-using System.Globalization;
 using System.IO;
 
 using Microsoft.Build.BuildEngine.Shared;
@@ -129,7 +127,7 @@ internal void WriteToStream(BinaryWriter writer)
         /// </summary>
         private static string Intern(string stringToIntern)
         {
-            string value = stringToIntern;
+            string value;
             if (!customInternTable.TryGetValue(stringToIntern, out value))
             {
                 customInternTable.Add(stringToIntern, stringToIntern);
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
index b666ba90434..672eaee766f 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
@@ -2,13 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Data;
 using System.Xml;
 using System.IO;
-using System.Text;
 using System.Collections;
 using System.Diagnostics;
-using System.Globalization;
 
 using Microsoft.Build.BuildEngine.Shared;
 
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs
index 40e2870f2c1..40da4c5f1e2 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs
@@ -2,14 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Data;
-using System.Xml;
 using System.Collections;
 
-using Microsoft.Build.BuildEngine.Shared;
-
-using error = Microsoft.Build.BuildEngine.Shared.ErrorUtilities;
-
 namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs
index b83c555c246..46109721ae2 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroupProxy.cs
@@ -1,11 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Collections;
-using Microsoft.Build.BuildEngine;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/Resources/Constants.cs b/src/Deprecated/Engine/Resources/Constants.cs
index 499b2fa4acd..fa46c5249ee 100644
--- a/src/Deprecated/Engine/Resources/Constants.cs
+++ b/src/Deprecated/Engine/Resources/Constants.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Xml;
-using System.Globalization;
 using System.Collections.Generic;
 using System.Collections.Concurrent;
 using Microsoft.Build.Shared;
diff --git a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
index dd92e681f9b..edd9b7ee18a 100644
--- a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Text;
 using System.Reflection;
-using System.Collections;
 using System.Globalization;
 using System.Diagnostics;
 
diff --git a/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs b/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs
index 03d78fe93bd..5f77245afff 100644
--- a/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs
@@ -1,12 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections;
 using System.Globalization;
-using System.Text;
-
-using Microsoft.Build.BuildEngine;
 
 namespace Microsoft.Build.BuildEngine.Shared
 {
diff --git a/src/Deprecated/Engine/Shared/Delegate.cs b/src/Deprecated/Engine/Shared/Delegate.cs
index 024b2d2932f..26f42a67b90 100644
--- a/src/Deprecated/Engine/Shared/Delegate.cs
+++ b/src/Deprecated/Engine/Shared/Delegate.cs
@@ -1,8 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-
 namespace Microsoft.Build.BuildEngine.Shared
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Shared/ErrorUtilities.cs b/src/Deprecated/Engine/Shared/ErrorUtilities.cs
index 37c9fbe307c..213310ce25e 100644
--- a/src/Deprecated/Engine/Shared/ErrorUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ErrorUtilities.cs
@@ -2,10 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 using System.Diagnostics;
-using System.Configuration;
-using System.Globalization;
 
 namespace Microsoft.Build.BuildEngine.Shared
 {
diff --git a/src/Deprecated/Engine/Shared/EventArgsFormatting.cs b/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
index 0e449a15cc3..5e4fa1fe365 100644
--- a/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
+++ b/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Globalization;
-using System.Collections.Generic;
 using System.Text;
 
 using Microsoft.Build.Framework;
@@ -207,7 +206,7 @@ int threadId
             }
 
             // A null message is allowed and is to be treated as a blank line.
-            if (null == message)
+            if (message == null)
             {
                 message = String.Empty;
             }
@@ -220,12 +219,12 @@ int threadId
 
             for (int i = 0; i < lines.Length; i++)
             {
-                formattedMessage.Append(String.Format(
+                formattedMessage.AppendFormat(
                         CultureInfo.CurrentCulture, finalFormat,
                         threadId, file,
                         lineNumber, columnNumber, category, code,
                         lines[i], endLineNumber, endColumnNumber,
-                        subcategory));
+                        subcategory);
 
                 if (i < (lines.Length - 1))
                 {
diff --git a/src/Deprecated/Engine/Shared/ExceptionHandling.cs b/src/Deprecated/Engine/Shared/ExceptionHandling.cs
index c9550b278bb..f1d72ddd637 100644
--- a/src/Deprecated/Engine/Shared/ExceptionHandling.cs
+++ b/src/Deprecated/Engine/Shared/ExceptionHandling.cs
@@ -4,7 +4,6 @@
 using System;
 using System.IO;
 using System.Security;
-using System.Diagnostics;
 using System.Reflection;
 
 namespace Microsoft.Build.BuildEngine.Shared
diff --git a/src/Deprecated/Engine/Shared/FileMatcher.cs b/src/Deprecated/Engine/Shared/FileMatcher.cs
index 958d4c8fc4a..3292f664426 100644
--- a/src/Deprecated/Engine/Shared/FileMatcher.cs
+++ b/src/Deprecated/Engine/Shared/FileMatcher.cs
@@ -6,8 +6,6 @@
 using System.Text;
 using System.Diagnostics;
 using System.Text.RegularExpressions;
-using System.Threading;
-using System.Globalization;
 
 namespace Microsoft.Build.BuildEngine.Shared
 {
@@ -263,9 +261,8 @@ GetFileSystemEntries getFileSystemEntries
 
             string[] parts = path.Split(directorySeparatorCharacters);
             string pathRoot;
-            int startingElement=0;
-
             bool isUnc = path.StartsWith(directorySeparator + directorySeparator, StringComparison.Ordinal);
+            int startingElement;
             if (isUnc)
             {
                 pathRoot = directorySeparator + directorySeparator;
@@ -278,7 +275,7 @@ GetFileSystemEntries getFileSystemEntries
             else
             {
                 // Is it relative?
-                if (path.Length>2 && path[1] == ':')
+                if (path.Length > 2 && path[1] == ':')
                 {
                     // Not relative
                     pathRoot = parts[0] + directorySeparator;
diff --git a/src/Deprecated/Engine/Shared/FileUtilities.cs b/src/Deprecated/Engine/Shared/FileUtilities.cs
index 80162907b71..929f6333d22 100644
--- a/src/Deprecated/Engine/Shared/FileUtilities.cs
+++ b/src/Deprecated/Engine/Shared/FileUtilities.cs
@@ -3,14 +3,11 @@
 
 using System;
 using System.IO;
-using System.Security;
 using System.Collections;
 using System.Diagnostics;
 using System.Globalization;
 using System.Text.RegularExpressions;
 using System.Text;
-using System.Threading;
-using System.Runtime.InteropServices;
 
 namespace Microsoft.Build.BuildEngine.Shared
 {
@@ -828,7 +825,7 @@ private static Uri CreateUriFromPath(string path)
         {
             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
 
-            Uri pathUri = null;
+            Uri pathUri;
 
             // Try absolute first, then fall back on relative, otherwise it
             // makes some absolute UNC paths like (\\foo\bar) relative ...
diff --git a/src/Deprecated/Engine/Shared/FileUtilitiesRegex.cs b/src/Deprecated/Engine/Shared/FileUtilitiesRegex.cs
index e64be549021..493d9ebbbc6 100644
--- a/src/Deprecated/Engine/Shared/FileUtilitiesRegex.cs
+++ b/src/Deprecated/Engine/Shared/FileUtilitiesRegex.cs
@@ -3,9 +3,6 @@
 
 using System;
 using System.IO;
-using System.Security;
-using System.Collections;
-using System.Diagnostics;
 using System.Globalization;
 using System.Text.RegularExpressions;
 
diff --git a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
index d5a8422995e..fd30818c312 100644
--- a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
+++ b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
@@ -3,9 +3,6 @@
 
 using System;
 using System.IO;
-using System.Text;
-using System.Diagnostics;
-using System.Globalization;
 
 namespace Microsoft.Build.BuildEngine.Shared
 {
@@ -425,27 +422,23 @@ private static string FindRegistryValueUnderKey
             string registryKeyName
         )
         {
-            string keyValueAsString = String.Empty;
-
             Microsoft.Win32.RegistryKey baseKey = Microsoft.Win32.Registry
                 .LocalMachine
                 .OpenSubKey(registryBaseKeyName);
 
-            if (null == baseKey)
+            if (baseKey == null)
             {
                 return null;
             }
 
             object keyValue = baseKey.GetValue(registryKeyName);
 
-            if (null == keyValue)
+            if (keyValue == null)
             {
                 return null;
             }
 
-            keyValueAsString = keyValue.ToString();
-
-            return keyValueAsString;
+            return keyValue.ToString();
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Shared/InternalErrorException.cs b/src/Deprecated/Engine/Shared/InternalErrorException.cs
index 2d3a876f50b..4cef1bf4699 100644
--- a/src/Deprecated/Engine/Shared/InternalErrorException.cs
+++ b/src/Deprecated/Engine/Shared/InternalErrorException.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Diagnostics;
-using System.Security.Permissions; // for SecurityPermissionAttribute
 using System.Runtime.Serialization;
 
 namespace Microsoft.Build.BuildEngine.Shared
diff --git a/src/Deprecated/Engine/Shared/NativeMethodsShared.cs b/src/Deprecated/Engine/Shared/NativeMethodsShared.cs
index 8493287c32b..2ca73148bb5 100644
--- a/src/Deprecated/Engine/Shared/NativeMethodsShared.cs
+++ b/src/Deprecated/Engine/Shared/NativeMethodsShared.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 using System.Text;
 using System.Runtime.InteropServices;
 
diff --git a/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs b/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
index e443b6f188c..474f6b711d9 100644
--- a/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Text;
 
 namespace Microsoft.Build.BuildEngine.Shared
 {
diff --git a/src/Deprecated/Engine/Shared/ProjectErrorUtilities.cs b/src/Deprecated/Engine/Shared/ProjectErrorUtilities.cs
index 4ac64589eea..187f375ce8e 100644
--- a/src/Deprecated/Engine/Shared/ProjectErrorUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ProjectErrorUtilities.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Xml;
 
 /******************************************************************************
@@ -14,7 +13,6 @@
  * 
  * 
  ******************************************************************************/
-using Microsoft.Build.BuildEngine;
 
 namespace Microsoft.Build.BuildEngine.Shared
 {
diff --git a/src/Deprecated/Engine/Shared/ProjectFileErrorUtilities.cs b/src/Deprecated/Engine/Shared/ProjectFileErrorUtilities.cs
index 1fdb2c4a3f5..7f34c4a6499 100644
--- a/src/Deprecated/Engine/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ProjectFileErrorUtilities.cs
@@ -1,10 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Xml;
-using Microsoft.Build.BuildEngine;
-
 namespace Microsoft.Build.BuildEngine.Shared
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Shared/ProjectWriter.cs b/src/Deprecated/Engine/Shared/ProjectWriter.cs
index ce63521746b..cfd98bf6e8e 100644
--- a/src/Deprecated/Engine/Shared/ProjectWriter.cs
+++ b/src/Deprecated/Engine/Shared/ProjectWriter.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.IO;
 using System.Xml;
 using System.Text;
diff --git a/src/Deprecated/Engine/Shared/SolutionParser.cs b/src/Deprecated/Engine/Shared/SolutionParser.cs
index 93f6aa0d908..7790ff7d26e 100644
--- a/src/Deprecated/Engine/Shared/SolutionParser.cs
+++ b/src/Deprecated/Engine/Shared/SolutionParser.cs
@@ -1311,7 +1311,7 @@ internal string GetDefaultPlatformName()
         internal string GetProjectUniqueNameByGuid(string projectGuid)
         {
             ProjectInSolution proj = (ProjectInSolution) projects[projectGuid];
-            return (proj == null) ? null : proj.GetUniqueProjectName();
+            return proj?.GetUniqueProjectName();
         }
 
         /// <summary>
@@ -1324,7 +1324,7 @@ internal string GetProjectUniqueNameByGuid(string projectGuid)
         internal string GetProjectRelativePathByGuid(string projectGuid)
         {
             ProjectInSolution proj = (ProjectInSolution) projects[projectGuid];
-            return (proj == null) ? null : proj.RelativePath;
+            return proj?.RelativePath;
         }
 
         #endregion
diff --git a/src/Deprecated/Engine/Shared/TypeLoader.cs b/src/Deprecated/Engine/Shared/TypeLoader.cs
index b8066557901..03fc8616fdd 100644
--- a/src/Deprecated/Engine/Shared/TypeLoader.cs
+++ b/src/Deprecated/Engine/Shared/TypeLoader.cs
@@ -4,8 +4,6 @@
 using System;
 using System.IO;
 using System.Reflection;
-using System.Collections;
-using System.Globalization;
 using System.Collections.Generic;
 
 namespace Microsoft.Build.BuildEngine.Shared
@@ -52,7 +50,7 @@ AssemblyLoadInfo assembly
 
             // Maybe we've already cracked open this assembly before.  If so, just grab the list
             // of public desired types that we found last time.
-            List<Type> desiredTypesInAssembly = null;
+            List<Type> desiredTypesInAssembly;
             cacheOfAllDesiredTypesInAnAssembly.TryGetValue(assembly, out desiredTypesInAssembly);
 
             // If we have the assembly name (strong or weak), and we haven't cracked this assembly open
diff --git a/src/Deprecated/Engine/Shared/VisualStudioConstants.cs b/src/Deprecated/Engine/Shared/VisualStudioConstants.cs
index b5e01531931..b48c284f147 100644
--- a/src/Deprecated/Engine/Shared/VisualStudioConstants.cs
+++ b/src/Deprecated/Engine/Shared/VisualStudioConstants.cs
@@ -1,8 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-
 namespace Microsoft.Build.BuildEngine.Shared
 {
     /// <summary>
diff --git a/src/Deprecated/Engine/Shared/XMakeAttributes.cs b/src/Deprecated/Engine/Shared/XMakeAttributes.cs
index 7ca23215793..33bef0d06d8 100644
--- a/src/Deprecated/Engine/Shared/XMakeAttributes.cs
+++ b/src/Deprecated/Engine/Shared/XMakeAttributes.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Xml;
-using System.Globalization;
 
 namespace Microsoft.Build.BuildEngine.Shared
 {
diff --git a/src/Deprecated/Engine/Shared/XMakeElements.cs b/src/Deprecated/Engine/Shared/XMakeElements.cs
index 73705f027a6..49205e6f6db 100644
--- a/src/Deprecated/Engine/Shared/XMakeElements.cs
+++ b/src/Deprecated/Engine/Shared/XMakeElements.cs
@@ -1,10 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections;
 using System.Xml;
-using System.Globalization;
 
 namespace Microsoft.Build.BuildEngine.Shared
 {
diff --git a/src/Deprecated/Engine/Shared/XmlUtilities.cs b/src/Deprecated/Engine/Shared/XmlUtilities.cs
index e16d9685062..69b8ea969ea 100644
--- a/src/Deprecated/Engine/Shared/XmlUtilities.cs
+++ b/src/Deprecated/Engine/Shared/XmlUtilities.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Xml;
-using System.Text.RegularExpressions;
 
 namespace Microsoft.Build.BuildEngine.Shared
 {
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index 3b7760dbb85..6dc05efbbac 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -6,8 +6,6 @@
 using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
-using System.Reflection;
-using System.Security;
 using System.Text;
 using System.Xml;
 
@@ -351,7 +349,7 @@ private static void CreateSolutionProject(SolutionParser solution, Project msbui
             // Add a <target> element for each project we have
             foreach (ProjectInSolution proj in solution.ProjectsInOrder)
             {
-                string errorMessage = null;
+                string errorMessage;
 
                 // is it a solution folder?
                 if (proj.ProjectType == SolutionProjectType.SolutionFolder)
@@ -576,7 +574,6 @@ string subTargetName
 
             foreach (ConfigurationInSolution solutionConfiguration in solution.SolutionConfigurations)
             {
-                ProjectConfigurationInSolution projectConfiguration = null;
                 string condition = GetConditionStringForConfiguration(solutionConfiguration);
 
                 // Create the build item group for this configuration if we haven't already
@@ -586,6 +583,7 @@ string subTargetName
                     solutionConfiguration.ProjectBuildItems.Condition = condition;
                 }
 
+                ProjectConfigurationInSolution projectConfiguration;
                 if (proj.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out projectConfiguration))
                 {
                     if (projectConfiguration.IncludeInBuild)
@@ -702,8 +700,6 @@ out string addedReferenceGuids
         {
             StringBuilder referenceGuids = new StringBuilder();
 
-            string message = null;
-
             // Suffix for the reference item name. Since we need to attach additional (different) metadata to every
             // reference item, we need to have helper item lists each with only one item
             int outputReferenceItemNameSuffix = 0;
@@ -723,6 +719,7 @@ out string addedReferenceGuids
 
                     bool addCreateItem = false;
 
+                    string message;
                     if ((referencedProject.ProjectType == SolutionProjectType.ManagedProject) ||
                         ((referencedProject.ProjectType == SolutionProjectType.Unknown) && (referencedProject.CanBeMSBuildProjectFile(out message))))
                     {
@@ -752,11 +749,8 @@ out string addedReferenceGuids
                             vcbuildTask = AddResolveVCProjectOutputTaskElement(target, Path.Combine(solution.SolutionFileDirectory, Path.GetFileName(solution.SolutionFile)),
                                 referencedProject.AbsolutePath, referencedProjectConfiguration.FullName);
                         }
-                        catch (Exception e)
+                        catch (Exception e) when (!ExceptionHandling.NotExpectedException(e))
                         {
-                            if (ExceptionHandling.NotExpectedException(e))
-                               throw;
-
                             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(false,
                                 "SubCategoryForSolutionParsingErrors",
                                 new BuildEventFileInfo(solution.SolutionFile),
@@ -835,8 +829,7 @@ string projectConfigurationName
                 importLibraryItemName.Append(subTargetName);
             }
 
-            string referenceGuidsToRemove = null;
-
+            string referenceGuidsToRemove;
             AddResolveProjectReferenceTasks(solution, msbuildProject, target, proj, solutionConfiguration,
                 referenceItemName.ToString(), importLibraryItemName.ToString(), out referenceGuidsToRemove);
 
@@ -844,13 +837,12 @@ string projectConfigurationName
                 referenceGuidsToRemove = string.Empty;
 
             string fullProjectPath = null;
-            string tmpExtension = null;
             string projectPath = null;
 
             try
             {
                 fullProjectPath = proj.AbsolutePath;
-                tmpExtension = string.Format(CultureInfo.InvariantCulture, ".tmp_{0}_{1}.vcproj", solutionConfiguration.ConfigurationName, solutionConfiguration.PlatformName);
+                string tmpExtension = string.Format(CultureInfo.InvariantCulture, ".tmp_{0}_{1}.vcproj", solutionConfiguration.ConfigurationName, solutionConfiguration.PlatformName);
                 projectPath = Path.ChangeExtension(fullProjectPath, tmpExtension);
             }
             catch (Exception e)
@@ -1292,7 +1284,7 @@ ProjectInSolution proj
                 // Find out if the web project has a project configuration for this solution configuration.
                 // (Actually, web projects only have one project configuration, so the TryGetValue should
                 // pretty much always return "true".
-                ProjectConfigurationInSolution projectConfiguration = null;
+                ProjectConfigurationInSolution projectConfiguration;
                 if (proj.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out projectConfiguration))
                 {
                     // See if the web project is marked as active for this solution configuration.  If so,
@@ -1398,9 +1390,8 @@ string subTargetName
 
                     // Update our big condition string to include this configuration.
                     conditionDescribingValidConfigurations.Append(" or ");
-                    conditionDescribingValidConfigurations.Append(
-                        String.Format(CultureInfo.InvariantCulture, "('$(AspNetConfiguration)' == '{0}')",
-                        EscapingUtilities.Escape(configurationName)));
+                    conditionDescribingValidConfigurations.AppendFormat(CultureInfo.InvariantCulture, "('$(AspNetConfiguration)' == '{0}')",
+                        EscapingUtilities.Escape(configurationName));
                 }
 
                 StringBuilder referenceItemName = new StringBuilder(GenerateSafePropertyName(proj, "References"));
@@ -1418,8 +1409,7 @@ string subTargetName
                     // of referenced projects.
                     foreach (ConfigurationInSolution solutionConfiguration in solution.SolutionConfigurations)
                     {
-                        string referenceProjectGuids = null;
-
+                        string referenceProjectGuids;
                         AddResolveProjectReferenceTasks(solution, msbuildProject, newTarget, proj, solutionConfiguration,
                             referenceItemName.ToString(), null /* don't care about native references */, out referenceProjectGuids);
                     }
@@ -1499,8 +1489,8 @@ private static string MakeIntoSafeItemName(string name)
         static internal BuildTask AddErrorWarningMessageElement(Target target, string elementType,
             bool treatAsLiteral, string textResourceName, params object[] args)
         {
-            string code = null;
-            string helpKeyword = null;
+            string code;
+            string helpKeyword;
             string text = ResourceUtilities.FormatResourceString(out code, out helpKeyword, textResourceName, args);
 
             BuildTask task = target.AddNewTask(elementType);
@@ -1549,9 +1539,8 @@ string errorMessage
 
             foreach (ConfigurationInSolution solutionConfiguration in solution.SolutionConfigurations)
             {
-                ProjectConfigurationInSolution projectConfiguration = null;
-                BuildTask newTask = null;
-
+                ProjectConfigurationInSolution projectConfiguration;
+                BuildTask newTask;
                 if (proj.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out projectConfiguration))
                 {
                     if (projectConfiguration.IncludeInBuild)
@@ -1806,8 +1795,7 @@ ConfigurationInSolution solutionConfiguration
             // add a project configuration entry for each project in the solution
             foreach (ProjectInSolution project in solution.ProjectsInOrder)
             {
-                ProjectConfigurationInSolution projectConfiguration = null;
-
+                ProjectConfigurationInSolution projectConfiguration;
                 if (project.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out projectConfiguration))
                 {
                     solutionConfigurationContents.AppendFormat(
@@ -2013,8 +2001,6 @@ private static string DetermineLikelyActiveSolutionConfiguration(SolutionParser
         /// <owner>LukaszG</owner>
         static private void ScanProjectDependencies(SolutionParser solution, Engine parentEngine, string childProjectToolsVersion, string fullSolutionConfigurationName, BuildEventContext projectBuildEventContext)
         {
-            string message = null;
-
             // Don't bother with all this if the solution configuration doesn't even exist.
             if (fullSolutionConfigurationName == null)
             {
@@ -2029,6 +2015,7 @@ static private void ScanProjectDependencies(SolutionParser solution, Engine pare
                     continue;
                 }
 
+                string message;
                 if ((project.ProjectType == SolutionProjectType.ManagedProject) ||
                     ((project.ProjectType == SolutionProjectType.Unknown) && (project.CanBeMSBuildProjectFile(out message))))
                 {
diff --git a/src/Deprecated/Engine/Solution/VCProjectParser.cs b/src/Deprecated/Engine/Solution/VCProjectParser.cs
index 0aaaa4658d5..725f09023a3 100644
--- a/src/Deprecated/Engine/Solution/VCProjectParser.cs
+++ b/src/Deprecated/Engine/Solution/VCProjectParser.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using System.Xml;
 
 namespace Microsoft.Build.BuildEngine
@@ -44,8 +43,6 @@ static internal List<string> GetReferencedProjectGuids(XmlDocument project)
         internal static bool IsStaticLibrary(XmlDocument project, string configurationName)
         {
             XmlNodeList configurationsElements = project.DocumentElement.GetElementsByTagName("Configurations");
-            XmlElement configurationElement = null;
-
             bool isStaticLibrary = false;
 
             // There should be only one configurations element
@@ -61,8 +58,7 @@ internal static bool IsStaticLibrary(XmlDocument project, string configurationNa
                         if ((string.Equals(element.Name, "Configuration", StringComparison.OrdinalIgnoreCase)) &&
                             (string.Equals(element.GetAttribute("Name"), configurationName, StringComparison.OrdinalIgnoreCase)))
                         {
-                            configurationElement = element;
-
+                            XmlElement configurationElement = element;
                             string configurationType = configurationElement.GetAttribute("ConfigurationType");
                             isStaticLibrary = (configurationType == "4");
 
diff --git a/src/Deprecated/Engine/Solution/VCWrapperProject.cs b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
index 574ab4561a9..e20945c6112 100644
--- a/src/Deprecated/Engine/Solution/VCWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
@@ -2,9 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Text;
 using System.Xml;
 using Microsoft.Build.BuildEngine.Shared;
 using Microsoft.Win32;
@@ -138,8 +136,7 @@ string fullConfigurationName
         static internal XmlDocument GenerateVCWrapperProject(Engine parentEngine, string vcProjectFilename, string toolsVersion)
         {
             string projectPath = Path.GetFullPath(vcProjectFilename);
-            Project msbuildProject = null;
-
+            Project msbuildProject;
             try
             {
                 msbuildProject = new Project(parentEngine, toolsVersion);
@@ -266,7 +263,7 @@ private static string GenerateFullPathToTool(RegistryView registryView)
                 string location = TryLocationFromRegistry(baseKey, vs9RegKey, vs9InstallDirValueName,
                     vs9RelativePathToVCBuildLayouts, vs9RelativePathToVCBuildBatch);
 
-                if (null != location)
+                if (location != null)
                 {
                     return location;
                 }
@@ -275,7 +272,7 @@ private static string GenerateFullPathToTool(RegistryView registryView)
                 location = TryLocationFromRegistry(baseKey, vc9RegKey, vc9InstallDirValueName,
                     vc9RelativePathToVCBuildLayouts, vc9RelativePathToVCBuildBatch);
 
-                if (null != location)
+                if (location != null)
                 {
                     return location;
                 }
@@ -326,7 +323,7 @@ private static string TryLocationFromRegistry(RegistryKey root, string subKeyNam
 
                         // if not found in layouts location, try the alternate dir if any,
                         // which contains vcbuild for batch installs
-                        if (null != relativePathFromValueOnBatch)
+                        if (relativePathFromValueOnBatch != null)
                         {
                             vcBuildPath = Path.Combine(rootDir, relativePathFromValueOnBatch);
                             if (File.Exists(vcBuildPath))
diff --git a/src/Deprecated/Engine/Tasks/IntrinsicTask.cs b/src/Deprecated/Engine/Tasks/IntrinsicTask.cs
index ee398d9d5dd..2633ca633bd 100644
--- a/src/Deprecated/Engine/Tasks/IntrinsicTask.cs
+++ b/src/Deprecated/Engine/Tasks/IntrinsicTask.cs
@@ -3,15 +3,11 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.BuildEngine.Shared;
 using System.Xml;
-using System.Reflection;
-using System.Globalization;
 using System.Collections;
-using System.Diagnostics;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/Utilities/EngineFileUtilities.cs b/src/Deprecated/Engine/Utilities/EngineFileUtilities.cs
index fb3af131228..34b8a79a3bc 100644
--- a/src/Deprecated/Engine/Utilities/EngineFileUtilities.cs
+++ b/src/Deprecated/Engine/Utilities/EngineFileUtilities.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
-using System.IO;
 using Microsoft.Build.BuildEngine.Shared;
 
 namespace Microsoft.Build.BuildEngine
diff --git a/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs b/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs
index f53abbf2461..deb2b0749b8 100644
--- a/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs
+++ b/src/Deprecated/Engine/Xml/BuildItemGroupChildXml.cs
@@ -3,10 +3,8 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.BuildEngine.Shared;
 using System.Xml;
-using System.Collections;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs b/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs
index 357ff686326..2dacb63d74e 100644
--- a/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs
+++ b/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs
@@ -3,10 +3,8 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.BuildEngine.Shared;
 using System.Xml;
-using System.Collections;
 
 namespace Microsoft.Build.BuildEngine
 {
diff --git a/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs b/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs
index 9287f2aae5d..50cb627cc52 100644
--- a/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs
+++ b/src/Deprecated/Engine/Xml/ProjectXmlUtilities.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using System.Xml;
 using Microsoft.Build.BuildEngine.Shared;
 
diff --git a/src/Framework.UnitTests/Attribute_Tests.cs b/src/Framework.UnitTests/Attribute_Tests.cs
index e94e9d66173..7e30539fb15 100644
--- a/src/Framework.UnitTests/Attribute_Tests.cs
+++ b/src/Framework.UnitTests/Attribute_Tests.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Reflection;
 
 using Microsoft.Build.Framework;
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index 0d39dc25f6e..96af6943e1f 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -30,6 +30,9 @@
   </ItemGroup>
 
   <ItemGroup>
+    <Compile Include="..\Shared\ChangeWaves.cs">
+      <Link>SharedUtilities\ChangeWaves.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\UnitTests\TestEnvironment.cs" />
     <Compile Include="..\Shared\FileUtilities.cs" />
     <Compile Include="..\Shared\TempFileUtilities.cs" />
diff --git a/src/Framework/BuildEngineResult.cs b/src/Framework/BuildEngineResult.cs
index 34f7cbcd135..3035212b8cc 100644
--- a/src/Framework/BuildEngineResult.cs
+++ b/src/Framework/BuildEngineResult.cs
@@ -2,10 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
-using System.Text;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index b2b9084973a..5e56b0c79aa 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Runtime.InteropServices;
 using System.Runtime.Serialization;
 using System.IO;
 using Microsoft.Build.Shared;
diff --git a/src/Framework/BuildEventContext.cs b/src/Framework/BuildEventContext.cs
index a66f2cd262a..edde77d5fbb 100644
--- a/src/Framework/BuildEventContext.cs
+++ b/src/Framework/BuildEventContext.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
-using System.Globalization;
 
 namespace Microsoft.Build.Framework
 {
@@ -246,7 +243,7 @@ public override bool Equals(object obj)
                 return true;
             }
 
-            if (ReferenceEquals(obj, null))
+            if (obj is null)
             {
                 return false;
             }
@@ -273,7 +270,7 @@ public override bool Equals(object obj)
                 return true;
             }
 
-            if (ReferenceEquals(left, null))
+            if (left is null)
             {
                 return false;
             }
diff --git a/src/Framework/BuildStartedEventArgs.cs b/src/Framework/BuildStartedEventArgs.cs
index cf7482812ef..a177576f7e2 100644
--- a/src/Framework/BuildStartedEventArgs.cs
+++ b/src/Framework/BuildStartedEventArgs.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Runtime.InteropServices;
 using System;
 using System.Collections.Generic;
 
diff --git a/src/Framework/BuildStatusEventArgs.cs b/src/Framework/BuildStatusEventArgs.cs
index ec63ccafa41..0d096f830ef 100644
--- a/src/Framework/BuildStatusEventArgs.cs
+++ b/src/Framework/BuildStatusEventArgs.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Runtime.InteropServices;
 using System;
 
 namespace Microsoft.Build.Framework
diff --git a/src/Framework/BuildWarningEventArgs.cs b/src/Framework/BuildWarningEventArgs.cs
index 0bf9641b45d..5b37aa338c1 100644
--- a/src/Framework/BuildWarningEventArgs.cs
+++ b/src/Framework/BuildWarningEventArgs.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Runtime.InteropServices;
 using System;
 using System.IO;
 using Microsoft.Build.Shared;
diff --git a/src/Framework/CriticalBuildMessageEventArgs.cs b/src/Framework/CriticalBuildMessageEventArgs.cs
index c9ab167b834..2bc8853a295 100644
--- a/src/Framework/CriticalBuildMessageEventArgs.cs
+++ b/src/Framework/CriticalBuildMessageEventArgs.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/ExternalProjectFinishedEventArgs.cs b/src/Framework/ExternalProjectFinishedEventArgs.cs
index 4fae3f9eb48..ab5a72406dc 100644
--- a/src/Framework/ExternalProjectFinishedEventArgs.cs
+++ b/src/Framework/ExternalProjectFinishedEventArgs.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Text;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/ExternalProjectStartedEventArgs.cs b/src/Framework/ExternalProjectStartedEventArgs.cs
index f0dea23e6ea..d086130dfab 100644
--- a/src/Framework/ExternalProjectStartedEventArgs.cs
+++ b/src/Framework/ExternalProjectStartedEventArgs.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Text;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/FxCopExclusions/Microsoft.Build.Framework.Suppressions.cs b/src/Framework/FxCopExclusions/Microsoft.Build.Framework.Suppressions.cs
index 8f3195f091a..9596e6a1cbd 100644
--- a/src/Framework/FxCopExclusions/Microsoft.Build.Framework.Suppressions.cs
+++ b/src/Framework/FxCopExclusions/Microsoft.Build.Framework.Suppressions.cs
@@ -4,8 +4,6 @@
 // To Use:
 // Add add module level suppressions to this file to have them suppressed in the assembly
 
-using System.Diagnostics.CodeAnalysis;
-
 #if CODE_ANALYSIS
 [module: SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
 [module: SuppressMessage("Microsoft.MSInternal", "CA905:SystemAndMicrosoftNamespacesRequireApproval", Scope="namespace", Target="Microsoft.Build.CommandLine", Justification="This is an approved namespace.")]
diff --git a/src/Framework/IEventSource.cs b/src/Framework/IEventSource.cs
index 9c9d7fa9ab5..f0cea1f1ea4 100644
--- a/src/Framework/IEventSource.cs
+++ b/src/Framework/IEventSource.cs
@@ -1,8 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Runtime.InteropServices;
-
 namespace Microsoft.Build.Framework
 {
     /// <summary>
diff --git a/src/Framework/IGeneratedTask.cs b/src/Framework/IGeneratedTask.cs
index 131548629f1..8bb038dc415 100644
--- a/src/Framework/IGeneratedTask.cs
+++ b/src/Framework/IGeneratedTask.cs
@@ -1,10 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
-using System.Text;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/ITask.cs b/src/Framework/ITask.cs
index 28f1e6989ca..de05943b10a 100644
--- a/src/Framework/ITask.cs
+++ b/src/Framework/ITask.cs
@@ -1,8 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Runtime.InteropServices;
-
 namespace Microsoft.Build.Framework
 {
     /// <summary>
diff --git a/src/Framework/ITaskFactory.cs b/src/Framework/ITaskFactory.cs
index cce384af4f3..4c8c97bb209 100644
--- a/src/Framework/ITaskFactory.cs
+++ b/src/Framework/ITaskFactory.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/ITaskFactory2.cs b/src/Framework/ITaskFactory2.cs
index 3a3c7cca912..948e4dfca45 100644
--- a/src/Framework/ITaskFactory2.cs
+++ b/src/Framework/ITaskFactory2.cs
@@ -1,9 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Text;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/ITaskItem2.cs b/src/Framework/ITaskItem2.cs
index ce33b3cd535..ef4c557a5bd 100644
--- a/src/Framework/ITaskItem2.cs
+++ b/src/Framework/ITaskItem2.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections;
 using System.Runtime.InteropServices;
-using System.Collections.Generic;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 5d73b6aa153..abc5fd12d93 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -8,6 +8,12 @@ namespace Microsoft.Build.Eventing
     [EventSource(Name = "Microsoft-Build")]
     internal sealed class MSBuildEventSource : EventSource
     {
+        public static class Keywords
+        {
+            public const EventKeywords All = (EventKeywords)0x1;
+            public const EventKeywords PerformanceLog = (EventKeywords)0x2;
+        }
+
         /// <summary>
         /// define the singleton instance of the event source
         /// </summary>
@@ -21,14 +27,14 @@ private MSBuildEventSource() { }
         /// Call this method to notify listeners of information relevant to collecting a set of items, mutating them in a specified way, and saving the results.
         /// </summary>
         /// <param name="itemType">The type of the item being mutated.</param>
-        [Event(1)]
+        [Event(1, Keywords = Keywords.All)]
         public void ApplyLazyItemOperationsStart(string itemType)
         {
             WriteEvent(1, itemType);
         }
 
         /// <param name="itemType">The type of the item being mutated.</param>
-        [Event(2)]
+        [Event(2, Keywords = Keywords.All)]
         public void ApplyLazyItemOperationsStop(string itemType)
         {
             WriteEvent(2, itemType);
@@ -37,13 +43,13 @@ public void ApplyLazyItemOperationsStop(string itemType)
         /// <summary>
         /// Call this method to notify listeners of information relevant to the setup for a BuildManager to receive build requests.
         /// </summary>
-        [Event(3)]
+        [Event(3, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void BuildStart()
         {
             WriteEvent(3);
         }
 
-        [Event(4)]
+        [Event(4, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void BuildStop()
         {
             WriteEvent(4);
@@ -53,7 +59,7 @@ public void BuildStop()
         /// Call this method to notify listeners of information of how a project file built.
         /// <param name="projectPath">Filename of the project being built.</param>
         /// </summary>
-        [Event(5)]
+        [Event(5, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void BuildProjectStart(string projectPath)
         {
             WriteEvent(5, projectPath);
@@ -61,26 +67,26 @@ public void BuildProjectStart(string projectPath)
 
         /// <param name="projectPath">Filename of the project being built.</param>
         /// <param name="targets">Names of the targets that built.</param>
-        [Event(6)]
+        [Event(6, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void BuildProjectStop(string projectPath, string targets)
         {
             WriteEvent(6, projectPath, targets);
         }
 
-        [Event(7)]
+        [Event(7, Keywords = Keywords.All)]
         public void RarComputeClosureStart()
         {
             WriteEvent(7);
         }
 
-        [Event(8)]
+        [Event(8, Keywords = Keywords.All)]
         public void RarComputeClosureStop()
         {
             WriteEvent(8);
         }
 
         /// <param name="condition">The condition being evaluated.</param>
-        [Event(9)]
+        [Event(9, Keywords = Keywords.All)]
         public void EvaluateConditionStart(string condition)
         {
             WriteEvent(9, condition);
@@ -88,7 +94,7 @@ public void EvaluateConditionStart(string condition)
 
         /// <param name="condition">The condition being evaluated.</param>
         /// <param name="result">The result of evaluating the condition.</param>
-        [Event(10)]
+        [Event(10, Keywords = Keywords.All)]
         public void EvaluateConditionStop(string condition, bool result)
         {
             WriteEvent(10, condition, result);
@@ -98,122 +104,122 @@ public void EvaluateConditionStop(string condition, bool result)
         /// Call this method to notify listeners of how the project data was evaluated.
         /// </summary>
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(11)]
+        [Event(11, Keywords = Keywords.All)]
         public void EvaluateStart(string projectFile)
         {
             WriteEvent(11, projectFile);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(12)]
+        [Event(12, Keywords = Keywords.All)]
         public void EvaluatePass0Start(string projectFile)
         {
             WriteEvent(12, projectFile);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(13)]
+        [Event(13, Keywords = Keywords.All)]
         public void EvaluatePass0Stop(string projectFile)
         {
             WriteEvent(13, projectFile);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(14)]
+        [Event(14, Keywords = Keywords.All)]
         public void EvaluatePass1Start(string projectFile)
         {
             WriteEvent(14, projectFile);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(15)]
+        [Event(15, Keywords = Keywords.All)]
         public void EvaluatePass1Stop(string projectFile)
         {
             WriteEvent(15, projectFile);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(16)]
+        [Event(16, Keywords = Keywords.All)]
         public void EvaluatePass2Start(string projectFile)
         {
             WriteEvent(16, projectFile);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(17)]
+        [Event(17, Keywords = Keywords.All)]
         public void EvaluatePass2Stop(string projectFile)
         {
             WriteEvent(17, projectFile);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(18)]
+        [Event(18, Keywords = Keywords.All)]
         public void EvaluatePass3Start(string projectFile)
         {
             WriteEvent(18, projectFile);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(19)]
+        [Event(19, Keywords = Keywords.All)]
         public void EvaluatePass3Stop(string projectFile)
         {
             WriteEvent(19, projectFile);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(20)]
+        [Event(20, Keywords = Keywords.All)]
         public void EvaluatePass4Start(string projectFile)
         {
             WriteEvent(20, projectFile);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(21)]
+        [Event(21, Keywords = Keywords.All)]
         public void EvaluatePass4Stop(string projectFile)
         {
             WriteEvent(21, projectFile);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(22)]
+        [Event(22, Keywords = Keywords.All)]
         public void EvaluatePass5Start(string projectFile)
         {
             WriteEvent(22, projectFile);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(23)]
+        [Event(23, Keywords = Keywords.All)]
         public void EvaluatePass5Stop(string projectFile)
         {
             WriteEvent(23, projectFile);
         }
 
         /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(24)]
+        [Event(24, Keywords = Keywords.All)]
         public void EvaluateStop(string projectFile)
         {
             WriteEvent(24, projectFile);
         }
 
-        [Event(25)]
+        [Event(25, Keywords = Keywords.All)]
         public void GenerateResourceOverallStart()
         {
             WriteEvent(25);
         }
 
-        [Event(26)]
+        [Event(26, Keywords = Keywords.All)]
         public void GenerateResourceOverallStop()
         {
             WriteEvent(26);
         }
 
-        [Event(27)]
+        [Event(27, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void RarOverallStart()
         {
             WriteEvent(27);
         }
 
-        [Event(28)]
+        [Event(28, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void RarOverallStop()
         {
             WriteEvent(28);
@@ -225,7 +231,7 @@ public void RarOverallStop()
         /// <param name="rootDirectory">Source of files to glob.</param>
         /// <param name="glob">Pattern, possibly with wildcard(s) to be expanded.</param>
         /// <param name="excludedPatterns">Patterns not to expand.</param>
-        [Event(41)]
+        [Event(41, Keywords = Keywords.All)]
         public void ExpandGlobStart(string rootDirectory, string glob, string excludedPatterns)
         {
             WriteEvent(41, rootDirectory, glob, excludedPatterns);
@@ -234,7 +240,7 @@ public void ExpandGlobStart(string rootDirectory, string glob, string excludedPa
         /// <param name="rootDirectory">Source of files to glob.</param>
         /// <param name="glob">Pattern, possibly with wildcard(s) to be expanded.</param>
         /// <param name="excludedPatterns">Patterns not to expand.</param>
-        [Event(42)]
+        [Event(42, Keywords = Keywords.All)]
         public void ExpandGlobStop(string rootDirectory, string glob, string excludedPatterns)
         {
             WriteEvent(42, rootDirectory, glob, excludedPatterns);
@@ -244,26 +250,26 @@ public void ExpandGlobStop(string rootDirectory, string glob, string excludedPat
         /// Call this method to notify listeners of timing related to loading an XmlDocumentWithLocation from a path.
         /// <param name="fullPath">Path to the document to load.</param>
         /// </summary>
-        [Event(29)]
+        [Event(29, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void LoadDocumentStart(string fullPath)
         {
             WriteEvent(29, fullPath);
         }
 
         /// <param name="fullPath">Path to the document to load.</param>
-        [Event(30)]
+        [Event(30, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void LoadDocumentStop(string fullPath)
         {
             WriteEvent(30, fullPath);
         }
 
-        [Event(31)]
+        [Event(31, Keywords = Keywords.All)]
         public void RarLogResultsStart()
         {
             WriteEvent(31);
         }
 
-        [Event(32)]
+        [Event(32, Keywords = Keywords.All)]
         public void RarLogResultsStop()
         {
             WriteEvent(32);
@@ -273,14 +279,14 @@ public void RarLogResultsStop()
         /// Call this method to notify listeners of profiling for the function that parses an XML document into a ProjectRootElement.
         /// </summary>
         /// <param name="projectFileName">Relevant information about where in the run of the progam it is.</param>
-        [Event(33)]
+        [Event(33, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void ParseStart(string projectFileName)
         {
             WriteEvent(33, projectFileName);
         }
 
         /// <param name="projectFileName">Relevant information about where in the run of the progam it is.</param>
-        [Event(34)]
+        [Event(34, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void ParseStop(string projectFileName)
         {
             WriteEvent(34, projectFileName);
@@ -289,53 +295,53 @@ public void ParseStop(string projectFileName)
         /// <summary>
         /// Call this method to notify listeners of profiling for the method that removes blacklisted references from the reference table. It puts primary and dependency references in invalid file lists.
         /// </summary>
-        [Event(35)]
+        [Event(35, Keywords = Keywords.All)]
         public void RarRemoveReferencesMarkedForExclusionStart()
         {
             WriteEvent(35);
         }
 
-        [Event(36)]
+        [Event(36, Keywords = Keywords.All)]
         public void RarRemoveReferencesMarkedForExclusionStop()
         {
             WriteEvent(36);
         }
 
-        [Event(37)]
+        [Event(37, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void RequestThreadProcStart()
         {
             WriteEvent(37);
         }
 
-        [Event(38)]
+        [Event(38, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void RequestThreadProcStop()
         {
             WriteEvent(38);
         }
 
         /// <param name="fileLocation">Project file's location.</param>
-        [Event(39)]
+        [Event(39, Keywords = Keywords.All)]
         public void SaveStart(string fileLocation)
         {
             WriteEvent(39, fileLocation);
         }
 
         /// <param name="fileLocation">Project file's location.</param>
-        [Event(40)]
+        [Event(40, Keywords = Keywords.All)]
         public void SaveStop(string fileLocation)
         {
             WriteEvent(40, fileLocation);
         }
 
         /// <param name="targetName">The name of the target being executed.</param>
-        [Event(43)]
+        [Event(43, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void TargetStart(string targetName)
         {
             WriteEvent(43, targetName);
         }
 
         /// <param name="targetName">The name of the target being executed.</param>
-        [Event(44)]
+        [Event(44, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void TargetStop(string targetName)
         {
             WriteEvent(44, targetName);
@@ -345,68 +351,68 @@ public void TargetStop(string targetName)
         /// Call this method to notify listeners of the start of a build as called from the command line.
         /// </summary>
         /// <param name="commandLine">The command line used to run MSBuild.</param>
-        [Event(45)]
+        [Event(45, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void MSBuildExeStart(string commandLine)
         {
             WriteEvent(45, commandLine);
         }
 
         /// <param name="commandLine">The command line used to run MSBuild.</param>
-        [Event(46)]
+        [Event(46, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void MSBuildExeStop(string commandLine)
         {
             WriteEvent(46, commandLine);
         }
 
-        [Event(47)]
+        [Event(47, Keywords = Keywords.All)]
         public void ExecuteTaskStart(string taskName, int taskID)
         {
             WriteEvent(47, taskName, taskID);
         }
 
-        [Event(48)]
+        [Event(48, Keywords = Keywords.All)]
         public void ExecuteTaskStop(string taskName, int taskID)
         {
             WriteEvent(48, taskName, taskID);
         }
 
-        [Event(49)]
+        [Event(49, Keywords = Keywords.All)]
         public void ExecuteTaskYieldStart(string taskName, int taskID)
         {
             WriteEvent(49, taskName, taskID);
         }
 
-        [Event(50)]
+        [Event(50, Keywords = Keywords.All)]
         public void ExecuteTaskYieldStop(string taskName, int taskID)
         {
             WriteEvent(50, taskName, taskID);
         }
 
-        [Event(51)]
+        [Event(51, Keywords = Keywords.All)]
         public void ExecuteTaskReacquireStart(string taskName, int taskID)
         {
             WriteEvent(51, taskName, taskID);
         }
 
-        [Event(52)]
+        [Event(52, Keywords = Keywords.All)]
         public void ExecuteTaskReacquireStop(string taskName, int taskID)
         {
             WriteEvent(52, taskName, taskID);
         }
 
-        [Event(53)]
+        [Event(53, Keywords = Keywords.All)]
         public void ProjectGraphConstructionStart(string graphEntryPoints)
         {
             WriteEvent(53, graphEntryPoints);
         }
 
-        [Event(54)]
+        [Event(54, Keywords = Keywords.All)]
         public void ProjectGraphConstructionStop(string graphEntryPoints)
         {
             WriteEvent(54, graphEntryPoints);
         }
 
-        [Event(55)]
+        [Event(55, Keywords = Keywords.All)]
         public void PacketReadSize(int size)
         {
             WriteEvent(55, size);
diff --git a/src/Framework/MetaProjectGeneratedEventArgs.cs b/src/Framework/MetaProjectGeneratedEventArgs.cs
index 68504864230..d690e9aa215 100644
--- a/src/Framework/MetaProjectGeneratedEventArgs.cs
+++ b/src/Framework/MetaProjectGeneratedEventArgs.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/Profiler/EvaluationIdProvider.cs b/src/Framework/Profiler/EvaluationIdProvider.cs
index 7d4e4d17aca..a348f793a94 100644
--- a/src/Framework/Profiler/EvaluationIdProvider.cs
+++ b/src/Framework/Profiler/EvaluationIdProvider.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Diagnostics;
 using System.Threading;
 
diff --git a/src/Framework/Profiler/EvaluationLocation.cs b/src/Framework/Profiler/EvaluationLocation.cs
index b4a6eed4fe1..61ff4933c84 100644
--- a/src/Framework/Profiler/EvaluationLocation.cs
+++ b/src/Framework/Profiler/EvaluationLocation.cs
@@ -255,16 +255,15 @@ public override string ToString()
         public override int GetHashCode()
         {
             var hashCode = 1198539463;
-            hashCode = (hashCode * -1521134295) + base.GetHashCode();
             hashCode = (hashCode * -1521134295) + Id.GetHashCode();
             hashCode = (hashCode * -1521134295) + EqualityComparer<long?>.Default.GetHashCode(ParentId);
-            hashCode = (hashCode * -1521134295) + EvaluationPass.GetHashCode();
+            hashCode = (hashCode * -1521134295) + EqualityComparer<EvaluationPass>.Default.GetHashCode(EvaluationPass);
             hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(EvaluationPassDescription);
             hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(File);
             hashCode = (hashCode * -1521134295) + EqualityComparer<int?>.Default.GetHashCode(Line);
             hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ElementName);
             hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(ElementDescription);
-            hashCode = (hashCode * -1521134295) + Kind.GetHashCode();
+            hashCode = (hashCode * -1521134295) + EqualityComparer<EvaluationLocationKind>.Default.GetHashCode(Kind);
             return hashCode;
         }
 
diff --git a/src/Framework/Profiler/ProfilerResult.cs b/src/Framework/Profiler/ProfilerResult.cs
index d4455ee0e36..43cf2d62331 100644
--- a/src/Framework/Profiler/ProfilerResult.cs
+++ b/src/Framework/Profiler/ProfilerResult.cs
@@ -86,7 +86,6 @@ public override bool Equals(object obj)
         public override int GetHashCode()
         {
             var hashCode = -2131368567;
-            hashCode = (hashCode * -1521134295) + base.GetHashCode();
             hashCode = (hashCode * -1521134295) + EqualityComparer<TimeSpan>.Default.GetHashCode(InclusiveTime);
             hashCode = (hashCode * -1521134295) + EqualityComparer<TimeSpan>.Default.GetHashCode(ExclusiveTime);
             hashCode = (hashCode * -1521134295) + NumberOfHits.GetHashCode();
diff --git a/src/Framework/ProjectFinishedEventArgs.cs b/src/Framework/ProjectFinishedEventArgs.cs
index b7c0ce6746d..7ae29c7215f 100644
--- a/src/Framework/ProjectFinishedEventArgs.cs
+++ b/src/Framework/ProjectFinishedEventArgs.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Runtime.InteropServices;
 using System;
 using System.IO;
 using Microsoft.Build.Shared;
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index 52d7e8ccb7d..b1bd90f8076 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Runtime.InteropServices;
 using System;
 using System.Collections;
 using System.IO;
diff --git a/src/Framework/Properties/AssemblyInfo.cs b/src/Framework/Properties/AssemblyInfo.cs
index 426cb913abf..cb201c360de 100644
--- a/src/Framework/Properties/AssemblyInfo.cs
+++ b/src/Framework/Properties/AssemblyInfo.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
 using System.Resources;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
@@ -39,7 +38,6 @@
 
 [assembly: InternalsVisibleTo("Microsoft.Build.Framework.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
-[assembly: InternalsVisibleTo("Microsoft.Build.Framework.Whidbey.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Utilities.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
diff --git a/src/Framework/Sdk/SdkReference.cs b/src/Framework/Sdk/SdkReference.cs
index 9be25528bcc..f48c8444bbc 100644
--- a/src/Framework/Sdk/SdkReference.cs
+++ b/src/Framework/Sdk/SdkReference.cs
@@ -50,7 +50,7 @@ public SdkReference(string name, string version, string minimumVersion)
         /// <returns></returns>
         public bool Equals(SdkReference other)
         {
-            if (ReferenceEquals(null, other)) return false;
+            if (other is null) return false;
             if (ReferenceEquals(this, other)) return true;
             return string.Equals(Name, other.Name, StringComparison.OrdinalIgnoreCase) &&
                    string.Equals(Version, other.Version, StringComparison.OrdinalIgnoreCase) &&
@@ -94,7 +94,7 @@ public static bool TryParse(string sdk, out SdkReference sdkReference)
         /// <inheritdoc />
         public override bool Equals(object obj)
         {
-            if (ReferenceEquals(null, obj)) return false;
+            if (obj is null) return false;
             if (ReferenceEquals(this, obj)) return true;
             return obj is SdkReference && Equals((SdkReference) obj);
         }
diff --git a/src/Framework/Sdk/SdkResultItem.cs b/src/Framework/Sdk/SdkResultItem.cs
index ca76abd1421..5c24ad028b8 100644
--- a/src/Framework/Sdk/SdkResultItem.cs
+++ b/src/Framework/Sdk/SdkResultItem.cs
@@ -3,9 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/TargetFinishedEventArgs.cs b/src/Framework/TargetFinishedEventArgs.cs
index ff5add204fb..c4951de6c61 100644
--- a/src/Framework/TargetFinishedEventArgs.cs
+++ b/src/Framework/TargetFinishedEventArgs.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Runtime.InteropServices;
 using System;
 using System.IO;
 using System.Collections;
diff --git a/src/Framework/TargetStartedEventArgs.cs b/src/Framework/TargetStartedEventArgs.cs
index d33fd2b7280..69b2ae7a1db 100644
--- a/src/Framework/TargetStartedEventArgs.cs
+++ b/src/Framework/TargetStartedEventArgs.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Runtime.InteropServices;
 using System;
 using System.IO;
 using Microsoft.Build.Shared;
diff --git a/src/Framework/TaskFinishedEventArgs.cs b/src/Framework/TaskFinishedEventArgs.cs
index 81fc6211552..f8a8e1ef918 100644
--- a/src/Framework/TaskFinishedEventArgs.cs
+++ b/src/Framework/TaskFinishedEventArgs.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Runtime.InteropServices;
 using System;
 using System.IO;
 using Microsoft.Build.Shared;
diff --git a/src/Framework/TaskPropertyInfo.cs b/src/Framework/TaskPropertyInfo.cs
index bbda09f9634..7180c722eed 100644
--- a/src/Framework/TaskPropertyInfo.cs
+++ b/src/Framework/TaskPropertyInfo.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/TestInfo.cs b/src/Framework/TestInfo.cs
index 3fd75696ec0..1d2ebbb32bb 100644
--- a/src/Framework/TestInfo.cs
+++ b/src/Framework/TestInfo.cs
@@ -1,10 +1,4 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
-namespace Microsoft.Build.Framework
+﻿namespace Microsoft.Build.Framework
 {
     //  This is a central place to keep track of whether tests are running or not.  Test startup code
     //  will set this to true.  It is consumed in BuildEnvironmentHelper.  However, since that class
diff --git a/src/Framework/XamlTypes/Argument.cs b/src/Framework/XamlTypes/Argument.cs
index 1d61487e8fb..8620f4305b1 100644
--- a/src/Framework/XamlTypes/Argument.cs
+++ b/src/Framework/XamlTypes/Argument.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.ComponentModel;
-using System.Windows.Markup;
 
 namespace Microsoft.Build.Framework.XamlTypes
 {
diff --git a/src/Framework/XamlTypes/Category.cs b/src/Framework/XamlTypes/Category.cs
index 6b8db83241d..b67ff735563 100644
--- a/src/Framework/XamlTypes/Category.cs
+++ b/src/Framework/XamlTypes/Category.cs
@@ -1,9 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.ComponentModel;
-using System.Windows.Markup;
 
 namespace Microsoft.Build.Framework.XamlTypes
 {
diff --git a/src/Framework/XamlTypes/CategorySchema.cs b/src/Framework/XamlTypes/CategorySchema.cs
index c35077df14e..4f684ba7f4c 100644
--- a/src/Framework/XamlTypes/CategorySchema.cs
+++ b/src/Framework/XamlTypes/CategorySchema.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
diff --git a/src/Framework/XamlTypes/DataSource.cs b/src/Framework/XamlTypes/DataSource.cs
index 515bbaa392c..52248fedf67 100644
--- a/src/Framework/XamlTypes/DataSource.cs
+++ b/src/Framework/XamlTypes/DataSource.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.ComponentModel;
-using System.Windows.Markup;
 
 namespace Microsoft.Build.Framework.XamlTypes
 {
diff --git a/src/Framework/XamlTypes/DynamicEnumProperty.cs b/src/Framework/XamlTypes/DynamicEnumProperty.cs
index 3aca6f3ab18..3e090dd3ac4 100644
--- a/src/Framework/XamlTypes/DynamicEnumProperty.cs
+++ b/src/Framework/XamlTypes/DynamicEnumProperty.cs
@@ -1,10 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
-using System.Windows.Markup;
 
 namespace Microsoft.Build.Framework.XamlTypes
 {
diff --git a/src/Framework/XamlTypes/ItemType.cs b/src/Framework/XamlTypes/ItemType.cs
index 95c2ccb121a..c83c628f4b0 100644
--- a/src/Framework/XamlTypes/ItemType.cs
+++ b/src/Framework/XamlTypes/ItemType.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.ComponentModel;
-using System.Windows.Markup;
 
 namespace Microsoft.Build.Framework.XamlTypes
 {
diff --git a/src/Framework/XamlTypes/Rule.cs b/src/Framework/XamlTypes/Rule.cs
index caac61eec3a..5893a27acf7 100644
--- a/src/Framework/XamlTypes/Rule.cs
+++ b/src/Framework/XamlTypes/Rule.cs
@@ -422,7 +422,7 @@ public List<Category> EvaluatedCategories
                 // check-lock-check pattern DOESN'T work here because two fields get initialized within this lazy initialization method.
                 lock (_syncObject)
                 {
-                    if (null == _evaluatedCategories)
+                    if (_evaluatedCategories == null)
                     {
                         CreateCategoryNamePropertyListMap();
                     }
@@ -453,7 +453,7 @@ public OrderedDictionary GetPropertiesByCategory()
             // check-lock-check pattern DOESN'T work here because two fields get initialized within this lazy initialization method.
             lock (_syncObject)
             {
-                if (null == _categoryNamePropertyListMap)
+                if (_categoryNamePropertyListMap == null)
                 {
                     CreateCategoryNamePropertyListMap();
                 }
@@ -471,7 +471,7 @@ public IList<BaseProperty> GetPropertiesInCategory(string categoryName)
             // check-lock-check pattern DOESN'T work here because two fields get initialized within this lazy initialization method.
             lock (_syncObject)
             {
-                if (null == _categoryNamePropertyListMap)
+                if (_categoryNamePropertyListMap == null)
                 {
                     CreateCategoryNamePropertyListMap();
                 }
@@ -557,7 +557,7 @@ public IEnumerable<object> GetSchemaObjects(Type type)
         /// </summary>
         private void Initialize()
         {
-            if (null != Properties)
+            if (Properties != null)
             {
                 // Set parent pointers on all containing properties.
                 foreach (BaseProperty property in Properties)
@@ -577,7 +577,7 @@ private void CreateCategoryNamePropertyListMap()
             {
                 _evaluatedCategories = new List<Category>();
 
-                if (null != Categories)
+                if (Categories != null)
                 {
                     _evaluatedCategories.AddRange(Categories);
                 }
diff --git a/src/Framework/XamlTypes/RuleSchema.cs b/src/Framework/XamlTypes/RuleSchema.cs
index fdbaadba3a2..a4369541ea9 100644
--- a/src/Framework/XamlTypes/RuleSchema.cs
+++ b/src/Framework/XamlTypes/RuleSchema.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
diff --git a/src/Framework/XamlTypes/StringListProperty.cs b/src/Framework/XamlTypes/StringListProperty.cs
index 5de191f47ff..d3c6a74b503 100644
--- a/src/Framework/XamlTypes/StringListProperty.cs
+++ b/src/Framework/XamlTypes/StringListProperty.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
-using System.ComponentModel;
-
 namespace Microsoft.Build.Framework.XamlTypes
 {
     /// <summary>
diff --git a/src/MSBuild.UnitTests/PerfLog_Tests.cs b/src/MSBuild.UnitTests/PerfLog_Tests.cs
new file mode 100644
index 00000000000..b39f192a446
--- /dev/null
+++ b/src/MSBuild.UnitTests/PerfLog_Tests.cs
@@ -0,0 +1,108 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Globalization;
+using System.IO;
+using System.Linq;
+using System.Threading;
+
+using Microsoft.Build.CommandLine;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests.Shared;
+using Xunit;
+using Xunit.Abstractions;
+using Shouldly;
+using System.IO.Compression;
+using System.Reflection;
+
+namespace Microsoft.Build.UnitTests
+{
+    public class PerfLogTests
+    {
+#if USE_MSBUILD_DLL_EXTN
+        private const string MSBuildExeName = "MSBuild.dll";
+#else
+        private const string MSBuildExeName = "MSBuild.exe";
+#endif
+
+        private readonly ITestOutputHelper _output;
+
+        public PerfLogTests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        [Fact]
+        [Trait("Category", "mono-osx-failing")] // Disable on Mono OSX, since Mono doesn't implement EventSource.
+        public void TestPerfLogEnabledProducedLogFile()
+        {
+            using (TestEnvironment testEnv = TestEnvironment.Create(_output))
+            {
+                // Setup perf log.
+                TransientTestFolder perfLogFolder = testEnv.CreateFolder(createFolder: true);
+                testEnv.SetEnvironmentVariable("DOTNET_PERFLOG_DIR", perfLogFolder.Path);
+
+                // Setup project directory.
+                TransientTestFolder projectFolder = testEnv.CreateFolder(createFolder: true);
+                TransientTestFile classLibrary = testEnv.CreateFile(projectFolder, "ClassLibrary.csproj",
+                    @"<Project>
+                  <Target Name=""ClassLibraryTarget"">
+                      <Message Text=""ClassLibraryBuilt""/>
+                  </Target>
+                  </Project>
+                    ");
+
+                string projectPath = Path.Combine(projectFolder.Path, "ClassLibrary.csproj");
+                string msbuildParameters = "\"" + projectPath + "\"";
+
+                RunnerUtilities.ExecMSBuild(msbuildParameters, out bool successfulExit);
+                successfulExit.ShouldBeTrue();
+
+                // Look for the file.
+                // NOTE: We don't explicitly look for one file because it's possible that more components will add files that will show up here.
+                // It's most important to ensure that at least one file shows up because any others that show up will be there because MSBuild properly
+                // enabled this functionality.
+                string[] files = Directory.GetFiles(perfLogFolder.Path, "perf-*.log");
+                files.ShouldNotBeEmpty();
+                files.ShouldAllBe(f => new FileInfo(f).Length > 0);
+            }
+        }
+
+        [Fact]
+        public void TestPerfLogDirectoryDoesNotExist()
+        {
+            using (TestEnvironment testEnv = TestEnvironment.Create(_output))
+            {
+                // Setup invalid perf log directory.
+                TransientTestFolder perfLogFolder = testEnv.CreateFolder(createFolder: true);
+                string perfLogPath = Path.Combine(perfLogFolder.Path, "logs");
+                testEnv.SetEnvironmentVariable("DOTNET_PERFLOG_DIR", perfLogPath);
+
+                // Setup project directory.
+                TransientTestFolder projectFolder = testEnv.CreateFolder(createFolder: true);
+                TransientTestFile classLibrary = testEnv.CreateFile(projectFolder, "ClassLibrary.csproj",
+                    @"<Project>
+                  <Target Name=""ClassLibraryTarget"">
+                      <Message Text=""ClassLibraryBuilt""/>
+                  </Target>
+                  </Project>
+                    ");
+
+                string projectPath = Path.Combine(projectFolder.Path, "ClassLibrary.csproj");
+                string msbuildParameters = "\"" + projectPath + "\"";
+
+                Directory.Exists(perfLogPath).ShouldBeFalse();
+
+                RunnerUtilities.ExecMSBuild(msbuildParameters, out bool successfulExit);
+                successfulExit.ShouldBeTrue();
+
+                Directory.Exists(perfLogPath).ShouldBeFalse();
+            }
+        }
+    }
+}
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index a2cc9a8d075..06997104d73 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -437,15 +437,35 @@ public void ExtractSwitchParametersTest()
         }
 
         [Fact]
-        public void Help()
+        public void GetLengthOfSwitchIndicatorTest()
         {
-                MSBuildApp.Execute(
+            var commandLineSwitchWithSlash = "/Switch";
+            var commandLineSwitchWithSingleDash = "-Switch";
+            var commandLineSwitchWithDoubleDash = "--Switch";
+
+            var commandLineSwitchWithNoneOrIncorrectIndicator = "zSwitch";
+
+            MSBuildApp.GetLengthOfSwitchIndicator(commandLineSwitchWithSlash).ShouldBe(1);
+            MSBuildApp.GetLengthOfSwitchIndicator(commandLineSwitchWithSingleDash).ShouldBe(1);
+            MSBuildApp.GetLengthOfSwitchIndicator(commandLineSwitchWithDoubleDash).ShouldBe(2);
+
+            MSBuildApp.GetLengthOfSwitchIndicator(commandLineSwitchWithNoneOrIncorrectIndicator).ShouldBe(0);
+        }
+
+        [Theory]
+        [InlineData("-?")]
+        [InlineData("-h")]
+        [InlineData("--help")]
+        [InlineData(@"/h")]
+        public void Help(string indicator)
+        {
+            MSBuildApp.Execute(
 #if FEATURE_GET_COMMANDLINE
-                    @"c:\bin\msbuild.exe -? "
+                @$"c:\bin\msbuild.exe {indicator} "
 #else
-                    new [] {@"c:\bin\msbuild.exe", "-?"}
+                new [] {@"c:\bin\msbuild.exe", indicator}
 #endif
-                ).ShouldBe(MSBuildApp.ExitType.Success);
+            ).ShouldBe(MSBuildApp.ExitType.Success);
         }
 
         [Fact]
@@ -1259,7 +1279,23 @@ private void RunPriorityBuildTest(ProcessPriorityClass expectedPrority, params s
             logContents.ShouldContain(expected, () => logContents);
         }
 
-#region IgnoreProjectExtensionTests
+        /// <summary>
+        /// Test the default file to build in cases involving at least one solution filter file.
+        /// </summary>
+        [Theory]
+        [InlineData(new string[] { "my.proj", "my.sln", "my.slnf" }, "my.sln")]
+        [InlineData(new string[] { "abc.proj", "bcd.csproj", "slnf.slnf", "other.slnf" }, "abc.proj")]
+        [InlineData(new string[] { "abc.sln", "slnf.slnf", "abc.slnf" }, "abc.sln")]
+        [InlineData(new string[] { "abc.csproj", "abc.slnf", "not.slnf" }, "abc.csproj")]
+        [InlineData(new string[] { "abc.slnf" }, "abc.slnf")]
+        public void TestDefaultBuildWithSolutionFilter(string[] projects, string answer)
+        {
+            string[] extensionsToIgnore = Array.Empty<string>();
+            IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
+            MSBuildApp.ProcessProjectSwitch(Array.Empty<string>(), extensionsToIgnore, projectHelper.GetFiles).ShouldBe(answer, StringCompareShould.IgnoreCase);
+        }
+
+        #region IgnoreProjectExtensionTests
 
         /// <summary>
         /// Test the case where the extension is a valid extension but is not a project
@@ -1285,6 +1321,7 @@ public void TestTwoIdenticalExtensionsToIgnore()
             IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
             MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
         }
+
         /// <summary>
         /// Pass a null and an empty list of project extensions to ignore, this simulates the switch not being set on the commandline
         /// </summary>
@@ -1315,6 +1352,7 @@ public void TestProcessProjectSwitchNullInList()
             }
            );
         }
+
         /// <summary>
         /// Pass in one extension and an empty string
         /// </summary>
@@ -1582,7 +1620,7 @@ internal string[] GetFiles(string path, string searchPattern)
                 {
                     if (String.Equals(searchPattern, "*.sln", StringComparison.OrdinalIgnoreCase))
                     {
-                        if (String.Equals(Path.GetExtension(file), ".sln", StringComparison.OrdinalIgnoreCase))
+                        if (FileUtilities.IsSolutionFilename(file))
                         {
                             fileNamesToReturn.Add(file);
                         }
diff --git a/src/MSBuild/AssemblyInfo.cs b/src/MSBuild/AssemblyInfo.cs
index f335e6b3bea..63428b4c74e 100644
--- a/src/MSBuild/AssemblyInfo.cs
+++ b/src/MSBuild/AssemblyInfo.cs
@@ -2,14 +2,12 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
 using System.Resources;
 using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 
 [assembly: InternalsVisibleTo("Microsoft.Build.CommandLine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Utilities.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
-[assembly: InternalsVisibleTo("MSBuild.Whidbey.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 
 // This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly, 
 // so that we don't run into known security issues with loading libraries from unsafe locations 
diff --git a/src/MSBuild/CommandLineSwitchException.cs b/src/MSBuild/CommandLineSwitchException.cs
index 2563e623a45..eeafb59adcf 100644
--- a/src/MSBuild/CommandLineSwitchException.cs
+++ b/src/MSBuild/CommandLineSwitchException.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
 using System.Runtime.Serialization;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 9e3a7923e83..c8b2ed78726 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -5,8 +5,6 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Globalization;
-using Microsoft.Win32;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.CommandLine
diff --git a/src/MSBuild/DistributedLoggerRecord.cs b/src/MSBuild/DistributedLoggerRecord.cs
index dd2d0dada2e..e644cc4076d 100644
--- a/src/MSBuild/DistributedLoggerRecord.cs
+++ b/src/MSBuild/DistributedLoggerRecord.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Logging;
 
 namespace Microsoft.Build.CommandLine
diff --git a/src/MSBuild/FxCopExclusions/MsBuild.Suppressions.cs b/src/MSBuild/FxCopExclusions/MsBuild.Suppressions.cs
index c633486272d..a3931515f98 100644
--- a/src/MSBuild/FxCopExclusions/MsBuild.Suppressions.cs
+++ b/src/MSBuild/FxCopExclusions/MsBuild.Suppressions.cs
@@ -5,8 +5,6 @@
 // Add module level suppressions to this file to have them suppressed in the assembly
 //
 
-using System.Diagnostics.CodeAnalysis;
-
 #if CODE_ANALYSIS
 [module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="wrn", Scope="resource", Target="MSBuild.Strings.resources", Justification="These are correct for the help text, they are file paths extensions and switches")]
 [module: SuppressMessage("Microsoft.Naming","CA1703:ResourceStringsShouldBeSpelledCorrectly", MessageId="warningsonly", Scope="resource", Target="MSBuild.Strings.resources", Justification="These are correct for the help text, they are file paths extensions and switches")]
diff --git a/src/MSBuild/InitializationException.cs b/src/MSBuild/InitializationException.cs
index e12b6c3000a..7fefa686647 100644
--- a/src/MSBuild/InitializationException.cs
+++ b/src/MSBuild/InitializationException.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
-using System.Globalization;
 using System.Runtime.Serialization;
 
 #if FEATURE_SECURITY_PERMISSIONS
diff --git a/src/MSBuild/LogMessagePacket.cs b/src/MSBuild/LogMessagePacket.cs
index 1a6845fa518..54ec464146b 100644
--- a/src/MSBuild/LogMessagePacket.cs
+++ b/src/MSBuild/LogMessagePacket.cs
@@ -1,11 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Text;
-using System.IO;
-using System.Reflection;
 
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 3bf42162617..a6f0873dac4 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -194,6 +194,7 @@
     <Compile Include="OutOfProcTaskHostNode.cs" />
     <Compile Include="OutOfProcTaskAppDomainWrapperBase.cs" />
     <Compile Include="OutOfProcTaskAppDomainWrapper.cs" />
+    <Compile Include="PerformanceLogEventListener.cs" />
     <Compile Include="XMake.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index fdfc6edbf08..4810afd35e9 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -31,7 +31,7 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="Reference_FusionName" _locComment="" -->Fusion name of the assembly (optional)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="SpecificVersion">
+                            <xs:element name="SpecificVersion" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Reference_SpecificVersion" _locComment="" -->Whether only the version in the fusion name should be referenced (optional, boolean)</xs:documentation>
                                 </xs:annotation>
@@ -41,7 +41,7 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="Reference_Aliases" _locComment="" -->Aliases for the reference (optional)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="Private">
+                            <xs:element name="Private" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Reference_Private" _locComment="" -->Whether the reference should be copied to the output folder (optional, boolean)</xs:documentation>
                                 </xs:annotation>
@@ -133,7 +133,7 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="COMReference_WrapperTool" _locComment="" -->Wrapper tool, such as tlbimp</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="Isolated">
+                            <xs:element name="Isolated" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="COMReference_Isolated" _locComment="" -->Is it isolated (boolean)</xs:documentation>
                                 </xs:annotation>
@@ -703,7 +703,7 @@ elementFormDefault="qualified">
                         <xs:choice>
                             <xs:element name="SubType"/>
                             <xs:element name="DependentUpon"/>
-                            <xs:element name="AutoGen">
+                            <xs:element name="AutoGen" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Compile_AutoGen" _locComment="" -->Whether file was generated from another file (boolean)</xs:documentation>
                                 </xs:annotation>
@@ -715,7 +715,7 @@ elementFormDefault="qualified">
                                 </xs:annotation>
                             </xs:element>
                             <xs:element name="DesignTimeSharedInput"/>
-                            <xs:element name="Visible">
+                            <xs:element name="Visible" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Compile_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
@@ -764,7 +764,7 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="EmbeddedResource_Link" _locComment="" -->Notional path within project to display if the file is physically located outside of the project file's cone (optional)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="Visible">
+                            <xs:element name="Visible" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="EmbeddedResource_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
@@ -813,18 +813,18 @@ elementFormDefault="qualified">
                                 </xs:annotation>
                             </xs:element>
                             <xs:element name="IsAssembly"/>
-                            <xs:element name="Visible">
+                            <xs:element name="Visible" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Content_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory">
+                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Content_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="CopyToPublishDirectory">
+                            <xs:element name="CopyToPublishDirectory" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Content_CopyToPublishDirectory" _locComment="" -->Copy file to publish directory (optional, boolean, default false)</xs:documentation>
                                 </xs:annotation>
@@ -865,7 +865,7 @@ elementFormDefault="qualified">
                             </xs:element>
                             <xs:element name="Group"/>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory">
+                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Page_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
                                 </xs:annotation>
@@ -906,7 +906,7 @@ elementFormDefault="qualified">
                             </xs:element>
                             <xs:element name="Group"/>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory">
+                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="Resource_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
                                 </xs:annotation>
@@ -947,7 +947,7 @@ elementFormDefault="qualified">
                             </xs:element>
                             <xs:element name="Group"/>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory">
+                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="ApplicationDefinition_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
                                 </xs:annotation>
@@ -980,7 +980,7 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="None_Link" _locComment="" -->Notional path within project to display if the file is physically located outside of the project file's cone (optional)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="Visible">
+                            <xs:element name="Visible" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="None_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
@@ -1047,7 +1047,7 @@ elementFormDefault="qualified">
                 <xs:extension base="msb:SimpleItemType">
                     <xs:sequence minOccurs="0" maxOccurs="unbounded">
                         <xs:choice>
-                            <xs:element name="Visible">
+                            <xs:element name="Visible" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="FileAssociation_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
@@ -1067,7 +1067,7 @@ elementFormDefault="qualified">
                 <xs:extension base="msb:SimpleItemType">
                     <xs:sequence minOccurs="0" maxOccurs="unbounded">
                         <xs:choice>
-                            <xs:element name="Visible">
+                            <xs:element name="Visible" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="BootstrapperFile_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
@@ -1086,18 +1086,18 @@ elementFormDefault="qualified">
                 <xs:extension base="msb:SimpleItemType">
                     <xs:sequence minOccurs="0" maxOccurs="unbounded">
                         <xs:choice>
-                            <xs:element name="Visible">
+                            <xs:element name="Visible" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="PublishFile_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
                             <xs:element name="Group"/>
-                            <xs:element name="IncludeHash">
+                            <xs:element name="IncludeHash" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="PublishFile_IncludeHash" _locComment="" -->(boolean)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="IsAssembly">
+                            <xs:element name="IsAssembly" type="msb:boolean">
                                 <xs:annotation>
                                     <xs:documentation><!-- _locID_text="PublishFile_IsAssembly" _locComment="" -->(boolean)</xs:documentation>
                                 </xs:annotation>
@@ -1158,6 +1158,18 @@ elementFormDefault="qualified">
     <xs:element name="MinimumVisualStudioVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="AdditionalFileItemNames" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="AllowUnsafeBlocks" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="AnalysisMode" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AnalysisMode" _locComment="" -->Customizes the set of rules that are enabled by default.</xs:documentation>
+      </xs:annotation>
+      <xs:simpleType>
+        <xs:restriction base="xs:string">
+          <xs:enumeration value="Default" />
+          <xs:enumeration value="AllEnabledByDefault" />
+          <xs:enumeration value="AllDisabledByDefault" />
+        </xs:restriction>
+      </xs:simpleType>
+    </xs:element>
     <xs:element name="AppConfigForCompiler" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ApplicationIcon" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ApplicationRevision" type="msb:StringPropertyType" substitutionGroup="msb:Property">
@@ -1202,7 +1214,7 @@ elementFormDefault="qualified">
             <xs:documentation><!-- _locID_text="AutorunEnabled" _locComment="" -->Indicates whether BindingRedirect elements should be automatically generated for referenced assemblies.</xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="AutorunEnabled" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="AutorunEnabled" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="AutorunEnabled" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
@@ -1214,7 +1226,7 @@ elementFormDefault="qualified">
         </xs:annotation>
     </xs:element>
     <xs:element name="BootstrapperComponentsUrl" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="BootstrapperEnabled" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="BootstrapperEnabled" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="BootstrapperEnabled" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
@@ -1228,14 +1240,14 @@ elementFormDefault="qualified">
     <xs:element name="ConfigurationName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ConfigurationOverrideFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="CreateDesktopShortcut" type="msb:boolean" substitutionGroup="msb:Property" />
-    <xs:element name="CreateWebPageOnPublish" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="CreateWebPageOnPublish" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="CreateWebPageOnPublish" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
     </xs:element>
     <xs:element name="CurrentSolutionConfigurationContents" type="msb:GenericPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="DebugSecurityZoneURL" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="DebugSymbols" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="DebugSymbols" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="DebugSymbols" _locComment="" -->Whether to emit symbols (boolean)</xs:documentation>
         </xs:annotation>
@@ -1249,19 +1261,19 @@ elementFormDefault="qualified">
     <xs:element name="DefaultHTMLPageLayout" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="DefaultTargetSchema" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="DefineConstants" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="DefineDebug" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="DefineDebug" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="DefineDebug" _locComment="" -->Whether DEBUG is defined (boolean)</xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="DefineTrace" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="DefineTrace" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="DefineTrace" _locComment="" -->Whether TRACE is defined (boolean)</xs:documentation>
         </xs:annotation>
     </xs:element>
     <xs:element name="DelaySign" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="DisableLangXtns" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="DisallowUrlActivation" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="DisallowUrlActivation" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="DisallowUrlActivation" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
@@ -1501,6 +1513,11 @@ elementFormDefault="qualified">
     <xs:element name="EnableSQLServerDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="EnableSecurityDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="EnableUnmanagedDebugging" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="EnforceCodeStyleInBuild" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="EnforceCodeStyleInBuild" _locComment="" -->Controls whether code style analysis rules configured as warnings or errors should execute on build and report violations. The default is false.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="ErrorLog" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ErrorReport" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="EmbedManifest" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
@@ -1541,8 +1558,34 @@ elementFormDefault="qualified">
             <xs:documentation><!-- _locID_text="InstallFrom" _locComment="" -->Web, Unc, or Disk</xs:documentation>
         </xs:annotation>
     </xs:element>
+    <xs:element name="AnalysisLevel" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="InstallUrl" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="IsCodeSharingProject" type="msb:boolean" substitutionGroup="msb:Property"/>
+    <xs:element name="IsPackable" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="IsPackable" _locComment="" -->Indicates whether the project can be used to create a NuGet package.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="EnableNETAnalyzers" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="EnableNETAnalyzers" _locComment="" -->Indicates whether the .NET analyzers are enabled. They are enabled by default for projects that target .NET 5.0 or later.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="EnableDefaultCompileItems" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="EnableDefaultCompileItems" _locComment="" -->Enable default Compile item globs for source files.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="EnableDefaultNoneItems" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="EnableDefaultNoneItems" _locComment="" -->Enable default None item globs (which cover most files in the project not covered by other globs).</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="EnableDefaultItems" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="EnableDefaultItems" _locComment="" -->Defaults to true, and if set to false will disable all default item globs.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="IsWebBootstrapper" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="JCPA" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="Keyword" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
@@ -1553,7 +1596,7 @@ elementFormDefault="qualified">
     <xs:element name="LinkIncremental" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ManifestCertificateThumbprint" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ManifestKeyFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="MapFileExtensions" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="MapFileExtensions" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="MapFileExtensions" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
@@ -1582,7 +1625,7 @@ elementFormDefault="qualified">
     </xs:element>
     <xs:element name="NoConfig" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="NoStandardLibraries" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="NoStdLib" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="NoStdLib" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="NoStdLib" _locComment="" -->Whether standard libraries (such as mscorlib) should be referenced automatically (boolean)</xs:documentation>
         </xs:annotation>
@@ -1596,12 +1639,12 @@ elementFormDefault="qualified">
     <xs:element name="OutDir" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="TargetExt" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="TargetName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="OpenBrowserOnPublish" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="OpenBrowserOnPublish" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="OpenBrowserOnPublish" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="Optimize" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="Optimize" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="Optimize" _locComment="" -->Should compiler optimize output (boolean)</xs:documentation>
         </xs:annotation>
@@ -1710,6 +1753,21 @@ elementFormDefault="qualified">
       </xs:annotation>
     </xs:element>
     <xs:element name="ResponseFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="RunAnalyzers" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="RunAnalyzers" _locComment="" -->Disables analyzers at both build and design time. This property takes precedence over RunAnalyzersDuringBuild and RunAnalyzersDuringLiveAnalysis. Default is true.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="RunAnalyzersDuringBuild" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="RunAnalyzersDuringBuild" _locComment="" -->Controls whether analyzers run at build time. Default is true.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
+    <xs:element name="RunAnalyzersDuringLiveAnalysis" type="msb:boolean" substitutionGroup="msb:Property">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="RunAnalyzersDuringLiveAnalysis" _locComment="" -->Controls whether analyzers analyze code live at design time. Default is true.</xs:documentation>
+        </xs:annotation>
+    </xs:element>
     <xs:element name="RootNamespace" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="RuntimeIdentifier" type="msb:StringPropertyType" substitutionGroup="msb:Property">
       <xs:annotation>
@@ -1771,7 +1829,7 @@ elementFormDefault="qualified">
     <xs:element name="TargetPlatformMinVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="TargetZone" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="TreatWarningsAsErrors" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="TrustUrlParameters" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="TrustUrlParameters" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="TrustUrlParameters" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
@@ -1779,7 +1837,7 @@ elementFormDefault="qualified">
     <xs:element name="TypeComplianceDiagnostics" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="UICulture" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="UpgradeBackupLocation" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="UpdateEnabled" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="UpdateEnabled" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="UpdateEnabled" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
@@ -1795,12 +1853,12 @@ elementFormDefault="qualified">
             <xs:documentation><!-- _locID_text="UpdateMode" _locComment="" -->Foreground or Background</xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="UpdatePeriodically" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="UpdatePeriodically" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="UpdatePeriodically" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="UpdateRequired" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+    <xs:element name="UpdateRequired" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
             <xs:documentation><!-- _locID_text="UpdateRequired" _locComment="" -->boolean</xs:documentation>
         </xs:annotation>
@@ -1816,7 +1874,7 @@ elementFormDefault="qualified">
     <xs:element name="VSTO_TrustAssembliesLocation" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="WarningLevel" type="msb:StringPropertyType" substitutionGroup="msb:Property">
         <xs:annotation>
-            <xs:documentation><!-- _locID_text="WarningLevel" _locComment="" -->integer between 0 and 4 inclusive</xs:documentation>
+            <xs:documentation><!-- _locID_text="WarningLevel" _locComment="" -->integer between 0 and 5 inclusive</xs:documentation>
         </xs:annotation>
     </xs:element>
     <xs:element name="WarningsAsErrors" type="msb:StringPropertyType" substitutionGroup="msb:Property">
@@ -2561,6 +2619,7 @@ elementFormDefault="qualified">
                     <xs:attribute name="IconFile" />
                     <xs:attribute name="InputManifest" />
                     <xs:attribute name="IsolatedComReferences" />
+                    <xs:attribute name="LauncherBasedDeployment" type="msb:boolean" />
                     <xs:attribute name="ManifestType" />
                     <xs:attribute name="MaxTargetPath" />
                     <xs:attribute name="OSVersion" />
@@ -2620,6 +2679,7 @@ elementFormDefault="qualified">
                     <xs:attribute name="ErrorReportUrl" />
                     <xs:attribute name="InputManifest" />
                     <xs:attribute name="Install" type="msb:boolean" />
+                    <xs:attribute name="LauncherBasedDeployment" type="msb:boolean" />
                     <xs:attribute name="MapFileExtensions" type="msb:boolean" />
                     <xs:attribute name="MaxTargetPath" />
                     <xs:attribute name="MinimumRequiredVersion" />
@@ -2641,6 +2701,17 @@ elementFormDefault="qualified">
             </xs:complexContent>
         </xs:complexType>
     </xs:element>
+    <xs:element name="GenerateLauncher" substitutionGroup="msb:Task">
+        <xs:complexType>
+            <xs:complexContent>
+                <xs:extension base="msb:TaskType">
+                    <xs:attribute name="EntryPoint" />
+                    <xs:attribute name="OutputPath" />
+                    <xs:attribute name="VisualStudioVersion" />
+                </xs:extension>
+            </xs:complexContent>
+        </xs:complexType>
+    </xs:element>
     <xs:element name="GenerateResource" substitutionGroup="msb:Task">
         <xs:complexType>
             <xs:complexContent>
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapper.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapper.cs
index 7f14fd5111e..1a971a16b76 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapper.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapper.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.CommandLine
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
index 99971d6460c..b1f085e2da1 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
@@ -2,22 +2,13 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
-using System.IO;
 using System.Linq;
-using System.Text;
-using System.Globalization;
 using System.Threading;
 using System.Reflection;
-using System.Runtime.CompilerServices;
 
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 #if FEATURE_APPDOMAIN
 using System.Runtime.Remoting;
@@ -360,7 +351,7 @@ IDictionary<string, TaskParameter> taskParams
                 try
                 {
                     PropertyInfo paramInfo = wrappedTask.GetType().GetProperty(param.Key, BindingFlags.Instance | BindingFlags.Public);
-                    paramInfo.SetValue(wrappedTask, param.Value == null ? null : param.Value.WrappedParameter, null);
+                    paramInfo.SetValue(wrappedTask, param.Value?.WrappedParameter, null);
                 }
                 catch (Exception e)
                 {
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 247e3208f41..e7604d0970b 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -5,14 +5,10 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
 using System.IO;
-using System.Linq;
-using System.Text;
 using System.Globalization;
 using System.Threading;
 using System.Reflection;
-using System.Runtime.CompilerServices;
 
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
@@ -268,7 +264,7 @@ public bool IsRunningMultipleNodes
         /// <summary>
         /// Enables or disables emitting a default error when a task fails without logging errors
         /// </summary>
-        public bool AllowFailureWithoutError { get; set; } = true;
+        public bool AllowFailureWithoutError { get; set; } = false;
         #endregion
 
         #region IBuildEngine Implementation (Methods)
@@ -1044,8 +1040,8 @@ private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> en
 
                 foreach (string variable in _savedEnvironment.Keys)
                 {
-                    string newValue = null;
                     string oldValue = _savedEnvironment[variable];
+                    string newValue;
                     if (!environment.TryGetValue(variable, out newValue))
                     {
                         s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(null, oldValue);
@@ -1062,7 +1058,7 @@ private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> en
                 foreach (string variable in environment.Keys)
                 {
                     string newValue = environment[variable];
-                    string oldValue = null;
+                    string oldValue;
                     if (!_savedEnvironment.TryGetValue(variable, out oldValue))
                     {
                         s_mismatchedEnvironmentValues[variable] = new KeyValuePair<string, string>(newValue, null);
diff --git a/src/MSBuild/PerformanceLogEventListener.cs b/src/MSBuild/PerformanceLogEventListener.cs
new file mode 100644
index 00000000000..a9ffec3aae4
--- /dev/null
+++ b/src/MSBuild/PerformanceLogEventListener.cs
@@ -0,0 +1,165 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Diagnostics;
+using System.Diagnostics.Tracing;
+using System.IO;
+using System.Text;
+using Microsoft.Build.Eventing;
+
+namespace Microsoft.Build.CommandLine
+{
+    internal sealed class PerformanceLogEventListener : EventListener
+    {
+        internal struct ProviderConfiguration
+        {
+            internal string Name { get; set; }
+            internal EventKeywords Keywords { get; set; }
+            internal EventLevel Level { get; set; }
+        }
+
+        private static ProviderConfiguration[] s_config = new ProviderConfiguration[]
+        {
+            new ProviderConfiguration()
+            {
+                Name = "Microsoft-Build",
+                Keywords = MSBuildEventSource.Keywords.PerformanceLog,
+                Level = EventLevel.Verbose
+            }
+        };
+
+        private const string PerfLogDirEnvVar = "DOTNET_PERFLOG_DIR";
+        private const char EventDelimiter = '\n';
+        private string _processIDStr;
+        private StreamWriter _writer;
+
+        [ThreadStatic]
+        private static StringBuilder s_builder;
+
+        internal static PerformanceLogEventListener Create()
+        {
+            PerformanceLogEventListener eventListener = null;
+            try
+            {
+                // Initialization happens as a separate step and not in the constructor to ensure that
+                // if an exception is thrown during init, we have the opportunity to dispose of the listener,
+                // which will disable any EventSources that have been enabled.  Any EventSources that existed before
+                // this EventListener will be passed to OnEventSourceCreated before our constructor is called, so
+                // we if we do this work in the constructor, and don't get an opportunity to call Dispose, the
+                // EventSources will remain enabled even if there aren't any consuming EventListeners.
+
+                // Check to see if we should enable the event listener.
+                string logDirectory = Environment.GetEnvironmentVariable(PerfLogDirEnvVar);
+                if (Directory.Exists(logDirectory))
+                {
+                    eventListener = new PerformanceLogEventListener();
+                    eventListener.Initialize(logDirectory);
+                }
+            }
+            catch
+            {
+                if (eventListener != null)
+                {
+                    eventListener.Dispose();
+                    eventListener = null;
+                }
+            }
+
+            return eventListener;
+        }
+
+        private PerformanceLogEventListener()
+        {
+        }
+
+        internal void Initialize(string logDirectory)
+        {
+            _processIDStr = Process.GetCurrentProcess().Id.ToString();
+
+            // Use a GUID disambiguator to make sure that we have a unique file name.
+            string logFilePath = Path.Combine(logDirectory, $"perf-{_processIDStr}-{Guid.NewGuid().ToString("N")}.log");
+
+            Stream outputStream = new FileStream(
+                logFilePath,
+                FileMode.Create,    // Create or overwrite.
+                FileAccess.Write,   // Open for writing.
+                FileShare.Read,     // Allow others to read.
+                4096,               // Default buffer size.
+                FileOptions.None);  // No hints about how the file will be written.
+
+            _writer = new StreamWriter(outputStream);
+        }
+
+        public override void Dispose()
+        {
+            lock (this)
+            {
+                if (_writer != null)
+                {
+                    _writer.Dispose();
+                    _writer = null;
+                }
+            }
+
+            base.Dispose();
+        }
+
+        protected override void OnEventSourceCreated(EventSource eventSource)
+        {
+            try
+            {
+                // Enable the provider if it matches a requested configuration.
+                foreach (ProviderConfiguration entry in s_config)
+                {
+                    if (entry.Name.Equals(eventSource.Name))
+                    {
+                        EnableEvents(eventSource, entry.Level, entry.Keywords);
+                    }
+                }
+            }
+            catch
+            {
+                // If we fail to enable, just skip it and continue.
+            }
+
+            base.OnEventSourceCreated(eventSource);
+        }
+
+        protected override void OnEventWritten(EventWrittenEventArgs eventData)
+        {
+            try
+            {
+                if (s_builder == null)
+                {
+                    s_builder = new StringBuilder();
+                }
+                else
+                {
+                    s_builder.Clear();
+                }
+
+                s_builder.Append($"[{DateTime.UtcNow.ToString("o")}] Event={eventData.EventSource.Name}/{eventData.EventName} ProcessID={_processIDStr} ThreadID={System.Threading.Thread.CurrentThread.ManagedThreadId}\t ");
+                for (int i = 0; i < eventData.PayloadNames.Count; i++)
+                {
+                    s_builder.Append($"{eventData.PayloadNames[i]}=\"{eventData.Payload[i]}\" ");
+                }
+
+                lock (this)
+                {
+                    if (_writer != null)
+                    {
+                        _writer.Write(s_builder.ToString());
+                        _writer.Write(EventDelimiter);
+                    }
+                }
+            }
+            catch
+            {
+                // If we fail to log an event, just skip it and continue.
+            }
+
+            base.OnEventWritten(eventData);
+        }
+    }
+}
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index c50f1abb97f..d9d4839ebcb 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -14,7 +14,6 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
-using System.Resources;
 using System.Security;
 using System.Text;
 using System.Text.RegularExpressions;
@@ -213,13 +212,15 @@ string [] args
 #endif
             )
         {
-            if (Environment.GetEnvironmentVariable("MSBUILDDUMPPROCESSCOUNTERS") == "1")
+            using (PerformanceLogEventListener eventListener = PerformanceLogEventListener.Create())
             {
-                DumpCounters(true /* initialize only */);
-            }
+                if (Environment.GetEnvironmentVariable("MSBUILDDUMPPROCESSCOUNTERS") == "1")
+                {
+                    DumpCounters(true /* initialize only */);
+                }
 
-            // return 0 on success, non-zero on failure
-            int exitCode = ((s_initialized && Execute(
+                // return 0 on success, non-zero on failure
+                int exitCode = ((s_initialized && Execute(
 #if FEATURE_GET_COMMANDLINE
                 Environment.CommandLine
 #else
@@ -227,12 +228,13 @@ string [] args
 #endif
                 ) == ExitType.Success) ? 0 : 1);
 
-            if (Environment.GetEnvironmentVariable("MSBUILDDUMPPROCESSCOUNTERS") == "1")
-            {
-                DumpCounters(false /* log to console */);
-            }
+                if (Environment.GetEnvironmentVariable("MSBUILDDUMPPROCESSCOUNTERS") == "1")
+                {
+                    DumpCounters(false /* log to console */);
+                }
 
-            return exitCode;
+                return exitCode;
+            }
         }
 
 #if !FEATURE_GET_COMMANDLINE
@@ -395,12 +397,11 @@ private static void DumpCounter(PerformanceCounter counter, bool initializeOnly)
                 if (!initializeOnly)
                 {
                     string friendlyCounterType = GetFriendlyCounterType(counter.CounterType, counter.CounterName);
-                    string valueFormat;
-
+                    
                     // At least some (such as % in GC; maybe all) "%" counters are already multiplied by 100. So we don't do that here.
 
                     // Show decimal places if meaningful
-                    valueFormat = value < 10 ? "{0,20:N2}" : "{0,20:N0}";
+                    string valueFormat = value < 10 ? "{0,20:N2}" : "{0,20:N0}";
 
                     string valueString = String.Format(CultureInfo.CurrentCulture, valueFormat, value);
 
@@ -526,7 +527,7 @@ string [] commandLine
                 MSBuildEventSource.Log.MSBuildExeStart(commandLine);
 #else
                 if (MSBuildEventSource.Log.IsEnabled()) {
-                    MSBuildEventSource.Log.MSBuildExeStop(string.Join(" ", commandLine));
+                    MSBuildEventSource.Log.MSBuildExeStart(string.Join(" ", commandLine));
                 }
 #endif
                 Console.CancelKeyPress += cancelHandler;
@@ -753,7 +754,7 @@ string [] commandLine
             catch (LoggerException e)
             {
                 // display the localized message from the outer exception in canonical format
-                if (null != e.ErrorCode)
+                if (e.ErrorCode != null)
                 {
                     // Brief prefix to indicate that it's a logger failure, and provide the "error" indication
                     Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("LoggerFailurePrefixNoErrorCode", e.ErrorCode, e.Message));
@@ -765,7 +766,7 @@ string [] commandLine
                     Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("LoggerFailurePrefixWithErrorCode", e.Message));
                 }
 
-                if (null != e.InnerException)
+                if (e.InnerException != null)
                 {
                     // write out exception details -- don't bother triggering Watson, because most of these exceptions will be coming
                     // from buggy loggers written by users
@@ -1107,7 +1108,7 @@ string outputResultsCache
                 if (needToValidateProject && !FileUtilities.IsSolutionFilename(projectFile))
                 {
                     Microsoft.Build.Evaluation.Project project = projectCollection.LoadProject(projectFile, globalProperties, toolsVersion);
-                    Microsoft.Build.Evaluation.Toolset toolset = projectCollection.GetToolset((toolsVersion == null) ? project.ToolsVersion : toolsVersion);
+                    Microsoft.Build.Evaluation.Toolset toolset = projectCollection.GetToolset(toolsVersion ?? project.ToolsVersion);
 
                     if (toolset == null)
                     {
@@ -1676,8 +1677,8 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman
                         string switchName;
                         string switchParameters;
 
-                        // all switches should start with - or / unless a project is being specified
-                        if (!unquotedCommandLineArg.StartsWith("-", StringComparison.Ordinal) && (!unquotedCommandLineArg.StartsWith("/", StringComparison.Ordinal) || FileUtilities.LooksLikeUnixFilePath(unquotedCommandLineArg)))
+                        // all switches should start with - or / or -- unless a project is being specified
+                        if (!ValidateSwitchIndicatorInUnquotedArgument(unquotedCommandLineArg) || FileUtilities.LooksLikeUnixFilePath(unquotedCommandLineArg))
                         {
                             switchName = null;
                             // add a (fake) parameter indicator for later parsing
@@ -1688,17 +1689,20 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman
                             // check if switch has parameters (look for the : parameter indicator)
                             int switchParameterIndicator = unquotedCommandLineArg.IndexOf(':');
 
+                            // get the length of the beginning sequence considered as a switch indicator (- or / or --)
+                            int switchIndicatorsLength = GetLengthOfSwitchIndicator(unquotedCommandLineArg);
+
                             // extract the switch name and parameters -- the name is sandwiched between the switch indicator (the
-                            // leading - or /) and the parameter indicator (if the switch has parameters); the parameters (if any)
+                            // leading - or / or --) and the parameter indicator (if the switch has parameters); the parameters (if any)
                             // follow the parameter indicator
                             if (switchParameterIndicator == -1)
                             {
-                                switchName = unquotedCommandLineArg.Substring(1);
+                                switchName = unquotedCommandLineArg.Substring(switchIndicatorsLength);
                                 switchParameters = String.Empty;
                             }
                             else
                             {
-                                switchName = unquotedCommandLineArg.Substring(1, switchParameterIndicator - 1);
+                                switchName = unquotedCommandLineArg.Substring(switchIndicatorsLength, switchParameterIndicator - 1);
                                 switchParameters = ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, switchName, switchParameterIndicator);
                             }
                         }
@@ -1722,6 +1726,23 @@ internal static void GatherCommandLineSwitches(ArrayList commandLineArgs, Comman
                                 String.Equals(switchName, "maxcpucount", StringComparison.OrdinalIgnoreCase))
                             {
                                 int numberOfCpus = Environment.ProcessorCount;
+#if !MONO
+                                // .NET Core on Windows returns a core count limited to the current NUMA node
+                                //     https://github.com/dotnet/runtime/issues/29686
+                                // so always double-check it.
+                                if (NativeMethodsShared.IsWindows && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_8)
+#if NETFRAMEWORK
+                                     // .NET Framework calls Windows APIs that have a core count limit (32/64 depending on process bitness).
+                                     // So if we get a high core count on full framework, double-check it.
+                                     && (numberOfCpus >= 32)
+#endif
+                                    )
+                                {
+                                    var result = NativeMethodsShared.GetLogicalCoreCount();
+                                    if(result != -1)
+                                        numberOfCpus = result;
+                                }
+#endif
                                 switchParameters = ":" + numberOfCpus;
                             }
                             else if (String.Equals(switchName, "bl", StringComparison.OrdinalIgnoreCase) ||
@@ -1776,7 +1797,6 @@ internal static string ExtractSwitchParameters
             int switchParameterIndicator
         )
         {
-            string switchParameters = null;
 
             // find the parameter indicator again using the quoted arg
             // NOTE: since the parameter indicator cannot be part of a switch name, quoting around it is not relevant, because a
@@ -1793,6 +1813,7 @@ int switchParameterIndicator
             ErrorUtilities.VerifyThrow(doubleQuotesRemovedFromArg >= doubleQuotesRemovedFromSwitchIndicatorAndName,
                 "The name portion of the switch cannot contain more quoting than the arg itself.");
 
+            string switchParameters;
             // if quoting in the name portion of the switch was terminated
             if ((doubleQuotesRemovedFromSwitchIndicatorAndName % 2) == 0)
             {
@@ -2388,7 +2409,7 @@ internal static bool ProcessNodeReuseSwitch(string[] parameters)
             enableNodeReuse = false;
 #endif
 
-            if (Traits.Instance.DisableNodeReuse) // For example to disable node reuse in a gated checkin, without using the flag
+            if (Environment.GetEnvironmentVariable("MSBUILDDISABLENODEREUSE") == "1") // For example to disable node reuse in a gated checkin, without using the flag
             {
                 enableNodeReuse = false;
             }
@@ -2756,82 +2777,70 @@ DirectoryGetFiles getFiles
             // We need to look in a directory for a project file...
             if (projectFile == null)
             {
+                ValidateExtensions(projectsExtensionsToIgnore);
+                HashSet<string> extensionsToIgnore = new HashSet<string>(projectsExtensionsToIgnore ?? Array.Empty<string>(), StringComparer.OrdinalIgnoreCase);
                 // Get all files in the current directory that have a proj-like extension
                 string[] potentialProjectFiles = getFiles(projectDirectory ?? ".", "*.*proj");
-                // Get all files in the current directory that have a sln extension
-                string[] potentialSolutionFiles = getFiles(projectDirectory ?? ".", "*.sln");
-
-                List<string> extensionsToIgnore = new List<string>();
-                if (projectsExtensionsToIgnore != null)
-                {
-                    extensionsToIgnore.AddRange(projectsExtensionsToIgnore);
-                }
-
+                List<string> actualProjectFiles = new List<string>();
                 if (potentialProjectFiles != null)
                 {
                     foreach (string s in potentialProjectFiles)
                     {
-                        if (s.EndsWith("~", StringComparison.CurrentCultureIgnoreCase))
+                        if (!extensionsToIgnore.Contains(Path.GetExtension(s)) && !s.EndsWith("~", StringComparison.CurrentCultureIgnoreCase))
                         {
-                            extensionsToIgnore.Add(Path.GetExtension(s));
+                            actualProjectFiles.Add(s);
                         }
                     }
                 }
 
+                // Get all files in the current directory that have a sln extension
+                string[] potentialSolutionFiles = getFiles(projectDirectory ?? ".", "*.sln");
+                List<string> actualSolutionFiles = new List<string>();
+                List<string> solutionFilterFiles = new List<string>();
                 if (potentialSolutionFiles != null)
                 {
                     foreach (string s in potentialSolutionFiles)
                     {
-                        if (!FileUtilities.IsSolutionFilename(s))
+                        if (!extensionsToIgnore.Contains(Path.GetExtension(s)))
                         {
-                            extensionsToIgnore.Add(Path.GetExtension(s));
+                            if (FileUtilities.IsSolutionFilterFilename(s))
+                            {
+                                solutionFilterFiles.Add(s);
+                            }
+                            else if (FileUtilities.IsSolutionFilename(s))
+                            {
+                                actualSolutionFiles.Add(s);
+                            }
                         }
                     }
                 }
 
-                Dictionary<string, object> extensionsToIgnoreDictionary = ValidateExtensions(extensionsToIgnore.ToArray());
-
-                // Remove projects that are in the projectExtensionsToIgnore List
-                // If we have no extensions to ignore we can skip removing any extensions
-                if (extensionsToIgnoreDictionary.Count > 0)
-                {
-                    // No point removing extensions if we have no project files
-                    if (potentialProjectFiles?.Length > 0)
-                    {
-                        potentialProjectFiles = RemoveFilesWithExtensionsToIgnore(potentialProjectFiles, extensionsToIgnoreDictionary);
-                    }
-
-                    // No point removing extensions if we have no solutions
-                    if (potentialSolutionFiles?.Length > 0)
-                    {
-                        potentialSolutionFiles = RemoveFilesWithExtensionsToIgnore(potentialSolutionFiles, extensionsToIgnoreDictionary);
-                    }
-                }
                 // If there is exactly 1 project file and exactly 1 solution file
-                if ((potentialProjectFiles.Length == 1) && (potentialSolutionFiles.Length == 1))
+                if (actualProjectFiles.Count == 1 && actualSolutionFiles.Count == 1)
                 {
                     // Grab the name of both project and solution without extensions
-                    string solutionName = Path.GetFileNameWithoutExtension(potentialSolutionFiles[0]);
-                    string projectName = Path.GetFileNameWithoutExtension(potentialProjectFiles[0]);
+                    string solutionName = Path.GetFileNameWithoutExtension(actualSolutionFiles[0]);
+                    string projectName = Path.GetFileNameWithoutExtension(actualProjectFiles[0]);
                     // Compare the names and error if they are not identical
                     InitializationException.VerifyThrow(String.Equals(solutionName, projectName, StringComparison.OrdinalIgnoreCase), projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
+                    projectFile = actualSolutionFiles[0];
                 }
                 // If there is more than one solution file in the current directory we have no idea which one to use
-                else if (potentialSolutionFiles.Length > 1)
+                else if (actualSolutionFiles.Count > 1)
                 {
                     InitializationException.VerifyThrow(false, projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
                 }
                 // If there is more than one project file in the current directory we may be able to figure it out
-                else if (potentialProjectFiles.Length > 1)
+                else if (actualProjectFiles.Count > 1)
                 {
                     // We have more than one project, it is ambiguous at the moment
                     bool isAmbiguousProject = true;
 
                     // If there are exactly two projects and one of them is a .proj use that one and ignore the other
-                    if (potentialProjectFiles.Length == 2)
+                    if (actualProjectFiles.Count == 2)
                     {
-                        string firstPotentialProjectExtension = Path.GetExtension(potentialProjectFiles[0]);
-                        string secondPotentialProjectExtension = Path.GetExtension(potentialProjectFiles[1]);
+                        string firstPotentialProjectExtension = Path.GetExtension(actualProjectFiles[0]);
+                        string secondPotentialProjectExtension = Path.GetExtension(actualProjectFiles[1]);
 
                         // If the two projects have the same extension we can't decide which one to pick
                         if (!String.Equals(firstPotentialProjectExtension, secondPotentialProjectExtension, StringComparison.OrdinalIgnoreCase))
@@ -2839,14 +2848,14 @@ DirectoryGetFiles getFiles
                             // Check to see if the first project is the proj, if it is use it
                             if (String.Equals(firstPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
                             {
-                                potentialProjectFiles = new string[] { potentialProjectFiles[0] };
+                                projectFile = actualProjectFiles[0];
                                 // We have made a decision
                                 isAmbiguousProject = false;
                             }
                             // If the first project is not the proj check to see if the second one is the proj, if so use it
                             else if (String.Equals(secondPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
                             {
-                                potentialProjectFiles = new string[] { potentialProjectFiles[1] };
+                                projectFile = actualProjectFiles[1];
                                 // We have made a decision
                                 isAmbiguousProject = false;
                             }
@@ -2854,108 +2863,84 @@ DirectoryGetFiles getFiles
                     }
                     InitializationException.VerifyThrow(!isAmbiguousProject, projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
                 }
-                // if there are no project or solution files in the directory, we can't build
-                else if ((potentialProjectFiles.Length == 0) &&
-                         (potentialSolutionFiles.Length == 0))
+                // if there are no project, solution filter, or solution files in the directory, we can't build
+                else if (actualProjectFiles.Count == 0 &&
+                         actualSolutionFiles.Count== 0 &&
+                         solutionFilterFiles.Count == 0)
                 {
                     InitializationException.VerifyThrow(false, "MissingProjectError");
                 }
-
-                // We are down to only one project or solution.
-                // If only 1 solution build the solution.  If only 1 project build the project
-                // If 1 solution and 1 project and they are of the same name build the solution
-                projectFile = (potentialSolutionFiles.Length == 1) ? potentialSolutionFiles[0] : potentialProjectFiles[0];
+                else
+                {
+                    // We are down to only one project, solution, or solution filter.
+                    // If only 1 solution build the solution.  If only 1 project build the project. Otherwise, build the solution filter.
+                    projectFile = actualSolutionFiles.Count == 1 ? actualSolutionFiles[0] : actualProjectFiles.Count == 1 ? actualProjectFiles[0] : solutionFilterFiles[0];
+                    InitializationException.VerifyThrow(actualSolutionFiles.Count == 1 || actualProjectFiles.Count == 1 || solutionFilterFiles.Count == 1, projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
+                }
             }
 
             return projectFile;
         }
 
-        /// <summary>
-        ///  This method takes in a list of file name extensions to ignore. It will then validate the extensions
-        ///  to make sure they start with a period, have atleast one character after the period and do not contain
-        ///  any invalid path chars or wild cards
-        /// </summary>
-        /// <param name="projectsExtensionsToIgnore"></param>
-        /// <returns></returns>
-        private static Dictionary<string, object> ValidateExtensions(string[] projectsExtensionsToIgnore)
+        private static void ValidateExtensions(string[] projectExtensionsToIgnore)
         {
-            // Dictionary to contain the list of files which match the extensions to ignore. We are using a dictionary for fast lookups of extensions to ignore
-            Dictionary<string, object> extensionsToIgnoreDictionary = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
-
-            // Go through each of the extensions to ignore and add them as a key in the dictionary
-            if (projectsExtensionsToIgnore?.Length > 0)
+            if (projectExtensionsToIgnore?.Length > 0)
             {
-                string extension = null;
-
-                foreach (string extensionToIgnore in projectsExtensionsToIgnore)
+                foreach (string extension in projectExtensionsToIgnore)
                 {
-                    // Use the path get extension method to figure out if there is an extension in the passed 
-                    // in extension to ignore. Will return null or empty if there is no extension in the string
-                    try
-                    {
-                        // Use GetExtension to parse the extension from the extensionToIgnore
-                        extension = Path.GetExtension(extensionToIgnore);
-                    }
-                    catch (ArgumentException)
-                    {
-                        // There has been an invalid char in the extensionToIgnore
-                        InitializationException.Throw("InvalidExtensionToIgnore", extensionToIgnore, null, false);
-                    }
+                    // There has to be more than a . passed in as the extension.
+                    InitializationException.VerifyThrow(extension?.Length >= 2, "InvalidExtensionToIgnore", extension);
 
-                    // if null or empty is returned that means that there was not extension able to be parsed from the string
-                    InitializationException.VerifyThrow(!string.IsNullOrEmpty(extension), "InvalidExtensionToIgnore", extensionToIgnore);
+                    // There is an invalid char in the extensionToIgnore.
+                    InitializationException.VerifyThrow(extension.IndexOfAny(Path.GetInvalidPathChars()) == -1, "InvalidExtensionToIgnore", extension, null, false);
 
-                    // There has to be more than a . passed in as the extension
-                    InitializationException.VerifyThrow(extension.Length >= 2, "InvalidExtensionToIgnore", extensionToIgnore);
+                    // There were characters before the extension.
+                    InitializationException.VerifyThrow(String.Equals(extension, Path.GetExtension(extension), StringComparison.OrdinalIgnoreCase), "InvalidExtensionToIgnore", extension, null, false);
 
-                    // The parsed extension does not match the passed in extension, this means that there were
-                    // some other chars before the last extension
-                    if (!string.Equals(extension, extensionToIgnore, StringComparison.OrdinalIgnoreCase))
-                    {
-                        InitializationException.Throw("InvalidExtensionToIgnore", extensionToIgnore, null, false);
-                    }
-
-                    // Make sure that no wild cards are in the string because for now we dont allow wild card extensions
-                    if (extensionToIgnore.IndexOfAny(s_wildcards) > -1)
-                    {
-                        InitializationException.Throw("InvalidExtensionToIgnore", extensionToIgnore, null, false);
-                    }
-                    if (!extensionsToIgnoreDictionary.ContainsKey(extensionToIgnore))
-                    {
-                        extensionsToIgnoreDictionary.Add(extensionToIgnore, null);
-                    }
+                    // Make sure that no wild cards are in the string because for now we dont allow wild card extensions.
+                    InitializationException.VerifyThrow(extension.IndexOfAny(s_wildcards) == -1, "InvalidExtensionToIgnore", extension, null, false);
                 }
             }
-            return extensionsToIgnoreDictionary;
         }
 
         /// <summary>
-        /// Removes filenames from the given list whose extensions are on the list of extensions to ignore
+        /// Checks whether an argument given as a parameter starts with valid indicator,
+        /// <br/>which means, whether switch begins with one of: "/", "-", "--"
         /// </summary>
-        /// <param name="potentialProjectOrSolutionFiles">A list of project or solution file names</param>
-        /// <param name="extensionsToIgnore">A list of extensions to ignore</param>
-        /// <returns>Array of project or solution files names which do not have an extension to be ignored </returns>
-        private static string[] RemoveFilesWithExtensionsToIgnore
-                                (
-                                    string[] potentialProjectOrSolutionFiles,
-                                    Dictionary<string, object> extensionsToIgnoreDictionary
-                                )
+        /// <param name="unquotedCommandLineArgument">Command line argument with beginning indicator (e.g. --help).
+        /// <br/>This argument has to be unquoted, otherwise the first character will always be a quote character "</param>
+        /// <returns>true if argument's beginning matches one of possible indicators
+        /// <br/>false if argument's beginning doesn't match any of correct indicator
+        /// </returns>
+        private static bool ValidateSwitchIndicatorInUnquotedArgument(string unquotedCommandLineArgument)
         {
-            // If we got to this method we should have to possible projects or solutions and some extensions to ignore
-            ErrorUtilities.VerifyThrow(potentialProjectOrSolutionFiles?.Length > 0, "There should be some potential project or solution files");
-            ErrorUtilities.VerifyThrow(extensionsToIgnoreDictionary?.Count > 0, "There should be some extensions to Ignore");
+            return unquotedCommandLineArgument.StartsWith("-", StringComparison.Ordinal) // superset of "--"
+                || unquotedCommandLineArgument.StartsWith("/", StringComparison.Ordinal);
+        }
 
-            List<string> filesToKeep = new List<string>();
-            foreach (string projectOrSolutionFile in potentialProjectOrSolutionFiles)
+        /// <summary>
+        /// Gets the length of the switch indicator (- or / or --)
+        /// <br/>The length returned from this method is deduced from the beginning sequence of unquoted argument.
+        /// <br/>This way it will "assume" that there's no further error (e.g. //  or ---) which would also be considered as a correct indicator.
+        /// </summary>
+        /// <param name="unquotedSwitch">Unquoted argument with leading indicator and name</param>
+        /// <returns>Correct length of used indicator
+        /// <br/>0 if no leading sequence recognized as correct indicator</returns>
+        /// Internal for testing purposes
+        internal static int GetLengthOfSwitchIndicator(string unquotedSwitch)
+        {
+            if (unquotedSwitch.StartsWith("--", StringComparison.Ordinal))
             {
-                string extension = Path.GetExtension(projectOrSolutionFile);
-                // Check to see if the file extension of the project is in our ignore list. If not keep the file
-                if (!extensionsToIgnoreDictionary.ContainsKey(extension))
-                {
-                    filesToKeep.Add(projectOrSolutionFile);
-                }
+                return 2;
+            }
+            else if (unquotedSwitch.StartsWith("-", StringComparison.Ordinal) || unquotedSwitch.StartsWith("/", StringComparison.Ordinal))
+            {
+                return 1;
+            }
+            else
+            {
+                return 0;
             }
-            return filesToKeep.ToArray();
         }
 
         /// <summary>
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 0d9ca6d8f34..44d367d12ca 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -48,8 +48,14 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Build.CPPTasks.Common" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <bindingRedirect oldVersion="16.0.0.0-16.8.0.0" newVersion="16.8.0.0" />
-          <codeBase version="16.8.0.0" href="..\..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
+          <bindingRedirect oldVersion="16.0.0.0-16.9.0.0" newVersion="16.9.0.0" />
+          <codeBase version="16.9.0.0" href="..\..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
+        </dependentAssembly>
+
+        <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
+        <dependentAssembly>
+          <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
         </dependentAssembly>
 
         <!-- Redirects for components dropped by Visual Studio -->
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 07b6a964c1c..7a2af88853e 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -41,6 +41,12 @@
           <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="15.1.0.0" />
         </dependentAssembly>
 
+        <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
+        <dependentAssembly>
+          <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
+        </dependentAssembly>
+
         <!-- Redirects for components dropped by Visual Studio -->
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Activities.Build" culture="neutral" publicKeyToken="31bf3856ad364e35" />
@@ -54,8 +60,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Build.CPPTasks.Common" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <bindingRedirect oldVersion="16.0.0.0-16.8.0.0" newVersion="16.8.0.0" />
-          <codeBase version="16.8.0.0" href="..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
+          <bindingRedirect oldVersion="16.0.0.0-16.9.0.0" newVersion="16.9.0.0" />
+          <codeBase version="16.9.0.0" href="..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
         </dependentAssembly>
 
         <!-- Workaround for crash in C++ CodeAnalysis scenarios due to https://github.com/Microsoft/msbuild/issues/1675 -->
diff --git a/src/MSBuildTaskHost/AssemblyInfo.cs b/src/MSBuildTaskHost/AssemblyInfo.cs
index bf85c36e740..11f47e95489 100644
--- a/src/MSBuildTaskHost/AssemblyInfo.cs
+++ b/src/MSBuildTaskHost/AssemblyInfo.cs
@@ -1,5 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Reflection;
+using System.Runtime.CompilerServices;
 
+[assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
diff --git a/src/MSBuildTaskHost/FileSystem/MSBuildTaskHostFileSystem.cs b/src/MSBuildTaskHost/FileSystem/MSBuildTaskHostFileSystem.cs
index 3b285db56ba..103061df36c 100644
--- a/src/MSBuildTaskHost/FileSystem/MSBuildTaskHostFileSystem.cs
+++ b/src/MSBuildTaskHost/FileSystem/MSBuildTaskHostFileSystem.cs
@@ -21,6 +21,16 @@ public bool DirectoryEntryExists(string path)
             return NativeMethodsShared.FileOrDirectoryExists(path);
         }
 
+        public FileAttributes GetAttributes(string path)
+        {
+            return File.GetAttributes(path);
+        }
+
+        public DateTime GetLastWriteTimeUtc(string path)
+        {
+            return File.GetLastWriteTimeUtc(path);
+        }
+
         public bool DirectoryExists(string path)
         {
             return NativeMethodsShared.DirectoryExists(path);
@@ -31,6 +41,26 @@ public IEnumerable<string> EnumerateDirectories(string path, string searchPatter
             return Directory.GetDirectories(path, searchPattern, searchOption);
         }
 
+        public TextReader ReadFile(string path)
+        {
+            return new StreamReader(path);
+        }
+
+        public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share)
+        {
+            return new FileStream(path, mode, access, share);
+        }
+
+        public string ReadFileAllText(string path)
+        {
+            return File.ReadAllText(path);
+        }
+
+        public byte[] ReadFileAllBytes(string path)
+        {
+            return File.ReadAllBytes(path);
+        }
+
         public IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
         {
             return Directory.GetFiles(path, searchPattern, searchOption);
diff --git a/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs b/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs
new file mode 100644
index 00000000000..c540a86288e
--- /dev/null
+++ b/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs
@@ -0,0 +1,271 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.Collections.Generic;
+using System.Linq;
+
+namespace System.Collections.Immutable
+{
+    static class ImmutableExtensions
+    {
+        public static ImmutableDictionary<K,V> ToImmutableDictionary<K,V>(this IDictionary<K,V> dictionary)
+        {
+            return new ImmutableDictionary<K, V>(dictionary);
+        }
+    }
+
+    static class ImmutableDictionary
+    {
+        internal static ImmutableDictionary<K, V> Create<K, V>(IEqualityComparer<K> comparer)
+        {
+            return new ImmutableDictionary<K, V>(comparer);
+        }
+    }
+
+    /// <summary>
+    /// Inefficient ImmutableDictionary implementation: keep a mutable dictionary and wrap all operations.
+    /// </summary>
+    /// <typeparam name="K"></typeparam>
+    /// <typeparam name="V"></typeparam>
+    sealed class ImmutableDictionary<K, V> : IDictionary<K, V>, IDictionary
+    {
+        /// <summary>
+        /// The underlying dictionary.
+        /// </summary>
+        private Dictionary<K, V> _backing;
+
+        #region Read-only Operations
+
+        public ICollection<K> Keys => _backing.Keys;
+        public ICollection<V> Values => _backing.Values;
+
+        ICollection IDictionary.Keys => _backing.Keys;
+        ICollection IDictionary.Values => _backing.Values;
+
+        public int Count => _backing.Count;
+
+        public V this[K key] => _backing[key];
+
+        public bool IsReadOnly => true;
+        public bool IsFixedSize => true;
+        public bool IsSynchronized => true;
+
+        public object SyncRoot => this;
+
+        public bool TryGetValue(K key, out V value)
+        {
+            return _backing.TryGetValue(key, out value);
+        }
+
+        public bool Contains(KeyValuePair<K, V> item)
+        {
+            return _backing.Contains(item);
+        }
+
+        bool IDictionary.Contains(object key)
+        {
+            return ((IDictionary)_backing).Contains(key);
+        }
+
+        public bool ContainsKey(K key)
+        {
+            return _backing.ContainsKey(key);
+        }
+
+        public IEnumerator<KeyValuePair<K, V>> GetEnumerator()
+        {
+            return _backing.GetEnumerator();
+        }
+
+        IDictionaryEnumerator IDictionary.GetEnumerator()
+        {
+            return _backing.GetEnumerator();
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            return _backing.GetEnumerator();
+        }
+
+        void ICollection<KeyValuePair<K, V>>.CopyTo(KeyValuePair<K, V>[] array, int arrayIndex)
+        {
+            CheckCopyToArguments(array, arrayIndex);
+            foreach (var item in this)
+            {
+                array[arrayIndex++] = item;
+            }
+        }
+
+        void ICollection.CopyTo(Array array, int arrayIndex)
+        {
+            CheckCopyToArguments(array, arrayIndex);
+            foreach (var item in this)
+            {
+                array.SetValue(new DictionaryEntry(item.Key, item.Value), arrayIndex++);
+            }
+        }
+
+        private void CheckCopyToArguments(Array array, int arrayIndex)
+        {
+            if (array == null)
+            {
+                throw new ArgumentNullException(nameof(array));
+            }
+            if (arrayIndex < 0)
+            {
+                throw new ArgumentOutOfRangeException(nameof(arrayIndex));
+            }
+            if (arrayIndex + Count > array.Length)
+            {
+                throw new ArgumentException(nameof(arrayIndex));
+            }
+        }
+
+        #endregion
+
+        #region Write Operations
+
+        internal ImmutableDictionary<K, V> SetItem(K key, V value)
+        {
+            if (TryGetValue(key, out V existingValue) && Object.Equals(existingValue, value))
+            {
+                return this;
+            }
+
+            var clone = new ImmutableDictionary<K, V>(_backing);
+            clone._backing[key] = value;
+
+            return clone;
+        }
+
+        internal ImmutableDictionary<K, V> Remove(K key)
+        {
+            if (!ContainsKey(key))
+            {
+                return this;
+            }
+
+            var clone = new ImmutableDictionary<K, V>(_backing);
+            clone._backing.Remove(key);
+
+            return clone;
+        }
+
+        internal ImmutableDictionary<K, V> Clear()
+        {
+            return new ImmutableDictionary<K, V>(_backing.Comparer);
+        }
+
+        internal ImmutableDictionary()
+        {
+            _backing = new Dictionary<K, V>();
+        }
+
+        internal ImmutableDictionary(IEqualityComparer<K> comparer)
+        {
+            _backing = new Dictionary<K, V>(comparer);
+        }
+
+        internal ImmutableDictionary(IDictionary<K, V> source, IEqualityComparer<K> keyComparer = null)
+        {
+            if (source is ImmutableDictionary<K, V> imm)
+            {
+                _backing = new Dictionary<K, V>(imm._backing, keyComparer ?? imm._backing.Comparer);
+            }
+            else
+            {
+                _backing = new Dictionary<K, V>(source, keyComparer);
+            }
+        }
+
+        internal static ImmutableDictionary<K, V> Empty
+        {
+            get
+            {
+                return new ImmutableDictionary<K, V>();
+            }
+        }
+
+        public IEqualityComparer<K> KeyComparer { get => _backing.Comparer; internal set => throw new NotSupportedException(); }
+
+        internal KeyValuePair<K, V>[] ToArray()
+        {
+            return _backing.ToArray();
+        }
+
+        internal ImmutableDictionary<K, V> AddRange(KeyValuePair<K, V>[] v)
+        {
+            var n = new Dictionary<K, V>(_backing, _backing.Comparer);
+
+            foreach (var item in v)
+            {
+                n.Add(item.Key, item.Value);
+            }
+
+            return new ImmutableDictionary<K, V>(n);
+        }
+
+        internal ImmutableDictionary<K, V> WithComparers(IEqualityComparer<K> keyComparer)
+        {
+            return new ImmutableDictionary<K, V>(_backing, keyComparer);
+        }
+
+        #endregion
+
+        #region Unsupported Operations
+
+        object IDictionary.this[object key]
+        {
+            get { return _backing[(K)key]; }
+            set { throw new NotSupportedException(); }
+        }
+
+        void IDictionary.Add(object key, object value)
+        {
+            throw new NotSupportedException();
+        }
+
+        void IDictionary.Remove(object key)
+        {
+            throw new NotSupportedException();
+        }
+
+        void IDictionary.Clear()
+        {
+            throw new NotSupportedException();
+        }
+
+        V IDictionary<K, V>.this[K key]
+        {
+            get { return _backing[key]; }
+            set { throw new NotSupportedException(); }
+        }
+
+        void IDictionary<K, V>.Add(K key, V value)
+        {
+            throw new NotSupportedException();
+        }
+
+        bool IDictionary<K, V>.Remove(K key)
+        {
+            throw new NotSupportedException();
+        }
+
+        void ICollection<KeyValuePair<K, V>>.Add(KeyValuePair<K, V> item)
+        {
+            throw new NotSupportedException();
+        }
+
+        void ICollection<KeyValuePair<K, V>>.Clear()
+        {
+            throw new NotSupportedException();
+        }
+
+        bool ICollection<KeyValuePair<K, V>>.Remove(KeyValuePair<K, V> item)
+        {
+            throw new NotSupportedException();
+        }
+
+        #endregion
+    }
+}
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 7fa58465d0b..615488880be 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -166,6 +166,7 @@
     <Compile Include="AssemblyResources.cs" />
     <Compile Include="Concurrent\ConcurrentDictionary.cs" />
     <Compile Include="Concurrent\ConcurrentQueue.cs" />
+    <Compile Include="Immutable\ImmutableDictionary.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
     <Compile Include="TypeLoader.cs" />
     <Compile Include="WeakStringCache.Locking.cs" />
@@ -197,7 +198,6 @@
     </Compile>
     <Compile Include="OutOfProcTaskAppDomainWrapper.cs" />
   </ItemGroup>
-  <ItemGroup />
   <ItemGroup>
     <None Include="app.config" />
   </ItemGroup>
diff --git a/src/MSBuildTaskHost/OutOfProcTaskAppDomainWrapper.cs b/src/MSBuildTaskHost/OutOfProcTaskAppDomainWrapper.cs
index 409480581b0..9ad2624a492 100644
--- a/src/MSBuildTaskHost/OutOfProcTaskAppDomainWrapper.cs
+++ b/src/MSBuildTaskHost/OutOfProcTaskAppDomainWrapper.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.CommandLine
 {
diff --git a/src/MSBuildTaskHost/OutOfProcTaskHost.cs b/src/MSBuildTaskHost/OutOfProcTaskHost.cs
index 61861caac5f..48f3dce2cde 100644
--- a/src/MSBuildTaskHost/OutOfProcTaskHost.cs
+++ b/src/MSBuildTaskHost/OutOfProcTaskHost.cs
@@ -2,13 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Diagnostics;
 
 // CR: We could move MSBuildApp.ExitType out of MSBuildApp
-using Microsoft.Build.CommandLine;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
diff --git a/src/MSBuildTaskHost/Properties/AssemblyInfo.cs b/src/MSBuildTaskHost/Properties/AssemblyInfo.cs
index a99ec575844..7b572bc6037 100644
--- a/src/MSBuildTaskHost/Properties/AssemblyInfo.cs
+++ b/src/MSBuildTaskHost/Properties/AssemblyInfo.cs
@@ -1,6 +1,4 @@
 ﻿using System;
-using System.Reflection;
-using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 
 // The following GUID is for the ID of the typelib if this project is exposed to COM
diff --git a/src/MSBuildTaskHost/TypeLoader.cs b/src/MSBuildTaskHost/TypeLoader.cs
index 1b8bdd09f92..59579d98cac 100644
--- a/src/MSBuildTaskHost/TypeLoader.cs
+++ b/src/MSBuildTaskHost/TypeLoader.cs
@@ -4,11 +4,7 @@
 using System;
 using System.IO;
 using System.Reflection;
-using System.Collections;
-using System.Globalization;
 using System.Collections.Generic;
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
 using System.Threading;
 
 namespace Microsoft.Build.Shared
diff --git a/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec b/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec
index 1cedee0fe1d..14bfd426aff 100644
--- a/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec
+++ b/src/Package/DevDivPackage/VS.ExternalAPIs.MSBuild.nuspec
@@ -4,8 +4,11 @@
     <id>VS.ExternalAPIs.MSBuild</id>
     <summary>CoreXT package containing MSBuild binaries for the VS build.</summary>
     <description>CoreXT package containing MSBuild binaries for the VS build. Produced from the MSBuild $branchname$ branch.</description>
-    <authors>MSBuild</authors>
+    <authors>Microsoft</authors>
+    <copyright>© Microsoft Corporation. All rights reserved.</copyright>
+    <projectUrl>$projectUrl$</projectUrl>
     <version>0.0</version>
+    <license type="expression">$licenseExpression$</license>
     <dependencies>
       <group targetFramework=".NETFramework4.7.2" />
     </dependencies>
@@ -24,4 +27,4 @@
     <file src="Microsoft.Build.Framework.tlb" target="lib\net472" />
     <file src="Microsoft.Build.Tasks.Core.tlb" target="lib\net472" />
   </files>
-</package>
\ No newline at end of file
+</package>
diff --git a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
index f2132af28e6..9482f3faf5d 100644
--- a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
+++ b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
@@ -4,8 +4,11 @@
     <id>MsBuild.Engine.Corext</id>
     <summary>Aggregate of MsBuild.Corext with the latest MSBuild team deliverables</summary>
     <description>Use this package to update your existing MsBuild.Corext package to the latest MSBuild binaries and core build files.</description>
+    <projectUrl>$projectUrl$</projectUrl>
+    <license type="expression">$licenseExpression$</license>
     <requireLicenseAcceptance>false</requireLicenseAcceptance>
-    <authors>msbtm@microsoft.com</authors>
+    <authors>Microsoft</authors>
+    <copyright>© Microsoft Corporation. All rights reserved.</copyright>
     <version>$version$</version>
   </metadata>
 
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 44277b783c7..2f87ef174f2 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -6,6 +6,7 @@ package name=Microsoft.Build
         vs.package.language=neutral
 
 vs.dependencies
+  vs.dependency id=Microsoft.Build.UnGAC
   vs.dependency id=Microsoft.VisualStudio.PackageGroup.NuGet
                 version=[15.0,17.0)
 
@@ -47,7 +48,7 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
   file source=$(X86BinPath)Microsoft.Common.CrossTargeting.targets
   file source=$(X86BinPath)Microsoft.Common.overridetasks
diff --git a/src/Package/Microsoft.Build.UnGAC/Microsoft.Build.UnGAC.csproj b/src/Package/Microsoft.Build.UnGAC/Microsoft.Build.UnGAC.csproj
new file mode 100644
index 00000000000..6282c3a2134
--- /dev/null
+++ b/src/Package/Microsoft.Build.UnGAC/Microsoft.Build.UnGAC.csproj
@@ -0,0 +1,29 @@
+﻿<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <!-- Setup runs on net45 and may not have installed newer yet. -->
+    <TargetFramework>net45</TargetFramework>
+    <!-- Set as an exe because this project publishes its own output. -->
+    <OutputType>Exe</OutputType>
+    <!-- Forcing the 'vsix' output to be json output. Workaround for https://github.com/dotnet/arcade/issues/6120 -->
+    <TargetVsixContainerName>Microsoft.Build.UnGAC.exe</TargetVsixContainerName>
+    <!-- VS Insertion -->
+    <VisualStudioInsertionComponent>Microsoft.Build.UnGAC</VisualStudioInsertionComponent>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <_SwixArgs Include="PackageType=manifest"/>
+    <!-- If we don't set TargetExt to .json, arcade defaults to generating a .vsix -->
+    <_SwixArgs Include="TargetExt=.json"/>
+  </ItemGroup>
+
+  <!-- SwrProperty is an arcade concept. -->
+  <ItemGroup>
+    <!-- BinDir is set via SwrProperty to be passed to the swr compiler. OutDir is the path to the bin folder. See exe.swr to see how this is used. -->
+    <SwrProperty Include="BinDir=$(OutDir)" />
+    <!-- Version must constantly update in order for our exe package to run on install and update. -->
+    <SwrProperty Include="Version=$(VsixVersion)" />
+
+    <!-- our swr file must be picked up, this is how we set that. -->
+    <SwrFile Include="exe.swr" Condition=" '$(MSBuildRuntimeType)' == 'Full' " />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src/Package/Microsoft.Build.UnGAC/NativeMethods.cs b/src/Package/Microsoft.Build.UnGAC/NativeMethods.cs
new file mode 100644
index 00000000000..f468942cf12
--- /dev/null
+++ b/src/Package/Microsoft.Build.UnGAC/NativeMethods.cs
@@ -0,0 +1,22 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Runtime.InteropServices;
+
+namespace Microsoft.Build.UnGAC
+{
+    // See: https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/fusion/iassemblycache-interface
+    [ComImport, Guid("E707DCDE-D1CD-11D2-BAB9-00C04F8ECEAE"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
+    internal interface IAssemblyCache
+    {
+        [PreserveSig]
+        uint UninstallAssembly(uint dwFlags, [MarshalAs(UnmanagedType.LPWStr)] string pszAssemblyName, IntPtr pRefData, ref ulong pulDisposition);
+    }
+
+    public static class NativeMethods
+    {
+        [DllImport("fusion.dll")]
+        internal static extern uint CreateAssemblyCache(out IAssemblyCache ppAsmCache, int dwReserved);
+    }
+}
diff --git a/src/Package/Microsoft.Build.UnGAC/Program.cs b/src/Package/Microsoft.Build.UnGAC/Program.cs
new file mode 100644
index 00000000000..c5b5caa710d
--- /dev/null
+++ b/src/Package/Microsoft.Build.UnGAC/Program.cs
@@ -0,0 +1,53 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+
+namespace Microsoft.Build.UnGAC
+{
+    /// <summary>
+    /// Original Issue: https://github.com/dotnet/msbuild/issues/5183
+    /// This tool was created to help prevent customers from putting MSBuild assemblies in the Global Assembly Cache.
+    /// It runs at VS install-time as well as repair-time.
+    /// It is intended to run as best effort. Meaning that if it fails, we avoid throwing and instead log it.
+    /// </summary>
+    class Program
+    {
+        static void Main(string[] args)
+        {
+            try
+            {
+                string[] assembliesToUnGAC =
+                {
+                    "Microsoft.Build, Version=15.1.0.0",
+                    "Microsoft.Build.Engine, Version=15.1.0.0",
+                    "Microsoft.Build.Framework, Version=15.1.0.0",
+                    "Microsoft.Build.Tasks.Core, Version=15.1.0.0",
+                    "Microsoft.Build.Utilities.Core, Version=15.1.0.0",
+                    "Microsoft.Build.Conversion.Core, Version=15.1.0.0"
+                };
+
+                uint hresult = NativeMethods.CreateAssemblyCache(out IAssemblyCache assemblyCache, 0);
+
+                // Most significant bit is set, meaning there was an error in the Hresult.
+                if ((hresult >> 31) == 1)
+                {
+                    Console.WriteLine($"Could not successfully call CreateAssemblyCache. HResult: {hresult}");
+                    Console.WriteLine("Exiting without removing assemblies from the GAC...");
+                    return;
+                }
+
+                foreach (string assembly in assembliesToUnGAC)
+                {
+                    hresult = assemblyCache.UninstallAssembly(dwFlags: 0, pszAssemblyName: assembly, pRefData: IntPtr.Zero, pulDisposition: 0);
+
+                    Console.WriteLine($"Tried to remove {assembly} from the GAC. HResult: 0x{hresult:X8}");
+                }
+            }
+            catch (Exception e)
+            {
+                Console.WriteLine($"Caught an exception! We don't want to throw because we want MSBuild to install.\n" + e.ToString());
+            }
+        }
+    }
+}
diff --git a/src/Package/Microsoft.Build.UnGAC/exe.swr b/src/Package/Microsoft.Build.UnGAC/exe.swr
new file mode 100644
index 00000000000..9a717021a50
--- /dev/null
+++ b/src/Package/Microsoft.Build.UnGAC/exe.swr
@@ -0,0 +1,19 @@
+use vs
+
+package name=Microsoft.Build.UnGAC
+        version=$(Version)
+        vs.package.type=exe
+        vs.package.chip=neutral
+        vs.package.language=neutral
+
+vs.installCommand fileName=[Payload]
+
+vs.repairCommand fileName=[Payload]
+
+vs.installSize
+  SystemDrive=0
+  TargetDrive=0
+  SharedDrive=0
+
+vs.payloads
+    vs.payload source=$(BinDir)Microsoft.Build.UnGAC.exe
diff --git a/src/Samples/Dependency/Alpha.cs b/src/Samples/Dependency/Alpha.cs
index 11a097028f7..61ad4b52b6a 100644
--- a/src/Samples/Dependency/Alpha.cs
+++ b/src/Samples/Dependency/Alpha.cs
@@ -1,12 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
 namespace Dependency
 {
     public class Alpha
diff --git a/src/Samples/Dependency/Properties/AssemblyInfo.cs b/src/Samples/Dependency/Properties/AssemblyInfo.cs
index b61d429590f..1b7d6870cf6 100644
--- a/src/Samples/Dependency/Properties/AssemblyInfo.cs
+++ b/src/Samples/Dependency/Properties/AssemblyInfo.cs
@@ -3,8 +3,6 @@
 
 using System.Resources;
 using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
 
 // General Information about an assembly is controlled through the following
 // set of attributes. Change these attribute values to modify the information
diff --git a/src/Samples/PortableTask/Properties/AssemblyInfo.cs b/src/Samples/PortableTask/Properties/AssemblyInfo.cs
index 75cf54e9b05..acc604b168d 100644
--- a/src/Samples/PortableTask/Properties/AssemblyInfo.cs
+++ b/src/Samples/PortableTask/Properties/AssemblyInfo.cs
@@ -3,8 +3,6 @@
 
 using System.Resources;
 using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
 
 // General Information about an assembly is controlled through the following 
 // set of attributes. Change these attribute values to modify the information
diff --git a/src/Samples/PortableTask/Sleep.cs b/src/Samples/PortableTask/Sleep.cs
index 9053276192e..19c1c1663bd 100644
--- a/src/Samples/PortableTask/Sleep.cs
+++ b/src/Samples/PortableTask/Sleep.cs
@@ -1,7 +1,4 @@
 ﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 using System.Threading.Tasks;
 
 namespace PortableTask
diff --git a/src/Samples/TaskUsageLogger/Properties/AssemblyInfo.cs b/src/Samples/TaskUsageLogger/Properties/AssemblyInfo.cs
index d73eddfb906..fd24e6b516b 100644
--- a/src/Samples/TaskUsageLogger/Properties/AssemblyInfo.cs
+++ b/src/Samples/TaskUsageLogger/Properties/AssemblyInfo.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Reflection;
-using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 
 // General Information about an assembly is controlled through the following 
diff --git a/src/Samples/TaskUsageLogger/TaskUsageLogger.cs b/src/Samples/TaskUsageLogger/TaskUsageLogger.cs
index be374631b4d..4ed1dbcb9b0 100644
--- a/src/Samples/TaskUsageLogger/TaskUsageLogger.cs
+++ b/src/Samples/TaskUsageLogger/TaskUsageLogger.cs
@@ -215,7 +215,7 @@ private void GatherAndEvaluateDefaultTasksForToolsVersion(string toolsVersion, P
         /// </summary>
         private void GatherAndEvaluateTasksForProject(Project p, int projectContextId)
         {
-            HashSet<UsingTaskData> usingTasks = null;
+            HashSet<UsingTaskData> usingTasks;
             if (!_tasksByProjectContextId.TryGetValue(projectContextId, out usingTasks))
             {
                 usingTasks = new HashSet<UsingTaskData>();
@@ -248,7 +248,7 @@ private void GatherAndEvaluatedTasksInFile(ProjectRootElement pre, Project conta
                 string evaluatedTaskName = EvaluateIfNecessary(usingTask.TaskName, containingProject);
 
                 // A task registration can define either AssemblyName or AssemblyFile, but not both.
-                string evaluatedTaskAssemblyPath = null;
+                string evaluatedTaskAssemblyPath;
                 if (String.IsNullOrEmpty(usingTask.AssemblyName))
                 {
                     evaluatedTaskAssemblyPath = EvaluateIfNecessary(usingTask.AssemblyFile, containingProject);
diff --git a/src/Samples/TaskWithDependency/LogStringFromDependency.cs b/src/Samples/TaskWithDependency/LogStringFromDependency.cs
index a26888a128d..b1c902ff02b 100644
--- a/src/Samples/TaskWithDependency/LogStringFromDependency.cs
+++ b/src/Samples/TaskWithDependency/LogStringFromDependency.cs
@@ -1,8 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
-using System.Reflection;
 using Dependency;
 
 namespace TaskWithDependency
diff --git a/src/Samples/TaskWithDependency/Properties/AssemblyInfo.cs b/src/Samples/TaskWithDependency/Properties/AssemblyInfo.cs
index 916799f691d..518b51cd063 100644
--- a/src/Samples/TaskWithDependency/Properties/AssemblyInfo.cs
+++ b/src/Samples/TaskWithDependency/Properties/AssemblyInfo.cs
@@ -3,8 +3,6 @@
 
 using System.Resources;
 using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
 
 // General Information about an assembly is controlled through the following 
 // set of attributes. Change these attribute values to modify the information
diff --git a/src/Samples/XmlFileLogger/Properties/AssemblyInfo.cs b/src/Samples/XmlFileLogger/Properties/AssemblyInfo.cs
index ce2c367b25e..051d53af8b3 100644
--- a/src/Samples/XmlFileLogger/Properties/AssemblyInfo.cs
+++ b/src/Samples/XmlFileLogger/Properties/AssemblyInfo.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Reflection;
-using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 
 // General Information about an assembly is controlled through the following 
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
index e36e10ad324..da266d8220e 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
@@ -261,7 +261,7 @@ OpenBaseKey openBaseKey
 
                     string directoryName = getRegistrySubKeyDefaultValue(baseKey, directoryKey.RegistryKey);
 
-                    if (null != directoryName)
+                    if (directoryName != null)
                     {
                         _uniqueDirectoryPaths.Add(directoryName);
                         _directoryNames.Add(new AssemblyFoldersExInfo(hive, view, directoryKey.RegistryKey, directoryName, directoryKey.TargetFrameworkVersion));
@@ -387,7 +387,7 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
                         // To be added to our dictionary our candidate version from the registry must be a valid target framework version which is less than or equal 
                         // to the target version. Therefore if the candidate version is not a valid target framework version we will pretend it is and sort it in its correct form.
 
-                        Version replacementVersion = null;
+                        Version replacementVersion;
                         if (candidateVersion.Build > 255)
                         {
                             // Pretend the candidate version is really Maj.Minor ignore the build and revision
@@ -457,7 +457,7 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
         /// </summary>
         private static void AddCandidateVersion(SortedDictionary<Version, List<string>> targetFrameworkVersionToRegistryVersions, string version, Version candidateVersion)
         {
-            List<string> listOfFrameworks = null;
+            List<string> listOfFrameworks;
             if (targetFrameworkVersionToRegistryVersions.TryGetValue(candidateVersion, out listOfFrameworks))
             {
                 listOfFrameworks.Add(version);
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs b/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs
index 405adacf084..de37122792b 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.IO;
 using System.Linq;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.AssemblyFoldersFromConfig;
diff --git a/src/Shared/AssemblyFolders/Serialization/AssemblyFolderItem.cs b/src/Shared/AssemblyFolders/Serialization/AssemblyFolderItem.cs
index 8d24dc64e5f..ba2973e27ce 100644
--- a/src/Shared/AssemblyFolders/Serialization/AssemblyFolderItem.cs
+++ b/src/Shared/AssemblyFolders/Serialization/AssemblyFolderItem.cs
@@ -1,7 +1,5 @@
-﻿using System;
-using System.Diagnostics;
+﻿using System.Diagnostics;
 using System.Runtime.Serialization;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Shared.AssemblyFoldersFromConfig
 {
diff --git a/src/Shared/AssemblyLoadInfo.cs b/src/Shared/AssemblyLoadInfo.cs
index 15fa6b27e44..014d7d411df 100644
--- a/src/Shared/AssemblyLoadInfo.cs
+++ b/src/Shared/AssemblyLoadInfo.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.IO;
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using System.Diagnostics;
 
diff --git a/src/Shared/AssemblyNameComparer.cs b/src/Shared/AssemblyNameComparer.cs
index 554b52060af..389de34083b 100644
--- a/src/Shared/AssemblyNameComparer.cs
+++ b/src/Shared/AssemblyNameComparer.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
 using System.Collections;
 using System.Collections.Generic;
 
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index 1986216d384..1d4f2a4bf71 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -4,9 +4,7 @@
 using System;
 using System.Text;
 using System.Reflection;
-using System.Collections;
 using System.Globalization;
-using System.Diagnostics;
 using System.Collections.Generic;
 using System.Configuration.Assemblies;
 using System.Runtime.Serialization;
@@ -496,8 +494,7 @@ internal int CompareTo(AssemblyNameExtension that, bool considerRetargetableFlag
                 }
 
                 // Will not return 0 as the this != that check above takes care of the case where they are equal.
-                result = this.Version.CompareTo(that.Version);
-                return result;
+                return this.Version.CompareTo(that.Version);
             }
 
             // We need some final collating order for these, alphabetical by FullName seems as good as any.
@@ -713,7 +710,7 @@ private bool EqualsImpl(AssemblyNameExtension that, bool ignoreVersion, bool con
             }
 
             // If that is null then this and that are not equal. Also, this would cause a crash on the next line.
-            if (object.ReferenceEquals(that, null))
+            if (that is null)
             {
                 return false;
             }
@@ -923,7 +920,7 @@ internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFl
             }
 
             // If that is null then this and that are not equal. Also, this would cause a crash on the next line.
-            if (object.ReferenceEquals(that, null))
+            if (that is null)
             {
                 return false;
             }
diff --git a/src/Shared/AwaitExtensions.cs b/src/Shared/AwaitExtensions.cs
index 7a96844a816..b47da420b1f 100644
--- a/src/Shared/AwaitExtensions.cs
+++ b/src/Shared/AwaitExtensions.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Concurrent;
-using System.Globalization;
 using System.Runtime.CompilerServices;
 using System.Threading;
 using System.Threading.Tasks;
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index d8bd3da94f8..1a6c9e3c39c 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -2,19 +2,11 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Collections.ObjectModel;
 using System.Diagnostics;
-using System.Linq;
-using System.Text;
 using System.IO;
-using System.Threading;
 using System.Runtime.Serialization.Formatters.Binary;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using System.Globalization;
 using System.Reflection;
@@ -201,6 +193,17 @@ public void Translate(ref byte[] byteArray)
                 }
             }
 
+            /// <summary>
+            /// Translates a byte array
+            /// </summary>
+            /// <param name="byteArray">The array to be translated.</param>
+            /// <param name="length">The length of array which will be used in translation. This parameter is not used when reading</param>
+            public void Translate(ref byte[] byteArray, ref int length) 
+            {
+                Translate(ref byteArray);
+                length = byteArray.Length;
+            }
+
             /// <summary>
             /// Translates a string array.
             /// </summary>
@@ -786,8 +789,7 @@ public void Translate(ref string[] array)
                     return;
                 }
 
-                int count = 0;
-                count = array.Length;
+                int count = array.Length;
                 _writer.Write(count);
 
                 for (int i = 0; i < count; i++)
@@ -997,17 +999,27 @@ public void Translate<T>(ref T value)
             /// </summary>
             /// <param name="byteArray">The byte array to be translated</param>
             public void Translate(ref byte[] byteArray)
+            {
+                var length = byteArray?.Length ?? 0;
+                Translate(ref byteArray, ref length);
+            }
+
+            /// <summary>
+            /// Translates a byte array
+            /// </summary>
+            /// <param name="byteArray">The array to be translated.</param>
+            /// <param name="length">The length of array which will be used in translation</param>
+            public void Translate(ref byte[] byteArray, ref int length) 
             {
                 if (!TranslateNullable(byteArray))
                 {
                     return;
                 }
 
-                int count = byteArray.Length;
-                _writer.Write(count);
-                if (count > 0)
+                _writer.Write(length);
+                if (length > 0)
                 {
-                    _writer.Write(byteArray);
+                    _writer.Write(byteArray, 0, length);
                 }
             }
 
diff --git a/src/Shared/BinaryWriterExtensions.cs b/src/Shared/BinaryWriterExtensions.cs
index f6d77b447bb..f4f5b00d73b 100644
--- a/src/Shared/BinaryWriterExtensions.cs
+++ b/src/Shared/BinaryWriterExtensions.cs
@@ -1,10 +1,6 @@
 ﻿using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Linq;
 using System.Runtime.CompilerServices;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Shared
 {
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index a5c7fb21cdd..9d211bc1148 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -7,7 +7,6 @@
 using System.Linq;
 using System.Collections.Generic;
 using System.Text.RegularExpressions;
-using System.Threading;
 using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
diff --git a/src/Shared/BuildEventFileInfo.cs b/src/Shared/BuildEventFileInfo.cs
index a25508300de..7f2225e9fb4 100644
--- a/src/Shared/BuildEventFileInfo.cs
+++ b/src/Shared/BuildEventFileInfo.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Xml;
-using System.Xml.Schema;
 using Microsoft.Build.Construction;
 
 namespace Microsoft.Build.Shared
@@ -70,7 +69,7 @@ internal BuildEventFileInfo(string file, int line, int column)
         internal BuildEventFileInfo(string file, int line, int column, int endLine, int endColumn)
         {
             // Projects that don't have a filename when the are built should use an empty string instead.
-            _file = (file == null) ? String.Empty : file;
+            _file = file ?? String.Empty;
             _line = line;
             _column = column;
             _endLine = endLine;
diff --git a/src/Shared/CanonicalError.cs b/src/Shared/CanonicalError.cs
index f0c247113f6..6b8377e6531 100644
--- a/src/Shared/CanonicalError.cs
+++ b/src/Shared/CanonicalError.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Collections;
-using System.Diagnostics;
 using System.Globalization;
 using System.Text.RegularExpressions;
 
diff --git a/src/Shared/ChangeWaves.cs b/src/Shared/ChangeWaves.cs
new file mode 100644
index 00000000000..29487ea8b78
--- /dev/null
+++ b/src/Shared/ChangeWaves.cs
@@ -0,0 +1,208 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Shared;
+using System;
+using System.Linq;
+
+namespace Microsoft.Build.Utilities
+{
+    internal enum ChangeWaveConversionState
+    {
+        NotConvertedYet,
+        Valid,
+        InvalidFormat,
+        OutOfRotation
+    }
+
+    /// <summary>
+    /// All waves are enabled by default, meaning all features behind change wave versions are enabled.
+    /// </summary>
+    public class ChangeWaves
+    {
+        public static readonly string[] AllWaves = { Wave16_8, Wave16_10, Wave17_0 };
+        public static readonly Version[] AllWavesAsVersion = Array.ConvertAll<string, Version>(AllWaves, Version.Parse);
+        public const string Wave16_8 = "16.8";
+        public const string Wave16_10 = "16.10";
+        public const string Wave17_0 = "17.0";
+
+        /// <summary>
+        /// Special value indicating that all features behind change-waves should be enabled.
+        /// </summary>
+        public const string EnableAllFeatures = "999.999";
+
+        internal static readonly Version LowestWaveAsVersion = new Version(AllWaves[0]);
+        internal static readonly Version HighestWaveAsVersion = new Version(AllWaves[AllWaves.Length - 1]);
+        internal static readonly Version EnableAllFeaturesAsVersion = new Version(EnableAllFeatures);
+
+        internal static string LowestWave
+        {
+            get
+            {
+                return AllWaves[0];
+            }
+        }
+
+        internal static string HighestWave
+        {
+            get
+            {
+                return AllWaves[AllWaves.Length - 1];
+            }
+        }
+
+        private static string cachedWave = null;
+
+        public static string DisabledWave
+        {
+            get
+            {
+                if (cachedWave == null)
+                {
+                    cachedWave = Traits.Instance.MSBuildDisableFeaturesFromVersion ?? "";
+                }
+
+                return cachedWave;
+            }
+            set
+            {
+                cachedWave = value;
+            }
+        }
+
+        private static ChangeWaveConversionState _state;
+        internal static ChangeWaveConversionState ConversionState
+        {
+            get
+            {
+                return _state;
+            }
+            set
+            {
+                // Keep state persistent.
+                if (_state == ChangeWaveConversionState.NotConvertedYet)
+                {
+                    _state = value;
+                }
+            }
+        }
+
+        /// <summary>
+        /// Ensure the the environment variable MSBuildDisableFeaturesFromWave is set to a proper value.
+        /// </summary>
+        /// <returns> String representation of the set change wave. "999.999" if unset or invalid, and clamped if out of bounds. </returns>
+        internal static void ApplyChangeWave()
+        {
+            Version changeWave;
+
+            // If unset, enable all features.
+            if (DisabledWave.Length == 0 || DisabledWave.Equals(EnableAllFeatures, StringComparison.OrdinalIgnoreCase))
+            {
+                ConversionState = ChangeWaveConversionState.Valid;
+                DisabledWave = ChangeWaves.EnableAllFeatures;
+                return;
+            }
+
+            // If the version is of invalid format, log a warning and enable all features.
+            if (!Version.TryParse(DisabledWave, out changeWave))
+            {
+                ConversionState = ChangeWaveConversionState.InvalidFormat;
+                DisabledWave = ChangeWaves.EnableAllFeatures;
+                return;
+            }
+            // If the version is 999.999, we're done.
+            else if (changeWave == EnableAllFeaturesAsVersion)
+            {
+                ConversionState = ChangeWaveConversionState.Valid;
+                DisabledWave = changeWave.ToString();
+                return;
+            }
+            // If the version is out of rotation, log a warning and clamp the value.
+            else if (changeWave < LowestWaveAsVersion)
+            {
+                ConversionState = ChangeWaveConversionState.OutOfRotation;
+                DisabledWave = LowestWave;
+                return;
+            }
+            else if (changeWave > HighestWaveAsVersion)
+            {
+                ConversionState = ChangeWaveConversionState.OutOfRotation;
+                DisabledWave = HighestWave;
+                return;
+            }
+
+            // Ensure it's set to an existing version within the current rotation
+            if (!AllWavesAsVersion.Contains(changeWave))
+            {
+                foreach (Version wave in AllWavesAsVersion)
+                {
+                    if (wave > changeWave)
+                    {
+                        ConversionState = ChangeWaveConversionState.Valid;
+                        DisabledWave = wave.ToString();
+                        return;
+                    }
+                }
+            }
+
+            ConversionState = ChangeWaveConversionState.Valid;
+            DisabledWave = changeWave.ToString();
+        }
+
+        /// <summary>
+        /// Compares the passed wave to the MSBuildDisableFeaturesFromVersion environment variable.
+        /// Version MUST be of the format: "xx.yy".
+        /// </summary>
+        /// <param name="wave">The version to compare.</param>
+        /// <returns>A bool indicating whether the feature behind a version is enabled.</returns>
+        public static bool AreFeaturesEnabled(string wave)
+        {
+            Version waveToCheck;
+
+            // When a caller passes an invalid wave, fail the build.
+            ErrorUtilities.VerifyThrow(Version.TryParse(wave.ToString(), out waveToCheck),
+                                       $"Argument 'wave' passed with invalid format." +
+                                       $"Please use pre-existing const strings or define one with format 'xx.yy");
+
+            return AreFeaturesEnabled(waveToCheck);
+        }
+
+        /// <summary>
+        /// Compares the passed wave to the MSBuildDisableFeaturesFromVersion environment variable.
+        /// </summary>
+        /// <param name="wave">The version to compare.</param>
+        /// <returns>A bool indicating whether the version is enabled.</returns>
+        public static bool AreFeaturesEnabled(Version wave)
+        {
+            if (_state == ChangeWaveConversionState.NotConvertedYet)
+            {
+                ApplyChangeWave();
+            }
+
+            // This is opt out behavior, all waves are enabled by default.
+            if (DisabledWave.Length == 0 || DisabledWave.Equals(EnableAllFeatures, StringComparison.OrdinalIgnoreCase))
+            {
+                return true;
+            }
+
+            Version currentSetWave;
+
+            // If we can't parse the environment variable, default to enabling features.
+            if (!Version.TryParse(DisabledWave, out currentSetWave))
+            {
+                return true;
+            }
+
+            return wave < currentSetWave;
+        }
+
+        /// <summary>
+        /// Resets the state and value of the currently disabled version.
+        /// </summary>
+        public static void ResetStateForTests()
+        {
+            DisabledWave = null;
+            _state = ChangeWaveConversionState.NotConvertedYet;
+        }
+    }
+}
diff --git a/src/Shared/CollectionHelpers.cs b/src/Shared/CollectionHelpers.cs
index 516706b0fcf..07ba40bad1d 100644
--- a/src/Shared/CollectionHelpers.cs
+++ b/src/Shared/CollectionHelpers.cs
@@ -3,9 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
-using System.Collections;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Shared
 {
@@ -40,7 +37,7 @@ internal static List<T> RemoveNulls<T>(List<T> inputs)
         /// </summary>
         internal static bool ContainsValueAndIsEqual(this Dictionary<string, string> dictionary, string key, string value, StringComparison comparer)
         {
-            string valueFromDictionary = null;
+            string valueFromDictionary;
             if (dictionary.TryGetValue(key, out valueFromDictionary))
             {
                 return String.Equals(value, valueFromDictionary, comparer);
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index cd238bd5540..26859071fc0 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -75,8 +75,10 @@ internal Handshake(HandshakeOptions nodeType)
             // This indicates in the first byte that we are a modern build.
             options = (int)nodeType | (((int)CommunicationsUtilities.handshakeVersion) << 24);
             string handshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
+            CommunicationsUtilities.Trace("Handshake salt is " + handshakeSalt);
             string toolsDirectory = (nodeType & HandshakeOptions.X64) == HandshakeOptions.X64 ? BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64 : BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
-            salt = CommunicationsUtilities.GetHandshakeHashCode(handshakeSalt + toolsDirectory);
+            CommunicationsUtilities.Trace("Tools directory is " + toolsDirectory);
+            salt = CommunicationsUtilities.GetHashCode(handshakeSalt + toolsDirectory);
             Version fileVersion = new Version(FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).FileVersion);
             fileVersionMajor = fileVersion.Major;
             fileVersionMinor = fileVersion.Minor;
@@ -595,7 +597,7 @@ internal static void Trace(int nodeId, string format, params object[] args)
         /// but stripped out architecture specific defines
         /// that causes the hashcode to be different and this causes problem in cross-architecture handshaking
         /// </summary>
-        internal static int GetHandshakeHashCode(string fileVersion)
+        internal static int GetHashCode(string fileVersion)
         {
             unsafe
             {
diff --git a/src/Shared/CopyOnWriteDictionary.cs b/src/Shared/CopyOnWriteDictionary.cs
index b884ff4389c..6b1820bc5d5 100644
--- a/src/Shared/CopyOnWriteDictionary.cs
+++ b/src/Shared/CopyOnWriteDictionary.cs
@@ -4,9 +4,12 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Collections.Immutable;
 using System.Diagnostics.CodeAnalysis;
+using System.Linq;
 using System.Runtime.Serialization;
-using Microsoft.Build.Shared;
+
+#nullable enable
 
 namespace Microsoft.Build.Collections
 {
@@ -14,17 +17,8 @@ namespace Microsoft.Build.Collections
     /// A dictionary that has copy-on-write semantics.
     /// KEYS AND VALUES MUST BE IMMUTABLE OR COPY-ON-WRITE FOR THIS TO WORK.
     /// </summary>
-    /// <typeparam name="K">The key type.</typeparam>
     /// <typeparam name="V">The value type.</typeparam>
     /// <remarks>
-    /// This dictionary works by having a backing dictionary which is ref-counted for each
-    /// COWDictionary which references it.  When a write operation is performed on any
-    /// COWDictionary, we check the reference count on the backing dictionary.  If it is 
-    /// greater than 1, it means any changes we make to it would be visible to other readers.
-    /// Therefore, we clone the backing dictionary and decrement the reference count on the
-    /// original.  From there on we use the cloned dictionary, which now has a reference count
-    /// of 1.
-    ///
     /// Thread safety: for all users, this class is as thread safe as the underlying Dictionary implementation, that is,
     /// safe for concurrent readers or one writer from EACH user. It achieves this by locking itself and cloning before
     /// any write, if it is being shared - i.e., stopping sharing before any writes occur.
@@ -34,31 +28,37 @@ namespace Microsoft.Build.Collections
     /// be run in a separate appdomain.
     /// </comment>
     [Serializable]
-    internal class CopyOnWriteDictionary<K, V> : IDictionary<K, V>, IDictionary
+    internal class CopyOnWriteDictionary<V> : IDictionary<string, V>, IDictionary, ISerializable
     {
-#if DEBUG
+#if !NET35 // MSBuildNameIgnoreCaseComparer not compiled into MSBuildTaskHost but also allocations not interesting there.
         /// <summary>
-        /// When set forces immediate copy
+        /// Empty dictionary with a <see cref="MSBuildNameIgnoreCaseComparer" />,
+        /// used as the basis of new dictionaries with that comparer to avoid
+        /// allocating new comparers objects.
         /// </summary>
-        private static readonly bool s_forceWrite = (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDFORCECOWCOPY")));
-#endif
+        private readonly static ImmutableDictionary<string, V> NameComparerDictionaryPrototype = ImmutableDictionary.Create<string, V>((IEqualityComparer<string>)MSBuildNameIgnoreCaseComparer.Default);
 
         /// <summary>
-        /// The default capacity.
+        /// Empty dictionary with <see cref="StringComparer.OrdinalIgnoreCase" />,
+        /// used as the basis of new dictionaries with that comparer to avoid
+        /// allocating new comparers objects.
         /// </summary>
-        private readonly int capacity;
+        private readonly static ImmutableDictionary<string, V> OrdinalIgnoreCaseComparerDictionaryPrototype = ImmutableDictionary.Create<string, V>((IEqualityComparer<string>)StringComparer.OrdinalIgnoreCase);
+#endif
+
 
         /// <summary>
         /// The backing dictionary.
         /// Lazily created.
         /// </summary>
-        private CopyOnWriteBackingDictionary<K, V> backing;
+        private ImmutableDictionary<string, V> _backing;
 
         /// <summary>
         /// Constructor. Consider supplying a comparer instead.
         /// </summary>
         internal CopyOnWriteDictionary()
         {
+            _backing = ImmutableDictionary<string, V>.Empty;
         }
 
         /// <summary>
@@ -72,7 +72,7 @@ internal CopyOnWriteDictionary(int capacity)
         /// <summary>
         /// Constructor taking a specified comparer for the keys
         /// </summary>
-        internal CopyOnWriteDictionary(IEqualityComparer<K> keyComparer)
+        internal CopyOnWriteDictionary(IEqualityComparer<string> keyComparer)
             : this(0, keyComparer)
         {
         }
@@ -80,64 +80,71 @@ internal CopyOnWriteDictionary(IEqualityComparer<K> keyComparer)
         /// <summary>
         /// Constructor taking a specified comparer for the keys and an initial capacity
         /// </summary>
-        internal CopyOnWriteDictionary(int capacity, IEqualityComparer<K> keyComparer)
+        internal CopyOnWriteDictionary(int capacity, IEqualityComparer<string>? keyComparer)
         {
-            this.capacity = capacity;
-            Comparer = keyComparer;
+            _backing = GetInitialDictionary(keyComparer);
         }
 
         /// <summary>
         /// Serialization constructor, for crossing appdomain boundaries
         /// </summary>
-        [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "info", Justification = "Not needed")]
         [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "context", Justification = "Not needed")]
         protected CopyOnWriteDictionary(SerializationInfo info, StreamingContext context)
         {
+            object v = info.GetValue(nameof(_backing), typeof(KeyValuePair<string, V>[]));
+
+            object comparer = info.GetValue(nameof(Comparer), typeof(IEqualityComparer<string>));
+
+            var b = GetInitialDictionary((IEqualityComparer<string>)comparer);
+
+            _backing = b.AddRange((KeyValuePair<string, V>[])v);
+        }
+
+        private static ImmutableDictionary<string, V> GetInitialDictionary(IEqualityComparer<string>? keyComparer)
+        {
+#if NET35
+            return ImmutableDictionary.Create<string, V>(keyComparer);
+#else
+            return keyComparer is MSBuildNameIgnoreCaseComparer
+                            ? NameComparerDictionaryPrototype
+                            : keyComparer == StringComparer.OrdinalIgnoreCase
+                              ? OrdinalIgnoreCaseComparerDictionaryPrototype
+                              : ImmutableDictionary.Create<string, V>(keyComparer);
+#endif
         }
 
         /// <summary>
         /// Cloning constructor. Defers the actual clone.
         /// </summary>
-        private CopyOnWriteDictionary(CopyOnWriteDictionary<K, V> that)
+        private CopyOnWriteDictionary(CopyOnWriteDictionary<V> that)
         {
-            Comparer = that.Comparer;
-            backing = that.backing;
-            if (backing != null)
-            {
-                lock (((ICollection)backing).SyncRoot)
-                {
-                    backing.AddRef();
-                }
-            }
+            _backing = that._backing;
         }
 
-        public CopyOnWriteDictionary(IDictionary<K, V> dictionary)
+        public CopyOnWriteDictionary(IDictionary<string, V> dictionary)
         {
-            foreach (KeyValuePair<K, V> pair in dictionary)
-            {
-                this[pair.Key] = pair.Value;
-            }
+            _backing = dictionary.ToImmutableDictionary();
         }
 
         /// <summary>
         /// Returns the collection of keys in the dictionary.
         /// </summary>
-        public ICollection<K> Keys => ReadOperation.Keys;
+        public ICollection<string> Keys => ((IDictionary<string, V>)_backing).Keys;
 
         /// <summary>
         /// Returns the collection of values in the dictionary.
         /// </summary>
-        public ICollection<V> Values => ReadOperation.Values;
+        public ICollection<V> Values => ((IDictionary<string, V>)_backing).Values;
 
         /// <summary>
         /// Returns the number of items in the collection.
         /// </summary>
-        public int Count => ReadOperation.Count;
+        public int Count => _backing.Count;
 
         /// <summary>
         /// Returns true if the collection is read-only.
         /// </summary>
-        public bool IsReadOnly => ((IDictionary<K, V>)ReadOperation).IsReadOnly;
+        public bool IsReadOnly => ((IDictionary<string, V>)_backing).IsReadOnly;
 
         /// <summary>
         /// IDictionary implementation
@@ -174,112 +181,29 @@ public CopyOnWriteDictionary(IDictionary<K, V> dictionary)
         /// </summary>
         object ICollection.SyncRoot => this;
 
-        /// <summary>
-        /// A special single dummy instance that always appears empty.
-        /// </summary>
-        internal static CopyOnWriteDictionary<K, V> Dummy { get; } = new CopyOnWriteDictionary<K, V> { _isDummy = true };
-
-        /// <summary>
-        /// Whether this is a dummy instance that always appears empty.
-        /// </summary>
-        internal bool IsDummy
-        {
-            get
-            {
-                if (_isDummy)
-                {
-                    ErrorUtilities.VerifyThrow(backing == null || backing.Count == 0, "count"); // check count without recursion
-                }
-
-                return _isDummy;
-            }
-        }
-
-        private bool _isDummy;
-
         /// <summary>
         /// Comparer used for keys
         /// </summary>
-        internal IEqualityComparer<K> Comparer { get; private set; }
-
-        /// <summary>
-        /// Gets the backing dictionary for reading.
-        /// </summary>
-        private CopyOnWriteBackingDictionary<K, V> ReadOperation
-        {
-            get
-            {
-                ErrorUtilities.VerifyThrow(!IsDummy || backing == null || backing.Count == 0, "count"); // check count without recursion
-#if DEBUG
-                if (s_forceWrite)
-                {
-                    if (!IsDummy)
-                    {
-                        return WriteOperation;
-                    }
-                }
-#endif
-                if (backing == null)
-                {
-                    return CopyOnWriteBackingDictionary<K, V>.ReadOnlyEmptyInstance;
-                }
-
-                return backing;
-            }
-        }
-
-        /// <summary>
-        /// Gets the backing dictionary for writing.
-        /// </summary>
-        private CopyOnWriteBackingDictionary<K, V> WriteOperation
+        internal IEqualityComparer<string> Comparer
         {
-            get
-            {
-                ErrorUtilities.VerifyThrow(!IsDummy, "dummy");
-
-                if (backing == null)
-                {
-                    backing = new CopyOnWriteBackingDictionary<K, V>(capacity, Comparer);
-                }
-                else
-                {
-                    lock (((ICollection)backing).SyncRoot)
-                    {
-                        backing = backing.CloneForWriteIfNecessary();
-                    }
-                }
-
-                return backing;
-            }
+            get => _backing.KeyComparer;
+            private set => _backing = _backing.WithComparers(keyComparer: value);
         }
 
         /// <summary>
         /// Accesses the value for the specified key.
         /// </summary>
-        public V this[K key]
+        public V this[string key]
         {
-            get => ReadOperation[key];
+            get => _backing[key];
 
             set
             {
-                if (!IsDummy)
-                {
-                    if (ReadOperation.HasNoClones)
-                    {
-                        WriteOperation[key] = value;
-                    }
-                    else
-                    {
-                        // Try to avoid a clone if it already is present with the same value
-                        if (!ReadOperation.TryGetValue(key, out V existingValue) || !EqualityComparer<V>.Default.Equals(existingValue, value))
-                        {
-                            WriteOperation[key] = value;
-                        }
-                    }
-                }
+                _backing = _backing.SetItem(key, value);
             }
         }
 
+#nullable disable
         /// <summary>
         /// IDictionary implementation
         /// </summary>
@@ -287,66 +211,56 @@ object IDictionary.this[object key]
         {
             get
             {
-                TryGetValue((K) key, out V val);
+                TryGetValue((string) key, out V val);
                 return val;
             }
 
-            set => this[(K)key] = (V)value;
+            set => this[(string)key] = (V)value;
         }
+#nullable restore
 
         /// <summary>
         /// Adds a value to the dictionary.
         /// </summary>
-        public void Add(K key, V value)
+        public void Add(string key, V value)
         {
-            if (!IsDummy)
-            {
-                WriteOperation.Add(key, value);
-            }
+            _backing = _backing.SetItem(key, value);
         }
 
         /// <summary>
         /// Returns true if the dictionary contains the specified key.
         /// </summary>
-        public bool ContainsKey(K key)
+        public bool ContainsKey(string key)
         {
-            return ReadOperation.ContainsKey(key);
+            return _backing.ContainsKey(key);
         }
 
         /// <summary>
         /// Removes the entry for the specified key from the dictionary.
         /// </summary>
-        public bool Remove(K key)
+        public bool Remove(string key)
         {
-            // Avoid a clone if it's not present
-            if (ReadOperation.HasNoClones || ReadOperation.ContainsKey(key))
-            {
-                if (!IsDummy)
-                {
-                    return WriteOperation.Remove(key);
-                }
-            }
+            ImmutableDictionary<string, V> initial = _backing;
+
+            _backing = _backing.Remove(key);
 
-            return false;
+            return initial != _backing; // whether the removal occured
         }
 
         /// <summary>
         /// Attempts to find the value for the specified key in the dictionary.
         /// </summary>
-        public bool TryGetValue(K key, out V value)
+        public bool TryGetValue(string key, out V value)
         {
-            return ReadOperation.TryGetValue(key, out value);
+            return _backing.TryGetValue(key, out value);
         }
 
         /// <summary>
         /// Adds an item to the collection.
         /// </summary>
-        public void Add(KeyValuePair<K, V> item)
+        public void Add(KeyValuePair<string, V> item)
         {
-            if (!IsDummy)
-            {
-                ((IDictionary<K, V>)WriteOperation).Add(item);
-            }
+            _backing = _backing.SetItem(item.Key, item.Value);
         }
 
         /// <summary>
@@ -354,54 +268,43 @@ public void Add(KeyValuePair<K, V> item)
         /// </summary>
         public void Clear()
         {
-            if (ReadOperation.Count > 0)
-            {
-                if (!IsDummy)
-                {
-                    WriteOperation.Clear();
-                }
-            }
+            _backing = _backing.Clear();
         }
 
         /// <summary>
         /// Returns true ff the collection contains the specified item.
         /// </summary>
-        public bool Contains(KeyValuePair<K, V> item)
+        public bool Contains(KeyValuePair<string, V> item)
         {
-            return ((IDictionary<K, V>)ReadOperation).Contains(item);
+            return _backing.Contains(item);
         }
 
         /// <summary>
         /// Copies all of the elements of the collection to the specified array.
         /// </summary>
-        public void CopyTo(KeyValuePair<K, V>[] array, int arrayIndex)
+        public void CopyTo(KeyValuePair<string, V>[] array, int arrayIndex)
         {
-            ((IDictionary<K, V>)ReadOperation).CopyTo(array, arrayIndex);
+            ((IDictionary<string, V>)_backing).CopyTo(array, arrayIndex);
         }
 
         /// <summary>
         /// Remove an item from the dictionary.
         /// </summary>
-        public bool Remove(KeyValuePair<K, V> item)
+        public bool Remove(KeyValuePair<string, V> item)
         {
-            // If it doesn't already contain the key, avoid copying the dictionary.
-            if (ReadOperation.HasNoClones || ReadOperation.ContainsKey(item.Key))
-            {
-                if (!IsDummy)
-                {
-                    return ((IDictionary<K, V>)WriteOperation).Remove(item);
-                }
-            }
+            ImmutableDictionary<string, V> initial = _backing;
 
-            return false;
+            _backing = _backing.Remove(item.Key);
+
+            return initial != _backing; // whether the removal occured
         }
 
         /// <summary>
         /// Implementation of generic IEnumerable.GetEnumerator()
         /// </summary>
-        public IEnumerator<KeyValuePair<K, V>> GetEnumerator()
+        public IEnumerator<KeyValuePair<string, V>> GetEnumerator()
         {
-            return ReadOperation.GetEnumerator();
+            return _backing.GetEnumerator();
         }
 
         /// <summary>
@@ -409,7 +312,7 @@ public IEnumerator<KeyValuePair<K, V>> GetEnumerator()
         /// </summary>
         IEnumerator IEnumerable.GetEnumerator()
         {
-            return ((IEnumerable<KeyValuePair<K, V>>)this).GetEnumerator();
+            return ((IEnumerable<KeyValuePair<string, V>>)this).GetEnumerator();
         }
 
         /// <summary>
@@ -417,7 +320,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// </summary>
         void IDictionary.Add(object key, object value)
         {
-            Add((K)key, (V)value);
+            Add((string)key, (V)value);
         }
 
         /// <summary>
@@ -433,7 +336,7 @@ void IDictionary.Clear()
         /// </summary>
         bool IDictionary.Contains(object key)
         {
-            return ContainsKey((K)key);
+            return ContainsKey((string)key);
         }
 
         /// <summary>
@@ -441,7 +344,7 @@ bool IDictionary.Contains(object key)
         /// </summary>
         IDictionaryEnumerator IDictionary.GetEnumerator()
         {
-            return ((IDictionary)ReadOperation).GetEnumerator();
+            return ((IDictionary)_backing).GetEnumerator();
         }
 
         /// <summary>
@@ -449,7 +352,7 @@ IDictionaryEnumerator IDictionary.GetEnumerator()
         /// </summary>
         void IDictionary.Remove(object key)
         {
-            Remove((K)key);
+            Remove((string)key);
         }
 
         /// <summary>
@@ -458,7 +361,7 @@ void IDictionary.Remove(object key)
         void ICollection.CopyTo(Array array, int index)
         {
             int i = 0;
-            foreach (KeyValuePair<K, V> entry in this)
+            foreach (KeyValuePair<string, V> entry in this)
             {
                 array.SetValue(new DictionaryEntry(entry.Key, entry.Value), index + i);
                 i++;
@@ -468,123 +371,26 @@ void ICollection.CopyTo(Array array, int index)
         /// <summary>
         /// Clone, with the actual clone deferred
         /// </summary>
-        internal CopyOnWriteDictionary<K, V> Clone()
+        internal CopyOnWriteDictionary<V> Clone()
         {
-            return new CopyOnWriteDictionary<K, V>(this);
+            return new CopyOnWriteDictionary<V>(this);
         }
 
         /// <summary>
         /// Returns true if these dictionaries have the same backing.
         /// </summary>
-        internal bool HasSameBacking(CopyOnWriteDictionary<K, V> other)
+        internal bool HasSameBacking(CopyOnWriteDictionary<V> other)
         {
-            return ReferenceEquals(other.backing, backing);
+            return ReferenceEquals(other._backing, _backing);
         }
 
-        /// <summary>
-        /// A dictionary which is reference counted to allow several references for read operations, but knows when to clone for
-        /// write operations.
-        /// </summary>
-        /// <typeparam name="K1">The key type.</typeparam>
-        /// <typeparam name="V1">The value type.</typeparam>
-        [Serializable]
-        private class CopyOnWriteBackingDictionary<K1, V1> : Dictionary<K1, V1>
+        public void GetObjectData(SerializationInfo info, StreamingContext context)
         {
-            /// <summary>
-            /// An empty dictionary 
-            /// </summary>
-            [SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Justification = "Error in code analysis.")]
-            private static readonly CopyOnWriteBackingDictionary<K1, V1> s_readOnlyEmptyDictionary = new CopyOnWriteBackingDictionary<K1, V1>();
-
-            /// <summary>
-            /// The reference count. 
-            /// </summary>
-            [SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields", Justification = "Error in code analysis.")]
-            [NonSerialized]
-            private int _refCount = 1;
-
-            /// <summary>
-            /// Constructor.
-            /// </summary>
-            public CopyOnWriteBackingDictionary(int capacity, IEqualityComparer<K1> comparer)
-                : base(capacity, comparer)
-            {
-                // Tracing.Record("New COWBD");
-            }
+            ImmutableDictionary<string, V> snapshot = _backing;
+            KeyValuePair<string, V>[] array = snapshot.ToArray();
 
-            /// <summary>
-            /// Serialization constructor, for crossing appdomain boundaries
-            /// </summary>
-            protected CopyOnWriteBackingDictionary(SerializationInfo info, StreamingContext context)
-                : base(info, context)
-            {
-            }
-
-            /// <summary>
-            /// Empty constructor.
-            /// </summary>
-            private CopyOnWriteBackingDictionary()
-            {
-            }
-
-            /// <summary>
-            /// Cloning constructor.
-            /// </summary>
-            private CopyOnWriteBackingDictionary(CopyOnWriteBackingDictionary<K1, V1> that)
-                : base(that, that.Comparer)
-            {
-                // Tracing.Record("New COWBD-clone");
-            }
-
-            /// <summary>
-            /// Returns a read-only empty instance.
-            /// </summary>
-            public static CopyOnWriteBackingDictionary<K1, V1> ReadOnlyEmptyInstance => s_readOnlyEmptyDictionary;
-
-            /// <summary>
-            /// Returns true if this collection has no clones.
-            /// </summary>
-            public bool HasNoClones
-            {
-                get
-                {
-                    ErrorUtilities.VerifyThrow(_refCount >= 1, "refCount should not be less than 1.");
-                    return _refCount == 1;
-                }
-            }
-
-            /// <summary>
-            /// Clones backing dictionary if necessary for a write operation.
-            /// </summary>
-            public CopyOnWriteBackingDictionary<K1, V1> CloneForWriteIfNecessary()
-            {
-                if (!HasNoClones)
-                {
-                    _refCount--;
-                    return new CopyOnWriteBackingDictionary<K1, V1>(this);
-                }
-
-                return this;
-            }
-
-            /// <summary>
-            /// Adds a reader-reference to this backing dictionary.
-            /// </summary>
-            public int AddRef()
-            {
-                return ++_refCount;
-            }
-
-            /// <summary>
-            /// Deserialization does not call any constructors, not even
-            /// the parameterless constructor. Therefore since we do not serialize
-            /// this field, we must populate it here.
-            /// </summary>
-            [OnDeserialized]
-            private void OnDeserialized(StreamingContext context)
-            {
-                _refCount = 1;
-            }
+            info.AddValue(nameof(_backing), array);
+            info.AddValue(nameof(Comparer), Comparer);
         }
     }
 }
diff --git a/src/Shared/Debugging/PrintLineDebugger.cs b/src/Shared/Debugging/PrintLineDebugger.cs
index fc5b610c0fe..bfcdbfd57c4 100644
--- a/src/Shared/Debugging/PrintLineDebugger.cs
+++ b/src/Shared/Debugging/PrintLineDebugger.cs
@@ -9,7 +9,6 @@
 using System.Runtime.CompilerServices;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using CommonWriterType = System.Action<string, string, System.Collections.Generic.IEnumerable<string>>;
 
 namespace Microsoft.Build.Shared.Debugging
diff --git a/src/Shared/EncodingStringWriter.cs b/src/Shared/EncodingStringWriter.cs
index 6fb97fc2613..18465774860 100644
--- a/src/Shared/EncodingStringWriter.cs
+++ b/src/Shared/EncodingStringWriter.cs
@@ -1,10 +1,6 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Globalization;
+﻿using System.Globalization;
 using System.IO;
-using System.Linq;
 using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Shared
 {
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 439a8491f96..b1332593d52 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -5,7 +5,6 @@
 using System.IO;
 using System.Diagnostics;
 using System.Globalization;
-using System.Runtime.CompilerServices;
 using System.Threading;
 
 #if BUILDINGAPPXTASKS
diff --git a/src/Shared/EscapingStringExtensions/EscapingStringExtensions.cs b/src/Shared/EscapingStringExtensions/EscapingStringExtensions.cs
deleted file mode 100644
index ae749f47692..00000000000
--- a/src/Shared/EscapingStringExtensions/EscapingStringExtensions.cs
+++ /dev/null
@@ -1,34 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using Microsoft.Build.Shared;
-
-namespace Microsoft.Build.Shared.EscapingStringExtensions
-{
-    internal static class EscapingStringExtensions
-    {
-        internal static string Unescape(this string escapedString)
-        {
-            return EscapingUtilities.UnescapeAll(escapedString);
-        }
-
-        internal static string Unescape
-        (
-            this string escapedString,
-            out bool escapingWasNecessary
-        )
-        {
-            return EscapingUtilities.UnescapeAll(escapedString, out escapingWasNecessary);
-        }
-
-        internal static string Escape(this string unescapedString)
-        {
-            return EscapingUtilities.Escape(unescapedString);
-        }
-
-        internal static bool ContainsEscapedWildcards(this string escapedString)
-        {
-            return EscapingUtilities.ContainsEscapedWildcards(escapedString);
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/Shared/EscapingUtilities.cs b/src/Shared/EscapingUtilities.cs
index 8ea0e83f3b6..a8d86f06c31 100644
--- a/src/Shared/EscapingUtilities.cs
+++ b/src/Shared/EscapingUtilities.cs
@@ -24,20 +24,6 @@ static internal class EscapingUtilities
         /// </summary>
         private static Dictionary<string, string> s_unescapedToEscapedStrings = new Dictionary<string, string>(StringComparer.Ordinal);
 
-        /// <summary>
-        /// Replaces all instances of %XX in the input string with the character represented
-        /// by the hexadecimal number XX.
-        /// </summary>
-        /// <param name="escapedString">The string to unescape.</param>
-        /// <returns>unescaped string</returns>
-        internal static string UnescapeAll
-        (
-            string escapedString
-        )
-        {
-            return UnescapeAll(escapedString, out bool _);
-        }
-
         private static bool IsHexDigit(char character)
         {
             return ((character >= '0') && (character <= '9'))
@@ -50,16 +36,10 @@ private static bool IsHexDigit(char character)
         /// by the hexadecimal number XX.
         /// </summary>
         /// <param name="escapedString">The string to unescape.</param>
-        /// <param name="escapingWasNecessary">Whether any replacements were made.</param>
+        /// <param name="trim">If the string should be trimmed before being unescaped.</param>
         /// <returns>unescaped string</returns>
-        internal static string UnescapeAll
-        (
-            string escapedString,
-            out bool escapingWasNecessary
-        )
+        internal static string UnescapeAll(string escapedString, bool trim = false)
         {
-            escapingWasNecessary = false;
-
             // If the string doesn't contain anything, then by definition it doesn't
             // need unescaping.
             if (String.IsNullOrEmpty(escapedString))
@@ -72,13 +52,29 @@ out bool escapingWasNecessary
             int indexOfPercent = escapedString.IndexOf('%');
             if (indexOfPercent == -1)
             {
-                return escapedString;
+                return trim ? escapedString.Trim() : escapedString;
             }
 
             // This is where we're going to build up the final string to return to the caller.
             StringBuilder unescapedString = StringBuilderCache.Acquire(escapedString.Length);
 
             int currentPosition = 0;
+            int escapedStringLength = escapedString.Length;
+            if (trim)
+            {
+                while (currentPosition < escapedString.Length && Char.IsWhiteSpace(escapedString[currentPosition]))
+                {
+                    currentPosition++;
+                }
+                if (currentPosition == escapedString.Length)
+                {
+                    return String.Empty;
+                }
+                while (Char.IsWhiteSpace(escapedString[escapedStringLength - 1]))
+                {
+                    escapedStringLength--;
+                }
+            }
 
             // Loop until there are no more percent signs in the input string.
             while (indexOfPercent != -1)
@@ -86,7 +82,7 @@ out bool escapingWasNecessary
                 // There must be two hex characters following the percent sign
                 // for us to even consider doing anything with this.
                 if (
-                        (indexOfPercent <= (escapedString.Length - 3)) &&
+                        (indexOfPercent <= (escapedStringLength - 3)) &&
                         IsHexDigit(escapedString[indexOfPercent + 1]) &&
                         IsHexDigit(escapedString[indexOfPercent + 2])
                     )
@@ -106,8 +102,6 @@ out bool escapingWasNecessary
                     // Advance the current pointer to reflect the fact that the destination string
                     // is up to date with everything up to and including this escape code we just found.
                     currentPosition = indexOfPercent + 3;
-
-                    escapingWasNecessary = true;
                 }
 
                 // Find the next percent sign.
@@ -116,7 +110,7 @@ out bool escapingWasNecessary
 
             // Okay, there are no more percent signs in the input string, so just copy the remaining
             // characters into the destination.
-            unescapedString.Append(escapedString, currentPosition, escapedString.Length - currentPosition);
+            unescapedString.Append(escapedString, currentPosition, escapedStringLength - currentPosition);
 
             return StringBuilderCache.GetStringAndRelease(unescapedString);
         }
@@ -167,9 +161,9 @@ private static string EscapeWithOptionalCaching(string unescapedString, bool cac
             // next, if we're caching, check to see if it's already there.
             if (cache)
             {
-                string cachedEscapedString = null;
                 lock (s_unescapedToEscapedStrings)
                 {
+                    string cachedEscapedString;
                     if (s_unescapedToEscapedStrings.TryGetValue(unescapedString, out cachedEscapedString))
                     {
                         return cachedEscapedString;
diff --git a/src/Shared/EventArgsFormatting.cs b/src/Shared/EventArgsFormatting.cs
index 34871308e62..77de4f84fc0 100644
--- a/src/Shared/EventArgsFormatting.cs
+++ b/src/Shared/EventArgsFormatting.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Globalization;
-using System.Collections.Generic;
 using System.Text;
 
 using Microsoft.Build.Framework;
@@ -320,7 +319,7 @@ string logOutputProperties
             }
 
             // A null message is allowed and is to be treated as a blank line.
-            if (null == message)
+            if (message == null)
             {
                 message = String.Empty;
             }
@@ -333,12 +332,12 @@ string logOutputProperties
 
             for (int i = 0; i < lines.Length; i++)
             {
-                formattedMessage.Append(String.Format(
+                formattedMessage.AppendFormat(
                         CultureInfo.CurrentCulture, finalFormat,
                         threadId, file,
                         lineNumber, columnNumber, category, code,
                         lines[i], endLineNumber, endColumnNumber,
-                        subcategory, projectFile, logOutputProperties));
+                        subcategory, projectFile, logOutputProperties);
 
                 if (i < (lines.Length - 1))
                 {
diff --git a/src/Shared/FileDelegates.cs b/src/Shared/FileDelegates.cs
index 5631a190a83..bbe0c8e39a4 100644
--- a/src/Shared/FileDelegates.cs
+++ b/src/Shared/FileDelegates.cs
@@ -1,10 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.IO;
-using System.Diagnostics;
-using System.Globalization;
 
 namespace Microsoft.Build.Shared
 {
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 1e6efff4bc5..a9c8fa2b2f3 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Concurrent;
 using System.IO;
 using System.Text;
@@ -444,9 +443,8 @@ GetFileSystemEntries getFileSystemEntries
 
             string[] parts = path.Split(directorySeparatorCharacters);
             string pathRoot;
-            int startingElement = 0;
-
             bool isUnc = path.StartsWith(s_directorySeparator + s_directorySeparator, StringComparison.Ordinal);
+            int startingElement;
             if (isUnc)
             {
                 pathRoot = s_directorySeparator + s_directorySeparator;
diff --git a/src/Shared/FileSystem/CachingFileSystemWrapper.cs b/src/Shared/FileSystem/CachingFileSystemWrapper.cs
index 26682f6968e..c3b3b141f20 100644
--- a/src/Shared/FileSystem/CachingFileSystemWrapper.cs
+++ b/src/Shared/FileSystem/CachingFileSystemWrapper.cs
@@ -12,6 +12,7 @@ internal class CachingFileSystemWrapper : IFileSystem
     {
         private readonly IFileSystem _fileSystem;
         private readonly ConcurrentDictionary<string, bool> _existenceCache = new ConcurrentDictionary<string, bool>();
+        private readonly ConcurrentDictionary<string, DateTime> _lastWriteTimeCache = new ConcurrentDictionary<string, DateTime>();
 
         public CachingFileSystemWrapper(IFileSystem fileSystem)
         {
@@ -23,6 +24,16 @@ public bool DirectoryEntryExists(string path)
             return CachedExistenceCheck(path, p => _fileSystem.DirectoryEntryExists(p));
         }
 
+        public FileAttributes GetAttributes(string path)
+        {
+            return _fileSystem.GetAttributes(path);
+        }
+
+        public DateTime GetLastWriteTimeUtc(string path)
+        {
+            return _lastWriteTimeCache.GetOrAdd(path, p =>_fileSystem.GetLastWriteTimeUtc(p));
+        }
+
         public bool DirectoryExists(string path)
         {
             return CachedExistenceCheck(path, p => _fileSystem.DirectoryExists(p));
@@ -38,6 +49,26 @@ public IEnumerable<string> EnumerateDirectories(string path, string searchPatter
             return _fileSystem.EnumerateDirectories(path, searchPattern, searchOption);
         }
 
+        public TextReader ReadFile(string path)
+        {
+            return _fileSystem.ReadFile(path);
+        }
+
+        public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share)
+        {
+            return _fileSystem.GetFileStream(path, mode, access, share);
+        }
+
+        public string ReadFileAllText(string path)
+        {
+            return _fileSystem.ReadFileAllText(path);
+        }
+
+        public byte[] ReadFileAllBytes(string path)
+        {
+            return _fileSystem.ReadFileAllBytes(path);
+        }
+
         public IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
         {
             return _fileSystem.EnumerateFiles(path, searchPattern, searchOption);
diff --git a/src/Shared/FileSystem/FileSystems.cs b/src/Shared/FileSystem/FileSystems.cs
index 63379a92bbf..15b6b43bb2b 100644
--- a/src/Shared/FileSystem/FileSystems.cs
+++ b/src/Shared/FileSystem/FileSystems.cs
@@ -1,8 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-
 namespace Microsoft.Build.Shared.FileSystem
 {
     /// <summary>
diff --git a/src/Shared/FileSystem/IFileSystem.cs b/src/Shared/FileSystem/IFileSystem.cs
index 946aae0b286..0ef03e74c65 100644
--- a/src/Shared/FileSystem/IFileSystem.cs
+++ b/src/Shared/FileSystem/IFileSystem.cs
@@ -1,44 +1,47 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
 using System.IO;
 
 namespace Microsoft.Build.Shared.FileSystem
 {
-    /// <summary>
-    /// Abstracts away some file system operations
-    /// </summary>
+
+    /*
+     * This is a clone of Microsoft.Build.FileSystem.MSBuildFileSystemBase.
+     * MSBuildFileSystemBase is the public, reference interface. Changes should be made to MSBuildFileSystemBase and cloned in IFileSystem.
+     * Any new code should depend on MSBuildFileSystemBase instead of IFileSystem, if possible.
+     *
+     * MSBuild uses IFileSystem internally and adapts MSBuildFileSystemBase instances received from the outside to IFileSystem.
+     * Ideally there should be only one, public interface. However, such an interface would need to be put into the 
+     * Microsoft.Build.Framework assembly, but that assembly cannot take new types because it breaks some old version of Nuget.exe.
+     * IFileSystem cannot be deleted for the same reason.
+     */
     internal interface IFileSystem
     {
-        /// <summary>
-        /// Returns an enumerable collection of file names that match a search pattern in a specified path, and optionally searches subdirectories.
-        /// </summary>
+        TextReader ReadFile(string path);
+
+        Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
+
+        string ReadFileAllText(string path);
+
+        byte[] ReadFileAllBytes(string path);
+
         IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly);
 
-        /// <summary>
-        /// Returns an enumerable collection of directory names that match a search pattern in a specified path, and optionally searches subdirectories.
-        /// </summary>
         IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly);
 
-        /// <summary>
-        /// Returns an enumerable collection of file names and directory names that match a search pattern in a specified path, and optionally searches subdirectories.
-        /// </summary>
         IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly);
 
-        /// <summary>
-        /// Determines whether the given path refers to an existing directory on disk.
-        /// </summary>
+        FileAttributes GetAttributes(string path);
+
+        public DateTime GetLastWriteTimeUtc(string path);
+
         bool DirectoryExists(string path);
 
-        /// <summary>
-        /// Determines whether the given path refers to an existing file on disk.
-        /// </summary>
         bool FileExists(string path);
 
-        /// <summary>
-        /// Determines whether the given path refers to an existing entry in the directory service.
-        /// </summary>
         bool DirectoryEntryExists(string path);
     }
 }
diff --git a/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs b/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs
index 6819117fbf4..188efaf27fa 100644
--- a/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs
+++ b/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs
@@ -1,55 +1,79 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
 using System.IO;
 
 namespace Microsoft.Build.Shared.FileSystem
 {
     /// <summary>
-    /// Implementation of file system operations directly over the dot net managed layer
+    /// Implementation of file system operations on windows. Combination of native and managed implementations.
+    /// TODO Remove this class and replace with WindowsFileSystem. Test perf to ensure no regressions.
     /// </summary>
-    internal sealed class MSBuildOnWindowsFileSystem : IFileSystem
+    internal class MSBuildOnWindowsFileSystem : IFileSystem
     {
         private static readonly MSBuildOnWindowsFileSystem Instance = new MSBuildOnWindowsFileSystem();
 
-        /// <nodoc/>
         public static MSBuildOnWindowsFileSystem Singleton() => Instance;
 
-        private MSBuildOnWindowsFileSystem()
-        { }
+        protected MSBuildOnWindowsFileSystem() { }
+
+        public TextReader ReadFile(string path)
+        {
+            return ManagedFileSystem.Singleton().ReadFile(path);
+        }
+
+        public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share)
+        {
+            return ManagedFileSystem.Singleton().GetFileStream(path, mode, access, share);
+        }
+
+        public string ReadFileAllText(string path)
+        {
+            return ManagedFileSystem.Singleton().ReadFileAllText(path);
+        }
+
+        public byte[] ReadFileAllBytes(string path)
+        {
+            return ManagedFileSystem.Singleton().ReadFileAllBytes(path);
+        }
 
-        /// <inheritdoc/>
         public IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)
         {
             return ManagedFileSystem.Singleton().EnumerateFiles(path, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
         public IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption)
         {
             return ManagedFileSystem.Singleton().EnumerateDirectories(path, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
         public IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
         {
             return ManagedFileSystem.Singleton().EnumerateFileSystemEntries(path, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
+        public FileAttributes GetAttributes(string path)
+        {
+            return ManagedFileSystem.Singleton().GetAttributes(path);
+        }
+
+        public DateTime GetLastWriteTimeUtc(string path)
+        {
+            return ManagedFileSystem.Singleton().GetLastWriteTimeUtc(path);
+        }
+
         public bool DirectoryExists(string path)
         {
             return WindowsFileSystem.Singleton().DirectoryExists(path);
         }
 
-        /// <inheritdoc/>
         public bool FileExists(string path)
         {
             return WindowsFileSystem.Singleton().FileExists(path);
         }
 
-        /// <inheritdoc/>
         public bool DirectoryEntryExists(string path)
         {
             return WindowsFileSystem.Singleton().DirectoryEntryExists(path);
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index c809822b1df..201a62e7436 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
 using System.IO;
 
@@ -9,48 +10,70 @@ namespace Microsoft.Build.Shared.FileSystem
     /// <summary>
     /// Implementation of file system operations directly over the dot net managed layer
     /// </summary>
-    internal sealed class ManagedFileSystem : IFileSystem
+    internal class ManagedFileSystem : IFileSystem
     {
         private static readonly ManagedFileSystem Instance = new ManagedFileSystem();
 
-        /// <nodoc/>
         public static ManagedFileSystem Singleton() => ManagedFileSystem.Instance;
 
-        private ManagedFileSystem()
-        { }
+        protected ManagedFileSystem() { }
 
-        /// <inheritdoc/>
-        public IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)
+        public TextReader ReadFile(string path)
+        {
+            return new StreamReader(path);
+        }
+
+        public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share)
+        {
+            return new FileStream(path, mode, access, share);
+        }
+
+        public string ReadFileAllText(string path)
+        {
+            return File.ReadAllText(path);
+        }
+
+        public byte[] ReadFileAllBytes(string path)
+        {
+            return File.ReadAllBytes(path);
+        }
+
+        public virtual IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)
         {
             return Directory.EnumerateFiles(path, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
-        public IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption)
+        public virtual IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption)
         {
             return Directory.EnumerateDirectories(path, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
-        public IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
+        public virtual IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
         {
             return Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
-        public bool DirectoryExists(string path)
+        public FileAttributes GetAttributes(string path)
+        {
+            return File.GetAttributes(path);
+        }
+
+        public virtual DateTime GetLastWriteTimeUtc(string path)
+        {
+            return File.GetLastWriteTimeUtc(path);
+        }
+
+        public virtual bool DirectoryExists(string path)
         {
             return Directory.Exists(path);
         }
 
-        /// <inheritdoc/>
-        public bool FileExists(string path)
+        public virtual bool FileExists(string path)
         {
             return File.Exists(path);
         }
 
-        /// <inheritdoc/>
-        public bool DirectoryEntryExists(string path)
+        public virtual bool DirectoryEntryExists(string path)
         {
             return FileExists(path) || DirectoryExists(path);
         }
diff --git a/src/Shared/FileSystem/WindowsFileSystem.cs b/src/Shared/FileSystem/WindowsFileSystem.cs
index 71431d00924..9f4e3bf1dda 100644
--- a/src/Shared/FileSystem/WindowsFileSystem.cs
+++ b/src/Shared/FileSystem/WindowsFileSystem.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
@@ -22,54 +23,62 @@ internal enum FileArtifactType : byte
     }
 
     /// <summary>
-    /// Windows-specific implementation of file system operations using Windows native invocations
+    /// Windows-specific implementation of file system operations using Windows native invocations.
+    /// TODO For potential extra perf gains, provide native implementations for all IFileSystem methods and stop inheriting from ManagedFileSystem
     /// </summary>
-    internal class WindowsFileSystem : IFileSystem
+    internal class WindowsFileSystem : ManagedFileSystem
     {
         private static readonly WindowsFileSystem Instance = new WindowsFileSystem();
 
-        /// <nodoc/>
-        public static WindowsFileSystem Singleton() => WindowsFileSystem.Instance;
+        public new static WindowsFileSystem Singleton() => WindowsFileSystem.Instance;
 
-        private WindowsFileSystem()
-        { }
+        private WindowsFileSystem(){ }
 
-        /// <inheritdoc/>
-        public IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)
+        public override IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)
         {
             return EnumerateFileOrDirectories(path, FileArtifactType.File, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
-        public IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption)
+        public override IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption)
         {
             return EnumerateFileOrDirectories(path, FileArtifactType.Directory, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
-        public IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
+        public override IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
         {
             return EnumerateFileOrDirectories(path, FileArtifactType.FileOrDirectory, searchPattern, searchOption);
         }
 
-        /// <inheritdoc/>
-        public bool DirectoryExists(string path)
+        public override bool DirectoryExists(string path)
         {
             return NativeMethodsShared.DirectoryExistsWindows(path);
         }
 
-        /// <inheritdoc/>
-        public bool FileExists(string path)
+        public override bool FileExists(string path)
         {
             return NativeMethodsShared.FileExistsWindows(path);
         }
 
-        /// <inheritdoc/>
-        public bool DirectoryEntryExists(string path)
+        public override bool DirectoryEntryExists(string path)
         {
             return NativeMethodsShared.FileOrDirectoryExistsWindows(path);
         }
 
+        public override DateTime GetLastWriteTimeUtc(string path)
+        {
+            var fileLastWriteTime = NativeMethodsShared.GetLastWriteFileUtcTime(path);
+
+            if (fileLastWriteTime != DateTime.MinValue)
+            {
+                return fileLastWriteTime;
+            }
+            else
+            {
+                NativeMethodsShared.GetLastWriteDirectoryUtcTime(path, out var directoryLastWriteTime);
+                return directoryLastWriteTime;
+            }
+        }
+
         private static IEnumerable<string> EnumerateFileOrDirectories(
             string directoryPath,
             FileArtifactType fileArtifactType,
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 7d71b3ee28b..0eb22b7380d 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -13,7 +13,6 @@
 using System.Linq;
 using System.Reflection;
 using System.Runtime.CompilerServices;
-using System.Text.RegularExpressions;
 using System.Text;
 using System.Threading;
 using Microsoft.Build.Utilities;
@@ -187,7 +186,7 @@ internal static void ClearCacheDirectory()
         internal static string EnsureTrailingSlash(string fileSpec)
         {
             fileSpec = FixFilePath(fileSpec);
-            if (fileSpec.Length > 0 && !EndsWithSlash(fileSpec))
+            if (fileSpec.Length > 0 && !IsSlash(fileSpec[fileSpec.Length - 1]))
             {
                 fileSpec += Path.DirectorySeparatorChar;
             }
@@ -196,17 +195,37 @@ internal static string EnsureTrailingSlash(string fileSpec)
         }
 
         /// <summary>
-        /// Ensures the path does not have a leading slash.
+        /// Ensures the path does not have a leading or trailing slash after removing the first 'start' characters.
         /// </summary>
-        internal static string EnsureNoLeadingSlash(string path)
+        internal static string EnsureNoLeadingOrTrailingSlash(string path, int start)
         {
-            path = FixFilePath(path);
-            if (path.Length > 0 && IsSlash(path[0]))
+            int stop = path.Length;
+            while (start < stop && IsSlash(path[start]))
+            {
+                start++;
+            }
+            while (start < stop && IsSlash(path[stop - 1]))
             {
-                path = path.Substring(1);
+                stop--;
             }
 
-            return path;
+            return FixFilePath(path.Substring(start, stop - start));
+        }
+
+        /// <summary>
+        /// Ensures the path does not have a leading slash after removing the first 'start' characters but does end in a slash.
+        /// </summary>
+        internal static string EnsureTrailingNoLeadingSlash(string path, int start)
+        {
+            int stop = path.Length;
+            while (start < stop && IsSlash(path[start]))
+            {
+                start++;
+            }
+
+            return FixFilePath(start < stop && IsSlash(path[stop - 1]) ?
+                path.Substring(start) :
+                path.Substring(start) + Path.DirectorySeparatorChar);
         }
 
         /// <summary>
@@ -1072,7 +1091,7 @@ private static Uri CreateUriFromPath(string path)
         {
             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
 
-            Uri pathUri = null;
+            Uri pathUri;
 
             // Try absolute first, then fall back on relative, otherwise it
             // makes some absolute UNC paths like (\\foo\bar) relative ...
diff --git a/src/Shared/FileUtilitiesRegex.cs b/src/Shared/FileUtilitiesRegex.cs
index 9ab2e9faf9e..d3e3b97af5f 100644
--- a/src/Shared/FileUtilitiesRegex.cs
+++ b/src/Shared/FileUtilitiesRegex.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.IO;
-using System.Globalization;
-using System.Text.RegularExpressions;
 using System.Runtime.CompilerServices;
 
 namespace Microsoft.Build.Shared
@@ -20,10 +17,10 @@ internal static class FileUtilitiesRegex
         private static readonly char _forwardSlash = '/';
 
         /// <summary>
-        /// Indicates whether the specified string follows the pattern drive pattern (e.g. "C:", "D:")
+        /// Indicates whether the specified string follows the pattern drive pattern (for example "C:", "D:").
         /// </summary>
-        /// <param name="pattern">input to check for drive pattern</param>
-        /// <returns>true if follows the drive pattern, false otherwise</returns>
+        /// <param name="pattern">Input to check for drive pattern.</param>
+        /// <returns>true if follows the drive pattern, false otherwise.</returns>
         internal static bool IsDrivePattern(string pattern)
         {
             // Format must be two characters long: "<drive letter>:"
@@ -32,10 +29,10 @@ internal static bool IsDrivePattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string follows the pattern drive pattern (e.g. "C:/" or "C:\")
+        /// Indicates whether the specified string follows the pattern drive pattern (for example "C:/" or "C:\").
         /// </summary>
-        /// <param name="pattern">input to check for drive pattern with slash</param>
-        /// <returns>true if follows the drive pattern with slash, false otherwise</returns>
+        /// <param name="pattern">Input to check for drive pattern with slash.</param>
+        /// <returns>true if follows the drive pattern with slash, false otherwise.</returns>
         internal static bool IsDrivePatternWithSlash(string pattern)
         {
             return pattern.Length == 3 &&
@@ -43,10 +40,10 @@ internal static bool IsDrivePatternWithSlash(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string starts with the drive pattern (e.g. "C:")
+        /// Indicates whether the specified string starts with the drive pattern (for example "C:").
         /// </summary>
-        /// <param name="pattern">input to check for drive pattern</param>
-        /// <returns>true if starts with drive pattern, false otherwise</returns>
+        /// <param name="pattern">Input to check for drive pattern.</param>
+        /// <returns>true if starts with drive pattern, false otherwise.</returns>
         internal static bool StartsWithDrivePattern(string pattern)
         {
             // Format dictates a length of at least 2,
@@ -58,10 +55,10 @@ internal static bool StartsWithDrivePattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string starts with the drive pattern (e.g. "C:/" or "C:\")
+        /// Indicates whether the specified string starts with the drive pattern (for example "C:/" or "C:\").
         /// </summary>
-        /// <param name="pattern">input to check for drive pattern</param>
-        /// <returns>true if starts with drive pattern with slash, false otherwise</returns>
+        /// <param name="pattern">Input to check for drive pattern.</param>
+        /// <returns>true if starts with drive pattern with slash, false otherwise.</returns>
         internal static bool StartsWithDrivePatternWithSlash(string pattern)
         {
             // Format dictates a length of at least 3,
@@ -76,8 +73,8 @@ internal static bool StartsWithDrivePatternWithSlash(string pattern)
         /// <summary>
         /// Indicates whether the specified file-spec comprises exactly "\\server\share" (with no trailing characters).
         /// </summary>
-        /// <param name="pattern">input to check for Unc pattern</param>
-        /// <returns>true if comprises Unc pattern</returns>
+        /// <param name="pattern">Input to check for UNC pattern.</param>
+        /// <returns>true if comprises UNC pattern.</returns>
         internal static bool IsUncPattern(string pattern)
         {
             //Return value == pattern.length means:
@@ -90,8 +87,8 @@ internal static bool IsUncPattern(string pattern)
         /// <summary>
         /// Indicates whether the specified file-spec begins with "\\server\share".
         /// </summary>
-        /// <param name="pattern">input to check for Unc pattern</param>
-        /// <returns>true if starts with Unc pattern</returns>
+        /// <param name="pattern">Input to check for UNC pattern.</param>
+        /// <returns>true if starts with UNC pattern.</returns>
         internal static bool StartsWithUncPattern(string pattern)
         {
             //Any non -1 value returned means there was a match, therefore is begins with the pattern.
@@ -101,8 +98,8 @@ internal static bool StartsWithUncPattern(string pattern)
         /// <summary>
         /// Indicates whether the file-spec begins with a UNC pattern and how long the match is.
         /// </summary>
-        /// <param name="pattern">input to check for Unc pattern</param>
-        /// <returns>length of the match, -1 if no match</returns>
+        /// <param name="pattern">Input to check for UNC pattern.</param>
+        /// <returns>length of the match, -1 if no match.</returns>
         internal static int StartsWithUncPatternMatchLength(string pattern)
         {
             if (!MeetsUncPatternMinimumRequirements(pattern))
@@ -151,7 +148,7 @@ internal static int StartsWithUncPatternMatchLength(string pattern)
         /// <summary>
         /// Indicates whether or not the file-spec meets the minimum requirements of a UNC pattern.
         /// </summary>
-        /// <param name="pattern">input to check for Unc pattern minimum requirements</param>
+        /// <param name="pattern">Input to check for UNC pattern minimum requirements.</param>
         /// <returns>true if the UNC pattern is a minimum length of 5 and the first two characters are be a slash, false otherwise.</returns>
 #if !NET35
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index fdde34fa4bd..bacbc95e936 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -10,15 +10,11 @@
 using System.IO;
 using System.Linq;
 using System.Runtime.Versioning;
-
-using Microsoft.Build.Evaluation;
 using Microsoft.Win32;
 
 #if FEATURE_SYSTEM_CONFIGURATION
 using PropertyElement = Microsoft.Build.Evaluation.ToolsetElement.PropertyElement;
 #endif
-using System.Reflection;
-using System.Runtime.InteropServices;
 using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
@@ -849,7 +845,7 @@ internal static string GenerateProgramFiles64()
                 return Path.Combine(NativeMethodsShared.FrameworkBasePath, "xbuild");
             }
 
-            string programFilesX64 = null;
+            string programFilesX64;
             if (string.Equals(programFiles, programFiles32))
             {
                 // either we're in a 32-bit window, or we're on a 32-bit machine.  
@@ -944,8 +940,7 @@ internal static string GenerateReferenceAssemblyPath(string targetFrameworkRootP
                     path = Path.Combine(path, frameworkName.Profile);
                 }
 
-                path = Path.GetFullPath(path);
-                return path;
+                return Path.GetFullPath(path);
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
@@ -1661,8 +1656,7 @@ public DotNetFrameworkSpecV3(
             public override string GetPathToDotNetFrameworkSdk(VisualStudioSpec visualStudioSpec)
             {
                 string pathToBinRoot = this.GetPathToDotNetFrameworkSdkTools(visualStudioSpec);
-                pathToBinRoot = RemoveDirectories(pathToBinRoot, 1);
-                return pathToBinRoot;
+                return RemoveDirectories(pathToBinRoot, 1);
             }
 
             /// <summary>
diff --git a/src/Shared/FxCopExclusions/Microsoft.Build.Shared.Suppressions.cs b/src/Shared/FxCopExclusions/Microsoft.Build.Shared.Suppressions.cs
index 6c33e988869..e0dd6eed111 100644
--- a/src/Shared/FxCopExclusions/Microsoft.Build.Shared.Suppressions.cs
+++ b/src/Shared/FxCopExclusions/Microsoft.Build.Shared.Suppressions.cs
@@ -5,8 +5,6 @@
 // Add module level suppressions to this file to have them suppressed in the assembly
 //
 
-using System.Diagnostics.CodeAnalysis;
-
 #if CODE_ANALYSIS
 [module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.XMakeAttributes.#GetExplicitMSBuildArchitecture(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
 [module: SuppressMessage("Microsoft.Performance","CA1811:AvoidUncalledPrivateCode", Scope="member", Target="Microsoft.Build.Shared.XMakeAttributes.#GetExplicitMSBuildRuntime(System.String)", Justification="Source file used by several assemblies and this method is not called by all of them.")]
diff --git a/src/Shared/IConstrainedEqualityComparer.cs b/src/Shared/IConstrainedEqualityComparer.cs
index 9233b04f8cf..50f1bf44d99 100644
--- a/src/Shared/IConstrainedEqualityComparer.cs
+++ b/src/Shared/IConstrainedEqualityComparer.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 
 namespace Microsoft.Build.Collections
diff --git a/src/Shared/IElementLocation.cs b/src/Shared/IElementLocation.cs
index 2d802b18bf4..b9b26cfd74b 100644
--- a/src/Shared/IElementLocation.cs
+++ b/src/Shared/IElementLocation.cs
@@ -1,8 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 
 namespace Microsoft.Build.Shared
diff --git a/src/Shared/INodeEndpoint.cs b/src/Shared/INodeEndpoint.cs
index 3b0e66ffa13..a7dca856dd6 100644
--- a/src/Shared/INodeEndpoint.cs
+++ b/src/Shared/INodeEndpoint.cs
@@ -1,10 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-
 namespace Microsoft.Build.BackEnd
 {
     #region Delegates
diff --git a/src/Shared/ITranslator.cs b/src/Shared/ITranslator.cs
index 47b7770b797..6fec218805e 100644
--- a/src/Shared/ITranslator.cs
+++ b/src/Shared/ITranslator.cs
@@ -258,6 +258,13 @@ void Translate<T>(ref T value)
         /// </summary>
         /// <param name="byteArray">The array to be translated.</param>
         void Translate(ref byte[] byteArray);
+        
+        /// <summary>
+        /// Translates a byte array
+        /// </summary>
+        /// <param name="byteArray">The array to be translated.</param>
+        /// <param name="length">The length of array which will be used in translation</param>
+        void Translate(ref byte[] byteArray, ref int length);
 
         /// <summary>
         /// Translates an array of objects implementing INodePacketTranslatable.
diff --git a/src/Shared/InternalErrorException.cs b/src/Shared/InternalErrorException.cs
index 87e836eaaef..448cc5f6a46 100644
--- a/src/Shared/InternalErrorException.cs
+++ b/src/Shared/InternalErrorException.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Diagnostics;
-using System.IO;
-using System.Linq;
 using System.Runtime.Serialization;
 
 namespace Microsoft.Build.Shared
diff --git a/src/Shared/InterningBinaryReader.cs b/src/Shared/InterningBinaryReader.cs
index 128cdec4826..8eba40139be 100644
--- a/src/Shared/InterningBinaryReader.cs
+++ b/src/Shared/InterningBinaryReader.cs
@@ -2,11 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.Text;
 using System.IO;
 using System.Diagnostics;
-using System.Globalization;
 
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
 
diff --git a/src/Shared/LanguageParser/CSharptokenCharReader.cs b/src/Shared/LanguageParser/CSharptokenCharReader.cs
index 23cb8610b18..38f35bfd895 100644
--- a/src/Shared/LanguageParser/CSharptokenCharReader.cs
+++ b/src/Shared/LanguageParser/CSharptokenCharReader.cs
@@ -3,11 +3,6 @@
 
 using System;
 using System.IO;
-using System.Text;
-using System.Resources;
-using System.Reflection;
-using System.Collections;
-using System.Globalization;
 
 namespace Microsoft.Build.Shared.LanguageParser
 {
diff --git a/src/Shared/LanguageParser/CSharptokenEnumerator.cs b/src/Shared/LanguageParser/CSharptokenEnumerator.cs
index ec70a0ff137..d3d01f4c042 100644
--- a/src/Shared/LanguageParser/CSharptokenEnumerator.cs
+++ b/src/Shared/LanguageParser/CSharptokenEnumerator.cs
@@ -3,11 +3,6 @@
 
 using System;
 using System.IO;
-using System.Text;
-using System.Resources;
-using System.Reflection;
-using System.Collections;
-using System.Globalization;
 using System.Diagnostics;
 
 namespace Microsoft.Build.Shared.LanguageParser
diff --git a/src/Shared/LanguageParser/CSharptokenizer.cs b/src/Shared/LanguageParser/CSharptokenizer.cs
index b784e842f12..0f0ea0983b7 100644
--- a/src/Shared/LanguageParser/CSharptokenizer.cs
+++ b/src/Shared/LanguageParser/CSharptokenizer.cs
@@ -1,14 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.IO;
-using System.Text;
-using System.Resources;
-using System.Reflection;
 using System.Collections;
-using System.Globalization;
-using System.Diagnostics;
 
 namespace Microsoft.Build.Shared.LanguageParser
 {
diff --git a/src/Shared/LanguageParser/StreamMappedString.cs b/src/Shared/LanguageParser/StreamMappedString.cs
index 5967e0b4212..a5e11f905ad 100644
--- a/src/Shared/LanguageParser/StreamMappedString.cs
+++ b/src/Shared/LanguageParser/StreamMappedString.cs
@@ -4,11 +4,6 @@
 using System;
 using System.IO;
 using System.Text;
-using System.Resources;
-using System.Reflection;
-using System.Collections;
-using System.Globalization;
-using System.Diagnostics;
 
 namespace Microsoft.Build.Shared.LanguageParser
 {
@@ -378,7 +373,7 @@ public string Substring(int startPosition, int length)
         {
             StringBuilder result = new StringBuilder(length);
 
-            int charactersExtracted = 0;
+            int charactersExtracted;
             for (int i = 0; i < length; i += charactersExtracted)
             {
                 char[] page = GetPage(startPosition + i);
diff --git a/src/Shared/LanguageParser/VisualBasictokenCharReader.cs b/src/Shared/LanguageParser/VisualBasictokenCharReader.cs
index 9faab70db0c..f409167ce25 100644
--- a/src/Shared/LanguageParser/VisualBasictokenCharReader.cs
+++ b/src/Shared/LanguageParser/VisualBasictokenCharReader.cs
@@ -3,11 +3,6 @@
 
 using System;
 using System.IO;
-using System.Text;
-using System.Resources;
-using System.Reflection;
-using System.Collections;
-using System.Globalization;
 
 namespace Microsoft.Build.Shared.LanguageParser
 {
diff --git a/src/Shared/LanguageParser/VisualBasictokenEnumerator.cs b/src/Shared/LanguageParser/VisualBasictokenEnumerator.cs
index 0b90ff73a58..e0304216852 100644
--- a/src/Shared/LanguageParser/VisualBasictokenEnumerator.cs
+++ b/src/Shared/LanguageParser/VisualBasictokenEnumerator.cs
@@ -3,11 +3,6 @@
 
 using System;
 using System.IO;
-using System.Text;
-using System.Resources;
-using System.Reflection;
-using System.Collections;
-using System.Globalization;
 
 namespace Microsoft.Build.Shared.LanguageParser
 {
diff --git a/src/Shared/LanguageParser/VisualBasictokenizer.cs b/src/Shared/LanguageParser/VisualBasictokenizer.cs
index ef49547ea8d..ee2a0699596 100644
--- a/src/Shared/LanguageParser/VisualBasictokenizer.cs
+++ b/src/Shared/LanguageParser/VisualBasictokenizer.cs
@@ -1,13 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.IO;
-using System.Text;
-using System.Resources;
-using System.Reflection;
 using System.Collections;
-using System.Globalization;
 
 namespace Microsoft.Build.Shared.LanguageParser
 {
diff --git a/src/Shared/LanguageParser/token.cs b/src/Shared/LanguageParser/token.cs
index c402fcd1fb6..495d648099d 100644
--- a/src/Shared/LanguageParser/token.cs
+++ b/src/Shared/LanguageParser/token.cs
@@ -2,12 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Text;
-using System.Resources;
-using System.Reflection;
-using System.Collections;
-using System.Globalization;
 
 namespace Microsoft.Build.Shared.LanguageParser
 {
diff --git a/src/Shared/LanguageParser/tokenChar.cs b/src/Shared/LanguageParser/tokenChar.cs
index 5cd32212f98..98c179f63e1 100644
--- a/src/Shared/LanguageParser/tokenChar.cs
+++ b/src/Shared/LanguageParser/tokenChar.cs
@@ -1,12 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Text;
-using System.Resources;
-using System.Reflection;
-using System.Collections;
 using System.Globalization;
 
 namespace Microsoft.Build.Shared.LanguageParser
diff --git a/src/Shared/LanguageParser/tokenCharReader.cs b/src/Shared/LanguageParser/tokenCharReader.cs
index aa8aa07d3d4..3f326e75c3b 100644
--- a/src/Shared/LanguageParser/tokenCharReader.cs
+++ b/src/Shared/LanguageParser/tokenCharReader.cs
@@ -3,11 +3,6 @@
 
 using System;
 using System.IO;
-using System.Text;
-using System.Resources;
-using System.Reflection;
-using System.Collections;
-using System.Globalization;
 
 namespace Microsoft.Build.Shared.LanguageParser
 {
diff --git a/src/Shared/LanguageParser/tokenEnumerator.cs b/src/Shared/LanguageParser/tokenEnumerator.cs
index 48b82b6be59..8863c3529f7 100644
--- a/src/Shared/LanguageParser/tokenEnumerator.cs
+++ b/src/Shared/LanguageParser/tokenEnumerator.cs
@@ -1,13 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Text;
-using System.Resources;
-using System.Reflection;
 using System.Collections;
-using System.Globalization;
 
 namespace Microsoft.Build.Shared.LanguageParser
 {
diff --git a/src/Shared/LoadedType.cs b/src/Shared/LoadedType.cs
index 5a6cbe0c208..b1cdebf4649 100644
--- a/src/Shared/LoadedType.cs
+++ b/src/Shared/LoadedType.cs
@@ -2,9 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 using System.Reflection;
-using System.Collections.Generic;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Shared
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index d439204c328..497be9de813 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using System.IO;
 using System.Reflection;
 
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index 6840143985b..df97ba927ce 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -3,7 +3,6 @@
 
 
 using Microsoft.Build.Shared.FileSystem;
-using System;
 using System.Collections.Immutable;
 using System.IO;
 using System.Reflection;
diff --git a/src/Shared/MetadataConversionUtilities.cs b/src/Shared/MetadataConversionUtilities.cs
index 39a454c6266..b815f2fba99 100644
--- a/src/Shared/MetadataConversionUtilities.cs
+++ b/src/Shared/MetadataConversionUtilities.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Shared
@@ -63,7 +62,7 @@ internal static bool TryConvertItemMetadataToBool
                 string itemMetadataName
             )
         {
-            bool metadataFound = false;
+            bool metadataFound;
             return TryConvertItemMetadataToBool(item, itemMetadataName, out metadataFound);
         }
     }
diff --git a/src/Shared/Modifiers.cs b/src/Shared/Modifiers.cs
index 872ae9fb681..1ad37579cb6 100644
--- a/src/Shared/Modifiers.cs
+++ b/src/Shared/Modifiers.cs
@@ -3,18 +3,8 @@
 
 using System;
 using System.IO;
-using System.Security;
-using System.Collections;
-using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
-using System.Globalization;
-using System.Text.RegularExpressions;
-using System.Text;
-using System.Threading;
-using System.Runtime.InteropServices;
 using System.Collections.Generic;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
diff --git a/src/Shared/NGen.cs b/src/Shared/NGen.cs
index 380fa11d26b..cf3cb7a3ab6 100644
--- a/src/Shared/NGen.cs
+++ b/src/Shared/NGen.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using Microsoft.Build.Framework;
-
 namespace Microsoft.Build.Shared
 {
     /// <summary>
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index c9c803b7c8e..7d66b7731ce 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -8,9 +8,7 @@
 using System.Diagnostics.CodeAnalysis;
 using System.IO;
 using System.Runtime.InteropServices;
-using System.Security.Cryptography.X509Certificates;
 using System.Text;
-using System.Text.RegularExpressions;
 using System.Threading;
 using System.Reflection;
 using Microsoft.Win32;
@@ -136,6 +134,32 @@ private enum eDesiredAccess : int
             PROCESS_QUERY_INFORMATION = 0x0400,
             PROCESS_ALL_ACCESS = SYNCHRONIZE | 0xFFF
         }
+#pragma warning disable 0649, 0169
+        internal enum LOGICAL_PROCESSOR_RELATIONSHIP
+        {
+            RelationProcessorCore,
+            RelationNumaNode,
+            RelationCache,
+            RelationProcessorPackage,
+            RelationGroup,
+            RelationAll = 0xffff
+        }
+        internal struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX
+        {
+            public LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
+            public uint Size;
+            public PROCESSOR_RELATIONSHIP Processor;
+        }
+        [StructLayout(LayoutKind.Sequential)]
+        internal unsafe struct PROCESSOR_RELATIONSHIP
+        {
+            public byte Flags;
+            private byte EfficiencyClass;
+            private fixed byte Reserved[20];
+            public ushort GroupCount;
+            public IntPtr GroupInfo;
+        }
+#pragma warning restore 0169, 0149
 
         /// <summary>
         /// Flags for CoWaitForMultipleHandles
@@ -409,59 +433,124 @@ public SystemInformationData()
                 }
                 else
                 {
-                    try
+                    ProcessorArchitectures processorArchitecture = ProcessorArchitectures.Unknown;
+#if !NET35
+                    // Get the architecture from the runtime.
+                    processorArchitecture = RuntimeInformation.OSArchitecture switch
                     {
-                        // On Unix run 'uname -m' to get the architecture. It's common for Linux and Mac
-                        using (
-                            var proc =
-                                Process.Start(
-                                    new ProcessStartInfo("uname")
-                                    {
-                                        Arguments = "-m",
-                                        UseShellExecute = false,
-                                        RedirectStandardOutput = true,
-                                        CreateNoWindow = true
-                                    }))
+                        Architecture.Arm => ProcessorArchitectures.ARM,
+                        Architecture.Arm64 =>  ProcessorArchitectures.ARM64,
+                        Architecture.X64 => ProcessorArchitectures.X64,
+                        Architecture.X86 => ProcessorArchitectures.X86,
+                        _ => ProcessorArchitectures.Unknown,
+                    };
+#endif
+                    // Fall back to 'uname -m' to get the architecture.
+                    if (processorArchitecture == ProcessorArchitectures.Unknown)
+                    {
+                        try
                         {
-                            string arch = null;
-                            if (proc != null)
+                            // On Unix run 'uname -m' to get the architecture. It's common for Linux and Mac
+                            using (
+                                var proc =
+                                    Process.Start(
+                                        new ProcessStartInfo("uname")
+                                        {
+                                            Arguments = "-m",
+                                            UseShellExecute = false,
+                                            RedirectStandardOutput = true,
+                                            CreateNoWindow = true
+                                        }))
                             {
-                                // Since uname -m simply returns kernel property, it should be quick.
-                                // 1 second is the best guess for a safe timeout.
-                                proc.WaitForExit(1000);
-                                arch = proc.StandardOutput.ReadLine();
-                            }
-
-                            if (!string.IsNullOrEmpty(arch))
-                            {
-                                if (arch.StartsWith("x86_64", StringComparison.OrdinalIgnoreCase))
-                                {
-                                    ProcessorArchitectureType = ProcessorArchitectures.X64;
-                                }
-                                else if (arch.StartsWith("ia64", StringComparison.OrdinalIgnoreCase))
+                                string arch = null;
+                                if (proc != null)
                                 {
-                                    ProcessorArchitectureType = ProcessorArchitectures.IA64;
+                                    // Since uname -m simply returns kernel property, it should be quick.
+                                    // 1 second is the best guess for a safe timeout.
+                                    proc.WaitForExit(1000);
+                                    arch = proc.StandardOutput.ReadLine();
                                 }
-                                else if (arch.StartsWith("arm", StringComparison.OrdinalIgnoreCase))
-                                {
-                                    ProcessorArchitectureType = ProcessorArchitectures.ARM;
-                                }
-                                else if (arch.StartsWith("i", StringComparison.OrdinalIgnoreCase)
-                                         && arch.EndsWith("86", StringComparison.OrdinalIgnoreCase))
+
+                                if (!string.IsNullOrEmpty(arch))
                                 {
-                                    ProcessorArchitectureType = ProcessorArchitectures.X86;
+                                    if (arch.StartsWith("x86_64", StringComparison.OrdinalIgnoreCase))
+                                    {
+                                        ProcessorArchitectureType = ProcessorArchitectures.X64;
+                                    }
+                                    else if (arch.StartsWith("ia64", StringComparison.OrdinalIgnoreCase))
+                                    {
+                                        ProcessorArchitectureType = ProcessorArchitectures.IA64;
+                                    }
+                                    else if (arch.StartsWith("arm", StringComparison.OrdinalIgnoreCase))
+                                    {
+                                        ProcessorArchitectureType = ProcessorArchitectures.ARM;
+                                    }
+                                    else if (arch.StartsWith("aarch64", StringComparison.OrdinalIgnoreCase))
+                                    {
+                                        ProcessorArchitectureType = ProcessorArchitectures.ARM64;
+                                    }
+                                    else if (arch.StartsWith("i", StringComparison.OrdinalIgnoreCase)
+                                            && arch.EndsWith("86", StringComparison.OrdinalIgnoreCase))
+                                    {
+                                        ProcessorArchitectureType = ProcessorArchitectures.X86;
+                                    }
                                 }
                             }
                         }
+                        catch
+                        {
+                            // Best effort: fall back to Unknown
+                        }
                     }
-                    catch
+
+                    ProcessorArchitectureTypeNative = ProcessorArchitectureType = processorArchitecture;
+                }
+            }
+        }
+
+        /// <summary>
+        /// Get the exact physical core count on Windows
+        /// Useful for getting the exact core count in 32 bits processes,
+        /// as Environment.ProcessorCount has a 32-core limit in that case. 
+        /// https://github.com/dotnet/runtime/blob/221ad5b728f93489655df290c1ea52956ad8f51c/src/libraries/System.Runtime.Extensions/src/System/Environment.Windows.cs#L171-L210
+        /// </summary>
+        public unsafe static int GetLogicalCoreCount()
+        {
+            uint len = 0;
+            const int ERROR_INSUFFICIENT_BUFFER = 122;
+
+            if (!GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, IntPtr.Zero, ref len) &&
+                Marshal.GetLastWin32Error() == ERROR_INSUFFICIENT_BUFFER)
+            {
+                // Allocate that much space
+                var buffer = new byte[len];
+                fixed (byte* bufferPtr = buffer)
+                {
+                    // Call GetLogicalProcessorInformationEx with the allocated buffer
+                    if (GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore, (IntPtr)bufferPtr, ref len))
                     {
-                        ProcessorArchitectureType = ProcessorArchitectures.Unknown;
+                        // Walk each SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX in the buffer, where the Size of each dictates how
+                        // much space it's consuming.  For each group relation, count the number of active processors in each of its group infos.
+                        int processorCount = 0;
+                        byte* ptr = bufferPtr;
+                        byte* endPtr = bufferPtr + len;
+                        while (ptr < endPtr)
+                        {
+                            var current = (SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX*)ptr;
+                            if (current->Relationship == LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore)
+                            {
+                                // Flags is 0 if the core has a single logical proc, LTP_PC_SMT if more than one
+                                // for now, assume "more than 1" == 2, as it has historically been for hyperthreading
+                                processorCount += (current->Processor.Flags == 0) ? 1 : 2;
+                            }
+                            ptr += current->Size;
+                        }
+                        return processorCount;
                     }
-
-                    ProcessorArchitectureTypeNative = ProcessorArchitectureType;
                 }
             }
+
+            return -1;
         }
 
         #endregion
@@ -804,6 +893,10 @@ internal static int SetErrorMode(int newMode)
         [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
         [DllImport("kernel32.dll", SetLastError = true)]
         internal static extern void GetNativeSystemInfo(ref SYSTEM_INFO lpSystemInfo);
+        
+        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
+        [DllImport("kernel32.dll", SetLastError = true)]
+        internal static extern bool GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, IntPtr Buffer, ref uint ReturnedLength);
 
         /// <summary>
         /// Get the last write time of the fullpath to a directory. If the pointed path is not a directory, or
@@ -820,9 +913,7 @@ internal static bool GetLastWriteDirectoryUtcTime(string fullPath, out DateTime
                 fileModifiedTimeUtc = DateTime.MinValue;
 
                 WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
-                bool success = false;
-
-                success = GetFileAttributesEx(fullPath, 0, ref data);
+                bool success = GetFileAttributesEx(fullPath, 0, ref data);
                 if (success)
                 {
                     if ((data.fileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
@@ -970,9 +1061,7 @@ internal static DateTime GetLastWriteFileUtcTime(string fullPath)
                 }
 
                 WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
-                bool success = false;
-
-                success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
+                bool success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
 
                 if (success && (data.fileAttributes & NativeMethodsShared.FILE_ATTRIBUTE_DIRECTORY) == 0)
                 {
@@ -1078,7 +1167,7 @@ internal static void KillTree(int processIdToKill)
             // Only when you create the process using the Process object
             // does the Process object retain the original handle.
 
-            Process thisProcess = null;
+            Process thisProcess;
             try
             {
                 thisProcess = Process.GetProcessById(processIdToKill);
@@ -1580,9 +1669,7 @@ internal static bool DirectoryExists(string fullPath)
         internal static bool DirectoryExistsWindows(string fullPath)
         {
             NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA data = new NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA();
-            bool success = false;
-
-            success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
+            bool success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
             return success && (data.fileAttributes & NativeMethodsShared.FILE_ATTRIBUTE_DIRECTORY) != 0;
         }
 
@@ -1596,9 +1683,7 @@ internal static bool FileExists(string fullPath)
         internal static bool FileExistsWindows(string fullPath)
         {
             NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA data = new NativeMethodsShared.WIN32_FILE_ATTRIBUTE_DATA();
-            bool success = false;
-
-            success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
+            bool success = NativeMethodsShared.GetFileAttributesEx(fullPath, 0, ref data);
             return success && (data.fileAttributes & NativeMethodsShared.FILE_ATTRIBUTE_DIRECTORY) == 0;
         }
 
diff --git a/src/Shared/NodeBuildComplete.cs b/src/Shared/NodeBuildComplete.cs
index 5d6b5472e90..5e9b03e32ce 100644
--- a/src/Shared/NodeBuildComplete.cs
+++ b/src/Shared/NodeBuildComplete.cs
@@ -1,10 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 using System.Diagnostics;
 
 namespace Microsoft.Build.BackEnd
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 88b6cb2966b..462615f5505 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -15,13 +15,12 @@
 #if FEATURE_SECURITY_PERMISSIONS || FEATURE_PIPE_SECURITY
 using System.Security.AccessControl;
 #endif
+#if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
 using System.Security.Principal;
+#endif
 #if !FEATURE_APM
 using System.Threading.Tasks;
 #endif
-#if FEATURE_SECURITY_PERMISSIONS
-using System.Security.Permissions;
-#endif
 
 namespace Microsoft.Build.BackEnd
 {
@@ -30,7 +29,7 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
     {
-        #region Private Data
+#region Private Data
 
 #if NETCOREAPP2_1 || MONO
         /// <summary>
@@ -292,9 +291,8 @@ private void InternalDisconnect()
         private void EnqueuePacket(INodePacket packet)
         {
             ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
-            ErrorUtilities.VerifyThrow(null != _packetQueue, "packetQueue is null");
-            ErrorUtilities.VerifyThrow(null != _packetAvailable, "packetAvailable is null");
-
+            ErrorUtilities.VerifyThrow(_packetQueue != null, "packetQueue is null");
+            ErrorUtilities.VerifyThrow(_packetAvailable != null, "packetAvailable is null");
             _packetQueue.Enqueue(packet);
             _packetAvailable.Set();
         }
diff --git a/src/Shared/NodeEngineShutdownReason.cs b/src/Shared/NodeEngineShutdownReason.cs
index 91c67a0c816..1d49af7082f 100644
--- a/src/Shared/NodeEngineShutdownReason.cs
+++ b/src/Shared/NodeEngineShutdownReason.cs
@@ -1,10 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-
 namespace Microsoft.Build.Execution
 {
     #region Enums
diff --git a/src/Shared/NodeShutdown.cs b/src/Shared/NodeShutdown.cs
index 24a9dfe88f1..8bd7ce3da77 100644
--- a/src/Shared/NodeShutdown.cs
+++ b/src/Shared/NodeShutdown.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 
 namespace Microsoft.Build.BackEnd
 {
diff --git a/src/Shared/OutOfProcTaskHostTaskResult.cs b/src/Shared/OutOfProcTaskHostTaskResult.cs
index 5bba48c8960..f7c803c095e 100644
--- a/src/Shared/OutOfProcTaskHostTaskResult.cs
+++ b/src/Shared/OutOfProcTaskHostTaskResult.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 
 using Microsoft.Build.BackEnd;
 
diff --git a/src/Shared/Pair.cs b/src/Shared/Pair.cs
index 9ef1e7f7256..214cd891074 100644
--- a/src/Shared/Pair.cs
+++ b/src/Shared/Pair.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using Microsoft.Build.Framework;
-using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
 
 namespace Microsoft.Build.Shared
diff --git a/src/Shared/ProjectErrorUtilities.cs b/src/Shared/ProjectErrorUtilities.cs
index 303749fc6fd..540b26f71d1 100644
--- a/src/Shared/ProjectErrorUtilities.cs
+++ b/src/Shared/ProjectErrorUtilities.cs
@@ -1,8 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Diagnostics;
 
 /******************************************************************************
  * 
diff --git a/src/Shared/ProjectFileErrorUtilities.cs b/src/Shared/ProjectFileErrorUtilities.cs
index c311159d878..d672e250e5f 100644
--- a/src/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Shared/ProjectFileErrorUtilities.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Xml;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 
diff --git a/src/Shared/ReadOnlyCollection.cs b/src/Shared/ReadOnlyCollection.cs
index bb362f26f24..4837b457a32 100644
--- a/src/Shared/ReadOnlyCollection.cs
+++ b/src/Shared/ReadOnlyCollection.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
 using System.Collections;
 using Microsoft.Build.Shared;
 
diff --git a/src/Shared/ReadOnlyEmptyCollection.cs b/src/Shared/ReadOnlyEmptyCollection.cs
index d3610dcc5ba..22caa31c707 100644
--- a/src/Shared/ReadOnlyEmptyCollection.cs
+++ b/src/Shared/ReadOnlyEmptyCollection.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using System.Collections;
 using Microsoft.Build.Shared;
 
diff --git a/src/Shared/RegisteredTaskObjectCacheBase.cs b/src/Shared/RegisteredTaskObjectCacheBase.cs
index 17444232eba..3e8cabaf744 100644
--- a/src/Shared/RegisteredTaskObjectCacheBase.cs
+++ b/src/Shared/RegisteredTaskObjectCacheBase.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Concurrent;
-using System.Collections.Generic;
 using Microsoft.Build.Framework;
 
 #if BUILD_ENGINE
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index 6d42db51002..6901698abf6 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -6,9 +6,6 @@
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
-using System.Text.RegularExpressions;
-using System.Reflection;
-using System.Text;
 using System.ComponentModel;
 
 #if BUILDINGAPPXTASKS
diff --git a/src/Shared/Resources/Strings.shared.resx b/src/Shared/Resources/Strings.shared.resx
index fd568252430..4a2ab0dd185 100644
--- a/src/Shared/Resources/Strings.shared.resx
+++ b/src/Shared/Resources/Strings.shared.resx
@@ -200,6 +200,10 @@
     <value>MSB5008: Error parsing the solution configuration section in solution file. The entry "{0}" is invalid.</value>
     <comment>{StrBegin="MSB5008: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
+  <data name="SolutionParseNestedProjectErrorWithNameAndGuid" Visibility="Public">
+    <value>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</value>
+    <comment>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</comment>
+  </data>
   <data name="SolutionParseNestedProjectError" Visibility="Public">
     <value>MSB5009: Error parsing the nested project section in solution file.</value>
     <comment>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</comment>
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index da68649da45..bd83b1430f4 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -80,6 +80,11 @@
         <target state="translated">MSB5026: Soubor filtru řešení v {0} určuje, že v {1} se bude nacházet soubor řešení, ale tento soubor neexistuje.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
+      <trans-unit id="SolutionParseNestedProjectErrorWithNameAndGuid">
+        <source>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</source>
+        <target state="new">MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</target>
+        <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Verze nástrojů {0} je neznámá. Dostupné verze nástrojů jsou {1}.</target>
@@ -217,7 +222,7 @@
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009: Při analýze vnořeného oddílu projektu v souboru řešení došlo k chybě.</target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index a50d17cb12b..1107a885715 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -80,6 +80,11 @@
         <target state="translated">MSB5026: Die Projektmappenfilter-Datei unter "{0}" gibt an, dass eine Projektmappendatei unter "{1}" vorhanden ist. Diese Datei ist jedoch nicht vorhanden.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
+      <trans-unit id="SolutionParseNestedProjectErrorWithNameAndGuid">
+        <source>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</source>
+        <target state="new">MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</target>
+        <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Die Toolsversion "{0}" ist unbekannt. Verfügbare Toolversionen sind {1}.</target>
@@ -217,7 +222,7 @@
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009: Fehler beim Analysieren des geschachtelten Projektabschnitts in der Projektmappendatei.</target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
diff --git a/src/Shared/Resources/xlf/Strings.shared.en.xlf b/src/Shared/Resources/xlf/Strings.shared.en.xlf
index cf10e5c095a..62bf77f50b8 100644
--- a/src/Shared/Resources/xlf/Strings.shared.en.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.en.xlf
@@ -85,6 +85,11 @@
         <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
+      <trans-unit id="SolutionParseNestedProjectErrorWithNameAndGuid">
+        <source>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</source>
+        <target state="new">MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</target>
+        <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="new">MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index 826677d1ee6..d1db5d376da 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -80,6 +80,11 @@
         <target state="translated">MSB5026: El archivo de filtro de soluciones en "{0}" especifica que habrá un archivo de solución en "{1}", pero ese archivo no existe.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
+      <trans-unit id="SolutionParseNestedProjectErrorWithNameAndGuid">
+        <source>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</source>
+        <target state="new">MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</target>
+        <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: No se reconoce la versión de herramientas "{0}". Las versiones de herramientas disponibles son {1}.</target>
@@ -217,7 +222,7 @@
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009: Error al analizar la sección del proyecto anidado en el archivo de solución.</target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 547f7a28e07..f0b7844102f 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -80,6 +80,11 @@
         <target state="translated">MSB5026: le fichier de filtre de solution sur "{0}" spécifie l'existence d'un fichier solution sur "{1}", mais ce fichier n'existe pas.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
+      <trans-unit id="SolutionParseNestedProjectErrorWithNameAndGuid">
+        <source>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</source>
+        <target state="new">MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</target>
+        <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: La version des outils "{0}" n'est pas reconnue. Les versions disponibles sont {1}.</target>
@@ -217,7 +222,7 @@
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009: Erreur pendant l'analyse de la section du projet imbriqué dans le fichier solution.</target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index d6dd6d83bf3..ba935b47140 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -80,6 +80,11 @@
         <target state="translated">MSB5026: nel file di filtro della soluzione in "{0}" è indicata la presenza di un file di soluzione in "{1}", ma tale file non esiste.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
+      <trans-unit id="SolutionParseNestedProjectErrorWithNameAndGuid">
+        <source>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</source>
+        <target state="new">MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</target>
+        <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: versione degli strumenti "{0}" non riconosciuta. Le versioni disponibili sono {1}.</target>
@@ -217,7 +222,7 @@
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009: errore durante l'analisi della sezione del progetto annidato nel file di soluzione.</target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index 8819383842b..ad63f47366d 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -80,6 +80,11 @@
         <target state="translated">MSB5026: "{0}" のソリューション フィルター ファイルでは、"{1}" にソリューション ファイルを配置するように指定されていますが、そのファイルは存在しません。</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
+      <trans-unit id="SolutionParseNestedProjectErrorWithNameAndGuid">
+        <source>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</source>
+        <target state="new">MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</target>
+        <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: ツール バージョン "{0}" が認識されません。使用可能なツール バージョンは {1} です。</target>
@@ -217,7 +222,7 @@
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009: ソリューション ファイル内の入れ子にされたプロジェクト セクションを解析中にエラーが発生しました。</target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 283d44b5076..61cbd35c3e9 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -80,6 +80,11 @@
         <target state="translated">MSB5026: "{0}"의 솔루션 필터 파일이 "{1}"에 솔루션 파일이 있도록 지정하지만, 해당 파일이 없습니다.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
+      <trans-unit id="SolutionParseNestedProjectErrorWithNameAndGuid">
+        <source>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</source>
+        <target state="new">MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</target>
+        <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: 도구 버전 "{0}"을(를) 인식할 수 없습니다. 사용할 수 있는 도구 버전은 {1}입니다.</target>
@@ -217,7 +222,7 @@
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009: 솔루션 파일의 중첩된 프로젝트 섹션을 구문 분석하는 동안 오류가 발생했습니다.</target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index 394f3cca893..3358ffe4438 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -80,6 +80,11 @@
         <target state="translated">MSB5026: Plik filtru rozwiązania w lokalizacji „{0}” określa, że plik rozwiązania będzie się znajdował w lokalizacji „{1}”, ale ten plik nie istnieje.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
+      <trans-unit id="SolutionParseNestedProjectErrorWithNameAndGuid">
+        <source>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</source>
+        <target state="new">MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</target>
+        <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Wersja narzędzi „{0}” nie została rozpoznana. Dostępne wersje narzędzi to {1}.</target>
@@ -217,7 +222,7 @@
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009: Błąd podczas analizowania zagnieżdżonej sekcji projektu w pliku rozwiązania.</target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index 5b91a379052..1235da65833 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -80,6 +80,11 @@
         <target state="translated">MSB5026: o arquivo de filtro da solução em "{0}" especifica que haverá um arquivo de solução em "{1}", mas esse arquivo não existe.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
+      <trans-unit id="SolutionParseNestedProjectErrorWithNameAndGuid">
+        <source>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</source>
+        <target state="new">MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</target>
+        <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: A versão das ferramentas "{0}" não é reconhecida. As versões das ferramentas disponíveis são {1}.</target>
@@ -217,7 +222,7 @@
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009: Erro ao analisar a seção do projeto aninhado no arquivo de solução.</target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index 0399406e0a6..ea0c75dbcf7 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -80,6 +80,11 @@
         <target state="translated">MSB5026: файл фильтра решения в "{0}" указывает на то, что в "{1}" будет находиться файл решения, однако этот файл отсутствует.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
+      <trans-unit id="SolutionParseNestedProjectErrorWithNameAndGuid">
+        <source>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</source>
+        <target state="new">MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</target>
+        <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: версия инструментов "{0}" не распознана. Доступные версии инструментов: {1}.</target>
@@ -217,7 +222,7 @@
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009: ошибка синтаксического анализа вложенного раздела проекта в файле решения.</target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index d17522e92d2..ad32bf482b0 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -80,6 +80,11 @@
         <target state="translated">MSB5026: "{0}" konumundaki çözüm filtresi dosyası, "{1}" konumunda bir çözüm dosyası olacağını belirtiyor, ancak bu dosya mevcut değil.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
+      <trans-unit id="SolutionParseNestedProjectErrorWithNameAndGuid">
+        <source>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</source>
+        <target state="new">MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</target>
+        <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Araçlar sürümü "{0}" tanınmıyor. Kullanılabilir araç sürümleri şunlardır: {1}.</target>
@@ -217,7 +222,7 @@
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009: Çözüm dosyasındaki iç içe proje bölümünü ayrıştırma hatası oluştu.</target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index ada4552472c..b54af69ce2d 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -80,6 +80,11 @@
         <target state="translated">MSB5026: 位于“{0}”的解决方案筛选器文件指定“{1}”处将存在一个解决方案文件，但该文件不存在。</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
+      <trans-unit id="SolutionParseNestedProjectErrorWithNameAndGuid">
+        <source>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</source>
+        <target state="new">MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</target>
+        <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: 无法识别工具版本“{0}”。可用的工具版本为 {1}。</target>
@@ -217,7 +222,7 @@
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009: 分析解决方案文件中的嵌套项目节时出错。</target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index 93035219c43..208ff11b7f7 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -80,6 +80,11 @@
         <target state="translated">MSB5026: 位於 "{0}" 的解決方案篩選檔案指定將會有位於 "{1}" 的解決方案檔案，但該檔案並不存在。</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
+      <trans-unit id="SolutionParseNestedProjectErrorWithNameAndGuid">
+        <source>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</source>
+        <target state="new">MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</target>
+        <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: 工具版本 "{0}" 無法辨認。可用的工具版本為 {1}。</target>
@@ -217,7 +222,7 @@
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009: 剖析方案檔中的巢狀專案區段時發生錯誤。</target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
diff --git a/src/Shared/StrongNameHelpers.cs b/src/Shared/StrongNameHelpers.cs
index 7d8bbdb6a4b..8bc93fb0951 100644
--- a/src/Shared/StrongNameHelpers.cs
+++ b/src/Shared/StrongNameHelpers.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Security;
-using System.Text;
 using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 using System.Diagnostics.CodeAnalysis;
@@ -143,7 +141,7 @@ public static bool StrongNameKeyInstall(string pwzKeyContainer, IntPtr pbKeyBlob
         public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob)
         {
             IntPtr ppbSignatureBlob = IntPtr.Zero;
-            int cbSignatureBlob = 0;
+            int cbSignatureBlob;
             return StrongNameSignatureGeneration(pwzFilePath, pwzKeyContainer, pbKeyBlob, cbKeyBlob, ref ppbSignatureBlob, out cbSignatureBlob);
         }
 
@@ -280,7 +278,7 @@ public static bool StrongNameKeyInstall(string pwzKeyContainer, byte[] bKeyBlob,
         public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, byte[] bKeyBlob, int cbKeyBlob)
         {
             IntPtr ppbSignatureBlob = IntPtr.Zero;
-            int cbSignatureBlob = 0;
+            int cbSignatureBlob;
             return StrongNameSignatureGeneration(pwzFilePath, pwzKeyContainer, bKeyBlob, cbKeyBlob, ref ppbSignatureBlob, out cbSignatureBlob);
         }
 
diff --git a/src/Shared/TaskEngineAssemblyResolver.cs b/src/Shared/TaskEngineAssemblyResolver.cs
index e58b0ea73f0..ddbc6dcc62c 100644
--- a/src/Shared/TaskEngineAssemblyResolver.cs
+++ b/src/Shared/TaskEngineAssemblyResolver.cs
@@ -5,7 +5,6 @@
 using System.IO;
 using System.Reflection;
 using System.Diagnostics;
-using System.Globalization;
 
 #if FEATURE_ASSEMBLYLOADCONTEXT
 using System.Runtime.Loader;
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index 141528ecc11..45d007d25b3 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -7,7 +7,6 @@
 using System.Globalization;
 
 using Microsoft.Build.Shared;
-using System.Reflection;
 
 namespace Microsoft.Build.BackEnd
 {
diff --git a/src/Shared/TaskHostTaskCancelled.cs b/src/Shared/TaskHostTaskCancelled.cs
index 3c2b9b580e9..83a0389b7ba 100644
--- a/src/Shared/TaskHostTaskCancelled.cs
+++ b/src/Shared/TaskHostTaskCancelled.cs
@@ -1,11 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
diff --git a/src/Shared/TaskHostTaskComplete.cs b/src/Shared/TaskHostTaskComplete.cs
index 9699bbab4f3..11194395c49 100644
--- a/src/Shared/TaskHostTaskComplete.cs
+++ b/src/Shared/TaskHostTaskComplete.cs
@@ -4,10 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
-using System.Text;
-
-using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index fe6d67f1c8c..7e27f0e68a2 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -1313,7 +1313,7 @@ public bool LogMessageFromText(string lineOfText, MessageImportance messageImpor
             bool isError = false;
             CanonicalError.Parts messageParts = CanonicalError.Parse(lineOfText);
 
-            if (null == messageParts)
+            if (messageParts == null)
             {
                 // Line was not recognized as a canonical error. Log it as a message.
                 LogMessage(messageImportance, lineOfText);
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index b7a2e6309c4..ead8151a85b 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -6,8 +6,6 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Security;
-
-using Microsoft.Build.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System.Reflection;
@@ -274,11 +272,9 @@ internal static TaskParameter FactoryForDeserialization(ITranslator translator)
         private ITaskItem CreateNewTaskItemFrom(ITaskItem copyFrom)
         {
             ITaskItem2 copyFromAsITaskItem2 = copyFrom as ITaskItem2;
-
-            string escapedItemSpec = null;
-            string escapedDefiningProject = null;
-            Dictionary<string, string> escapedMetadata = null;
-
+            string escapedItemSpec;
+            string escapedDefiningProject;
+            Dictionary<string, string> escapedMetadata;
             if (copyFromAsITaskItem2 != null)
             {
                 escapedItemSpec = copyFromAsITaskItem2.EvaluatedIncludeEscaped;
@@ -736,7 +732,7 @@ string ITaskItem2.GetMetadataValueEscaped(string metadataName)
                     _customEscapedMetadata.TryGetValue(metadataName, out metadataValue);
                 }
 
-                return (metadataValue == null) ? String.Empty : metadataValue;
+                return metadataValue ?? String.Empty;
             }
 
             /// <summary>
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index e08128daad5..7453ed33cb3 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -7,9 +7,6 @@
 using System.Configuration;
 #endif
 using System.IO;
-using System.Text;
-using System.Globalization;
-using System.Reflection;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
 
@@ -36,7 +33,7 @@ internal static ToolsetConfigurationSection ReadToolsetConfigurationSection(Conf
             // If section definition is present and section is not present, this value is not null
             // If section definition is not present and section is also not present, this value is null
             // If the section definition is not present and section is present, then this value is null
-            if (null != configuration)
+            if (configuration != null)
             {
                 ConfigurationSection msbuildSection = configuration.GetSection("msbuildToolsets");
                 configurationSection = msbuildSection as ToolsetConfigurationSection;
diff --git a/src/Shared/Tracing.cs b/src/Shared/Tracing.cs
index 2fb1dbdcbb5..7cdc0392191 100644
--- a/src/Shared/Tracing.cs
+++ b/src/Shared/Tracing.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.Reflection;
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index 418a6f1c055..3522c0972c1 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -31,6 +31,8 @@ public Traits()
 
         public EscapeHatches EscapeHatches { get; }
 
+        internal readonly string MSBuildDisableFeaturesFromVersion = Environment.GetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION"); 
+
         /// <summary>
         /// Do not expand wildcards that match a certain pattern
         /// </summary>
@@ -94,11 +96,6 @@ public Traits()
         /// </summary>
         public readonly int LogPropertyTracking = ParseIntFromEnvironmentVariableOrDefault("MsBuildLogPropertyTracking", 0); // Default to logging nothing via the property tracker.
 
-        /// <summary>
-        /// Setting this environment variable to 1 disables the node reuse feature.
-        /// </summary>
-        public readonly bool DisableNodeReuse = Environment.GetEnvironmentVariable("MSBUILDDISABLENODEREUSE") == "1";
-
         private static int ParseIntFromEnvironmentVariableOrDefault(string environmentVariable, int defaultValue)
         {
             return int.TryParse(Environment.GetEnvironmentVariable(environmentVariable), out int result)
@@ -136,6 +133,16 @@ internal class EscapeHatches
         /// </summary>
         public readonly bool TruncateTaskInputs = Environment.GetEnvironmentVariable("MSBUILDTRUNCATETASKINPUTS") == "1";
 
+        /// <summary>
+        /// Disables truncation of Condition messages in Tasks/Targets via ExpanderOptions.Truncate.
+        /// </summary>
+        public readonly bool DoNotTruncateConditions = Environment.GetEnvironmentVariable("MSBuildDoNotTruncateConditions") == "1";
+
+        /// <summary>
+        /// Disables skipping full drive/filesystem globs that are behind a false condition.
+        /// </summary>
+        public readonly bool AlwaysEvaluateDangerousGlobs = Environment.GetEnvironmentVariable("MSBuildAlwaysEvaluateDangerousGlobs") == "1";
+
         /// <summary>
         /// Emit events for project imports.
         /// </summary>
diff --git a/src/Shared/TranslatorHelpers.cs b/src/Shared/TranslatorHelpers.cs
index f1cd7166213..130ad05d9cd 100644
--- a/src/Shared/TranslatorHelpers.cs
+++ b/src/Shared/TranslatorHelpers.cs
@@ -1,10 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 
 namespace Microsoft.Build.BackEnd
 {
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index 7115f9d347f..7f879afa8aa 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -9,7 +9,6 @@
 using System.IO;
 using System.Reflection;
 using System.Threading;
-using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
 {
diff --git a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
index 9680172543b..2c804fa0320 100644
--- a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
+++ b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
@@ -368,25 +368,25 @@ public void CreateAssemblyNameWithNameAndVersionCulturePublicKey()
             extension = new AssemblyNameExtension("A, Version=2.0.0.0, PublicKeyToken=b03f5f7f11d50a3a");
             Assert.Equal("A", extension.Name);
             Assert.True(extension.Version.Equals(new Version("2.0.0.0")));
-            Assert.True(Object.ReferenceEquals(extension.CultureInfo, null));
+            Assert.True(extension.CultureInfo is null);
             Assert.Contains("b03f5f7f11d50a3a", extension.FullName);
 
             extension = new AssemblyNameExtension("A, Culture=en, PublicKeyToken=b03f5f7f11d50a3a");
             Assert.Equal("A", extension.Name);
-            Assert.True(Object.ReferenceEquals(extension.Version, null));
+            Assert.True(extension.Version is null);
             Assert.True(extension.CultureInfo.Equals(new CultureInfo("en")));
             Assert.Contains("b03f5f7f11d50a3a", extension.FullName);
 
             extension = new AssemblyNameExtension("A, PublicKeyToken=b03f5f7f11d50a3a");
             Assert.Equal("A", extension.Name);
-            Assert.True(Object.ReferenceEquals(extension.Version, null));
-            Assert.True(Object.ReferenceEquals(extension.CultureInfo, null));
+            Assert.True(extension.Version is null);
+            Assert.True(extension.CultureInfo is null);
             Assert.Contains("b03f5f7f11d50a3a", extension.FullName);
 
             extension = new AssemblyNameExtension("A");
             Assert.Equal("A", extension.Name);
-            Assert.True(Object.ReferenceEquals(extension.Version, null));
-            Assert.True(Object.ReferenceEquals(extension.CultureInfo, null));
+            Assert.True(extension.Version is null);
+            Assert.True(extension.CultureInfo is null);
         }
 
         /// <summary>
diff --git a/src/Shared/UnitTests/BuildEventArgsExtension.cs b/src/Shared/UnitTests/BuildEventArgsExtension.cs
index c7ba27feaf2..c2e67c450c9 100644
--- a/src/Shared/UnitTests/BuildEventArgsExtension.cs
+++ b/src/Shared/UnitTests/BuildEventArgsExtension.cs
@@ -5,7 +5,6 @@
 using Microsoft.Build.Framework;
 using System.Collections.Generic;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
-using Xunit;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -29,7 +28,7 @@ public static bool IsEquivalent(this BuildEventArgs args, BuildEventArgs other)
                 return true;
             }
 
-            if (Object.ReferenceEquals(other, null) || Object.ReferenceEquals(args, null))
+            if (other is null || args is null)
             {
                 return false;
             }
diff --git a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
index 22e8352e0f0..73813296685 100644
--- a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
+++ b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
@@ -6,10 +6,8 @@
 using System.IO;
 using System.Runtime.Serialization.Formatters.Binary;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Execution;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Construction;
 using Xunit;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests.OM.Collections
 {
@@ -24,10 +22,10 @@ public class CopyOnWriteDictionary_Tests
         [Fact]
         public void Indexer_ReferenceFound()
         {
-            object k1 = new Object();
+            string k1 = new string(nameof(Indexer_ReferenceFound).ToCharArray()); // force create new string
             object v1 = new Object();
 
-            var dictionary = new CopyOnWriteDictionary<object, object>();
+            var dictionary = new CopyOnWriteDictionary<object>();
             dictionary[k1] = v1;
 
             // Now look for the same key we inserted
@@ -45,8 +43,8 @@ public void Indexer_NotFound()
         {
             Assert.Throws<KeyNotFoundException>(() =>
             {
-                var dictionary = new CopyOnWriteDictionary<object, object>();
-                object value = dictionary[new Object()];
+                var dictionary = new CopyOnWriteDictionary<object>();
+                object value = dictionary[string.Empty];
             }
            );
         }
@@ -56,10 +54,10 @@ public void Indexer_NotFound()
         [Fact]
         public void TryGetValue_ReferenceFound()
         {
-            object k1 = new Object();
+            string k1 = new string(nameof(TryGetValue_ReferenceFound).ToCharArray());
             object v1 = new Object();
 
-            var dictionary = new CopyOnWriteDictionary<object, object>();
+            var dictionary = new CopyOnWriteDictionary<object>();
             dictionary[k1] = v1;
 
             // Now look for the same key we inserted
@@ -76,14 +74,14 @@ public void TryGetValue_ReferenceFound()
         [Fact]
         public void TryGetValue_ReferenceNotFound()
         {
-            var dictionary = new CopyOnWriteDictionary<object, object>();
+            var dictionary = new CopyOnWriteDictionary<object>();
 
             object v;
-            bool result = dictionary.TryGetValue(new Object(), out v);
+            bool result = dictionary.TryGetValue(string.Empty, out v);
 
             Assert.False(result);
             Assert.Null(v);
-            Assert.False(dictionary.ContainsKey(new Object()));
+            Assert.False(dictionary.ContainsKey(string.Empty));
         }
 
         /// <summary>
@@ -95,7 +93,7 @@ public void EqualityComparer()
             string k1 = String.Concat("ke", "y");
             object v1 = new Object();
 
-            var dictionary = new CopyOnWriteDictionary<string, object>();
+            var dictionary = new CopyOnWriteDictionary<object>();
             dictionary[k1] = v1;
 
             // Now look for a different but equatable key
@@ -115,7 +113,7 @@ public void EqualityComparer()
         [Fact]
         public void CloneVisibility()
         {
-            var dictionary = new CopyOnWriteDictionary<string, string>();
+            var dictionary = new CopyOnWriteDictionary<string>();
             dictionary["test"] = "1";
             Assert.Equal("1", dictionary["test"]);
 
@@ -131,7 +129,7 @@ public void CloneVisibility()
         [Fact]
         public void CloneComparer()
         {
-            var dictionary = new CopyOnWriteDictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+            var dictionary = new CopyOnWriteDictionary<string>(StringComparer.OrdinalIgnoreCase);
             dictionary["test"] = "1";
             Assert.Equal("1", dictionary["test"]);
 
@@ -146,24 +144,24 @@ public void CloneComparer()
         [Fact]
         public void OriginalWritesNotVisibleToClones()
         {
-            var dictionary = new CopyOnWriteDictionary<string, string>();
+            var dictionary = new CopyOnWriteDictionary<string>();
             dictionary["test"] = "1";
-            Assert.Equal("1", dictionary["test"]);
+            dictionary["test"].ShouldBe("1");
 
             var clone = dictionary.Clone();
             var clone2 = dictionary.Clone();
 
-            Assert.True(dictionary.HasSameBacking(clone));
-            Assert.True(dictionary.HasSameBacking(clone2));
+            dictionary.HasSameBacking(clone).ShouldBeTrue();
+            dictionary.HasSameBacking(clone2).ShouldBeTrue();
 
             dictionary["test"] = "2";
 
-            Assert.False(dictionary.HasSameBacking(clone));
-            Assert.False(dictionary.HasSameBacking(clone2));
-            Assert.True(clone.HasSameBacking(clone2));
+            dictionary.HasSameBacking(clone).ShouldBeFalse();
+            dictionary.HasSameBacking(clone2).ShouldBeFalse();
+            clone.HasSameBacking(clone2).ShouldBeTrue();
 
-            Assert.Equal("1", clone["test"]);
-            Assert.Equal("1", clone2["test"]);
+            clone["test"].ShouldBe("1");
+            clone2["test"].ShouldBe("1");
         }
 
         /// <summary>
@@ -172,7 +170,7 @@ public void OriginalWritesNotVisibleToClones()
         [Fact]
         public void CloneWritesNotVisibleToOriginal()
         {
-            var dictionary = new CopyOnWriteDictionary<string, string>();
+            var dictionary = new CopyOnWriteDictionary<string>();
             dictionary["test"] = "1";
             Assert.Equal("1", dictionary["test"]);
 
@@ -200,8 +198,8 @@ public void CloneWritesNotVisibleToOriginal()
         [Fact]
         public void SerializeDeserialize()
         {
-            CopyOnWriteDictionary<int, string> dictionary = new CopyOnWriteDictionary<int, string>();
-            dictionary.Add(1, "1");
+            CopyOnWriteDictionary<string> dictionary = new CopyOnWriteDictionary<string>();
+            dictionary.Add("Key1", "1");
 
             using (MemoryStream stream = new MemoryStream())
             {
@@ -210,13 +208,13 @@ public void SerializeDeserialize()
                 formatter.Serialize(stream, dictionary);
                 stream.Position = 0;
 
-                var dictionary2 = (CopyOnWriteDictionary<int, string>)formatter.Deserialize(stream);
+                var dictionary2 = (CopyOnWriteDictionary<string>)formatter.Deserialize(stream);
 
                 Assert.Equal(dictionary.Count, dictionary2.Count);
                 Assert.Equal(dictionary.Comparer, dictionary2.Comparer);
-                Assert.Equal("1", dictionary2[1]);
+                Assert.Equal("1", dictionary2["Key1"]);
 
-                dictionary2.Add(2, "2");
+                dictionary2.Add("key2", "2");
             }
         }
 
@@ -226,7 +224,7 @@ public void SerializeDeserialize()
         [Fact]
         public void SerializeDeserialize2()
         {
-            CopyOnWriteDictionary<string, string> dictionary = new CopyOnWriteDictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
+            CopyOnWriteDictionary<string> dictionary = new CopyOnWriteDictionary<string>(MSBuildNameIgnoreCaseComparer.Default);
 
             using (MemoryStream stream = new MemoryStream())
             {
@@ -235,10 +233,10 @@ public void SerializeDeserialize2()
                 formatter.Serialize(stream, dictionary);
                 stream.Position = 0;
 
-                CopyOnWriteDictionary<string, string> dictionary2 = (CopyOnWriteDictionary<string, string>)formatter.Deserialize(stream);
+                CopyOnWriteDictionary<string> deserialized = (CopyOnWriteDictionary<string>)formatter.Deserialize(stream);
 
-                Assert.Equal(dictionary.Count, dictionary2.Count);
-                Assert.IsType<MSBuildNameIgnoreCaseComparer>(dictionary2.Comparer);
+                deserialized.Count.ShouldBe(dictionary.Count);
+                deserialized.Comparer.ShouldBeOfType<MSBuildNameIgnoreCaseComparer>();
             }
         }
     }
diff --git a/src/Shared/UnitTests/EscapingUtilities_Tests.cs b/src/Shared/UnitTests/EscapingUtilities_Tests.cs
index cecdccab0d3..627de15dff6 100644
--- a/src/Shared/UnitTests/EscapingUtilities_Tests.cs
+++ b/src/Shared/UnitTests/EscapingUtilities_Tests.cs
@@ -46,9 +46,7 @@ public void Escape()
         [Fact]
         public void UnescapeEscape()
         {
-            string text;
-
-            text = "*";
+            string text = "*";
             Assert.Equal(text, EscapingUtilities.UnescapeAll(EscapingUtilities.Escape(text)));
 
             text = "?";
@@ -63,9 +61,7 @@ public void UnescapeEscape()
         [Fact]
         public void EscapeUnescape()
         {
-            string text;
-
-            text = "%2a";
+            string text = "%2a";
             Assert.Equal(text, EscapingUtilities.Escape(EscapingUtilities.UnescapeAll(text)));
 
             text = "%3f";
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index 293b4dbcec3..418a51b91db 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -2034,10 +2034,9 @@ private void GetMatchingDirectories(string[] candidates, string path, string pat
                             int nextSlash = normalizedCandidate.IndexOfAny(FileMatcher.directorySeparatorCharacters, path.Length + 1);
                             if (nextSlash != -1)
                             {
-                                string match;
-
+                                
                                 //UNC paths start with a \\ fragment. Match against \\ when path is empty (i.e., inside the current working directory)
-                                match = normalizedCandidate.StartsWith(@"\\") && string.IsNullOrEmpty(path)
+                                string match = normalizedCandidate.StartsWith(@"\\") && string.IsNullOrEmpty(path)
                                     ? @"\\"
                                     : normalizedCandidate.Substring(0, nextSlash);
 
@@ -2545,6 +2544,14 @@ public FileSystemAdapter(MockFileSystem mockFileSystem)
                 _mockFileSystem = mockFileSystem;
             }
 
+            public TextReader ReadFile(string path) => throw new NotImplementedException();
+
+            public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share) => throw new NotImplementedException();
+
+            public string ReadFileAllText(string path) => throw new NotImplementedException();
+
+            public byte[] ReadFileAllBytes(string path) => throw new NotImplementedException();
+
             public IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
             {
                 return FileSystems.Default.EnumerateFiles(path, searchPattern, searchOption);
@@ -2560,6 +2567,10 @@ public IEnumerable<string> EnumerateFileSystemEntries(string path, string search
                 return FileSystems.Default.EnumerateFileSystemEntries(path, searchPattern, searchOption);
             }
 
+            public FileAttributes GetAttributes(string path) => throw new NotImplementedException();
+
+            public DateTime GetLastWriteTimeUtc(string path) => throw new NotImplementedException();
+
             public bool DirectoryExists(string path)
             {
                 return _mockFileSystem.DirectoryExists(path);
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index 43e2aa4c725..636c41df025 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -2,14 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
-using System.Reflection;
-using System.Text;
 using System.Threading;
 using System.Linq;
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
diff --git a/src/Shared/UnitTests/ImmutableDictionary_Tests.cs b/src/Shared/UnitTests/ImmutableDictionary_Tests.cs
new file mode 100644
index 00000000000..e30a8cc75d1
--- /dev/null
+++ b/src/Shared/UnitTests/ImmutableDictionary_Tests.cs
@@ -0,0 +1,258 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+// We don't automatically run these tests against the BCL implementation of ImmutableDictionary as it would require dual-compiling
+// this file. When making changes to this test, though, it is recommended to run them manually by uncommenting the following line.
+// This helps ensure that the real thing has the same behavior that we expect in our implementation.
+//#define _TEST_BCL_IMMUTABLE_DICTIONARY
+
+extern alias MSBuildTaskHost;
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+
+using Shouldly;
+using Xunit;
+
+#if _TEST_BCL_IMMUTABLE_DICTIONARY
+using ImmutableDictionary = System.Collections.Immutable.ImmutableDictionary<string, string>;
+#else
+using ImmutableDictionary = MSBuildTaskHost::System.Collections.Immutable.ImmutableDictionary<string, string>;
+#endif
+
+namespace Microsoft.Build.UnitTests
+{
+    public class ImmutableDictionary_Tests
+    {
+        private readonly ImmutableDictionary _emptyDict = ImmutableDictionary.Empty;
+
+        [Fact]
+        public void SimplesBoolPropertiesReturnExpectedValues()
+        {
+            ((IDictionary)_emptyDict).IsFixedSize.ShouldBeTrue();
+            ((IDictionary)_emptyDict).IsReadOnly.ShouldBeTrue();
+            ((IDictionary)_emptyDict).IsSynchronized.ShouldBeTrue();
+        }
+
+        [Fact]
+        public void CountReturnsExpectedValue()
+        {
+            _emptyDict.Count.ShouldBe(0);
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            dict.Count.ShouldBe(1);
+            dict = dict.SetItem("Key2", "Value2");
+            dict.Count.ShouldBe(2);
+            dict = dict.Clear();
+            dict.Count.ShouldBe(0);
+        }
+
+        [Fact]
+        public void IndexerReturnsPreviouslySetItem()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            dict["Key1"].ShouldBe("Value1");
+            ((IDictionary)dict)["Key1"].ShouldBe("Value1");
+            ((IDictionary<string, string>)dict)["Key1"].ShouldBe("Value1");
+        }
+
+        [Fact]
+        public void IndexerThrowsForItemNotPreviouslySet()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            Should.Throw<KeyNotFoundException>(() => _ = dict["Key2"]);
+            Should.Throw<KeyNotFoundException>(() => _ = ((IDictionary)dict)["Key2"]);
+            Should.Throw<KeyNotFoundException>(() => _ = ((IDictionary<string, string>)dict)["Key2"]);
+        }
+
+        [Fact]
+        public void ContainsReturnsTrueForPeviouslySetItem()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            dict.Contains(new KeyValuePair<string, string>("Key1", "Value1")).ShouldBeTrue();
+            dict.ContainsKey("Key1").ShouldBeTrue();
+            ((IDictionary)dict).Contains("Key1").ShouldBeTrue();
+        }
+
+        [Fact]
+        public void ContainsReturnsFalseForItemNotPeviouslySet()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            dict.Contains(new KeyValuePair<string, string>("Key2", "Value2")).ShouldBeFalse();
+            dict.ContainsKey("Key2").ShouldBeFalse();
+            ((IDictionary)dict).Contains("Key2").ShouldBeFalse();
+        }
+
+        [Fact]
+        public void EnumeratorEnumeratesItems()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+
+            IEnumerator<KeyValuePair<string, string>> enumerator1 = dict.GetEnumerator();
+            int i = 0;
+            while (enumerator1.MoveNext())
+            {
+                i++;
+                enumerator1.Current.Key.ShouldBe("Key1");
+                enumerator1.Current.Value.ShouldBe("Value1");
+            }
+            i.ShouldBe(dict.Count);
+
+            IDictionaryEnumerator enumerator2 = ((IDictionary)dict).GetEnumerator();
+            i = 0;
+            while (enumerator2.MoveNext())
+            {
+                i++;
+                enumerator2.Key.ShouldBe("Key1");
+                enumerator2.Value.ShouldBe("Value1");
+            }
+            i.ShouldBe(dict.Count);
+
+            IEnumerator enumerator3 = ((IEnumerable)dict).GetEnumerator();
+            i = 0;
+            while (enumerator3.MoveNext())
+            {
+                i++;
+                KeyValuePair<string, string> entry = (KeyValuePair<string, string>)enumerator3.Current;
+                entry.Key.ShouldBe("Key1");
+                entry.Value.ShouldBe("Value1");
+            }
+            i.ShouldBe(dict.Count);
+        }
+
+        [Fact]
+        public void CopyToCopiesItemsToArray()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+
+            KeyValuePair<string, string>[] array1 = new KeyValuePair<string, string>[1];
+            ((ICollection<KeyValuePair<string, string>>)dict).CopyTo(array1, 0);
+            array1[0].Key.ShouldBe("Key1");
+            array1[0].Value.ShouldBe("Value1");
+
+            array1 = new KeyValuePair<string, string>[2];
+            ((ICollection<KeyValuePair<string, string>>)dict).CopyTo(array1, 1);
+            array1[1].Key.ShouldBe("Key1");
+            array1[1].Value.ShouldBe("Value1");
+
+            DictionaryEntry[] array2 = new DictionaryEntry[1];
+            ((ICollection)dict).CopyTo(array2, 0);
+            array2[0].Key.ShouldBe("Key1");
+            array2[0].Value.ShouldBe("Value1");
+
+            array2 = new DictionaryEntry[2];
+            ((ICollection)dict).CopyTo(array2, 1);
+            array2[1].Key.ShouldBe("Key1");
+            array2[1].Value.ShouldBe("Value1");
+        }
+
+        [Fact]
+        public void CopyToThrowsOnInvalidInput()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+
+            Should.Throw<ArgumentNullException>(() => ((ICollection<KeyValuePair<string, string>>)dict).CopyTo(null, 0));
+            Should.Throw<ArgumentNullException>(() => ((ICollection)dict).CopyTo(null, 0));
+
+            KeyValuePair<string, string>[] array1 = new KeyValuePair<string, string>[1];
+            DictionaryEntry[] array2 = new DictionaryEntry[1];
+            Should.Throw<ArgumentOutOfRangeException>(() => ((ICollection<KeyValuePair<string, string>>)dict).CopyTo(array1, -1));
+            Should.Throw<ArgumentOutOfRangeException>(() => ((ICollection)dict).CopyTo(array1, -1));
+
+            Should.Throw<ArgumentException>(() => ((ICollection<KeyValuePair<string, string>>)dict).CopyTo(array1, 1));
+            Should.Throw<ArgumentException>(() => ((ICollection)dict).CopyTo(array1, 1));
+        }
+
+        [Fact]
+        public void KeysReturnsKeys()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+
+            ICollection<string> keys1 = ((IDictionary<string, string>)dict).Keys;
+            keys1.ShouldBe(new string[] { "Key1" });
+
+            ICollection keys2 = ((IDictionary)dict).Keys;
+            keys2.ShouldBe(new string[] { "Key1" });
+        }
+
+        [Fact]
+        public void ValuesReturnsValues()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+
+            ICollection<string> values1 = ((IDictionary<string, string>)dict).Values;
+            values1.ShouldBe(new string[] { "Value1" });
+
+            ICollection values2 = ((IDictionary)dict).Values;
+            values2.ShouldBe(new string[] { "Value1" });
+        }
+
+        [Fact]
+        public void SetItemReturnsNewInstanceAfterAdding()
+        {
+            ImmutableDictionary dict = _emptyDict.SetItem("Key1", "Value1");
+            dict.ShouldNotBeSameAs(_emptyDict);
+        }
+
+        [Fact]
+        public void SetItemReturnsNewInstanceAfterUpdating()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.SetItem("Key1", "Value2");
+            dict2.ShouldNotBeSameAs(dict1);
+        }
+
+        [Fact]
+        public void SetItemReturnsSameInstanceWhenItemAlreadyExists()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.SetItem("Key1", "Value1");
+            dict2.ShouldBeSameAs(dict1);
+        }
+
+        [Fact]
+        public void RemoveReturnsNewInstanceAfterDeleting()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.Remove("Key1");
+            dict2.ShouldNotBeSameAs(dict1);
+        }
+
+        [Fact]
+        public void RemoveReturnsSameInstanceWhenItemDoesNotExist()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.Remove("Key2");
+            dict2.ShouldBeSameAs(dict1);
+        }
+
+        [Fact]
+        public void ClearReturnsNewInstance()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.Clear();
+            dict2.ShouldNotBeSameAs(dict1);
+        }
+
+        [Fact]
+        public void WithComparersCreatesNewInstanceWithSpecifiedKeyComparer()
+        {
+            ImmutableDictionary dict1 = _emptyDict.SetItem("Key1", "Value1");
+            ImmutableDictionary dict2 = dict1.WithComparers(StringComparer.OrdinalIgnoreCase);
+            dict2["KEY1"].ShouldBe("Value1");
+        }
+
+        [Fact]
+        public void AddRangeAddsAllItems()
+        {
+            ImmutableDictionary dict = _emptyDict.AddRange(new KeyValuePair<string, string>[]
+            {
+                new KeyValuePair<string, string>("Key1", "Value1"),
+                new KeyValuePair<string, string>("Key2", "Value2")
+            });
+            dict.Count.ShouldBe(2);
+            dict["Key1"].ShouldBe("Value1");
+            dict["Key2"].ShouldBe("Value2");
+        }
+    }
+}
diff --git a/src/Shared/UnitTests/MockEngine.cs b/src/Shared/UnitTests/MockEngine.cs
index 466e3d639ce..431e8948cb0 100644
--- a/src/Shared/UnitTests/MockEngine.cs
+++ b/src/Shared/UnitTests/MockEngine.cs
@@ -12,7 +12,6 @@
 using Microsoft.Build.Logging;
 
 using Shouldly;
-using Xunit;
 using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests
@@ -40,6 +39,7 @@ internal sealed class MockEngine : IBuildEngine7
         private readonly bool _logToConsole;
         private readonly ConcurrentDictionary<object, object> _objectCache = new ConcurrentDictionary<object, object>();
         private readonly ConcurrentQueue<BuildErrorEventArgs> _errorEvents = new ConcurrentQueue<BuildErrorEventArgs>();
+        private readonly ConcurrentQueue<BuildWarningEventArgs> _warningEvents = new ConcurrentQueue<BuildWarningEventArgs>();
 
         internal MockEngine() : this(false)
         {
@@ -51,9 +51,10 @@ internal MockEngine() : this(false)
 
         internal int Errors { get; set; }
 
-        public bool AllowFailureWithoutError { get; set; } = true;
+        public bool AllowFailureWithoutError { get; set; } = false;
 
         public BuildErrorEventArgs[] ErrorEvents => _errorEvents.ToArray();
+        public BuildWarningEventArgs[] WarningEvents => _warningEvents.ToArray();
 
         public Dictionary<string, string> GlobalProperties { get; set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
@@ -104,6 +105,7 @@ public void LogWarningEvent(BuildWarningEventArgs eventArgs)
         {
             lock (_lockObj)
             {
+                _warningEvents.Enqueue(eventArgs);
                 string message = string.Empty;
 
                 if (!string.IsNullOrEmpty(eventArgs.File))
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 771ece294c2..6c62d8044f4 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -3,16 +3,19 @@
 
 using System;
 using System.Collections;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
 using System.Runtime.InteropServices;
 using System.Text;
+using System.Threading;
 using System.Xml;
 
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
+using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
 using Microsoft.Build.Logging;
@@ -1042,11 +1045,11 @@ internal static string[] GetTempFiles(int number, DateTime lastWriteTime)
         /// <summary>
         /// Get items of item type "i" with using the item xml fragment passed in
         /// </summary>
-        internal static IList<ProjectItem> GetItemsFromFragment(string fragment, bool allItems = false)
+        internal static IList<ProjectItem> GetItemsFromFragment(string fragment, bool allItems = false, bool ignoreCondition = false)
         {
             string content = FormatProjectContentsWithItemGroupFragment(fragment);
 
-            IList<ProjectItem> items = GetItems(content, allItems);
+            IList<ProjectItem> items = GetItems(content, allItems, ignoreCondition);
             return items;
         }
 
@@ -1058,11 +1061,14 @@ internal static IList<ProjectItem> GetItemsFromFragment(string fragment, bool al
         /// <summary>
         /// Get the items of type "i" in the project provided
         /// </summary>
-        internal static IList<ProjectItem> GetItems(string content, bool allItems = false)
+        internal static IList<ProjectItem> GetItems(string content, bool allItems = false, bool ignoreCondition = false)
         {
             var projectXml = ProjectRootElement.Create(XmlReader.Create(new StringReader(CleanupFileContents(content))));
             Project project = new Project(projectXml);
-            IList<ProjectItem> item = Helpers.MakeList(allItems ? project.Items : project.GetItems("i"));
+            IList<ProjectItem> item = Helpers.MakeList(
+                ignoreCondition ?
+                (allItems ? project.ItemsIgnoringCondition : project.GetItemsIgnoringCondition("i")) :
+                (allItems ? project.Items : project.GetItems("i")));
 
             return item;
         }
@@ -1557,7 +1563,7 @@ internal static TransientTestFile CreateProjectFile(
             
             foreach (var defaultTarget in (defaultTargets ?? string.Empty).Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
             {
-                sb.Append($"<Target Name='{defaultTarget}'/>");
+                sb.Append("<Target Name='").Append(defaultTarget).Append("'/>");
             }
 
             sb.Append(extraContent ?? string.Empty);
@@ -1936,5 +1942,133 @@ public void Dispose()
                 _buildManager.Dispose();
             }
         }
+
+        internal class LoggingFileSystem : MSBuildFileSystemBase
+        {
+            private readonly IFileSystem _wrappingFileSystem;
+            private int _fileSystemCalls;
+
+            public int FileSystemCalls => _fileSystemCalls;
+
+            public ConcurrentDictionary<string, int> ExistenceChecks { get; } = new ConcurrentDictionary<string, int>();
+
+            public LoggingFileSystem(IFileSystem wrappingFileSystem = null)
+            {
+                _wrappingFileSystem = wrappingFileSystem ?? FileSystems.Default;
+            }
+
+            public override TextReader ReadFile(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.ReadFile(path);
+            }
+
+            public override Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.GetFileStream(path, mode, access, share);
+            }
+
+            public override string ReadFileAllText(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.ReadFileAllText(path);
+            }
+
+            public override byte[] ReadFileAllBytes(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.ReadFileAllBytes(path);
+            }
+
+            public override IEnumerable<string> EnumerateFiles(
+                string path,
+                string searchPattern = "*",
+                SearchOption searchOption = SearchOption.TopDirectoryOnly
+            )
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.EnumerateFiles(path, searchPattern, searchOption);
+            }
+
+            public override IEnumerable<string> EnumerateDirectories(
+                string path,
+                string searchPattern = "*",
+                SearchOption searchOption = SearchOption.TopDirectoryOnly
+            )
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.EnumerateDirectories(path, searchPattern, searchOption);
+            }
+
+            public override IEnumerable<string> EnumerateFileSystemEntries(
+                string path,
+                string searchPattern = "*",
+                SearchOption searchOption = SearchOption.TopDirectoryOnly
+            )
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+            }
+
+            public override FileAttributes GetAttributes(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.GetAttributes(path);
+            }
+
+            public override DateTime GetLastWriteTimeUtc(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+
+                return _wrappingFileSystem.GetLastWriteTimeUtc(path);
+            }
+
+            public override bool DirectoryExists(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+                IncrementExistenceChecks(path);
+
+                return _wrappingFileSystem.DirectoryExists(path);
+            }
+
+            public override bool FileExists(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+                IncrementExistenceChecks(path);
+
+                return _wrappingFileSystem.FileExists(path);
+            }
+
+            private int _directoryEntryExistsCalls;
+            public int DirectoryEntryExistsCalls => _directoryEntryExistsCalls;
+
+            public override bool FileOrDirectoryExists(string path)
+            {
+                IncrementCalls(ref _fileSystemCalls);
+                IncrementCalls(ref _directoryEntryExistsCalls);
+                IncrementExistenceChecks(path);
+
+                return _wrappingFileSystem.DirectoryEntryExists(path);
+            }
+
+            private void IncrementCalls(ref int incremented)
+            {
+                Interlocked.Increment(ref incremented);
+            }
+
+            private void IncrementExistenceChecks(string path)
+            {
+                ExistenceChecks.AddOrUpdate(path, p => 1, (p, c) => c + 1);
+            }
+        }
     }
 }
diff --git a/src/Shared/UnitTests/ResourceUtilities_Tests.cs b/src/Shared/UnitTests/ResourceUtilities_Tests.cs
index 8fbc9589e8c..7731a95e67d 100644
--- a/src/Shared/UnitTests/ResourceUtilities_Tests.cs
+++ b/src/Shared/UnitTests/ResourceUtilities_Tests.cs
@@ -1,9 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
 
@@ -23,61 +20,51 @@ public void ExtractMSBuildCode()
             Assert.Equal("This is a message.", messageOnly);
 
             // no whitespace between colon and message is ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "MSB7007:This is a message.", out code);
             Assert.Equal("MSB7007", code);
             Assert.Equal("This is a message.", messageOnly);
 
             // whitespace before code and after colon is ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "  MSB7007:   This is a message.", out code);
             Assert.Equal("MSB7007", code);
             Assert.Equal("This is a message.", messageOnly);
 
             // whitespace between code and colon is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "MSB7007 : This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("MSB7007 : This is a message.", messageOnly);
 
             // whitespace in code is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "MSB 7007: This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("MSB 7007: This is a message.", messageOnly);
 
             // code with less than 4 digits is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "MSB007: This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("MSB007: This is a message.", messageOnly);
 
             // code without digits is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "MSB: This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("MSB: This is a message.", messageOnly);
 
             // code without MSB prefix is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "1001: This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("1001: This is a message.", messageOnly);
 
             // digits before MSB prefix is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "7001MSB: This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("7001MSB: This is a message.", messageOnly);
 
             // mixing letters and digits is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "MSB564B: This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("MSB564B: This is a message.", messageOnly);
 
             // lowercase code is not ok
-            code = null;
             messageOnly = ResourceUtilities.ExtractMessageCode(true /* msbuild code only */, "msb1001: This is a message.", out code);
             Assert.Null(code);
             Assert.Equal("msb1001: This is a message.", messageOnly);
diff --git a/src/Shared/UnitTests/StreamHelpers.cs b/src/Shared/UnitTests/StreamHelpers.cs
index 9bd808c82ee..af9c876d4b6 100644
--- a/src/Shared/UnitTests/StreamHelpers.cs
+++ b/src/Shared/UnitTests/StreamHelpers.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.IO;
-using Xunit;
 
 namespace Microsoft.Build.UnitTests
 {
diff --git a/src/Shared/UnitTests/TestAssemblyInfo.cs b/src/Shared/UnitTests/TestAssemblyInfo.cs
index cd0ab81f3f6..a325fb4cac4 100644
--- a/src/Shared/UnitTests/TestAssemblyInfo.cs
+++ b/src/Shared/UnitTests/TestAssemblyInfo.cs
@@ -1,6 +1,5 @@
 ﻿
 using System;
-using System.Diagnostics;
 using System.IO;
 using System.Linq;
 using System.Runtime.InteropServices;
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index ff87775797e..8f05e3b94b5 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -17,6 +17,7 @@
 
 using TempPaths = System.Collections.Generic.Dictionary<string, string>;
 using CommonWriterType = System.Action<string, string, System.Collections.Generic.IEnumerable<string>>;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -87,9 +88,19 @@ private void Cleanup()
                 // Assert invariants
                 foreach (var item in _invariants)
                     item.AssertInvariant(Output);
+
+                // Reset change waves
+                SetChangeWave(string.Empty);
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
             }
         }
 
+        public void SetChangeWave(string wave)
+        {
+            ChangeWaves.ResetStateForTests();
+            SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", wave);
+        }
+
         /// <summary>
         ///     Evaluate the test with the given invariant.
         /// </summary>
diff --git a/src/Shared/UnitTests/TestProgram.cs b/src/Shared/UnitTests/TestProgram.cs
index 92c0a75f2af..8c7f23da42e 100644
--- a/src/Shared/UnitTests/TestProgram.cs
+++ b/src/Shared/UnitTests/TestProgram.cs
@@ -1,7 +1,5 @@
 ﻿using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 
 
 class Program
diff --git a/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs b/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs
index 26cf742803d..f8acd297b4e 100644
--- a/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs
+++ b/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 
-using System;
 using System.IO;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.Shared;
diff --git a/src/Shared/UnitTests/TypeLoader_Tests.cs b/src/Shared/UnitTests/TypeLoader_Tests.cs
index 1e123fc26f0..64feb85113e 100644
--- a/src/Shared/UnitTests/TypeLoader_Tests.cs
+++ b/src/Shared/UnitTests/TypeLoader_Tests.cs
@@ -3,13 +3,10 @@
 
 
 using System;
-using System.Collections;
 using System.IO;
 using Microsoft.Build.Shared;
 using System.Reflection;
 using Xunit;
-using Microsoft.Build.Tasks;
-using Microsoft.Build.Framework;
 using Microsoft.Build.UnitTests.Shared;
 
 namespace Microsoft.Build.UnitTests
diff --git a/src/Shared/UnitTests/XmakeAttributes_Tests.cs b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
index 986b4c288a4..f3c58b19237 100644
--- a/src/Shared/UnitTests/XmakeAttributes_Tests.cs
+++ b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
@@ -1,8 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
 using Microsoft.Build.Shared;
 using Xunit;
 
@@ -60,8 +58,7 @@ public void TestRuntimeValuesMatch()
         [Fact]
         public void TestMergeRuntimeValues()
         {
-            string mergedRuntime = null;
-
+            string mergedRuntime;
             Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.currentRuntime, out mergedRuntime));
             Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr4, mergedRuntime);
 
@@ -99,11 +96,10 @@ public void TestArchitectureValuesMatch()
         [Fact]
         public void TestMergeArchitectureValues()
         {
-            string mergedArchitecture = null;
-
             string currentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x64 : XMakeAttributes.MSBuildArchitectureValues.x86;
             string notCurrentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
 
+            string mergedArchitecture;
             Assert.True(XMakeAttributes.TryMergeArchitectureValues(XMakeAttributes.MSBuildArchitectureValues.any, XMakeAttributes.MSBuildArchitectureValues.currentArchitecture, out mergedArchitecture));
             Assert.Equal(currentArchitecture, mergedArchitecture);
 
diff --git a/src/Shared/VersionUtilities.cs b/src/Shared/VersionUtilities.cs
index 565ceadeb34..ab4a2a2ba5c 100644
--- a/src/Shared/VersionUtilities.cs
+++ b/src/Shared/VersionUtilities.cs
@@ -2,9 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Win32;
 using System.Collections;
-using System.Globalization;
 using System.Collections.Generic;
 
 namespace Microsoft.Build.Shared
@@ -67,8 +65,6 @@ internal static SortedDictionary<Version, List<string>> GatherVersionStrings(Ver
         /// <param name="throwException">Should we use Parse to TryParse (parse means we throw an exception, tryparse means we will not).</param>
         internal static Version ConvertToVersion(string version, bool throwException)
         {
-            Version result = null;
-
             if (version.Length > 0 && (version[0] == 'v' || version[0] == 'V'))
             {
                 version = version.Substring(1);
@@ -82,6 +78,7 @@ internal static Version ConvertToVersion(string version, bool throwException)
                 version += ".0";
             }
 
+            Version result;
             if (throwException)
             {
                 result = Version.Parse(version);
diff --git a/src/Shared/VisualStudioConstants.cs b/src/Shared/VisualStudioConstants.cs
index 441c1431a0f..1df4e15a0e9 100644
--- a/src/Shared/VisualStudioConstants.cs
+++ b/src/Shared/VisualStudioConstants.cs
@@ -1,8 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-
 namespace Microsoft.Build.Shared
 {
     /// <summary>
diff --git a/src/Shared/VisualStudioLocationHelper.cs b/src/Shared/VisualStudioLocationHelper.cs
index b3f5bcb2487..54d57493b1f 100644
--- a/src/Shared/VisualStudioLocationHelper.cs
+++ b/src/Shared/VisualStudioLocationHelper.cs
@@ -1,7 +1,5 @@
 ﻿using System;
 using System.Collections.Generic;
-using System.IO;
-using System.Linq;
 using System.Runtime.InteropServices;
 #if FEATURE_VISUALSTUDIOSETUP
 using Microsoft.VisualStudio.Setup.Configuration;
diff --git a/src/Shared/XmlUtilities.cs b/src/Shared/XmlUtilities.cs
index 4670c3805ae..2695d35d4b0 100644
--- a/src/Shared/XmlUtilities.cs
+++ b/src/Shared/XmlUtilities.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Xml;
-using System.Text.RegularExpressions;
 using Microsoft.Build.Construction;
 
 namespace Microsoft.Build.Shared
diff --git a/src/Tasks.UnitTests/Al_Tests.cs b/src/Tasks.UnitTests/Al_Tests.cs
index c09615294a1..0f16023de2c 100644
--- a/src/Tasks.UnitTests/Al_Tests.cs
+++ b/src/Tasks.UnitTests/Al_Tests.cs
@@ -4,8 +4,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
-using System.Text.RegularExpressions;
-using System.Globalization;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
diff --git a/src/Tasks.UnitTests/AppConfig_Tests.cs b/src/Tasks.UnitTests/AppConfig_Tests.cs
index 84bc5f552d4..50c9ebe80aa 100644
--- a/src/Tasks.UnitTests/AppConfig_Tests.cs
+++ b/src/Tasks.UnitTests/AppConfig_Tests.cs
@@ -4,9 +4,7 @@
 using System;
 using System.Text;
 using System.Xml;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
diff --git a/src/Tasks.UnitTests/AspNetCompiler_Tests.cs b/src/Tasks.UnitTests/AspNetCompiler_Tests.cs
index 47c4e148f13..b5d321f21fe 100644
--- a/src/Tasks.UnitTests/AspNetCompiler_Tests.cs
+++ b/src/Tasks.UnitTests/AspNetCompiler_Tests.cs
@@ -1,15 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Reflection;
-using System.Collections;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Evaluation;
-using System.Text.RegularExpressions;
 using System.Globalization;
 using Xunit;
 
diff --git a/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs b/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs
index 4cf2b992ef4..3ed117dcd2d 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/AssemblyFoldersFromConfig_Tests.cs
@@ -1,12 +1,6 @@
-﻿using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
+﻿using System.IO;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Tasks.AssemblyFoldersFromConfig;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index ffa93bd923d..2d0f453a127 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -14,6 +14,7 @@
 using SystemProcessorArchitecture = System.Reflection.ProcessorArchitecture;
 using Xunit.Abstractions;
 using Shouldly;
+using System.Text;
 
 namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests
 {
@@ -3679,7 +3680,10 @@ public void ConflictGeneratesMessageReferencingAssemblyName()
             Assert.Equal(1, e.Warnings); // @"Expected one warning."
 
             // Check that we have a message identifying conflicts with "D"
-            e.AssertLogContainsMessageFromResource(AssemblyResources.GetString, "ResolveAssemblyReference.FoundConflicts", "D");
+            string warningMessage = e.WarningEvents[0].Message;
+            warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.FoundConflicts", "D", string.Empty));
+            warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ConflictFound", "D, Version=1.0.0.0, CulTUre=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa", "D, Version=2.0.0.0, Culture=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa"));
+            warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.FourSpaceIndent", ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ReferenceDependsOn", "D, Version=1.0.0.0, CulTUre=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa", Path.Combine(s_myLibraries_V1Path, "D.dll"))));
         }
 
         /// <summary>
@@ -3721,8 +3725,15 @@ public void ConflictGeneratesMessageReferencingEachConflictingAssemblyName()
             Assert.Equal(2, e.Warnings); // @"Expected two warnings."
 
             // Check that we have both the expected messages
-            e.AssertLogContainsMessageFromResource(AssemblyResources.GetString, "ResolveAssemblyReference.FoundConflicts", "D");
-            e.AssertLogContainsMessageFromResource(AssemblyResources.GetString, "ResolveAssemblyReference.FoundConflicts", "G");
+            string warningMessage = e.WarningEvents[0].Message;
+            warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.FoundConflicts", "D", string.Empty));
+            warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ConflictFound", "D, Version=1.0.0.0, CulTUre=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa", "D, Version=2.0.0.0, Culture=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa"));
+            warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.FourSpaceIndent", ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ReferenceDependsOn", "D, Version=1.0.0.0, CulTUre=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa", Path.Combine(s_myLibraries_V1Path, "D.dll"))));
+
+            warningMessage = e.WarningEvents[1].Message;
+            warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.FoundConflicts", "G", string.Empty));
+            warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ConflictFound", "G, Version=1.0.0.0, CulTUre=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa", "G, Version=2.0.0.0, Culture=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa"));
+            warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.FourSpaceIndent", ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ReferenceDependsOn", "G, Version=1.0.0.0, CulTUre=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa", Path.Combine(s_myLibraries_V1Path, "G.dll"))));
         }
 
         /// <summary>
@@ -7178,14 +7189,10 @@ private static void GenerateNewReferences(out Reference enginePrimaryReference,
         public void IgnoreDefaultInstalledSubsetTables()
         {
             string redistListPath = CreateGenericRedistList();
-            string subsetListClientPath = string.Empty;
-            string explicitSubsetListPath = string.Empty;
-
             try
             {
-                subsetListClientPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("v3.5\\SubsetList\\Client.xml", _engineOnlySubset);
-                explicitSubsetListPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("v3.5\\SubsetList\\ExplicitList.xml", _xmlOnlySubset);
-
+                string subsetListClientPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("v3.5\\SubsetList\\Client.xml", _engineOnlySubset);
+                string explicitSubsetListPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("v3.5\\SubsetList\\ExplicitList.xml", _xmlOnlySubset);
                 ResolveAssemblyReference t = new ResolveAssemblyReference();
                 t.BuildEngine = new MockEngine(_output);
                 t.Assemblies = new ITaskItem[] { new TaskItem("Microsoft.Build.Engine"), new TaskItem("System.Xml") };
@@ -8021,8 +8028,7 @@ public void ReverseAssemblyNameExtensionComparer()
         [Trait("Category", "mono-osx-failing")]
         public void TargetFrameworkFiltering()
         {
-            int resultSet = 0;
-            resultSet = RunTargetFrameworkFilteringTest("3.0");
+            int resultSet = RunTargetFrameworkFilteringTest("3.0");
             Assert.Equal(0x3, resultSet); // "Expected assemblies A & B to be found."
 
             resultSet = RunTargetFrameworkFilteringTest("3.5");
@@ -8321,9 +8327,6 @@ public void VerifyAssemblyInRedistListDiffSimpleName()
         [Fact]
         public void Verifyp2pAndProfile()
         {
-            // Create a generic redist list with system.xml and microsoft.build.engine.
-            string profileRedistList = String.Empty;
-            string fullRedistList = String.Empty;
             string fullFrameworkDirectory = Path.Combine(Path.GetTempPath(), "Verifyp2pAndProfile");
             string targetFrameworkDirectory = Path.Combine(fullFrameworkDirectory, "Profiles", "Client");
 
@@ -8334,6 +8337,9 @@ public void Verifyp2pAndProfile()
 
             try
             {
+                // Create a generic redist list with system.xml and microsoft.build.engine.
+                string profileRedistList;
+                string fullRedistList;
                 GenerateRedistAndProfileXmlLocations(fullRedistListContents, _engineOnlySubset, out profileRedistList, out fullRedistList, fullFrameworkDirectory, targetFrameworkDirectory);
 
                 ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -8369,9 +8375,6 @@ public void Verifyp2pAndProfile()
         [Fact]
         public void Verifyp2pAndProfile2()
         {
-            // Create a generic redist list with system.xml and microsoft.build.engine.
-            string profileRedistList = String.Empty;
-            string fullRedistList = String.Empty;
             string fullFrameworkDirectory = Path.Combine(Path.GetTempPath(), "Verifyp2pAndProfile");
             string targetFrameworkDirectory = Path.Combine(fullFrameworkDirectory, "Profiles", "Client");
 
@@ -8382,6 +8385,9 @@ public void Verifyp2pAndProfile2()
 
             try
             {
+                // Create a generic redist list with system.xml and microsoft.build.engine.
+                string profileRedistList;
+                string fullRedistList;
                 GenerateRedistAndProfileXmlLocations(fullRedistListContents, _engineOnlySubset, out profileRedistList, out fullRedistList, fullFrameworkDirectory, targetFrameworkDirectory);
 
                 ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -8419,13 +8425,13 @@ public void Verifyp2pAndProfile2()
         [Fact]
         public void VerifyClientProfileRedistListAndProfileList()
         {
-            // Create a generic redist list with system.xml and microsoft.build.engine.
-            string profileRedistList = String.Empty;
-            string fullRedistList = String.Empty;
             string fullFrameworkDirectory = Path.Combine(Path.GetTempPath(), "VerifyClientProfileRedistListAndProfileList");
             string targetFrameworkDirectory = Path.Combine(fullFrameworkDirectory, "Profiles", "Client");
             try
             {
+                // Create a generic redist list with system.xml and microsoft.build.engine.
+                string profileRedistList;
+                string fullRedistList;
                 GenerateRedistAndProfileXmlLocations(_fullRedistListContents, _engineOnlySubset, out profileRedistList, out fullRedistList, fullFrameworkDirectory, targetFrameworkDirectory);
 
                 ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -8466,13 +8472,13 @@ public void VerifyClientProfileRedistListAndProfileList()
         [Fact]
         public void VerifyClientProfileRedistListAndProfileList2()
         {
-            // Create a generic redist list with system.xml and microsoft.build.engine.
-            string profileRedistList = String.Empty;
-            string fullRedistList = String.Empty;
             string fullFrameworkDirectory = Path.Combine(Path.GetTempPath(), "VerifyClientProfileRedistListAndProfileList2");
             string targetFrameworkDirectory = Path.Combine(fullFrameworkDirectory, "Profiles", "Client");
             try
             {
+                // Create a generic redist list with system.xml and microsoft.build.engine.
+                string profileRedistList;
+                string fullRedistList;
                 GenerateRedistAndProfileXmlLocations(_fullRedistListContents, _engineOnlySubset, out profileRedistList, out fullRedistList, fullFrameworkDirectory, targetFrameworkDirectory);
 
                 ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -8514,9 +8520,6 @@ public void VerifyClientProfileRedistListAndProfileList2()
         [Fact]
         public void VerifyAssemblyInGacButNotInProfileIsNotResolved()
         {
-            // Create a generic redist list with system.xml and microsoft.build.engine.
-            string profileRedistList = String.Empty;
-            string fullRedistList = String.Empty;
             string fullFrameworkDirectory = Path.Combine(Path.GetTempPath(), "VerifyAssemblyInGacButNotInProfileIsNotResolved");
             string targetFrameworkDirectory = Path.Combine(fullFrameworkDirectory, "Profiles", "Client");
             useFrameworkFileExists = true;
@@ -8527,6 +8530,9 @@ public void VerifyAssemblyInGacButNotInProfileIsNotResolved()
 
             try
             {
+                // Create a generic redist list with system.xml and microsoft.build.engine.
+                string profileRedistList;
+                string fullRedistList;
                 GenerateRedistAndProfileXmlLocations(fullRedistListContents, _engineOnlySubset, out profileRedistList, out fullRedistList, fullFrameworkDirectory, targetFrameworkDirectory);
 
                 ResolveAssemblyReference t = new ResolveAssemblyReference();
@@ -8568,9 +8574,6 @@ public void VerifyAssemblyInGacButNotInProfileIsNotResolved()
         [Fact]
         public void VerifyProfileErrorsAreLogged()
         {
-            // Create a generic redist list with system.xml and microsoft.build.engine.
-            string profileRedistList = String.Empty;
-            string fullRedistList = String.Empty;
             string fullFrameworkDirectory = Path.Combine(Path.GetTempPath(), "VerifyProfileErrorsAreLogged");
             string targetFrameworkDirectory = Path.Combine(fullFrameworkDirectory, "Profiles", "Client");
             try
@@ -8581,6 +8584,9 @@ public void VerifyProfileErrorsAreLogged()
                         "File AssemblyName='Microsoft.Build.Engine' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' >" +
                    "";
 
+                // Create a generic redist list with system.xml and microsoft.build.engine.
+                string profileRedistList;
+                string fullRedistList;
                 GenerateRedistAndProfileXmlLocations(fullRedistListContentsErrors, _engineOnlySubset, out profileRedistList, out fullRedistList, fullFrameworkDirectory, targetFrameworkDirectory);
 
                 ResolveAssemblyReference t = new ResolveAssemblyReference();
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
index 1f35cf0117a..eef70e698bf 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
@@ -1,6 +1,5 @@
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests.VersioningAndUnification.AutoUnify;
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index c2b855a00e7..373805aa30f 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -3,7 +3,6 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.IO;
-using System.Runtime.Versioning;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
@@ -14,7 +13,6 @@
 using SystemProcessorArchitecture = System.Reflection.ProcessorArchitecture;
 using Xunit;
 using Xunit.Abstractions;
-using Shouldly;
 
 namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests
 {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs b/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
index 97a73298a40..b5653161757 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
@@ -1,10 +1,13 @@
 using System;
 using System.Collections.Generic;
+using System.IO;
 using System.Reflection;
+using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
+using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
 
@@ -196,7 +199,12 @@ public void ConflictWithBackVersionPrimary()
             bool result = Execute(t);
 
             Assert.Equal(1, e.Warnings); // @"Expected one warning."
-            e.AssertLogContainsMessageFromResource(AssemblyResources.GetString, "ResolveAssemblyReference.FoundConflicts", "D");
+
+            // Check that we have a message identifying conflicts with "D"
+            string warningMessage = e.WarningEvents[0].Message;
+            warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.FoundConflicts", "D", string.Empty));
+            warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ConflictFound", "D, Version=1.0.0.0, CulTUre=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa", "D, Version=2.0.0.0, Culture=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa"));
+            warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.FourSpaceIndent", ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ReferenceDependsOn", "D, Version=1.0.0.0, CulTUre=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa", Path.Combine(s_myLibraries_V1Path, "D.dll"))));
 
             Assert.Empty(t.SuggestedRedirects);
             Assert.Equal(3, t.ResolvedFiles.Length);
@@ -236,7 +244,12 @@ public void ConflictWithBackVersionPrimaryWithAutoUnify()
             bool result = Execute(t);
 
             Assert.Equal(1, e.Warnings); // @"Expected one warning."
-            e.AssertLogContainsMessageFromResource(AssemblyResources.GetString, "ResolveAssemblyReference.FoundConflicts", "D");
+
+            // Check that we have a message identifying conflicts with "D"
+            string warningMessage = e.WarningEvents[0].Message;
+            warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.FoundConflicts", "D", string.Empty));
+            warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ConflictFound", "D, Version=1.0.0.0, CulTUre=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa", "D, Version=2.0.0.0, Culture=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa"));
+            warningMessage.ShouldContain(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.FourSpaceIndent", ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ReferenceDependsOn", "D, Version=1.0.0.0, CulTUre=neutral, PublicKeyToken=aaaaaaaaaaaaaaaa", Path.Combine(s_myLibraries_V1Path, "D.dll"))));
 
             Assert.Empty(t.SuggestedRedirects);
             Assert.Equal(3, t.ResolvedFiles.Length);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs
index b90925b6d9a..411b8388b54 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkHigherThanRedist.cs
@@ -1,4 +1,3 @@
-using System;
 using System.Collections.Generic;
 using System.IO;
 using Microsoft.Build.Framework;
diff --git a/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs b/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
index 41ba25b30b3..d82ce671a45 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/WinMDTests.cs
@@ -700,7 +700,7 @@ private void VerifyImplementationArchitecture(string winmdName, string targetPro
             Assert.Equal(@"WindowsRuntime 1.0", t.ResolvedFiles[0].GetMetadata(ItemMetadataNames.imageRuntime));
             Assert.True(bool.Parse(t.ResolvedFiles[0].GetMetadata(ItemMetadataNames.winMDFile)));
 
-            string fullMessage = null;
+            string fullMessage;
             if (implementationFileArch.Equals("Unknown"))
             {
                 fullMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ResolveAssemblyReference.UnknownProcessorArchitecture", @"C:\WinMDArchVerification\" + winmdName + ".dll", @"C:\WinMDArchVerification\" + winmdName + ".winmd", NativeMethods.IMAGE_FILE_MACHINE_R4000.ToString("X", CultureInfo.InvariantCulture));
diff --git a/src/Tasks.UnitTests/AssignCulture_Tests.cs b/src/Tasks.UnitTests/AssignCulture_Tests.cs
index 7cb8da21223..3ea98d3f3c1 100644
--- a/src/Tasks.UnitTests/AssignCulture_Tests.cs
+++ b/src/Tasks.UnitTests/AssignCulture_Tests.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Reflection;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
index 421485d904f..84c9ae915dc 100644
--- a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
+++ b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.IO;
-using System.Reflection;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs b/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs
index c1de8787f55..725b9e526e2 100644
--- a/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs
+++ b/src/Tasks.UnitTests/AssignProjectConfiguration_Tests.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections;
-using System.Text;
 using System.Xml;
 
 using Microsoft.Build.Framework;
@@ -292,23 +291,20 @@ private void TestUnresolvedReferencesHelper(ArrayList projectRefs, Hashtable pre
         [Fact]
         public void TestUnresolvedReferences()
         {
-            Hashtable unresolvedProjects = null;
-            Hashtable resolvedProjects = null;
-            Hashtable projectConfigurations = null;
-            ArrayList projectRefs = null;
-
-            projectRefs = new ArrayList();
+            ArrayList projectRefs = new ArrayList();
             projectRefs.Add(ResolveNonMSBuildProjectOutput_Tests.CreateReferenceItem("MCDep1.vcproj", "{2F6BBCC3-7111-4116-A68B-000000000000}",
                 "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}", "MCDep1"));
             projectRefs.Add(ResolveNonMSBuildProjectOutput_Tests.CreateReferenceItem("MCDep2.vcproj", "{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}",
                 "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}", "MCDep2"));
 
             // 1. multiple projects, none resolvable
-            projectConfigurations = new Hashtable();
+            Hashtable projectConfigurations = new Hashtable();
             projectConfigurations.Add("{11111111-1111-1111-1111-111111111111}", @"Config1|Win32");
             projectConfigurations.Add("{11111111-1111-1111-1111-111111111112}", @"Config2|AnyCPU");
             projectConfigurations.Add("{11111111-1111-1111-1111-111111111113}", @"Config3|AnyCPU");
 
+            Hashtable unresolvedProjects;
+            Hashtable resolvedProjects;
             TestUnresolvedReferencesHelper(projectRefs, projectConfigurations, out unresolvedProjects, out resolvedProjects);
 
             Assert.Empty(resolvedProjects); // "No resolved refs expected for case 1"
diff --git a/src/Tasks.UnitTests/AxImp_Tests.cs b/src/Tasks.UnitTests/AxImp_Tests.cs
index 0df05217c48..7d55a4512bd 100644
--- a/src/Tasks.UnitTests/AxImp_Tests.cs
+++ b/src/Tasks.UnitTests/AxImp_Tests.cs
@@ -3,7 +3,6 @@
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
 
 using Xunit;
 
diff --git a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
index 770ccc508fe..71380bfebf1 100644
--- a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
+++ b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.IO;
-using System.Reflection;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Microsoft.Runtime.Hosting;
diff --git a/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs b/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs
index a1f2bad0ffd..8d438b418fc 100644
--- a/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs
+++ b/src/Tasks.UnitTests/CSharpParserUtilitites_Tests.cs
@@ -1,14 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Reflection;
-using System.Collections;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
-using System.Text.RegularExpressions;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
diff --git a/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs b/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
index defc3d56400..de1f3b0bb61 100644
--- a/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
+++ b/src/Tasks.UnitTests/CSharpTokenizer_Tests.cs
@@ -3,12 +3,6 @@
 
 using System;
 using System.IO;
-using System.Reflection;
-using System.Collections;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
-using System.Text.RegularExpressions;
 
 using Microsoft.Build.Shared.LanguageParser;
 using Xunit;
diff --git a/src/Tasks.UnitTests/CallTarget_Tests.cs b/src/Tasks.UnitTests/CallTarget_Tests.cs
index 32350f613cb..58c1b7a45f6 100644
--- a/src/Tasks.UnitTests/CallTarget_Tests.cs
+++ b/src/Tasks.UnitTests/CallTarget_Tests.cs
@@ -2,16 +2,11 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Reflection;
-using System.Collections;
 using System.Collections.Generic;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
-using System.Text.RegularExpressions;
 using Shouldly;
 using Xunit;
 
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
index 8d0a7300c85..fab60ae6143 100644
--- a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
+++ b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
@@ -3,7 +3,6 @@
 
 using System.IO;
 using System;
-using System.Diagnostics;
 using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs b/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs
index 3409ecec7ef..b45459a0548 100644
--- a/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs
+++ b/src/Tasks.UnitTests/ComReferenceWalker_Tests.cs
@@ -3,11 +3,8 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Tasks;
 using System.Runtime.InteropServices.ComTypes;
-
-using Marshal = System.Runtime.InteropServices.Marshal;
 using COMException = System.Runtime.InteropServices.COMException;
 using Xunit;
 
diff --git a/src/Tasks.UnitTests/ComReference_Tests.cs b/src/Tasks.UnitTests/ComReference_Tests.cs
index 80addaa2ae3..7e9b308679d 100644
--- a/src/Tasks.UnitTests/ComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ComReference_Tests.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Shared;
 using Xunit;
diff --git a/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs b/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs
index 4eae02a779f..888f7603f24 100644
--- a/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs
+++ b/src/Tasks.UnitTests/CommandLineBuilderExtension_Tests.cs
@@ -2,13 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Reflection;
-using System.Collections;
-using System.Text.RegularExpressions;
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 
diff --git a/src/Tasks.UnitTests/CommandLine_Support.cs b/src/Tasks.UnitTests/CommandLine_Support.cs
index c807d9c934c..4319bce40fa 100644
--- a/src/Tasks.UnitTests/CommandLine_Support.cs
+++ b/src/Tasks.UnitTests/CommandLine_Support.cs
@@ -2,16 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 using System.Reflection;
-using System.Collections;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
-using System.Text.RegularExpressions;
-using System.Globalization;
-using System.Text;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -43,7 +37,7 @@ static internal bool CallValidateParameters(ToolTask task)
          */
         private static string[] Parse(string cl)
         {
-            int emptySplits = 0;
+            int emptySplits;
             string[] pieces = (string[])QuotingUtilities.SplitUnquoted(cl, int.MaxValue, false, true, out emptySplits, ' ', '\n').ToArray(typeof(string));
             return pieces;
         }
@@ -262,8 +256,7 @@ internal static void ValidateEquals(ToolTaskExtension t, string lookFor, bool us
                 t.AddCommandLineCommands(b);
 
             string cl = b.ToString();
-            string msg;
-            msg = String.Format("Command-line = [{0}]\r\n", cl);
+            string msg = String.Format("Command-line = [{0}]\r\n", cl);
             msg += String.Format("Expected     = [{0}]\r\n", lookFor);
 
             if (cl != lookFor)
diff --git a/src/Tasks.UnitTests/ConvertToAbsolutePath_Tests.cs b/src/Tasks.UnitTests/ConvertToAbsolutePath_Tests.cs
index fb6814a909b..185ec52cc69 100644
--- a/src/Tasks.UnitTests/ConvertToAbsolutePath_Tests.cs
+++ b/src/Tasks.UnitTests/ConvertToAbsolutePath_Tests.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.IO;
 
 using Microsoft.Build.Framework;
diff --git a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
index 9a77edb3002..6e94a149782 100644
--- a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
@@ -31,14 +31,14 @@ public void Basic()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"f:\myproject\SubFolder\MyForm.resx",
-                    null,
-                    true,
-                    null,    // Root namespace
-                    null,
-                    null,
-                    StreamHelpers.StringToStream("namespace MyStuff.Namespace { class Class {} }"),
-                    null
+                    fileName: @"f:\myproject\SubFolder\MyForm.resx",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: null,    // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream("namespace MyStuff.Namespace { class Class {} }"),
+                    log: null
                 );
 
             Assert.Equal("MyStuff.Namespace.Class", result);
@@ -71,14 +71,14 @@ public void Regress172107()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"irrelevant",
-                    null,
-                    true,
-                    null,    // Root namespace
-                    null,
-                    null,
-                    sourcesStream,
-                    null
+                    fileName: @"irrelevant",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: null,    // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: sourcesStream,
+                    log: null
                 );
 
             MemoryStream m = new MemoryStream();
@@ -119,14 +119,14 @@ public void Regress249540()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"irrelevant",
-                    null,
-                    true,
-                    null,    // Root namespace
-                    null,
-                    null,
-                    sourcesStream,
-                    null
+                    fileName: @"irrelevant",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: null,    // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: sourcesStream,
+                    log: null
                 );
 
             Assert.Equal("d\u00C4a.Class", result);
@@ -141,14 +141,14 @@ public void RelativeDependentUpon()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"f:\myproject\SubFolder\MyForm.resx",
-                    null,
-                    true,
-                    null,    // Root namespace
-                    null,
-                    null,
-                    StreamHelpers.StringToStream("namespace Namespace { class Class {} }"),
-                    null
+                    fileName: @"f:\myproject\SubFolder\MyForm.resx",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: null,    // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream("namespace Namespace { class Class {} }"),
+                    log: null
                 );
 
             Assert.Equal("Namespace.Class", result);
@@ -163,14 +163,14 @@ public void AbsoluteDependentUpon()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"f:\myproject\SubFolder\MyForm.resx",
-                    null,
-                    true,
-                    "RootNamespace",    // Root namespace (will be ignored because it's dependent)
-                    null,
-                    null,
-                    StreamHelpers.StringToStream("namespace MyStuff.Namespace { class Class {} }"),
-                    null
+                    fileName: @"f:\myproject\SubFolder\MyForm.resx",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",    // Root namespace (will be ignored because it's dependent)
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream("namespace MyStuff.Namespace { class Class {} }"),
+                    log: null
                 );
 
             Assert.Equal("MyStuff.Namespace.Class", result);
@@ -185,14 +185,14 @@ public void DependentWithCulture()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"f:\myproject\SubFolder\MyForm.en-GB.resx",
-                    null,
-                    true,
-                    "RootNamespace",    // Root namespace (will be ignored because it's dependent)
-                    null,
-                    null,
-                    StreamHelpers.StringToStream("namespace MyStuff.Namespace { class Class {} }"),
-                    null
+                    fileName: @"f:\myproject\SubFolder\MyForm.en-GB.resx",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",    // Root namespace (will be ignored because it's dependent)
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream("namespace MyStuff.Namespace { class Class {} }"),
+                    log: null
                 );
 
             Assert.Equal("MyStuff.Namespace.Class.en-GB", result);
@@ -208,14 +208,14 @@ public void DependentWithCultureMetadata()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"f:\myproject\SubFolder\MyForm.resx",
-                    null,
-                    true,
-                    "RootNamespace",    // Root namespace (will be ignored because it's dependent)
-                    null,
-                    "en-GB",
-                    StreamHelpers.StringToStream("namespace MyStuff.Namespace { class Class {} }"),
-                    null
+                    fileName: @"f:\myproject\SubFolder\MyForm.resx",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",    // Root namespace (will be ignored because it's dependent)
+                    dependentUponFileName: null,
+                    culture: "en-GB",
+                    binaryStream: StreamHelpers.StringToStream("namespace MyStuff.Namespace { class Class {} }"),
+                    log: null
                 );
 
             Assert.Equal("MyStuff.Namespace.Class.en-GB", result);
@@ -230,14 +230,14 @@ public void DependentWithEmbeddedCulture()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"f:\myproject\SubFolder\MyForm.fr-fr.resx",
-                    null,
-                    true,
-                    "RootNamespace",    // Root namespace (will be ignored because it's dependent)
-                    null,
-                    null,
-                    StreamHelpers.StringToStream("namespace MyStuff.Namespace { class Class {} }"),
-                    null
+                    fileName: @"f:\myproject\SubFolder\MyForm.fr-fr.resx",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",    // Root namespace (will be ignored because it's dependent)
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream("namespace MyStuff.Namespace { class Class {} }"),
+                    log: null
                 );
 
             Assert.Equal("MyStuff.Namespace.Class.fr-fr", result);
@@ -253,19 +253,42 @@ public void RootnamespaceWithCulture()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"SubFolder\MyForm.en-GB.ResX",
-                    null,
-                    true,
-                    "RootNamespace",        // Root namespace
-                    null,
-                    null,
-                    null,
-                    null
+                    fileName: @"SubFolder\MyForm.en-GB.ResX",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",        // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null
                 );
 
             Assert.Equal("RootNamespace.SubFolder.MyForm.en-GB", result);
         }
 
+        /// <summary>
+        /// Explicitly retain culture
+        /// </summary>
+        [Fact]
+        public void RootnamespaceWithCulture_RetainCultureInFileName()
+        {
+            string result =
+            CreateCSharpManifestResourceName.CreateManifestNameImpl
+                (
+                    fileName: @"Subfolder\File.cs.cshtml",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",        // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null,
+                    treatAsCultureNeutral: true // retain culture in name
+                );
+
+            result.ShouldBe("RootNamespace.Subfolder.File.cs.cshtml");
+        }
+
         /// <summary>
         /// If there is a link file name then it is preferred over the main file name.
         /// </summary>
@@ -275,14 +298,14 @@ public void Regress222308()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"..\..\XmlEditor\Setup\XmlEditor.rgs",
-                    @"XmlEditor.rgs",
-                    true,
-                    "RootNamespace",        // Root namespace
-                    null,
-                    null,
-                    null,
-                    null
+                    fileName: @"..\..\XmlEditor\Setup\XmlEditor.rgs",
+                    linkFileName: @"XmlEditor.rgs",
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",        // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null
                 );
 
             Assert.Equal("RootNamespace.XmlEditor.rgs", result);
@@ -297,14 +320,14 @@ public void BitmapWithRootNamespace()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"SubFolder\SplashScreen.bmp",
-                    null,
-                    true,
-                    "RootNamespace",        // Root namespace
-                    null,
-                    null,
-                    null,
-                    null
+                    fileName: @"SubFolder\SplashScreen.bmp",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",        // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null
                 );
 
             Assert.Equal("RootNamespace.SubFolder.SplashScreen.bmp", result);
@@ -319,14 +342,14 @@ public void CulturedBitmapWithRootNamespace()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"SubFolder\SplashScreen.fr.bmp",
-                    null,
-                    true,
-                    "RootNamespace",        // Root namespace
-                    null,
-                    null,
-                    null,
-                    null
+                    fileName: @"SubFolder\SplashScreen.fr.bmp",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",        // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null
                 );
 
             Assert.Equal(FileUtilities.FixFilePath(@"fr\RootNamespace.SubFolder.SplashScreen.bmp"), result);
@@ -341,14 +364,14 @@ public void CulturedBitmapWithRootNamespaceNoDirectoryPrefix()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"SubFolder\SplashScreen.fr.bmp",
-                    null,    // Link file name
-                    false,
-                    "RootNamespace",        // Root namespace
-                    null,
-                    null,
-                    null,
-                    null
+                    fileName: @"SubFolder\SplashScreen.fr.bmp",
+                    linkFileName: null,    // Link file name
+                    prependCultureAsDirectory: false,
+                    rootNamespace: "RootNamespace",        // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null
                 );
 
             Assert.Equal(@"RootNamespace.SubFolder.SplashScreen.bmp", result);
@@ -695,14 +718,14 @@ public void Regress419591()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    "MyForm.en-GB.resx",
-                    null,
-                    true,
-                    "RootNamespace",    // Root namespace (will be ignored because it's dependent)
-                    "MyForm.en-GB.cs",
-                    null,
-                    StreamHelpers.StringToStream("namespace ClassLibrary1 { class MyForm {} }"),
-                    null
+                    fileName: "MyForm.en-GB.resx",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",    // Root namespace (will be ignored because it's dependent)
+                    dependentUponFileName: "MyForm.en-GB.cs",
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream("namespace ClassLibrary1 { class MyForm {} }"),
+                    log: null
                 );
 
             Assert.Equal("ClassLibrary1.MyForm", result);
@@ -724,14 +747,14 @@ public void Regress419591_EmptySource()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    "MyForm.en-GB.resx",
-                    null,
-                    true,
-                    "RootNamespace",
-                    "MyForm.en-GB.cs",
-                    null,
-                    StreamHelpers.StringToStream(""),
-                    null
+                    fileName: "MyForm.en-GB.resx",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",
+                    dependentUponFileName: "MyForm.en-GB.cs",
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream(""),
+                    log: null
                 );
 
             Assert.Equal("RootNamespace.MyForm.en-GB", result);
@@ -751,13 +774,13 @@ public void Regress459265()
 
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    "MyForm.resx",
-                    null,
-                    true,
-                    "RootNamespace",    // Root namespace (will be ignored because it's dependent)
-                    "MyForm.cs",
-                    null,
-                    StreamHelpers.StringToStream(
+                    fileName: "MyForm.resx",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",    // Root namespace (will be ignored because it's dependent)
+                    dependentUponFileName: "MyForm.cs",
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream(
 @"using System;
 #if false
 namespace ClassLibrary1
@@ -773,7 +796,7 @@ class MyForm
     }
 }"
                     ),
-                    c.Log
+                    log: c.Log
                 );
 
             Assert.Contains(
@@ -910,14 +933,14 @@ public void CulturedResourcesFileWithRootNamespaceWithinSubfolder()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"SubFolder\MyResource.fr.resources",
-                    null,    // Link file name
-                    false,
-                    "RootNamespace",        // Root namespace
-                    null,
-                    null,
-                    null,
-                    null
+                    fileName: @"SubFolder\MyResource.fr.resources",
+                    linkFileName: null,    // Link file name
+                    prependCultureAsDirectory: false,
+                    rootNamespace: "RootNamespace",        // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null
                 );
 
             Assert.Equal(@"RootNamespace.SubFolder.MyResource.fr.resources", result);
@@ -932,14 +955,14 @@ public void CulturedResourcesFileWithRootNamespace()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"MyResource.fr.resources",
-                    null,    // Link file name
-                    false,
-                    "RootNamespace",        // Root namespace
-                    null,
-                    null,
-                    null,
-                    null
+                    fileName: @"MyResource.fr.resources",
+                    linkFileName: null,    // Link file name
+                    prependCultureAsDirectory: false,
+                    rootNamespace: "RootNamespace",        // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null
                 );
 
             Assert.Equal(@"RootNamespace.MyResource.fr.resources", result);
@@ -954,14 +977,14 @@ public void ResourcesFileWithRootNamespace()
             string result =
             CreateCSharpManifestResourceName.CreateManifestNameImpl
                 (
-                    @"MyResource.resources",
-                    null,    // Link file name
-                    false,
-                    "RootNamespace",        // Root namespace
-                    null,
-                    null,
-                    null,
-                    null
+                    fileName: @"MyResource.resources",
+                    linkFileName: null,    // Link file name
+                    prependCultureAsDirectory: false,
+                    rootNamespace: "RootNamespace",        // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null
                 );
 
             Assert.Equal(@"RootNamespace.MyResource.resources", result);
diff --git a/src/Tasks.UnitTests/CreateItem_Tests.cs b/src/Tasks.UnitTests/CreateItem_Tests.cs
index 2bc06e46f48..de694d88f7d 100644
--- a/src/Tasks.UnitTests/CreateItem_Tests.cs
+++ b/src/Tasks.UnitTests/CreateItem_Tests.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.IO;
 using System.Collections.Generic;
 using Microsoft.Build.Execution;
@@ -183,8 +182,6 @@ public void RecursiveDirOutOfProc()
 
             ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine("Subdir", "Bar.txt"), "bar");
 
-            env.SetEnvironmentVariable("MSBUILDTARGETRESULTCOMPRESSIONTHRESHOLD", "0");
-
             BuildRequestData data = new BuildRequestData(projectFileFullPath, new Dictionary<string, string>(), null, new string[] { "Repro" }, null);
             BuildParameters parameters = new BuildParameters
             {
diff --git a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
index ce70c6c1a2f..b1617749091 100644
--- a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
@@ -32,20 +32,20 @@ public void Basic()
             string result =
             CreateVisualBasicManifestResourceName.CreateManifestNameImpl
                 (
-                    @"f:\myproject\SubFolder\MyForm.resx",
-                    null,    // Link file name
-                    true,
-                    null,    // Root namespace
-                    null,
-                    null,
-                    StreamHelpers.StringToStream(
+                    fileName: @"f:\myproject\SubFolder\MyForm.resx",
+                    linkFileName: null,    // Link file name
+                    prependCultureAsDirectory: true,
+                    rootNamespace: null,    // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream(
 @"
 Namespace Nested.TestNamespace 
     Class TestClass 
     End Class
 End Namespace
 "),
-                    null
+                    log: null
                 );
 
             Assert.Equal("Nested.TestNamespace.TestClass", result);
@@ -60,20 +60,20 @@ public void RelativeDependentUpon()
             string result =
             CreateVisualBasicManifestResourceName.CreateManifestNameImpl
                 (
-                    @"f:\myproject\SubFolder\MyForm.resx",
-                    null,    // Link file name
-                    true,
-                    null,    // Root namespace
-                    null,
-                    null,
-                    StreamHelpers.StringToStream(
+                    fileName: @"f:\myproject\SubFolder\MyForm.resx",
+                    linkFileName: null,    // Link file name
+                    prependCultureAsDirectory: true,
+                    rootNamespace: null,    // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream(
 @"
 Namespace TestNamespace 
     Class TestClass 
     End Class
 End Namespace
 "),
-                    null
+                    log: null
 
                 );
 
@@ -89,20 +89,20 @@ public void AbsoluteDependentUpon()
             string result =
             CreateVisualBasicManifestResourceName.CreateManifestNameImpl
                 (
-                    @"f:\myproject\SubFolder\MyForm.resx",
-                    null,    // Link file name
-                    true,
-                    null,    // Root namespace
-                    null,
-                    null,
-                    StreamHelpers.StringToStream(
+                    fileName: @"f:\myproject\SubFolder\MyForm.resx",
+                    linkFileName: null,    // Link file name
+                    prependCultureAsDirectory: true,
+                    rootNamespace: null,    // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream(
 @"
 Namespace Nested.TestNamespace 
     Class TestClass 
     End Class
 End Namespace
 "),
-                    null
+                    log: null
 
                 );
 
@@ -118,20 +118,20 @@ public void DependentWithCulture()
             string result =
             CreateVisualBasicManifestResourceName.CreateManifestNameImpl
                 (
-                    @"f:\myproject\SubFolder\MyForm.en-GB.resx",
-                    null,    // Link file name
-                    true,
-                    null,        // Root namespace
-                    null,
-                    null,
-                    StreamHelpers.StringToStream(
+                    fileName: @"f:\myproject\SubFolder\MyForm.en-GB.resx",
+                    linkFileName: null,    // Link file name
+                    prependCultureAsDirectory: true,
+                    rootNamespace: null,        // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream(
 @"
 Namespace Nested.TestNamespace 
     Class TestClass 
     End Class
 End Namespace
 "),
-                    null
+                    log: null
 
                 );
 
@@ -148,20 +148,20 @@ public void DependentWithCultureMetadata()
             string result =
             CreateVisualBasicManifestResourceName.CreateManifestNameImpl
                 (
-                    @"f:\myproject\SubFolder\MyForm.resx",
-                    null,    // Link file name
-                    true,
-                    null,        // Root namespace
-                    null,
-                    "en-GB",
-                    StreamHelpers.StringToStream(
+                    fileName: @"f:\myproject\SubFolder\MyForm.resx",
+                    linkFileName: null,    // Link file name
+                    prependCultureAsDirectory: true,
+                    rootNamespace: null,        // Root namespace
+                    dependentUponFileName: null,
+                    culture: "en-GB",
+                    binaryStream: StreamHelpers.StringToStream(
 @"
 Namespace Nested.TestNamespace 
     Class TestClass 
     End Class
 End Namespace
 "),
-                    null
+                    log: null
 
                 );
 
@@ -177,20 +177,20 @@ public void DependentWithCultureAndRootNamespace()
             string result =
             CreateVisualBasicManifestResourceName.CreateManifestNameImpl
                 (
-                    @"f:\myproject\SubFolder\MyForm.en-GB.resx",
-                    null,    // Link file name
-                    true,
-                    "RootNamespace",
-                    null,
-                    null,
-                    StreamHelpers.StringToStream(
+                    fileName: @"f:\myproject\SubFolder\MyForm.en-GB.resx",
+                    linkFileName: null,    // Link file name
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream(
 @"
 Namespace Nested.TestNamespace 
     Class TestClass 
     End Class
 End Namespace
 "),
-                    null
+                    log: null
 
                 );
 
@@ -206,20 +206,20 @@ public void DependentWithEmbeddedCulture()
             string result =
             CreateVisualBasicManifestResourceName.CreateManifestNameImpl
                 (
-                    @"f:\myproject\SubFolder\MyForm.fr-fr.resx",
-                    null,    // Link file name
-                    true,
-                    "RootNamespace",    // Root namespace
-                    null,
-                    null,
-                    StreamHelpers.StringToStream(
+                    fileName: @"f:\myproject\SubFolder\MyForm.fr-fr.resx",
+                    linkFileName: null,    // Link file name
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",    // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream(
 @"
 Namespace Nested.TestNamespace 
     Class TestClass 
     End Class
 End Namespace
 "),
-                    null
+                    log: null
 
                 );
 
@@ -235,20 +235,46 @@ public void RootnamespaceWithCulture()
         {
             string result =
                 CreateVisualBasicManifestResourceName.CreateManifestNameImpl(
-                    FileUtilities.FixFilePath(@"SubFolder\MyForm.en-GB.ResX"),
-                    null,
+                    fileName: FileUtilities.FixFilePath(@"SubFolder\MyForm.en-GB.ResX"),
+                    linkFileName: null,
+                    // Link file name
+                    prependCultureAsDirectory:
                     // Link file name
                     true,
-                    "RootNamespace",
+                    rootNamespace: "RootNamespace",
+                    // Root namespace
+                    dependentUponFileName:
                     // Root namespace
                     null,
-                    null,
-                    null,
-                    null);
+                    culture: null,
+                    binaryStream: null,
+                    log: null);
 
             Assert.Equal("RootNamespace.MyForm.en-GB", result);
         }
 
+        [Fact]
+        public void RootnamespaceWithCulture_RetainCultureInFileName()
+        {
+            string result =
+            CreateVisualBasicManifestResourceName.CreateManifestNameImpl
+                (
+                    fileName: @"File.cs.vb",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",        // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null,
+                    treatAsCultureNeutral: true // retain culture in name
+                );
+
+            // Visual basic does not carry subfolder.
+            // See https://github.com/dotnet/msbuild/pull/5477
+            result.ShouldBe("RootNamespace.File.cs.vb");
+        }
+
         /// <summary>
         /// If there is a link file name then it is preferred over the main file name.
         /// </summary>
@@ -258,14 +284,14 @@ public void Regress222308()
             string result =
             CreateVisualBasicManifestResourceName.CreateManifestNameImpl
                 (
-                    @"..\..\XmlEditor\Setup\XmlEditor.rgs",
-                    @"MyXmlEditor.rgs",
-                    true,
-                    "RootNamespace",        // Root namespace
-                    null,
-                    null,
-                    null,
-                    null
+                    fileName: @"..\..\XmlEditor\Setup\XmlEditor.rgs",
+                    linkFileName: @"MyXmlEditor.rgs",
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",        // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null
 
                 );
 
@@ -280,14 +306,14 @@ public void BitmapWithRootNamespace()
         {
             string result =
                 CreateVisualBasicManifestResourceName.CreateManifestNameImpl(
-                    FileUtilities.FixFilePath(@"SubFolder\SplashScreen.bmp"),
-                    null,             // Link file name
-                    true,
-                    "RootNamespace", // Root namespace
-                    null,
-                    null,
-                    null,
-                    null);
+                    fileName: FileUtilities.FixFilePath(@"SubFolder\SplashScreen.bmp"),
+                    linkFileName: null,             // Link file name
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace", // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null);
 
             Assert.Equal("RootNamespace.SplashScreen.bmp", result);
         }
@@ -300,14 +326,14 @@ public void CulturedBitmapWithRootNamespace()
         {
             string result =
                 CreateVisualBasicManifestResourceName.CreateManifestNameImpl(
-                    FileUtilities.FixFilePath(@"SubFolder\SplashScreen.fr.bmp"),
-                    null,             // Link file name
-                    true,
-                    "RootNamespace",  // Root namespace
-                    null,
-                    null,
-                    null,
-                    null);
+                    fileName: FileUtilities.FixFilePath(@"SubFolder\SplashScreen.fr.bmp"),
+                    linkFileName: null,             // Link file name
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",  // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null);
 
             Assert.Equal(FileUtilities.FixFilePath(@"fr\RootNamespace.SplashScreen.bmp"), result);
         }
@@ -320,14 +346,14 @@ public void CulturedBitmapWithRootNamespaceNoDirectoryPrefix()
         {
             string result =
                 CreateVisualBasicManifestResourceName.CreateManifestNameImpl(
-                    FileUtilities.FixFilePath(@"SubFolder\SplashScreen.fr.bmp"),
-                    null,             // Link file name
-                    false,
-                    "RootNamespace",  // Root namespace
-                    null,
-                    null,
-                    null,
-                    null);
+                    fileName: FileUtilities.FixFilePath(@"SubFolder\SplashScreen.fr.bmp"),
+                    linkFileName: null,             // Link file name
+                    prependCultureAsDirectory: false,
+                    rootNamespace: "RootNamespace",  // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null);
 
             Assert.Equal(@"RootNamespace.SplashScreen.bmp", result);
         }
@@ -444,18 +470,18 @@ public void Regress419591()
             string result =
             CreateVisualBasicManifestResourceName.CreateManifestNameImpl
                 (
-                    "MyForm.ro.resx",
-                    null,    // Link file name
-                    true,
-                    "RootNamespace",    // Root namespace
-                    "MyForm.ro.vb",
-                    null,
-                    StreamHelpers.StringToStream(
+                    fileName: "MyForm.ro.resx",
+                    linkFileName: null,    // Link file name
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",    // Root namespace
+                    dependentUponFileName: "MyForm.ro.vb",
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream(
 @"
     Class MyForm 
     End Class
 "),
-                    null
+                    log: null
 
                 );
 
@@ -477,13 +503,13 @@ public void Regress459265()
             string result =
             CreateVisualBasicManifestResourceName.CreateManifestNameImpl
                 (
-                    "MyForm.resx",
-                    null,
-                    true,
-                    "RootNamespace",    // Root namespace (will be ignored because it's dependent)
-                    "MyForm.vb",
-                    null,
-                    StreamHelpers.StringToStream(
+                    fileName: "MyForm.resx",
+                    linkFileName: null,
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",    // Root namespace (will be ignored because it's dependent)
+                    dependentUponFileName: "MyForm.vb",
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream(
 @"Imports System
 
 #if false
@@ -499,7 +525,7 @@ End Class
 End Namespace
 "
                     ),
-                    c.Log
+                    log: c.Log
                 );
 
             Assert.Contains(
@@ -618,14 +644,14 @@ public void CulturedResourcesFileWithRootNamespaceWithinSubfolder()
         {
             string result =
                 CreateVisualBasicManifestResourceName.CreateManifestNameImpl(
-                    FileUtilities.FixFilePath(@"SubFolder\MyResource.fr.resources"),
-                    null,             // Link file name
-                    false,
-                    "RootNamespace",  // Root namespace
-                    null,
-                    null,
-                    null,
-                    null);
+                    fileName: FileUtilities.FixFilePath(@"SubFolder\MyResource.fr.resources"),
+                    linkFileName: null,             // Link file name
+                    prependCultureAsDirectory: false,
+                    rootNamespace: "RootNamespace",  // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null);
 
             Assert.Equal(@"RootNamespace.MyResource.fr.resources", result);
         }
@@ -639,14 +665,14 @@ public void CulturedResourcesFileWithRootNamespace()
             string result =
             CreateVisualBasicManifestResourceName.CreateManifestNameImpl
                 (
-                    @"MyResource.fr.resources",
-                    null,    // Link file name
-                    false,
-                    "RootNamespace",        // Root namespace
-                    null,
-                    null,
-                    null,
-                    null
+                    fileName: @"MyResource.fr.resources",
+                    linkFileName: null,    // Link file name
+                    prependCultureAsDirectory: false,
+                    rootNamespace: "RootNamespace",        // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null
                 );
 
             Assert.Equal(@"RootNamespace.MyResource.fr.resources", result);
@@ -661,14 +687,14 @@ public void ResourcesFileWithRootNamespace()
             string result =
             CreateVisualBasicManifestResourceName.CreateManifestNameImpl
                 (
-                    @"MyResource.resources",
-                    null,    // Link file name
-                    false,
-                    "RootNamespace",        // Root namespace
-                    null,
-                    null,
-                    null,
-                    null
+                    fileName: @"MyResource.resources",
+                    linkFileName: null,    // Link file name
+                    prependCultureAsDirectory: false,
+                    rootNamespace: "RootNamespace",        // Root namespace
+                    dependentUponFileName: null,
+                    culture: null,
+                    binaryStream: null,
+                    log: null
                 );
 
             Assert.Equal(@"RootNamespace.MyResource.resources", result);
@@ -679,14 +705,14 @@ private void AssertSimpleCase(string code, string expected)
             string result =
             CreateVisualBasicManifestResourceName.CreateManifestNameImpl
                 (
-                    "MyForm.resx",
-                    null,    // Link file name
-                    true,
-                    "RootNamespace",    // Root namespace
-                    "MyForm.vb",
-                    null,
-                    StreamHelpers.StringToStream(code),
-                    null
+                    fileName: "MyForm.resx",
+                    linkFileName: null,    // Link file name
+                    prependCultureAsDirectory: true,
+                    rootNamespace: "RootNamespace",    // Root namespace
+                    dependentUponFileName: "MyForm.vb",
+                    culture: null,
+                    binaryStream: StreamHelpers.StringToStream(code),
+                    log: null
                 );
 
             Assert.Equal(expected, result);
diff --git a/src/Tasks.UnitTests/Culture_Tests.cs b/src/Tasks.UnitTests/Culture_Tests.cs
index 125295e4555..b4fdc551710 100644
--- a/src/Tasks.UnitTests/Culture_Tests.cs
+++ b/src/Tasks.UnitTests/Culture_Tests.cs
@@ -1,12 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Reflection;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
diff --git a/src/Tasks.UnitTests/Delete_Tests.cs b/src/Tasks.UnitTests/Delete_Tests.cs
index b644ff1e4c5..cf9ed630114 100644
--- a/src/Tasks.UnitTests/Delete_Tests.cs
+++ b/src/Tasks.UnitTests/Delete_Tests.cs
@@ -1,9 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Reflection;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs b/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs
index 7457d18b840..d80ba5e5592 100644
--- a/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs
+++ b/src/Tasks.UnitTests/ErrorWarningMessage_Tests.cs
@@ -2,13 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Reflection;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
-using Microsoft.Build.Exceptions;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index 1b8cbd86330..df8ac22edce 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -122,21 +122,33 @@ public void Timeout()
         [Fact]
         public void TimeoutFailsEvenWhenExitCodeIsIgnored()
         {
-            // On non-Windows the exit code of a killed process is SIGTERM (143)
-            int expectedExitCode = NativeMethodsShared.IsWindows ? -1 : 143;
 
             Exec exec = PrepareExec(NativeMethodsShared.IsWindows ? ":foo \n goto foo" : "while true; do sleep 1; done");
             exec.Timeout = 5;
             exec.IgnoreExitCode = true;
             bool result = exec.Execute();
 
-            Assert.False(result);
-            Assert.Equal(expectedExitCode, exec.ExitCode);
-            ((MockEngine)exec.BuildEngine).AssertLogContains("MSB5002");
-            Assert.Equal(1, ((MockEngine)exec.BuildEngine).Warnings);
+            result.ShouldBeFalse();
+            MockEngine mockEngine = (MockEngine)exec.BuildEngine;
+            mockEngine.AssertLogContains("MSB5002");
+            mockEngine.Warnings.ShouldBe(1);
 
             // ToolTask does not log an error on timeout.
-            Assert.Equal(0, ((MockEngine)exec.BuildEngine).Errors);
+            mockEngine.Errors.ShouldBe(0);
+
+            if (NativeMethodsShared.IsMono)
+            {
+                // The standard check for SIGTERM fails intermittently on macOS Mono
+                // https://github.com/dotnet/msbuild/issues/5506
+                // To avoid test flakiness, allow 259 even though I can't justify it.
+                exec.ExitCode.ShouldBeOneOf(143, 259);
+            }
+            else
+            {
+                // On non-Windows the exit code of a killed process is generally 128 + SIGTERM = 143
+                // though this isn't 100% guaranteed, see https://unix.stackexchange.com/a/99134
+                exec.ExitCode.ShouldBe(NativeMethodsShared.IsWindows ? -1 : 143);
+            }
         }
 
         [Fact]
diff --git a/src/Tasks.UnitTests/FileStateTests.cs b/src/Tasks.UnitTests/FileStateTests.cs
index 0c7ed064dbf..62f6eab495f 100644
--- a/src/Tasks.UnitTests/FileStateTests.cs
+++ b/src/Tasks.UnitTests/FileStateTests.cs
@@ -3,14 +3,8 @@
 
 using System;
 using System.IO;
-using System.Reflection;
-using System.Collections;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
-using System.Text.RegularExpressions;
-using System.Globalization;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
diff --git a/src/Tasks.UnitTests/FindAppConfigFile_Tests.cs b/src/Tasks.UnitTests/FindAppConfigFile_Tests.cs
index a8a63af387c..c2bd134f11a 100644
--- a/src/Tasks.UnitTests/FindAppConfigFile_Tests.cs
+++ b/src/Tasks.UnitTests/FindAppConfigFile_Tests.cs
@@ -1,9 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
diff --git a/src/Tasks.UnitTests/FindInList_Tests.cs b/src/Tasks.UnitTests/FindInList_Tests.cs
index c9220eeac13..a87a9cc5ffc 100644
--- a/src/Tasks.UnitTests/FindInList_Tests.cs
+++ b/src/Tasks.UnitTests/FindInList_Tests.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
diff --git a/src/Tasks.UnitTests/FindInvalidProjectReferences_Tests.cs b/src/Tasks.UnitTests/FindInvalidProjectReferences_Tests.cs
index 0561635bf2d..18a0cba61dd 100644
--- a/src/Tasks.UnitTests/FindInvalidProjectReferences_Tests.cs
+++ b/src/Tasks.UnitTests/FindInvalidProjectReferences_Tests.cs
@@ -1,18 +1,10 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Reflection;
-using System.Collections;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
-using System.Text.RegularExpressions;
 using System.Collections.Generic;
-using System.Diagnostics;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
diff --git a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
index 7180353c888..b764f4d7869 100644
--- a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
+++ b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
@@ -3,15 +3,11 @@
 
 using System;
 using System.Collections;
-using System.Diagnostics;
-using System.Globalization;
 using System.IO;
 using System.Linq;
 using System.Xml.Linq;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
-using Microsoft.Build.UnitTests.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
diff --git a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
index 192eba7fa52..3c7f54c0cff 100644
--- a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
+++ b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
@@ -9,9 +9,6 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Evaluation;
-using System.Linq;
-using Microsoft.Build.Execution;
 using Xunit;
 using Microsoft.Build.Tasks;
 
diff --git a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
index 03a50d12ec5..88f8cf4959f 100644
--- a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
+++ b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
@@ -2,11 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Shared;
-using Microsoft.Build.UnitTests;
 using System.IO;
 using Microsoft.Build.Utilities;
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
diff --git a/src/Tasks.UnitTests/LC_Tests.cs b/src/Tasks.UnitTests/LC_Tests.cs
index 3cf5fcfd760..0cbde2ca3a2 100644
--- a/src/Tasks.UnitTests/LC_Tests.cs
+++ b/src/Tasks.UnitTests/LC_Tests.cs
@@ -1,8 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
diff --git a/src/Tasks.UnitTests/MakeDir_Tests.cs b/src/Tasks.UnitTests/MakeDir_Tests.cs
index 26eec72b8ac..d79835aa6c4 100644
--- a/src/Tasks.UnitTests/MakeDir_Tests.cs
+++ b/src/Tasks.UnitTests/MakeDir_Tests.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.IO;
-using System.Reflection;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks.UnitTests/MockFaultInjectionHelper.cs b/src/Tasks.UnitTests/MockFaultInjectionHelper.cs
index c4b532cb80b..bb5b2b9401a 100644
--- a/src/Tasks.UnitTests/MockFaultInjectionHelper.cs
+++ b/src/Tasks.UnitTests/MockFaultInjectionHelper.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 
 namespace Microsoft.Build.UnitTests
 {
diff --git a/src/Tasks.UnitTests/MockTypeInfo.cs b/src/Tasks.UnitTests/MockTypeInfo.cs
index e81e2638b43..418edadd7fa 100644
--- a/src/Tasks.UnitTests/MockTypeInfo.cs
+++ b/src/Tasks.UnitTests/MockTypeInfo.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices.ComTypes;
 
 using Marshal = System.Runtime.InteropServices.Marshal;
diff --git a/src/Tasks.UnitTests/MockTypeLib.cs b/src/Tasks.UnitTests/MockTypeLib.cs
index 1abaa5bd860..51221e3e723 100644
--- a/src/Tasks.UnitTests/MockTypeLib.cs
+++ b/src/Tasks.UnitTests/MockTypeLib.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices.ComTypes;
 
 using Microsoft.Build.Tasks;
diff --git a/src/Tasks.UnitTests/MockUnmanagedMemoryHelper.cs b/src/Tasks.UnitTests/MockUnmanagedMemoryHelper.cs
index e89971269c4..7046cafa1e4 100644
--- a/src/Tasks.UnitTests/MockUnmanagedMemoryHelper.cs
+++ b/src/Tasks.UnitTests/MockUnmanagedMemoryHelper.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
-using System.Runtime.InteropServices.ComTypes;
 
 using Marshal = System.Runtime.InteropServices.Marshal;
 using Xunit;
diff --git a/src/Tasks.UnitTests/Move_Tests.cs b/src/Tasks.UnitTests/Move_Tests.cs
index 298548b0fbf..c2c912bb0cf 100644
--- a/src/Tasks.UnitTests/Move_Tests.cs
+++ b/src/Tasks.UnitTests/Move_Tests.cs
@@ -1,12 +1,9 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.IO;
-using System.Reflection;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
-using Microsoft.Build.UnitTests;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Shared;
 using Xunit;
diff --git a/src/Tasks.UnitTests/PortableTasks_Tests.cs b/src/Tasks.UnitTests/PortableTasks_Tests.cs
index 0b0be178988..037fc932f31 100644
--- a/src/Tasks.UnitTests/PortableTasks_Tests.cs
+++ b/src/Tasks.UnitTests/PortableTasks_Tests.cs
@@ -4,7 +4,6 @@
 using System.IO;
 using System.Linq;
 using System.Text.RegularExpressions;
-using Microsoft.Build.UnitTests;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
diff --git a/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs b/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs
index 436ba0447e6..5eab296f158 100644
--- a/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs
+++ b/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.IO;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.AccessControl;
@@ -11,7 +10,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
-using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
diff --git a/src/Tasks.UnitTests/RemoveDir_Tests.cs b/src/Tasks.UnitTests/RemoveDir_Tests.cs
index 08b010d299b..7f88ef17839 100644
--- a/src/Tasks.UnitTests/RemoveDir_Tests.cs
+++ b/src/Tasks.UnitTests/RemoveDir_Tests.cs
@@ -1,9 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Reflection;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks.UnitTests/RemoveDuplicates_Tests.cs b/src/Tasks.UnitTests/RemoveDuplicates_Tests.cs
index a3d7fdf300e..ad537c820c4 100644
--- a/src/Tasks.UnitTests/RemoveDuplicates_Tests.cs
+++ b/src/Tasks.UnitTests/RemoveDuplicates_Tests.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
diff --git a/src/Tasks.UnitTests/ResolveCodeAnalysisRuleSet_Tests.cs b/src/Tasks.UnitTests/ResolveCodeAnalysisRuleSet_Tests.cs
index efa139dce95..ba48744b488 100644
--- a/src/Tasks.UnitTests/ResolveCodeAnalysisRuleSet_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveCodeAnalysisRuleSet_Tests.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.IO;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Shared;
 using Xunit;
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index 3ef6eb09388..f8c1c4855f7 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -4,7 +4,6 @@
 #if FEATURE_APPDOMAIN
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 
 // TYPELIBATTR clashes with the one in InteropServices.
@@ -38,7 +37,7 @@ private TaskItem SetupTaskItem()
 
         private void AssertReference(ITaskItem item, bool valid, string attribute)
         {
-            string missingOrInvalidAttribute = null;
+            string missingOrInvalidAttribute;
             Assert.Equal(ResolveComReference.VerifyReferenceMetadataForNameItem(item, out missingOrInvalidAttribute), valid);
             Assert.Equal(missingOrInvalidAttribute, attribute);
         }
@@ -610,10 +609,9 @@ public void TestCheckForConflictingReferences()
             Assert.True(rcr.CheckForConflictingReferences());
             Assert.Equal(3, rcr.allProjectRefs.Count);
 
-            ComReferenceInfo referenceInfo;
-
+            
             // duplicate refs should not be treated as conflicts
-            referenceInfo = new ComReferenceInfo(tlbRefInfo);
+            ComReferenceInfo referenceInfo = new ComReferenceInfo(tlbRefInfo);
             rcr.allProjectRefs.Add(referenceInfo);
             referenceInfo = new ComReferenceInfo(axRefInfo);
             rcr.allProjectRefs.Add(referenceInfo);
diff --git a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
index eaca84dcc98..2b846b46bd1 100644
--- a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
@@ -4,9 +4,6 @@
 using System;
 using System.Collections;
 using System.IO;
-using System.Text;
-using System.Linq;
-using System.Xml;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Tasks;
@@ -46,7 +43,7 @@ private void TestVerifyReferenceAttributesHelper(string itemSpec, string project
             ITaskItem reference = CreateReferenceItem(itemSpec, projectGuid, package, name);
 
             ResolveNonMSBuildProjectOutput rvpo = new ResolveNonMSBuildProjectOutput();
-            string missingAttr = null;
+            string missingAttr;
             bool result = rvpo.VerifyReferenceAttributes(reference, out missingAttr);
 
             string message = string.Format("Reference \"{0}\" [project \"{1}\", package \"{2}\", name \"{3}\"], " +
@@ -208,9 +205,7 @@ public void TestManagedCheck()
             Hashtable unresolvedOutputs = null;
             Hashtable resolvedOutputs = null;
             Hashtable projectOutputs = null;
-            ArrayList projectRefs = null;
-
-            projectRefs = new ArrayList();
+            ArrayList projectRefs = new ArrayList();
             projectRefs.Add(CreateReferenceItem("MCDep1.vcproj", "{2F6BBCC3-7111-4116-A68B-000000000000}",
                 "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}", "MCDep1"));
             projectRefs.Add(CreateReferenceItem("MCDep2.vcproj", "{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}",
@@ -237,23 +232,20 @@ public void TestManagedCheck()
         [Trait("Category", "mono-osx-failing")]
         public void TestUnresolvedReferences()
         {
-            Hashtable unresolvedOutputs = null;
-            Hashtable resolvedOutputs = null;
-            Hashtable projectOutputs = null;
-            ArrayList projectRefs = null;
-
-            projectRefs = new ArrayList();
+            ArrayList projectRefs = new ArrayList();
             projectRefs.Add(CreateReferenceItem("MCDep1.vcproj", "{2F6BBCC3-7111-4116-A68B-000000000000}",
                 "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}", "MCDep1"));
             projectRefs.Add(CreateReferenceItem("MCDep2.vcproj", "{2F6BBCC3-7111-4116-A68B-34CFC76F37C5}",
                 "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}", "MCDep2"));
 
             // 1. multiple project refs, none resolvable
-            projectOutputs = new Hashtable();
+            Hashtable projectOutputs = new Hashtable();
             projectOutputs.Add("{11111111-1111-1111-1111-111111111111}", Path.Combine("obj", "wrong.dll"));
             projectOutputs.Add("{11111111-1111-1111-1111-111111111112}", Path.Combine("obj", "wrong2.dll"));
             projectOutputs.Add("{11111111-1111-1111-1111-111111111113}", Path.Combine("obj", "wrong3.dll"));
 
+            Hashtable unresolvedOutputs;
+            Hashtable resolvedOutputs;
             TestUnresolvedReferencesHelper(projectRefs, projectOutputs, out unresolvedOutputs, out resolvedOutputs);
 
             Assert.Empty(resolvedOutputs); // "No resolved refs expected for case 1"
diff --git a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
index 7271638e319..74dfedd39d1 100644
--- a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
@@ -4,12 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Reflection;
-using System.Globalization;
-using System.Resources;
-using System.Text.RegularExpressions;
-using Microsoft.Win32;
-using System.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
@@ -18,9 +12,7 @@
 
 
 using SDKReference = Microsoft.Build.Tasks.ResolveSDKReference.SDKReference;
-using ProcessorArchitecture = Microsoft.Build.Utilities.ProcessorArchitecture;
 using Microsoft.Build.Evaluation;
-using System.Linq;
 using Microsoft.Build.Execution;
 using Xunit;
 
@@ -100,14 +92,13 @@ public void ParseDependsOnString()
         [Fact]
         public void GetUnResolvedDependentSDKs()
         {
-            string[] result = null;
             HashSet<SDKReference> resolvedSDKsEmpty = new HashSet<SDKReference>();
             List<string> dependentSDKsEmpty = new List<string>();
 
             HashSet<SDKReference> resolvedSDKs = new HashSet<SDKReference>() { new SDKReference(new TaskItem(), "bar", "1.0"), new SDKReference(new TaskItem(), "foo", "1.0"), new SDKReference(new TaskItem(), "Newt", "1.0") };
             List<string> dependentSDKs = new List<string>() { "bar, Version=1.0", "bar, Version=2.0", "baz, Version=2.0", "CannotParseMeAsSDK", "newt, version=1.0" };
 
-            result = ResolveSDKReference.GetUnresolvedDependentSDKs(resolvedSDKsEmpty, dependentSDKsEmpty);
+            string[] result = ResolveSDKReference.GetUnresolvedDependentSDKs(resolvedSDKsEmpty, dependentSDKsEmpty);
             Assert.Empty(result);
 
             result = ResolveSDKReference.GetUnresolvedDependentSDKs(new HashSet<SDKReference>(), dependentSDKs);
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index 6b859de116a..fa551927b4f 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -7,8 +7,6 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
-using System.Text.RegularExpressions;
-using System.Text;
 using Xunit;
 using Xunit.Abstractions;
 using System.IO;
@@ -396,11 +394,11 @@ public void ForceSomeOutOfDate()
             }
             finally
             {
-                if (null != firstResx) File.Delete(firstResx);
-                if (null != secondResx) File.Delete(secondResx);
-                if (null != cache) File.Delete(cache);
-                if (null != firstResx) File.Delete(Path.ChangeExtension(firstResx, ".resources"));
-                if (null != secondResx) File.Delete(Path.ChangeExtension(secondResx, ".resources"));
+                if (firstResx != null) File.Delete(firstResx);
+                if (secondResx != null) File.Delete(secondResx);
+                if (cache != null) File.Delete(cache);
+                if (firstResx != null) File.Delete(Path.ChangeExtension(firstResx, ".resources"));
+                if (secondResx != null) File.Delete(Path.ChangeExtension(secondResx, ".resources"));
             }
         }
 
@@ -1190,10 +1188,8 @@ public void TextToResourcesBadFormat()
                 // another invalid escape, this one more serious, "unsupported or invalid escape character"
                 new string[] {   @"foo=\ujjjjbar", "MSB3569"},
             };
-
-            GenerateResource t = null;
-            string textFile = null;
-
+            GenerateResource t;
+            string textFile;
             foreach (string[] test in tests)
             {
                 t = Utilities.CreateTaskOutOfProc(_output);
@@ -1274,10 +1270,10 @@ public void FailedResXReader()
             }
             finally
             {
-                if (null != resxFile1) File.Delete(resxFile1);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resourcesFile1) File.Delete(resourcesFile1);
-                if (null != resourcesFile2) File.Delete(resourcesFile2);
+                if (resxFile1 != null) File.Delete(resxFile1);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resourcesFile1 != null) File.Delete(resourcesFile1);
+                if (resourcesFile2 != null) File.Delete(resourcesFile2);
             }
         }
 
@@ -1334,10 +1330,10 @@ public void FailedResXReaderWithAllOutputResourcesSpecified()
             }
             finally
             {
-                if (null != resxFile1) File.Delete(resxFile1);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resourcesFile1) File.Delete(resourcesFile1);
-                if (null != resourcesFile2) File.Delete(resourcesFile2);
+                if (resxFile1 != null) File.Delete(resxFile1);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resourcesFile1 != null) File.Delete(resourcesFile1);
+                if (resourcesFile2 != null) File.Delete(resourcesFile2);
             }
         }
 
@@ -1419,8 +1415,8 @@ public void InvalidStateFile()
             }
             finally
             {
-                if (null != resxFile) File.Delete(resxFile);
-                if (null != resourcesFile) File.Delete(resourcesFile);
+                if (resxFile != null) File.Delete(resxFile);
+                if (resourcesFile != null) File.Delete(resourcesFile);
             }
         }
 
@@ -1651,8 +1647,7 @@ public void FilesWrittenSet()
 
             Utilities.ExecuteTask(t);
 
-            int i = 0;
-
+            int i;
             for (i = 0; i < 4; i++)
             {
                 Assert.Equal(t.FilesWritten[i].ItemSpec, t.OutputResources[i].ItemSpec);
@@ -2121,10 +2116,10 @@ public void StronglyTypedResourceWithMoreThanOneInputResourceFile()
             }
             finally
             {
-                if (null != resxFile) File.Delete(resxFile);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resxFile) File.Delete(Path.ChangeExtension(resxFile, ".resources"));
-                if (null != resxFile2) File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
+                if (resxFile != null) File.Delete(resxFile);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resxFile != null) File.Delete(Path.ChangeExtension(resxFile, ".resources"));
+                if (resxFile2 != null) File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
             }
         }
 
@@ -2269,7 +2264,7 @@ public void StronglyTypedResourceFilenameWithoutLanguage()
             }
             finally
             {
-                if (null != txtFile) File.Delete(txtFile);
+                if (txtFile != null) File.Delete(txtFile);
             }
         }
 
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 5f113730374..2beea1736da 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -1162,15 +1162,13 @@ public void StronglyTypedResourcesOutOfDate()
             string resxFile = null;
             string resourcesFile = null;
             string strFile = null;
-            string stateFile = null;
-
             try
             {
                 GenerateResource t = Utilities.CreateTask(_output);
                 resxFile = Utilities.WriteTestResX(false, null, null);
                 resourcesFile = Utilities.GetTempFileName(".resources");
                 strFile = Path.ChangeExtension(resourcesFile, ".cs"); // STR filename should be generated from output not input filename
-                stateFile = Utilities.GetTempFileName(".cache");
+                string stateFile = Utilities.GetTempFileName(".cache");
 
                 // Make sure the .cs file isn't already there.
                 File.Delete(strFile);
@@ -1539,10 +1537,8 @@ public void TextToResourcesBadFormat()
                 // another invalid escape, this one more serious, "unsupported or invalid escape character"
                 new string[] {   @"foo=\ujjjjbar", "MSB3569"},
             };
-
-            GenerateResource t = null;
-            string textFile = null;
-
+            GenerateResource t;
+            string textFile;
             foreach (string[] test in tests)
             {
                 t = Utilities.CreateTask(_output);
@@ -1619,10 +1615,10 @@ public void FailedResXReader()
             }
             finally
             {
-                if (null != resxFile1) File.Delete(resxFile1);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resourcesFile1) File.Delete(resourcesFile1);
-                if (null != resourcesFile2) File.Delete(resourcesFile2);
+                if (resxFile1 != null) File.Delete(resxFile1);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resourcesFile1 != null) File.Delete(resourcesFile1);
+                if (resourcesFile2 != null) File.Delete(resourcesFile2);
             }
         }
 
@@ -1676,10 +1672,10 @@ public void FailedResXReaderWithAllOutputResourcesSpecified()
             }
             finally
             {
-                if (null != resxFile1) File.Delete(resxFile1);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resourcesFile1) File.Delete(resourcesFile1);
-                if (null != resourcesFile2) File.Delete(resourcesFile2);
+                if (resxFile1 != null) File.Delete(resxFile1);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resourcesFile1 != null) File.Delete(resourcesFile1);
+                if (resourcesFile2 != null) File.Delete(resourcesFile2);
             }
         }
 
@@ -1760,8 +1756,8 @@ public void InvalidStateFile()
             }
             finally
             {
-                if (null != resxFile) File.Delete(resxFile);
-                if (null != resourcesFile) File.Delete(resourcesFile);
+                if (resxFile != null) File.Delete(resxFile);
+                if (resourcesFile != null) File.Delete(resourcesFile);
             }
         }
 
@@ -2016,7 +2012,7 @@ public void FilesWrittenSet()
 
             Utilities.ExecuteTask(t);
 
-            int i = 0;
+            int i;
 
             // should be four files written, not including the tlogs
             for (i = 0; i < 4; i++)
@@ -2490,10 +2486,10 @@ public void StronglyTypedResourceWithMoreThanOneInputResourceFile()
             }
             finally
             {
-                if (null != resxFile) File.Delete(resxFile);
-                if (null != resxFile2) File.Delete(resxFile2);
-                if (null != resxFile) File.Delete(Path.ChangeExtension(resxFile, ".resources"));
-                if (null != resxFile2) File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
+                if (resxFile != null) File.Delete(resxFile);
+                if (resxFile2 != null) File.Delete(resxFile2);
+                if (resxFile != null) File.Delete(Path.ChangeExtension(resxFile, ".resources"));
+                if (resxFile2 != null) File.Delete(Path.ChangeExtension(resxFile2, ".resources"));
             }
         }
 
@@ -2632,7 +2628,7 @@ public void StronglyTypedResourceFilenameWithoutLanguage()
             }
             finally
             {
-                if (null != txtFile) File.Delete(txtFile);
+                if (txtFile != null) File.Delete(txtFile);
             }
         }
 
@@ -3275,16 +3271,12 @@ public void ResxValueNewlines(string newline)
             string resxDataName = "DataWithNewline";
             string data = "<data name=\"" + resxDataName + "\">" + newline +
                 "<value>" + resxValue + "</value>" + newline + "</data>";
-
-            string resxFile = null;
-
             GenerateResource t = Utilities.CreateTask(_output);
             t.StateFile = new TaskItem(Utilities.GetTempFileName(".cache"));
 
             try
             {
-                resxFile = Utilities.WriteTestResX(false, null, data);
-
+                string resxFile = Utilities.WriteTestResX(false, null, data);
                 t.Sources = new ITaskItem[] { new TaskItem(resxFile) };
 
                 Utilities.ExecuteTask(t);
@@ -3462,7 +3454,7 @@ public static string CreateBasicResourcesFile(bool useResX, ITestOutputHelper ou
         {
             GenerateResource t = CreateTask(output);
 
-            string sourceFile = null;
+            string sourceFile;
             if (useResX)
                 sourceFile = WriteTestResX(false, null, null);
             else
@@ -3888,7 +3880,7 @@ public static void STRNamespaceTestHelper(string strLanguage, string resourcesNa
                 Utilities.AssertLogContainsResource(t, "GenerateResource.ProcessingFile", textFile, resourcesFile);
                 Utilities.AssertLogContainsResource(t, "GenerateResource.ReadResourceMessage", 4, textFile);
 
-                string typeName = null;
+                string typeName;
                 if (t.StronglyTypedNamespace != null)
                     typeName = t.StronglyTypedNamespace + ".";
                 else
diff --git a/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs
index 6e816f18cfb..4da317cd6e7 100644
--- a/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/MSBuildResXReader_Tests.cs
@@ -1,12 +1,9 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Linq;
 using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Tasks.ResourceHandling;
 using Microsoft.Build.Tasks.UnitTests.ResourceHandling;
 using Microsoft.Build.UnitTests;
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
index f4550d7260c..a48675078f4 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
@@ -1,13 +1,9 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.IO;
 using System.Reflection;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
-using System.Resources;
 using Microsoft.Build.Shared;
 using Xunit;
 
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs
index a98e8a261b0..81a366f9489 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResGen_Tests.cs
@@ -7,10 +7,7 @@
 using System.IO;
 using System.Reflection;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
-using System.Text.RegularExpressions;
-using System.Globalization;
 
 using ResGen = Microsoft.Build.Tasks.GenerateResource.ResGen;
 using Xunit;
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs b/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs
index 62414fb64cf..d75034568e8 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResXHelper.cs
@@ -1,13 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
 namespace Microsoft.Build.Tasks.UnitTests.ResourceHandling
 {
     static class ResXHelper
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index aebcd578141..cdedaeeca88 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -6,7 +6,6 @@
 using System.Linq;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.Utilities;
 using Shouldly;
diff --git a/src/Tasks.UnitTests/SGen_Tests.cs b/src/Tasks.UnitTests/SGen_Tests.cs
index 79400d3d7bb..0d8ed3160f0 100644
--- a/src/Tasks.UnitTests/SGen_Tests.cs
+++ b/src/Tasks.UnitTests/SGen_Tests.cs
@@ -2,14 +2,11 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 using System.IO;
 using System.Linq;
 using Xunit;
-using Xunit.Abstractions;
 using Shouldly;
 
 namespace Microsoft.Build.UnitTests
diff --git a/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs b/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs
index a6082ff5033..4c5356142f2 100644
--- a/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs
+++ b/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs
@@ -2,11 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
-using Microsoft.Build.UnitTests;
 using System.IO;
 using Microsoft.Build.Tasks;
 using Xunit;
diff --git a/src/Tasks.UnitTests/StreamHelpers.cs b/src/Tasks.UnitTests/StreamHelpers.cs
index 13ea1f9ca5a..e0469e16184 100644
--- a/src/Tasks.UnitTests/StreamHelpers.cs
+++ b/src/Tasks.UnitTests/StreamHelpers.cs
@@ -1,13 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.IO;
-using System.Reflection;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
-using Xunit;
 
 namespace Microsoft.Build.UnitTests
 {
diff --git a/src/Tasks.UnitTests/StreamMappedString_Tests.cs b/src/Tasks.UnitTests/StreamMappedString_Tests.cs
index b5c6b9da473..b0a3c35c662 100644
--- a/src/Tasks.UnitTests/StreamMappedString_Tests.cs
+++ b/src/Tasks.UnitTests/StreamMappedString_Tests.cs
@@ -3,12 +3,6 @@
 
 using System;
 using System.IO;
-using System.Reflection;
-using System.Collections;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
-using System.Text.RegularExpressions;
 using Microsoft.Build.Shared.LanguageParser;
 using Xunit;
 
diff --git a/src/Tasks.UnitTests/TlbImp_Tests.cs b/src/Tasks.UnitTests/TlbImp_Tests.cs
index 3d5e2d8138d..92ad2f58b80 100644
--- a/src/Tasks.UnitTests/TlbImp_Tests.cs
+++ b/src/Tasks.UnitTests/TlbImp_Tests.cs
@@ -3,12 +3,7 @@
 
 using System;
 using System.IO;
-using System.Reflection;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
-using System.Text.RegularExpressions;
-using System.Globalization;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.AxTlbImp_Tests
diff --git a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
index 96ccee06a50..40644c9b2d9 100644
--- a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
+++ b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Reflection;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks.UnitTests/Touch_Tests.cs b/src/Tasks.UnitTests/Touch_Tests.cs
index c866e0189dd..df6124e73f8 100644
--- a/src/Tasks.UnitTests/Touch_Tests.cs
+++ b/src/Tasks.UnitTests/Touch_Tests.cs
@@ -111,8 +111,7 @@ private static FileAttributes GetAttributes(string path)
 
             if (path == myreadonly_txt)
             {
-                a = System.IO.FileAttributes.ReadOnly;
-                return a;
+                return System.IO.FileAttributes.ReadOnly;
             }
 
             Assert.True(false, "Unexpected file attributes: " + path);
diff --git a/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs b/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs
index 8da3db927bf..86b21f27b45 100644
--- a/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs
+++ b/src/Tasks.UnitTests/VisualBasicParserUtilitites_Tests.cs
@@ -1,14 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO;
-using System.Reflection;
-using System.Collections;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
-using System.Text.RegularExpressions;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
diff --git a/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs b/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs
index 60d2775f719..238556c4cdb 100644
--- a/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs
+++ b/src/Tasks.UnitTests/VisualBasicTokenizer_Tests.cs
@@ -2,13 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Reflection;
-using System.Collections;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Tasks;
-using Microsoft.Build.Utilities;
-using System.Text.RegularExpressions;
 
 using Microsoft.Build.Shared.LanguageParser;
 using Xunit;
diff --git a/src/Tasks.UnitTests/WinMDExp_Tests.cs b/src/Tasks.UnitTests/WinMDExp_Tests.cs
index ff2c26a4693..dbbe15cb777 100644
--- a/src/Tasks.UnitTests/WinMDExp_Tests.cs
+++ b/src/Tasks.UnitTests/WinMDExp_Tests.cs
@@ -2,14 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
-using System.Reflection;
-using System.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
-using System.Text.RegularExpressions;
-using System.Globalization;
 using Xunit;
 using Microsoft.Build.Shared;
 
diff --git a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
index 9e7f41c1eb8..bf668ed0950 100644
--- a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
+++ b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
@@ -3,13 +3,10 @@
 
 using System;
 using System.IO;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 using Xunit;
-using System.Collections.Generic;
 using System.Linq;
 using System.Runtime.InteropServices;
 using Shouldly;
@@ -619,7 +616,10 @@ public void OneAttributePositionalAndNamedParams()
             string content = File.ReadAllText(task.OutputFile.ItemSpec);
             Console.WriteLine(content);
 
-            CheckContentCSharp(content, @"[assembly: AssemblyTrademarkAttribute(""Microsoft"", Date=""2009"", Copyright=""(C)"")]");
+            // NOTE: order here is defined by dictionary traversal order and may change
+            // based on implementation details there, but named parameters can have different
+            // orders so that's ok.
+            CheckContentCSharp(content, @"[assembly: AssemblyTrademarkAttribute(""Microsoft"", Copyright=""(C)"", Date=""2009"")]");
 
             File.Delete(task.OutputFile.ItemSpec);
         }
diff --git a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
index ab6b6c95d2b..bb96a257fe6 100644
--- a/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
+++ b/src/Tasks.UnitTests/WriteLinesToFile_Tests.cs
@@ -1,7 +1,5 @@
 ﻿using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
diff --git a/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs b/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs
index 5d0a4375577..3db0accefe3 100644
--- a/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs
+++ b/src/Tasks.UnitTests/XamlDataDrivenToolTask_Tests.cs
@@ -2,25 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Text;
-using System.Xml;
 using System.IO;
-using System.Runtime.Remoting;
-using System.Globalization;
 using System.Reflection;
-
-using System.CodeDom;
-using System.CodeDom.Compiler;
-using System.Xaml;
-
-using Microsoft.CSharp;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Tasks.Xaml;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.XamlDataDrivenToolTask_Tests
diff --git a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
index f5f983078e7..981b8fb02e3 100644
--- a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
@@ -3,13 +3,10 @@
 
 using System;
 using System.Collections.Generic;
-using System.Text;
 using Microsoft.Build.Framework;
-using System.Xml;
 using System.IO;
 using System.CodeDom;
 using System.CodeDom.Compiler;
-using System.Linq;
 using Microsoft.CSharp;
 using System.Reflection;
 using Microsoft.Build.Shared;
diff --git a/src/Tasks.UnitTests/XmlPeek_Tests.cs b/src/Tasks.UnitTests/XmlPeek_Tests.cs
index 16e232bdc47..1aec24c15b7 100644
--- a/src/Tasks.UnitTests/XmlPeek_Tests.cs
+++ b/src/Tasks.UnitTests/XmlPeek_Tests.cs
@@ -1,20 +1,10 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.UnitTests;
 using Microsoft.Build.Utilities;
-using Microsoft.Build.Shared;
 using System;
-using System.CodeDom.Compiler;
-using System.Collections.Generic;
-using System.Reflection;
-using System.Reflection.Emit;
 using System.IO;
-using System.Text.RegularExpressions;
-using System.Text;
-using System.Xml;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
diff --git a/src/Tasks.UnitTests/XmlPoke_Tests.cs b/src/Tasks.UnitTests/XmlPoke_Tests.cs
index a77409a28fc..98b16aaacc0 100644
--- a/src/Tasks.UnitTests/XmlPoke_Tests.cs
+++ b/src/Tasks.UnitTests/XmlPoke_Tests.cs
@@ -1,20 +1,14 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
-using Microsoft.Build.Tasks;
-using Microsoft.Build.UnitTests;
-using Microsoft.Build.Utilities;
-using Microsoft.Build.Shared;
 using System;
-using System.CodeDom.Compiler;
 using System.Collections.Generic;
-using System.Reflection;
-using System.Reflection.Emit;
 using System.IO;
 using System.Linq;
-using System.Text;
 using System.Xml;
+using Microsoft.Build.Tasks;
+using Microsoft.Build.Utilities;
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -23,16 +17,16 @@ sealed public class XmlPoke_Tests
     {
         private const string XmlNamespaceUsedByTests = "http://nsurl";
 
-        private string _xmlFileWithNs = $@"<?xml version='1.0' encoding='utf-8'?>
+        private const string _xmlFileWithNs = @"<?xml version='1.0' encoding='utf-8'?>
         
-<class AccessModifier='public' Name='test' xmlns:s='{XmlNamespaceUsedByTests}'>
+<class AccessModifier='public' Name='test' xmlns:s='" + XmlNamespaceUsedByTests + @"'>
   <s:variable Type='String' Name='a'></s:variable>
   <s:variable Type='String' Name='b'></s:variable>
   <s:variable Type='String' Name='c'></s:variable>
   <method AccessModifier='public static' Name='GetVal' />
 </class>";
 
-        private string _xmlFileNoNs = @"<?xml version='1.0' encoding='utf-8'?>
+        private const string _xmlFileNoNs = @"<?xml version='1.0' encoding='utf-8'?>
         
 <class AccessModifier='public' Name='test'>
   <variable Type='String' Name='a'></variable>
@@ -56,9 +50,11 @@ public void PokeWithNamespace()
 
             List<XmlAttribute> nodes = xmlDocument.SelectNodes(query, ns)?.Cast<XmlAttribute>().ToList();
 
-            Assert.True(nodes?.Count == 3, $"There should be 3 <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.Count.ShouldBe(3, $"There should be 3 <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
 
-            Assert.True(nodes?.All(i => i.Value.Equals("Mert")), $"All <variable /> elements should have Name=\"Mert\" {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldAllBe(i => i.Value.Equals("Mert"), $"All <variable /> elements should have Name=\"Mert\" {Environment.NewLine}{xmlDocument.OuterXml}");
         }
 
         [Fact]
@@ -72,9 +68,11 @@ public void PokeNoNamespace()
 
             List<XmlAttribute> nodes = xmlDocument.SelectNodes(query)?.Cast<XmlAttribute>().ToList();
 
-            Assert.True(nodes?.Count == 3, $"There should be 3 <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.Count.ShouldBe(3, $"There should be 3 <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
 
-            Assert.True(nodes?.All(i => i.Value.Equals(value)), $"All <variable /> elements should have Name=\"{value}\" {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldAllBe(i => i.Value.Equals(value), $"All <variable /> elements should have Name=\"{value}\" {Environment.NewLine}{xmlDocument.OuterXml}");
         }
 
         [Fact]
@@ -87,9 +85,11 @@ public void PokeAttribute()
 
             List<XmlAttribute> nodes = xmlDocument.SelectNodes(query)?.Cast<XmlAttribute>().ToList();
 
-            Assert.True(nodes?.Count == 1, $"There should be 1 <class /> element with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <class /> elements with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
 
-            Assert.Equal(value, nodes?.First().Value);
+            nodes.Count.ShouldBe(1, $"There should be 1 <class /> element with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes[0].Value.ShouldBe(value);
         }
 
         [Fact]
@@ -102,13 +102,35 @@ public void PokeChildren()
 
             List<XmlElement> nodes = xmlDocument.SelectNodes(query)?.Cast<XmlElement>().ToList();
 
-            Assert.True(nodes?.Count == 1, $"There should be 1 <class /> element {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <class /> elements {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.Count.ShouldBe(1, $"There should be 1 <class /> element {Environment.NewLine}{xmlDocument.OuterXml}");
 
             var testNodes = nodes?.First().ChildNodes.Cast<XmlElement>().ToList();
 
-            Assert.True(testNodes?.Count == 1, $"There should be 1 <class /> element with one child Test element {Environment.NewLine}{xmlDocument.OuterXml}");
+            testNodes.ShouldNotBeNull($"There should be <class /> elements with one child Test element {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            testNodes.Count.ShouldBe(1, $"There should be 1 <class /> element with one child Test element {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            testNodes[0].InnerText.ShouldBe("Testing");
+        }
+
+        [Fact]
+        public void PokeAttributeWithCondition()
+        {
+            const string original = "b";
+            const string value = "x";
+            const string queryTemplate = "/class/variable[@Name='{0}']/@Name";
+
+            XmlDocument xmlDocument = ExecuteXmlPoke(query: string.Format(queryTemplate, original), value: value);
+
+            List<XmlAttribute> nodes = xmlDocument.SelectNodes(string.Format(queryTemplate, value))?.Cast<XmlAttribute>().ToList();
+
+            nodes.ShouldNotBeNull($"There should be <class /> element with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.Count.ShouldBe(1, $"There should be 1 <class /> element with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
 
-            Assert.Equal("Testing", testNodes?.First().InnerText);
+            nodes[0].Value.ShouldBe(value);
         }
 
         [Fact]
@@ -138,23 +160,14 @@ public void PokeMissingParams()
                     p.Value = new TaskItem("Mert");
                 }
 
-                bool exceptionThrown = false;
-                try
-                {
-                    p.Execute();
-                }
-                catch (ArgumentNullException)
-                {
-                    exceptionThrown = true;
-                }
-
+                // "Expecting argumentnullexception for the first 7 tests"
                 if (i < 7)
                 {
-                    Assert.True(exceptionThrown); // "Expecting argumentnullexception for the first 7 tests"
+                    Should.Throw<ArgumentNullException>(() => p.Execute());
                 }
                 else
                 {
-                    Assert.False(exceptionThrown); // "Expecting argumentnullexception for the first 7 tests"
+                    Should.NotThrow(() => p.Execute());
                 }
             }
         }
@@ -171,12 +184,11 @@ public void ErrorInNamespaceDecl()
             p.XmlInputPath = new TaskItem(xmlInputPath);
             p.Query = "//s:variable/@Name";
             p.Namespaces = "<!THIS IS ERROR Namespace Prefix=\"s\" Uri=\"http://nsurl\" />";
-            Assert.Equal("<!THIS IS ERROR Namespace Prefix=\"s\" Uri=\"http://nsurl\" />", p.Namespaces);
+            p.Namespaces.ShouldBe("<!THIS IS ERROR Namespace Prefix=\"s\" Uri=\"http://nsurl\" />");
             p.Value = new TaskItem("Nur");
 
-            bool executeResult = p.Execute();
-            Assert.Contains("MSB3731", engine.Log);
-            Assert.False(executeResult); // "Execution should've failed"
+            p.Execute().ShouldBeFalse(); // "Execution should've failed"
+            engine.AssertLogContains("MSB3731");
         }
 
         [Fact]
@@ -192,8 +204,8 @@ public void PokeNoNSWPrefixedQueryError()
             p.XmlInputPath = new TaskItem(xmlInputPath);
             p.Query = "//s:variable/@Name";
             p.Value = new TaskItem("Nur");
-            Assert.False(p.Execute()); // "Test should've failed"
-            Assert.True(engine.Log.Contains("MSB3732"), "Engine log should contain error code MSB3732 " + engine.Log);
+            p.Execute().ShouldBeFalse(); // "Test should've failed"
+            engine.AssertLogContains("MSB3732");
         }
 
         [Fact]
@@ -225,11 +237,11 @@ public void MissingNamespaceParameters()
 
                 if (i == 3)
                 {
-                    Assert.True(result); // "Only 3rd value should pass."
+                    result.ShouldBeTrue(); // "Only 3rd value should pass."
                 }
                 else
                 {
-                    Assert.False(result); // "Only 3rd value should pass."
+                    result.ShouldBeFalse(); // "Only 3rd value should pass."
                 }
             }
         }
@@ -245,11 +257,13 @@ public void PokeElement()
 
             List<XmlElement> nodes = xmlDocument.SelectNodes(query)?.Cast<XmlElement>().ToList();
 
-            Assert.True(nodes?.Count == 3, $"There should be 3 <variable/> elements {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <variable/> elements {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.Count.ShouldBe(3, $"There should be 3 <variable/> elements {Environment.NewLine}{xmlDocument.OuterXml}");
 
             foreach (var node in nodes)
             {
-                Assert.Equal(value, node.InnerXml);
+                node.InnerXml.ShouldBe(value);
             }
         }
 
@@ -270,7 +284,7 @@ public void PokeWithoutUsingTask()
             logger.AssertLogDoesntContain("MSB4036");
         }
 
-        private void Prepare(string xmlFile, out string xmlInputPath)
+        private static void Prepare(string xmlFile, out string xmlInputPath)
         {
             string dir = Path.Combine(Path.GetTempPath(), DateTime.Now.Ticks.ToString());
             Directory.CreateDirectory(dir);
@@ -285,7 +299,7 @@ private void Prepare(string xmlFile, out string xmlInputPath)
         /// <param name="useNamespace"><code>true</code> to use namespaces, otherwise <code>false</code> (Default).</param>
         /// <param name="value">The value to use.</param>
         /// <returns>An <see cref="XmlDocument"/> containing the resulting XML after the XmlPoke task has executed.</returns>
-        private XmlDocument ExecuteXmlPoke(string query, bool useNamespace = false, string value = null)
+        private static XmlDocument ExecuteXmlPoke(string query, bool useNamespace = false, string value = null)
         {
             MockEngine engine = new MockEngine(true);
 
diff --git a/src/Tasks.UnitTests/XslTransformation_Tests.cs b/src/Tasks.UnitTests/XslTransformation_Tests.cs
index a4e0fb53426..5fc54d6dfcf 100644
--- a/src/Tasks.UnitTests/XslTransformation_Tests.cs
+++ b/src/Tasks.UnitTests/XslTransformation_Tests.cs
@@ -1,9 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.UnitTests;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
 using System;
@@ -13,7 +11,6 @@
 using System.Reflection.Emit;
 using System.IO;
 using System.Text.RegularExpressions;
-using System.Text;
 using System.Xml.Xsl;
 using System.Xml;
 using Xunit;
@@ -1126,16 +1123,12 @@ private void Compile(string inputFile, string outputFile)
 
             // Create TypeBuilder and compile the stylesheet into it
             TypeBuilder typeBldr = modBldr.DefineType(CompiledQueryName, TypeAttributes.Public | TypeAttributes.Abstract | TypeAttributes.Sealed | TypeAttributes.BeforeFieldInit);
-
-            CompilerErrorCollection errors = null;
             try
             {
-                using (XmlReader reader = XmlReader.Create(sourceUri, readerSettings))
-                {
-                    errors = XslCompiledTransform.CompileToType(
-                        reader, xsltSettings, xmlResolver, false, typeBldr, scriptAsmPath
-                    );
-                }
+                using XmlReader reader = XmlReader.Create(sourceUri, readerSettings);
+                CompilerErrorCollection errors = XslCompiledTransform.CompileToType(reader, xsltSettings,
+                                                                                    xmlResolver, false, typeBldr,
+                                                                                    scriptAsmPath);
             }
             catch (Exception e)
             {
diff --git a/src/Tasks/Al.cs b/src/Tasks/Al.cs
index 85136a7d6e6..0d62166eea0 100644
--- a/src/Tasks/Al.cs
+++ b/src/Tasks/Al.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
diff --git a/src/Tasks/AppConfig/AppConfig.cs b/src/Tasks/AppConfig/AppConfig.cs
index 88df2dd738b..cf9f406003f 100644
--- a/src/Tasks/AppConfig/AppConfig.cs
+++ b/src/Tasks/AppConfig/AppConfig.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 using System.Xml;
 
 using Microsoft.Build.Shared;
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
index dced5e5453e..82fbcc95204 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
@@ -15,11 +15,11 @@ internal class AssemblyFoldersResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        /// <param name="searchPathElement"></param>
-        /// <param name="getAssemblyName"></param>
-        /// <param name="fileExists"></param>
-        /// <param name="getRuntimeVersion"></param>
-        /// <param name="targetedRuntimeVesion"></param>
+        /// <param name="searchPathElement">The corresponding element from the search path.</param>
+        /// <param name="getAssemblyName">Delegate that gets the assembly name.</param>
+        /// <param name="fileExists">Delegate that returns if the file exists.</param>
+        /// <param name="getRuntimeVersion">Delegate that returns the clr runtime version for the file.</param>
+        /// <param name="targetedRuntimeVesion">The targeted runtime version.</param>
         public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
             : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
         {
diff --git a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
index eb126f0656a..23ccac23cb2 100644
--- a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
+++ b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
@@ -23,11 +23,11 @@ internal class CandidateAssemblyFilesResolver : Resolver
         /// Construct.
         /// </summary>
         /// <param name="candidateAssemblyFiles">List of literal assembly file names to be considered when SearchPaths has {CandidateAssemblyFiles}.</param>
-        /// <param name="searchPathElement"></param>
-        /// <param name="getAssemblyName"></param>
-        /// <param name="fileExists"></param>
-        /// <param name="getRuntimeVersion"></param>
-        /// <param name="targetedRuntimeVesion"></param>
+        /// <param name="searchPathElement">The corresponding element from the search path.</param>
+        /// <param name="getAssemblyName">Delegate that gets the assembly name.</param>
+        /// <param name="fileExists">Delegate that returns if the file exists.</param>
+        /// <param name="getRuntimeVersion">Delegate that returns the clr runtime version for the file.</param>
+        /// <param name="targetedRuntimeVesion">The targeted runtime version.</param>
         public CandidateAssemblyFilesResolver(string[] candidateAssemblyFiles, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
             : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
         {
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index 96b53b98a28..f24bb0cff16 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 using System.Collections.Generic;
 using System.Linq;
 using System.Xml.Linq;
diff --git a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
index 24e3b06dade..b0da1661f29 100644
--- a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
+++ b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
@@ -134,7 +134,7 @@ private static SortedDictionary<Version, SortedDictionary<AssemblyNameExtension,
                         {
                             if (targetedRuntime.CompareTo(runtimeVersion) >= 0 || specificVersion)
                             {
-                                SortedDictionary<AssemblyNameExtension, string> assembliesWithRuntime = null;
+                                SortedDictionary<AssemblyNameExtension, string> assembliesWithRuntime;
                                 assembliesWithValidRuntimes.TryGetValue(runtimeVersion, out assembliesWithRuntime);
 
                                 // Create a new list if one does not exist.
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 5b5c4d57fd0..a842843a021 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -102,7 +102,7 @@ internal sealed class ReferenceTable
         /// </summary>
         private readonly IsWinMDFile _isWinMDFile;
 
-        /// <summary>version of the framework targeted by this project</summary>
+        /// <summary>Version of the framework targeted by this project.</summary>
         private readonly Version _projectTargetFramework;
 
         /// <summary>
@@ -111,7 +111,7 @@ internal sealed class ReferenceTable
         private readonly FrameworkNameVersioning _targetFrameworkMoniker;
 
         /// <summary>
-        /// Logging helper to allow the logging of meessages from the Reference Table
+        /// Logging helper to allow the logging of meessages from the Reference Table.
         /// </summary>
         private readonly TaskLoggingHelper _log;
 
@@ -186,10 +186,10 @@ internal sealed class ReferenceTable
         /// <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
         /// <param name="allowedAssemblyExtensions"></param>
         /// <param name="getRuntimeVersion"></param>
-        /// <param name="targetedRuntimeVersion"></param>
-        /// <param name="projectTargetFramework"></param>
-        /// <param name="targetFrameworkMoniker"></param>
-        /// <param name="log"></param>
+        /// <param name="targetedRuntimeVersion">Version of the runtime to target.</param>
+        /// <param name="projectTargetFramework">Version of the framework targeted by the project.</param>
+        /// <param name="targetFrameworkMoniker">Target framework moniker we are targeting.</param>
+        /// <param name="log">Logging helper to allow the logging of meessages from the Reference Table.</param>
         /// <param name="latestTargetFrameworkDirectories"></param>
         /// <param name="copyLocalDependenciesWhenParentReferenceInGac"></param>
         /// <param name="doNotCopyLocalIfInGac"></param>
@@ -224,10 +224,10 @@ internal sealed class ReferenceTable
         /// <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
         /// <param name="allowedAssemblyExtensions"></param>
         /// <param name="getRuntimeVersion"></param>
-        /// <param name="targetedRuntimeVersion"></param>
-        /// <param name="projectTargetFramework"></param>
-        /// <param name="targetFrameworkMoniker"></param>
-        /// <param name="log"></param>
+        /// <param name="targetedRuntimeVersion">Version of the runtime to target.</param>
+        /// <param name="projectTargetFramework">Version of the framework targeted by the project.</param>
+        /// <param name="targetFrameworkMoniker">Target framework moniker we are targeting.</param>
+        /// <param name="log">Logging helper to allow the logging of meessages from the Reference Table.</param>
         /// <param name="latestTargetFrameworkDirectories"></param>
         /// <param name="copyLocalDependenciesWhenParentReferenceInGac"></param>
         /// <param name="doNotCopyLocalIfInGac"></param>
@@ -565,8 +565,7 @@ ITaskItem referenceAssemblyName
             AssemblyNameExtension assemblyName = null;
             string fusionName = referenceAssemblyName.GetMetadata(ItemMetadataNames.fusionName);
             bool result = MetadataConversionUtilities.TryConvertItemMetadataToBool(referenceAssemblyName, ItemMetadataNames.IgnoreVersionForFrameworkReference, out bool metadataFound);
-            bool ignoreVersionForFrameworkReference = false;
-
+            bool ignoreVersionForFrameworkReference;
             if (metadataFound)
             {
                 ignoreVersionForFrameworkReference = result;
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index c88ed99568e..90af55781f5 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -7,6 +7,7 @@
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using System.Reflection;
 using System.Text;
 using System.Xml.Linq;
@@ -441,6 +442,18 @@ public string TargetedRuntimeVersion
             set { _targetedRuntimeVersionRawValue = value; }
         }
 
+        /// <summary>
+        /// If not null, serializes information about <see cref="AssemblyFiles" /> inputs to the named file.
+        /// This overrides the usual outputs, so do not use this unless you are building an SDK with many references.
+        /// </summary>
+        public string AssemblyInformationCacheOutputPath { get; set; }
+
+        /// <summary>
+        /// If not null, uses this set of caches as inputs if RAR cannot find the usual cache in the obj folder. Typically
+        /// used for demos and first-run scenarios.
+        /// </summary>
+        public ITaskItem[] AssemblyInformationCachePaths { get; set; }
+
         /// <summary>
         /// List of locations to search for assemblyFiles when resolving dependencies.
         /// The following types of things can be passed in here:
@@ -963,16 +976,31 @@ quiet at the engine level.
 
                         if (conflictCandidate.IsConflictVictim)
                         {
-                            LogConflict(conflictCandidate, fusionName);
+                            bool logWarning = idealAssemblyRemappingsIdentities.Any(i => i.assemblyName.FullName.Equals(fusionName) && i.reference.GetConflictVictims().Count == 0);
+                            StringBuilder logConflict = StringBuilderCache.Acquire();
+                            LogConflict(conflictCandidate, fusionName, logConflict);
+                            StringBuilder logDependencies = logWarning ? logConflict.AppendLine() : StringBuilderCache.Acquire();
 
                             // Log the assemblies and primary source items which are related to the conflict which was just logged.
                             Reference victor = dependencyTable.GetReference(conflictCandidate.ConflictVictorName);
 
                             // Log the winner of the conflict resolution, the source items and dependencies which caused it
-                            LogReferenceDependenciesAndSourceItems(conflictCandidate.ConflictVictorName.FullName, victor);
+                            LogReferenceDependenciesAndSourceItemsToStringBuilder(conflictCandidate.ConflictVictorName.FullName, victor, logDependencies);
 
                             // Log the reference which lost the conflict and the dependencies and source items which caused it.
-                            LogReferenceDependenciesAndSourceItems(fusionName, conflictCandidate);
+                            LogReferenceDependenciesAndSourceItemsToStringBuilder(fusionName, conflictCandidate, logDependencies.AppendLine());
+
+                            if (logWarning)
+                            {
+                                // This warning is logged regardless of AutoUnify since it means a conflict existed where the reference	
+                                // chosen was not the conflict victor in a version comparison. In other words, the victor was older.
+                                Log.LogWarningWithCodeFromResources("ResolveAssemblyReference.FoundConflicts", assemblyName.Name, StringBuilderCache.GetStringAndRelease(logConflict));
+                            }
+                            else
+                            {
+                                Log.LogMessage(ChooseReferenceLoggingImportance(conflictCandidate), StringBuilderCache.GetStringAndRelease(logConflict));
+                                Log.LogMessage(MessageImportance.Low, StringBuilderCache.GetStringAndRelease(logDependencies));
+                            }
                         }
                     }
 
@@ -1055,13 +1083,6 @@ quiet at the engine level.
                                     }
                                 }
                             }
-
-                            if (conflictVictims.Count == 0)
-                            {
-                                // This warning is logged regardless of AutoUnify since it means a conflict existed where the reference
-                                // chosen was not the conflict victor in a version comparison, in other words it was older.
-                                Log.LogWarningWithCodeFromResources("ResolveAssemblyReference.FoundConflicts", idealRemappingPartialAssemblyName.Name);
-                            }
                         }
 
                         // Log the warning
@@ -1151,27 +1172,27 @@ internal static string ByteArrayToString(byte[] a)
         /// <summary>
         /// Log the source items and dependencies which lead to a given item.
         /// </summary>
-        private void LogReferenceDependenciesAndSourceItems(string fusionName, Reference conflictCandidate)
+        private void LogReferenceDependenciesAndSourceItemsToStringBuilder(string fusionName, Reference conflictCandidate, StringBuilder log)
         {
             ErrorUtilities.VerifyThrowInternalNull(conflictCandidate, "ConflictCandidate");
-            Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.FourSpaceIndent", ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ReferenceDependsOn", fusionName, conflictCandidate.FullPath));
+            log.Append(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.FourSpaceIndent", ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ReferenceDependsOn", fusionName, conflictCandidate.FullPath)));
 
             if (conflictCandidate.IsPrimary)
             {
                 if (conflictCandidate.IsResolved)
                 {
-                    LogDependeeReference(conflictCandidate);
+                    LogDependeeReferenceToStringBuilder(conflictCandidate, log);
                 }
                 else
                 {
-                    Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.EightSpaceIndent", ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.UnResolvedPrimaryItemSpec", conflictCandidate.PrimarySourceItem));
+                    log.AppendLine().Append(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.EightSpaceIndent", ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.UnResolvedPrimaryItemSpec", conflictCandidate.PrimarySourceItem)));
                 }
             }
 
             // Log the references for the conflict victim
             foreach (Reference dependeeReference in conflictCandidate.GetDependees())
             {
-                LogDependeeReference(dependeeReference);
+                LogDependeeReferenceToStringBuilder(dependeeReference, log);
             }
         }
 
@@ -1179,14 +1200,15 @@ private void LogReferenceDependenciesAndSourceItems(string fusionName, Reference
         /// Log the dependee and the item specs which caused the dependee reference to be resolved.
         /// </summary>
         /// <param name="dependeeReference"></param>
-        private void LogDependeeReference(Reference dependeeReference)
+        /// <param name="log">The means by which messages should be logged.</param>
+        private void LogDependeeReferenceToStringBuilder(Reference dependeeReference, StringBuilder log)
         {
-            Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.EightSpaceIndent", dependeeReference.FullPath);
+            log.AppendLine().AppendLine(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.EightSpaceIndent", dependeeReference.FullPath));
 
-            Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.TenSpaceIndent", ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.PrimarySourceItemsForReference", dependeeReference.FullPath));
+            log.Append(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.TenSpaceIndent", ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.PrimarySourceItemsForReference", dependeeReference.FullPath)));
             foreach (ITaskItem sourceItem in dependeeReference.GetSourceItems())
             {
-                Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.TwelveSpaceIndent", sourceItem.ItemSpec);
+                log.AppendLine().Append(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.TwelveSpaceIndent", sourceItem.ItemSpec));
             }
         }
 
@@ -1786,26 +1808,24 @@ private void LogImageRuntime(Reference reference, MessageImportance importance)
         /// </summary>
         /// <param name="reference">The reference.</param>
         /// <param name="fusionName">The fusion name of the reference.</param>
-        private void LogConflict(Reference reference, string fusionName)
+        /// <param name="log">StringBuilder holding information to be logged.</param>
+        private void LogConflict(Reference reference, string fusionName, StringBuilder log)
         {
-            // Set an importance level to be used for secondary messages.
-            MessageImportance importance = ChooseReferenceLoggingImportance(reference);
-
-            Log.LogMessageFromResources(importance, "ResolveAssemblyReference.ConflictFound", reference.ConflictVictorName, fusionName);
+            log.Append(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ConflictFound", reference.ConflictVictorName, fusionName));
             switch (reference.ConflictLossExplanation)
             {
                 case ConflictLossReason.HadLowerVersion:
                     {
                         Debug.Assert(!reference.IsPrimary, "A primary reference should never lose a conflict because of version. This is an insoluble conflict instead.");
                         string message = Log.FormatResourceString("ResolveAssemblyReference.ConflictHigherVersionChosen", reference.ConflictVictorName);
-                        Log.LogMessageFromResources(importance, "ResolveAssemblyReference.FourSpaceIndent", message);
+                        log.AppendLine().Append(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.FourSpaceIndent", message));
                         break;
                     }
 
                 case ConflictLossReason.WasNotPrimary:
                     {
                         string message = Log.FormatResourceString("ResolveAssemblyReference.ConflictPrimaryChosen", reference.ConflictVictorName, fusionName);
-                        Log.LogMessageFromResources(importance, "ResolveAssemblyReference.FourSpaceIndent", message);
+                        log.AppendLine().Append(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.FourSpaceIndent", message));
                         break;
                     }
 
@@ -1820,9 +1840,7 @@ private void LogConflict(Reference reference, string fusionName)
                     {
                         // For dependencies, adding an app.config entry could help. Log a comment, there will be
                         // a summary warning later on.
-                        string message;
-                        string code = Log.ExtractMessageCode(Log.FormatResourceString("ResolveAssemblyReference.ConflictUnsolvable", reference.ConflictVictorName, fusionName), out message);
-                        Log.LogMessage(MessageImportance.High, message);
+                        log.AppendLine().Append(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ConflictUnsolvable", reference.ConflictVictorName, fusionName));
                     }
                     break;
                 // Can happen if one of the references has a dependency with the same simplename, and version but no publickeytoken and the other does.
@@ -2443,13 +2461,13 @@ private AssemblyNameExtension[] GetDependencies(Reference resolvedReference, Fil
             AssemblyNameExtension[] result = null;
             if (resolvedReference?.IsPrimary == true && !resolvedReference.IsBadImage)
             {
-                System.Runtime.Versioning.FrameworkName frameworkName = null;
-                string[] scatterFiles = null;
                 try
                 {
                     // in case of P2P that have not build the reference can be resolved but file does not exist on disk. 
                     if (fileExists(resolvedReference.FullPath))
                     {
+                        FrameworkNameVersioning frameworkName;
+                        string[] scatterFiles;
                         getAssemblyMetadata(resolvedReference.FullPath, assemblyMetadataCache, out result, out scatterFiles, out frameworkName);
                     }
                 }
@@ -2753,7 +2771,7 @@ private void PopulateSuggestedRedirects(List<DependentAssembly> idealAssemblyRem
                     List<AssemblyNameExtension> conflictVictims = reference.GetConflictVictims();
 
                     // Skip any remapping that has no conflict victims since a redirect will not help.
-                    if (null == conflictVictims || 0 == conflictVictims.Count)
+                    if (conflictVictims == null || 0 == conflictVictims.Count)
                     {
                         continue;
                     }
diff --git a/src/Tasks/AssemblyInfo.cs b/src/Tasks/AssemblyInfo.cs
index ea3d84521ab..6a11208e44d 100644
--- a/src/Tasks/AssemblyInfo.cs
+++ b/src/Tasks/AssemblyInfo.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
 using System.Resources;
 using System.Runtime.InteropServices;
 using System.Runtime.CompilerServices;
@@ -13,7 +12,6 @@
 [assembly: GuidAttribute("E3D4D3B9-944C-407b-A82E-B19719EA7FB3")]
 
 [assembly: InternalsVisibleTo("Microsoft.Build.Tasks.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
-[assembly: InternalsVisibleTo("Microsoft.Build.Tasks.Whidbey.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 
 // This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly, 
 // so that we don't run into known security issues with loading libraries from unsafe locations 
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index 096efe5a0b7..ee5446c50e8 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -133,7 +133,10 @@ public override bool Execute()
                     Culture.ItemCultureInfo info = Culture.GetItemCultureInfo
                         (
                             AssignedFiles[i].ItemSpec,
-                            dependentUpon
+                            dependentUpon,
+                            // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
+                            // https://github.com/dotnet/msbuild/issues/3064
+                            AssignedFiles[i].GetMetadata("WithCulture").Equals("false", StringComparison.OrdinalIgnoreCase)
                         );
 
                     if (!string.IsNullOrEmpty(info.culture))
@@ -169,7 +172,7 @@ public override bool Execute()
                 {
                     Debug.Assert(false, "Unexpected exception in AssignCulture.Execute. " + 
                         "Please log a MSBuild bug specifying the steps to reproduce the problem. " + 
-                        e.Message);
+                        e);
                     throw;
                 }
 #endif
diff --git a/src/Tasks/AxReference.cs b/src/Tasks/AxReference.cs
index 5cb6271b1fc..2b7b15cd61a 100644
--- a/src/Tasks/AxReference.cs
+++ b/src/Tasks/AxReference.cs
@@ -58,7 +58,6 @@ protected override string GetWrapperFileNameInternal(string typeLibName)
         /// </summary>
         internal bool GenerateWrapper(out ComReferenceWrapperInfo wrapperInfo)
         {
-            wrapperInfo = null;
 
             // The tool gets the public key for itself, but we get it here anyway to
             // give nice messages in errors cases.
diff --git a/src/Tasks/AxTlbBaseReference.cs b/src/Tasks/AxTlbBaseReference.cs
index 09a2e87204f..d0aa26be0fd 100644
--- a/src/Tasks/AxTlbBaseReference.cs
+++ b/src/Tasks/AxTlbBaseReference.cs
@@ -248,8 +248,6 @@ internal static string GetWrapperFileName(string interopDllHeader, string typeLi
         /// </summary>
         internal void GetAndValidateStrongNameKey(out StrongNameKeyPair keyPair, out byte[] publicKey)
         {
-            keyPair = null;
-            publicKey = null;
 
             // get key pair/public key
             StrongNameUtils.GetStrongNameKey(Log, KeyFile, KeyContainer, out keyPair, out publicKey);
diff --git a/src/Tasks/AxTlbBaseTask.cs b/src/Tasks/AxTlbBaseTask.cs
index 06937af99a7..5a0b3d0b54c 100644
--- a/src/Tasks/AxTlbBaseTask.cs
+++ b/src/Tasks/AxTlbBaseTask.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 using System.Reflection;
 using Microsoft.Build.Shared.FileSystem;
 
@@ -105,9 +104,7 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
         /// <returns>A string containing the full path of this tool, or null if the tool was not found</returns>
         protected override string GenerateFullPathToTool()
         {
-            string pathToTool = null;
-
-            pathToTool = SdkToolsPathUtility.GeneratePathToTool
+            string pathToTool = SdkToolsPathUtility.GeneratePathToTool
             (
                 SdkToolsPathUtility.FileInfoExists,
                 Utilities.ProcessorArchitecture.CurrentProcessArchitecture,
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index 974e99b12a7..c3ecc2aac73 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -510,7 +510,7 @@ private void Refresh()
                 StringBuilder productsOrder = new StringBuilder();
                 foreach (Product p in Products)
                 {
-                    productsOrder.Append(p.ProductCode + Environment.NewLine);
+                    productsOrder.Append(p.ProductCode).Append(Environment.NewLine);
                 }
                 DumpStringToFile(productsOrder.ToString(), "BootstrapperInstallOrder.txt", false);
             }
@@ -1945,8 +1945,7 @@ public static string XmlToConfigurationFile(XmlNode input)
                         {
                             // HACKHACK
                             string str = r.ReadToEnd();
-                            str = str.Replace("%NEWLINE%", Environment.NewLine);
-                            return str;
+                            return str.Replace("%NEWLINE%", Environment.NewLine);
                         }
                     }
                 }
diff --git a/src/Tasks/BootstrapperUtil/Product.cs b/src/Tasks/BootstrapperUtil/Product.cs
index 542b9749106..56338f5ca04 100644
--- a/src/Tasks/BootstrapperUtil/Product.cs
+++ b/src/Tasks/BootstrapperUtil/Product.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Globalization;
diff --git a/src/Tasks/CallTarget.cs b/src/Tasks/CallTarget.cs
index e0ff2e5c514..d67f4c61cb0 100644
--- a/src/Tasks/CallTarget.cs
+++ b/src/Tasks/CallTarget.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 
diff --git a/src/Tasks/ComReference.cs b/src/Tasks/ComReference.cs
index c886278ade5..ffa0fb88171 100644
--- a/src/Tasks/ComReference.cs
+++ b/src/Tasks/ComReference.cs
@@ -236,7 +236,6 @@ internal static void GetFuncDescForDescIndex(ITypeInfo typeInfo, int funcIndex,
         /// </summary>
         internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silent, ITypeLib typeLib, string typeLibId, out string typeLibName)
         {
-            typeLibName = "";
 
             // see if the type library supports ITypeLib2
             if (!(typeLib is ITypeLib2 typeLib2))
diff --git a/src/Tasks/CreateCSharpManifestResourceName.cs b/src/Tasks/CreateCSharpManifestResourceName.cs
index af7321ea80e..9837e9b1f2a 100644
--- a/src/Tasks/CreateCSharpManifestResourceName.cs
+++ b/src/Tasks/CreateCSharpManifestResourceName.cs
@@ -39,9 +39,13 @@ Stream binaryStream
         )
         {
             string culture = null;
+            bool treatAsCultureNeutral = false;
             if (fileName != null && itemSpecToTaskitem.TryGetValue(fileName, out ITaskItem item))
             {
                 culture = item.GetMetadata("Culture");
+                // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
+                // https://github.com/dotnet/msbuild/issues/3064
+                treatAsCultureNeutral = item.GetMetadata("WithCulture").Equals("false", StringComparison.OrdinalIgnoreCase);
             }
 
             /*
@@ -59,7 +63,8 @@ The reason is that CreateManifestName can't be static because it is an
                 dependentUponFileName,
                 culture,
                 binaryStream,
-                Log
+                Log,
+                treatAsCultureNeutral
             );
         }
 
@@ -78,6 +83,7 @@ The reason is that CreateManifestName can't be static because it is an
         /// <param name="culture">The override culture of this resource, if any</param>
         /// <param name="binaryStream">File contents binary stream, may be null</param>
         /// <param name="log">Task's TaskLoggingHelper, for logging warnings or errors</param>
+        /// <param name="treatAsCultureNeutral">Whether to treat the current file as 'culture-neutral' and retain the culture in the name.</param>
         /// <returns>Returns the manifest name</returns>
         internal static string CreateManifestNameImpl
         (
@@ -88,7 +94,8 @@ internal static string CreateManifestNameImpl
             string dependentUponFileName, // May be null
             string culture, // may be null 
             Stream binaryStream, // File contents binary stream, may be null
-            TaskLoggingHelper log
+            TaskLoggingHelper log,
+            bool treatAsCultureNeutral = false
         )
         {
             // Use the link file name if there is one, otherwise, fall back to file name.
@@ -99,7 +106,7 @@ TaskLoggingHelper log
             }
 
             dependentUponFileName = FileUtilities.FixFilePath(dependentUponFileName);
-            Culture.ItemCultureInfo info = Culture.GetItemCultureInfo(embeddedFileName, dependentUponFileName);
+            Culture.ItemCultureInfo info = Culture.GetItemCultureInfo(embeddedFileName, dependentUponFileName, treatAsCultureNeutral);
 
             // If the item has a culture override, respect that. 
             if (!string.IsNullOrEmpty(culture))
diff --git a/src/Tasks/CreateItem.cs b/src/Tasks/CreateItem.cs
index 472f4e0c5a8..cb7bd833620 100644
--- a/src/Tasks/CreateItem.cs
+++ b/src/Tasks/CreateItem.cs
@@ -99,7 +99,7 @@ private List<ITaskItem> CreateOutputItems(Dictionary<string, string> metadataTab
                 )
                 {
                     ITaskItem newItem = i;
-                    if (null != metadataTable)
+                    if (metadataTable != null)
                     {
                         foreach (KeyValuePair<string, string> nameAndValue in metadataTable)
                         {
diff --git a/src/Tasks/CreateManifestResourceName.cs b/src/Tasks/CreateManifestResourceName.cs
index f53eee09666..b8b0d2fbf57 100644
--- a/src/Tasks/CreateManifestResourceName.cs
+++ b/src/Tasks/CreateManifestResourceName.cs
@@ -10,7 +10,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
-using System.ComponentModel;
 
 namespace Microsoft.Build.Tasks
 {
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 4d656ba43ee..864450634a1 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -37,9 +37,13 @@ protected override string CreateManifestName
         )
         {
             string culture = null;
+            bool treatAsCultureNeutral = false;
             if (fileName != null && itemSpecToTaskitem.TryGetValue(fileName, out ITaskItem item))
             {
                 culture = item.GetMetadata("Culture");
+                // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
+                // https://github.com/dotnet/msbuild/issues/3064
+                treatAsCultureNeutral = item.GetMetadata("WithCulture").Equals("false", StringComparison.OrdinalIgnoreCase);
             }
 
             /*
@@ -57,7 +61,8 @@ The reason is that CreateManifestName can't be static because it is an
                 dependentUponFileName,
                 culture,
                 binaryStream,
-                Log
+                Log,
+                treatAsCultureNeutral
             );
         }
 
@@ -76,6 +81,7 @@ The reason is that CreateManifestName can't be static because it is an
         /// <param name="culture">The override culture of this resource, if any</param>
         /// <param name="binaryStream">File contents binary stream, may be null</param>
         /// <param name="log">Task's TaskLoggingHelper, for logging warnings or errors</param>
+        /// <param name="treatAsCultureNeutral">Whether to treat the current file as 'culture-neutral' and retain the culture in the name.</param>
         /// <returns>Returns the manifest name</returns>
         internal static string CreateManifestNameImpl
         (
@@ -86,7 +92,8 @@ internal static string CreateManifestNameImpl
             string dependentUponFileName, // May be null
             string culture,
             Stream binaryStream, // File contents binary stream, may be null
-            TaskLoggingHelper log
+            TaskLoggingHelper log,
+            bool treatAsCultureNeutral = false
         )
         {
             // Use the link file name if there is one, otherwise, fall back to file name.
@@ -96,7 +103,7 @@ TaskLoggingHelper log
                 embeddedFileName = fileName;
             }
 
-            Culture.ItemCultureInfo info = Culture.GetItemCultureInfo(embeddedFileName, dependentUponFileName);
+            Culture.ItemCultureInfo info = Culture.GetItemCultureInfo(embeddedFileName, dependentUponFileName, treatAsCultureNeutral);
 
             // If the item has a culture override, respect that. 
             if (!string.IsNullOrEmpty(culture))
diff --git a/src/Tasks/Culture.cs b/src/Tasks/Culture.cs
index 6dc32800ee3..f2635dac38c 100644
--- a/src/Tasks/Culture.cs
+++ b/src/Tasks/Culture.cs
@@ -29,18 +29,20 @@ internal struct ItemCultureInfo
         internal static ItemCultureInfo GetItemCultureInfo
         (
             string name,
-            string dependentUponFilename
+            string dependentUponFilename,
+            bool treatAsCultureNeutral = false
         )
         {
             ItemCultureInfo info;
             info.culture = null;
             string parentName = dependentUponFilename ?? String.Empty;
 
-            if (String.Equals(Path.GetFileNameWithoutExtension(parentName),
+            if (treatAsCultureNeutral || string.Equals(Path.GetFileNameWithoutExtension(parentName),
                                    Path.GetFileNameWithoutExtension(name),
                                    StringComparison.OrdinalIgnoreCase))
             {
-                // Dependent, but we treat it is as not localized because they have same base filename
+                // Dependent but we treat it is as not localized because they have same base filename
+                // Or we want to treat this as a 'culture-neutral' file and retain the culture in the name. https://github.com/dotnet/msbuild/pull/5824
                 info.cultureNeutralFilename = name;
             }
             else
diff --git a/src/Tasks/FileIO/VerifyFileHash.cs b/src/Tasks/FileIO/VerifyFileHash.cs
index 5addbea5571..7bc2370e688 100644
--- a/src/Tasks/FileIO/VerifyFileHash.cs
+++ b/src/Tasks/FileIO/VerifyFileHash.cs
@@ -2,9 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Linq;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
diff --git a/src/Tasks/FileIO/WriteLinesToFile.cs b/src/Tasks/FileIO/WriteLinesToFile.cs
index 97d07788c00..c4fdfbb1a50 100644
--- a/src/Tasks/FileIO/WriteLinesToFile.cs
+++ b/src/Tasks/FileIO/WriteLinesToFile.cs
@@ -5,7 +5,6 @@
 using Microsoft.Build.Shared;
 using System;
 using System.IO;
-using System.Runtime.CompilerServices;
 using System.Text;
 
 namespace Microsoft.Build.Tasks
diff --git a/src/Tasks/FileState.cs b/src/Tasks/FileState.cs
index c979b21be5b..6545558ff30 100644
--- a/src/Tasks/FileState.cs
+++ b/src/Tasks/FileState.cs
@@ -5,7 +5,6 @@
 using System.IO;
 using System.Runtime.InteropServices;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
diff --git a/src/Tasks/FormatUrl.cs b/src/Tasks/FormatUrl.cs
index 788da79089b..4942b3d2bed 100644
--- a/src/Tasks/FormatUrl.cs
+++ b/src/Tasks/FormatUrl.cs
@@ -19,8 +19,13 @@ public sealed class FormatUrl : TaskExtension
 
         public override bool Execute()
         {
+#if RUNTIME_TYPE_NETCORE
+            Log.LogErrorFromResources("TaskRequiresFrameworkFailure", nameof(FormatUrl));
+            return false;
+#else
             OutputUrl = InputUrl != null ? PathUtil.Format(InputUrl) : String.Empty;
             return true;
+#endif
         }
     }
 }
diff --git a/src/Tasks/FxCopExclusions/Microsoft.Build.Tasks.Suppressions.cs b/src/Tasks/FxCopExclusions/Microsoft.Build.Tasks.Suppressions.cs
index 7349ce57fe8..22d44319af5 100644
--- a/src/Tasks/FxCopExclusions/Microsoft.Build.Tasks.Suppressions.cs
+++ b/src/Tasks/FxCopExclusions/Microsoft.Build.Tasks.Suppressions.cs
@@ -5,8 +5,6 @@
 // Add module level suppressions to this file to have them suppressed in the assembly
 //
 
-using System.Diagnostics.CodeAnalysis;
-
 #if CODE_ANALYSIS
 [module: SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="0", Scope="module", Target="microsoft.build.tasks.core.dll", Justification="Already shipped several versions with a name like this")]
 [module: SuppressMessage("Microsoft.Usage","CA1806:DoNotIgnoreMethodResults", MessageId="Microsoft.Build.Tasks.NativeMethods.GetCachePath(Microsoft.Build.Tasks.AssemblyCacheFlags,System.Text.StringBuilder,System.Int32@)", Scope="member", Target="Microsoft.Build.Tasks.GlobalAssemblyCache.#GetGacPath()", Justification="We do not use the method result we use one of the out parameters as a check instead. This is because the method can have a failed hresult but return a object in the out parameter.")]
diff --git a/src/Tasks/GenerateApplicationManifest.cs b/src/Tasks/GenerateApplicationManifest.cs
index 69cdab6c19c..c69fe1a7155 100644
--- a/src/Tasks/GenerateApplicationManifest.cs
+++ b/src/Tasks/GenerateApplicationManifest.cs
@@ -125,7 +125,15 @@ private bool BuildApplicationManifest(ApplicationManifest manifest)
             {
                 foreach (ITaskItem item in Dependencies)
                 {
-                    AddAssemblyFromItem(item);
+                    if (LauncherBasedDeployment)
+                    {
+                        // In Launcher-based deployments, everything needs to be a regular file.
+                        AddFileFromItem(item);
+                    }
+                    else
+                    {
+                        AddAssemblyFromItem(item);
+                    }
                 }
             }
 
diff --git a/src/Tasks/GenerateLauncher.cs b/src/Tasks/GenerateLauncher.cs
new file mode 100644
index 00000000000..12d90d87a3d
--- /dev/null
+++ b/src/Tasks/GenerateLauncher.cs
@@ -0,0 +1,97 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.IO;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Tasks.Deployment.Bootstrapper;
+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
+using Microsoft.Build.Utilities;
+
+namespace Microsoft.Build.Tasks
+{
+    /// <summary>
+    /// Generates a bootstrapper for ClickOnce deployment projects.
+    /// </summary>
+    public sealed class GenerateLauncher : TaskExtension
+    {
+        private const string LAUNCHER_EXE = "Launcher.exe";
+        private const string ENGINE_PATH = "Engine"; // relative to ClickOnce bootstrapper path
+
+        #region Properties
+
+        public ITaskItem EntryPoint { get; set; }
+
+        public string LauncherPath { get; set; }
+
+        public string OutputPath { get; set; }
+
+        public string VisualStudioVersion { get; set; }
+
+        public string AssemblyName { get; set; }
+
+        [Output]
+        public ITaskItem OutputEntryPoint { get; set; }
+        #endregion
+
+        public override bool Execute()
+        {
+            if (LauncherPath == null)
+            {
+                // Launcher lives next to ClickOnce bootstrapper.
+                // GetDefaultPath obtains the root ClickOnce boostrapper path.
+                LauncherPath = Path.Combine(
+                    Microsoft.Build.Tasks.Deployment.Bootstrapper.Util.GetDefaultPath(VisualStudioVersion),
+                    ENGINE_PATH,
+                    LAUNCHER_EXE);
+            }
+
+            if (EntryPoint == null)
+            {
+                Log.LogErrorWithCodeFromResources("GenerateLauncher.InvalidInput");
+                return false;
+            }
+
+            var launcherBuilder = new LauncherBuilder(LauncherPath);
+            string entryPointFileName = Path.GetFileName(EntryPoint.ItemSpec);
+            //
+            // If the EntryPoint specified is apphost.exe or singlefilehost.exe, we need to replace the EntryPoint
+            // with the AssemblyName instead since apphost.exe/singlefilehost.exe is an intermediate file for
+            // for final published {assemblyname}.exe.
+            //
+            if ((entryPointFileName.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase) || 
+                entryPointFileName.Equals(Constants.SingleFileHostExe, StringComparison.InvariantCultureIgnoreCase)) &&
+                !String.IsNullOrEmpty(AssemblyName))
+            {
+                entryPointFileName = AssemblyName;
+            }
+            BuildResults results = launcherBuilder.Build(entryPointFileName, OutputPath);
+
+            BuildMessage[] messages = results.Messages;
+            if (messages != null)
+            {
+                foreach (BuildMessage message in messages)
+                {
+                    switch (message.Severity)
+                    {
+                        case BuildMessageSeverity.Error:
+                            Log.LogError(null, message.HelpCode, message.HelpKeyword, null, 0, 0, 0, 0, message.Message);
+                            break;
+                        case BuildMessageSeverity.Warning:
+                            Log.LogWarning(null, message.HelpCode, message.HelpKeyword, null, 0, 0, 0, 0, message.Message);
+                            break;
+                        case BuildMessageSeverity.Info:
+                            Log.LogMessage(null, message.HelpCode, message.HelpKeyword, null, 0, 0, 0, 0, message.Message);
+                            continue;
+                    }
+                }
+            }
+
+            OutputEntryPoint = new TaskItem(Path.Combine(Path.GetDirectoryName(EntryPoint.ItemSpec), results.KeyFile));
+            OutputEntryPoint.SetMetadata(ItemMetadataNames.targetPath, results.KeyFile);
+
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
diff --git a/src/Tasks/GenerateManifestBase.cs b/src/Tasks/GenerateManifestBase.cs
index 7aa4cfd5f95..3ad0bf8c681 100644
--- a/src/Tasks/GenerateManifestBase.cs
+++ b/src/Tasks/GenerateManifestBase.cs
@@ -42,6 +42,8 @@ protected GenerateManifestBase() : base(AssemblyResources.PrimaryResources, "MSB
 
         public ITaskItem InputManifest { get; set; }
 
+        public bool LauncherBasedDeployment { get; set; }
+
         public int MaxTargetPath { get; set; }
 
         [Output]
@@ -481,6 +483,8 @@ private bool InitializeManifest(Type manifestType)
             {
                 _manifest.Description = Description;
             }
+            _manifest.LauncherBasedDeployment = LauncherBasedDeployment;
+            _manifest.AssemblyName = AssemblyName;
 
             return true;
         }
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 86b126dc255..7a3ad571bda 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -834,7 +834,7 @@ public override bool Execute()
                             this.StronglyTypedClassName = process.StronglyTypedClassName; // in case a default was chosen
                             this.StronglyTypedFileName = process.StronglyTypedFilename;   // in case a default was chosen
                             _stronglyTypedResourceSuccessfullyCreated = process.StronglyTypedResourceSuccessfullyCreated;
-                            if (null != process.UnsuccessfullyCreatedOutFiles)
+                            if (process.UnsuccessfullyCreatedOutFiles != null)
                             {
                                 foreach (string item in process.UnsuccessfullyCreatedOutFiles)
                                 {
@@ -955,7 +955,7 @@ private bool IsDangerous(String filename)
                 internetSecurityManager = (IInternetSecurityManager)Activator.CreateInstance(iismType);
             }
 
-            Int32 zone = 0;
+            int zone;
             internetSecurityManager.MapUrlToZone(Path.GetFullPath(filename), out zone, 0);
             if (zone < ZoneInternet)
             {
@@ -1067,7 +1067,7 @@ private bool ComputePathToResGen()
             {
                 _resgenPath = ToolLocationHelper.GetPathToDotNetFrameworkSdkFile("resgen.exe", TargetDotNetFrameworkVersion.Version35);
 
-                if (null == _resgenPath && ExecuteAsTool)
+                if (_resgenPath == null && ExecuteAsTool)
                 {
                     Log.LogErrorWithCodeFromResources("General.PlatformSDKFileNotFound", "resgen.exe",
                         ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion.Version35),
@@ -1085,7 +1085,7 @@ private bool ComputePathToResGen()
                     ExecuteAsTool);
             }
 
-            if (null == _resgenPath && !ExecuteAsTool)
+            if (_resgenPath == null && !ExecuteAsTool)
             {
                 // if Resgen.exe is not installed, just use the filename
                 _resgenPath = String.Empty;
@@ -1175,7 +1175,6 @@ private bool TransformResourceFilesUsingResGen(List<ITaskItem> inputsToProcess,
             else
             {
                 int initialResourceIndex = 0;
-                int numberOfResourcesToAdd = 0;
                 bool doneProcessingResources = false;
                 CommandLineBuilderExtension resourcelessCommandBuilder = new CommandLineBuilderExtension();
                 string resourcelessCommand = null;
@@ -1189,7 +1188,7 @@ private bool TransformResourceFilesUsingResGen(List<ITaskItem> inputsToProcess,
 
                 while (!doneProcessingResources)
                 {
-                    numberOfResourcesToAdd = CalculateResourceBatchSize(inputsToProcess, outputsToProcess, resourcelessCommand, initialResourceIndex);
+                    int numberOfResourcesToAdd = CalculateResourceBatchSize(inputsToProcess, outputsToProcess, resourcelessCommand, initialResourceIndex);
                     ResGen resGen = CreateResGenTaskWithDefaultParameters();
 
                     resGen.InputFiles = inputsToProcess.GetRange(initialResourceIndex, numberOfResourcesToAdd).ToArray();
@@ -1244,7 +1243,7 @@ private int CalculateResourceBatchSize(List<ITaskItem> inputsToProcess, List<ITa
                 i++;
             }
 
-            int numberOfResourcesToAdd = 0;
+            int numberOfResourcesToAdd;
             if (currentCommand.Length <= s_maximumCommandLength)
             {
                 // We've successfully added all the rest.
@@ -1833,7 +1832,7 @@ private bool NeedSeparateAppDomain()
                                             (
                                                 MessageImportance.Low,
                                                 "GenerateResource.SeparateAppDomainBecauseOfType",
-                                                (name == null) ? String.Empty : name,
+                                                name ?? String.Empty,
                                                 typeName,
                                                 source.ItemSpec,
                                                 ((IXmlLineInfo)reader).LineNumber
@@ -1879,7 +1878,7 @@ private bool NeedSeparateAppDomain()
                                             (
                                                 MessageImportance.Low,
                                                 "GenerateResource.SeparateAppDomainBecauseOfMimeType",
-                                                (name == null) ? String.Empty : name,
+                                                name ?? String.Empty,
                                                 mimeType,
                                                 source.ItemSpec,
                                                 ((IXmlLineInfo)reader).LineNumber
@@ -1925,7 +1924,7 @@ private bool NeedSeparateAppDomain()
                                         MessageImportance.Low,
                                         "GenerateResource.SeparateAppDomainBecauseOfErrorDeserializingLineNumber",
                                         source.ItemSpec,
-                                        (name == null) ? String.Empty : name,
+                                        name ?? String.Empty,
                                         ((IXmlLineInfo)reader).LineNumber,
                                         e.Message
                                     );
@@ -2170,8 +2169,7 @@ private void RecordFilesWritten()
             {
                 if (StronglyTypedFileName == null)
                 {
-                    CodeDomProvider provider = null;
-
+                    CodeDomProvider provider;
                     if (ProcessResourceFiles.TryCreateCodeDomProvider(Log, StronglyTypedLanguage, out provider))
                     {
                         StronglyTypedFileName = ProcessResourceFiles.GenerateDefaultStronglyTypedFilename(
@@ -2193,7 +2191,7 @@ private void ReadStateFile()
             // just doesn't exist, then this method will return a brand new cache object.
 
             // This method eats IO Exceptions
-            _cache = ResGenDependencies.DeserializeCache((StateFile == null) ? null : StateFile.ItemSpec, UseSourcePath, Log);
+            _cache = ResGenDependencies.DeserializeCache(StateFile?.ItemSpec, UseSourcePath, Log);
             ErrorUtilities.VerifyThrow(_cache != null, "We did not create a cache!");
         }
 
@@ -2205,7 +2203,7 @@ private void WriteStateFile()
             if (_cache.IsDirty)
             {
                 // And now we serialize the cache to save our resgen linked file resolution for later use.
-                _cache.SerializeCache((StateFile == null) ? null : StateFile.ItemSpec, Log);
+                _cache.SerializeCache(StateFile?.ItemSpec, Log);
             }
         }
     }
@@ -2358,7 +2356,7 @@ internal ArrayList UnsuccessfullyCreatedOutFiles
         {
             get
             {
-                if (null == _unsuccessfullyCreatedOutFiles)
+                if (_unsuccessfullyCreatedOutFiles == null)
                 {
                     _unsuccessfullyCreatedOutFiles = new ArrayList();
                 }
@@ -2846,7 +2844,7 @@ private string EnsurePathIsShortEnough(string currentOutputFile, string currentO
             // reliably with cmd's dir command either (depending on whether you use absolute or relative paths
             // and whether there are quotes around the name).
             const int EffectiveMaxPath = 258;   // Everything <= EffectiveMaxPath should work well.
-            bool success = false;
+            bool success;
             try
             {
                 currentOutputFile = Path.GetFullPath(currentOutputFile);
@@ -2917,8 +2915,7 @@ private void RemoveCorruptedFile(string filename)
         /// <returns>Resources format</returns>
         private Format GetFormat(string filename)
         {
-            string extension = String.Empty;
-
+            string extension;
             try
             {
                 extension = Path.GetExtension(filename);
@@ -3416,8 +3413,7 @@ private bool HaveSystemResourcesExtensionsReference
         /// <param name="sourceFile">The generated strongly typed filename</param>
         private void CreateStronglyTypedResources(ReaderInfo reader, String outFile, String inputFileName, out String sourceFile)
         {
-            CodeDomProvider provider = null;
-
+            CodeDomProvider provider;
             if (!TryCreateCodeDomProvider(_logger, _stronglyTypedLanguage, out provider))
             {
                 sourceFile = null;
@@ -3829,10 +3825,10 @@ private void AddResource(ReaderInfo reader, IResource entry, String inputFileNam
         /// <summary>
         /// Add a resource from an XML or binary format file to the internal data structures
         /// </summary>
-        /// <param name="reader">Reader info</param>
-        /// <param name="name">Resource name</param>
-        /// <param name="value">Resource value</param>
-        /// <param name="inputFileName">Input file for messages</param>
+        /// <param name="reader">Reader information.</param>
+        /// <param name="name">Resource name.</param>
+        /// <param name="value">Resource value.</param>
+        /// <param name="inputFileName">Input file for messages.</param>
         private void AddResource(ReaderInfo reader, string name, object value, String inputFileName)
         {
             AddResource(reader, name, value, inputFileName, 0, 0);
diff --git a/src/Tasks/GenerateTrustInfo.cs b/src/Tasks/GenerateTrustInfo.cs
index 7a922908366..9dbd8e79e4d 100644
--- a/src/Tasks/GenerateTrustInfo.cs
+++ b/src/Tasks/GenerateTrustInfo.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.IO;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
diff --git a/src/Tasks/GetReferenceAssemblyPaths.cs b/src/Tasks/GetReferenceAssemblyPaths.cs
index 408bf6f3435..f3b9f3e2467 100644
--- a/src/Tasks/GetReferenceAssemblyPaths.cs
+++ b/src/Tasks/GetReferenceAssemblyPaths.cs
@@ -246,7 +246,16 @@ private IList<String> GetPaths(string rootPath, string targetFrameworkFallbackSe
                 // 1/26/16: Note this was changed from a warning to an error (see GitHub #173).
                 if (pathsToReturn.Count == 0)
                 {
-                    Log.LogErrorWithCodeFromResources("GetReferenceAssemblyPaths.NoReferenceAssemblyDirectoryFound", frameworkmoniker.ToString());
+                    // Fixes bad error message when an old SDK assumes "net50" means ".NETFramework 5.0" instead of "netcoreapp 5.0"
+                    // https://github.com/dotnet/msbuild/issues/5820
+                    if (frameworkmoniker.Identifier == ".NETFramework" && frameworkmoniker.Version.Major >= 5)
+                    {
+                        Log.LogErrorWithCodeFromResources("GetReferenceAssemblyPaths.OutOfDateSDK", frameworkmoniker.ToString());
+                    }
+                    else
+                    {
+                        Log.LogErrorWithCodeFromResources("GetReferenceAssemblyPaths.NoReferenceAssemblyDirectoryFound", frameworkmoniker.ToString());
+                    }
                 }
             }
 
diff --git a/src/Tasks/ListOperators/RemoveDuplicates.cs b/src/Tasks/ListOperators/RemoveDuplicates.cs
index bdbed517f56..85562f5183f 100644
--- a/src/Tasks/ListOperators/RemoveDuplicates.cs
+++ b/src/Tasks/ListOperators/RemoveDuplicates.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index 1f0e1cc3d6a..d5a7628a245 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -655,7 +655,10 @@ private void ValidateReferencesForClickOnceApplication()
             foreach (FileReference file in FileReferences)
             {
                 // Check that file is not an assembly...
-                if (!String.IsNullOrEmpty(file.ResolvedPath) && PathUtil.IsAssembly(file.ResolvedPath))
+                // Unless this is a Launcher-based deployments where all files except launcher
+                // are added as regular file references and not assembly references.
+                if (!LauncherBasedDeployment &&
+                    !String.IsNullOrEmpty(file.ResolvedPath) && PathUtil.IsAssembly(file.ResolvedPath))
                 {
                     OutputMessages.AddWarningMessage("GenerateManifest.AssemblyAsFile", file.ToString());
                 }
diff --git a/src/Tasks/ManifestUtil/AssemblyIdentity.cs b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
index 8f50a5387fd..772c790c23e 100644
--- a/src/Tasks/ManifestUtil/AssemblyIdentity.cs
+++ b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
@@ -433,23 +433,23 @@ public string GetFullName(FullNameFlags flags)
             var sb = new StringBuilder(_name);
             if (!String.IsNullOrEmpty(_version))
             {
-                sb.Append(String.Format(CultureInfo.InvariantCulture, ", Version={0}", _version));
+                sb.AppendFormat(CultureInfo.InvariantCulture, ", Version={0}", _version);
             }
             if (!String.IsNullOrEmpty(_culture))
             {
-                sb.Append(String.Format(CultureInfo.InvariantCulture, ", Culture={0}", _culture));
+                sb.AppendFormat(CultureInfo.InvariantCulture, ", Culture={0}", _culture);
             }
             if (!String.IsNullOrEmpty(_publicKeyToken))
             {
-                sb.Append(String.Format(CultureInfo.InvariantCulture, ", PublicKeyToken={0}", _publicKeyToken));
+                sb.AppendFormat(CultureInfo.InvariantCulture, ", PublicKeyToken={0}", _publicKeyToken);
             }
             if (!String.IsNullOrEmpty(_processorArchitecture) && (flags & FullNameFlags.ProcessorArchitecture) != 0)
             {
-                sb.Append(String.Format(CultureInfo.InvariantCulture, ", ProcessorArchitecture={0}", _processorArchitecture));
+                sb.AppendFormat(CultureInfo.InvariantCulture, ", ProcessorArchitecture={0}", _processorArchitecture);
             }
             if (!String.IsNullOrEmpty(_type) && (flags & FullNameFlags.Type) != 0)
             {
-                sb.Append(String.Format(CultureInfo.InvariantCulture, ", Type={0}", _type));
+                sb.AppendFormat(CultureInfo.InvariantCulture, ", Type={0}", _type);
             }
             return sb.ToString();
         }
diff --git a/src/Tasks/ManifestUtil/CngLightup.cs b/src/Tasks/ManifestUtil/CngLightup.cs
index d89603de45a..bdc2bc26723 100644
--- a/src/Tasks/ManifestUtil/CngLightup.cs
+++ b/src/Tasks/ManifestUtil/CngLightup.cs
@@ -48,16 +48,13 @@ internal static partial class CngLightup
             typeof(object).Assembly.GetType(RSAEncryptionPaddingTypeName, false);
 
         private static readonly object s_pkcs1SignaturePadding =
-            s_rsaSignaturePaddingType == null ? null :
-            s_rsaSignaturePaddingType.GetProperty("Pkcs1", BindingFlags.Static | BindingFlags.Public).GetValue(null);
+            s_rsaSignaturePaddingType?.GetProperty("Pkcs1", BindingFlags.Static | BindingFlags.Public).GetValue(null);
 
         private static readonly object s_pkcs1EncryptionPadding =
-            s_rsaEncryptionPaddingType == null ? null :
-            s_rsaEncryptionPaddingType.GetProperty("Pkcs1", BindingFlags.Static | BindingFlags.Public).GetValue(null);
+            s_rsaEncryptionPaddingType?.GetProperty("Pkcs1", BindingFlags.Static | BindingFlags.Public).GetValue(null);
 
         private static readonly object s_oaepSha1EncryptionPadding =
-            s_rsaEncryptionPaddingType == null ? null :
-            s_rsaEncryptionPaddingType.GetProperty("OaepSHA1", BindingFlags.Static | BindingFlags.Public).GetValue(null);
+            s_rsaEncryptionPaddingType?.GetProperty("OaepSHA1", BindingFlags.Static | BindingFlags.Public).GetValue(null);
 
         private static readonly Lazy<bool> s_preferRsaCng = new Lazy<bool>(DetectRsaCngSupport);
 
diff --git a/src/Tasks/ManifestUtil/Constants.cs b/src/Tasks/ManifestUtil/Constants.cs
index f559bdf342a..601e8dfc9f5 100644
--- a/src/Tasks/ManifestUtil/Constants.cs
+++ b/src/Tasks/ManifestUtil/Constants.cs
@@ -26,5 +26,9 @@ internal static class Constants
         public const int MaxFileAssociationExtensionLength = 24;
         public const string ClientFrameworkSubset = "Client";
         public const string DotNetFrameworkIdentifier = ".NETFramework";
+        public const string DotNetCoreIdentifier = ".NETCore";
+        public const string DotNetCoreAppIdentifier = ".NETCoreApp";
+        public const string AppHostExe = "apphost.exe";
+        public const string SingleFileHostExe = "singlefilehost.exe";
     }
 }
diff --git a/src/Tasks/ManifestUtil/DeployManifest.cs b/src/Tasks/ManifestUtil/DeployManifest.cs
index 687ea0d65a6..0e726a88a57 100644
--- a/src/Tasks/ManifestUtil/DeployManifest.cs
+++ b/src/Tasks/ManifestUtil/DeployManifest.cs
@@ -177,9 +177,7 @@ private static FrameworkNameVersioning GetInstallableFrameworkName(FrameworkName
         private static string GetRedistListFilePath(string referenceAssemblyPath)
         {
             string redistListPath = Path.Combine(referenceAssemblyPath, _redistListFolder);
-            redistListPath = Path.Combine(redistListPath, _redistListFile);
-
-            return redistListPath;
+            return Path.Combine(redistListPath, _redistListFile);
         }
 
         private static IList<string> GetPathToReferenceAssemblies(FrameworkNameVersioning targetFrameworkMoniker)
diff --git a/src/Tasks/ManifestUtil/LauncherBuilder.cs b/src/Tasks/ManifestUtil/LauncherBuilder.cs
new file mode 100644
index 00000000000..13fd92fb899
--- /dev/null
+++ b/src/Tasks/ManifestUtil/LauncherBuilder.cs
@@ -0,0 +1,120 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.IO;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Tasks.Deployment.Bootstrapper;
+
+namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
+{
+    /// <summary>
+    /// Adds Launcher and updates its resource
+    /// </summary>
+    public class LauncherBuilder
+    {
+        private const string LAUNCHER_RESOURCENAME = "FILENAME";
+        private const int LAUNCHER_RESOURCE_TABLE = 50;
+
+        private BuildResults _results;
+
+        public LauncherBuilder(string launcherPath)
+        {
+            LauncherPath = launcherPath;
+        }
+
+        /// <summary>
+        /// Specifies the location of the required Launcher files.
+        /// </summary>
+        /// <value>Path to Launcher files.</value>
+        public string LauncherPath { get; set; }
+
+        public BuildResults Build(string filename, string outputPath)
+        {
+            string launcherFilename = Path.GetFileName(LauncherPath);
+
+            _results = new BuildResults();
+
+            try
+            {
+                if (filename == null)
+                {
+                    _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateLauncher.InvalidInput"));
+                    return _results;
+                }
+
+                if (String.IsNullOrEmpty(outputPath))
+                {
+                    _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateLauncher.NoOutputPath"));
+                    return _results;
+                }
+
+                // Copy setup.bin to the output directory
+                string strOutputExe = System.IO.Path.Combine(outputPath, launcherFilename);
+                if (!CopyLauncherToOutputDirectory(strOutputExe))
+                {
+                    // Appropriate messages should have been stuffed into the results already
+                    return _results;
+                }
+
+                var resourceUpdater = new ResourceUpdater();
+                resourceUpdater.AddStringResource(LAUNCHER_RESOURCE_TABLE, LAUNCHER_RESOURCENAME, filename);
+                if (!resourceUpdater.UpdateResources(strOutputExe, _results))
+                {
+                    return _results;
+                }
+
+                _results.SetKeyFile(launcherFilename);
+                _results.BuildSucceeded();
+            }
+            catch (Exception ex)
+            {
+                _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateLauncher.General", ex.Message));
+            }
+
+            return _results;
+        }
+
+        private bool CopyLauncherToOutputDirectory(string strOutputExe)
+        {
+            if (!FileSystems.Default.FileExists(LauncherPath))
+            {
+                _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateLauncher.MissingLauncherExe", LauncherPath));
+                return false;
+            }
+
+            try
+            {
+                EnsureFolderExists(Path.GetDirectoryName(strOutputExe));
+                File.Copy(LauncherPath, strOutputExe, true);
+                ClearReadOnlyAttribute(strOutputExe);
+            }
+            catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
+            {
+                _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateLauncher.CopyError", LauncherPath, strOutputExe, ex.Message));
+                return false;
+            }
+
+            return true;
+        }
+
+        private static void EnsureFolderExists(string strFolderPath)
+        {
+            if (!FileSystems.Default.DirectoryExists(strFolderPath))
+            {
+                Directory.CreateDirectory(strFolderPath);
+            }
+        }
+
+        private static void ClearReadOnlyAttribute(string strFileName)
+        {
+            FileAttributes attribs = File.GetAttributes(strFileName);
+            if ((attribs & FileAttributes.ReadOnly) != 0)
+            {
+                attribs &= (~FileAttributes.ReadOnly);
+                File.SetAttributes(strFileName, attribs);
+            }
+        }
+    }
+}
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index 13a69ff34fc..762e09e226d 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -68,6 +68,19 @@ private void CollectionToArray()
             }
         }
 
+        /// <summary>
+        /// Assembly name passed to the manifest generation task
+        /// </summary>
+        [XmlIgnore]
+        public string AssemblyName { get; set; }
+
+        /// <summary>
+        /// Indicates if manifest is part of Launcher-based deployment, which requires
+        /// somewhat different manifest generation and validation.
+        /// </summary>
+        [XmlIgnore]
+        public bool LauncherBasedDeployment { get; set; } = false;
+
         /// <summary>
         /// Specifies a textual description for the manifest.
         /// </summary>
@@ -466,7 +479,7 @@ private void UpdateAssemblyReference(AssemblyReference a, string targetFramework
             }
         }
 
-        private static void UpdateFileReference(BaseReference f, string targetFrameworkVersion)
+        private void UpdateFileReference(BaseReference f, string targetFrameworkVersion)
         {
             if (String.IsNullOrEmpty(f.ResolvedPath))
             {
@@ -485,6 +498,21 @@ private static void UpdateFileReference(BaseReference f, string targetFrameworkV
             }
             f.Hash = hash;
             f.Size = size;
+
+            //
+            // .NETCore Launcher.exe based Deployment: If the filereference is for apphost.exe, we need to change
+            // the ResolvedPath and TargetPath to {assemblyname}.exe before we write the manifest, so that the
+            // manifest does not have a file reference to apphost.exe
+            //
+            string fileName = Path.GetFileName(f.ResolvedPath);
+            if (LauncherBasedDeployment &&
+                fileName.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase) &&
+                !String.IsNullOrEmpty(AssemblyName))
+            {
+                f.ResolvedPath = Path.Combine(Path.GetDirectoryName(f.ResolvedPath), AssemblyName);
+                f.TargetPath = BaseReference.GetDefaultTargetPath(f.ResolvedPath);
+            }
+
             if (String.IsNullOrEmpty(f.TargetPath))
             {
                 if (!String.IsNullOrEmpty(f.SourcePath))
diff --git a/src/Tasks/ManifestUtil/MetadataReader.cs b/src/Tasks/ManifestUtil/MetadataReader.cs
index c338c4d8ded..c7238f82e74 100644
--- a/src/Tasks/ManifestUtil/MetadataReader.cs
+++ b/src/Tasks/ManifestUtil/MetadataReader.cs
@@ -289,7 +289,7 @@ public bool HasAssemblyAttribute(string name)
         {
             _assemblyImport.GetAssemblyFromScope(out uint assemblyScope);
             IMetaDataImport2 import2 = (IMetaDataImport2)_assemblyImport;
-            IntPtr valuePtr = IntPtr.Zero;
+            IntPtr valuePtr;
             import2.GetCustomAttributeByName(assemblyScope, name, out valuePtr, out uint valueLen);
             return valueLen != 0;
         }
diff --git a/src/Tasks/ManifestUtil/PathUtil.cs b/src/Tasks/ManifestUtil/PathUtil.cs
index 195b96d0a92..6d6e0a57085 100644
--- a/src/Tasks/ManifestUtil/PathUtil.cs
+++ b/src/Tasks/ManifestUtil/PathUtil.cs
@@ -112,7 +112,7 @@ public static bool IsProgramFile(string path)
 
         public static bool IsUncPath(string path)
         {
-            Uri u = null;
+            Uri u;
             if (!Uri.TryCreate(path, UriKind.Absolute, out u) || u == null)
                 return false;
             return u.IsUnc;
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 78743d0b3eb..d4fe3572301 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -480,7 +480,7 @@ public static PermissionSet XmlToPermissionSet(XmlElement element)
         /// <param name="path">Path of the file to sign with the certificate.</param>
         public static void SignFile(string certThumbprint, Uri timestampUrl, string path)
         {
-            SignFile(certThumbprint, timestampUrl, path, null);
+            SignFile(certThumbprint, timestampUrl, path, null, null);
         }
 
         /// <summary>
@@ -490,7 +490,27 @@ public static void SignFile(string certThumbprint, Uri timestampUrl, string path
         /// <param name="timestampUrl">URL that specifies an address of a time stamping server.</param>
         /// <param name="path">Path of the file to sign with the certificate.</param>
         /// <param name="targetFrameworkVersion">Version of the .NET Framework for the target.</param>
-        public static void SignFile(string certThumbprint, Uri timestampUrl, string path, string targetFrameworkVersion)
+        public static void SignFile(string certThumbprint,
+                                    Uri timestampUrl,
+                                    string path,
+                                    string targetFrameworkVersion)
+        {
+            SignFile(certThumbprint, timestampUrl, path, targetFrameworkVersion, null);
+        }
+
+        /// <summary>
+        /// Signs a ClickOnce manifest or PE file.
+        /// </summary>
+        /// <param name="certThumbprint">Hexadecimal string that contains the SHA-1 hash of the certificate.</param>
+        /// <param name="timestampUrl">URL that specifies an address of a time stamping server.</param>
+        /// <param name="path">Path of the file to sign with the certificate.</param>
+        /// <param name="targetFrameworkVersion">Version of the .NET Framework for the target.</param>
+        /// <param name="targetFrameworkIdentifier">.NET Framework identifier for the target.</param>
+        public static void SignFile(string certThumbprint,
+                                    Uri timestampUrl,
+                                    string path,
+                                    string targetFrameworkVersion,
+                                    string targetFrameworkIdentifier)
         {
             System.Resources.ResourceManager resources = new System.Resources.ResourceManager("Microsoft.Build.Tasks.Core.Strings.ManifestUtilities", typeof(SecurityUtilities).Module.Assembly);
 
@@ -514,8 +534,18 @@ public static void SignFile(string certThumbprint, Uri timestampUrl, string path
                     throw new ArgumentException("TargetFrameworkVersion");
                 }
 
-                // SHA-256 digest can be parsed only with .NET 4.5 or higher.
-                bool isTargetFrameworkSha256Supported = targetVersion.CompareTo(s_dotNet45Version) >= 0;
+                bool isTargetFrameworkSha256Supported = false;
+                if (String.IsNullOrEmpty(targetFrameworkIdentifier) ||
+                    targetFrameworkIdentifier.Equals(Constants.DotNetFrameworkIdentifier, StringComparison.InvariantCultureIgnoreCase))
+                {
+                    // SHA-256 digest can be parsed only with .NET 4.5 or higher.
+                    isTargetFrameworkSha256Supported = targetVersion.CompareTo(s_dotNet45Version) >= 0;
+                }
+                else if (targetFrameworkIdentifier.Equals(Constants.DotNetCoreAppIdentifier, StringComparison.InvariantCultureIgnoreCase))
+                {
+                    // Use SHA-256 digest for .NET Core apps
+                    isTargetFrameworkSha256Supported = true;
+                }
                 SignFileInternal(cert, timestampUrl, path, isTargetFrameworkSha256Supported, resources);
             }
             else
@@ -733,21 +763,21 @@ internal static string GetCommandLineParameters(string certThumbprint, Uri times
             var commandLine = new StringBuilder();
             if (useSha256)
             {
-                commandLine.Append(String.Format(CultureInfo.InvariantCulture, "sign /fd sha256 /sha1 {0} ", certThumbprint));
+                commandLine.AppendFormat(CultureInfo.InvariantCulture, "sign /fd sha256 /sha1 {0} ", certThumbprint);
             }
             else
             {
-                commandLine.Append(String.Format(CultureInfo.InvariantCulture, "sign /sha1 {0} ", certThumbprint));
+                commandLine.AppendFormat(CultureInfo.InvariantCulture, "sign /sha1 {0} ", certThumbprint);
             }
 
             if (timestampUrl != null)
             {
-                commandLine.Append(String.Format(CultureInfo.InvariantCulture,
+                commandLine.AppendFormat(CultureInfo.InvariantCulture,
                                                 "{0} {1} ",
                                                 useRFC3161Timestamp ? "/tr" : "/t",
-                                                timestampUrl.ToString()));
+                                                timestampUrl.ToString());
             }
-            commandLine.Append(string.Format(CultureInfo.InvariantCulture, "\"{0}\"", path));
+            commandLine.AppendFormat(CultureInfo.InvariantCulture, "\"{0}\"", path);
             return commandLine.ToString();
         }
 
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index 72d619f4b6b..c4d0460087f 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -121,14 +121,13 @@ private void FixupPermissionSetElement(XmlElement permissionSetElement)
                 return;
             }
 
-            XmlAttribute idrefAttribute = null;
             XmlElement defaultAssemblyRequestElement = (XmlElement)permissionSetElement.ParentNode.SelectSingleNode(XPaths.defaultAssemblyRequestElement, nsmgr);
             if (defaultAssemblyRequestElement == null)
             {
                 defaultAssemblyRequestElement = document.CreateElement(XmlUtil.TrimPrefix(XPaths.defaultAssemblyRequestElement), XmlNamespaces.asmv2);
                 permissionSetElement.ParentNode.AppendChild(defaultAssemblyRequestElement);
             }
-            idrefAttribute = (XmlAttribute)permissionSetElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.permissionSetReferenceAttribute));
+            XmlAttribute idrefAttribute = (XmlAttribute)permissionSetElement.Attributes.GetNamedItem(XmlUtil.TrimPrefix(XPaths.permissionSetReferenceAttribute));
             if (idrefAttribute == null)
             {
                 idrefAttribute = document.CreateAttribute(XmlUtil.TrimPrefix(XPaths.permissionSetReferenceAttribute));
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index eedc9f79b71..43c5c7e61d4 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -4,9 +4,7 @@
 // mansign.cs
 //
 
-using System;
 using System.Diagnostics.CodeAnalysis;
-using System.Globalization;
 using System.IO;
 using System.Security.Cryptography;
 using System.Security.Cryptography.Xml;
@@ -14,8 +12,6 @@
 using System.Text;
 using System.Xml;
 using System.Runtime.InteropServices;
-using System.Security.Cryptography.Pkcs;
-using Microsoft.Win32;
 
 using _FILETIME = System.Runtime.InteropServices.ComTypes.FILETIME;
 
@@ -329,9 +325,7 @@ private SignedCmiManifest2() { }
 
         internal SignedCmiManifest2(XmlDocument manifestDom, bool useSha256)
         {
-            if (manifestDom == null)
-                throw new ArgumentNullException(nameof(manifestDom));
-            _manifestDom = manifestDom;
+            _manifestDom = manifestDom ?? throw new ArgumentNullException(nameof(manifestDom));
             _useSha256 = useSha256;
         }
 
@@ -687,8 +681,8 @@ private static XmlDocument CreateLicenseDom(CmiManifestSigner2 signer, XmlElemen
             XmlElement manifestInformationNode = licenseDom.SelectSingleNode("r:license/r:grant/as:ManifestInformation", nsm) as XmlElement;
 
             manifestInformationNode.SetAttribute("Hash", hash.Length == 0 ? "" : BytesToHexString(hash, 0, hash.Length));
-            manifestInformationNode.SetAttribute("Description", signer.Description == null ? "" : signer.Description);
-            manifestInformationNode.SetAttribute("Url", signer.DescriptionUrl == null ? "" : signer.DescriptionUrl);
+            manifestInformationNode.SetAttribute("Description", signer.Description ?? "");
+            manifestInformationNode.SetAttribute("Url", signer.DescriptionUrl ?? "");
 
             XmlElement authenticodePublisherNode = licenseDom.SelectSingleNode("r:license/r:grant/as:AuthenticodePublisher/as:X509SubjectName", nsm) as XmlElement;
             authenticodePublisherNode.InnerText = signer.Certificate.SubjectName.Name;
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index b194c847366..f70cb0e0dc6 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -81,6 +81,7 @@
     <Compile Include="..\Shared\NGen.cs">
       <Link>NGen.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\IConstrainedEqualityComparer.cs"/>
     <Compile Include="..\Shared\IInternable.cs">
       <Link>IInternable.cs</Link>
     </Compile>
@@ -149,6 +150,7 @@
       <Link>Modifiers.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
     <Compile Include="..\Shared\ReadOnlyCollection.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
     <Compile Include="..\Shared\Tracing.cs" />
@@ -404,6 +406,9 @@
     <Compile Include="FindInList.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="FormatUrl.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="FormatVersion.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -416,6 +421,9 @@
     <Compile Include="GenerateDeploymentManifest.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="GenerateLauncher.cs" Condition="'$(MonoBuild)' != 'true'">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="GenerateManifestBase.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -597,9 +605,6 @@
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="FindInvalidProjectReferences.cs" />
-    <Compile Include="FormatUrl.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="GenerateBootstrapper.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index 0c5e0242a92..51ef08021b0 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -21,13 +21,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Import Project="$(CustomBeforeMicrosoftCommonCrossTargetingTargets)" Condition="'$(CustomBeforeMicrosoftCommonCrossTargetingTargets)' != '' and Exists('$(CustomBeforeMicrosoftCommonCrossTargetingTargets)')"/>
 
   <Target Name="GetTargetFrameworks"
+          DependsOnTargets="GetTargetFrameworksWithPlatformFromInnerBuilds"
           Returns="@(_ThisProjectBuildMetadata)">
+
+    <Error Condition="'$(IsCrossTargetingBuild)' != 'true'"
+           Text="Internal MSBuild error: CrossTargeting GetTargetFrameworks target should only be used in cross targeting (outer) build" />
+    
     <ItemGroup>
       <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
-        <TargetFrameworks Condition="'$(TargetFrameworks)' != ''">$(TargetFrameworks)</TargetFrameworks>
-        <TargetFrameworks Condition="'$(TargetFrameworks)' == ''">$(TargetFramework)</TargetFrameworks>
-        <HasSingleTargetFramework>true</HasSingleTargetFramework>
-        <HasSingleTargetFramework Condition="'$(IsCrossTargetingBuild)' == 'true'">false</HasSingleTargetFramework>
+        <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
+        <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
+        <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
+
+        <HasSingleTargetFramework>false</HasSingleTargetFramework>
+
         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
         <IsRidAgnostic>false</IsRidAgnostic>
         <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
@@ -46,6 +53,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </ItemGroup>
   </Target>
 
+  <Target Name="GetTargetFrameworksWithPlatformFromInnerBuilds"
+          DependsOnTargets="_ComputeTargetFrameworkItems">
+
+    <MSBuild Projects="@(_InnerBuildProjects)"
+             Condition="'@(_InnerBuildProjects)' != '' "
+             Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework"
+             BuildInParallel="$(BuildInParallel)">
+      <Output ItemName="_TargetFrameworkInfo" TaskParameter="TargetOutputs" />
+    </MSBuild>
+
+  </Target>
+
   <!--
   ============================================================
                                        DispatchToInnerBuilds
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index b5d20aaf8eb..a006a2f3083 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -256,6 +256,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <_DeploymentBuiltUpdateIntervalUnits Condition="'$(UpdatePeriodically)'!='true'">Days</_DeploymentBuiltUpdateIntervalUnits>
     <_DeploymentBuiltMinimumRequiredVersion Condition="'$(UpdateRequired)'=='true' and '$(Install)'=='true'">$(MinimumRequiredVersion)</_DeploymentBuiltMinimumRequiredVersion>
 
+    <_DeploymentLauncherBased Condition="'$(TargetFrameworkIdentifier)' == '.NETCoreApp'">true</_DeploymentLauncherBased>
+
     <MaxTargetPath Condition="'$(MaxTargetPath)'==''">100</MaxTargetPath>
   </PropertyGroup>
 
@@ -611,6 +613,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ContinueOnError Condition="'$(ContinueOnError)' == ''">false</ContinueOnError>
   </PropertyGroup>
 
+  <!-- Users familiar with how some other repos work try to use NoWarn with MSBuild in place of MSBuildWarningsAsMessages. -->
+  <PropertyGroup Condition="$([MSBuild]::AreFeaturesEnabled('16.8'))">
+    <MSBuildWarningsAsMessages Condition="'$(MSBuildWarningsAsMessages)'==''">$(NoWarn)</MSBuildWarningsAsMessages>
+    <MSBuildWarningsAsErrors Condition="'$(MSBuildWarningsAsErrors)'==''">$(WarningsAsErrors)</MSBuildWarningsAsErrors>
+  </PropertyGroup>
+
   <!-- Common Project System support -->
   <PropertyGroup>
     <CommonXamlResourcesDirectory Condition=" '$(CommonXamlResourcesDirectory)' == '' ">$(MSBuildThisFileDirectory)$(LangName)\</CommonXamlResourcesDirectory>
@@ -754,6 +762,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ***********************************************************************************************
     -->
 
+  <Target Name="_AddOutputPathToGlobalPropertiesToRemove">
+    <PropertyGroup>
+      <_GlobalPropertiesToRemoveFromProjectReferences Condition="'$(PassOutputPathToReferencedProjects)'=='false'">$(_GlobalPropertiesToRemoveFromProjectReferences);OutputPath</_GlobalPropertiesToRemoveFromProjectReferences>
+    </PropertyGroup>
+  </Target>
+
   <!--
     ============================================================
                                         _CheckForInvalidConfigurationAndPlatform
@@ -969,7 +983,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework);"
         Condition="'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != '' and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'"
         ContinueOnError="!$(BuildingProject)"
-        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
+        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
     </MSBuild>
   </Target>
 
@@ -994,7 +1008,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)"
         Condition="'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''  and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'"
         ContinueOnError="!$(BuildingProject)"
-        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
+        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
     </MSBuild>
   </Target>
 
@@ -1019,7 +1033,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)"
         Condition="'$(BuildPassReferences)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceExistent)' != ''  and '%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true'"
         ContinueOnError="!$(BuildingProject)"
-        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
+        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
     </MSBuild>
   </Target>
 
@@ -1579,7 +1593,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     ======================================================================================
   -->
-  <Target Name="_GetProjectReferenceTargetFrameworkProperties">
+  <Target Name="_GetProjectReferenceTargetFrameworkProperties" DependsOnTargets="_AddOutputPathToGlobalPropertiesToRemove">
     <!--
       Select the moniker to send to each project reference  if not already set. NugetTargetMoniker (NTM) is preferred by default over
       TargetFrameworkMoniker (TFM) because it is required to disambiguate the UWP case where TFM is fixed at .NETCore,Version=v5.0 and
@@ -1597,11 +1611,33 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       and the mechanism here for selecting the best one can be skipped as an optimization.
 
       We give this treatment to .vcxproj by default since no .vcxproj can target more
-      than one framework.
+      than one framework currently. The user must specify exactly one TargetFramework.
+
+      vcxproj files compile down to OS-specific binaries, either native or .NET. In the
+      _GetProjectReferenceTargetFrameworkProperties target of Microsoft.Common.CurrentVersion.targets,
+      SkipTargetFrameworkProperties is set to true for vcxproj to account for that.
+
+      This means we do not fill the Item _ProjectReferenceTargetFrameworkPossibilities or, by extension,
+      the AnnotatedProjects Item.
+
+      For single-targeted projects, we normally decorate the AnnotatedProjects Item with
+      UndefineProperties metadata specifying that TargetFramework should be undefined. Because it
+      isn't defined properly at that stage, however, this does not happen, and TargetFramework is
+      defined at this point in addition to having been defined globally. Currently, this is always
+      true for vcxproj.
+
+      MSBuild permits building the same project twice as long as it has different sets of global properties.
+      Because the TargetFramework global property is not being removed as expected by the multitargeting
+      part of MSBuild, the engine recognizes that there are differences and builds it twice. This can
+      become more noticeable if the projects build in parallel, since they could try to access the same
+      resources and conflict, failing the build. Note, however, that building the same project twice in
+      this way is always wrong even if it seems minor because they do not conflict, and the second build is
+      relatively fast.
    -->
    <ItemGroup>
       <_MSBuildProjectReferenceExistent Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' == '' and ('%(Extension)' == '.vcxproj' or '%(Extension)' == '.nativeproj')">
         <SkipGetTargetFrameworkProperties>true</SkipGetTargetFrameworkProperties>
+        <UndefineProperties>%(_MSBuildProjectReferenceExistent.UndefineProperties);TargetFramework</UndefineProperties>
       </_MSBuildProjectReferenceExistent>
    </ItemGroup>
 
@@ -1634,7 +1670,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         BuildInParallel="$(BuildInParallel)"
         Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)"
         ContinueOnError="!$(BuildingProject)"
-        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier"
+        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier$(_GlobalPropertiesToRemoveFromProjectReferences)"
         Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true'"
         SkipNonexistentTargets="true">
       <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetFrameworkPossibilities" />
@@ -1653,11 +1689,26 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </ItemGroup>
 
     <!-- For each reference, get closest match -->
+
+    <!-- Pass the CurrentProjectTargetPlatform parameter to the task only if GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter is true.  This means
+         that we are using a version of NuGet which supports that parameter on this task. -->
+    
     <GetReferenceNearestTargetFrameworkTask AnnotatedProjectReferences="@(_ProjectReferenceTargetFrameworkPossibilities)"
                                             CurrentProjectTargetFramework="$(ReferringTargetFrameworkForProjectReferences)"
+                                            CurrentProjectTargetPlatform="$(TargetPlatformMoniker)"
                                             CurrentProjectName="$(MSBuildProjectName)"
                                             FallbackTargetFrameworks="$(AssetTargetFallback)"
-                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities->Count())' != '0' and '$(ReferringTargetFrameworkForProjectReferences)' != ''">
+                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities->Count())' != '0' and '$(ReferringTargetFrameworkForProjectReferences)' != ''
+                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' == 'true'">
+      <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
+    </GetReferenceNearestTargetFrameworkTask>
+
+    <GetReferenceNearestTargetFrameworkTask AnnotatedProjectReferences="@(_ProjectReferenceTargetFrameworkPossibilities)"
+                                            CurrentProjectTargetFramework="$(ReferringTargetFrameworkForProjectReferences)"
+                                            CurrentProjectName="$(MSBuildProjectName)"
+                                            FallbackTargetFrameworks="$(AssetTargetFallback)"
+                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities->Count())' != '0' and '$(ReferringTargetFrameworkForProjectReferences)' != ''
+                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' != 'true'">
       <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
     </GetReferenceNearestTargetFrameworkTask>
 
@@ -1697,20 +1748,41 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </Target>
 
   <Target Name="GetTargetFrameworks"
+          DependsOnTargets="GetTargetFrameworksWithPlatformForSingleTargetFramework"
           Returns="@(_ThisProjectBuildMetadata)">
+
+    <Error Condition="'$(IsCrossTargetingBuild)' == 'true'"
+           Text="Internal MSBuild error: Non-CrossTargeting GetTargetFrameworks target should not be used in cross targeting (outer) build" />
+
     <ItemGroup>
       <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
-        <TargetFrameworks Condition="'$(TargetFrameworks)' != ''">$(TargetFrameworks)</TargetFrameworks>
-        <TargetFrameworks Condition="'$(TargetFrameworks)' == ''">$(TargetFramework)</TargetFrameworks>
+        <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
+        <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
+        <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
+
         <HasSingleTargetFramework>true</HasSingleTargetFramework>
-        <HasSingleTargetFramework Condition="'$(IsCrossTargetingBuild)' == 'true'">false</HasSingleTargetFramework>
+        
         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
-      <IsRidAgnostic>false</IsRidAgnostic>
-      <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
+        <IsRidAgnostic>false</IsRidAgnostic>
+        <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
   </Target>
 
+  <Target Name="GetTargetFrameworksWithPlatformForSingleTargetFramework"
+        Returns="@(_TargetFrameworkInfo)">
+
+    <ItemGroup>
+      <_TargetFrameworkInfo Include="$(TargetFramework)">
+        <TargetFrameworks>$(TargetFramework)</TargetFrameworks>
+        <TargetFrameworkMonikers>$(TargetFrameworkMoniker)</TargetFrameworkMonikers>
+        <TargetPlatformMonikers>$(TargetPlatformMoniker)</TargetPlatformMonikers>
+        <TargetPlatformMonikers Condition="'$(TargetPlatformMoniker)' == ''">None</TargetPlatformMonikers>
+      </_TargetFrameworkInfo>
+    </ItemGroup>
+
+  </Target>
+
   <!--
     ============================================================
                                     GetTargetFrameworkProperties
@@ -1795,7 +1867,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform); %(_MSBuildProjectReferenceExistent.SetTargetFramework)"
         Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and ('$(BuildingInsideVisualStudio)' == 'true' or '$(BuildProjectReferences)' != 'true') and '$(VisualStudioVersion)' != '10.0' and '@(_MSBuildProjectReferenceExistent)' != ''"
         ContinueOnError="!$(BuildingProject)"
-        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
+        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
 
       <Output TaskParameter="TargetOutputs" ItemName="_ResolvedProjectReferencePaths" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)'=='true'"/>
       <Output TaskParameter="TargetOutputs" ItemName="%(_MSBuildProjectReferenceExistent.OutputItemType)" Condition="'%(_MSBuildProjectReferenceExistent.OutputItemType)' != ''"/>
@@ -1812,7 +1884,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform);  %(_MSBuildProjectReferenceExistent.SetTargetFramework)"
         Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '$(BuildingInsideVisualStudio)' != 'true' and '$(BuildProjectReferences)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''"
         ContinueOnError="$(ContinueOnError)"
-        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
+        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
 
       <Output TaskParameter="TargetOutputs" ItemName="_ResolvedProjectReferencePaths" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)'=='true' or '$(DesignTimeBuild)' == 'true'"/>
       <Output TaskParameter="TargetOutputs" ItemName="%(_MSBuildProjectReferenceExistent.OutputItemType)" Condition="'%(_MSBuildProjectReferenceExistent.OutputItemType)' != ''"/>
@@ -1830,7 +1902,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         Condition="'%(_MSBuildProjectReferenceExistent.BuildReference)' == 'true' and '@(ProjectReferenceWithConfiguration)' != '' and '$(BuildingProject)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''"
         ContinueOnError="$(ContinueOnError)"
         SkipNonexistentTargets="true"
-        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
+        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
 
       <Output TaskParameter="TargetOutputs" ItemName="NativeReference" Condition="'%(_MSBuildProjectReferenceExistent.ReferenceOutputAssembly)' == 'true'"/>
     </MSBuild>
@@ -2422,7 +2494,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       Targets="GetTargetPathWithTargetPlatformMoniker"
       BuildInParallel="$(BuildInParallel)"
       ContinueOnError="!$(BuildingProject)"
-      RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
+      RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
 
       <Output TaskParameter="TargetOutputs" ItemName="TargetPathWithTargetPlatformMoniker" />
     </MSBuild>
@@ -3790,6 +3862,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <ResolveManifestFiles
         TargetFrameworkVersion="$(TargetFrameworkVersion)"
+        TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
         SigningManifests="$(SignManifests)"
         DeploymentManifestEntryPoint="@(ApplicationManifest)"
         PublishFiles="@(_DeploymentPublishFileOfTypeManifestEntryPoint)">
@@ -3826,6 +3899,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Target
       Name="GenerateApplicationManifest"
       DependsOnTargets="
+            _DeploymentSetClickOnceVersions;
+            _DeploymentGenerateLauncher;
             _DeploymentComputeNativeManifestInfo;
             _DeploymentComputeClickOnceManifestInfo;
             ResolveComReferences;
@@ -3871,11 +3946,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         IconFile="@(_DeploymentManifestIconFile)"
         InputManifest="$(_DeploymentBaseManifest)"
         IsolatedComReferences="@(ResolvedIsolatedComModules)"
+        LauncherBasedDeployment="$(_DeploymentLauncherBased)"
         ManifestType="$(_DeploymentManifestType)"
         MaxTargetPath="$(MaxTargetPath)"
         OutputManifest="@(ApplicationManifest)"
         OSVersion="$(OSVersion)"
-        Platform="$(PlatformTarget)"
+        Platform="$(_DeploymentPlatformTarget)"
         Product="$(ProductName)"
         Publisher="$(PublisherName)"
         RequiresMinimumFramework35SP1="$(_DeploymentRequiresMinimumFramework35SP1)"
@@ -3884,7 +3960,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         TargetCulture="$(TargetCulture)"
         TargetFrameworkSubset="$(TargetFrameworkSubset)"
         TargetFrameworkProfile="$(TargetFrameworkProfile)"
-        TargetFrameworkVersion="$(TargetFrameworkVersion)"
+        TargetFrameworkVersion="$(_DeploymentManifestTargetFrameworkVersion)"
         TrustInfoFile="@(_DeploymentIntermediateTrustInfoFile)"
         UseApplicationTrust="$(UseApplicationTrust)">
 
@@ -3898,6 +3974,109 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
+  <!--
+    ============================================================
+                                        _DeploymentSetClickOnceVersions
+
+    Sets ClickOnce versions
+    ============================================================
+    -->
+  <Target
+      Name="_DeploymentSetClickOnceVersions"
+      Condition="'$(GenerateClickOnceManifests)'=='true'">
+
+    <PropertyGroup>
+      <_DeploymentManifestTargetFrameworkMoniker>$(TargetFrameworkMoniker)</_DeploymentManifestTargetFrameworkMoniker>
+      <_DeploymentManifestTargetFrameworkVersion>$(TargetFrameworkVersion)</_DeploymentManifestTargetFrameworkVersion>
+    </PropertyGroup>
+
+  </Target>
+
+  <!--
+    ============================================================
+                                        _DeploymentGenerateLauncher
+
+    Generates Launcher if needed
+    ============================================================
+    -->
+  <Target
+      Name="_DeploymentGenerateLauncher"
+      Condition="'$(GenerateClickOnceManifests)'=='true' and '$(_DeploymentLauncherBased)' == 'true'">
+
+    <!-- 
+      If apphost based built EXE is found, use that as the Launcher.exe's entry point otherwise
+      use the built DLL as the entry point
+    -->
+    <ItemGroup Condition="'$(UseAppHost)' == 'true' and '$(_IsExecutable)' == 'true' and exists('$(AppHostIntermediatePath)')">
+      <EntryPointForLauncher Include="$(AppHostIntermediatePath)"/>
+      <ContentWithTargetPath Include="@(EntryPointForLauncher)"/>
+    </ItemGroup>
+    <ItemGroup Condition="'$(EntryPointForLauncher)'==''">
+      <EntryPointForLauncher Include="$(_DeploymentManifestEntryPoint)"/>
+    </ItemGroup>
+
+    <!-- Generates Launcher and obtains its Framework version and moniker -->
+    <GenerateLauncher
+        AssemblyName="$(_DeploymentApplicationManifestIdentity)"
+        EntryPoint="@(EntryPointForLauncher)"
+        OutputPath="$(IntermediateOutputPath)"
+        VisualStudioVersion="$(VisualStudioVersion)">
+
+      <Output TaskParameter="OutputEntryPoint" ItemName="_DeploymentManifestLauncherEntryPoint"/>
+    </GenerateLauncher>
+
+    <!--
+      .NET Core ClickOnce deployments use Launcher, which targets .NET FX 4.5 as the minimum
+      supported ClickOnce runtime version on target user's machine.
+
+      TargetFramework Verion and Moniker properties are used in Deployment manifest generation
+      task to set compatibleFrameworks element, which needs to match Launcher's target version.
+
+      Version can be overriden with DeploymentManifestTargetFrameworkVersionOverride property.
+    -->
+    <PropertyGroup>
+      <_DeploymentManifestTargetFrameworkVersion Condition="'$(DeploymentManifestTargetFrameworkVersionOverride)' == ''">v4.5</_DeploymentManifestTargetFrameworkVersion>
+      <_DeploymentManifestTargetFrameworkVersion Condition="'$(DeploymentManifestTargetFrameworkVersionOverride)' != ''">$(DeploymentManifestTargetFrameworkVersionOverride)</_DeploymentManifestTargetFrameworkVersion>
+      <_DeploymentManifestTargetFrameworkMoniker>.NETFramework,Version=$(_DeploymentManifestTargetFrameworkVersion)</_DeploymentManifestTargetFrameworkMoniker>
+    </PropertyGroup>
+
+    <!-- Sign Launcher EXE -->
+    <SignFile
+        CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)"
+        TimestampUrl="$(ManifestTimestampUrl)"
+        SigningTarget="@(_DeploymentManifestLauncherEntryPoint)"
+        TargetFrameworkVersion="$(TargetFrameworkVersion)"
+        TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
+        Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
+
+    <!-- Sign the original ClickOnce entrypoint -->
+    <SignFile
+        CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)"
+        TimestampUrl="$(ManifestTimestampUrl)"
+        SigningTarget="@(_DeploymentManifestEntryPoint)"
+        TargetFrameworkVersion="$(TargetFrameworkVersion)"
+        TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
+        Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
+
+    <!-- Sign apphost.exe if it's the entrypoint for the Launcher.exe. This is the case in loose file publish -->
+    <SignFile
+        CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)"
+        TimestampUrl="$(ManifestTimestampUrl)"
+        SigningTarget="$(AppHostIntermediatePath)"
+        TargetFrameworkVersion="$(TargetFrameworkVersion)"
+        TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
+        Condition="'$(_DeploymentSignClickOnceManifests)'=='true' and '$(UseAppHost)' == 'true' and '$(PublishSingleFile)' != 'true' and '$(_IsExecutable)' == 'true' and exists('$(AppHostIntermediatePath)')" />
+
+    <!--
+      Replace entry-point with Launcher and move original project's entry-point to content group.
+    -->
+    <ItemGroup>
+      <ContentWithTargetPath Include="@(_DeploymentManifestEntryPoint)"/>
+      <_DeploymentManifestEntryPoint Remove="@(_DeploymentManifestEntryPoint)"/>
+      <_DeploymentManifestEntryPoint Include="@(_DeploymentManifestLauncherEntryPoint)"/>
+    </ItemGroup>
+  </Target>
+
   <!--
     ============================================================
                                         _DeploymentComputeNativeManifestInfo
@@ -3929,6 +4108,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
+  <PropertyGroup>
+    <DeploymentComputeClickOnceManifestInfoDependsOn>
+      CleanPublishFolder;
+      _DeploymentGenerateTrustInfo
+      $(DeploymentComputeClickOnceManifestInfoDependsOn)
+    </DeploymentComputeClickOnceManifestInfoDependsOn>
+  </PropertyGroup>
+
   <!--
     ============================================================
                                         _DeploymentComputeClickOnceManifestInfo
@@ -3936,12 +4123,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     Compute info for  ClickOnce manifest generation
     ============================================================
     -->
+
   <Target
       Name="_DeploymentComputeClickOnceManifestInfo"
       Condition="'$(GenerateClickOnceManifests)'=='true'"
-      DependsOnTargets="
-            CleanPublishFolder;
-            _DeploymentGenerateTrustInfo">
+      DependsOnTargets="$(DeploymentComputeClickOnceManifestInfoDependsOn)">
 
     <!-- Grab just the serialization assemblies for a referenced assembly.  There may also be a symbols file in ReferenceRelatedPaths -->
     <ItemGroup>
@@ -3959,14 +4145,39 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ItemGroup>
       <_SatelliteAssemblies Include="@(IntermediateSatelliteAssembliesWithTargetPath);@(ReferenceSatellitePaths)" />
       <_DeploymentReferencePaths Include="@(ReferenceCopyLocalPaths)"
-                                 Condition="'%(Extension)' == '.dll' Or '%(Extension)' == '.exe'">
+                                 Condition="'%(Extension)' == '.dll' Or '%(Extension)' == '.exe' Or '%(Extension)' == '.md'">
         <IsPrimary>true</IsPrimary>
       </_DeploymentReferencePaths>
       <_DeploymentReferencePaths Include="@(_DeploymentReferencePaths);@(_CopyLocalFalseRefPathsWithExclusion)" />
+    </ItemGroup>
+
+    <!-- Include managed references in clickonce manifest only if single file publish is false -->
+    <ItemGroup Condition="'$(PublishSingleFile)' != 'true'">
       <_ManifestManagedReferences Include="@(_DeploymentReferencePaths);@(ReferenceDependencyPaths);@(_SGenDllsRelatedToCurrentDll);@(SerializationAssembly);@(ReferenceCOMWrappersToCopyLocal)"
                                Exclude="@(_SatelliteAssemblies);@(_ReferenceScatterPaths);@(_ExcludedAssembliesFromManifestGeneration)" />
     </ItemGroup>
 
+    <!-- Include the following files in clickonce manifest only if single file publish is false -->
+    <ItemGroup Condition="'$(PublishSingleFile)' != 'true'">
+      <ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce)"/>
+    </ItemGroup>
+
+    <!-- For single file publish, we need to include the SF bundle EXE and files excluded from the bundle EXE in the clickonce manifest -->
+    <ItemGroup Condition="'$(PublishSingleFile)' == 'true'">
+      <ClickOnceFiles Include="$(PublishedSingleFilePath)"/>
+      <ClickOnceFiles Include="@(_FilesExcludedFromBundle)"/>
+    </ItemGroup>
+
+    <!-- For single file publish in .net core app, sign the SF EXE if signing is enabled -->
+    <SignFile
+      CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)"
+      TimestampUrl="$(ManifestTimestampUrl)"
+      SigningTarget="$(PublishedSingleFilePath)"
+      TargetFrameworkVersion="$(TargetFrameworkVersion)"
+      TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
+      Condition="'$(_DeploymentSignClickOnceManifests)'=='true' and '$(_DeploymentLauncherBased)' == 'true' and '$(PublishSingleFile)' == 'true'"
+      />
+
     <!-- Copy the application executable from Obj folder to app.publish folder.
     This is being done to avoid Windows Forms designer memory issues that can arise while operating directly on files located in Obj directory. -->
     <Copy
@@ -3986,16 +4197,22 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!-- Create list of items for manifest generation -->
     <ResolveManifestFiles
-        TargetFrameworkVersion="$(TargetFrameworkVersion)"
-        SigningManifests="$(SignManifests)"
+        AssemblyName="$(_DeploymentApplicationManifestIdentity)"
         EntryPoint="@(_DeploymentClickOnceApplicationExecutable)"
         ExtraFiles="@(_DebugSymbolsIntermediatePath);$(IntermediateOutputPath)$(TargetName).xml;@(_ReferenceRelatedPaths)"
-        Files="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath)"
+        Files="@(ClickOnceFiles)"
+        IsSelfContainedPublish="$(SelfContained)"
+        IsSingleFilePublish="$(PublishSingleFile)"
+        LauncherBasedDeployment="$(_DeploymentLauncherBased)"
         ManagedAssemblies="@(_ManifestManagedReferences)"
         NativeAssemblies="@(NativeReferenceFile);@(_DeploymentNativePrerequisite)"
         PublishFiles="@(PublishFile)"
+        RuntimePackAssets="@(RuntimePackAsset)"
         SatelliteAssemblies="@(_SatelliteAssemblies)"
-        TargetCulture="$(TargetCulture)">
+        SigningManifests="$(SignManifests)"
+        TargetCulture="$(TargetCulture)"
+        TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
+        TargetFrameworkVersion="$(TargetFrameworkVersion)">
 
       <Output TaskParameter="OutputAssemblies" ItemName="_DeploymentManifestDependenciesUnfiltered"/>
       <Output TaskParameter="OutputFiles" ItemName="_DeploymentManifestFiles"/>
@@ -4014,6 +4231,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_DeploymentManifestType>ClickOnce</_DeploymentManifestType>
     </PropertyGroup>
 
+    <!--
+      Manifest platform should always be MSIL for Launcher-based deployments, as the Launcher is MSIL.
+      Do not set _DeploymentPlatformTarget property in Launcher case - this is interpreted as MSIL,
+      by GenerateApplicationManifest and GenerateDeploymentManifest tasks.
+      Otherwise, set it to PlatformTarget.
+    -->
+    <PropertyGroup>
+      <_DeploymentPlatformTarget Condition="'$(_DeploymentLauncherBased)' != 'true'">$(PlatformTarget)</_DeploymentPlatformTarget>
+    </PropertyGroup>
+
     <!-- Obtain manifest version from ApplicationVersion and ApplicationRevision properties -->
     <FormatVersion Version="$(ApplicationVersion)" Revision="$(ApplicationRevision)">
       <Output TaskParameter="OutputVersion" PropertyName="_DeploymentManifestVersion"/>
@@ -4090,18 +4317,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.
           EntryPoint="@(_DeploymentResolvedDeploymentManifestEntryPoint)"
           ErrorReportUrl="$(_DeploymentFormattedErrorReportUrl)"
           Install="$(Install)"
+          LauncherBasedDeployment="$(_DeploymentLauncherBased)"
           MapFileExtensions="$(MapFileExtensions)"
           MaxTargetPath="$(MaxTargetPath)"
           MinimumRequiredVersion="$(_DeploymentBuiltMinimumRequiredVersion)"
           OutputManifest="@(DeployManifest)"
-          Platform="$(PlatformTarget)"
+          Platform="$(_DeploymentPlatformTarget)"
           Product="$(ProductName)"
           Publisher="$(PublisherName)"
           SuiteName="$(SuiteName)"
           SupportUrl="$(_DeploymentFormattedSupportUrl)"
           TargetCulture="$(TargetCulture)"
-          TargetFrameworkVersion="$(TargetFrameworkVersion)"
-          TargetFrameworkMoniker="$(TargetFrameworkMoniker)"
+          TargetFrameworkVersion="$(_DeploymentManifestTargetFrameworkVersion)"
+          TargetFrameworkMoniker="$(_DeploymentManifestTargetFrameworkMoniker)"
           TrustUrlParameters="$(TrustUrlParameters)"
           UpdateEnabled="$(UpdateEnabled)"
           UpdateInterval="$(_DeploymentBuiltUpdateInterval)"
@@ -4463,7 +4691,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Target
     Name="_GetCopyToOutputDirectoryItemsFromTransitiveProjectReferences"
-    DependsOnTargets="_PopulateCommonStateForGetCopyToOutputDirectoryItems"
+    DependsOnTargets="_PopulateCommonStateForGetCopyToOutputDirectoryItems;_AddOutputPathToGlobalPropertiesToRemove"
     Returns="@(_TransitiveItemsToCopyToOutputDirectory)">
 
     <!-- Get items from child projects first. -->
@@ -4475,7 +4703,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         Condition="'@(_MSBuildProjectReferenceExistent)' != '' and '$(_GetChildProjectCopyToOutputDirectoryItems)' == 'true' and '%(_MSBuildProjectReferenceExistent.Private)' != 'false' and '$(UseCommonOutputDirectory)' != 'true'"
         ContinueOnError="$(ContinueOnError)"
         SkipNonexistentTargets="true"
-        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)">
+        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
 
       <Output TaskParameter="TargetOutputs" ItemName="_AllChildProjectItemsWithTargetPath"/>
 
@@ -5116,7 +5344,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         BuildInParallel="$(BuildInParallel)"
         Condition="'$(BuildingInsideVisualStudio)' != 'true' and '$(BuildProjectReferences)' == 'true' and '@(_MSBuildProjectReferenceExistent)' != ''"
         ContinueOnError="$(ContinueOnError)"
-        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)"/>
+        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)"/>
 
   </Target>
 
@@ -5427,6 +5655,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!-- Copy files to publish folder -->
     <Copy
+        Condition="'$(PublishSingleFile)' != 'true'"
         SourceFiles=
                 "@(_ApplicationManifestFinal);
                 @(_DeploymentResolvedManifestEntryPoint);
@@ -5457,9 +5686,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
         UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)"
         UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)"
-        Condition="'%(_DeploymentManifestDependencies.DependencyType)'=='Install'"/>
+        Condition="'$(PublishSingleFile)' != 'true' and '%(_DeploymentManifestDependencies.DependencyType)'=='Install'"/>
 
     <Copy
+        Condition="'$(PublishSingleFile)' != 'true'"
         SourceFiles="@(_ReferenceScatterPaths)"
         DestinationFiles="@(_ReferenceScatterPaths->'$(_DeploymentApplicationDir)%(Filename)%(Extension)$(_DeploymentFileMappingExtension)')"
         SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
@@ -5470,6 +5700,28 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)"
             />
 
+    <ItemGroup Condition="'$(PublishSingleFile)' == 'true'">
+      <PublishedSingleFileToBeCopied Include="@(_DeploymentManifestFiles)"/>
+    </ItemGroup>
+
+    <!-- For single-file publish case, we need to only copy the clickonce manifest, manifest entry point (launcher) and the SF EXE -->
+    <Copy
+        Condition="'$(PublishSingleFile)' == 'true'"
+        SourceFiles=
+                "@(_ApplicationManifestFinal);
+                 @(_DeploymentResolvedManifestEntryPoint);
+                 @(PublishedSingleFileToBeCopied);"
+        DestinationFiles=
+                "@(_ApplicationManifestFinal->'$(_DeploymentApplicationDir)%(TargetPath)');
+                 @(_DeploymentManifestEntryPoint->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)');
+                 @(PublishedSingleFileToBeCopied->'$(_DeploymentApplicationDir)%(TargetPath)$(_DeploymentFileMappingExtension)')"
+        SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
+        OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
+        Retries="$(CopyRetryCount)"
+        UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)"
+        UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)"
+        RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"/>
+
     <FormatUrl InputUrl="$(_DeploymentApplicationUrl)">
       <Output TaskParameter="OutputUrl" PropertyName="_DeploymentFormattedApplicationUrl"/>
     </FormatUrl>
@@ -5519,13 +5771,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)"
         TimestampUrl="$(ManifestTimestampUrl)"
         SigningTarget="$(_DeploymentApplicationDir)$(_DeploymentTargetApplicationManifestFileName)"
+        TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
         TargetFrameworkVersion="$(TargetFrameworkVersion)"
         Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
 
     <!-- Update entry point path in deploy manifest -->
     <UpdateManifest
         ApplicationPath="$(_DeploymentApplicationFolderName)\$(_DeploymentTargetApplicationManifestFileName)"
-        TargetFrameworkVersion="$(TargetFrameworkVersion)"
+        TargetFrameworkVersion="$(_DeploymentManifestTargetFrameworkVersion)"
         ApplicationManifest="$(_DeploymentApplicationDir)$(_DeploymentTargetApplicationManifestFileName)"
         InputManifest="$(OutDir)$(TargetDeployManifestFileName)"
         OutputManifest="$(PublishDir)$(TargetDeployManifestFileName)">
@@ -5538,6 +5791,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)"
         TimestampUrl="$(ManifestTimestampUrl)"
         SigningTarget="$(PublishDir)$(TargetDeployManifestFileName)"
+        TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
         TargetFrameworkVersion="$(TargetFrameworkVersion)"
         Condition="'$(_DeploymentSignClickOnceManifests)'=='true'" />
 
@@ -5546,13 +5800,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         TimestampUrl="$(ManifestTimestampUrl)"
         SigningTarget="$(PublishDir)\setup.exe"
         Condition="'$(BootstrapperEnabled)'=='true' and '$(_DeploymentSignClickOnceManifests)'=='true'" />
-
-
   </Target>
 
 
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -5853,6 +6103,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
        Needed for certain build environments that import partial sets of targets. -->
   <Target Name="CollectReferencedNuGetPackages" Returns="@(ReferencedNuGetPackages)"/>
 
+  <!-- Get the TargetFrameworks that are supported for the Visual Studio TargetFramework drop down -->
+  <Target Name="GenerateSupportedTargetFrameworkAlias" Returns="@(SupportedTargetFrameworkAlias)"/>
+
   <!--
     ============================================================
                                         PriFilesOutputGroup
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index 32f8ed42f3c..9f7f4620cd2 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -116,6 +116,7 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateBindingRedirects"              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateBootstrapper"                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateDeploymentManifest"            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateLauncher"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
diff --git a/src/Tasks/Microsoft.Managed.After.targets b/src/Tasks/Microsoft.Managed.After.targets
index 243c49179e2..a5dfd1da0ff 100644
--- a/src/Tasks/Microsoft.Managed.After.targets
+++ b/src/Tasks/Microsoft.Managed.After.targets
@@ -43,10 +43,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <_MainReferenceTarget Condition="'$(_MainReferenceTarget)' == ''">GetTargetPath</_MainReferenceTarget>
 
     <ProjectReferenceTargetsForBuildInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>
-    <ProjectReferenceTargetsForBuild>$(_MainReferenceTarget);GetNativeManifest;$(_RecursiveTargetForContentCopying);$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
+    <ProjectReferenceTargetsForBuild>$(_MainReferenceTarget);GetNativeManifest;$(_RecursiveTargetForContentCopying);GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
 
     <ProjectReferenceTargetsForCleanInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForCleanInOuterBuild)</ProjectReferenceTargetsForCleanInOuterBuild>
-    <ProjectReferenceTargetsForClean>Clean;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
+    <ProjectReferenceTargetsForClean>Clean;GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
 
     <ProjectReferenceTargetsForRebuildInOuterBuild>$(ProjectReferenceTargetsForCleanInOuterBuild);$(ProjectReferenceTargetsForBuildInOuterBuild);$(ProjectReferenceTargetsForRebuildInOuterBuild)</ProjectReferenceTargetsForRebuildInOuterBuild>
     <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 46a9a4846ce..a4e4fd164a2 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -1334,10 +1334,7 @@ internal enum AssemblyComparisonResult
         [HandleProcessCorruptedStateExceptions]
         internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrData, uint attrDataSize, out string strValue)
         {
-            IntPtr attrDataPostProlog = IntPtr.Zero;
             int attrDataOffset = 0;
-            int strLen = 0;
-            int i = 0;
             strValue = null;
 
             try
@@ -1354,8 +1351,9 @@ internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrDa
                 if ((attrDataSize >= 4) && (Marshal.ReadInt16(attrData, attrDataOffset) == 1))
                 {
                     int preReadOffset = 2; // pass the prolog
-                    attrDataPostProlog = attrData + preReadOffset;
+                    IntPtr attrDataPostProlog = attrData + preReadOffset;
 
+                    int strLen;
                     // Get the offset at which the uncompressed data starts, and the 
                     // length of the uncompressed data.
                     attrDataOffset = CorSigUncompressData(attrDataPostProlog, out strLen);
@@ -1368,6 +1366,7 @@ internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrDa
                         {
                             // Read in the uncompressed data
                             byte[] bytes = new byte[(int)strLen];
+                            int i;
                             for (i = 0; i < strLen; i++)
                             {
                                 bytes[i] = Marshal.ReadByte(attrDataPostProlog, attrDataOffset + i);
diff --git a/src/Tasks/RCWForCurrentContext.cs b/src/Tasks/RCWForCurrentContext.cs
index c8944fa05b1..0511c385cb1 100644
--- a/src/Tasks/RCWForCurrentContext.cs
+++ b/src/Tasks/RCWForCurrentContext.cs
@@ -79,7 +79,7 @@ public T RCW
         {
             get
             {
-                if (null == _rcwForCurrentCtx)
+                if (_rcwForCurrentCtx == null)
                 {
                     throw new ObjectDisposedException("RCWForCurrentCtx");
                 }
@@ -108,7 +108,7 @@ private void CleanupComObject()
         {
             try
             {
-                if (null != _rcwForCurrentCtx &&
+                if (_rcwForCurrentCtx != null &&
                     _shouldReleaseRCW &&
                     Marshal.IsComObject(_rcwForCurrentCtx))
                 {
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index 236d8102924..3632a916d83 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -252,7 +252,7 @@ private static string[] GetLinkedFiles(string filename, string baseLinkedFileDir
                         // contains the .resx file as the path from which it should resolve
                         // relative paths. So we should base our timestamp/existence checking
                         // on the same switch & resolve in the same manner as ResGen.
-                        resxReader.BasePath = (baseLinkedFileDirectory == null) ? Path.GetDirectoryName(filename) : baseLinkedFileDirectory;
+                        resxReader.BasePath = baseLinkedFileDirectory ?? Path.GetDirectoryName(filename);
 
                         foreach (DictionaryEntry dictEntry in resxReader)
                         {
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index 89ed55d4c40..a8cf11d7a56 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Globalization;
@@ -490,7 +489,7 @@ private bool ComputePathToTlbImp()
             {
                 _tlbimpPath = GetPathToSDKFileWithCurrentlyTargetedArchitecture("TlbImp.exe", TargetDotNetFrameworkVersion.Version35, VisualStudioVersion.VersionLatest);
 
-                if (null == _tlbimpPath && ExecuteAsTool)
+                if (_tlbimpPath == null && ExecuteAsTool)
                 {
                     Log.LogErrorWithCodeFromResources("General.PlatformSDKFileNotFound", "TlbImp.exe",
                         ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion.Version35, VisualStudioVersion.VersionLatest),
@@ -502,7 +501,7 @@ private bool ComputePathToTlbImp()
                 _tlbimpPath = SdkToolsPathUtility.GeneratePathToTool(SdkToolsPathUtility.FileInfoExists, TargetProcessorArchitecture, SdkToolsPath, "TlbImp.exe", Log, ExecuteAsTool);
             }
 
-            if (null == _tlbimpPath && !ExecuteAsTool)
+            if (_tlbimpPath == null && !ExecuteAsTool)
             {
                 // if TlbImp.exe is not installed, just use the filename
                 _tlbimpPath = "TlbImp.exe";
@@ -539,7 +538,7 @@ private bool ComputePathToAxImp()
                 // We want to use the copy of AxImp corresponding to our targeted architecture if possible.  
                 _aximpPath = GetPathToSDKFileWithCurrentlyTargetedArchitecture("AxImp.exe", targetAxImpVersion, VisualStudioVersion.VersionLatest);
 
-                if (null == _aximpPath)
+                if (_aximpPath == null)
                 {
                     Log.LogErrorWithCodeFromResources("General.PlatformSDKFileNotFound", "AxImp.exe",
                         ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(targetAxImpVersion, VisualStudioVersion.VersionLatest),
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index ab41808f881..8d449461da6 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -7,6 +7,7 @@
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
@@ -46,9 +47,11 @@ public sealed class ResolveManifestFiles : TaskExtension
         private CultureInfo _targetCulture;
         private bool _includeAllSatellites;
 
+        private string _targetFrameworkIdentifier;
         private string _targetFrameworkVersion;
         // if signing manifests is on and not all app files are included, then the project can't be published.
         private bool _canPublish;
+        private Dictionary<string, ITaskItem> _runtimePackAssets;
         #endregion
 
         #region Properties
@@ -81,6 +84,15 @@ public ITaskItem[] NativeAssemblies
             set => _nativeAssemblies = Util.SortItems(value);
         }
 
+        // Runtime assets for self-contained deployment from .NETCore runtime pack
+        public ITaskItem[] RuntimePackAssets { get; set; }
+
+        // True if deployment mode during publish is set to self-contained mode
+        public bool IsSelfContainedPublish { get; set; } = false;
+
+        // True if single file publish is on
+        public bool IsSingleFilePublish { get; set; } = false;
+
         [Output]
         public ITaskItem[] OutputAssemblies { get; set; }
 
@@ -109,6 +121,10 @@ public ITaskItem[] SatelliteAssemblies
 
         public bool SigningManifests { get; set; }
 
+        public string AssemblyName { get; set; }
+
+        public bool LauncherBasedDeployment {get; set; } = false;
+
         public string TargetFrameworkVersion
         {
             get
@@ -122,6 +138,19 @@ public string TargetFrameworkVersion
             set => _targetFrameworkVersion = value;
         }
 
+        public string TargetFrameworkIdentifier
+        {
+            get
+            {
+                if (string.IsNullOrEmpty(_targetFrameworkIdentifier))
+                {
+                    return Constants.DotNetFrameworkIdentifier;
+                }
+                return _targetFrameworkIdentifier;
+            }
+            set => _targetFrameworkIdentifier = value;
+        }
+
         #endregion
 
         public override bool Execute()
@@ -137,6 +166,12 @@ public override bool Execute()
 
             GetPublishInfo(out List<PublishInfo> assemblyPublishInfoList, out List<PublishInfo> filePublishInfoList, out List<PublishInfo> satellitePublishInfoList, out List<PublishInfo> manifestEntryPointList);
 
+            // Create dictionary for runtimepack assets
+            if (RuntimePackAssets != null && RuntimePackAssets.Length > 0)
+            {
+                _runtimePackAssets = RuntimePackAssets.ToDictionary(p => p.ItemSpec, StringComparer.OrdinalIgnoreCase);
+            }
+
             OutputAssemblies = GetOutputAssembliesAndSatellites(assemblyPublishInfoList, satellitePublishInfoList);
 
             if (!_canPublish && is35Project)
@@ -238,13 +273,27 @@ private static ITaskItem CreateAssemblyItem(ITaskItem item, string group, string
         }
 
         // Creates an output item for a file, with optional Group and IsData attributes.
-        private static ITaskItem CreateFileItem(ITaskItem item, string group, string targetPath, string includeHash, bool isDataFile)
+        private ITaskItem CreateFileItem(ITaskItem item, string group, string targetPath, string includeHash, bool isDataFile)
         {
             ITaskItem outputItem = new TaskItem(item.ItemSpec);
             item.CopyMetadataTo(outputItem);
             if (String.IsNullOrEmpty(targetPath))
             {
-                targetPath = GetItemTargetPath(outputItem);
+                targetPath = Path.GetFileName(item.ItemSpec);
+                //
+                // .NETCore Launcher.exe based deployment: If the file is apphost.exe, we need to set 'TargetPath' metadata
+                // to {assemblyname}.exe so that the file gets published as {assemblyname}.exe and not apphost.exe.
+                //
+                if (LauncherBasedDeployment && 
+                    targetPath.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase) &&
+                    !String.IsNullOrEmpty(AssemblyName))
+                {
+                    targetPath = AssemblyName;
+                }
+                else
+                {
+                    targetPath = GetItemTargetPath(outputItem);
+                }
             }
             outputItem.SetMetadata(ItemMetadataNames.targetPath, targetPath);
             if (!String.IsNullOrEmpty(group) && !isDataFile)
@@ -616,6 +665,15 @@ private void GetPublishInfo(
 
         private bool IsFiltered(ITaskItem item)
         {
+            // In the case of .NET Core apps published as self-contained with loose files (i.e. PublishSingleFile != true),
+            // .NETCore binaries that come from the .NETCore Runtime pack should not be filtered out.
+            if (IsSelfContainedPublish && !IsSingleFilePublish &&
+                _runtimePackAssets != null &&
+                _runtimePackAssets.TryGetValue(item.ItemSpec, out _))
+            {
+                return false;
+            }
+
             // If assembly is part of the FX then it should be filtered out...
             // System.Reflection.AssemblyName.GetAssemblyName throws if file is not an assembly.
             // We're using AssemblyIdentity.FromManagedAssembly here because it just does an
@@ -630,7 +688,14 @@ private bool IsFiltered(ITaskItem item)
                 return true;
             }
 
-            if (identity?.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion) == true)
+            if (String.Equals(TargetFrameworkIdentifier, Constants.DotNetCoreAppIdentifier, StringComparison.InvariantCultureIgnoreCase))
+            {
+                if (identity?.IsInFramework(Constants.DotNetCoreIdentifier, null) == true)
+                {
+                    return true;
+                }
+            }
+            else if (identity?.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion) == true)
             {
                 return true;
             }
diff --git a/src/Tasks/ResourceHandling/BinaryFormatterByteArrayResource.cs b/src/Tasks/ResourceHandling/BinaryFormatterByteArrayResource.cs
index 2da459e1c88..fc4d2ad8d24 100644
--- a/src/Tasks/ResourceHandling/BinaryFormatterByteArrayResource.cs
+++ b/src/Tasks/ResourceHandling/BinaryFormatterByteArrayResource.cs
@@ -1,15 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Shared;
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
 using System.Resources;
 using System.Resources.Extensions;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Tasks.ResourceHandling
 {
diff --git a/src/Tasks/ResourceHandling/FileStreamResource.cs b/src/Tasks/ResourceHandling/FileStreamResource.cs
index 779c5a4e826..b689f14d2f4 100644
--- a/src/Tasks/ResourceHandling/FileStreamResource.cs
+++ b/src/Tasks/ResourceHandling/FileStreamResource.cs
@@ -1,15 +1,9 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Shared;
-using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Linq;
 using System.Resources;
 using System.Resources.Extensions;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Tasks.ResourceHandling
 {
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index 06437e4493b..58c4a455c2c 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -3,14 +3,10 @@
 
 using Microsoft.Build.Shared;
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Collections.Immutable;
 using System.IO;
-using System.Linq;
 using System.Reflection;
 using System.Text;
-using System.Threading.Tasks;
 using System.Xml;
 using System.Xml.Linq;
 
diff --git a/src/Tasks/ResourceHandling/StringResource.cs b/src/Tasks/ResourceHandling/StringResource.cs
index 092162561f2..ece4e87deb5 100644
--- a/src/Tasks/ResourceHandling/StringResource.cs
+++ b/src/Tasks/ResourceHandling/StringResource.cs
@@ -1,12 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
 using System.Resources;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Tasks.ResourceHandling
 {
diff --git a/src/Tasks/ResourceHandling/TypeConverterByteArrayResource.cs b/src/Tasks/ResourceHandling/TypeConverterByteArrayResource.cs
index 6be9dd13d18..c8f391f8735 100644
--- a/src/Tasks/ResourceHandling/TypeConverterByteArrayResource.cs
+++ b/src/Tasks/ResourceHandling/TypeConverterByteArrayResource.cs
@@ -1,15 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Shared;
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
 using System.Resources;
 using System.Resources.Extensions;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Tasks.ResourceHandling
 {
diff --git a/src/Tasks/ResourceHandling/TypeConverterStringResource.cs b/src/Tasks/ResourceHandling/TypeConverterStringResource.cs
index 534a04927cd..f0b9ed23c5e 100644
--- a/src/Tasks/ResourceHandling/TypeConverterStringResource.cs
+++ b/src/Tasks/ResourceHandling/TypeConverterStringResource.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Shared;
 using System.Resources;
 using System.Resources.Extensions;
 
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index cc1e2699443..b465dd10789 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -1569,7 +1569,8 @@
     <comment>{StrBegin="MSB3276: "}</comment>
   </data>
   <data name="ResolveAssemblyReference.FoundConflicts">
-    <value>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</value>
+    <value>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</value>
     <comment>{StrBegin="MSB3277: "}</comment>
   </data>
   <data name="ResolveAssemblyReference.LogAttributeFormat">
@@ -2160,7 +2161,10 @@
     <value>MSB3645: .NET Framework v3.5 Service Pack 1 was not found. In order to target "{0}", .NET Framework v3.5 Service Pack 1 or later must be installed.</value>
     <comment>{StrBegin="MSB3645: "}</comment>
   </data>
-
+  <data name="GetReferenceAssemblyPaths.OutOfDateSDK">
+    <value>MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</value>
+    <comment>{StrBegin="MSB3971: "}</comment>
+  </data>
 
   <!--
         The WinMDExp task has the error buckets of MSB3762 - MSB3772
@@ -2832,6 +2836,31 @@
     <value>MSB3954: Failed to compute hash for file '{0}' because it does not exist or is inaccessible.</value>
     <comment>{StrBegin="MSB3954: "}</comment>
   </data>
+
+  <!--
+        MSB3961 - MSB3970   Task: GenerateLauncher
+        If this bucket overflows, pls. contact 'vsppbdev'.
+  -->
+  <data name="GenerateLauncher.CopyError">
+    <value>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</value>
+    <comment>{StrBegin="MSB3961: "}</comment>
+  </data>
+  <data name="GenerateLauncher.General">
+    <value>MSB3962: An error occurred generating a launcher: {0}</value>
+    <comment>{StrBegin="MSB3962: "}</comment>
+  </data>
+  <data name="GenerateLauncher.InvalidInput">
+    <value>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</value>
+    <comment>{StrBegin="MSB3963: "}</comment>
+  </data>
+  <data name="GenerateLauncher.MissingLauncherExe">
+    <value>MSB3964: Could not find required file '{0}'.</value>
+    <comment>{StrBegin="MSB3964: "}</comment>
+  </data>
+  <data name="GenerateLauncher.NoOutputPath">
+    <value>MSB3965: No output path specified in build settings.</value>
+    <comment>{StrBegin="MSB3965: "}</comment>
+  </data>
   <!--
         The tasks message bucket is: MSB3001 - MSB3999
 
@@ -2915,6 +2944,8 @@
             MSB3931 - MSB3940   Task: Unzip
             MSB3941 - MSB3950   Task: ZipDirectory
             MSB3951 - MSB3960   Task: VerifyFileHash
+            MSB3961 - MSB3970   Task: GenerateLauncher
+            MSB3971 - MSB3980   Task: GetReferenceAssemblyPaths overflow
 
             MSB4000 - MSB4200   Portable targets & tasks (vsproject\flavors\portable\msbuild)
             MSB9000 - MSB9900   MSBuild targets files (C++)
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 9598c9d6157..5e5782da0a1 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -774,6 +774,31 @@
         <target state="translated">MSB3160: Upozornění ověření Xml v souboru {0}: {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="translated">MSB3961: Při pokusu o zkopírování položky {0} do umístění {1} došlo k chybě: {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="translated">MSB3962: Při generování spouštěče došlo k chybě: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="translated">MSB3963: Nebyl k dispozici dostatek dat k vygenerování spouštěče. Zadejte prosím hodnotu EntryPoint.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="translated">MSB3964: Nepovedlo se najít požadovaný soubor {0}.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="translated">MSB3965: V nastavení sestavení nebyla zadána žádná výstupní cesta.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: Odkaz {0} nepovoluje částečně důvěryhodné volající.</target>
@@ -1306,6 +1331,11 @@
         <target state="translated">Byla nalezena instalace sady Microsoft Windows SDK v umístění {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="GetReferenceAssemblyPaths.OutOfDateSDK">
+        <source>MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</source>
+        <target state="new">MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</target>
+        <note>{StrBegin="MSB3971: "}</note>
+      </trans-unit>
       <trans-unit id="MakeDir.Comment">
         <source>Creating directory "{0}".</source>
         <target state="translated">Probíhá vytváření adresáře {0}.</target>
@@ -1802,8 +1832,10 @@
         <note>{StrBegin="MSB3276: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.FoundConflicts">
-        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</source>
-        <target state="translated">MSB3277: Byly zjištěny konflikty mezi různými verzemi sestavení {0}. Tyto problémy nebylo možné vyřešit. Tyto konflikty odkazů jsou uvedeny v protokolu sestavení, jestliže je protokolování nastaveno jako podrobné.</target>
+        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</source>
+        <target state="new">MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</target>
         <note>{StrBegin="MSB3277: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.LogAttributeFormat">
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 44b9fbe1ba8..63259a0d892 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -774,6 +774,31 @@
         <target state="translated">MSB3160: XML-Validierungswarnung in der Datei "{0}": {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="translated">MSB3961: Fehler beim Kopieren von "{0}" nach "{1}": {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="translated">MSB3962: Fehler beim Generieren eines Startprogramms: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="translated">MSB3963: Es wurden nicht genügend Daten zum Generieren eines Startprogramms bereitgestellt. Geben Sie einen Wert für "EntryPoint" an.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="translated">MSB3964: Die erforderliche Datei "{0}" wurde nicht gefunden.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="translated">MSB3965: In den Buildeinstellungen wurde kein Ausgabepfad angegeben.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: Der Verweis "{0}" lässt Aufrufer, die nur teilweise vertrauenswürdig sind, nicht zu.</target>
@@ -1306,6 +1331,11 @@
         <target state="translated">Eine Installation des Microsoft Windows SDK wurde in "{0}" gefunden.</target>
         <note />
       </trans-unit>
+      <trans-unit id="GetReferenceAssemblyPaths.OutOfDateSDK">
+        <source>MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</source>
+        <target state="new">MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</target>
+        <note>{StrBegin="MSB3971: "}</note>
+      </trans-unit>
       <trans-unit id="MakeDir.Comment">
         <source>Creating directory "{0}".</source>
         <target state="translated">Das Verzeichnis "{0}" wird erstellt.</target>
@@ -1802,8 +1832,10 @@
         <note>{StrBegin="MSB3276: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.FoundConflicts">
-        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</source>
-        <target state="translated">MSB3277: Es wurden Konflikte zwischen verschiedenen Versionen von "{0}" gefunden, die nicht gelöst werden konnten. Diese Verweiskonflikte werden im Buildprotokoll aufgelistet, wenn die Protokollausführlichkeit auf "Ausführlich" festgelegt ist.</target>
+        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</source>
+        <target state="new">MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</target>
         <note>{StrBegin="MSB3277: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.LogAttributeFormat">
diff --git a/src/Tasks/Resources/xlf/Strings.en.xlf b/src/Tasks/Resources/xlf/Strings.en.xlf
index c9d6885f10c..0c447b05ab3 100644
--- a/src/Tasks/Resources/xlf/Strings.en.xlf
+++ b/src/Tasks/Resources/xlf/Strings.en.xlf
@@ -819,6 +819,31 @@
         <target state="new">MSB3160: Xml Validation warning in file '{0}': {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="new">MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="new">MSB3962: An error occurred generating a launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="new">MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="new">MSB3964: Could not find required file '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="new">MSB3965: No output path specified in build settings.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="new">MSB3177: Reference '{0}' does not allow partially trusted callers.</target>
@@ -1351,6 +1376,11 @@
         <target state="new">Found the Microsoft Windows SDK installed at "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="GetReferenceAssemblyPaths.OutOfDateSDK">
+        <source>MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</source>
+        <target state="new">MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</target>
+        <note>{StrBegin="MSB3971: "}</note>
+      </trans-unit>
       <trans-unit id="MakeDir.Comment">
         <source>Creating directory "{0}".</source>
         <target state="new">Creating directory "{0}".</target>
@@ -1847,8 +1877,10 @@
         <note>{StrBegin="MSB3276: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.FoundConflicts">
-        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</source>
-        <target state="new">MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</target>
+        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</source>
+        <target state="new">MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</target>
         <note>{StrBegin="MSB3277: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.LogAttributeFormat">
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index e34aa053c3e..75c343a1b85 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -774,6 +774,31 @@
         <target state="translated">MSB3160: Advertencia de validación XML en el archivo '{0}': {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="translated">MSB3961: Error al intentar copiar "{0}" en "{1}": {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="translated">MSB3962: Error al generar un iniciador: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="translated">MSB3963: No se han proporcionado datos suficientes para generar un iniciador. Proporcione un valor para "EntryPoint".</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="translated">MSB3964: No se encuentra el archivo "{0}" necesario.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="translated">MSB3965: No se especificó la ruta de acceso de salida en la configuración de compilación.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: La referencia '{0}' no permite llamadores de confianza parcial.</target>
@@ -1306,6 +1331,11 @@
         <target state="translated">Se encontró Microsoft Windows SDK instalado en "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="GetReferenceAssemblyPaths.OutOfDateSDK">
+        <source>MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</source>
+        <target state="new">MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</target>
+        <note>{StrBegin="MSB3971: "}</note>
+      </trans-unit>
       <trans-unit id="MakeDir.Comment">
         <source>Creating directory "{0}".</source>
         <target state="translated">Creando directorio "{0}".</target>
@@ -1802,8 +1832,10 @@
         <note>{StrBegin="MSB3276: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.FoundConflicts">
-        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</source>
-        <target state="translated">MSB3277: Se encontraron conflictos entre diferentes versiones de "{0}" que no se pudieron resolver. Estos conflictos de referencia se enumeran en el registro de compilación si su nivel de detalle está establecido como detallado.</target>
+        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</source>
+        <target state="new">MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</target>
         <note>{StrBegin="MSB3277: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.LogAttributeFormat">
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 9720b69bf5f..69d7093223a 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -774,6 +774,31 @@
         <target state="translated">MSB3160: Avertissement de validation XML dans le fichier '{0}' : {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="translated">MSB3961: une erreur s'est produite durant la tentative de copie de '{0}' vers '{1}' : {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="translated">MSB3962: une erreur s'est produite durant la génération d'un lanceur : {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="translated">MSB3963: les données fournies sont insuffisantes pour générer un lanceur. Fournissez une valeur pour 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="translated">MSB3964: le fichier nécessaire '{0}' est introuvable.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="translated">MSB3965: aucun chemin de sortie spécifié dans les paramètres de build.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: La référence '{0}' n'autorise pas les appelants dont le niveau de confiance n'est pas suffisant.</target>
@@ -1173,7 +1198,7 @@
       </trans-unit>
       <trans-unit id="GenerateResource.AdditionalInputNewerThanTLog">
         <source>Additional input "{0}" has been updated since the last build.  Forcing regeneration of all resources.</source>
-        <target state="translated">L'entrée supplémentaire "{0}" a été mise à jour depuis la dernière génération.  Régénération forcée de toutes les ressources.</target>
+        <target state="translated">L'entrée supplémentaire "{0}" a été mise à jour depuis la dernière génération.  Regénération forcée de toutes les ressources.</target>
         <note />
       </trans-unit>
       <trans-unit id="GenerateResource.SeparateAppDomainBecauseNeverLockTypeAssembliesTrue">
@@ -1306,6 +1331,11 @@
         <target state="translated">Le Kit de développement Microsoft Windows SDK a été trouvé dans "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="GetReferenceAssemblyPaths.OutOfDateSDK">
+        <source>MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</source>
+        <target state="new">MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</target>
+        <note>{StrBegin="MSB3971: "}</note>
+      </trans-unit>
       <trans-unit id="MakeDir.Comment">
         <source>Creating directory "{0}".</source>
         <target state="translated">Création du répertoire "{0}".</target>
@@ -1459,7 +1489,7 @@
       </trans-unit>
       <trans-unit id="RegisterAssembly.TypeLibUpToDate">
         <source>Type library "{0}" is up to date, skipping regeneration.</source>
-        <target state="translated">La bibliothèque de types "{0}" est à jour, régénération ignorée.</target>
+        <target state="translated">La bibliothèque de types "{0}" est à jour, regénération ignorée.</target>
         <note />
       </trans-unit>
       <trans-unit id="RegisterAssembly.UnauthorizedAccess">
@@ -1802,8 +1832,10 @@
         <note>{StrBegin="MSB3276: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.FoundConflicts">
-        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</source>
-        <target state="translated">MSB3277: Des conflits entre différentes versions de "{0}" ont été trouvés et n'ont pas pu être résolus.  Ces conflits de référence sont consignés dans le journal de génération quand la verbosité du journal est définie sur Detailed.</target>
+        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</source>
+        <target state="new">MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</target>
         <note>{StrBegin="MSB3277: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.LogAttributeFormat">
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 7ce334457fc..1a23962fb62 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -774,6 +774,31 @@
         <target state="translated">MSB3160: avviso di convalida XML nel file '{0}': {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="translated">MSB3961: si è verificato un errore durante il tentativo di copiare '{0}' in '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="translated">MSB3962: si è verificato un errore durante la generazione di un launcher: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="translated">MSB3963: i dati forniti non sono sufficienti per la generazione di un launcher. Specificare un valore per 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="translated">MSB3964: non è stato possibile trovare il file richiesto '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="translated">MSB3965: non è stato specificato alcun percorso di output nelle impostazioni di compilazione.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: il riferimento '{0}' non consente chiamanti parzialmente attendibili.</target>
@@ -1306,6 +1331,11 @@
         <target state="translated">Rilevato Microsoft Windows SDK installato in "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="GetReferenceAssemblyPaths.OutOfDateSDK">
+        <source>MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</source>
+        <target state="new">MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</target>
+        <note>{StrBegin="MSB3971: "}</note>
+      </trans-unit>
       <trans-unit id="MakeDir.Comment">
         <source>Creating directory "{0}".</source>
         <target state="translated">Creazione directory "{0}".</target>
@@ -1802,8 +1832,10 @@
         <note>{StrBegin="MSB3276: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.FoundConflicts">
-        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</source>
-        <target state="translated">MSB3277: sono stati rilevati conflitti irrisolvibili tra versioni diverse di "{0}". Questi conflitti dei riferimenti sono elencati nel log di compilazione quando il livello di dettaglio del log è impostato su dettagliato.</target>
+        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</source>
+        <target state="new">MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</target>
         <note>{StrBegin="MSB3277: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.LogAttributeFormat">
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 52d2825682c..e339715b791 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -774,6 +774,31 @@
         <target state="translated">MSB3160: ファイル '{0}' での XML 検証警告です: {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="translated">MSB3961: '{0}' を '{1}' にコピーしようとしてエラーが発生しました: {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="translated">MSB3962: 起動ツールの生成中にエラーが発生しました: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="translated">MSB3963: 起動ツールを生成するために十分なデータが指定されませんでした。'EntryPoint' の値を指定してください。</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="translated">MSB3964: 必要なファイル '{0}' が見つかりませんでした。</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="translated">MSB3965: 出力パスがビルド設定で指定されていません。</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: 参照 '{0}' は部分的に信頼された呼び出し側を許可しません。</target>
@@ -1306,6 +1331,11 @@
         <target state="translated">Microsoft Windows SDK が "{0}" にインストールされていました。</target>
         <note />
       </trans-unit>
+      <trans-unit id="GetReferenceAssemblyPaths.OutOfDateSDK">
+        <source>MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</source>
+        <target state="new">MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</target>
+        <note>{StrBegin="MSB3971: "}</note>
+      </trans-unit>
       <trans-unit id="MakeDir.Comment">
         <source>Creating directory "{0}".</source>
         <target state="translated">ディレクトリ "{0}" を作成しています。</target>
@@ -1802,8 +1832,10 @@
         <note>{StrBegin="MSB3276: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.FoundConflicts">
-        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</source>
-        <target state="translated">MSB3277: "{0}" の異なるバージョン間で、解決できない競合が見つかりました。これらの参照上の競合は、ログの詳細度が詳細に設定されている場合にビルド ログにリストされます。</target>
+        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</source>
+        <target state="new">MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</target>
         <note>{StrBegin="MSB3277: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.LogAttributeFormat">
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 2e70e167585..f6bf91b9f77 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -774,6 +774,31 @@
         <target state="translated">MSB3160: '{0}' 파일에서 XML 유효성 검사 경고가 발생했습니다. {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="translated">MSB3961: '{0}'을(를) '{1}'에 복사하는 동안 오류가 발생했습니다. {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="translated">MSB3962: 시작 관리자를 생성하는 동안 오류가 발생했습니다. {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="translated">MSB3963: 시작 관리자를 생성하는 데 충분한 데이터가 제공되지 않았습니다. 'EntryPoint'의 값을 제공하세요.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="translated">MSB3964: 필요한 파일 '{0}'을(를) 찾을 수 없습니다.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="translated">MSB3965: 빌드 설정에 출력 경로를 지정하지 않았습니다.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: '{0}' 참조에는 부분적으로 신뢰할 수 있는 호출자를 사용할 수 없습니다.</target>
@@ -1306,6 +1331,11 @@
         <target state="translated">Microsoft Windows SDK가 "{0}"에 설치되어 있습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="GetReferenceAssemblyPaths.OutOfDateSDK">
+        <source>MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</source>
+        <target state="new">MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</target>
+        <note>{StrBegin="MSB3971: "}</note>
+      </trans-unit>
       <trans-unit id="MakeDir.Comment">
         <source>Creating directory "{0}".</source>
         <target state="translated">"{0}" 디렉터리를 만들고 있습니다.</target>
@@ -1802,8 +1832,10 @@
         <note>{StrBegin="MSB3276: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.FoundConflicts">
-        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</source>
-        <target state="translated">MSB3277: 확인할 수 없는 "{0}"의 서로 다른 버전이 충돌합니다. 이러한 참조 충돌은 로그의 세부 정보 표시가 [자세히]로 설정된 경우 빌드 로그에 나열됩니다.</target>
+        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</source>
+        <target state="new">MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</target>
         <note>{StrBegin="MSB3277: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.LogAttributeFormat">
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 6b53dc24fb7..1a059952732 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -774,6 +774,31 @@
         <target state="translated">MSB3160: Ostrzeżenie walidacji kodu xml w pliku '{0}': {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="translated">MSB3961: Wystąpił błąd podczas próby skopiowania elementu „{0}” do elementu „{1}”: {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="translated">MSB3962: Wystąpił problem podczas generowania modułu uruchamiania: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="translated">MSB3963: Podano za mało danych do wygenerowania modułu uruchamiania. Podaj wartość dla: „EntryPoint”.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="translated">MSB3964: Nie można było znaleźć wymaganego pliku „{0}”.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="translated">MSB3965: W ustawieniach kompilacji nie określono ścieżki wyjściowej.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: Odwołanie '{0}' nie zezwala na dostęp częściowo zaufanych wywołań.</target>
@@ -1306,6 +1331,11 @@
         <target state="translated">Znaleziono zestaw Microsoft Windows SDK zainstalowany w lokalizacji „{0}”.</target>
         <note />
       </trans-unit>
+      <trans-unit id="GetReferenceAssemblyPaths.OutOfDateSDK">
+        <source>MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</source>
+        <target state="new">MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</target>
+        <note>{StrBegin="MSB3971: "}</note>
+      </trans-unit>
       <trans-unit id="MakeDir.Comment">
         <source>Creating directory "{0}".</source>
         <target state="translated">Tworzenie katalogu „{0}”.</target>
@@ -1802,8 +1832,10 @@
         <note>{StrBegin="MSB3276: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.FoundConflicts">
-        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</source>
-        <target state="translated">MSB3277: Wykryto konflikty pomiędzy różnymi wersjami elementu „{0}”, których nie można rozwiązać. Takie konflikty odwołań są rejestrowane w dzienniku kompilacji po ustawieniu wysokiego poziomu szczegółowości.</target>
+        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</source>
+        <target state="new">MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</target>
         <note>{StrBegin="MSB3277: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.LogAttributeFormat">
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 0d31dafd981..659e4e64cd8 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -774,6 +774,31 @@
         <target state="translated">MSB3160: Aviso de validação de XML no arquivo "{0}": {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="translated">MSB3961: erro ao tentar copiar '{0}' para '{1}': {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="translated">MSB3962: erro ao gerar um inicializador: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="translated">MSB3963: não foram fornecidos dados suficientes para gerar um iniciador. Forneça um valor para: 'EntryPoint'.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="translated">MSB3964: não foi possível localizar o arquivo necessário '{0}'.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="translated">MSB3965: não foi especificado nenhum caminho de saída nas configurações de build.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: A referência "{0}" não admite chamadores parcialmente confiáveis.</target>
@@ -1306,6 +1331,11 @@
         <target state="translated">Localizado o SDK do Microsoft Windows instalado em "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="GetReferenceAssemblyPaths.OutOfDateSDK">
+        <source>MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</source>
+        <target state="new">MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</target>
+        <note>{StrBegin="MSB3971: "}</note>
+      </trans-unit>
       <trans-unit id="MakeDir.Comment">
         <source>Creating directory "{0}".</source>
         <target state="translated">Criando o diretório "{0}".</target>
@@ -1802,8 +1832,10 @@
         <note>{StrBegin="MSB3276: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.FoundConflicts">
-        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</source>
-        <target state="translated">MSB3277: foram encontrados conflitos entre versões diferentes "{0}" que não puderam ser resolvidos. Esses conflitos de referência estão relacionados no log de build quando o detalhamento do log está definido como detalhado.</target>
+        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</source>
+        <target state="new">MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</target>
         <note>{StrBegin="MSB3277: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.LogAttributeFormat">
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 29fe42402d0..363d15cb6bd 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -774,6 +774,31 @@
         <target state="translated">MSB3160: Предупреждение проверки Xml в файле "{0}": {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="translated">MSB3961: произошла ошибка при попытке скопировать элемент "{0}" в "{1}": {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="translated">MSB3962: произошла ошибка при создании средства запуска: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="translated">MSB3963: указано недостаточно данных для создания средства запуска. Укажите значение параметра "EntryPoint".</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="translated">MSB3964: не удалось найти требуемый файл "{0}".</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="translated">MSB3965: в параметрах сборки не указан путь для вывода.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: Ссылка "{0}" не допускает частично безопасные вызывающие стороны.</target>
@@ -1306,6 +1331,11 @@
         <target state="translated">Обнаружен пакет средств разработки Microsoft Windows SDK, установленный в "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="GetReferenceAssemblyPaths.OutOfDateSDK">
+        <source>MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</source>
+        <target state="new">MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</target>
+        <note>{StrBegin="MSB3971: "}</note>
+      </trans-unit>
       <trans-unit id="MakeDir.Comment">
         <source>Creating directory "{0}".</source>
         <target state="translated">Создание каталога "{0}".</target>
@@ -1802,8 +1832,10 @@
         <note>{StrBegin="MSB3276: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.FoundConflicts">
-        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</source>
-        <target state="translated">MSB3277: обнаружены неразрешимые конфликты между различными версиями "{0}". Эти конфликты перечисляются в журнале сборки, если выбран подробный уровень детализации журнала.</target>
+        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</source>
+        <target state="new">MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</target>
         <note>{StrBegin="MSB3277: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.LogAttributeFormat">
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 5076d987e41..ee2ca18a75d 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -774,6 +774,31 @@
         <target state="translated">MSB3160: '{0}' dosyasında Xml Doğrulaması uyarısı oluştu: {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="translated">MSB3961: '{0}', '{1}' konumuna kopyalanmaya çalışılırken hata oluştu: {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="translated">MSB3962: Başlatıcı oluşturulurken hata oluştu: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="translated">MSB3963: Başlatıcı oluşturmak için yeterli veri sağlanmadı. Lütfen 'EntryPoint' için bir değer girin.</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="translated">MSB3964: Gereken '{0}' dosyası bulunamadı.</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="translated">MSB3965: Oluşturma ayarlarında çıkış yolu belirtilmedi.</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: '{0}' başvurusu, kısmen güvenilen çağıranlara izin vermiyor.</target>
@@ -1306,6 +1331,11 @@
         <target state="translated">"{0}" konumuna yüklenmiş Microsoft Windows SDK bulundu.</target>
         <note />
       </trans-unit>
+      <trans-unit id="GetReferenceAssemblyPaths.OutOfDateSDK">
+        <source>MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</source>
+        <target state="new">MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</target>
+        <note>{StrBegin="MSB3971: "}</note>
+      </trans-unit>
       <trans-unit id="MakeDir.Comment">
         <source>Creating directory "{0}".</source>
         <target state="translated">"{0}" dizini oluşturuluyor.</target>
@@ -1802,8 +1832,10 @@
         <note>{StrBegin="MSB3276: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.FoundConflicts">
-        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</source>
-        <target state="translated">MSB3277: Farklı "{0}" sürümleri arasında çözümlenemeyen çakışmalar bulundu. Derleme günlüğünün ayrıntı düzeyi için ayrıntılı seçeneği ayarlandığında bu başvuru çakışmaları günlükte listelenir.</target>
+        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</source>
+        <target state="new">MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</target>
         <note>{StrBegin="MSB3277: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.LogAttributeFormat">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 2797e21cd0b..ea6cfc85cd5 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -774,6 +774,31 @@
         <target state="translated">MSB3160: 文件“{0}”中的 XML 验证警告: {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="translated">MSB3961: 尝试将“{0}”复制到“{1}”时出错: {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="translated">MSB3962: 生成引导程序时出错: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="translated">MSB3963: 未提供足够的数据来生成启动程序。请为 "EntryPoint" 提供一个值。</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="translated">MSB3964: 找不到所需的文件“{0}”。</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="translated">MSB3965: 生成设置中未指定输出路径。</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: 引用“{0}”不允许部分信任的调用方。</target>
@@ -1306,6 +1331,11 @@
         <target state="translated">找到安装在“{0}”的 Microsoft Windows SDK。</target>
         <note />
       </trans-unit>
+      <trans-unit id="GetReferenceAssemblyPaths.OutOfDateSDK">
+        <source>MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</source>
+        <target state="new">MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</target>
+        <note>{StrBegin="MSB3971: "}</note>
+      </trans-unit>
       <trans-unit id="MakeDir.Comment">
         <source>Creating directory "{0}".</source>
         <target state="translated">正在创建目录“{0}”。</target>
@@ -1802,8 +1832,10 @@
         <note>{StrBegin="MSB3276: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.FoundConflicts">
-        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</source>
-        <target state="translated">MSB3277: 发现“{0}”的不同版本间存在无法解决的冲突。当日志详细程度设置为“详细”时，这些引用冲突将会在生成日志中列出。</target>
+        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</source>
+        <target state="new">MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</target>
         <note>{StrBegin="MSB3277: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.LogAttributeFormat">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 05c4f11672b..710cba8dd90 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -774,6 +774,31 @@
         <target state="translated">MSB3160: 檔案 '{0}' 中發生 XML 驗證警告: {1}</target>
         <note>{StrBegin="MSB3160: "}</note>
       </trans-unit>
+      <trans-unit id="GenerateLauncher.CopyError">
+        <source>MSB3961: An error occurred trying to copy '{0}' to '{1}': {2}</source>
+        <target state="translated">MSB3961: 嘗試將 '{0}' 複製到 '{1}' 時發生錯誤: {2}</target>
+        <note>{StrBegin="MSB3961: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.General">
+        <source>MSB3962: An error occurred generating a launcher: {0}</source>
+        <target state="translated">MSB3962: 產生啟動器時發生錯誤: {0}</target>
+        <note>{StrBegin="MSB3962: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.InvalidInput">
+        <source>MSB3963: Not enough data was provided to generate a launcher. Please provide a value for: 'EntryPoint'.</source>
+        <target state="translated">MSB3963: 提供的資料不足，無法產生啟動器。請提供 'EntryPoint' 的值。</target>
+        <note>{StrBegin="MSB3963: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.MissingLauncherExe">
+        <source>MSB3964: Could not find required file '{0}'.</source>
+        <target state="translated">MSB3964: 找不到必要的檔案 '{0}'。</target>
+        <note>{StrBegin="MSB3964: "}</note>
+      </trans-unit>
+      <trans-unit id="GenerateLauncher.NoOutputPath">
+        <source>MSB3965: No output path specified in build settings.</source>
+        <target state="translated">MSB3965: 組建設定中未指定輸出路徑。</target>
+        <note>{StrBegin="MSB3965: "}</note>
+      </trans-unit>
       <trans-unit id="GenerateManifest.AllowPartiallyTrustedCallers">
         <source>MSB3177: Reference '{0}' does not allow partially trusted callers.</source>
         <target state="translated">MSB3177: 參考 '{0}' 不允許部分信任的呼叫端。</target>
@@ -1306,6 +1331,11 @@
         <target state="translated">找到安裝在 "{0}" 的 Microsoft Windows SDK。</target>
         <note />
       </trans-unit>
+      <trans-unit id="GetReferenceAssemblyPaths.OutOfDateSDK">
+        <source>MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</source>
+        <target state="new">MSB3971: The reference assemblies for "{0}" were not found. You might be using an older .NET SDK to target .NET 5.0 or higher. Update Visual Studio and/or your .NET SDK.</target>
+        <note>{StrBegin="MSB3971: "}</note>
+      </trans-unit>
       <trans-unit id="MakeDir.Comment">
         <source>Creating directory "{0}".</source>
         <target state="translated">正在建立目錄 "{0}"。</target>
@@ -1802,8 +1832,10 @@
         <note>{StrBegin="MSB3276: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.FoundConflicts">
-        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.  These reference conflicts are listed in the build log when log verbosity is set to detailed.</source>
-        <target state="translated">MSB3277: 在 "{0}" 的不同版本間發現衝突，但無法解決。當記錄詳細程度設定為 [詳細] 時，這些參考衝突會列在組建記錄檔中。</target>
+        <source>MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</source>
+        <target state="new">MSB3277: Found conflicts between different versions of "{0}" that could not be resolved.
+{1}</target>
         <note>{StrBegin="MSB3277: "}</note>
       </trans-unit>
       <trans-unit id="ResolveAssemblyReference.LogAttributeFormat">
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs
index c8e480c3f46..90237fd0920 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryTaskInfo.cs
@@ -41,7 +41,7 @@ internal sealed class RoslynCodeTaskFactoryTaskInfo : IEquatable<RoslynCodeTaskF
         /// <inheritdoc cref="IEquatable{T}.Equals(T)"/>
         public bool Equals(RoslynCodeTaskFactoryTaskInfo other)
         {
-            if (ReferenceEquals(null, other))
+            if (other is null)
             {
                 return false;
             }
diff --git a/src/Tasks/SdkToolsPathUtility.cs b/src/Tasks/SdkToolsPathUtility.cs
index bac55b5daee..c9efaf7cde9 100644
--- a/src/Tasks/SdkToolsPathUtility.cs
+++ b/src/Tasks/SdkToolsPathUtility.cs
@@ -110,7 +110,7 @@ internal static string GeneratePathToTool(FileExists fileExists, string currentA
             // Fall back and see if we can find it with the toolsLocation helper methods. This is not optimal because 
             // the location they are looking at is based on when the Microsoft.Build.Utilities.dll was compiled
             // but it is better than nothing.
-            if (null == pathToTool || !fileExists(pathToTool))
+            if (pathToTool == null || !fileExists(pathToTool))
             {
                 pathToTool = FindSDKToolUsingToolsLocationHelper(toolName);
 
diff --git a/src/Tasks/SignFile.cs b/src/Tasks/SignFile.cs
index 141220816ec..c3600305e9d 100644
--- a/src/Tasks/SignFile.cs
+++ b/src/Tasks/SignFile.cs
@@ -30,6 +30,8 @@ public SignFile()
         [Required]
         public ITaskItem SigningTarget { get; set; }
 
+        public string TargetFrameworkIdentifier { get; set; } = Constants.DotNetFrameworkIdentifier;
+
         public String TargetFrameworkVersion { get; set; }
 
         public string TimestampUrl { get; set; }
@@ -40,7 +42,7 @@ public override bool Execute()
             {
                 SecurityUtilities.SignFile(CertificateThumbprint,
                 TimestampUrl == null ? null : new Uri(TimestampUrl),
-                SigningTarget.ItemSpec, TargetFrameworkVersion);
+                SigningTarget.ItemSpec, TargetFrameworkVersion, TargetFrameworkIdentifier);
                 return true;
             }
             catch (ArgumentException ex) when (ex.ParamName.Equals("certThumbprint"))
diff --git a/src/Tasks/StrongNameUtils.cs b/src/Tasks/StrongNameUtils.cs
index d14ea996ebd..4abdc57311a 100644
--- a/src/Tasks/StrongNameUtils.cs
+++ b/src/Tasks/StrongNameUtils.cs
@@ -233,7 +233,6 @@ internal static StrongNameLevel GetAssemblyStrongNameLevel(string assemblyPath)
                 if (fileHandle != NativeMethods.InvalidIntPtr)
                 {
                     NativeMethods.CloseHandle(fileHandle);
-                    fileHandle = NativeMethods.InvalidIntPtr;
                 }
             }
 
diff --git a/src/Tasks/System.Design.cs b/src/Tasks/System.Design.cs
index 8ff555870e0..047c0c5000a 100644
--- a/src/Tasks/System.Design.cs
+++ b/src/Tasks/System.Design.cs
@@ -5,9 +5,7 @@
 using System.Reflection;
 using System.Globalization;
 using System.Resources;
-using System.Text;
 using System.Threading;
-using System.Security.Permissions;
 
 using System.ComponentModel;
 
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index ea9cf1c27e4..1dd51c92c86 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -252,10 +252,10 @@ internal SystemState(SerializationInfo info, StreamingContext context)
 
         /// <summary>
         /// Set the target framework paths.
-        /// This is used to optimize IO in the case of files requested from one 
+        /// This is used to optimize IO in the case of files requested from one
         /// of the FX folders.
         /// </summary>
-        /// <param name="installedAssemblyTableInfos"></param>
+        /// <param name="installedAssemblyTableInfos">List of Assembly Table Info.</param>
         internal void SetInstalledAssemblyInformation
         (
             AssemblyTableInfo[] installedAssemblyTableInfos
diff --git a/src/Tasks/TlbImp.cs b/src/Tasks/TlbImp.cs
index c54749f2baa..6269f060134 100644
--- a/src/Tasks/TlbImp.cs
+++ b/src/Tasks/TlbImp.cs
@@ -237,7 +237,7 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
                 commandLine.AppendFileNameIfNotNull(TypeLibName);
 
                 // options
-                commandLine.AppendSwitchIfNotNull("/asmversion:", (AssemblyVersion != null) ? AssemblyVersion.ToString() : null);
+                commandLine.AppendSwitchIfNotNull("/asmversion:", AssemblyVersion?.ToString());
                 commandLine.AppendSwitchIfNotNull("/namespace:", AssemblyNamespace);
                 commandLine.AppendSwitchIfNotNull("/machine:", Machine);
                 commandLine.AppendWhenTrue("/noclassmembers", Bag, "PreventClassMembers");
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index 71be097965b..d7ece292dbb 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -10,7 +10,6 @@
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
-using System.Linq;
 using System.Security;
 using System.Text;
 using Microsoft.Build.Framework;
diff --git a/src/Tasks/XamlTaskFactory/TaskParser.cs b/src/Tasks/XamlTaskFactory/TaskParser.cs
index 3e1f9e5d32f..ad7d411177f 100644
--- a/src/Tasks/XamlTaskFactory/TaskParser.cs
+++ b/src/Tasks/XamlTaskFactory/TaskParser.cs
@@ -177,7 +177,7 @@ internal bool ParseXamlDocument(TextReader reader, string desiredRule)
             ErrorUtilities.VerifyThrowArgumentLength(desiredRule, nameof(desiredRule));
 
             object rootObject = XamlServices.Load(reader);
-            if (null != rootObject)
+            if (rootObject != null)
             {
                 XamlTypes.ProjectSchemaDefinitions schemas = rootObject as XamlTypes.ProjectSchemaDefinitions;
                 if (schemas != null)
@@ -473,8 +473,8 @@ private static Property ObtainAttributes(XamlTypes.BaseProperty baseProperty, Pr
 
             if (intProperty != null)
             {
-                parameter.Max = intProperty.MaxValue != null ? intProperty.MaxValue.ToString() : null;
-                parameter.Min = intProperty.MinValue != null ? intProperty.MinValue.ToString() : null;
+                parameter.Max = intProperty.MaxValue?.ToString();
+                parameter.Min = intProperty.MinValue?.ToString();
             }
 
             if (boolProperty != null)
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index 5a722627479..679d22d00a1 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -176,7 +176,7 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
 
                     if (debugXamlTask)
                     {
-                        errorList.AppendLine(String.Format(Thread.CurrentThread.CurrentUICulture, "({0},{1}) {2}", error.Line, error.Column, error.ErrorText));
+                        errorList.AppendFormat(Thread.CurrentThread.CurrentUICulture, "({0},{1}) {2}", error.Line, error.Column, error.ErrorText).AppendLine();
                     }
                     else
                     {
diff --git a/src/Tasks/XmlPoke.cs b/src/Tasks/XmlPoke.cs
index e2d3876868a..8f42cfe910c 100644
--- a/src/Tasks/XmlPoke.cs
+++ b/src/Tasks/XmlPoke.cs
@@ -170,11 +170,13 @@ public override bool Execute()
             }
 
             XPathNodeIterator iter = nav.Select(expr);
+            int count = 0;
 
             while (iter.MoveNext())
             {
                 try
                 {
+                    count++;
                     iter.Current.InnerXml = _value.ItemSpec;
                     Log.LogMessageFromResources(MessageImportance.Low, "XmlPoke.Replaced", iter.Current.Name, _value.ItemSpec);
                 }
@@ -190,9 +192,9 @@ public override bool Execute()
                 }
             }
 
-            Log.LogMessageFromResources(MessageImportance.Normal, "XmlPoke.Count", iter.Count);
+            Log.LogMessageFromResources(MessageImportance.Normal, "XmlPoke.Count", count);
 
-            if (iter.Count > 0)
+            if (count > 0)
             {
 #if RUNTIME_TYPE_NETCORE
                 using (Stream stream = File.Create(_xmlInputPath.ItemSpec))
diff --git a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
index 562468ff8ec..16a31027654 100644
--- a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
+++ b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.IO;
-
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
diff --git a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
index 990979c8840..7691488053e 100644
--- a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
+++ b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
@@ -6,7 +6,6 @@
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
-using BuildUtilities = Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.UnitTests
 {
diff --git a/src/Utilities.UnitTests/StringExtensions_Tests.cs b/src/Utilities.UnitTests/StringExtensions_Tests.cs
index b1d41fcc71c..f8361c3e8e3 100644
--- a/src/Utilities.UnitTests/StringExtensions_Tests.cs
+++ b/src/Utilities.UnitTests/StringExtensions_Tests.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.CodeDom;
 using Shouldly;
 using Xunit;
 
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index 49c97bdefbc..04e90914861 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -379,13 +379,22 @@ public void RemoteTaskItem()
                     itemsInThisAppDomain[i].ItemSpec.ShouldBe(creator.CreatedTaskItems[i].ItemSpec);
                     itemsInThisAppDomain[i].MetadataCount.ShouldBe(creator.CreatedTaskItems[i].MetadataCount + 1);
 
+                    Dictionary<string, string> creatorMetadata = new Dictionary<string, string>(creator.CreatedTaskItems[i].MetadataCount);
                     foreach (string metadatum in creator.CreatedTaskItems[i].MetadataNames)
+                    {
+                        creatorMetadata[metadatum] = creator.CreatedTaskItems[i].GetMetadata(metadatum);
+                    }
+
+                    Dictionary<string, string> metadataInThisAppDomain = new Dictionary<string, string>(itemsInThisAppDomain[i].MetadataCount);
+                    foreach (string metadatum in itemsInThisAppDomain[i].MetadataNames)
                     {
                         if (!string.Equals("OriginalItemSpec", metadatum))
                         {
-                            itemsInThisAppDomain[i].GetMetadata(metadatum).ShouldBe(creator.CreatedTaskItems[i].GetMetadata(metadatum));
+                            metadataInThisAppDomain[metadatum] = itemsInThisAppDomain[i].GetMetadata(metadatum);
                         }
                     }
+
+                    metadataInThisAppDomain.ShouldBe(creatorMetadata, ignoreOrder: true);
                 }
             }
             finally
diff --git a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
index 2be4f4b4d2e..bf5eeb2a250 100644
--- a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
+++ b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
@@ -25,61 +25,51 @@ public void CheckMessageCode()
             messageOnly.ShouldBe("This is a message.");
 
             // whitespace before code and after colon is ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("  AL001:   This is a message.", out messageOnly);
             code.ShouldBe("AL001");
             messageOnly.ShouldBe("This is a message.");
 
             // whitespace after colon is not ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("AL001 : This is a message.", out messageOnly);
             code.ShouldBeNull();
             messageOnly.ShouldBe("AL001 : This is a message.");
 
             // big code is ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("  RESGEN7905001:   This is a message.", out messageOnly);
             code.ShouldBe("RESGEN7905001");
             messageOnly.ShouldBe("This is a message.");
 
             // small code is ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("R7: This is a message.", out messageOnly);
             code.ShouldBe("R7");
             messageOnly.ShouldBe("This is a message.");
 
             // lowercase code is ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("alink3456: This is a message.", out messageOnly);
             code.ShouldBe("alink3456");
             messageOnly.ShouldBe("This is a message.");
 
             // whitespace in code is not ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("  RES 7905:   This is a message.", out messageOnly);
             code.ShouldBeNull();
             messageOnly.ShouldBe("  RES 7905:   This is a message.");
 
             // only digits in code is not ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("7905: This is a message.", out messageOnly);
             code.ShouldBeNull();
             messageOnly.ShouldBe("7905: This is a message.");
 
             // only letters in code is not ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("ALINK: This is a message.", out messageOnly);
             code.ShouldBeNull();
             messageOnly.ShouldBe("ALINK: This is a message.");
 
             // digits before letters in code is not ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("6780ALINK: This is a message.", out messageOnly);
             code.ShouldBeNull();
             messageOnly.ShouldBe("6780ALINK: This is a message.");
 
             // mixing digits and letters in code is not ok
-            messageOnly = null;
             code = t.Log.ExtractMessageCode("LNK658A: This is a message.", out messageOnly);
             code.ShouldBeNull();
             messageOnly.ShouldBe("LNK658A: This is a message.");
@@ -210,7 +200,7 @@ nor is this
             }
             finally
             {
-                if (null != file) File.Delete(file);
+                if (file != null) File.Delete(file);
             }
         }
 
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index d94dc519c00..f8554d8b18e 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -1959,12 +1959,10 @@ public void GetPathToReferenceAssembliesDefaultLocationNullFrameworkName()
         [Trait("Category", "mono-osx-failing")]
         public void GetPathToReferenceAssembliesDefaultLocation45()
         {
-            FrameworkNameVersioning frameworkName = null;
-            IList<string> directories = null;
             if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45) != null)
             {
-                frameworkName = new FrameworkNameVersioning(".NETFramework", new Version("4.5"));
-                directories = ToolLocationHelper.GetPathToReferenceAssemblies(frameworkName);
+                FrameworkNameVersioning frameworkName = new FrameworkNameVersioning(".NETFramework", new Version("4.5"));
+                IList<string> directories = ToolLocationHelper.GetPathToReferenceAssemblies(frameworkName);
                 directories.Count.ShouldBe(1); // "Expected the method to return one path."
 
                 string referenceAssemblyPath = ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45);
@@ -2780,7 +2778,7 @@ public void GetPathToReferenceAssembliesWithNullTargetFrameworkFallbackSearchPat
 
         private static string CreateNewFrameworkAndGetAssembliesPath(TestEnvironment env, string frameworkName, string frameworkVersion, string rootDir)
         {
-            string frameworkListXml = null;
+            string frameworkListXml;
             if (NativeMethodsShared.IsMono)
             {
                 // Mono uses an extra attribute to point to the location of the corresponding
diff --git a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
index c71b51aaed0..9558f9098ea 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
@@ -900,8 +900,7 @@ public void FileTrackerFileIsExcludedFromDependencies()
                                       ? tempPath
                                       : FileUtilities.EnsureTrailingSlash(
                                           NativeMethodsShared.GetLongFilePath(tempPath).ToUpperInvariant());
-            string testFile;
-
+            
             // We don't want to be including these as dependencies or outputs:
             // 1. Files under %USERPROFILE%\Application Data in XP and %USERPROFILE%\AppData\Roaming in Vista and later.
             // 2. Files under %USERPROFILE%\Local Settings\Application Data in XP and %USERPROFILE%\AppData\Local in Vista and later.
@@ -910,7 +909,7 @@ public void FileTrackerFileIsExcludedFromDependencies()
             //    located under AppData, they would not be compacted out correctly otherwise).
 
             // This file's NOT excluded from dependencies
-            testFile = @"c:\foo\bar\baz";
+            string testFile = @"c:\foo\bar\baz";
             Assert.False(FileTracker.FileIsExcludedFromDependencies(testFile));
 
             // This file IS excluded from dependencies
diff --git a/src/Utilities/AssemblyInfo.cs b/src/Utilities/AssemblyInfo.cs
index 587a54ec812..2bb16a1128f 100644
--- a/src/Utilities/AssemblyInfo.cs
+++ b/src/Utilities/AssemblyInfo.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Reflection;
 using System.Resources;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
@@ -17,7 +16,6 @@
 #endif
 
 [assembly: InternalsVisibleTo("Microsoft.Build.Utilities.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
-[assembly: InternalsVisibleTo("Microsoft.Build.Utilities.Whidbey.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 
 // This will enable passing the SafeDirectories flag to any P/Invoke calls/implementations within the assembly, 
 // so that we don't run into known security issues with loading libraries from unsafe locations 
diff --git a/src/Utilities/FxCopExclusions/Microsoft.Build.Utilities.Suppressions.cs b/src/Utilities/FxCopExclusions/Microsoft.Build.Utilities.Suppressions.cs
index 0a30b020544..881022b12ce 100644
--- a/src/Utilities/FxCopExclusions/Microsoft.Build.Utilities.Suppressions.cs
+++ b/src/Utilities/FxCopExclusions/Microsoft.Build.Utilities.Suppressions.cs
@@ -5,8 +5,6 @@
 // Add module level suppressions to this file to have them suppressed in the assembly
 //
 
-using System.Diagnostics.CodeAnalysis;
-
 #if CODE_ANALYSIS
 [module: SuppressMessage("Microsoft.Naming","CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId="0", Scope="module", Target="microsoft.build.utilities.core.dll", Justification="It's been named this way for several versions now.")]
 [module: SuppressMessage("Microsoft.Naming","CA1709:IdentifiersShouldBeCasedCorrectly", MessageId="v", Justification="v in v3.5 is correctly cased")]
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index e8b84435ca2..840d2bcc37e 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -88,9 +88,6 @@
     <Compile Include="..\Shared\ExceptionHandling.cs">
       <Link>Shared\ExceptionHandling.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\EscapingStringExtensions\EscapingStringExtensions.cs">
-      <Link>Shared\EscapingStringExtensions\EscapingStringExtensions.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\FileUtilities.cs">
       <Link>Shared\FileUtilities.cs</Link>
     </Compile>
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index b6abb5f011d..6fc1777dcad 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
diff --git a/src/Utilities/Resources/xlf/Strings.fr.xlf b/src/Utilities/Resources/xlf/Strings.fr.xlf
index 7aeb490f466..28e1d87d3d2 100644
--- a/src/Utilities/Resources/xlf/Strings.fr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.fr.xlf
@@ -99,12 +99,12 @@
       </trans-unit>
       <trans-unit id="Tracking_LogFilesNotAvailable">
         <source>Tracking logs are not available, minimal rebuild will be disabled.</source>
-        <target state="translated">Les journaux de suivi ne sont pas disponibles, la régénération minimale sera désactivée.</target>
+        <target state="translated">Les journaux de suivi ne sont pas disponibles, la regénération minimale sera désactivée.</target>
         <note />
       </trans-unit>
       <trans-unit id="Tracking_MissingInputs">
         <source>Missing input files detected, minimal rebuild will be disabled.</source>
-        <target state="translated">Fichiers d'entrée manquants détectés, la régénération minimale sera désactivée.</target>
+        <target state="translated">Fichiers d'entrée manquants détectés, la regénération minimale sera désactivée.</target>
         <note />
       </trans-unit>
       <trans-unit id="Tracking_MissingOutputs">
@@ -119,7 +119,7 @@
       </trans-unit>
       <trans-unit id="Tracking_TrackingLogNotAvailable">
         <source>Write Tracking log not available, minimal rebuild will be disabled.</source>
-        <target state="translated">Journal de suivi d'écriture non disponible, la régénération minimale sera désactivée.</target>
+        <target state="translated">Journal de suivi d'écriture non disponible, la regénération minimale sera désactivée.</target>
         <note />
       </trans-unit>
       <trans-unit id="Tracking_WriteTrackingLogs">
@@ -259,12 +259,12 @@
       </trans-unit>
       <trans-unit id="Tracking_RebuildingDueToInvalidTLog">
         <source>MSB6008: Forcing a rebuild of all sources due to an error with the tracking logs. {0}</source>
-        <target state="translated">MSB6008: régénération forcée de toutes les sources en raison d'une erreur avec les journaux de suivi. {0}</target>
+        <target state="translated">MSB6008: regénération forcée de toutes les sources en raison d'une erreur avec les journaux de suivi. {0}</target>
         <note>{StrBegin="MSB6008: "}</note>
       </trans-unit>
       <trans-unit id="Tracking_RebuildingDueToInvalidTLogContents">
         <source>MSB6009: Forcing a rebuild of all source files due to the contents of "{0}" being invalid.</source>
-        <target state="translated">MSB6009: régénération forcée de tous les fichiers sources en raison d'un contenu de "{0}" non valide.</target>
+        <target state="translated">MSB6009: regénération forcée de tous les fichiers sources en raison d'un contenu de "{0}" non valide.</target>
         <note>{StrBegin="MSB6009: "}</note>
       </trans-unit>
       <trans-unit id="MuxLogger_BuildFinishedFailure">
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index 429a215a58a..0a361a8cd7a 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -4,9 +4,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Diagnostics;
-using System.Globalization;
-using System.Runtime.InteropServices;
 using System.Security;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
@@ -44,7 +41,7 @@ public sealed class TaskItem :
         // project file via XML child elements of the item element.  These have
         // no meaning to MSBuild, but tasks may use them.
         // Values are stored in escaped form.
-        private CopyOnWriteDictionary<string, string> _metadata;
+        private CopyOnWriteDictionary<string> _metadata;
 
         // cache of the fullpath value
         private string _fullPath;
@@ -102,7 +99,7 @@ IDictionary itemMetadata
 
             if (itemMetadata.Count > 0)
             {
-                _metadata = new CopyOnWriteDictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
+                _metadata = new CopyOnWriteDictionary<string>(MSBuildNameIgnoreCaseComparer.Default);
 
                 foreach (DictionaryEntry singleMetadata in itemMetadata)
                 {
@@ -214,7 +211,7 @@ public ICollection MetadataNames
         /// another appdomain, as the CLR has implemented remoting policies that disallow accessing 
         /// private fields in remoted items. 
         /// </summary>
-        private CopyOnWriteDictionary<string, string> Metadata
+        private CopyOnWriteDictionary<string> Metadata
         {
             get
             {
@@ -264,7 +261,7 @@ string metadataValue
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(metadataName),
                 "Shared.CannotChangeItemSpecModifiers", metadataName);
 
-            _metadata ??= new CopyOnWriteDictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
+            _metadata ??= new CopyOnWriteDictionary<string>(MSBuildNameIgnoreCaseComparer.Default);
 
             _metadata[metadataName] = metadataValue ?? string.Empty;
         }
@@ -360,7 +357,7 @@ public void CopyMetadataTo(ITaskItem destinationItem)
         /// </comments>
         public IDictionary CloneCustomMetadata()
         {
-            var dictionary = new CopyOnWriteDictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
+            var dictionary = new CopyOnWriteDictionary<string>(MSBuildNameIgnoreCaseComparer.Default);
 
             if (_metadata != null)
             {
@@ -444,7 +441,7 @@ string ITaskItem2.GetMetadataValueEscaped(string metadataName)
         /// </summary>
         /// <returns>The cloned metadata.</returns>
         IDictionary ITaskItem2.CloneCustomMetadataEscaped() => _metadata == null
-            ? new CopyOnWriteDictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default)
+            ? new CopyOnWriteDictionary<string>(MSBuildNameIgnoreCaseComparer.Default)
             : _metadata.Clone();
 
         #endregion
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index fb239098a87..d2473b7f3e5 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -17,7 +17,6 @@
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
 using UtilitiesDotNetFrameworkArchitecture = Microsoft.Build.Utilities.DotNetFrameworkArchitecture;
 using SharedDotNetFrameworkArchitecture = Microsoft.Build.Shared.DotNetFrameworkArchitecture;
-using System.Collections.ObjectModel;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.AssemblyFoldersFromConfig;
 
@@ -2297,7 +2296,7 @@ public static string GetDisplayNameForTargetFrameworkDirectory(string targetFram
 
             displayNameBuilder.Append(frameworkName.Identifier);
             displayNameBuilder.Append(" ");
-            displayNameBuilder.Append("v" + frameworkName.Version.ToString());
+            displayNameBuilder.Append('v').Append(frameworkName.Version.ToString());
 
             if (!string.IsNullOrEmpty(frameworkName.Profile))
             {
@@ -2993,7 +2992,7 @@ private static List<string> GetExtensionSdkDiskRoots(string[] diskRoots)
         /// <returns></returns>
         private static string GetTargetPlatformMonikerRegistryRoots(string registryRootLocation)
         {
-            ErrorUtilities.DebugTraceMessage("GetTargetPlatformMonikerRegistryRoots", "RegistryRoot passed in '{0}'", registryRootLocation != null ? registryRootLocation : string.Empty);
+            ErrorUtilities.DebugTraceMessage("GetTargetPlatformMonikerRegistryRoots", "RegistryRoot passed in '{0}'", registryRootLocation ?? string.Empty);
 
             string disableRegistryForSDKLookup = Environment.GetEnvironmentVariable("MSBUILDDISABLEREGISTRYFORSDKLOOKUP");
             // If we are not disabling the registry for platform sdk lookups then lets look in the default location.
@@ -3882,7 +3881,7 @@ private static IList<string> GetFrameworkVersions(string frameworkReferenceRoot,
                     //only add if the version folder name is of the right format
                     if (folder.Name.Length >= 4 && folder.Name.StartsWith("v", StringComparison.OrdinalIgnoreCase))
                     {
-                        Version ver = null;
+                        Version ver;
                         if (Version.TryParse(folder.Name.Substring(1), out ver))
                         {
                             frameworkVersions.Add(folder.Name);
@@ -3924,8 +3923,7 @@ private static IList<string> GetFrameworkProfiles(string frameworkReferenceRoot,
 
             var frameworkProfiles = new List<string>();
 
-            string frameworkProfilePath = null;
-            frameworkProfilePath = Path.Combine(frameworkReferenceRoot, frameworkIdentifier);
+            string frameworkProfilePath = Path.Combine(frameworkReferenceRoot, frameworkIdentifier);
             frameworkProfilePath = Path.Combine(frameworkProfilePath, frameworkVersion);
             frameworkProfilePath = Path.Combine(frameworkProfilePath, "Profiles");
 
@@ -3958,8 +3956,7 @@ private static IList<string> GetFx35AndEarlierVersions(string frameworkReference
             IList<string> versions = new List<string>();
 
             // only return v35 and earlier versions if .NetFx35 is installed
-            string dotNetFx35Path = null;
-            dotNetFx35Path = GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version35);
+            string dotNetFx35Path = GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version35);
 
             if (dotNetFx35Path != null)
             {
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 78311278ac0..93ec1767db9 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -607,7 +607,7 @@ string responseFileSwitch
 
             // Generally we won't set a working directory, and it will use the current directory
             string workingDirectory = GetWorkingDirectory();
-            if (null != workingDirectory)
+            if (workingDirectory != null)
             {
                 startInfo.WorkingDirectory = workingDirectory;
             }
@@ -615,7 +615,7 @@ string responseFileSwitch
             // Old style environment overrides
 #pragma warning disable 0618 // obsolete
             Dictionary<string, string> envOverrides = EnvironmentOverride;
-            if (null != envOverrides)
+            if (envOverrides != null)
             {
                 foreach (KeyValuePair<string, string> entry in envOverrides)
                 {
@@ -1453,7 +1453,7 @@ public override bool Execute()
                 // Old style environment overrides
 #pragma warning disable 0618 // obsolete
                 Dictionary<string, string> envOverrides = EnvironmentOverride;
-                if (null != envOverrides)
+                if (envOverrides != null)
                 {
                     foreach (KeyValuePair<string, string> entry in envOverrides)
                     {
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index d16a1ca76ee..86b3892f2a2 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -381,9 +381,9 @@ private ITaskItem[] ComputeSourcesNeedingCompilationFromCompositeRootingMarker(b
             // now that we have our dependencies, we need to check if any of them are newer than the outputs.
             DateTime newestSourceDependencyTime;
             DateTime oldestOutputTime;
-            string newestSourceDependencyFile = string.Empty;
             string oldestOutputFile = string.Empty;
 
+            string newestSourceDependencyFile;
             if (
                 CanonicalTrackedFilesHelper.FilesExistAndRecordNewestWriteTime(sourcesNeedingCompilationList, _log, out newestSourceDependencyTime, out newestSourceDependencyFile) &&
                 CanonicalTrackedFilesHelper.FilesExistAndRecordOldestWriteTime(_outputFileGroup, _log, out oldestOutputTime, out oldestOutputFile)
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index 7ca96f897c0..f69120d591e 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -93,7 +93,7 @@ private void InternalConstruct(ITask ownerTask, ITaskItem[] tlogFiles, bool cons
         /// </summary>
         private void ConstructOutputTable()
         {
-            string tLogRootingMarker = null;
+            string tLogRootingMarker;
             try
             {
                 // construct a rooting marker from the tlog files
diff --git a/src/Utilities/TrackedDependencies/DependencyTableCache.cs b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
index da70034829f..0767897c772 100644
--- a/src/Utilities/TrackedDependencies/DependencyTableCache.cs
+++ b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
@@ -175,7 +175,7 @@ private static string NormalizeTlogPath(string tlogPath)
                 if (i >= 0)
                 {
                     // If we bailed out early, add everything else before reversing the filename itself
-                    normalizedTlogPath.Append(tlogPath.Substring(0, i + 1));
+                    normalizedTlogPath.Append(tlogPath, 0, i + 1);
                 }
 
                 // now add the reversed filename
@@ -208,7 +208,7 @@ public bool Equals(ITaskItem x, ITaskItem y)
                     return true;
                 }
 
-                if (ReferenceEquals(x, null) || ReferenceEquals(y, null))
+                if (x is null || y is null)
                 {
                     return false;
                 }
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index 15d8417f515..f878d3b6318 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -2,7 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
+
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestClassRunnerWithAssemblyFixture.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestClassRunnerWithAssemblyFixture.cs
index b0b96e02968..035c80be769 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestClassRunnerWithAssemblyFixture.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestClassRunnerWithAssemblyFixture.cs
@@ -1,7 +1,6 @@
 ﻿using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
 using System.Threading;
 using System.Threading.Tasks;
 using Xunit.Abstractions;
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestCollectionRunnerWithAssemblyFixture.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestCollectionRunnerWithAssemblyFixture.cs
index f6dc321638b..0d1f5b5c31d 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestCollectionRunnerWithAssemblyFixture.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestCollectionRunnerWithAssemblyFixture.cs
@@ -24,13 +24,8 @@ public XunitTestCollectionRunnerWithAssemblyFixture(Dictionary<Type, object> ass
                                                             CancellationTokenSource cancellationTokenSource)
             : base(testCollection, testCases, diagnosticMessageSink, messageBus, testCaseOrderer, aggregator, cancellationTokenSource)
         {
-            if (assemblyFixtureAttributes == null)
-            {
-                throw new ArgumentNullException(nameof(assemblyFixtureAttributes));
-            }
-
             this.assemblyFixtureMappings = assemblyFixtureMappings;
-            this.assemblyFixtureAttributes = assemblyFixtureAttributes;
+            this.assemblyFixtureAttributes = assemblyFixtureAttributes ?? throw new ArgumentNullException(nameof(assemblyFixtureAttributes));
             this.diagnosticMessageSink = diagnosticMessageSink;
         }
 
diff --git a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestMethodRunnerWithAssemblyFixture.cs b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestMethodRunnerWithAssemblyFixture.cs
index 95a3918ce2d..76223e24a1e 100644
--- a/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestMethodRunnerWithAssemblyFixture.cs
+++ b/src/Xunit.NetCore.Extensions/AssemblyFixtureSupport/XunitTestMethodRunnerWithAssemblyFixture.cs
@@ -1,9 +1,7 @@
 ﻿using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
 using System.Threading;
-using System.Threading.Tasks;
 using Xunit.Abstractions;
 using Xunit.Sdk;
 
diff --git a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalFactDiscoverer.cs b/src/Xunit.NetCore.Extensions/Discoverers/ConditionalFactDiscoverer.cs
index 07b8a9c7d6a..3ef2fc34e4b 100644
--- a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalFactDiscoverer.cs
+++ b/src/Xunit.NetCore.Extensions/Discoverers/ConditionalFactDiscoverer.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 // See the LICENSE file in the project root for more information.
 
-using System;
 using System.Collections.Generic;
 using System.Linq;
 using Xunit.Abstractions;
diff --git a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTheoryDiscoverer.cs b/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTheoryDiscoverer.cs
index 7a1919e5dbb..b4b6e5b1ff7 100644
--- a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTheoryDiscoverer.cs
+++ b/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTheoryDiscoverer.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 // See the LICENSE file in the project root for more information.
 
-using System;
 using System.Collections.Generic;
 using System.Linq;
 using Xunit.Abstractions;
diff --git a/src/Xunit.NetCore.Extensions/SkippedTestCase.cs b/src/Xunit.NetCore.Extensions/SkippedTestCase.cs
index 415e4bcca01..d094c882519 100644
--- a/src/Xunit.NetCore.Extensions/SkippedTestCase.cs
+++ b/src/Xunit.NetCore.Extensions/SkippedTestCase.cs
@@ -6,7 +6,6 @@
 using System.Collections.Generic;
 using System.Threading;
 using System.Threading.Tasks;
-using Xunit;
 using Xunit.Abstractions;
 using Xunit.Sdk;
 
diff --git a/src/Xunit.NetCore.Extensions/XunitConstants.cs b/src/Xunit.NetCore.Extensions/XunitConstants.cs
index 99b4d53eb46..02d08d297f1 100644
--- a/src/Xunit.NetCore.Extensions/XunitConstants.cs
+++ b/src/Xunit.NetCore.Extensions/XunitConstants.cs
@@ -2,9 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 // See the LICENSE file in the project root for more information.
 
-using System;
-using Xunit.Sdk;
-
 namespace Xunit.NetCore.Extensions
 {
     public struct XunitConstants
