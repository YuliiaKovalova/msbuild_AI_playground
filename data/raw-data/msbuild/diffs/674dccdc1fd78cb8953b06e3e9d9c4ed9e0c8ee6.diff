diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 260f46914b1..81b331862cc 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -1,5 +1,5 @@
 trigger:
-- master
+- main
 - exp/*
 - vs*
 
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index eefef30630a..cb827f778a0 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -1,5 +1,5 @@
 trigger:
-- master
+- main
 - vs*
 - exp/*
 
@@ -15,7 +15,7 @@ variables:
     value: $(IbcSourceBranchName)
   - ${{ if startsWith(variables['Build.SourceBranch'], 'refs/heads/exp/') }}:
     - name: SourceBranch
-      value: master
+      value: main
   - name: _DotNetArtifactsCategory
     value: .NETCore
   - name: _DotNetValidationArtifactsCategory
diff --git a/CompatBaseline.txt b/CompatBaseline.txt
deleted file mode 100644
index a15e37c83dd..00000000000
--- a/CompatBaseline.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-# This API is marked obsolete and has been removed from the reference assembly
-MembersMustExist : Member 'Microsoft.Build.Utilities.ToolTask.EnvironmentOverride.get()' does not exist in the implementation but it does exist in the contract.
-#These changes will appear in Update 1; They represent added support for Framework 4.6.1 SDK.
-MembersMustExist : Member 'Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion461Path.get()' does not exist in the implementation but it does exist in the contract.
-MembersMustExist : Member 'Microsoft.Build.Utilities.TargetDotNetFrameworkVersion Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version461' does not exist in the implementation but it does exist in the contract.
-EnumValuesMustMatch : Enum value 'Microsoft.Build.Utilities.TargetDotNetFrameworkVersion Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.VersionLatest' is (System.Int32)7 in the implementation but (System.Int32)8 in the contract.
-MembersMustExist : Member 'Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk()' does not exist in the implementation but it does exist in the contract.
-MembersMustExist : Member 'Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(System.String)' does not exist in the implementation but it does exist in the contract.
diff --git a/README.md b/README.md
index 631504a1702..0ca7629c10a 100644
--- a/README.md
+++ b/README.md
@@ -6,9 +6,9 @@ For more information on MSBuild, see the [MSBuild documentation](https://docs.mi
 
 ### Build Status
 
-The current development branch is `master`. Changes in `master` will go into a future update of MSBuild, which will release with Visual Studio 16.10 and a corresponding version of the .NET Core SDK.
+The current development branch is `main`. Changes in `main` will go into a future update of MSBuild, which will release with Visual Studio 16.10 and a corresponding version of the .NET Core SDK.
 
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=master)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=master)
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=main)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=main)
 
 We have forked for MSBuild 16.9 in the branch [`vs16.9`](https://github.com/Microsoft/msbuild/tree/vs16.9). Changes to that branch need special approval.
 
diff --git a/RunApiPort.bat b/RunApiPort.bat
deleted file mode 100644
index 4c147cc6cf0..00000000000
--- a/RunApiPort.bat
+++ /dev/null
@@ -1,7 +0,0 @@
-@echo off
-setlocal
-
-msbuild %~dp0src\MSBuild.sln /p:Configuration=Port-Progress
-
-set ANALYSIS_PATH=%~dp0bin\Windows_NT\Port-Progress
-%~dp0ApiPort\ApiPort.exe analyze -f %ANALYSIS_PATH%\Microsoft.Build.dll -f %ANALYSIS_PATH%\Microsoft.Build.Framework.dll -f %ANALYSIS_PATH%\Microsoft.Build.Tasks.Core.dll -f %ANALYSIS_PATH%\Microsoft.Build.Utilities.Core.dll -f %ANALYSIS_PATH%\MSBuild.exe --target "ASP.NET 5, Version=1.0"
\ No newline at end of file
diff --git a/documentation/specs/resource-management.md b/documentation/specs/resource-management.md
new file mode 100644
index 00000000000..92343be73a4
--- /dev/null
+++ b/documentation/specs/resource-management.md
@@ -0,0 +1,41 @@
+# Managing tools with their own parallelism in MSBuild
+
+MSBuild supports building projects in parallel using multiple processes. Most users opt into `Environment.ProcessorCount` parallelism at the MSBuild layer.
+
+In addition, tools sometimes support parallel execution. The Visual C++ compiler `cl.exe` supports `/MP[n]`, which parallelizes compilation at the translation-unit (file) level. If a number isn't specified, it defaults to `NUM_PROCS`.
+
+When used in combination, `NUM_PROCS * NUM_PROCS` compiler processes can be launched, all of which would like to do file I/O and intense computation. This generally overwhelms the operating system's scheduler and causes thrashing and terrible build times.
+
+As a result, the standard guidance is to use only one multiproc option: MSBuild's _or_ `cl.exe`'s. But that leaves the machine underloaded when things could be happening in parallel.
+
+## Design
+
+`IBuildEngine` will be extended to allow a task to indicate to MSBuild that it would like to consume more than one CPU core (`RequestCores`). These will be advisory only — a task can still do as much work as it desires with as many threads and processes as it desires.
+
+A cooperating task would limit its own parallelism to the number of CPU cores MSBuild can reserve for the requesting task.
+
+`RequestCores(int requestedCores)` will always return a positive value, possibly less than the parameter if that many cores are not available. If no cores are available at the moment, the call blocks until at least one becomes available. The first `RequestCores` call made by a task is guaranteed to be non-blocking, though, as at minimum it will return the "implicit" core allocated to the task itself. This leads to two conceptual ways of adopting the API. Either the task calls `RequestCores` once, passing the desired number of cores, and then limiting its parallelism to whatever the call returns. Or the task makes additional calls throughout its execution, perhaps as it discovers more work to do. In this second scenario the task must be OK with waiting for additional cores for a long time or even forever if the sum of allocated cores has exceeded the limit defined by the policy.
+
+All resources acquired by a task will be automatically returned when the task's `Execute()` method returns, and a task can optionally return a subset by calling `ReleaseCores`. Additionally, all resources will be returned when the task calls `Reacquire` as this call is a signal to the scheduler that external tools have finished their work and the task can continue running. It does not matter when the resources where allocated - whether it was before or after calling `Yield` - they will all be released. Depending on the scheduling policy, freeing resources on `Reacquire` may prevent deadlocks.
+
+The exact core reservation policy and its interaction with task execution scheduling is still TBD. The pool of resources explicitly allocated by tasks may be completely separate, i.e. MSBuild will not wait until a resource is freed before starting execution of new tasks. Or it may be partially or fully shared to prevent oversubscribing the machine. In general, `ReleaseCores` may cause a transition of a waiting task to a Ready state. And vice-versa, completing a task or calling `Yield` may unblock a pending `RequestCores` call issued by a task.
+
+## Example 1
+
+In a 16-process build of a solution with 30 projects, 16 worker nodes are launched and begin executing work. Most block on dependencies to projects `A`, `B`, `C`, `D`, and `E`, so they don't have tasks running holding resources.
+
+Task `Work` is called in project `A` with 25 inputs. It would like to run as many as possible in parallel. It calls
+
+```C#
+int allowedParallelism = BuildEngine8.RequestCores(Inputs.Count); // Inputs.Count == 25
+```
+
+and gets up to `16`--the number of cores available to the build overall.
+
+While `A` runs `Work`, projects `B` and `C` run another task `Work2` that also calls `RequestCores` with a high value. Since `Work` in `A` has reserved all cores, the calls in `B` and `C` may return only 1, indicating that the task should not be doing parallel work. Subsequent `RequestCores` may block, waiting on `Work` to release cores (or return).
+
+When `Work` returns, MSBuild automatically returns all resources reserved by the task to the pool. At that time blocked `RequestCores` calls in `Work2` may unblock.
+
+## Implementation
+
+The `RequestCores` and `ReleaseCores` calls are marshaled back to the scheduler via newly introduced `INodePacket` implementations. The scheduler, having full view of the state of the system - i.e. number of build requests running, waiting, yielding, ..., number of cores explicitly allocated by individual tasks using the new API - is free to implement an arbitrary core allocation policy. In the initial implementation the policy will be controlled by a couple of environment variables to make it easy to test different settings.
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index d384a4640f8..1e25829f60b 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -25,6 +25,7 @@ The opt-out comes in the form of setting the environment variable `MSBuildDisabl
 - [Don't expand full drive globs with false condition](https://github.com/dotnet/msbuild/pull/5669)
 ### 16.10
 - [Error when a property expansion in a condition has whitespace](https://github.com/dotnet/msbuild/pull/5672)
+- [Allow Custom CopyToOutputDirectory Location With TargetPath](https://github.com/dotnet/msbuild/pull/6237)
 - [Allow users that have certain special characters in their username to build successfully when using exec](https://github.com/dotnet/msbuild/pull/6223)
 ### 17.0
 
diff --git a/documentation/wiki/Providing-Binary-Logs.md b/documentation/wiki/Providing-Binary-Logs.md
index b9423d5b271..dd7838e4c66 100644
--- a/documentation/wiki/Providing-Binary-Logs.md
+++ b/documentation/wiki/Providing-Binary-Logs.md
@@ -6,9 +6,9 @@ However, you should be aware what type of information is captured in the binary
 
 ⚠ NOTE: some build environments make secrets available using environment variables. Before sharing a binary log, make sure it does not expose API tokens or other important secrets.
 
-You can create a binary log by passing the `-bl` parameter to MSBuild.  You can explore the contents of the generated .binlog file using [MSBuild Structured Log Viewer](http://msbuildlog.com/).
+You can create a binary log by passing the `-bl` parameter to MSBuild. You can explore the contents of the generated .binlog file using [MSBuild Structured Log Viewer](http://msbuildlog.com/) or in your browser using [Live Structured Log Viewer](https://live.msbuildlog.com). Note: We don't capture any data from binary logs viewed on your browser.
 
 [More details about binary logs](Binary-Log.md)
 
 ## Capturing Binary Logs Through Visual Studio
-See [this guide](https://github.com/dotnet/project-system-tools) in the Project System Tools repo for capturing binlogs through Visual Studio.
+See [this guide](https://github.com/dotnet/project-system-tools) in the Project System Tools repo for capturing binlogs through Visual Studio.
\ No newline at end of file
diff --git a/documentation/wiki/UnGAC.md b/documentation/wiki/UnGAC.md
new file mode 100644
index 00000000000..79f7a3ddc77
--- /dev/null
+++ b/documentation/wiki/UnGAC.md
@@ -0,0 +1,34 @@
+# MSBuild, the Global Assembly Cache (GAC), and You
+
+## What is the GAC?
+
+See the [public documentation](https://docs.microsoft.com/dotnet/framework/app-domains/gac). The GAC is a folder where different installations of VS on the same machine look for assemblies that are commonly used. If an assembly is in the GAC, it will be prioritized over any other assembly.
+
+The only MSBuild assemblies you may see in the GAC are version 4.8. There is no reason any modern (15.1+) MSBuild assembly should be in the GAC today.
+
+## What MSBuild Assemblies are installed on my Machine?
+Run the [EnumerateMSBuild powershell script](https://github.com/Microsoft/msbuild/blob/master/scripts/EnumerateMSBuild.ps1) from our repo. It will output a `msbuild_versions.txt` file that lists MSBuild assemblies in their common folders along with their versions.
+
+## How to Remove MSBuild Assemblies from the GAC
+1. If on Visual Studio 16.8 or higher, repair your installation.
+2. Run these commands on a developer command prompt with admin privileges. Match the versions as necessary.
+    ```
+    gacutil /u "MSBuild, Version=15.1.0.0"
+    gacutil /u "Microsoft.Build.Conversion.Core, Version=15.1.0.0"
+    gacutil /u "Microsoft.Build, Version=15.1.0.0"
+    gacutil /u "Microsoft.Build.Engine, Version=15.1.0.0"
+    gacutil /u "Microsoft.Build.Tasks.Core, Version=15.1.0.0"
+    gacutil /u "Microsoft.Build.Utilities.Core, Version=15.1.0.0"
+    gacutil /u "Microsoft.Build.Framework, Version=15.1.0.0"
+    ```
+3. If you want to do this 'safely', move the folder out of the GAC and return it if it doesn't resolve the issue.
+
+## Related GAC issues
+https://developercommunity.visualstudio.com/content/problem/311136/update-to-1580-projects-wont-load.html
+
+https://developercommunity.visualstudio.com/content/problem/953754/after-update-to-1650-no-longer-able-to-loadcreate.html
+
+https://developercommunity.visualstudio.com/content/problem/208631/unable-to-create-or-open-solution.html
+
+## Other assemblies
+We have an issue [tracking other assemblies](https://github.com/dotnet/msbuild/issues/5955) that can cause problems when in the GAC. If one of these assemblies is causing issues for you, refer to [How to Remove MSBuild Assemblies from the GAC](#how-to-remove-msbuild-assemblies-from-the-gac) while changing the assembly name and version.
diff --git a/eng/Packages.props b/eng/Packages.props
index c4ae1af44ed..91058315eaa 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -2,7 +2,7 @@
   <ItemGroup>
     <PackageReference Update="BenchmarkDotNet" Version="0.12.1" />
     <PackageReference Update="jnm2.ReferenceAssemblies.net35" Version="1.0.1" />
-    <PackageReference Update="LargeAddressAware" Version="1.0.3" />
+    <PackageReference Update="LargeAddressAware" Version="1.0.5" />
     <PackageReference Update="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
     <PackageReference Update="Microsoft.DotNet.GenAPI" Version="2.1.0-prerelease-02404-02" />
@@ -18,6 +18,7 @@
     <PackageReference Update="SourceLink.Create.CommandLine" Version="2.1.2" />
     <PackageReference Update="System.CodeDom" Version="4.4.0" />
     <PackageReference Update="System.Collections.Immutable" Version="5.0.0" />
+    <PackageReference Update="System.Configuration.ConfigurationManager" Version="4.7.0" />
     <PackageReference Update="System.Memory" Version="4.5.4" />
     <PackageReference Update="System.Reflection.Metadata" Version="1.6.0" />
     <PackageReference Update="System.Resources.Extensions" Version="4.6.0" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index caf93915568..13d8260275b 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,13 +1,13 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="5.0.0-beta.21112.3">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="5.0.0-beta.21160.3">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>d8c68c834bcca3f721ad1550404807e301ba7afe</Sha>
+      <Sha>670382be6a978ba401c21c57ba44311199d2682a</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="5.9.0-rc.7097">
-      <Uri>https://dev.azure.com/devdiv/DevDiv/_git/NuGet-NuGet.Client-Trusted</Uri>
-      <Sha>ed9af679b4425c1ff4d41d2302d73f6e580a2839</Sha>
+    <Dependency Name="NuGet.Build.Tasks" Version="5.9.1-rc.8">
+      <Uri>https://github.com/nuget/nuget.client</Uri>
+      <Sha>d525b0e670f3b6cbd5c73a35f04730a9f658c852</Sha>
     </Dependency>
     <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="3.9.0-2.20574.26">
       <Uri>https://github.com/dotnet/roslyn</Uri>
diff --git a/eng/Versions.props b/eng/Versions.props
index 3916d33cc6a..3316d1de403 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -27,7 +27,7 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>5.0.102</DotNetCliVersion>
     <MicrosoftNetCompilersToolsetVersion>3.9.0-2.20574.26</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>5.9.0-rc.7097</NuGetBuildTasksVersion>
+    <NuGetBuildTasksVersion>5.9.1-rc.8</NuGetBuildTasksVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/common/post-build/publish-using-darc.ps1 b/eng/common/post-build/publish-using-darc.ps1
index 650b13b089b..a40ee827a43 100644
--- a/eng/common/post-build/publish-using-darc.ps1
+++ b/eng/common/post-build/publish-using-darc.ps1
@@ -54,7 +54,7 @@ try {
   --id $buildId `
   --publishing-infra-version $PublishingInfraVersion `
   --default-channels `
-  --source-branch master `
+  --source-branch main `
   --azdev-pat $AzdoToken `
   --bar-uri $MaestroApiEndPoint `
   --password $MaestroToken `
diff --git a/global.json b/global.json
index 4d0b3b44e05..5aff70ee07d 100644
--- a/global.json
+++ b/global.json
@@ -12,6 +12,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "5.0.0-beta.21112.3"
+    "Microsoft.DotNet.Arcade.Sdk": "5.0.0-beta.21160.3"
   }
 }
diff --git a/netci.groovy b/netci.groovy
deleted file mode 100644
index b74d67b95a4..00000000000
--- a/netci.groovy
+++ /dev/null
@@ -1,89 +0,0 @@
-// Import the utility functionality.
-import jobs.generation.*;
-
-// The input project name
-project = GithubProject
-
-// The input branch name (e.g. master)
-branch = GithubBranchName
-
-// What this repo is using for its machine images at the current time
-imageVersionMap = ['RHEL7.2' : 'latest']
-
-def CreateJob(script, runtime, osName, isPR, machineAffinityOverride = null, shouldSkipTestsWhenResultsNotFound = false, isSourceBuild = false) {
-    def newJobName = Utilities.getFullJobName("innerloop_${osName}_${runtime}${isSourceBuild ? '_SourceBuild_' : ''}", isPR)
-
-    // Create a new job with the specified name.  The brace opens a new closure
-    // and calls made within that closure apply to the newly created job.
-    def newJob = job(newJobName) {
-        description('')
-    }
-
-    newJob.with{
-        steps{
-            if(osName.contains("Windows") || osName.contains("windows")) {
-                batchFile(script)
-            } else {
-                shell(script)
-            }
-        }
-
-        skipTestsWhenResultsNotFound = shouldSkipTestsWhenResultsNotFound
-    }
-
-    // Add xunit result archiving. Skip if no results found.
-    Utilities.addXUnitDotNETResults(newJob, 'artifacts/**/TestResults/*.xml', skipTestsWhenResultsNotFound)
-
-    if (machineAffinityOverride == null) {
-        def imageVersion = imageVersionMap[osName];
-        Utilities.setMachineAffinity(newJob, osName, imageVersion)
-    }
-    else {
-        Utilities.setMachineAffinity(newJob, machineAffinityOverride)
-    }
-
-    Utilities.standardJobSetup(newJob, project, isPR, "*/${branch}")
-    // Add archiving of logs (even if the build failed)
-    Utilities.addArchival(newJob,
-                        'artifacts/**/log/*.binlog,artifacts/**/log/*.log,artifacts/**/TestResults/*,artifacts/**/MSBuild_*.failure.txt', /* filesToArchive */
-                        '', /* filesToExclude */
-                        false, /* doNotFailIfNothingArchived */
-                        false, /* archiveOnlyIfSuccessful */)
-    // Add trigger
-    if (isPR) {
-        TriggerBuilder prTrigger = TriggerBuilder.triggerOnPullRequest()
-
-        if (runtime == "MonoTest") {
-            // Until they're passing reliably, require opt in
-            // for Mono tests
-            prTrigger.setCustomTriggerPhrase("(?i).*test\\W+mono.*")
-            prTrigger.triggerOnlyOnComment()
-        }
-
-        prTrigger.triggerForBranch(branch)
-        // Set up what shows up in Github:
-        prTrigger.setGithubContext("${osName} Build for ${runtime}")
-        prTrigger.emitTrigger(newJob)
-    } else {
-        if (runtime != "Mono") {
-            Utilities.addGithubPushTrigger(newJob)
-        }
-    }
-}
-
-// sourcebuild simulation
-CreateJob(
-    "./build/build.sh build -dotnetBuildFromSource -skiptests -pack -configuration Release",
-    "CoreCLR",
-    "RHEL7.2",
-    true,
-    null,
-    true,
-    true)
-
-JobReport.Report.generateJobReport(out)
-
-// Make the call to generate the help job
-Utilities.createHelperJob(this, project, branch,
-    "Welcome to the ${project} Repository",  // This is prepended to the help message
-    "Have a nice day!")  // This is appended to the help message.  You might put known issues here.
diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
index 239f7910b68..00db63a067d 100644
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
@@ -38,6 +38,7 @@ protected BuildEventArgs(string message, string helpKeyword, string senderName,
         public Microsoft.Build.Framework.BuildEventContext BuildEventContext { get { throw null; } set { } }
         public string HelpKeyword { get { throw null; } }
         public virtual string Message { get { throw null; } protected set { } }
+        protected internal System.DateTime RawTimestamp { get { throw null; } set { } }
         public string SenderName { get { throw null; } }
         public int ThreadId { get { throw null; } }
         public System.DateTime Timestamp { get { throw null; } }
@@ -213,6 +214,15 @@ public partial interface IBuildEngine7 : Microsoft.Build.Framework.IBuildEngine,
     {
         bool AllowFailureWithoutError { get; set; }
     }
+    public partial interface IBuildEngine8 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7
+    {
+        bool ShouldTreatWarningAsError(string warningCode);
+    }
+    public partial interface IBuildEngine9 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7, Microsoft.Build.Framework.IBuildEngine8
+    {
+        void ReleaseCores(int coresToRelease);
+        int RequestCores(int requestedCores);
+    }
     public partial interface ICancelableTask : Microsoft.Build.Framework.ITask
     {
         void Cancel();
@@ -248,6 +258,10 @@ public partial interface IEventSource3 : Microsoft.Build.Framework.IEventSource,
         void IncludeEvaluationProfiles();
         void IncludeTaskInputs();
     }
+    public partial interface IEventSource4 : Microsoft.Build.Framework.IEventSource, Microsoft.Build.Framework.IEventSource2, Microsoft.Build.Framework.IEventSource3
+    {
+        void IncludeEvaluationPropertiesAndItems();
+    }
     public partial interface IForwardingLogger : Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
     {
         Microsoft.Build.Framework.IEventRedirector BuildEventRedirector { get; set; }
@@ -377,8 +391,11 @@ public sealed partial class ProjectEvaluationFinishedEventArgs : Microsoft.Build
     {
         public ProjectEvaluationFinishedEventArgs() { }
         public ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) { }
+        public System.Collections.IEnumerable GlobalProperties { get { throw null; } set { } }
+        public System.Collections.IEnumerable Items { get { throw null; } set { } }
         public Microsoft.Build.Framework.Profiler.ProfilerResult? ProfilerResult { get { throw null; } set { } }
         public string ProjectFile { get { throw null; } set { } }
+        public System.Collections.IEnumerable Properties { get { throw null; } set { } }
     }
     public partial class ProjectEvaluationStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
@@ -589,6 +606,22 @@ public TaskFinishedEventArgs(string message, string helpKeyword, string projectF
         public string TaskName { get { throw null; } }
     }
     public delegate void TaskFinishedEventHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e);
+    public partial class TaskParameterEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
+    {
+        public TaskParameterEventArgs(Microsoft.Build.Framework.TaskParameterMessageKind kind, string itemType, System.Collections.IList items, bool logItemMetadata, System.DateTime eventTimestamp) { }
+        public System.Collections.IList Items { get { throw null; } }
+        public string ItemType { get { throw null; } }
+        public Microsoft.Build.Framework.TaskParameterMessageKind Kind { get { throw null; } }
+        public bool LogItemMetadata { get { throw null; } }
+        public override string Message { get { throw null; } }
+    }
+    public enum TaskParameterMessageKind
+    {
+        TaskInput = 0,
+        TaskOutput = 1,
+        AddItem = 2,
+        RemoveItem = 3,
+    }
     public partial class TaskPropertyInfo
     {
         public TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) { }
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
index 9c2d45f2253..7b0fbb39d15 100644
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
@@ -38,6 +38,7 @@ protected BuildEventArgs(string message, string helpKeyword, string senderName,
         public Microsoft.Build.Framework.BuildEventContext BuildEventContext { get { throw null; } set { } }
         public string HelpKeyword { get { throw null; } }
         public virtual string Message { get { throw null; } protected set { } }
+        protected internal System.DateTime RawTimestamp { get { throw null; } set { } }
         public string SenderName { get { throw null; } }
         public int ThreadId { get { throw null; } }
         public System.DateTime Timestamp { get { throw null; } }
@@ -213,6 +214,15 @@ public partial interface IBuildEngine7 : Microsoft.Build.Framework.IBuildEngine,
     {
         bool AllowFailureWithoutError { get; set; }
     }
+    public partial interface IBuildEngine8 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7
+    {
+        bool ShouldTreatWarningAsError(string warningCode);
+    }
+    public partial interface IBuildEngine9 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7, Microsoft.Build.Framework.IBuildEngine8
+    {
+        void ReleaseCores(int coresToRelease);
+        int RequestCores(int requestedCores);
+    }
     public partial interface ICancelableTask : Microsoft.Build.Framework.ITask
     {
         void Cancel();
@@ -248,6 +258,10 @@ public partial interface IEventSource3 : Microsoft.Build.Framework.IEventSource,
         void IncludeEvaluationProfiles();
         void IncludeTaskInputs();
     }
+    public partial interface IEventSource4 : Microsoft.Build.Framework.IEventSource, Microsoft.Build.Framework.IEventSource2, Microsoft.Build.Framework.IEventSource3
+    {
+        void IncludeEvaluationPropertiesAndItems();
+    }
     public partial interface IForwardingLogger : Microsoft.Build.Framework.ILogger, Microsoft.Build.Framework.INodeLogger
     {
         Microsoft.Build.Framework.IEventRedirector BuildEventRedirector { get; set; }
@@ -376,8 +390,11 @@ public sealed partial class ProjectEvaluationFinishedEventArgs : Microsoft.Build
     {
         public ProjectEvaluationFinishedEventArgs() { }
         public ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) { }
+        public System.Collections.IEnumerable GlobalProperties { get { throw null; } set { } }
+        public System.Collections.IEnumerable Items { get { throw null; } set { } }
         public Microsoft.Build.Framework.Profiler.ProfilerResult? ProfilerResult { get { throw null; } set { } }
         public string ProjectFile { get { throw null; } set { } }
+        public System.Collections.IEnumerable Properties { get { throw null; } set { } }
     }
     public partial class ProjectEvaluationStartedEventArgs : Microsoft.Build.Framework.BuildStatusEventArgs
     {
@@ -588,6 +605,22 @@ public TaskFinishedEventArgs(string message, string helpKeyword, string projectF
         public string TaskName { get { throw null; } }
     }
     public delegate void TaskFinishedEventHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e);
+    public partial class TaskParameterEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
+    {
+        public TaskParameterEventArgs(Microsoft.Build.Framework.TaskParameterMessageKind kind, string itemType, System.Collections.IList items, bool logItemMetadata, System.DateTime eventTimestamp) { }
+        public System.Collections.IList Items { get { throw null; } }
+        public string ItemType { get { throw null; } }
+        public Microsoft.Build.Framework.TaskParameterMessageKind Kind { get { throw null; } }
+        public bool LogItemMetadata { get { throw null; } }
+        public override string Message { get { throw null; } }
+    }
+    public enum TaskParameterMessageKind
+    {
+        TaskInput = 0,
+        TaskOutput = 1,
+        AddItem = 2,
+        RemoveItem = 3,
+    }
     public partial class TaskPropertyInfo
     {
         public TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) { }
diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index ad59f4d890f..c94de3e3688 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -333,7 +333,6 @@ public Exec() { }
         [Microsoft.Build.Framework.OutputAttribute]
         public string StdOutEncoding { get { throw null; } set { } }
         protected override string ToolName { get { throw null; } }
-        public string UseUtf8Encoding { get { throw null; } set { } }
         public string WorkingDirectory { get { throw null; } set { } }
         protected internal override void AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
         protected override int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) { throw null; }
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 14e40af12dd..1cefcd56250 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -263,7 +263,6 @@ public Exec() { }
         [Microsoft.Build.Framework.OutputAttribute]
         public string StdOutEncoding { get { throw null; } set { } }
         protected override string ToolName { get { throw null; } }
-        public string UseUtf8Encoding { get { throw null; } set { } }
         public string WorkingDirectory { get { throw null; } set { } }
         protected internal override void AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) { }
         protected override int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) { throw null; }
diff --git a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
index 604210eaa06..e435979d2b2 100644
--- a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
@@ -227,6 +227,7 @@ public partial class MuxLogger : Microsoft.Build.Framework.ILogger, Microsoft.Bu
         public MuxLogger() { }
         public bool IncludeEvaluationMetaprojects { get { throw null; } set { } }
         public bool IncludeEvaluationProfiles { get { throw null; } set { } }
+        public bool IncludeEvaluationPropertiesAndItems { get { throw null; } set { } }
         public bool IncludeTaskInputs { get { throw null; } set { } }
         public string Parameters { get { throw null; } set { } }
         public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
@@ -353,6 +354,8 @@ protected Task(System.Resources.ResourceManager taskResources, string helpKeywor
         public Microsoft.Build.Framework.IBuildEngine5 BuildEngine5 { get { throw null; } }
         public Microsoft.Build.Framework.IBuildEngine6 BuildEngine6 { get { throw null; } }
         public Microsoft.Build.Framework.IBuildEngine7 BuildEngine7 { get { throw null; } }
+        public Microsoft.Build.Framework.IBuildEngine8 BuildEngine8 { get { throw null; } }
+        public Microsoft.Build.Framework.IBuildEngine9 BuildEngine9 { get { throw null; } }
         protected string HelpKeywordPrefix { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskHost HostObject { get { throw null; } set { } }
         public Microsoft.Build.Utilities.TaskLoggingHelper Log { get { throw null; } }
@@ -555,6 +558,7 @@ protected ToolTask(System.Resources.ResourceManager taskResources, string helpKe
         protected abstract string ToolName { get; }
         public string ToolPath { get { throw null; } set { } }
         public bool UseCommandProcessor { get { throw null; } set { } }
+        public string UseUtf8Encoding { get { throw null; } set { } }
         public bool YieldDuringToolExecution { get { throw null; } set { } }
         protected virtual string AdjustCommandsForOperatingSystem(string input) { throw null; }
         protected virtual bool CallHostObjectToExecute() { throw null; }
diff --git a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
index dc633b0e922..d77c4295057 100644
--- a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
@@ -72,6 +72,7 @@ public partial class MuxLogger : Microsoft.Build.Framework.ILogger, Microsoft.Bu
         public MuxLogger() { }
         public bool IncludeEvaluationMetaprojects { get { throw null; } set { } }
         public bool IncludeEvaluationProfiles { get { throw null; } set { } }
+        public bool IncludeEvaluationPropertiesAndItems { get { throw null; } set { } }
         public bool IncludeTaskInputs { get { throw null; } set { } }
         public string Parameters { get { throw null; } set { } }
         public Microsoft.Build.Framework.LoggerVerbosity Verbosity { get { throw null; } set { } }
@@ -198,6 +199,8 @@ protected Task(System.Resources.ResourceManager taskResources, string helpKeywor
         public Microsoft.Build.Framework.IBuildEngine5 BuildEngine5 { get { throw null; } }
         public Microsoft.Build.Framework.IBuildEngine6 BuildEngine6 { get { throw null; } }
         public Microsoft.Build.Framework.IBuildEngine7 BuildEngine7 { get { throw null; } }
+        public Microsoft.Build.Framework.IBuildEngine8 BuildEngine8 { get { throw null; } }
+        public Microsoft.Build.Framework.IBuildEngine9 BuildEngine9 { get { throw null; } }
         protected string HelpKeywordPrefix { get { throw null; } set { } }
         public Microsoft.Build.Framework.ITaskHost HostObject { get { throw null; } set { } }
         public Microsoft.Build.Utilities.TaskLoggingHelper Log { get { throw null; } }
@@ -395,6 +398,7 @@ protected ToolTask(System.Resources.ResourceManager taskResources, string helpKe
         protected abstract string ToolName { get; }
         public string ToolPath { get { throw null; } set { } }
         public bool UseCommandProcessor { get { throw null; } set { } }
+        public string UseUtf8Encoding { get { throw null; } set { } }
         public bool YieldDuringToolExecution { get { throw null; } set { } }
         protected virtual string AdjustCommandsForOperatingSystem(string input) { throw null; }
         protected virtual bool CallHostObjectToExecute() { throw null; }
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index b7c9a8e40e5..df63aa205be 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -1126,6 +1126,7 @@ public partial class ProjectInstance
         public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml) { }
         public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
         public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
+        public ProjectInstance(Microsoft.Build.Evaluation.Project project, Microsoft.Build.Execution.ProjectInstanceSettings settings) { }
         public ProjectInstance(string projectFile) { }
         public ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { }
         public ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
@@ -1426,6 +1427,9 @@ public CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, strin
     public partial class CacheResult
     {
         internal CacheResult() { }
+        public Microsoft.Build.Execution.BuildResult BuildResult { get { throw null; } }
+        public Microsoft.Build.Experimental.ProjectCache.ProxyTargets ProxyTargets { get { throw null; } }
+        public Microsoft.Build.Experimental.ProjectCache.CacheResultType ResultType { get { throw null; } }
         public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) { throw null; }
         public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) { throw null; }
         public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) { throw null; }
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index 5e7b0352732..2e945e6c024 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -1120,6 +1120,7 @@ public partial class ProjectInstance
         public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml) { }
         public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
         public ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
+        public ProjectInstance(Microsoft.Build.Evaluation.Project project, Microsoft.Build.Execution.ProjectInstanceSettings settings) { }
         public ProjectInstance(string projectFile) { }
         public ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) { }
         public ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
@@ -1420,6 +1421,9 @@ public CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, strin
     public partial class CacheResult
     {
         internal CacheResult() { }
+        public Microsoft.Build.Execution.BuildResult BuildResult { get { throw null; } }
+        public Microsoft.Build.Experimental.ProjectCache.ProxyTargets ProxyTargets { get { throw null; } }
+        public Microsoft.Build.Experimental.ProjectCache.CacheResultType ResultType { get { throw null; } }
         public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) { throw null; }
         public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) { throw null; }
         public static Microsoft.Build.Experimental.ProjectCache.CacheResult IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) { throw null; }
diff --git a/runApiCompat.bat b/runApiCompat.bat
deleted file mode 100644
index 34ad60930c5..00000000000
--- a/runApiCompat.bat
+++ /dev/null
@@ -1,14 +0,0 @@
-@echo off
-setlocal
-
-set MSBUILD_ROOT=%~dp0
-
-REM Copy .NET 4.6 reference assemblies to the same folder as the MSBuild reference assemblies so ApiCompat can resolve their framework references
-mkdir "%MSBUILD_ROOT%ref"
-RoboCopy "C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6" "%MSBUILD_ROOT%ref"
-RoboCopy "C:\Program Files (x86)\Reference Assemblies\Microsoft\MSBuild\v14.0" "%MSBUILD_ROOT%ref"
-
-REM Run ApiCompat
-\\fxcore\tools\bin\ApiCompat.exe "%MSBUILD_ROOT%\bin\Windows_NT\Debug-NetCore\Microsoft.Build.Framework.dll,%MSBUILD_ROOT%\bin\Windows_NT\Debug-NetCore\Microsoft.Build.Utilities.Core.dll,%MSBUILD_ROOT%\bin\Windows_NT\Debug-NetCore\Microsoft.Build.Tasks.Core.dll" -implDirs:"%MSBUILD_ROOT%ref" -contractDepends:"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6,C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6\Facades" -out:Differences.txt -baseline:CompatBaseline.txt
-
-endlocal
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index 6dcaa45e84e..a7be71e809a 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -60,7 +60,7 @@ public Project_Tests(ITestOutputHelper output)
         public void Dispose()
         {
             ProjectCollection.GlobalProjectCollection.UnloadAllProjects();
-            Assert.Equal(0, ProjectCollection.GlobalProjectCollection.Count);
+            ProjectCollection.GlobalProjectCollection.Count.ShouldBe(0);
 
             IDictionary<string, string> globalProperties = ProjectCollection.GlobalProjectCollection.GlobalProperties;
             foreach (string propertyName in globalProperties.Keys)
@@ -68,7 +68,7 @@ public void Dispose()
                 ProjectCollection.GlobalProjectCollection.RemoveGlobalProperty(propertyName);
             }
 
-            Assert.Empty(ProjectCollection.GlobalProjectCollection.GlobalProperties);
+            ProjectCollection.GlobalProjectCollection.GlobalProperties.ShouldBeEmpty();
         }
 
         private static readonly string ProjectWithItemGroup =
@@ -108,7 +108,7 @@ public void VerifyNewLinesAndTabsEvaluateToEmpty()
             ProjectRootElement xml = ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)));
             Project project = new Project(xml);
             bool result = project.Build(new ILogger[] { mockLogger });
-            Assert.True(result);
+            result.ShouldBeTrue();
             mockLogger.AssertLogContains("NewLineEvalAsEmpty");
             mockLogger.AssertLogContains("TabEvalAsEmpty");
             mockLogger.AssertLogContains("CarriageReturnEvalAsEmpty");
@@ -136,7 +136,7 @@ public void LogWithLoggersOnProjectCollection()
             Project project = new Project(xml, null, null, collection);
 
             bool result = project.Build();
-            Assert.True(result);
+            result.ShouldBeTrue();
             mockLogger.AssertLogContains("IHaveBeenLogged");
         }
 
@@ -163,7 +163,7 @@ public void LogWithLoggersOnProjectCollectionCustomOneUsed()
             Project project = new Project(xml, null, null, collection);
 
             bool result = project.Build(mockLogger);
-            Assert.True(result);
+            result.ShouldBeTrue();
             mockLogger.AssertLogContains("IHaveBeenLogged");
             mockLogger2.AssertLogDoesntContain("IHaveBeenLogged");
         }
@@ -238,7 +238,7 @@ public void FailedEvaluationClearsXmlCache()
         [Fact]
         public void ReadFromEmptyReader1()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 XmlReader reader = XmlReader.Create(new StringReader(String.Empty));
                 ProjectRootElement.Create(reader);
@@ -252,7 +252,7 @@ public void ReadFromEmptyReader1()
         [Fact]
         public void ReadFromEmptyReader2()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 XmlReader reader = XmlReader.Create(new StringReader(String.Empty));
                 Project project = new Project(reader);
@@ -266,7 +266,7 @@ public void ReadFromEmptyReader2()
         [Fact]
         public void ReadFromEmptyReader3()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 // Variation, we have a reader but it's already read
                 XmlReader reader = XmlReader.Create(new StringReader(ProjectRootElement.Create().RawXml));
@@ -287,7 +287,7 @@ public void ReadFromEmptyReader3()
         [Fact]
         public void ReadFromClosedReader()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 XmlReader reader = XmlReader.Create(new StringReader(String.Empty));
                 reader.Dispose();
@@ -311,7 +311,7 @@ public void ReadFromReaderTwoDocs()
 
             Project project2 = new Project(reader);
 
-            Assert.False(reader.Read());
+            reader.Read().ShouldBeFalse();
         }
 
         /// <summary>
@@ -320,7 +320,7 @@ public void ReadFromReaderTwoDocs()
         [Fact]
         public void ImportDoesNotExistDefaultSettings()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 ProjectRootElement xml = ProjectRootElement.Create();
                 xml.AddImport("__nonexistent__");
@@ -335,7 +335,7 @@ public void ImportDoesNotExistDefaultSettings()
         [Fact]
         public void ImportInvalidUriFormat()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 ProjectRootElement xml = ProjectRootElement.Create();
                 xml.AddImport(@"//MSBuildExtensionsPath32)\4.0\Microsoft.VisualStudioVersion.v11.Common.props");
@@ -375,7 +375,7 @@ public void ImportDoesNotExistIgnoreMissingImports()
             Project project = new Project(xml, null, null, new ProjectCollection(), ProjectLoadSettings.IgnoreMissingImports);
 
             // Make sure some evaluation did occur
-            Assert.Equal("1", project.GetPropertyValue("q"));
+            project.GetPropertyValue("q").ShouldBe("1");
         }
 
         /// <summary>
@@ -385,12 +385,12 @@ public void ImportDoesNotExistIgnoreMissingImports()
         [Fact]
         public void TryImportsIncludingDuplicatesExpectException()
         {
-            Assert.Throws<InvalidOperationException>(() =>
+            Should.Throw<InvalidOperationException>(() =>
             {
                 ProjectRootElement xml = ProjectRootElement.Create();
                 Project project = new Project(xml, null, null, new ProjectCollection(), ProjectLoadSettings.IgnoreMissingImports);
                 IList<ResolvedImport> imports = project.ImportsIncludingDuplicates;
-                Assert.Empty(imports);
+                imports.ShouldBeEmpty();
             }
            );
         }
@@ -600,27 +600,27 @@ public void BasicFromXmlFollowImport()
             ProjectRootElement xml = ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)));
             Project project = new Project(xml);
 
-            Assert.Equal("v3", project.GetPropertyValue("p2"));
+            project.GetPropertyValue("p2").ShouldBe("v3");
 
             List<ProjectItem> items = Helpers.MakeList(project.GetItems("i"));
-            Assert.Equal(4, items.Count);
-            Assert.Equal("i1", items[0].EvaluatedInclude);
-            Assert.Equal("v2X", items[1].EvaluatedInclude);
-            Assert.Equal("i3", items[2].EvaluatedInclude);
-            Assert.Equal("i4", items[3].EvaluatedInclude);
+            items.Count.ShouldBe(4);
+            items[0].EvaluatedInclude.ShouldBe("i1");
+            items[1].EvaluatedInclude.ShouldBe("v2X");
+            items[2].EvaluatedInclude.ShouldBe("i3");
+            items[3].EvaluatedInclude.ShouldBe("i4");
 
             IList<ResolvedImport> imports = project.Imports;
-            Assert.Single(imports);
-            Assert.True(object.ReferenceEquals(imports.First().ImportingElement, xml.Imports.ElementAt(0)));
+            imports.ShouldHaveSingleItem();
+            object.ReferenceEquals(imports.First().ImportingElement, xml.Imports.ElementAt(0)).ShouldBeTrue();
 
             // We can take advantage of the fact that we will get the same ProjectRootElement from the cache if we try to
             // open it with a path; get that and then compare it to what project.Imports gave us.
-            Assert.True(object.ReferenceEquals(imports.First().ImportedProject, ProjectRootElement.Open(importPath)));
+            object.ReferenceEquals(imports.First().ImportedProject, ProjectRootElement.Open(importPath)).ShouldBeTrue();
 
             // Test the logical project iterator
             List<ProjectElement> logicalElements = new List<ProjectElement>(project.GetLogicalProject());
 
-            Assert.Equal(18, logicalElements.Count);
+            logicalElements.Count.ShouldBe(18);
 
             ObjectModelHelpers.DeleteTempProjectDirectory();
         }
@@ -651,11 +651,10 @@ public void TransformsUseCorrectDirectory_Basic()
                 project.Save(file);
                 project.ReevaluateIfNecessary();
 
-                Assert.Equal(
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(
                     NativeMethodsShared.IsWindows
                         ? Path.Combine(Path.GetTempPath(), @"obj\i386\foo.dll")
-                        : Path.Combine(Path.GetTempPath(), @"obj/i386/foo.dll"),
-                    project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
+                        : Path.Combine(Path.GetTempPath(), @"obj/i386/foo.dll"));
             }
             finally
             {
@@ -685,21 +684,13 @@ public void TransformsUseCorrectDirectory_Basic_NotSaved()
 
             if (NativeMethodsShared.IsWindows)
             {
-                Assert.Equal(
-                    Path.Combine(Directory.GetCurrentDirectory(), @"obj\i386\foo.dll"),
-                    project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
-                Assert.Equal(
-                    Path.Combine(Directory.GetCurrentDirectory(), @"obj\i386\foo.dll"),
-                    projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), @"obj\i386\foo.dll"));
+                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), @"obj\i386\foo.dll"));
             }
             else
             {
-                Assert.Equal(
-                    Path.Combine(Directory.GetCurrentDirectory(), @"obj/i386/foo.dll"),
-                    project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
-                Assert.Equal(
-                   Path.Combine(Directory.GetCurrentDirectory(), @"obj/i386/foo.dll"),
-                    projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), @"obj/i386/foo.dll"));
+                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), @"obj/i386/foo.dll"));
             }
         }
 
@@ -728,12 +719,8 @@ public void TransformsUseCorrectDirectory_DirectoryTransform()
                 Project project = new Project(xml);
                 ProjectInstance projectInstance = new ProjectInstance(xml);
 
-                Assert.Equal(
-                        Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar,
-                        project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
-                Assert.Equal(
-                        Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar,
-                        projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
+                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
             }
             finally
             {
@@ -767,12 +754,8 @@ public void TransformsUseCorrectDirectory_DirectoryItemFunction()
                 Project project = new Project(xml);
                 ProjectInstance projectInstance = new ProjectInstance(xml);
 
-                Assert.Equal(
-                        Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar,
-                        project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
-                Assert.Equal(
-                        Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar,
-                        projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
+                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
             }
             finally
             {
@@ -809,12 +792,8 @@ public void TransformsUseCorrectDirectory_DirectoryNameItemFunction()
                 ProjectInstance projectInstance = new ProjectInstance(xml);
 
                 // Should be the full path to the directory
-                Assert.Equal(
-                    Path.Combine(Path.GetTempPath() /* remove c:\ */, "obj" + Path.DirectorySeparatorChar + "i386"),
-                    project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
-                Assert.Equal(
-                    Path.Combine(Path.GetTempPath() /* remove c:\ */, "obj" + Path.DirectorySeparatorChar + "i386"),
-                    projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude);
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath() /* remove c:\ */, "obj" + Path.DirectorySeparatorChar + "i386"));
+                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath() /* remove c:\ */, "obj" + Path.DirectorySeparatorChar + "i386"));
             }
             finally
             {
@@ -834,8 +813,8 @@ public void GetGlobalProperties()
             globalProperties.Add("g2", "v2");
             Project project = new Project(xml, globalProperties, null);
 
-            Assert.Equal("v1", project.GlobalProperties["g1"]);
-            Assert.Equal("v2", project.GlobalProperties["g2"]);
+            project.GlobalProperties["g1"].ShouldBe("v1");
+            project.GlobalProperties["g2"].ShouldBe("v2");
         }
 
         /// <summary>
@@ -852,8 +831,8 @@ public void GlobalPropertiesCloned()
 
             globalProperties.Add("g2", "v2");
 
-            Assert.Equal("v1", project.GlobalProperties["g1"]);
-            Assert.False(project.GlobalProperties.ContainsKey("g2"));
+            project.GlobalProperties["g1"].ShouldBe("v1");
+            project.GlobalProperties.ContainsKey("g2").ShouldBeFalse();
         }
 
         /// <summary>
@@ -865,7 +844,7 @@ public void GetGlobalPropertiesNone()
             ProjectRootElement xml = GetSampleProjectRootElement();
             Project project = new Project(xml);
 
-            Assert.Empty(project.GlobalProperties);
+            project.GlobalProperties.ShouldBeEmpty();
         }
 
         /// <summary>
@@ -879,13 +858,13 @@ public void ChangeGlobalProperties()
             ProjectPropertyElement propertyElement = project.Xml.AddProperty("p", "v0");
             propertyElement.Condition = "'$(g)'=='v1'";
             project.ReevaluateIfNecessary();
-            Assert.Equal(string.Empty, project.GetPropertyValue("p"));
+            project.GetPropertyValue("p").ShouldBe(string.Empty);
 
-            Assert.True(project.SetGlobalProperty("g", "v1"));
-            Assert.True(project.IsDirty);
+            project.SetGlobalProperty("g", "v1").ShouldBeTrue();
+            project.IsDirty.ShouldBeTrue();
             project.ReevaluateIfNecessary();
-            Assert.Equal("v0", project.GetPropertyValue("p"));
-            Assert.Equal("v1", project.GlobalProperties["g"]);
+            project.GetPropertyValue("p").ShouldBe("v0");
+            project.GlobalProperties["g"].ShouldBe("v1");
         }
 
         /// <summary>
@@ -899,8 +878,8 @@ public void ChangeGlobalPropertyAfterReevaluation()
             project.ReevaluateIfNecessary();
             project.SetGlobalProperty("p", "v2");
 
-            Assert.Equal("v2", project.GetPropertyValue("p"));
-            Assert.True(project.GetProperty("p").IsGlobalProperty);
+            project.GetPropertyValue("p").ShouldBe("v2");
+            project.GetProperty("p").IsGlobalProperty.ShouldBeTrue();
         }
 
         /// <summary>
@@ -912,19 +891,19 @@ public void SkipEvaluation()
             Project project = new Project();
             project.SetGlobalProperty("p", "v1");
             project.ReevaluateIfNecessary();
-            Assert.Equal("v1", project.GetPropertyValue("p"));
+            project.GetPropertyValue("p").ShouldBe("v1");
 
             project.SkipEvaluation = true;
             ProjectPropertyElement propertyElement = project.Xml.AddProperty("p1", "v0");
             propertyElement.Condition = "'$(g)'=='v1'";
             project.SetGlobalProperty("g", "v1");
             project.ReevaluateIfNecessary();
-            Assert.Equal(string.Empty, project.GetPropertyValue("p1"));
+            project.GetPropertyValue("p1").ShouldBe(string.Empty);
 
             project.SkipEvaluation = false;
             project.SetGlobalProperty("g", "v1");
             project.ReevaluateIfNecessary();
-            Assert.Equal("v0", project.GetPropertyValue("p1"));
+            project.GetPropertyValue("p1").ShouldBe("v0");
         }
 
         /// <summary>
@@ -934,7 +913,7 @@ public void SkipEvaluation()
         [Fact]
         public void ChangeGlobalPropertyAfterReevaluation2()
         {
-            Assert.Throws<InvalidOperationException>(() =>
+            Should.Throw<InvalidOperationException>(() =>
             {
                 Project project = new Project();
                 project.SetGlobalProperty("p", "v1");
@@ -952,12 +931,12 @@ public void ChangeEnvironmentProperty()
             Project project = new Project();
             project.SetProperty("computername", "v1");
 
-            Assert.Equal("v1", project.GetPropertyValue("computername"));
-            Assert.True(project.IsDirty);
+            project.GetPropertyValue("computername").ShouldBe("v1");
+            project.IsDirty.ShouldBeTrue();
 
             project.ReevaluateIfNecessary();
 
-            Assert.Equal("v1", project.GetPropertyValue("computername"));
+            project.GetPropertyValue("computername").ShouldBe("v1");
         }
 
         /// <summary>
@@ -966,7 +945,7 @@ public void ChangeEnvironmentProperty()
         [Fact]
         public void SetReservedPropertyThroughProject()
         {
-            Assert.Throws<InvalidOperationException>(() =>
+            Should.Throw<InvalidOperationException>(() =>
             {
                 Project project = new Project();
                 project.SetProperty("msbuildprojectdirectory", "v1");
@@ -986,14 +965,14 @@ public void ChangeGlobalPropertiesPreexisting()
             ProjectPropertyElement propertyElement = project.Xml.AddProperty("pp", "vv");
             propertyElement.Condition = "'$(p0)'=='v0' and '$(p1)'=='v1b'";
             project.ReevaluateIfNecessary();
-            Assert.Equal(string.Empty, project.GetPropertyValue("pp"));
+            project.GetPropertyValue("pp").ShouldBe(string.Empty);
 
             project.SetGlobalProperty("p1", "v1b");
-            Assert.True(project.IsDirty);
+            project.IsDirty.ShouldBeTrue();
             project.ReevaluateIfNecessary();
-            Assert.Equal("vv", project.GetPropertyValue("pp"));
-            Assert.Equal("v0", project.GlobalProperties["p0"]);
-            Assert.Equal("v1b", project.GlobalProperties["p1"]);
+            project.GetPropertyValue("pp").ShouldBe("vv");
+            project.GlobalProperties["p0"].ShouldBe("v0");
+            project.GlobalProperties["p1"].ShouldBe("v1b");
         }
 
         /// <summary>
@@ -1016,14 +995,14 @@ public void ChangeGlobalPropertiesInitiallyFromProjectCollection()
             ProjectPropertyElement propertyElement = project.Xml.AddProperty("pp", "vv");
             propertyElement.Condition = "'$(p0)'=='v0' and '$(p1)'=='v1b'";
             project.ReevaluateIfNecessary();
-            Assert.Equal(string.Empty, project.GetPropertyValue("pp"));
+            project.GetPropertyValue("pp").ShouldBe(string.Empty);
 
             project.SetGlobalProperty("p1", "v1b");
-            Assert.True(project.IsDirty);
+            project.IsDirty.ShouldBeTrue();
             project.ReevaluateIfNecessary();
-            Assert.Equal("vv", project.GetPropertyValue("pp"));
-            Assert.Equal("v0", collection.GlobalProperties["p0"]);
-            Assert.Equal("v1", collection.GlobalProperties["p1"]);
+            project.GetPropertyValue("pp").ShouldBe("vv");
+            collection.GlobalProperties["p0"].ShouldBe("v0");
+            collection.GlobalProperties["p1"].ShouldBe("v1");
         }
 
         /// <summary>
@@ -1034,11 +1013,11 @@ public void ChangeGlobalPropertiesSameValue()
         {
             Project project = new Project();
             project.SetGlobalProperty("g", "v1");
-            Assert.True(project.IsDirty);
+            project.IsDirty.ShouldBeTrue();
             project.ReevaluateIfNecessary();
 
-            Assert.False(project.SetGlobalProperty("g", "v1"));
-            Assert.False(project.IsDirty);
+            project.SetGlobalProperty("g", "v1").ShouldBeFalse();
+            project.IsDirty.ShouldBeFalse();
         }
 
         /// <summary>
@@ -1053,14 +1032,14 @@ public void RemoveGlobalProperties()
             propertyElement.Condition = "'$(g)'==''";
             project.SetGlobalProperty("g", "v1");
             project.ReevaluateIfNecessary();
-            Assert.Equal(string.Empty, project.GetPropertyValue("p"));
+            project.GetPropertyValue("p").ShouldBe(string.Empty);
 
             bool existed = project.RemoveGlobalProperty("g");
-            Assert.True(existed);
-            Assert.True(project.IsDirty);
+            existed.ShouldBeTrue();
+            project.IsDirty.ShouldBeTrue();
             project.ReevaluateIfNecessary();
-            Assert.Equal("v0", project.GetPropertyValue("p"));
-            Assert.False(project.GlobalProperties.ContainsKey("g"));
+            project.GetPropertyValue("p").ShouldBe("v0");
+            project.GlobalProperties.ContainsKey("g").ShouldBeFalse();
         }
 
         /// <summary>
@@ -1072,8 +1051,8 @@ public void RemoveNonExistentGlobalProperties()
             Project project = new Project();
             bool existed = project.RemoveGlobalProperty("x");
 
-            Assert.False(existed);
-            Assert.False(project.IsDirty);
+            existed.ShouldBeFalse();
+            project.IsDirty.ShouldBeFalse();
         }
 
         /// <summary>
@@ -1094,7 +1073,7 @@ public void GetToolsVersionExplicitlySpecified()
                 new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase),
                 ObjectModelHelpers.MSBuildDefaultToolsVersion);
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.ToolsVersion);
+            project.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
         }
 
         /// <summary>
@@ -1110,7 +1089,7 @@ public void GetToolsVersionNoneExplicitlySpecified()
 
             Project project = new Project(xml);
 
-            Assert.Equal(string.Empty, project.Xml.ToolsVersion);
+            project.Xml.ToolsVersion.ShouldBe(string.Empty);
 
             ObjectModelHelpers.DeleteTempProjectDirectory();
         }
@@ -1123,7 +1102,7 @@ public void GetToolsVersionFromProject()
         {
             Project project = new Project();
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.ToolsVersion);
+            project.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
         }
 
         /// <summary>
@@ -1147,12 +1126,12 @@ public void ProjectToolsVersion20Present()
             // to turn this behavior (new in Dev12) off, but it requires setting an environment variable and
             // clearing some internal state to make sure that the update environment variable is picked up, so
             // there's not a good way of doing it from these deliberately public OM only tests.
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.ToolsVersion);
+            project.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
 
             project.Xml.ToolsVersion = "4.0";
 
             // Still defaulting to the current ToolsVersion
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.ToolsVersion);
+            project.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
         }
 
         /// <summary>
@@ -1172,11 +1151,11 @@ public void ProjectToolsVersion20NotPresent()
             project.Xml.ToolsVersion = "2.0";
             project.ReevaluateIfNecessary();
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.ToolsVersion);
+            project.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
 
             project.Xml.ToolsVersion = ObjectModelHelpers.MSBuildDefaultToolsVersion;
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.ToolsVersion);
+            project.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
         }
 
         /// <summary>
@@ -1200,17 +1179,17 @@ public void MSBuildToolsVersionProperty()
             // to turn this behavior (new in Dev12) off, but it requires setting an environment variable and
             // clearing some internal state to make sure that the update environment variable is picked up, so
             // there's not a good way of doing it from these deliberately public OM only tests.
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.GetPropertyValue("msbuildtoolsversion"));
+            project.GetPropertyValue("msbuildtoolsversion").ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
 
             project.Xml.ToolsVersion = "4.0";
 
             // Still current
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.GetPropertyValue("msbuildtoolsversion"));
+            project.GetPropertyValue("msbuildtoolsversion").ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
 
             project.ReevaluateIfNecessary();
 
             // Still current
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.GetPropertyValue("msbuildtoolsversion"));
+            project.GetPropertyValue("msbuildtoolsversion").ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
         }
 
         /// <summary>
@@ -1222,7 +1201,7 @@ public void MSBuildToolsVersionProperty40()
         {
             Project project = new Project();
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, project.GetPropertyValue("msbuildtoolsversion"));
+            project.GetPropertyValue("msbuildtoolsversion").ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
         }
 
         /// <summary>
@@ -1237,7 +1216,7 @@ public void ChangingToolsVersionAttributeToUnrecognizedValue()
 
             project.Xml.ToolsVersion = "bogus";
 
-            Assert.Equal("bogus", project.Xml.ToolsVersion);
+            project.Xml.ToolsVersion.ShouldBe("bogus");
         }
 
         /// <summary>
@@ -1254,13 +1233,13 @@ public void GetSubToolsetVersion()
 
                 Project p = new Project(GetSampleProjectRootElement(), null, ObjectModelHelpers.MSBuildDefaultToolsVersion, new ProjectCollection());
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.ToolsVersion);
+                p.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
 
                 Toolset t = p.ProjectCollection.GetToolset(ObjectModelHelpers.MSBuildDefaultToolsVersion);
 
-                Assert.Equal(t.DefaultSubToolsetVersion, p.SubToolsetVersion);
+                p.SubToolsetVersion.ShouldBe(t.DefaultSubToolsetVersion);
 
-                Assert.Equal(t.DefaultSubToolsetVersion ?? MSBuildConstants.CurrentVisualStudioVersion, p.GetPropertyValue("VisualStudioVersion"));
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe(t.DefaultSubToolsetVersion ?? MSBuildConstants.CurrentVisualStudioVersion);
             }
             finally
             {
@@ -1284,9 +1263,9 @@ public void GetSubToolsetVersion_FromEnvironment()
 
                 Project p = new Project(GetSampleProjectRootElement(), null, ObjectModelHelpers.MSBuildDefaultToolsVersion, new ProjectCollection());
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.ToolsVersion);
-                Assert.Equal("ABCD", p.SubToolsetVersion);
-                Assert.Equal("ABCD", p.GetPropertyValue("VisualStudioVersion"));
+                p.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe("ABCD");
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe("ABCD");
             }
             finally
             {
@@ -1311,9 +1290,9 @@ public void GetSubToolsetVersion_FromProjectGlobalProperties()
 
                 Project p = new Project(GetSampleProjectRootElement(), globalProperties, ObjectModelHelpers.MSBuildDefaultToolsVersion, new ProjectCollection());
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.ToolsVersion);
-                Assert.Equal("ABCDE", p.SubToolsetVersion);
-                Assert.Equal("ABCDE", p.GetPropertyValue("VisualStudioVersion"));
+                p.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe("ABCDE");
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe("ABCDE");
             }
             finally
             {
@@ -1342,9 +1321,9 @@ public void GetSubToolsetVersion_FromConstructor()
 
                 Project p = new Project(GetSampleProjectRootElement(), globalProperties, ObjectModelHelpers.MSBuildDefaultToolsVersion, "ABCDEF", new ProjectCollection(projectCollectionGlobalProperties), ProjectLoadSettings.Default);
 
-                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, p.ToolsVersion);
-                Assert.Equal("ABCDEF", p.SubToolsetVersion);
-                Assert.Equal("ABCDEF", p.GetPropertyValue("VisualStudioVersion"));
+                p.ToolsVersion.ShouldBe(ObjectModelHelpers.MSBuildDefaultToolsVersion);
+                p.SubToolsetVersion.ShouldBe("ABCDEF");
+                p.GetPropertyValue("VisualStudioVersion").ShouldBe("ABCDEF");
             }
             finally
             {
@@ -1362,12 +1341,12 @@ public void LastEvaluationId()
             int last = project.LastEvaluationId;
 
             project.ReevaluateIfNecessary();
-            Assert.Equal(project.LastEvaluationId, last);
+            last.ShouldBe(project.LastEvaluationId);
             last = project.LastEvaluationId;
 
             project.SetProperty("p", "v");
             project.ReevaluateIfNecessary();
-            Assert.NotEqual(project.LastEvaluationId, last);
+            project.LastEvaluationId.ShouldNotBe(last);
         }
 
         /// <summary>
@@ -1389,7 +1368,7 @@ public void LastEvaluationIdAndUnload()
                 project.ProjectCollection.UnloadAllProjects();
 
                 project = new Project(path);
-                Assert.NotEqual(project.LastEvaluationId, last);
+                project.LastEvaluationId.ShouldNotBe(last);
             }
             finally
             {
@@ -1417,21 +1396,21 @@ public void ImportedXmlModified()
 
                 project.Xml.AddImport(path);
                 project.ReevaluateIfNecessary();
-                Assert.NotEqual(project.LastEvaluationId, last);
+                project.LastEvaluationId.ShouldNotBe(last);
                 last = project.LastEvaluationId;
 
                 project.ReevaluateIfNecessary();
-                Assert.Equal(project.LastEvaluationId, last);
+                last.ShouldBe(project.LastEvaluationId);
 
                 import.AddProperty("p", "v");
-                Assert.True(project.IsDirty);
+                project.IsDirty.ShouldBeTrue();
                 project.ReevaluateIfNecessary();
-                Assert.NotEqual(project.LastEvaluationId, last);
+                project.LastEvaluationId.ShouldNotBe(last);
                 last = project.LastEvaluationId;
-                Assert.Equal("v", project.GetPropertyValue("p"));
+                project.GetPropertyValue("p").ShouldBe("v");
 
                 project.ReevaluateIfNecessary();
-                Assert.Equal(project.LastEvaluationId, last);
+                last.ShouldBe(project.LastEvaluationId);
             }
             finally
             {
@@ -1474,13 +1453,12 @@ public void ImportingExistingPREObjectShouldPreserveTheObject()
 
                 // puts the import in the PRE cache
                 import.Save(importFile);
-                Assert.False(import.HasUnsavedChanges);
+                import.HasUnsavedChanges.ShouldBeFalse();
 
                 Project project = new Project(projectCollection);
                 project.Xml.AddImport(importFile);
                 project.ReevaluateIfNecessary();
-
-                Assert.Same(import, project.Imports.First().ImportedProject);
+                project.Imports.First().ImportedProject.ShouldBeSameAs(import);
             }
         }
 
@@ -1519,10 +1497,10 @@ public void ReloadedImportsMarkProjectAsDirty()
 
             Action<string, string, string, Project> assertContents = (p, i, m, project) =>
             {
-                Assert.Equal(p, project.GetPropertyValue("P"));
-                Assert.Single(project.GetItems("I"));
-                Assert.Equal(i, project.GetItems("I").First().EvaluatedInclude);
-                Assert.Equal(m, project.GetItems("I").First().GetMetadataValue("M"));
+                project.GetPropertyValue("P").ShouldBe(p);
+                project.GetItems("I").ShouldHaveSingleItem();
+                project.GetItems("I").First().EvaluatedInclude.ShouldBe(i);
+                project.GetItems("I").First().GetMetadataValue("M").ShouldBe(m);
             };
 
             using (var env = TestEnvironment.Create())
@@ -1539,23 +1517,23 @@ public void ReloadedImportsMarkProjectAsDirty()
 
                 // add to cache by saving
                 import.Save(importFile);
-                Assert.False(import.HasUnsavedChanges);
+                import.HasUnsavedChanges.ShouldBeFalse();
 
                 var project = new Project(projectCollection);
                 project.Xml.AddImport(importFile);
                 project.ReevaluateIfNecessary();
 
                 assertContents("p1", "i1", "m1", project);
-                Assert.False(project.IsDirty);
+                project.IsDirty.ShouldBeFalse();
 
                 import.ReloadFrom(XmlReader.Create(new StringReader(changedImportContents)));
-                Assert.True(import.HasUnsavedChanges);
+                import.HasUnsavedChanges.ShouldBeTrue();
 
-                Assert.True(project.IsDirty);
+                project.IsDirty.ShouldBeTrue();
                 assertContents("p1", "i1", "m1", project);
 
                 project.ReevaluateIfNecessary();
-                Assert.False(project.IsDirty);
+                project.IsDirty.ShouldBeFalse();
                 assertContents("p2", "i2", "m2", project);
 
                 var newProject = new Project(projectCollection);
@@ -1563,8 +1541,8 @@ public void ReloadedImportsMarkProjectAsDirty()
                 newProject.ReevaluateIfNecessary();
                 assertContents("p2", "i2", "m2", newProject);
 
-                Assert.Same(import, project.Imports.First().ImportedProject);
-                Assert.Same(import, newProject.Imports.First().ImportedProject);
+                project.Imports.First().ImportedProject.ShouldBeSameAs(import);
+                newProject.Imports.First().ImportedProject.ShouldBeSameAs(import);
             }
         }
 
@@ -1603,10 +1581,10 @@ public void ReloadedProjectRootElementMarksProjectAsDirty()
 
             Action<string, string, string, Project> assertContents = (p, i, m, project) =>
             {
-                Assert.Equal(p, project.GetPropertyValue("P"));
-                Assert.Single(project.GetItems("I"));
-                Assert.Equal(i, project.GetItems("I").First().EvaluatedInclude);
-                Assert.Equal(m, project.GetItems("I").First().GetMetadataValue("M"));
+                project.GetPropertyValue("P").ShouldBe(p);
+                project.GetItems("I").ShouldHaveSingleItem();
+                project.GetItems("I").First().EvaluatedInclude.ShouldBe(i);
+                project.GetItems("I").First().GetMetadataValue("M").ShouldBe(m);
             };
 
             using (var env = TestEnvironment.Create())
@@ -1623,22 +1601,22 @@ public void ReloadedProjectRootElementMarksProjectAsDirty()
 
                 // add to cache by saving
                 projectRootElement.Save(projectFile);
-                Assert.False(projectRootElement.HasUnsavedChanges);
+                projectRootElement.HasUnsavedChanges.ShouldBeFalse();
 
                 var project = new Project(projectRootElement, new Dictionary<string, string>(), MSBuildConstants.CurrentToolsVersion, projectCollection);
                 project.ReevaluateIfNecessary();
 
                 assertContents("p1", "i1", "m1", project);
-                Assert.False(project.IsDirty);
+                project.IsDirty.ShouldBeFalse();
 
                 projectRootElement.ReloadFrom(XmlReader.Create(new StringReader(changedProjectContents)));
-                Assert.True(projectRootElement.HasUnsavedChanges);
+                projectRootElement.HasUnsavedChanges.ShouldBeTrue();
 
-                Assert.True(project.IsDirty);
+                project.IsDirty.ShouldBeTrue();
                 assertContents("p1", "i1", "m1", project);
 
                 project.ReevaluateIfNecessary();
-                Assert.False(project.IsDirty);
+                project.IsDirty.ShouldBeFalse();
                 assertContents("p2", "i2", "m2", project);
             }
         }
@@ -1654,21 +1632,21 @@ public void ExternallyMarkDirty()
             project.SetProperty("p", "v");
             project.ReevaluateIfNecessary();
 
-            Assert.False(project.IsDirty);
+            project.IsDirty.ShouldBeFalse();
 
             ProjectProperty property1 = project.GetProperty("p");
 
             project.MarkDirty();
 
-            Assert.True(project.IsDirty);
+            project.IsDirty.ShouldBeTrue();
 
             project.ReevaluateIfNecessary();
 
-            Assert.False(project.IsDirty);
+            project.IsDirty.ShouldBeFalse();
 
             ProjectProperty property2 = project.GetProperty("p");
 
-            Assert.False(object.ReferenceEquals(property1, property2)); // different object indicates reevaluation occurred
+            object.ReferenceEquals(property1, property2).ShouldBeFalse(); // different object indicates reevaluation occurred
         }
 
         /// <summary>
@@ -1687,10 +1665,10 @@ public void ItemsByEvaluatedInclude()
 
             List<ProjectItem> items = Helpers.MakeList(project.GetItemsByEvaluatedInclude("i1"));
 
-            Assert.Equal(3, items.Count);
+            items.Count.ShouldBe(3);
             foreach (ProjectItem item in items)
             {
-                Assert.Equal("i1", item.EvaluatedInclude);
+                item.EvaluatedInclude.ShouldBe("i1");
             }
         }
 
@@ -1710,13 +1688,12 @@ public void ItemsByEvaluatedInclude_EvaluatedIncludeNeedsEscaping()
 
             List<ProjectItem> items = Helpers.MakeList(project.GetItemsByEvaluatedInclude("i&1"));
 
-            Assert.Equal(2, items.Count);
+            items.Count.ShouldBe(2);
             foreach (ProjectItem item in items)
             {
-                Assert.Equal("i&1", item.EvaluatedInclude);
-                Assert.True(
-                    string.Equals(item.ItemType, "i", StringComparison.OrdinalIgnoreCase)
-                    || string.Equals(item.ItemType, "l", StringComparison.OrdinalIgnoreCase));
+                item.EvaluatedInclude.ShouldBe("i&1");
+                (string.Equals(item.ItemType, "i", StringComparison.OrdinalIgnoreCase)
+                 || string.Equals(item.ItemType, "l", StringComparison.OrdinalIgnoreCase)).ShouldBeTrue();
             }
         }
 
@@ -1733,7 +1710,7 @@ public void ItemsByEvaluatedIncludeNone()
 
             List<ProjectItem> items = Helpers.MakeList(project.GetItemsByEvaluatedInclude("i2"));
 
-            Assert.Empty(items);
+            items.ShouldBeEmpty();
         }
 
         /// <summary>
@@ -1762,12 +1739,12 @@ public void ItemsByEvaluatedIncludeAndExpansion()
                 projectConstruction.AddItem("foo", Path.Combine(testFileRoot, "*.foo"));
 
                 count = Helpers.Count(projectConstruction.Items);
-                Assert.Equal(1, count); // "Construction Model"
+                count.ShouldBe(1); // "Construction Model"
 
                 Project project = new Project(projectConstruction);
 
                 count = Helpers.Count(project.GetItems("foo"));
-                Assert.Equal(2, count); // "Evaluation Model, Before Removal"
+                count.ShouldBe(2); // "Evaluation Model, Before Removal"
 
                 ProjectItem itemToRemove = null;
 
@@ -1780,15 +1757,15 @@ public void ItemsByEvaluatedIncludeAndExpansion()
 
                 project.RemoveItem(itemToRemove);
                 count = Helpers.Count(project.GetItems("foo"));
-                Assert.Equal(1, count); // "Evaluation Model, After Removal"
+                count.ShouldBe(1); // "Evaluation Model, After Removal"
 
                 ProjectInstance projectInstance = project.CreateProjectInstance();
                 count = Helpers.Count(projectInstance.Items);
-                Assert.Equal(1, count); // "Instance Model"
+                count.ShouldBe(1); // "Instance Model"
 
                 // Ensure XML has been updated accordingly on the Evaluation model (projectInstance doesn't back onto XML)
-                Assert.DoesNotContain(itemToRemove.Xml.Include, project.Xml.RawXml);
-                Assert.DoesNotContain("*.foo", project.Xml.RawXml);
+                project.Xml.RawXml.ShouldNotContain(itemToRemove.Xml.Include);
+                project.Xml.RawXml.ShouldNotContain("*.foo");
             }
             finally
             {
@@ -1812,13 +1789,13 @@ public void ItemsByEvaluatedIncludeReevaluation()
             project.ReevaluateIfNecessary();
 
             List<ProjectItem> items = Helpers.MakeList(project.GetItemsByEvaluatedInclude("i1"));
-            Assert.Single(items);
+            items.ShouldHaveSingleItem();
 
             project.Xml.AddItem("j", "i1");
             project.ReevaluateIfNecessary();
 
             items = Helpers.MakeList(project.GetItemsByEvaluatedInclude("i1"));
-            Assert.Equal(2, items.Count);
+            items.Count.ShouldBe(2);
         }
 
         /// <summary>
@@ -1832,7 +1809,7 @@ public void ItemsByEvaluatedIncludeDirectAdd()
             project.AddItem("i", "i1");
 
             List<ProjectItem> items = Helpers.MakeList(project.GetItemsByEvaluatedInclude("i1"));
-            Assert.Single(items);
+            items.ShouldHaveSingleItem();
         }
 
         /// <summary>
@@ -1847,7 +1824,7 @@ public void ItemsByEvaluatedIncludeDirectRemove()
             project.RemoveItem(item1);
 
             List<ProjectItem> items = Helpers.MakeList(project.GetItemsByEvaluatedInclude("i1"));
-            Assert.Empty(items);
+            items.ShouldBeEmpty();
         }
 
         /// <summary>
@@ -1873,8 +1850,8 @@ public void ChooseWhenTrue()
 
             Project project = new Project(XmlReader.Create(new StringReader(content)));
 
-            Assert.Equal("v1", project.GetPropertyValue("p"));
-            Assert.Equal("i1", Helpers.MakeList(project.GetItems("i"))[0].EvaluatedInclude);
+            project.GetPropertyValue("p").ShouldBe("v1");
+            Helpers.MakeList(project.GetItems("i"))[0].EvaluatedInclude.ShouldBe("i1");
         }
 
         /// <summary>
@@ -1908,8 +1885,8 @@ public void ChooseSecondWhenTrue()
 
             Project project = new Project(XmlReader.Create(new StringReader(content)));
 
-            Assert.Equal("v2", project.GetPropertyValue("p"));
-            Assert.Equal("i2", Helpers.MakeList(project.GetItems("i"))[0].EvaluatedInclude);
+            project.GetPropertyValue("p").ShouldBe("v2");
+            Helpers.MakeList(project.GetItems("i"))[0].EvaluatedInclude.ShouldBe("i2");
         }
 
         /// <summary>
@@ -1943,8 +1920,8 @@ public void ChooseOtherwise()
 
             Project project = new Project(XmlReader.Create(new StringReader(content)));
 
-            Assert.Equal("v2", project.GetPropertyValue("p"));
-            Assert.Equal("i2", Helpers.MakeList(project.GetItems("i"))[0].EvaluatedInclude);
+            project.GetPropertyValue("p").ShouldBe("v2");
+            Helpers.MakeList(project.GetItems("i"))[0].EvaluatedInclude.ShouldBe("i2");
         }
 
         /// <summary>
@@ -1991,12 +1968,12 @@ public void ChooseTwoPasses()
 
             Project project = new Project(XmlReader.Create(new StringReader(content)));
 
-            Assert.Equal("@(i);v1", project.GetPropertyValue("p"));
-            Assert.Equal("@(j);v1", project.GetPropertyValue("q"));
-            Assert.Equal("v1_v2", project.GetItems("i").ElementAt(0).EvaluatedInclude);
-            Assert.Single(project.GetItems("i"));
-            Assert.Equal("v1_v2", project.GetItems("j").ElementAt(0).EvaluatedInclude);
-            Assert.Single(project.GetItems("j"));
+            project.GetPropertyValue("p").ShouldBe("@(i);v1");
+            project.GetPropertyValue("q").ShouldBe("@(j);v1");
+            project.GetItems("i").ElementAt(0).EvaluatedInclude.ShouldBe("v1_v2");
+            project.GetItems("i").ShouldHaveSingleItem();
+            project.GetItems("j").ElementAt(0).EvaluatedInclude.ShouldBe("v1_v2");
+            project.GetItems("j").ShouldHaveSingleItem();
         }
 
         /// <summary>
@@ -2024,7 +2001,7 @@ public void ChooseEvaluateConditionOnlyOnce()
 
             Project project = new Project(XmlReader.Create(new StringReader(content)));
 
-            Assert.Empty(project.GetItems("i"));
+            project.GetItems("i").ShouldBeEmpty();
         }
 
         /// <summary>
@@ -2056,7 +2033,7 @@ public void ChooseSeesItemDefinitions()
 
             Project project = new Project(XmlReader.Create(new StringReader(content)));
 
-            Assert.Equal("m0;m1", project.GetItems("i").ElementAt(0).GetMetadataValue("m"));
+            project.GetItems("i").ElementAt(0).GetMetadataValue("m").ShouldBe("m0;m1");
         }
 
         /// <summary>
@@ -2073,9 +2050,9 @@ public void BuildDisabled()
 
             bool result = project.Build();
 
-            Assert.False(result);
+            result.ShouldBeFalse();
 
-            Assert.Equal("MSB4112", mockLogger.Errors[0].Code); //                 "Security message about disabled targets need to have code MSB4112, because code in the VS Core project system depends on this.  See DesignTimeBuildFeedback.cpp."
+            mockLogger.Errors[0].Code.ShouldBe("MSB4112"); //                 "Security message about disabled targets need to have code MSB4112, because code in the VS Core project system depends on this.  See DesignTimeBuildFeedback.cpp."
         }
 
         /// <summary>
@@ -2088,8 +2065,8 @@ public void BuildNonExistentTarget()
             Project project = new Project();
             MockLogger logger = new MockLogger();
             bool result = project.Build(new string[] { "nonexistent" }, new List<ILogger>() { logger });
-            Assert.False(result);
-            Assert.Equal(1, logger.ErrorCount);
+            result.ShouldBeFalse();
+            logger.ErrorCount.ShouldBe(1);
         }
 
         /// <summary>
@@ -2139,11 +2116,11 @@ public void BuildEvaluationUsesCustomLoggers()
                 project.ProjectCollection.UnregisterAllLoggers();
             }
 
-            Assert.True(result);
+            result.ShouldBeTrue();
 
-            Assert.Equal(0, mockLogger.WarningCount); //                 "Log should not contain MSB4011 because the build logger will not receive evaluation messages."
+            mockLogger.WarningCount.ShouldBe(0); //                 "Log should not contain MSB4011 because the build logger will not receive evaluation messages."
 
-            Assert.Equal("MSB4011", collectionLogger.Warnings[0].Code); //                 "Log should contain MSB4011 because the project collection logger should have been used for evaluation."
+            collectionLogger.Warnings[0].Code.ShouldBe("MSB4011"); //                 "Log should contain MSB4011 because the project collection logger should have been used for evaluation."
         }
 
         /// <summary>
@@ -2153,7 +2130,7 @@ public void BuildEvaluationUsesCustomLoggers()
         [Fact]
         public void UsingTaskExpansion1()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 ProjectRootElement xml = ProjectRootElement.Create();
                 xml.AddUsingTask("x", "@(x->'%(x)')", null);
@@ -2168,7 +2145,7 @@ public void UsingTaskExpansion1()
         [Fact]
         public void UsingTaskExpansion2()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 ProjectRootElement xml = ProjectRootElement.Create();
                 xml.AddUsingTask("@(x->'%(x)')", "y", null);
@@ -2183,7 +2160,7 @@ public void UsingTaskExpansion2()
         [Fact]
         public void UsingTaskExpansion3()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 ProjectRootElement xml = ProjectRootElement.Create();
                 xml.AddUsingTask("x", null, "@(x->'%(x)')");
@@ -2201,8 +2178,8 @@ public void SavingProjectClearsDirtyBit()
             string contents = ObjectModelHelpers.CleanupFileContents(@"<Project xmlns='msbuildnamespace'/>");
             Project project = new Project(XmlReader.Create(new StringReader(contents)));
 
-            Assert.True(project.Xml.HasUnsavedChanges); // Not dirty for saving
-            Assert.False(project.IsDirty); // "1" // was evaluated on load
+            project.Xml.HasUnsavedChanges.ShouldBeTrue(); // Not dirty for saving
+            project.IsDirty.ShouldBeFalse(); // "1" // was evaluated on load
 
             string file = null;
             try
@@ -2218,8 +2195,8 @@ public void SavingProjectClearsDirtyBit()
                 }
             }
 
-            Assert.False(project.Xml.HasUnsavedChanges); // Not dirty for saving
-            Assert.True(project.IsDirty); // "2" // Dirty for reevaluation, because the project now has gotten a new file name
+            project.Xml.HasUnsavedChanges.ShouldBeFalse(); // Not dirty for saving
+            project.IsDirty.ShouldBeTrue(); // "2" // Dirty for reevaluation, because the project now has gotten a new file name
         }
 
         /// <summary>
@@ -2240,7 +2217,7 @@ public void RemoveItemTwiceEvaluationProject()
             project.RemoveItem(itemToRemove);
             project.RemoveItem(itemToRemove); // should not throw
 
-            Assert.Empty(Helpers.MakeList(project.Items));
+            Helpers.MakeList(project.Items).ShouldBeEmpty();
         }
 
         /// <summary>
@@ -2261,7 +2238,7 @@ public void RemoveItemOutdatedByUpdate()
             itemToRemove.UnevaluatedInclude = "b.cs";
             project.RemoveItem(itemToRemove); // should not throw
 
-            Assert.Empty(Helpers.MakeList(project.Items));
+            Helpers.MakeList(project.Items).ShouldBeEmpty();
         }
 
         /// <summary>
@@ -2282,7 +2259,7 @@ public void RemoveSeveralItems()
 
             project.RemoveItems(project.GetItems("i"));
 
-            Assert.Empty(project.Items);
+            project.Items.ShouldBeEmpty();
         }
 
         /// <summary>
@@ -2307,7 +2284,7 @@ public void RemoveSeveralItemsOfVariousTypes()
 
             project.RemoveItems(list);
 
-            Assert.Equal(2, project.Items.Count());
+            project.Items.Count().ShouldBe(2);
         }
 
         /// <summary>
@@ -2327,7 +2304,7 @@ public void RemoveSeveralItemsExpandExpression()
             Project project = new Project(XmlReader.Create(new StringReader(projectOriginalContents)));
 
             project.RemoveItems(project.GetItems("j").Take(2));
-            Assert.Equal(3, project.Items.Count());
+            project.Items.Count().ShouldBe(3);
 
             StringWriter writer = new EncodingStringWriter();
             project.Save(writer);
@@ -2362,7 +2339,7 @@ public void RemoveSeveralItemsFirstZombiesSecond()
 
             project.RemoveItems(project.GetItems("i"));
 
-            Assert.Empty(project.Items);
+            project.Items.ShouldBeEmpty();
         }
 
         /// <summary>
@@ -2371,7 +2348,7 @@ public void RemoveSeveralItemsFirstZombiesSecond()
         [Fact]
         public void RemoveItemsOneNull()
         {
-            Assert.Throws<ArgumentNullException>(() =>
+            Should.Throw<ArgumentNullException>(() =>
             {
                 Project project = new Project();
                 project.RemoveItems(new List<ProjectItem>() { null });
@@ -2385,7 +2362,7 @@ public void RemoveItemsOneNull()
         [Fact]
         public void RemoveItemWrongProject()
         {
-            Assert.Throws<ArgumentException>(() =>
+            Should.Throw<ArgumentException>(() =>
             {
                 ProjectRootElement root1 = ProjectRootElement.Create();
                 root1.AddItem("i", "i1");
@@ -2418,7 +2395,7 @@ public void RemoveZombiedItem()
             project.RemoveItems(new List<ProjectItem>() { item });
             project.RemoveItems(new List<ProjectItem>() { item });
 
-            Assert.Empty(project.Items);
+            project.Items.ShouldBeEmpty();
         }
 
         /// <summary>
@@ -2427,7 +2404,7 @@ public void RemoveZombiedItem()
         [Fact]
         public void ReservedPropertyProjectConstructor()
         {
-            Assert.Throws<ArgumentException>(() =>
+            Should.Throw<ArgumentException>(() =>
             {
                 Dictionary<string, string> globalProperties = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 globalProperties.Add("msbuildprojectdirectory", "x");
@@ -2442,7 +2419,7 @@ public void ReservedPropertyProjectConstructor()
         [Fact]
         public void ReservedPropertyProjectCollectionConstructor()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 Dictionary<string, string> globalProperties = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 globalProperties.Add("msbuildprojectdirectory", "x");
@@ -2467,7 +2444,7 @@ public void ReservedPropertyProjectCollectionConstructor()
         [Fact]
         public void ReservedPropertyProjectCollectionConstructor2()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 Dictionary<string, string> globalProperties = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 globalProperties.Add("Target", "x");
@@ -2523,8 +2500,8 @@ public void RelativePathsInItemsInTargetsFilesAreRelativeToProjectFile()
                 Project project = new Project(projectPath);
 
                 IEnumerable<ProjectItem> items = project.GetItems("i");
-                Assert.Equal(unevaluatedInclude, Helpers.GetFirst(items).UnevaluatedInclude);
-                Assert.Equal(evaluatedInclude, Helpers.GetFirst(items).EvaluatedInclude);
+                Helpers.GetFirst(items).UnevaluatedInclude.ShouldBe(unevaluatedInclude);
+                Helpers.GetFirst(items).EvaluatedInclude.ShouldBe(evaluatedInclude);
             }
             finally
             {
@@ -2538,7 +2515,7 @@ public void RelativePathsInItemsInTargetsFilesAreRelativeToProjectFile()
         [Fact]
         public void ReservedPropertyProjectCollectionConstructor3()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 Dictionary<string, string> globalProperties = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 globalProperties.Add("Target", "x");
@@ -2588,15 +2565,15 @@ public void VariousImports()
 
             List<ProjectElement> logicalProject = new List<ProjectElement>(project.GetLogicalProject());
 
-            Assert.Equal(8, logicalProject.Count); // 4 properties + 4 property groups
-            Assert.True(object.ReferenceEquals(zero, logicalProject[0].ContainingProject));
-            Assert.True(object.ReferenceEquals(zero, logicalProject[1].ContainingProject));
-            Assert.True(object.ReferenceEquals(one, logicalProject[2].ContainingProject));
-            Assert.True(object.ReferenceEquals(one, logicalProject[3].ContainingProject));
-            Assert.True(object.ReferenceEquals(three, logicalProject[4].ContainingProject));
-            Assert.True(object.ReferenceEquals(three, logicalProject[5].ContainingProject));
-            Assert.True(object.ReferenceEquals(two, logicalProject[6].ContainingProject));
-            Assert.True(object.ReferenceEquals(two, logicalProject[7].ContainingProject));
+            logicalProject.Count.ShouldBe(8); // 4 properties + 4 property groups
+            object.ReferenceEquals(zero, logicalProject[0].ContainingProject).ShouldBeTrue();
+            object.ReferenceEquals(zero, logicalProject[1].ContainingProject).ShouldBeTrue();
+            object.ReferenceEquals(one, logicalProject[2].ContainingProject).ShouldBeTrue();
+            object.ReferenceEquals(one, logicalProject[3].ContainingProject).ShouldBeTrue();
+            object.ReferenceEquals(three, logicalProject[4].ContainingProject).ShouldBeTrue();
+            object.ReferenceEquals(three, logicalProject[5].ContainingProject).ShouldBeTrue();
+            object.ReferenceEquals(two, logicalProject[6].ContainingProject).ShouldBeTrue();
+            object.ReferenceEquals(two, logicalProject[7].ContainingProject).ShouldBeTrue();
 
             // Clear the cache
             project.ProjectCollection.UnloadAllProjects();
@@ -2634,13 +2611,13 @@ public void LogicalProjectWithWildcardImport()
 
                 List<ProjectElement> logicalProject = new List<ProjectElement>(project.GetLogicalProject());
 
-                Assert.Equal(6, logicalProject.Count); // 3 properties + 3 property groups
-                Assert.True(object.ReferenceEquals(zero, logicalProject[0].ContainingProject)); // PropertyGroup
-                Assert.True(object.ReferenceEquals(zero, logicalProject[1].ContainingProject)); // p = 0
-                Assert.True(object.ReferenceEquals(one, logicalProject[2].ContainingProject));  // PropertyGroup
-                Assert.True(object.ReferenceEquals(one, logicalProject[3].ContainingProject));  // p = 1
-                Assert.True(object.ReferenceEquals(two, logicalProject[4].ContainingProject));  // PropertyGroup
-                Assert.True(object.ReferenceEquals(two, logicalProject[5].ContainingProject));  // p = 2
+                logicalProject.Count.ShouldBe(6); // 3 properties + 3 property groups
+                object.ReferenceEquals(zero, logicalProject[0].ContainingProject).ShouldBeTrue(); // PropertyGroup
+                object.ReferenceEquals(zero, logicalProject[1].ContainingProject).ShouldBeTrue(); // p = 0
+                object.ReferenceEquals(one, logicalProject[2].ContainingProject).ShouldBeTrue();  // PropertyGroup
+                object.ReferenceEquals(one, logicalProject[3].ContainingProject).ShouldBeTrue();  // p = 1
+                object.ReferenceEquals(two, logicalProject[4].ContainingProject).ShouldBeTrue();  // PropertyGroup
+                object.ReferenceEquals(two, logicalProject[5].ContainingProject).ShouldBeTrue();  // p = 2
 
                 // Clear the cache
                 project.ProjectCollection.UnloadAllProjects();
@@ -2661,7 +2638,7 @@ public void LogicalProjectWithWildcardImport()
         [Fact]
         public void ImportPropertyEvaluatingToEmpty()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 string projectOriginalContents = ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='msbuildnamespace'>
@@ -2707,7 +2684,7 @@ public void GetItemProvenanceShouldReturnNothingWhenCalledWithEmptyOrNullArgs()
         [Fact]
         public void ImportPropertyEvaluatingToInvalidPath()
         {
-            Assert.Throws<InvalidProjectFileException>(() =>
+            Should.Throw<InvalidProjectFileException>(() =>
             {
                 string projectOriginalContents = ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='msbuildnamespace'>
@@ -3760,12 +3737,12 @@ public void GetAllGlobsShouldProduceGlobThatMatches(string itemContents, string[
 
             foreach (var matchingString in stringsThatShouldMatch)
             {
-                Assert.True(uberGlob.IsMatch(matchingString));
+                uberGlob.IsMatch(matchingString).ShouldBeTrue();
             }
 
             foreach (var nonMatchingString in stringsThatShouldNotMatch)
             {
-                Assert.False(uberGlob.IsMatch(nonMatchingString));
+                uberGlob.IsMatch(nonMatchingString).ShouldBeFalse();
             }
         }
 
@@ -3886,18 +3863,18 @@ public void ProjectInstanceShouldInitiallyHaveSameEvaluationIdAsTheProjectItCame
 
                 var projectInstance = project.CreateProjectInstance();
 
-                Assert.NotEqual(BuildEventContext.InvalidEvaluationId, initialEvaluationId);
-                Assert.Equal(initialEvaluationId, projectInstance.EvaluationId);
+                initialEvaluationId.ShouldNotBe(BuildEventContext.InvalidEvaluationId);
+                projectInstance.EvaluationId.ShouldBe(initialEvaluationId);
 
                 // trigger a new evaluation which increments the evaluation ID in the Project
                 project.AddItem("foo", "bar");
                 project.ReevaluateIfNecessary();
 
-                Assert.NotEqual(initialEvaluationId, project.LastEvaluationId);
-                Assert.Equal(initialEvaluationId, projectInstance.EvaluationId);
+                project.LastEvaluationId.ShouldNotBe(initialEvaluationId);
+                projectInstance.EvaluationId.ShouldBe(initialEvaluationId);
 
                 var newProjectInstance = project.CreateProjectInstance();
-                Assert.Equal(project.LastEvaluationId, newProjectInstance.EvaluationId);
+                newProjectInstance.EvaluationId.ShouldBe(project.LastEvaluationId);
             }
         }
 
@@ -3930,16 +3907,16 @@ public void ProjectImportedEventFalseCondition()
 
                     ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
 
-                    Assert.NotNull(eventArgs);
+                    eventArgs.ShouldNotBeNull();
 
-                    Assert.Equal(import.Project, eventArgs.UnexpandedProject);
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
 
-                    Assert.Null(eventArgs.ImportedProjectFile);
+                    eventArgs.ImportedProjectFile.ShouldBeNull();
 
-                    Assert.Equal(pre.FullPath, eventArgs.ProjectFile);
+                    eventArgs.ProjectFile.ShouldBe(pre.FullPath);
 
-                    Assert.Equal(6, eventArgs.LineNumber);
-                    Assert.Equal(3, eventArgs.ColumnNumber);
+                    eventArgs.LineNumber.ShouldBe(6);
+                    eventArgs.ColumnNumber.ShouldBe(3);
 
                     logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to false condition; ( \'$(Something)\' == \'nothing\' ) was evaluated as ( \'\' == \'nothing\' )."); 
                 }
@@ -3973,16 +3950,16 @@ public void ProjectImportedEventNoMatchingFiles()
 
                     ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
 
-                    Assert.NotNull(eventArgs);
+                    eventArgs.ShouldNotBeNull();
 
-                    Assert.Equal(import.Project, eventArgs.UnexpandedProject);
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
 
-                    Assert.Null(eventArgs.ImportedProjectFile);
+                    eventArgs.ImportedProjectFile.ShouldBeNull();
 
-                    Assert.Equal(pre.FullPath, eventArgs.ProjectFile);
+                    eventArgs.ProjectFile.ShouldBe(pre.FullPath);
 
-                    Assert.Equal(6, eventArgs.LineNumber);
-                    Assert.Equal(3, eventArgs.ColumnNumber);
+                    eventArgs.LineNumber.ShouldBe(6);
+                    eventArgs.ColumnNumber.ShouldBe(3);
 
                     logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to no matching files.");
                 }
@@ -4017,17 +3994,17 @@ public void ProjectImportedEventEmptyFile()
 
                     ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
 
-                    Assert.NotNull(eventArgs);
-                    Assert.True(eventArgs.ImportIgnored);
+                    eventArgs.ShouldNotBeNull();
+                    eventArgs.ImportIgnored.ShouldBeTrue();
 
-                    Assert.Equal(import.Project, eventArgs.UnexpandedProject);
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
 
-                    Assert.Equal(importFile.Path, eventArgs.ImportedProjectFile);
+                    eventArgs.ImportedProjectFile.ShouldBe(importFile.Path);
 
-                    Assert.Equal(pre.FullPath, eventArgs.ProjectFile);
+                    eventArgs.ProjectFile.ShouldBe(pre.FullPath);
 
-                    Assert.Equal(6, eventArgs.LineNumber);
-                    Assert.Equal(3, eventArgs.ColumnNumber);
+                    eventArgs.LineNumber.ShouldBe(6);
+                    eventArgs.ColumnNumber.ShouldBe(3);
 
                     logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to the file being empty.");
                 }
@@ -4064,23 +4041,63 @@ public void ProjectImportedEventInvalidFile()
 
                     ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
 
-                    Assert.NotNull(eventArgs);
-                    Assert.True(eventArgs.ImportIgnored);
+                    eventArgs.ShouldNotBeNull();
+                    eventArgs.ImportIgnored.ShouldBeTrue();
 
-                    Assert.Equal(import.Project, eventArgs.UnexpandedProject);
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
 
-                    Assert.Equal(importFile.Path, eventArgs.ImportedProjectFile);
+                    eventArgs.ImportedProjectFile.ShouldBe(importFile.Path);
 
-                    Assert.Equal(pre.FullPath, eventArgs.ProjectFile);
+                    eventArgs.ProjectFile.ShouldBe(pre.FullPath);
 
-                    Assert.Equal(6, eventArgs.LineNumber);
-                    Assert.Equal(3, eventArgs.ColumnNumber);
+                    eventArgs.LineNumber.ShouldBe(6);
+                    eventArgs.ColumnNumber.ShouldBe(3);
 
                     logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to the file being invalid.");
                 }
             }
         }
 
+        [Fact]
+        public void ProjectImportedEventInvalidFileWhenExpressionEvaluatesToEmpty()
+        {
+            using (var env = TestEnvironment.Create(_output))
+            {
+                env.SetEnvironmentVariable("MSBUILDLOGIMPORTS", "1");
+
+                ProjectRootElement pre = ProjectRootElement.Create(env.CreateFile(".proj").Path);
+
+                var import = pre.AddImport("$(SomethingThatEvaluatesToEmpty)");
+
+                pre.Save();
+                pre.Reload();
+
+                using (ProjectCollection collection = new ProjectCollection())
+                {
+                    MockLogger logger = new MockLogger();
+                    collection.RegisterLogger(logger);
+
+                    Project unused = new Project(pre, null, null, collection, ProjectLoadSettings.IgnoreInvalidImports);
+
+                    ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
+
+                    eventArgs.ShouldNotBeNull();
+                    eventArgs.ImportIgnored.ShouldBeTrue();
+
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
+
+                    eventArgs.ImportedProjectFile.ShouldBe(string.Empty);
+
+                    eventArgs.ProjectFile.ShouldBe(pre.FullPath);
+
+                    eventArgs.LineNumber.ShouldBe(3);
+                    eventArgs.ColumnNumber.ShouldBe(3);
+
+                    logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to the expression evaluating to an empty string.");
+                }
+            }
+        }
+
         [Fact]
         public void ProjectImportedEventMissingFile()
         {
@@ -4107,17 +4124,17 @@ public void ProjectImportedEventMissingFile()
 
                     ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
 
-                    Assert.NotNull(eventArgs);
-                    Assert.True(eventArgs.ImportIgnored);
+                    eventArgs.ShouldNotBeNull();
+                    eventArgs.ImportIgnored.ShouldBeTrue();
 
-                    Assert.Equal(import.Project, eventArgs.UnexpandedProject);
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
 
-                    Assert.Equal(importPath, eventArgs.ImportedProjectFile);
+                    eventArgs.ImportedProjectFile.ShouldBe(importPath);
 
-                    Assert.Equal(pre.FullPath, eventArgs.ProjectFile);
+                    eventArgs.ProjectFile.ShouldBe(pre.FullPath);
 
-                    Assert.Equal(6, eventArgs.LineNumber);
-                    Assert.Equal(3, eventArgs.ColumnNumber);
+                    eventArgs.LineNumber.ShouldBe(6);
+                    eventArgs.ColumnNumber.ShouldBe(3);
 
                     logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to the file not existing.");
                 }
@@ -4150,17 +4167,17 @@ public void ProjectImportedEventMissingFileNoGlobMatch()
 
                     ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
 
-                    Assert.NotNull(eventArgs);
-                    Assert.False(eventArgs.ImportIgnored);
+                    eventArgs.ShouldNotBeNull();
+                    eventArgs.ImportIgnored.ShouldBeFalse();
 
-                    Assert.Equal(import.Project, eventArgs.UnexpandedProject);
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
 
-                    Assert.Null(eventArgs.ImportedProjectFile);
+                    eventArgs.ImportedProjectFile.ShouldBeNull();
 
-                    Assert.Equal(pre.FullPath, eventArgs.ProjectFile);
+                    eventArgs.ProjectFile.ShouldBe(pre.FullPath);
 
-                    Assert.Equal(6, eventArgs.LineNumber);
-                    Assert.Equal(3, eventArgs.ColumnNumber);
+                    eventArgs.LineNumber.ShouldBe(6);
+                    eventArgs.ColumnNumber.ShouldBe(3);
 
                     logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to no matching files.");
                 }
@@ -4198,17 +4215,17 @@ public void ProjectImportEvent()
 
                     ProjectImportedEventArgs eventArgs = logger.AllBuildEvents.SingleOrDefault(i => i is ProjectImportedEventArgs) as ProjectImportedEventArgs;
 
-                    Assert.NotNull(eventArgs);
+                    eventArgs.ShouldNotBeNull();
 
-                    Assert.Equal(import.Project, eventArgs.UnexpandedProject);
+                    eventArgs.UnexpandedProject.ShouldBe(import.Project);
 
-                    Assert.Equal(pre1.FullPath, eventArgs.ImportedProjectFile);
+                    eventArgs.ImportedProjectFile.ShouldBe(pre1.FullPath);
 
-                    Assert.Equal(pre2.FullPath, eventArgs.ProjectFile);
+                    eventArgs.ProjectFile.ShouldBe(pre2.FullPath);
 
-                    Assert.False(eventArgs.ImportIgnored);
-                    Assert.Equal(6, eventArgs.LineNumber);
-                    Assert.Equal(3, eventArgs.ColumnNumber);
+                    eventArgs.ImportIgnored.ShouldBeFalse();
+                    eventArgs.LineNumber.ShouldBe(6);
+                    eventArgs.ColumnNumber.ShouldBe(3);
 
                     logger.AssertLogContains($"Importing project \"{pre1.FullPath}\" into project \"{pre2.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}).");
                 }
@@ -4244,14 +4261,14 @@ private static void AssertGlobResult(GlobResultList expected, string project, st
 
         private static void AssertGlobResultsEqual(GlobResultList expected, List<GlobResult> globs)
         {
-            Assert.Equal(expected.Count, globs.Count);
+            globs.Count.ShouldBe(expected.Count);
 
             for (var i = 0; i < expected.Count; i++)
             {
-                Assert.Equal(expected[i].Item1, globs[i].ItemElement.ItemType);
-                Assert.Equal(expected[i].Item2, globs[i].IncludeGlobs);
-                Assert.Equal(expected[i].Item3, globs[i].Excludes);
-                Assert.Equal(expected[i].Item4, globs[i].Removes);
+                globs[i].ItemElement.ItemType.ShouldBe(expected[i].Item1);
+                globs[i].IncludeGlobs.ShouldBe(expected[i].Item2);
+                globs[i].Excludes.ShouldBe(expected[i].Item3);
+                globs[i].Removes.ShouldBe(expected[i].Item4);
             }
         }
 
@@ -4291,17 +4308,17 @@ private static void GetProjectAndItemAtPosition(string project, string itemValue
 
         private static void AssertProvenanceResult(ProvenanceResultTupleList expected, List<ProvenanceResult> actual)
         {
-            Assert.Equal(expected.Count, actual.Count);
+            actual.Count.ShouldBe(expected.Count);
 
             for (var i = 0; i < expected.Count; i++)
             {
                 var expectedProvenance = expected[i];
                 var actualProvenance = actual[i];
 
-                Assert.Equal(expectedProvenance.Item1, actualProvenance.ItemElement.ItemType);
-                Assert.Equal(expectedProvenance.Item2, actualProvenance.Operation);
-                Assert.Equal(expectedProvenance.Item3, actualProvenance.Provenance);
-                Assert.Equal(expectedProvenance.Item4, actualProvenance.Occurrences);
+                actualProvenance.ItemElement.ItemType.ShouldBe(expectedProvenance.Item1);
+                actualProvenance.Operation.ShouldBe(expectedProvenance.Item2);
+                actualProvenance.Provenance.ShouldBe(expectedProvenance.Item3);
+                actualProvenance.Occurrences.ShouldBe(expectedProvenance.Item4);
             }
         }
 
@@ -4353,16 +4370,16 @@ private string GetSampleProjectContent()
         /// </summary>
         private void VerifyContentOfSampleProject(Project project)
         {
-            Assert.Equal("v2", project.GetProperty("p").UnevaluatedValue);
-            Assert.Equal("Xv2", project.GetProperty("p2").EvaluatedValue);
-            Assert.Equal("X$(p)", project.GetProperty("p2").UnevaluatedValue);
+            project.GetProperty("p").UnevaluatedValue.ShouldBe("v2");
+            project.GetProperty("p2").EvaluatedValue.ShouldBe("Xv2");
+            project.GetProperty("p2").UnevaluatedValue.ShouldBe("X$(p)");
 
             IList<ProjectItem> items = Helpers.MakeList(project.GetItems("i"));
-            Assert.Equal(3, items.Count);
-            Assert.Equal("i1", items[0].EvaluatedInclude);
-            Assert.Equal("v2X", items[1].EvaluatedInclude);
-            Assert.Equal("$(p)X;i3", items[1].UnevaluatedInclude);
-            Assert.Equal("i3", items[2].EvaluatedInclude);
+            items.Count.ShouldBe(3);
+            items[0].EvaluatedInclude.ShouldBe("i1");
+            items[1].EvaluatedInclude.ShouldBe("v2X");
+            items[1].UnevaluatedInclude.ShouldBe("$(p)X;i3");
+            items[2].EvaluatedInclude.ShouldBe("i3");
         }
     }
 }
diff --git a/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs
index d032033dd27..dc1e3cfdc23 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs
@@ -449,6 +449,48 @@ public void CreateProjectInstanceWithItemsContainingProjects()
             Assert.Equal(projAInstanceItem.MetadataCount, projAInstanceItem.MetadataNames.Count);
         }
 
+        /// <summary>
+        /// Constructs a new ProjectInstances from Project.
+        /// </summary>
+        [Fact]
+        public void CreateProjectInstanceFromProject()
+        {
+            const string CapturedMetadataName = "DefiningProjectFullPath";
+            var pc = new ProjectCollection();
+            var projA = ProjectRootElement.Create(pc);
+            var projB = ProjectRootElement.Create(pc);
+            projA.FullPath = Path.Combine(Path.GetTempPath(), "a.proj");
+            projB.FullPath = Path.Combine(Path.GetTempPath(), "b.proj");
+            projB.AddImport("a.proj");
+            projA.AddItem("Compile", "aItem.cs");
+            projB.AddItem("Compile", "bItem.cs");
+
+            var loadSettings = ProjectLoadSettings.RecordDuplicateButNotCircularImports
+                | ProjectLoadSettings.RejectCircularImports
+                | ProjectLoadSettings.IgnoreEmptyImports
+                | ProjectLoadSettings.IgnoreMissingImports
+                | ProjectLoadSettings.IgnoreInvalidImports;
+
+            var projBEval = new Project(projB, null, null, pc, loadSettings);
+            var projBInstance = new ProjectInstance(projBEval, ProjectInstanceSettings.ImmutableWithFastItemLookup);
+            var projBInstanceItem = projBInstance.GetItemsByItemTypeAndEvaluatedInclude("Compile", "bItem.cs").Single();
+            var projAInstanceItem = projBInstance.GetItemsByItemTypeAndEvaluatedInclude("Compile", "aItem.cs").Single();
+            Assert.Equal(projB.FullPath, projBInstanceItem.GetMetadataValue(CapturedMetadataName));
+            Assert.Equal(projA.FullPath, projAInstanceItem.GetMetadataValue(CapturedMetadataName));
+
+            // Although GetMetadataValue returns non-null, GetMetadata returns null...
+            Assert.Null(projAInstanceItem.GetMetadata(CapturedMetadataName));
+
+            // .. Just like built-in metadata does: (this segment just demonstrates similar functionality -- it's not meant to test built-in metadata)
+            Assert.NotNull(projAInstanceItem.GetMetadataValue("Identity"));
+            Assert.Null(projAInstanceItem.GetMetadata("Identity"));
+
+            Assert.True(projAInstanceItem.HasMetadata(CapturedMetadataName));
+            Assert.False(projAInstanceItem.Metadata.Any());
+            Assert.Contains(CapturedMetadataName, projAInstanceItem.MetadataNames);
+            Assert.Equal(projAInstanceItem.MetadataCount, projAInstanceItem.MetadataNames.Count);
+        }
+
         /// <summary>
         /// Verifies that the built-in metadata for specialized ProjectInstances is present when items are based on wildcards in the construction model.
         /// </summary>
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
index 253ceac7972..324dcb6eb3f 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/EvaluationLinkMocks/MockProjectLink.cs
@@ -187,7 +187,6 @@ public override bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnum
 
         public override string ExpandString(string unexpandedValue) => this.Proxy.ExpandString(unexpandedValue);
 
-// TODO: Glob is not needed for the CSproj, but we might want to test it at least 
         public override List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext)
         {
             throw new NotImplementedException();
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
index 185e828aae6..bd2e1172fe5 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
@@ -74,6 +74,8 @@ public MockRequestBuilder()
 
             public event BuildRequestBlockedDelegate OnBuildRequestBlocked;
 
+            public event ResourceRequestDelegate OnResourceRequest;
+
             public void BuildRequest(NodeLoggingContext context, BuildRequestEntry entry)
             {
                 Assert.Null(_builderThread); // "Received BuildRequest while one was in progress"
@@ -171,6 +173,11 @@ public void RaiseRequestBlocked(BuildRequestEntry entry, int blockingId, string
                 OnBuildRequestBlocked?.Invoke(entry, blockingId, blockingTarget, null);
             }
 
+            public void RaiseResourceRequest(ResourceRequest request)
+            {
+                OnResourceRequest?.Invoke(request);
+            }
+
             public void ContinueRequest()
             {
                 if (ThrowExceptionOnContinue)
@@ -180,6 +187,10 @@ public void ContinueRequest()
                 _continueEvent.Set();
             }
 
+            public void ContinueRequestWithResources(ResourceResponse response)
+            {
+            }
+
             public void CancelRequest()
             {
                 this.BeginCancel();
@@ -256,6 +267,9 @@ private ProjectInstance CreateStandinProject()
         private AutoResetEvent _engineExceptionEvent;
         private Exception _engineException_Exception;
 
+        private AutoResetEvent _engineResourceRequestEvent;
+        private ResourceRequest _engineResourceRequest_Request;
+
         private IBuildRequestEngine _engine;
         private IConfigCache _cache;
         private int _nodeRequestId;
@@ -272,6 +286,7 @@ public BuildRequestEngine_Tests()
             _newRequestEvent = new AutoResetEvent(false);
             _newConfigurationEvent = new AutoResetEvent(false);
             _engineExceptionEvent = new AutoResetEvent(false);
+            _engineResourceRequestEvent = new AutoResetEvent(false);
 
             _engine = (IBuildRequestEngine)_host.GetComponent(BuildComponentType.RequestEngine);
             _cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
@@ -293,6 +308,7 @@ public void Dispose()
             _newRequestEvent.Dispose();
             _newConfigurationEvent.Dispose();
             _engineExceptionEvent.Dispose();
+            _engineResourceRequestEvent.Dispose();
 
             _host = null;
         }
@@ -305,6 +321,7 @@ private void ConfigureEngine(IBuildRequestEngine engine)
             engine.OnRequestResumed += this.Engine_RequestResumed;
             engine.OnStatusChanged += this.Engine_EngineStatusChanged;
             engine.OnEngineException += this.Engine_Exception;
+            engine.OnResourceRequest += this.Engine_ResourceRequest;
         }
 
         /// <summary>
@@ -579,5 +596,15 @@ private void Engine_Exception(Exception e)
             _engineException_Exception = e;
             _engineExceptionEvent.Set();
         }
+
+        /// <summary>
+        /// Callback for event raised when resources are requested.
+        /// </summary>
+        /// <param name="request">The resource request</param>
+        private void Engine_ResourceRequest(ResourceRequest request)
+        {
+            _engineResourceRequest_Request = request;
+            _engineResourceRequestEvent.Set();
+        }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/CustomLogAndReturnTask.cs b/src/Build.UnitTests/BackEnd/CustomLogAndReturnTask.cs
new file mode 100644
index 00000000000..e6f05dff154
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/CustomLogAndReturnTask.cs
@@ -0,0 +1,39 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+namespace Microsoft.Build.UnitTests
+{
+    public class CustomLogAndReturnTask : Task
+    {
+        public string WarningCode { get; set; }
+
+        public string ErrorCode { get; set; }
+
+        public bool ReturnHasLoggedErrors { get; set; }
+
+        [Required]
+        public bool Return { get; set; }
+
+        // Unused for now, created for task batching.
+        public ITaskItem[] Sources { get; set; }
+
+        /// <summary>
+        /// This task returns and logs what you want based on the running test.
+        /// </summary>
+        public override bool Execute()
+        {
+            if(!string.IsNullOrEmpty(WarningCode))
+            {
+                Log.LogWarning(null, WarningCode, null, null, 0, 0, 0, 0, "Warning Logged!", null);
+            }
+
+            if(!string.IsNullOrEmpty(ErrorCode))
+            {
+                Log.LogError(null, ErrorCode, null, null, 0, 0, 0, 0, "Error Logged!", null);
+            }
+            return ReturnHasLoggedErrors ? !Log.HasLoggedErrors : Return;
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs b/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
index 3798326b7e2..8dc2e82dbdd 100644
--- a/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
@@ -68,6 +68,7 @@ public void ConsumeEventsGoodEventsNoHandlers()
             eventHelper.RaiseBuildEvent(RaiseEventHelper.NormalMessage);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.TaskFinished);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.CommandLine);
+            eventHelper.RaiseBuildEvent(RaiseEventHelper.TaskParameter);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.Warning);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.Error);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.TargetStarted);
@@ -99,6 +100,7 @@ public void LoggerExceptionInEventHandler()
                 RaiseExceptionInEventHandler(RaiseEventHelper.NormalMessage, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.TaskFinished, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.CommandLine, exception);
+                RaiseExceptionInEventHandler(RaiseEventHelper.TaskParameter, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.Warning, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.Error, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.TargetStarted, exception);
@@ -733,6 +735,11 @@ internal class RaiseEventHelper
             /// </summary>
             private static TaskCommandLineEventArgs s_taskCommandLine = new TaskCommandLineEventArgs("commandLine", "taskName", MessageImportance.Low);
 
+            /// <summary>
+            /// Task Parameter Event
+            /// </summary>
+            private static TaskParameterEventArgs s_taskParameter = new TaskParameterEventArgs(TaskParameterMessageKind.TaskInput, "ItemName", null, true, DateTime.MinValue);
+
             /// <summary>
             /// Build Warning Event
             /// </summary>
@@ -883,6 +890,11 @@ internal static TaskCommandLineEventArgs CommandLine
                 }
             }
 
+            /// <summary>
+            /// Event which can be raised in multiple tests.
+            /// </summary>
+            internal static TaskParameterEventArgs TaskParameter => s_taskParameter;
+
             /// <summary>
             /// Event which can be raised in multiple tests.
             /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index 8c7c480a220..4b1857121e1 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
@@ -203,6 +204,16 @@ public bool IncludeEvaluationProfile
             set { }
         }
 
+        /// <summary>
+        /// Log properties and items on ProjectEvaluationFinishedEventArgs
+        /// instead of ProjectStartedEventArgs.
+        /// </summary>
+        public bool IncludeEvaluationPropertiesAndItems
+        {
+            get => false;
+            set { }
+        }
+
         /// <summary>
         /// Should task events include task inputs?
         /// </summary>
@@ -459,7 +470,13 @@ public void LogProjectEvaluationStarted(BuildEventContext eventContext, string p
         /// <summary>
         /// Logs a project evaluation finished event
         /// </summary>
-        public void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEventContext, string projectFile)
+        public void LogProjectEvaluationFinished(
+            BuildEventContext projectEvaluationEventContext,
+            string projectFile,
+            IEnumerable globalProperties,
+            IEnumerable properties,
+            IEnumerable items,
+            ProfilerResult? profilerResult)
         {
         }
 
@@ -557,6 +574,16 @@ public bool HasBuildSubmissionLoggedErrors(int submissionId)
             return false;
         }
 
+        public ICollection<string> GetWarningsAsErrors(BuildEventContext context)
+        {
+            throw new NotImplementedException();
+        }
+
+        public ICollection<string> GetWarningsAsMessages(BuildEventContext context)
+        {
+            throw new NotImplementedException();
+        }
+
         #endregion
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 459d835bd25..a3137f5b399 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -2,6 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
+using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
@@ -31,6 +33,7 @@ public void LogMessageConstructorNullBuildEvent()
             }
            );
         }
+
         /// <summary>
         /// Verify when creating a LogMessagePacket
         /// that the correct Event Type is set.
@@ -44,6 +47,7 @@ public void VerifyEventType()
             TaskStartedEventArgs taskStarted = new TaskStartedEventArgs("message", "help", "projectFile", "taskFile", "taskName");
             TaskFinishedEventArgs taskFinished = new TaskFinishedEventArgs("message", "help", "projectFile", "taskFile", "taskName", true);
             TaskCommandLineEventArgs commandLine = new TaskCommandLineEventArgs("commandLine", "taskName", MessageImportance.Low);
+            TaskParameterEventArgs taskParameter = CreateTaskParameter();
             BuildWarningEventArgs warning = new BuildWarningEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
             BuildErrorEventArgs error = new BuildErrorEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
             TargetStartedEventArgs targetStarted = new TargetStartedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile");
@@ -51,6 +55,8 @@ public void VerifyEventType()
             ProjectStartedEventArgs projectStarted = new ProjectStartedEventArgs(-1, "message", "help", "ProjectFile", "targetNames", null, null, null);
             ProjectFinishedEventArgs projectFinished = new ProjectFinishedEventArgs("message", "help", "ProjectFile", true);
             ExternalProjectStartedEventArgs externalStartedEvent = new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames");
+            ProjectEvaluationStartedEventArgs evaluationStarted = new ProjectEvaluationStartedEventArgs();
+            ProjectEvaluationFinishedEventArgs evaluationFinished = new ProjectEvaluationFinishedEventArgs();
 
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
             VerifyLoggingPacket(buildStarted, LoggingEventType.BuildStartedEvent);
@@ -58,21 +64,125 @@ public void VerifyEventType()
             VerifyLoggingPacket(taskStarted, LoggingEventType.TaskStartedEvent);
             VerifyLoggingPacket(taskFinished, LoggingEventType.TaskFinishedEvent);
             VerifyLoggingPacket(commandLine, LoggingEventType.TaskCommandLineEvent);
+            VerifyLoggingPacket(taskParameter, LoggingEventType.TaskParameterEvent);
             VerifyLoggingPacket(warning, LoggingEventType.BuildWarningEvent);
             VerifyLoggingPacket(error, LoggingEventType.BuildErrorEvent);
             VerifyLoggingPacket(targetStarted, LoggingEventType.TargetStartedEvent);
             VerifyLoggingPacket(targetFinished, LoggingEventType.TargetFinishedEvent);
             VerifyLoggingPacket(projectStarted, LoggingEventType.ProjectStartedEvent);
             VerifyLoggingPacket(projectFinished, LoggingEventType.ProjectFinishedEvent);
+            VerifyLoggingPacket(evaluationStarted, LoggingEventType.ProjectEvaluationStartedEvent);
+            VerifyLoggingPacket(evaluationFinished, LoggingEventType.ProjectEvaluationFinishedEvent);
             VerifyLoggingPacket(externalStartedEvent, LoggingEventType.CustomEvent);
         }
 
+        private static BuildEventContext CreateBuildEventContext()
+        {
+            return new BuildEventContext(1, 2, 3, 4, 5, 6, 7);
+        }
+
+        private static ProjectEvaluationStartedEventArgs CreateProjectEvaluationStarted()
+        {
+            string projectFile = "test.csproj";
+            var result = new ProjectEvaluationStartedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationStarted"),
+                projectFile)
+            {
+                ProjectFile = projectFile
+            };
+            result.BuildEventContext = CreateBuildEventContext();
+
+            return result;
+        }
+
+        private static ProjectEvaluationFinishedEventArgs CreateProjectEvaluationFinished()
+        {
+            string projectFile = "test.csproj";
+            var result = new ProjectEvaluationFinishedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationFinished"),
+                projectFile)
+            {
+                ProjectFile = projectFile,
+                GlobalProperties = CreateProperties(),
+                Properties = CreateProperties(),
+                Items = new ArrayList
+                {
+                    new DictionaryEntry("Compile", new TaskItemData("a", null)),
+                    new DictionaryEntry("Compile", new TaskItemData("b", CreateStringDictionary())),
+                    new DictionaryEntry("Reference", new TaskItemData("c", CreateStringDictionary())),
+                }
+            };
+            result.BuildEventContext = CreateBuildEventContext();
+
+            return result;
+        }
+
+        private static IEnumerable CreateProperties()
+        {
+            return new ArrayList
+            {
+                new DictionaryEntry("a", "b"),
+                new DictionaryEntry("c", "d")
+            };
+        }
+
+        private static Dictionary<string, string> CreateStringDictionary()
+        {
+            return new Dictionary<string, string>
+            {
+                { "a", "b" },
+                { "c", "d" }
+            };
+        }
+
+        private static TaskItemData[] CreateTaskItems()
+        {
+            var items = new TaskItemData[]
+            {
+                new TaskItemData("ItemSpec1", null),
+                new TaskItemData("ItemSpec1", CreateStringDictionary()),
+                new TaskItemData("ItemSpec2", Enumerable.Range(1, 3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
+            };
+            return items;
+        }
+
+        private static TaskParameterEventArgs CreateTaskParameter()
+        {
+            // touch ItemGroupLoggingHelper to ensure static constructor runs
+            _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
+
+            var items = CreateTaskItems();
+            var result = new TaskParameterEventArgs(
+                TaskParameterMessageKind.TaskInput,
+                "ItemName",
+                items,
+                logItemMetadata: true,
+                DateTime.MinValue);
+
+            // normalize line endings as we can't rely on the line endings of NodePackets_Tests.cs
+            Assert.Equal(@"Task Parameter:
+    ItemName=
+        ItemSpec1
+        ItemSpec1
+                a=b
+                c=d
+        ItemSpec2
+                1=1value
+                2=2value
+                3=3value".Replace("\r\n", "\n"), result.Message);
+
+            return result;
+        }
+
         /// <summary>
         /// Tests serialization of LogMessagePacket with each kind of event type.
         /// </summary>
         [Fact]
         public void TestTranslation()
         {
+            // need to touch the type so that the static constructor runs
+            _ = ItemGroupLoggingHelper.OutputItemParameterMessagePrefix;
+
             TaskItem item = new TaskItem("Hello", "my.proj");
             List<TaskItem> targetOutputs = new List<TaskItem>();
             targetOutputs.Add(item);
@@ -88,13 +198,16 @@ public void TestTranslation()
                     new TaskStartedEventArgs("message", "help", "projectFile", "taskFile", "taskName"),
                     new TaskFinishedEventArgs("message", "help", "projectFile", "taskFile", "taskName", true),
                     new TaskCommandLineEventArgs("commandLine", "taskName", MessageImportance.Low),
+                    CreateTaskParameter(),
                     new BuildWarningEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender"),
                     new BuildErrorEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender"),
                     new TargetStartedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile"),
                     new TargetFinishedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile", true, targetOutputs),
                     new ProjectStartedEventArgs(-1, "message", "help", "ProjectFile", "targetNames", null, null, null),
                     new ProjectFinishedEventArgs("message", "help", "ProjectFile", true),
-                    new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames")
+                    new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames"),
+                    CreateProjectEvaluationStarted(),
+                    CreateProjectEvaluationFinished()
                 };
 
                 foreach (BuildEventArgs arg in testArgs)
@@ -250,6 +363,32 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     // Assert.AreEqual(leftProjectStarted.Properties, rightProjectStarted.Properties);
                     break;
 
+                case LoggingEventType.ProjectEvaluationStartedEvent:
+                    ProjectEvaluationStartedEventArgs leftEvaluationStarted = left.NodeBuildEvent.Value.Value as ProjectEvaluationStartedEventArgs;
+                    ProjectEvaluationStartedEventArgs rightEvaluationStarted = right.NodeBuildEvent.Value.Value as ProjectEvaluationStartedEventArgs;
+                    Assert.NotNull(leftEvaluationStarted);
+                    Assert.NotNull(rightEvaluationStarted);
+                    Assert.Equal(leftEvaluationStarted.ProjectFile, rightEvaluationStarted.ProjectFile);
+                    break;
+
+                case LoggingEventType.ProjectEvaluationFinishedEvent:
+                    ProjectEvaluationFinishedEventArgs leftEvaluationFinished = left.NodeBuildEvent.Value.Value as ProjectEvaluationFinishedEventArgs;
+                    ProjectEvaluationFinishedEventArgs rightEvaluationFinished = right.NodeBuildEvent.Value.Value as ProjectEvaluationFinishedEventArgs;
+                    Assert.NotNull(leftEvaluationFinished);
+                    Assert.NotNull(rightEvaluationFinished);
+                    Assert.Equal(leftEvaluationFinished.ProjectFile, rightEvaluationFinished.ProjectFile);
+                    Assert.Equal(leftEvaluationFinished.ProfilerResult, rightEvaluationFinished.ProfilerResult);
+                    Assert.Equal(
+                        TranslationHelpers.GetPropertiesString(leftEvaluationFinished.GlobalProperties),
+                        TranslationHelpers.GetPropertiesString(rightEvaluationFinished.GlobalProperties));
+                    Assert.Equal(
+                        TranslationHelpers.GetPropertiesString(leftEvaluationFinished.Properties),
+                        TranslationHelpers.GetPropertiesString(rightEvaluationFinished.Properties));
+                    Assert.Equal(
+                        TranslationHelpers.GetMultiItemsString(leftEvaluationFinished.Items),
+                        TranslationHelpers.GetMultiItemsString(rightEvaluationFinished.Items));
+                    break;
+
                 case LoggingEventType.TargetFinishedEvent:
                     TargetFinishedEventArgs leftTargetFinished = left.NodeBuildEvent.Value.Value as TargetFinishedEventArgs;
                     TargetFinishedEventArgs rightTargetFinished = right.NodeBuildEvent.Value.Value as TargetFinishedEventArgs;
@@ -259,6 +398,8 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     Assert.Equal(leftTargetFinished.Succeeded, rightTargetFinished.Succeeded);
                     Assert.Equal(leftTargetFinished.TargetFile, rightTargetFinished.TargetFile);
                     Assert.Equal(leftTargetFinished.TargetName, rightTargetFinished.TargetName);
+                    //TODO: target output translation is a special case and is done in TranslateTargetFinishedEvent
+                    //Assert.Equal(leftTargetFinished.TargetOutputs, rightTargetFinished.TargetOutputs);
                     break;
 
                 case LoggingEventType.TargetStartedEvent:
@@ -281,6 +422,19 @@ private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket ri
                     Assert.Equal(leftCommand.TaskName, rightCommand.TaskName);
                     break;
 
+                case LoggingEventType.TaskParameterEvent:
+                    var leftTaskParameter = left.NodeBuildEvent.Value.Value as TaskParameterEventArgs;
+                    var rightTaskParameter = right.NodeBuildEvent.Value.Value as TaskParameterEventArgs;
+                    Assert.NotNull(leftTaskParameter);
+                    Assert.NotNull(rightTaskParameter);
+                    Assert.Equal(leftTaskParameter.Kind, rightTaskParameter.Kind);
+                    Assert.Equal(leftTaskParameter.ItemType, rightTaskParameter.ItemType);
+                    Assert.Equal(leftTaskParameter.Items.Count, rightTaskParameter.Items.Count);
+                    Assert.Equal(leftTaskParameter.Message, rightTaskParameter.Message);
+                    Assert.Equal(leftTaskParameter.BuildEventContext, rightTaskParameter.BuildEventContext);
+                    Assert.Equal(leftTaskParameter.Timestamp, rightTaskParameter.Timestamp);
+                    break;
+
                 case LoggingEventType.TaskFinishedEvent:
                     TaskFinishedEventArgs leftTaskFinished = left.NodeBuildEvent.Value.Value as TaskFinishedEventArgs;
                     TaskFinishedEventArgs rightTaskFinished = right.NodeBuildEvent.Value.Value as TaskFinishedEventArgs;
diff --git a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
index 9d8db26b192..fe416e2e901 100644
--- a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
@@ -1417,6 +1417,21 @@ void IRequestBuilderCallback.ExitMSBuildCallbackState()
         {
         }
 
+        /// <summary>
+        /// Empty impl
+        /// </summary>
+        int IRequestBuilderCallback.RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)
+        {
+            return 0;
+        }
+
+        /// <summary>
+        /// Empty impl
+        /// </summary>
+        void IRequestBuilderCallback.ReleaseCores(int coresToRelease)
+        {
+        }
+
         #endregion
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
index 54c1888e2dd..faa5e75e688 100644
--- a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
@@ -978,6 +978,21 @@ void IRequestBuilderCallback.ExitMSBuildCallbackState()
         {
         }
 
+        /// <summary>
+        /// Empty impl
+        /// </summary>
+        int IRequestBuilderCallback.RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)
+        {
+            return 0;
+        }
+
+        /// <summary>
+        /// Empty impl
+        /// </summary>
+        void IRequestBuilderCallback.ReleaseCores(int coresToRelease)
+        {
+        }
+
         #endregion
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index ed6ff1db561..6e1556b5712 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -755,6 +755,21 @@ void IRequestBuilderCallback.ExitMSBuildCallbackState()
         {
         }
 
+        /// <summary>
+        /// Empty impl
+        /// </summary>
+        int IRequestBuilderCallback.RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)
+        {
+            return 0;
+        }
+
+        /// <summary>
+        /// Empty impl
+        /// </summary>
+        void IRequestBuilderCallback.ReleaseCores(int coresToRelease)
+        {
+        }
+
         #endregion
 
         #region IRequestBuilderCallback Members
diff --git a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
index 62a6e1a3d56..144f30bea1a 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
+using System.Linq;
 using System.Threading;
 
 
@@ -12,7 +13,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
-
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.BackEnd
@@ -36,22 +37,28 @@ public void ConstructorWithNullName()
             Assert.Throws<InternalErrorException>(() =>
             {
                 TaskHostConfiguration config = new TaskHostConfiguration(
-                    1,
-                    Directory.GetCurrentDirectory(),
-                    null,
-                    Thread.CurrentThread.CurrentCulture,
-                    Thread.CurrentThread.CurrentUICulture,
+                    nodeId: 1,
+                    startupDirectory: Directory.GetCurrentDirectory(),
+                    buildProcessEnvironment: null,
+                    culture: Thread.CurrentThread.CurrentCulture,
+                    uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                    appDomainSetup:
 #if FEATURE_APPDOMAIN
                     null,
+#endif
+                    lineNumberOfTask:
 #endif
                     1,
-                    1,
-                    @"c:\my project\myproj.proj",
-                    _continueOnErrorDefault,
-                    null,
-                    @"c:\my tasks\mytask.dll",
-                    null,
-                    null);
+                    columnNumberOfTask: 1,
+                    projectFileOfTask: @"c:\my project\myproj.proj",
+                    continueOnError: _continueOnErrorDefault,
+                    taskName: null,
+                    taskLocation: @"c:\my tasks\mytask.dll",
+                    taskParameters: null,
+                    globalParameters: null,
+                    warningsAsErrors: null,
+                    warningsAsMessages: null);
             }
            );
         }
@@ -64,22 +71,28 @@ public void ConstructorWithEmptyName()
             Assert.Throws<InternalErrorException>(() =>
             {
                 TaskHostConfiguration config = new TaskHostConfiguration(
-                    1,
-                    Directory.GetCurrentDirectory(),
-                    null,
-                    Thread.CurrentThread.CurrentCulture,
-                    Thread.CurrentThread.CurrentUICulture,
+                    nodeId: 1,
+                    startupDirectory: Directory.GetCurrentDirectory(),
+                    buildProcessEnvironment: null,
+                    culture: Thread.CurrentThread.CurrentCulture,
+                    uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                    appDomainSetup:
 #if FEATURE_APPDOMAIN
                     null,
+#endif
+                    lineNumberOfTask:
 #endif
                     1,
-                    1,
-                    @"c:\my project\myproj.proj",
-                    _continueOnErrorDefault,
-                    String.Empty,
-                    @"c:\my tasks\mytask.dll",
-                    null,
-                    null);
+                    columnNumberOfTask: 1,
+                    projectFileOfTask: @"c:\my project\myproj.proj",
+                    continueOnError: _continueOnErrorDefault,
+                    taskName: String.Empty,
+                    taskLocation: @"c:\my tasks\mytask.dll",
+                    taskParameters: null,
+                    globalParameters: null,
+                    warningsAsErrors: null,
+                    warningsAsMessages: null);
             }
            );
         }
@@ -92,22 +105,28 @@ public void ConstructorWithNullLocation()
             Assert.Throws<InternalErrorException>(() =>
             {
                 TaskHostConfiguration config = new TaskHostConfiguration(
-                    1,
-                    Directory.GetCurrentDirectory(),
-                    null,
-                    Thread.CurrentThread.CurrentCulture,
-                    Thread.CurrentThread.CurrentUICulture,
+                    nodeId: 1,
+                    startupDirectory: Directory.GetCurrentDirectory(),
+                    buildProcessEnvironment: null,
+                    culture: Thread.CurrentThread.CurrentCulture,
+                    uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                    appDomainSetup:
 #if FEATURE_APPDOMAIN
                     null,
+#endif
+                    lineNumberOfTask:
 #endif
                     1,
-                    1,
-                    @"c:\my project\myproj.proj",
-                    _continueOnErrorDefault,
-                    "TaskName",
-                    null,
-                    null,
-                    null);
+                    columnNumberOfTask: 1,
+                    projectFileOfTask: @"c:\my project\myproj.proj",
+                    continueOnError: _continueOnErrorDefault,
+                    taskName: "TaskName",
+                    taskLocation: null,
+                    taskParameters: null,
+                    globalParameters: null,
+                    warningsAsErrors: null,
+                    warningsAsMessages: null);
             }
            );
         }
@@ -122,22 +141,28 @@ public void ConstructorWithEmptyLocation()
             Assert.Throws<InternalErrorException>(() =>
             {
                 TaskHostConfiguration config = new TaskHostConfiguration(
-                    1,
-                    Directory.GetCurrentDirectory(),
-                    null,
-                    Thread.CurrentThread.CurrentCulture,
-                    Thread.CurrentThread.CurrentUICulture,
+                    nodeId: 1,
+                    startupDirectory: Directory.GetCurrentDirectory(),
+                    buildProcessEnvironment: null,
+                    culture: Thread.CurrentThread.CurrentCulture,
+                    uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                    appDomainSetup:
 #if FEATURE_APPDOMAIN
                     null,
+#endif
+                    lineNumberOfTask:
 #endif
                     1,
-                    1,
-                    @"c:\my project\myproj.proj",
-                    _continueOnErrorDefault,
-                    "TaskName",
-                    String.Empty,
-                    null,
-                    null);
+                    columnNumberOfTask: 1,
+                    projectFileOfTask: @"c:\my project\myproj.proj",
+                    continueOnError: _continueOnErrorDefault,
+                    taskName: "TaskName",
+                    taskLocation: String.Empty,
+                    taskParameters: null,
+                    globalParameters: null,
+                    warningsAsErrors: null,
+                    warningsAsMessages: null);
             }
            );
         }
@@ -150,59 +175,77 @@ public void ConstructorWithEmptyLocation()
         public void TestValidConstructors()
         {
             TaskHostConfiguration config = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                null,
-                null);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: null,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             TaskHostConfiguration config2 = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                null,
-                null);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: null,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             TaskHostConfiguration config3 = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                parameters,
-                null);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: parameters,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             IDictionary<string, object> parameters2 = new Dictionary<string, object>();
             parameters2.Add("Text", "Hello!");
@@ -211,22 +254,58 @@ public void TestValidConstructors()
             parameters2.Add("ItemArray", new ITaskItem[] { new TaskItem("DEF"), new TaskItem("GHI"), new TaskItem("JKL") });
 
             TaskHostConfiguration config4 = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: parameters2,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
+
+            HashSet<string> WarningsAsErrors = new HashSet<string>();
+            WarningsAsErrors.Add("MSB1234");
+            WarningsAsErrors.Add("MSB1235");
+            WarningsAsErrors.Add("MSB1236");
+            WarningsAsErrors.Add("MSB1237");
+
+            TaskHostConfiguration config5 = new TaskHostConfiguration(
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
+#if FEATURE_APPDOMAIN
+                null,
+#endif
+                lineNumberOfTask:
+#endif
                 1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                parameters2,
-                null);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: parameters2,
+                globalParameters: null,
+                warningsAsErrors: WarningsAsErrors,
+                warningsAsMessages: null);
         }
 
         /// <summary>
@@ -242,22 +321,28 @@ public void TestTranslationWithNullDictionary()
             };
 
             TaskHostConfiguration config = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                null,
-                expectedGlobalProperties);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: null,
+                globalParameters: expectedGlobalProperties,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -280,22 +365,28 @@ public void TestTranslationWithNullDictionary()
         public void TestTranslationWithEmptyDictionary()
         {
             TaskHostConfiguration config = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                new Dictionary<string, object>(),
-                new Dictionary<string, string>());
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: new Dictionary<string, object>(),
+                globalParameters: new Dictionary<string, string>(),
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -323,22 +414,28 @@ public void TestTranslationWithValueTypesInDictionary()
             parameters.Add("Text", "Foo");
             parameters.Add("BoolValue", false);
             TaskHostConfiguration config = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                parameters,
-                null);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: parameters,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -364,22 +461,28 @@ public void TestTranslationWithITaskItemInDictionary()
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("TaskItemValue", new TaskItem("Foo"));
             TaskHostConfiguration config = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                parameters,
-                null);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: parameters,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -404,22 +507,28 @@ public void TestTranslationWithITaskItemArrayInDictionary()
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("TaskItemArrayValue", new ITaskItem[] { new TaskItem("Foo"), new TaskItem("Baz") });
             TaskHostConfiguration config = new TaskHostConfiguration(
-                1,
-                Directory.GetCurrentDirectory(),
-                null,
-                Thread.CurrentThread.CurrentCulture,
-                Thread.CurrentThread.CurrentUICulture,
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
 #if FEATURE_APPDOMAIN
                 null,
+#endif
+                lineNumberOfTask:
 #endif
                 1,
-                1,
-                @"c:\my project\myproj.proj",
-                _continueOnErrorDefault,
-                "TaskName",
-                @"c:\MyTasks\MyTask.dll",
-                parameters,
-                null);
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: parameters,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: null);
 
             ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -439,6 +548,99 @@ public void TestTranslationWithITaskItemArrayInDictionary()
             TaskHostPacketHelpers.AreEqual(itemArray, deserializedItemArray);
         }
 
+        /// <summary>
+        /// Test serialization / deserialization when the parameter dictionary contains an ITaskItem array. 
+        /// </summary>
+        [Fact]
+        public void TestTranslationWithWarningsAsErrors()
+        {
+            HashSet<string> WarningsAsErrors = new HashSet<string>();
+            WarningsAsErrors.Add("MSB1234");
+            WarningsAsErrors.Add("MSB1235");
+            WarningsAsErrors.Add("MSB1236");
+            WarningsAsErrors.Add("MSB1237");
+            TaskHostConfiguration config = new TaskHostConfiguration(
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
+#if FEATURE_APPDOMAIN
+                null,
+#endif
+                lineNumberOfTask:
+#endif
+                1,
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: null,
+                globalParameters: null,
+                warningsAsErrors: WarningsAsErrors,
+                warningsAsMessages: null);
+
+            ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
+            INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
+
+            TaskHostConfiguration deserializedConfig = packet as TaskHostConfiguration;
+
+            Assert.Equal(config.TaskName, deserializedConfig.TaskName);
+#if !FEATURE_ASSEMBLYLOADCONTEXT
+            Assert.Equal(config.TaskLocation, deserializedConfig.TaskLocation);
+#endif
+            Assert.NotNull(deserializedConfig.WarningsAsErrors);
+            config.WarningsAsErrors.SequenceEqual(deserializedConfig.WarningsAsErrors, StringComparer.Ordinal).ShouldBeTrue();
+
+        }
+
+        /// <summary>
+        /// Test serialization / deserialization when the parameter dictionary contains warningsasmessages
+        /// </summary>
+        [Fact]
+        public void TestTranslationWithWarningsAsMessages()
+        {
+            HashSet<string> WarningsAsMessages = new HashSet<string>();
+            WarningsAsMessages.Add("MSB1234");
+            WarningsAsMessages.Add("MSB1235");
+            WarningsAsMessages.Add("MSB1236");
+            WarningsAsMessages.Add("MSB1237");
+            TaskHostConfiguration config = new TaskHostConfiguration(
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+#if FEATURE_APPDOMAIN
+                appDomainSetup:
+#if FEATURE_APPDOMAIN
+                null,
+#endif
+                lineNumberOfTask:
+#endif
+                1,
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                taskParameters: null,
+                globalParameters: null,
+                warningsAsErrors: null,
+                warningsAsMessages: WarningsAsMessages);
+
+            ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
+            INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
+
+            TaskHostConfiguration deserializedConfig = packet as TaskHostConfiguration;
+
+            Assert.NotNull(deserializedConfig.WarningsAsMessages);
+            config.WarningsAsMessages.SequenceEqual(deserializedConfig.WarningsAsMessages, StringComparer.Ordinal).ShouldBeTrue();
+        }
+
         /// <summary>
         /// Helper methods for testing the task host-related packets. 
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
index 3996c7221e8..1db0b3935b2 100644
--- a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
@@ -15,6 +15,7 @@
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using System.Threading.Tasks;
 using Xunit;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -705,6 +706,90 @@ public void TasksGetNoGlobalPropertiesIfNoneSpecified()
             mockLogger.AssertLogContains("Global property count: 0");
         }
 
+        [Fact]
+        public void RequestCoresThrowsOnInvalidInput()
+        {
+            Assert.Throws<ArgumentOutOfRangeException>(() =>
+            {
+                _taskHost.RequestCores(0);
+            });
+
+            Assert.Throws<ArgumentOutOfRangeException>(() =>
+            {
+                _taskHost.RequestCores(-1);
+            });
+        }
+
+        [Fact]
+        public void RequestCoresUsesImplicitCore()
+        {
+            // If the request callback has no cores to grant, we still get 1 for the implicit core.
+            _mockRequestCallback.CoresToGrant = 0;
+            _taskHost.RequestCores(3).ShouldBe(1);
+            _mockRequestCallback.LastRequestedCores.ShouldBe(2);
+            _mockRequestCallback.LastWaitForCores.ShouldBeFalse();
+        }
+
+        [Fact]
+        public void RequestCoresUsesCoresFromRequestCallback()
+        {
+            // The request callback has 1 core to grant, we should see it returned from RequestCores.
+            _mockRequestCallback.CoresToGrant = 1;
+            _taskHost.RequestCores(3).ShouldBe(2);
+            _mockRequestCallback.LastRequestedCores.ShouldBe(2);
+            _mockRequestCallback.LastWaitForCores.ShouldBeFalse();
+
+            // Since we've used the implicit core, the second call will return only what the request callback gives us and may block.
+            _mockRequestCallback.CoresToGrant = 1;
+            _taskHost.RequestCores(3).ShouldBe(1);
+            _mockRequestCallback.LastRequestedCores.ShouldBe(3);
+            _mockRequestCallback.LastWaitForCores.ShouldBeTrue();
+        }
+
+        [Fact]
+        public void ReleaseCoresThrowsOnInvalidInput()
+        {
+            Assert.Throws<ArgumentOutOfRangeException>(() =>
+            {
+                _taskHost.ReleaseCores(0);
+            });
+
+            Assert.Throws<ArgumentOutOfRangeException>(() =>
+            {
+                _taskHost.ReleaseCores(-1);
+            });
+        }
+
+        [Fact]
+        public void ReleaseCoresReturnsCoresToRequestCallback()
+        {
+            _mockRequestCallback.CoresToGrant = 1;
+            _taskHost.RequestCores(3).ShouldBe(2);
+
+            // We return one of two granted cores, the call passes through to the request callback.
+            _taskHost.ReleaseCores(1);
+            _mockRequestCallback.LastCoresToRelease.ShouldBe(1);
+
+            // The implicit core is still allocated so a subsequent RequestCores call may block.
+            _taskHost.RequestCores(1);
+            _mockRequestCallback.LastWaitForCores.ShouldBeTrue();
+        }
+
+        [Fact]
+        public void ReleaseCoresReturnsImplicitCore()
+        {
+            _mockRequestCallback.CoresToGrant = 1;
+            _taskHost.RequestCores(3).ShouldBe(2);
+
+            // We return both granted cores, one of them is returned to the request callback.
+            _taskHost.ReleaseCores(2);
+            _mockRequestCallback.LastCoresToRelease.ShouldBe(1);
+
+            // The implicit core is not allocated anymore so a subsequent RequestCores call won't block.
+            _taskHost.RequestCores(1);
+            _mockRequestCallback.LastWaitForCores.ShouldBeFalse();
+        }
+
         #region Helper Classes
 
         /// <summary>
@@ -1221,6 +1306,26 @@ internal class MockIRequestBuilderCallback : IRequestBuilderCallback, IRequestBu
             /// </summary>
             private BuildResult[] _buildResultsToReturn;
 
+            /// <summary>
+            /// The requestedCores argument passed to the last RequestCores call.
+            /// </summary>
+            public int LastRequestedCores { get; private set; }
+
+            /// <summary>
+            /// The waitForCores argument passed to the last RequestCores call.
+            /// </summary>
+            public bool LastWaitForCores { get; private set; }
+
+            /// <summary>
+            /// The value to be returned from the RequestCores call.
+            /// </summary>
+            public int CoresToGrant { get; set; }
+
+            /// <summary>
+            /// The coresToRelease argument passed to the last ReleaseCores call.
+            /// </summary>
+            public int LastCoresToRelease { get; private set; }
+
             /// <summary>
             /// Constructor which takes an array of build results to return from the BuildProjects method when it is called.
             /// </summary>
@@ -1247,6 +1352,11 @@ internal MockIRequestBuilderCallback(BuildResult[] buildResultsToReturn)
             /// Not Implemented
             /// </summary>
             public event BuildRequestBlockedDelegate OnBuildRequestBlocked;
+
+            /// <summary>
+            /// Not Implemented
+            /// </summary>
+            public event ResourceRequestDelegate OnResourceRequest;
 #pragma warning restore
 
             /// <summary>
@@ -1294,6 +1404,24 @@ public void ExitMSBuildCallbackState()
             {
             }
 
+            /// <summary>
+            /// Mock
+            /// </summary>
+            public int RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)
+            {
+                LastRequestedCores = requestedCores;
+                LastWaitForCores = waitForCores;
+                return CoresToGrant;
+            }
+
+            /// <summary>
+            /// Mock
+            /// </summary>
+            public void ReleaseCores(int coresToRelease)
+            {
+                LastCoresToRelease = coresToRelease;
+            }
+
             /// <summary>
             /// Mock of the Block on target in progress.
             /// </summary>
@@ -1318,6 +1446,14 @@ public void ContinueRequest()
                 throw new NotImplementedException();
             }
 
+            /// <summary>
+            /// Not Implemented
+            /// </summary>
+            public void ContinueRequestWithResources(ResourceResponse response)
+            {
+                throw new NotImplementedException();
+            }
+
             /// <summary>
             /// Not Implemented
             /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
index aaf86e1ad25..a4f5a3c09e5 100644
--- a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
+++ b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
@@ -2,10 +2,13 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
 using System.IO;
+using System.Text;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -104,5 +107,64 @@ internal static bool CompareExceptions(Exception left, Exception right)
 
             return CompareExceptions(left.InnerException, right.InnerException);
         }
+
+        internal static string GetPropertiesString(IEnumerable properties)
+        {
+            var dictionary = properties
+                .OfType<DictionaryEntry>()
+                .ToDictionary(
+                    (Func<DictionaryEntry, string>)(d => d.Key.ToString()),
+                    (Func<DictionaryEntry, string>)(d => d.Value.ToString()));
+            return ToString(dictionary);
+        }
+
+        internal static string GetMultiItemsString(IEnumerable items)
+        {
+            var list = items
+                .OfType<DictionaryEntry>()
+                .Select(i => i.Key.ToString() + GetTaskItemString(i.Value));
+            var text = string.Join("\n", list);
+            return text;
+        }
+
+        internal static string GetItemsString(IEnumerable items)
+        {
+            var list = items
+                .OfType<object>()
+                .Select(i => GetTaskItemString(i));
+            var text = string.Join("\n", list);
+            return text;
+        }
+
+        internal static string GetTaskItemString(object item)
+        {
+            var sb = new StringBuilder();
+
+            if (item is ITaskItem taskItem)
+            {
+                sb.Append(taskItem.ItemSpec);
+                foreach (string name in taskItem.MetadataNames)
+                {
+                    var value = taskItem.GetMetadata(name);
+                    sb.Append($";{name}={value}");
+                }
+            }
+            else
+            {
+                sb.Append(Convert.ToString(item));
+            }
+
+            return sb.ToString();
+        }
+
+        internal static string ToString(IDictionary<string, string> dictionary)
+        {
+            if (dictionary == null)
+            {
+                return "null";
+            }
+
+            return string.Join(";", dictionary.Select(kvp => kvp.Key + "=" + kvp.Value));
+        }
     }
 }
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index ec95009bec1..8deb4db94b7 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -7,7 +7,7 @@ namespace Microsoft.Build.UnitTests
 {
     public class BinaryLoggerTests : IDisposable
     {
-        private static string s_testProject = @"
+        private const string s_testProject = @"
          <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
             <PropertyGroup>
                <TestProperty>Test</TestProperty>
@@ -22,6 +22,38 @@ public class BinaryLoggerTests : IDisposable
                <Exec Command='echo a'/>
             </Target>
          </Project>";
+
+        private const string s_testProject2 = @"
+        <Project>
+            <ItemGroup>
+            <Compile Include=""0.cs"" />
+            </ItemGroup>
+            <ItemDefinitionGroup>
+            <Compile>
+                <MetadataFromItemDefinition>fromItemDefinition%61%62%63&lt;&gt;</MetadataFromItemDefinition>
+            </Compile>
+            </ItemDefinitionGroup>
+            <Target Name=""Build"" Outputs=""@(CombinedOutput)"">
+            <ItemGroup>
+                <Compile Include=""1.cs"">
+                <MetadataName>MetadataValue1%61%62%63&lt;&gt;</MetadataName>
+                </Compile>
+                <Compile Remove=""1.cs"" />
+                <Compile Include=""2.cs"" />
+                <Compile Include=""3.cs"">
+                <CustomMetadata>custom%61%62%63&lt;&gt;</CustomMetadata>
+                </Compile>
+            </ItemGroup>
+            <Message Importance=""High"" Condition=""$(Test) != true"" Text=""Hello"" />
+            <CombinePath BasePath=""base"" Paths=""@(Compile)"">
+                <Output TaskParameter=""CombinedPaths"" ItemName=""CombinedOutput""/>
+            </CombinePath>
+            <ItemGroup>
+                <Compile Remove=""2.cs"" />
+            </ItemGroup>
+            </Target>
+        </Project>";
+
         private readonly TestEnvironment _env;
         private string _logFile;
 
@@ -35,8 +67,10 @@ public BinaryLoggerTests(ITestOutputHelper output)
             _logFile = _env.ExpectFile(".binlog").Path;
         }
 
-        [Fact]
-        public void TestBinaryLoggerRoundtrip()
+        [Theory]
+        [InlineData(s_testProject)]
+        [InlineData(s_testProject2)]
+        public void TestBinaryLoggerRoundtrip(string projectText)
         {
             var binaryLogger = new BinaryLogger();
 
@@ -45,14 +79,14 @@ public void TestBinaryLoggerRoundtrip()
             var mockLogFromBuild = new MockLogger();
 
             // build and log into binary logger and mockLogger1
-            ObjectModelHelpers.BuildProjectExpectSuccess(s_testProject, binaryLogger, mockLogFromBuild);
+            ObjectModelHelpers.BuildProjectExpectSuccess(projectText, binaryLogger, mockLogFromBuild);
 
             var mockLogFromPlayback = new MockLogger();
 
             var binaryLogReader = new BinaryLogReplayEventSource();
             mockLogFromPlayback.Initialize(binaryLogReader);
 
-            // read the binary log and replay into mockLogger2testassembly
+            // read the binary log and replay into mockLogger2
             binaryLogReader.Replay(_logFile);
 
             // the binlog will have more information than recorded by the text log
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index afd56aea915..16b4cb0e035 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -1,12 +1,15 @@
-﻿using System;
+using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
 using System.Text;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Logging;
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -33,7 +36,7 @@ public void RoundtripBuildStartedEventArgs()
                     { "SampleName", "SampleValue" }
                 });
             Roundtrip(args,
-                e => ToString(e.BuildEnvironment),
+                e => TranslationHelpers.ToString(e.BuildEnvironment),
                 e => e.HelpKeyword,
                 e => e.ThreadId.ToString(),
                 e => e.SenderName);
@@ -70,15 +73,15 @@ public void RoundtripProjectStartedEventArgs()
                 toolsVersion: "Current");
             args.BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6);
 
-            Roundtrip(args,
+            Roundtrip<ProjectStartedEventArgs>(args,
                 e => ToString(e.BuildEventContext),
-                e => ToString(e.GlobalProperties),
-                e => ToString(e.Items.OfType<DictionaryEntry>().ToDictionary(d => d.Key.ToString(), d => ((ITaskItem)d.Value).ItemSpec)),
+                e => TranslationHelpers.GetPropertiesString(e.GlobalProperties),
+                e => TranslationHelpers.GetMultiItemsString(e.Items),
                 e => e.Message,
                 e => ToString(e.ParentProjectBuildEventContext),
                 e => e.ProjectFile,
                 e => e.ProjectId.ToString(),
-                e => ToString(e.Properties.OfType<DictionaryEntry>().ToDictionary(d => d.Key.ToString(), d => d.Value.ToString())),
+                e => TranslationHelpers.GetPropertiesString(e.Properties),
                 e => e.TargetNames,
                 e => e.ThreadId.ToString(),
                 e => e.Timestamp.ToString(),
@@ -309,13 +312,33 @@ public void RoundtripTaskCommandLineEventArgs()
                 e => e.Subcategory);
         }
 
+        [Fact]
+        public void RoundtripTaskParameterEventArgs()
+        {
+            var items = new ITaskItem[]
+            {
+                new TaskItemData("ItemSpec1", null),
+                new TaskItemData("ItemSpec2", Enumerable.Range(1,3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
+            };
+            var args = new TaskParameterEventArgs(TaskParameterMessageKind.TaskOutput, "ItemName", items, true, DateTime.MinValue);
+
+            Roundtrip(args,
+                e => e.Kind.ToString(),
+                e => e.ItemType,
+                e => e.LogItemMetadata.ToString(),
+                e => TranslationHelpers.GetItemsString(e.Items));
+        }
+
         [Fact]
         public void RoundtripProjectEvaluationStartedEventArgs()
         {
-            var args = new ProjectEvaluationStartedEventArgs("Message")
+            var projectFile = @"C:\foo\bar.proj";
+            var args = new ProjectEvaluationStartedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationStarted"),
+                projectFile)
             {
                 BuildEventContext = BuildEventContext.Invalid,
-                ProjectFile = @"C:\foo\bar.proj",
+                ProjectFile = projectFile,
             };
 
             Roundtrip(args,
@@ -326,21 +349,33 @@ public void RoundtripProjectEvaluationStartedEventArgs()
         [Fact]
         public void RoundtripProjectEvaluationFinishedEventArgs()
         {
-            var args = new ProjectEvaluationFinishedEventArgs("Message")
+            var projectFile = @"C:\foo\bar.proj";
+            var args = new ProjectEvaluationFinishedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationFinished"),
+                projectFile)
             {
                 BuildEventContext = BuildEventContext.Invalid,
                 ProjectFile = @"C:\foo\bar.proj",
+                GlobalProperties = new Dictionary<string, string>() { { "GlobalKey", "GlobalValue" } },
+                Properties = new List<DictionaryEntry>() { new DictionaryEntry("Key", "Value") },
+                Items = new List<DictionaryEntry>() { new DictionaryEntry("Key", new MyTaskItem() { ItemSpec = "TestItemSpec" }) }
             };
 
             Roundtrip(args,
                 e => e.Message,
-                e => e.ProjectFile);
+                e => e.ProjectFile,
+                e => TranslationHelpers.GetPropertiesString(e.GlobalProperties),
+                e => TranslationHelpers.GetPropertiesString(e.Properties),
+                e => TranslationHelpers.GetMultiItemsString(e.Items));
         }
 
         [Fact]
         public void RoundtripProjectEvaluationFinishedEventArgsWithProfileData()
         {
-            var args = new ProjectEvaluationFinishedEventArgs("Message")
+            var projectFile = @"C:\foo\bar.proj";
+            var args = new ProjectEvaluationFinishedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationFinished"),
+                projectFile)
             {
                 BuildEventContext = BuildEventContext.Invalid,
                 ProjectFile = @"C:\foo\bar.proj",
@@ -524,16 +559,6 @@ private string ToString(BuildEventContext context)
             return $"{context.BuildRequestId} {context.NodeId} {context.ProjectContextId} {context.ProjectInstanceId} {context.SubmissionId} {context.TargetId} {context.TaskId}";
         }
 
-        private string ToString(IDictionary<string, string> dictionary)
-        {
-            if (dictionary == null)
-            {
-                return "null";
-            }
-
-            return string.Join(";", dictionary.Select(kvp => kvp.Key + "=" + kvp.Value));
-        }
-
         private string ToString(IEnumerable<ITaskItem> items)
         {
             return string.Join(";", items.Select(i => ToString(i)));
diff --git a/src/Build.UnitTests/ConfigureableForwardingLogger_Tests.cs b/src/Build.UnitTests/ConfigureableForwardingLogger_Tests.cs
index f584072937b..3698f90ed5d 100644
--- a/src/Build.UnitTests/ConfigureableForwardingLogger_Tests.cs
+++ b/src/Build.UnitTests/ConfigureableForwardingLogger_Tests.cs
@@ -1,6 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
@@ -20,6 +21,7 @@ public class ConfigureableForwardingLogger_Tests
         private readonly TaskStartedEventArgs _taskStarted = new TaskStartedEventArgs("message", "help", "projectFile", "taskFile", "taskName");
         private readonly TaskFinishedEventArgs _taskFinished = new TaskFinishedEventArgs("message", "help", "projectFile", "taskFile", "taskName", true);
         private readonly TaskCommandLineEventArgs _commandLine = new TaskCommandLineEventArgs("commandLine", "taskName", MessageImportance.Low);
+        private readonly TaskParameterEventArgs _taskParameter = new TaskParameterEventArgs(TaskParameterMessageKind.TaskInput, "ItemName", null, true, DateTime.MinValue);
         private readonly BuildWarningEventArgs _warning = new BuildWarningEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
         private readonly BuildErrorEventArgs _error = new BuildErrorEventArgs("SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
         private readonly TargetStartedEventArgs _targetStarted = new TargetStartedEventArgs("message", "help", "targetName", "ProjectFile", "targetFile");
@@ -131,6 +133,7 @@ public void ForwardingLoggingEventsBasedOnVerbosity(LoggerVerbosity? loggerVerbo
                         _normalMessage,
                         _highMessage,
                         _commandLine,
+                        _taskParameter,
                         _warning,
                         _error,
                         _taskFinished,
@@ -150,6 +153,7 @@ public void ForwardingLoggingEventsBasedOnVerbosity(LoggerVerbosity? loggerVerbo
                         _normalMessage,
                         _highMessage,
                         _commandLine,
+                        _taskParameter,
                         _externalStartedEvent,
                         _warning,
                         _error,
@@ -266,6 +270,7 @@ private void RaiseEvents(EventSourceSink source)
             source.Consume(_normalMessage);
             source.Consume(_highMessage);
             source.Consume(_commandLine);
+            source.Consume(_taskParameter);
             source.Consume(_externalStartedEvent);
             source.Consume(_warning);
             source.Consume(_error);
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 0457c2005f2..31c8209404d 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -254,7 +254,6 @@ public void ErrorMessage()
 
             pc.Collection.RegisterLogger(logger);
 
-
             var p = pc.Collection.LoadProject(project.ProjectFile);
 
             BuildManager.DefaultBuildManager.Build(
@@ -266,13 +265,20 @@ public void ErrorMessage()
             sc.ToString().ShouldContain("source_of_error : error : Hello from project 2 [" + project.ProjectFile + ":: Number=2]");
         }
 
-        [Fact]
-        public void ErrorMessageWithMultiplePropertiesInMessage()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ErrorMessageWithMultiplePropertiesInMessage(bool includeEvaluationPropertiesAndItems)
         {
             using var env = TestEnvironment.Create(_output);
 
             var pc = env.CreateProjectCollection();
 
+            if (includeEvaluationPropertiesAndItems)
+            {
+                pc.Collection.LoggingService.IncludeEvaluationPropertiesAndItems = true;
+            }
+
             var project = env.CreateTestProjectWithFiles(@"
          <Project>
             <PropertyGroup>
@@ -300,7 +306,6 @@ public void ErrorMessageWithMultiplePropertiesInMessage()
 
             pc.Collection.RegisterLogger(logger);
 
-
             var p = pc.Collection.LoadProject(project.ProjectFile);
 
             BuildManager.DefaultBuildManager.Build(
@@ -308,8 +313,9 @@ public void ErrorMessageWithMultiplePropertiesInMessage()
                 new BuildRequestData(p.CreateProjectInstance(), new[] { "Spawn" }));
 
             p.Build().ShouldBeFalse();
-            sc.ToString().ShouldContain("source_of_error : error : Hello from project 1 [" + project.ProjectFile + ":: Number=1 TargetFramework=netcoreapp2.1]");
-            sc.ToString().ShouldContain("source_of_error : error : Hello from project 2 [" + project.ProjectFile + ":: Number=2 TargetFramework=netcoreapp2.1]");
+            string output = sc.ToString();
+            output.ShouldContain("source_of_error : error : Hello from project 1 [" + project.ProjectFile + ":: Number=1 TargetFramework=netcoreapp2.1]");
+            output.ShouldContain("source_of_error : error : Hello from project 2 [" + project.ProjectFile + ":: Number=2 TargetFramework=netcoreapp2.1]");
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index ad133c08db8..38ee432877a 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -28,6 +28,7 @@
 using Xunit;
 using Xunit.Abstractions;
 using Shouldly;
+using Microsoft.Build.UnitTests.Shared;
 
 namespace Microsoft.Build.UnitTests.Construction
 {
@@ -749,6 +750,37 @@ public void SolutionConfigurationWithDependencies()
             Helpers.VerifyAssertLineByLine(expected, solutionConfigurationContents);
         }
 
+        /// <summary>
+        /// This test forces a metaproj to be generated as part of the build. Since metaproj files are not written to disk, it will fail if its cached form does not align
+        /// with the version that is being built as when a property is part of the version added to the cache, but that version is not passed to the BuildManager.
+        /// </summary>
+        [Fact]
+        public void SolutionGeneratingMetaproj()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile proj1 = env.CreateFile("A.csproj", @"<Project><Target Name=""Printer""><Message Importance=""high"" Text=""print string"" /></Target></Project>");
+                TransientTestFile proj2 = env.CreateFile("B.csproj", @"<Project><Target Name=""Printer""><Message Importance=""high"" Text=""print string"" /></Target></Project>");
+                TransientTestFile proj3 = env.CreateFile("C.csproj", @"<Project><Target Name=""Printer""><Message Importance=""high"" Text=""print string"" /></Target></Project>");
+                TransientTestFile proj = env.CreateFile("mysln.sln",
+                @$"
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 11
+Project(`{"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"}`) = `A`, `{proj1.Path}`, `{"{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}"}`
+EndProject
+Project(`{"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"}`) = `B`, `{proj2.Path}`, `{"{881C1674-4ECA-451D-85B6-D7C59B7F16FA}"}`
+    ProjectSection(ProjectDependencies) = postProject
+        {"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"} = {"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"}
+    EndProjectSection
+EndProject
+Project(`{"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"}`) = `C`, `{proj3.Path}`, `{"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"}`
+EndProject
+".Replace("`", "\""));
+                RunnerUtilities.ExecMSBuild("\"" + proj.Path + "\"", out bool successfulExit);
+                successfulExit.ShouldBeTrue();
+            }
+        }
+
         /// <summary>
         /// Generated project metaproj should declare its outputs for relay.
         /// Here B depends on C (via solution dep only) and D (via ProjectReference only)
@@ -2477,6 +2509,30 @@ public void DirectorySolutionPropsTest(string projectName, bool enable)
             }
         }
 
+        /// <summary>
+        /// Regression test for https://github.com/dotnet/msbuild/issues/6236
+        /// </summary>
+        [Theory]
+        [InlineData("http://localhost:8080")]
+        [InlineData("a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-")]
+        public void AbsolutePathWorksForUnsupportedPaths(string relativePath)
+        {
+            string solutionFileContents =
+                $@"
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 16
+VisualStudioVersion = 16.0.31025.194
+MinimumVisualStudioVersion = 10.0.40219.1
+Project(""{{E24C65DC-7377-472B-9ABA-BC803B73C61A}}"") = ""WebSite1"", ""{relativePath}"", ""{{{{96E0707C-2E9C-4704-946F-FA583147737F}}}}""
+EndProject";
+
+            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+
+            ProjectInSolution projectInSolution = solution.ProjectsInOrder.ShouldHaveSingleItem();
+
+            projectInSolution.AbsolutePath.ShouldBe(Path.Combine(solution.SolutionFileDirectory, projectInSolution.RelativePath));
+        }
+
         #region Helper Functions
 
         /// <summary>
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index b9329dad3ba..00dc1bb6f61 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -471,6 +471,14 @@ public void ContextDisambiguatesSameRelativeGlobsPointingOutsideDifferentProject
         [MemberData(nameof(ContextDisambiguatesRelativeGlobsData))]
         public void ContextDisambiguatesAFullyQualifiedGlobPointingInAnotherRelativeGlobsCone(EvaluationContext.SharingPolicy policy, string[][] expectedGlobExpansions)
         {
+            if (policy == EvaluationContext.SharingPolicy.Shared)
+            {
+                // This test case has a dependency on our glob expansion caching policy. If the evaluation context is reused
+                // between evaluations and files are added to the filesystem between evaluations, the cache may be returning
+                // stale results. Run only the Isolated variant.
+                return;
+            }
+
             var project1Directory = _env.DefaultTestDirectory.CreateDirectory("Project1");
             var project1GlobDirectory = project1Directory.CreateDirectory("Glob").CreateDirectory("1").Path;
 
diff --git a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
index db0593111e7..6babb127ce7 100644
--- a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
@@ -1,10 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#if FEATURE_SYSTEM_CONFIGURATION
-
 using System.Configuration;
-using Microsoft.Win32;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -683,4 +680,3 @@ private ToolsetConfigurationReader GetStandardConfigurationReader()
 
     }
 }
-#endif
diff --git a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
index 2e44a4239a9..c90b546da38 100644
--- a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
@@ -3,9 +3,7 @@
 
 using System;
 using System.Collections.Generic;
-#if FEATURE_SYSTEM_CONFIGURATION
 using System.Configuration;
-#endif
 using System.IO;
 
 using Microsoft.Build.Collections;
diff --git a/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs b/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
index da2f1fc518e..bfcf5685dc2 100644
--- a/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
@@ -1,10 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#if FEATURE_SYSTEM_CONFIGURATION
-
-using System.Configuration;
-using Microsoft.Win32;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
@@ -15,7 +11,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using Microsoft.Build.UnitTests;
 
 namespace Microsoft.Build.UnitTests.Evaluation
 {
@@ -48,11 +43,13 @@ public void ImportFromExtensionsPathNotFound()
             string extnDir1 = null;
             string mainProjectPath = null;
 
-            try {
+            try
+            {
                 extnDir1 = GetNewExtensionsPathAndCreateFile("extensions1", Path.Combine("foo", "extn.proj"), GetExtensionTargetsFileContent1());
                 mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent());
 
-                var projColln = new ProjectCollection();
+                var projColln = GetProjectCollection();
+
                 projColln.ResetToolsetsForTests(WriteConfigFileAndGetReader("MSBuildExtensionsPath", extnDir1, Path.Combine("tmp", "nonexistent")));
                 var logger = new MockLogger();
                 projColln.RegisterLogger(logger);
@@ -60,7 +57,9 @@ public void ImportFromExtensionsPathNotFound()
                 Assert.Throws<InvalidProjectFileException>(() => projColln.LoadProject(mainProjectPath));
 
                 logger.AssertLogContains("MSB4226");
-            } finally {
+            }
+            finally
+            {
                 if (mainProjectPath != null)
                 {
                     FileUtilities.DeleteNoThrow(mainProjectPath);
@@ -91,7 +90,7 @@ public void ConditionalImportFromExtensionsPathNotFound()
             string extnDir1 = GetNewExtensionsPathAndCreateFile("extensions1", Path.Combine("foo", "extn.proj"), extnTargetsFileContentWithCondition);
             string mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent());
 
-            CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath", new string[] {extnDir1, Path.Combine("tmp", "nonexistent")},
+            CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath", new string[] { extnDir1, Path.Combine("tmp", "nonexistent") },
                                                             null,
                                                             (p, l) => {
                                                                 Assert.True(p.Build());
@@ -128,7 +127,7 @@ public void ImportFromExtensionsPathCircularImportError()
                                                             String.Format(extnTargetsFileContent2, mainProjectPath));
 
             CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath",
-                                                        new string[] {extnDir2, Path.Combine("tmp", "nonexistent"), extnDir1},
+                                                        new string[] { extnDir2, Path.Combine("tmp", "nonexistent"), extnDir1 },
                                                         null,
                                                         (p, l) => l.AssertLogContains("MSB4210"));
         }
@@ -199,7 +198,7 @@ public void ImportFromExtensionsPathWithWildCard()
             string mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", mainTargetsFileContent);
 
             CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath",
-                new[] {extnDir1, Path.Combine("tmp", "nonexistent"), extnDir2},
+                new[] { extnDir1, Path.Combine("tmp", "nonexistent"), extnDir2 },
                 null,
                 (project, logger) =>
                 {
@@ -281,7 +280,7 @@ public void ImportFromExtensionsPathWithWildCardNothingFound()
             string extnDir1 = GetNewExtensionsPathAndCreateFile("extensions1", Path.Combine("foo", "extn.proj"), extnTargetsFileContent);
             string mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent());
 
-            CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath", new string[] {Path.Combine("tmp", "nonexistent"), extnDir1},
+            CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath", new string[] { Path.Combine("tmp", "nonexistent"), extnDir1 },
                                                     null, (p, l) => Assert.True(p.Build()));
         }
 
@@ -293,11 +292,12 @@ public void ImportFromExtensionsPathInvalidFile()
             string extnDir1 = null;
             string mainProjectPath = null;
 
-            try {
+            try
+            {
                 extnDir1 = GetNewExtensionsPathAndCreateFile("extensions1", Path.Combine("foo", "extn.proj"), extnTargetsFileContent);
                 mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent());
 
-                var projColln = new ProjectCollection();
+                var projColln = GetProjectCollection();
                 projColln.ResetToolsetsForTests(WriteConfigFileAndGetReader("MSBuildExtensionsPath", extnDir1,
                                                                                 Path.Combine("tmp", "nonexistent")));
                 var logger = new MockLogger();
@@ -305,7 +305,9 @@ public void ImportFromExtensionsPathInvalidFile()
 
                 Assert.Throws<InvalidProjectFileException>(() => projColln.LoadProject(mainProjectPath));
                 logger.AssertLogContains("MSB4024");
-            } finally {
+            }
+            finally
+            {
                 if (mainProjectPath != null)
                 {
                     FileUtilities.DeleteNoThrow(mainProjectPath);
@@ -351,7 +353,7 @@ public void ImportFromExtensionsPathSearchOrder()
             string extnDir2 = GetNewExtensionsPathAndCreateFile("extensions2", Path.Combine("foo", "extn.proj"), extnTargetsFileContent2);
             string mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent());
 
-            CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath", new string[] {extnDir2, Path.Combine("tmp", "nonexistent"), extnDir1},
+            CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, "MSBuildExtensionsPath", new string[] { extnDir2, Path.Combine("tmp", "nonexistent"), extnDir1 },
                                                             null,
                                                             (p, l) => {
                                                                 Assert.True(p.Build());
@@ -395,8 +397,9 @@ public void ImportFromExtensionsPathSearchOrder2()
             string mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent());
 
             // MSBuildExtensionsPath* property value has highest priority for the lookups
-            try {
-                var projColln = new ProjectCollection();
+            try
+            {
+                var projColln = GetProjectCollection();
                 projColln.ResetToolsetsForTests(WriteConfigFileAndGetReader("MSBuildExtensionsPath", Path.Combine("tmp", "non-existent"), extnDir1));
                 var logger = new MockLogger();
                 projColln.RegisterLogger(logger);
@@ -408,7 +411,9 @@ public void ImportFromExtensionsPathSearchOrder2()
 
                 logger.AssertLogContains("Running FromExtn");
                 logger.AssertLogContains("PropertyFromExtn1: FromSecondFile");
-            } finally {
+            }
+            finally
+            {
                 if (mainProjectPath != null)
                 {
                     FileUtilities.DeleteNoThrow(mainProjectPath);
@@ -472,7 +477,8 @@ public void ImportFromExtensionsPathAnd32And64()
             string extnDir1 = null, extnDir2 = null, extnDir3 = null;
             string mainProjectPath = null;
 
-            try {
+            try
+            {
                 extnDir1 = GetNewExtensionsPathAndCreateFile("extensions1", Path.Combine("foo", "extn.proj"),
                                 String.Format(extnTargetsFileContentTemplate, String.Empty, "FromExtn2", "<Import Project='$(MSBuildExtensionsPath32)\\bar\\extn2.proj' />"));
                 extnDir2 = GetNewExtensionsPathAndCreateFile("extensions2", Path.Combine("bar", "extn2.proj"),
@@ -483,9 +489,10 @@ public void ImportFromExtensionsPathAnd32And64()
                 mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent());
 
                 ToolsetConfigurationReaderTestHelper.WriteConfigFile(String.Format(configFileContents, extnDir1, extnDir2, extnDir3));
+
                 var reader = GetStandardConfigurationReader();
+                var projColln = GetProjectCollection();
 
-                var projColln = new ProjectCollection();
                 projColln.ResetToolsetsForTests(reader);
                 var logger = new MockLogger();
                 projColln.RegisterLogger(logger);
@@ -495,7 +502,9 @@ public void ImportFromExtensionsPathAnd32And64()
                 logger.AssertLogContains("Running FromExtn3");
                 logger.AssertLogContains("Running FromExtn2");
                 logger.AssertLogContains("Running FromExtn");
-            } finally {
+            }
+            finally
+            {
                 if (mainProjectPath != null)
                 {
                     FileUtilities.DeleteNoThrow(mainProjectPath);
@@ -557,9 +566,9 @@ public void ExpandExtensionsPathFallback()
                     GetMainTargetFileContent());
 
                 ToolsetConfigurationReaderTestHelper.WriteConfigFile(configFileContents);
-                var reader = GetStandardConfigurationReader();
 
-                var projectCollection = new ProjectCollection(new Dictionary<string, string> {["FallbackExpandDir1"] = extnDir1});
+                var reader = GetStandardConfigurationReader();
+                var projectCollection = GetProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
 
                 projectCollection.ResetToolsetsForTests(reader);
                 var logger = new MockLogger();
@@ -618,9 +627,9 @@ public void ExpandExtensionsPathFallbackInErrorMessage()
                     GetMainTargetFileContent());
 
                 ToolsetConfigurationReaderTestHelper.WriteConfigFile(configFileContents);
-                var reader = GetStandardConfigurationReader();
 
-                var projectCollection = new ProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
+                var reader = GetStandardConfigurationReader();
+                var projectCollection = GetProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
 
                 projectCollection.ResetToolsetsForTests(reader);
                 var logger = new MockLogger();
@@ -688,9 +697,9 @@ public void FallbackImportWithIndirectReference()
                 mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", mainTargetsFileContent);
 
                 ToolsetConfigurationReaderTestHelper.WriteConfigFile(configFileContents);
-                var reader = GetStandardConfigurationReader();
 
-                var projectCollection = new ProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
+                var reader = GetStandardConfigurationReader();
+                var projectCollection = GetProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
 
                 projectCollection.ResetToolsetsForTests(reader);
                 var logger = new MockLogger();
@@ -753,9 +762,9 @@ public void FallbackImportWithUndefinedProperty()
                 mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", mainTargetsFileContent);
 
                 ToolsetConfigurationReaderTestHelper.WriteConfigFile(configFileContents);
-                var reader = GetStandardConfigurationReader();
 
-                var projectCollection = new ProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
+                var reader = GetStandardConfigurationReader();
+                var projectCollection = GetProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
 
                 projectCollection.ResetToolsetsForTests(reader);
                 var logger = new MockLogger();
@@ -812,9 +821,9 @@ public void FallbackImportWithFileNotFoundWhenPropertyNotDefined()
                 mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", mainTargetsFileContent);
 
                 ToolsetConfigurationReaderTestHelper.WriteConfigFile(configFileContents);
-                var reader = GetStandardConfigurationReader();
 
-                var projectCollection = new ProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
+                var reader = GetStandardConfigurationReader();
+                var projectCollection = GetProjectCollection(new Dictionary<string, string> { ["FallbackExpandDir1"] = extnDir1 });
 
                 projectCollection.ResetToolsetsForTests(reader);
                 var logger = new MockLogger();
@@ -834,7 +843,8 @@ public void FallbackImportWithFileNotFoundWhenPropertyNotDefined()
         void CreateAndBuildProjectForImportFromExtensionsPath(string extnPathPropertyName, Action<Project, MockLogger> action)
         {
             string extnDir1 = null, extnDir2 = null, mainProjectPath = null;
-            try {
+            try
+            {
                 extnDir1 = GetNewExtensionsPathAndCreateFile("extensions1", Path.Combine("foo", "extn.proj"),
                                     GetExtensionTargetsFileContent1(extnPathPropertyName));
                 extnDir2 = GetNewExtensionsPathAndCreateFile("extensions2", Path.Combine("bar", "extn2.proj"),
@@ -842,10 +852,12 @@ void CreateAndBuildProjectForImportFromExtensionsPath(string extnPathPropertyNam
 
                 mainProjectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory("main.proj", GetMainTargetFileContent(extnPathPropertyName));
 
-                CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, extnPathPropertyName, new string[] {extnDir1, extnDir2},
+                CreateAndBuildProjectForImportFromExtensionsPath(mainProjectPath, extnPathPropertyName, new string[] { extnDir1, extnDir2 },
                                                                 null,
                                                                 action);
-            } finally {
+            }
+            finally
+            {
                 if (extnDir1 != null)
                 {
                     FileUtilities.DeleteDirectoryNoThrow(extnDir1, recursive: true);
@@ -864,15 +876,19 @@ void CreateAndBuildProjectForImportFromExtensionsPath(string extnPathPropertyNam
         void CreateAndBuildProjectForImportFromExtensionsPath(string mainProjectPath, string extnPathPropertyName, string[] extnDirs, Action<string[]> setExtensionsPath,
                 Action<Project, MockLogger> action)
         {
-            try {
-                var projColln = new ProjectCollection();
+            try
+            {
+                var projColln = GetProjectCollection();
+
                 projColln.ResetToolsetsForTests(WriteConfigFileAndGetReader(extnPathPropertyName, extnDirs));
                 var logger = new MockLogger();
                 projColln.RegisterLogger(logger);
                 var project = projColln.LoadProject(mainProjectPath);
 
                 action(project, logger);
-            } finally {
+            }
+            finally
+            {
                 if (mainProjectPath != null)
                 {
                     FileUtilities.DeleteNoThrow(mainProjectPath);
@@ -913,6 +929,30 @@ private ToolsetConfigurationReader WriteConfigFileAndGetReader(string extnPathPr
             return GetStandardConfigurationReader();
         }
 
+        private ProjectCollection GetProjectCollection(IDictionary<string, string> globalProperties = null)
+        {
+            ProjectCollection projColln;
+
+            if (globalProperties == null)
+            {
+#if FEATURE_SYSTEM_CONFIGURATION
+                projColln = new ProjectCollection();
+#else
+                projColln = new ProjectCollection(ToolsetDefinitionLocations.ConfigurationFile);
+#endif
+            }
+            else
+            {
+#if FEATURE_SYSTEM_CONFIGURATION
+                projColln = new ProjectCollection(globalProperties);
+#else
+                projColln = new ProjectCollection(globalProperties, loggers: null, ToolsetDefinitionLocations.ConfigurationFile);
+#endif
+            }
+
+            return projColln;
+        }
+
         string GetNewExtensionsPathAndCreateFile(string extnDirName, string relativeFilePath, string fileContents)
         {
             var extnDir = Path.Combine(ObjectModelHelpers.TempProjectDir, extnDirName);
@@ -922,7 +962,7 @@ string GetNewExtensionsPathAndCreateFile(string extnDirName, string relativeFile
             return extnDir;
         }
 
-        string GetMainTargetFileContent(string extensionsPathPropertyName="MSBuildExtensionsPath")
+        string GetMainTargetFileContent(string extensionsPathPropertyName = "MSBuildExtensionsPath")
         {
             string mainTargetsFileContent = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003' >
@@ -936,7 +976,7 @@ string GetMainTargetFileContent(string extensionsPathPropertyName="MSBuildExtens
             return String.Format(mainTargetsFileContent, extensionsPathPropertyName);
         }
 
-        string GetExtensionTargetsFileContent1(string extensionsPathPropertyName="MSBuildExtensionsPath")
+        string GetExtensionTargetsFileContent1(string extensionsPathPropertyName = "MSBuildExtensionsPath")
         {
             string extnTargetsFileContent1 = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003' >
@@ -954,7 +994,7 @@ string GetExtensionTargetsFileContent1(string extensionsPathPropertyName="MSBuil
             return String.Format(extnTargetsFileContent1, extensionsPathPropertyName);
         }
 
-        string GetExtensionTargetsFileContent2(string extensionsPathPropertyName="MSBuildExtensionsPath")
+        string GetExtensionTargetsFileContent2(string extensionsPathPropertyName = "MSBuildExtensionsPath")
         {
             string extnTargetsFileContent2 = @"
                 <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003' >
@@ -977,4 +1017,3 @@ private ToolsetConfigurationReader GetStandardConfigurationReader()
         }
     }
 }
-#endif
diff --git a/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs b/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs
new file mode 100644
index 00000000000..298cf5ff37f
--- /dev/null
+++ b/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs
@@ -0,0 +1,80 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#if !FEATURE_SYSTEM_CONFIGURATION
+/*  This test is designed especially to test Configuration parsing in net5.0
+ *  which means it WON'T work in net472 and thus we don't run it in net472 */
+
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
+
+using Xunit;
+using System.Collections.Generic;
+using Shouldly;
+
+namespace Microsoft.Build.UnitTests.Evaluation
+{
+    /// <summary>
+    /// Unit tests for MSBuild Net5.0 Configuration Parsing
+    /// </summary>
+    public class ToolsetConfigurationNet5Test
+    {
+        [Fact]
+        // The default ToolsetDefintionLocations is None, which results in only the local which results in only the several included
+        // paths such as SDK path and RoslynTargetPath and nothing else. This behavior is expected and the exact same as before.
+        public void ToolsetDefinitionLocationsIsDefault()
+        {
+            var projectCollection = new ProjectCollection();
+            IDictionary<string, string> toolsetProperties
+                = new Dictionary<string, string>();
+
+            foreach (Toolset toolset in projectCollection.Toolsets)
+            {
+                foreach (KeyValuePair<string, ProjectPropertyInstance> properties in toolset.Properties)
+                {
+                    toolsetProperties[properties.Value.Name] = properties.Value.EvaluatedValue;
+                }
+            }
+
+            toolsetProperties.ShouldContainKey("MSBuildSDKsPath");
+            toolsetProperties.ShouldContainKey("RoslynTargetsPath");
+            toolsetProperties["MSBuildSDKsPath"].ShouldNotBeNullOrEmpty();
+            toolsetProperties["RoslynTargetsPath"].ShouldNotBeNullOrEmpty();
+
+            toolsetProperties.ShouldNotContainKey("VCTargetsPath");
+            toolsetProperties.ShouldNotContainKey("MSBuildToolsRoot");
+            toolsetProperties.ShouldNotContainKey("MSBuildExtensionsPath");
+        }
+
+        [Fact]
+        // With ToolsetDefintionLocations set to ConfigurationFile (Which would only happen in net5.0 if the user decides to set it). 
+        // Most toolsets are available and the MsBuildTools and SDK paths are all in the net5.0 runtime.
+        public void ToolsetDefinitionLocationsIsConfiguration()
+        {
+            var projectCollection = new ProjectCollection(ToolsetDefinitionLocations.ConfigurationFile);
+            IDictionary<string, string> toolsetProperties
+                = new Dictionary<string, string>();
+
+            foreach (Toolset toolset in projectCollection.Toolsets)
+            {
+                foreach (KeyValuePair<string, ProjectPropertyInstance> properties in toolset.Properties)
+                {
+                    toolsetProperties[properties.Value.Name] = properties.Value.EvaluatedValue;
+                }
+            }
+
+            toolsetProperties.ShouldContainKey("MSBuildSDKsPath");
+            toolsetProperties.ShouldContainKey("RoslynTargetsPath");
+            toolsetProperties["MSBuildSDKsPath"].ShouldNotBeNullOrEmpty();
+            toolsetProperties["RoslynTargetsPath"].ShouldNotBeNullOrEmpty();
+
+            toolsetProperties.ShouldContainKey("VCTargetsPath");
+            toolsetProperties.ShouldContainKey("MSBuildToolsRoot");
+            toolsetProperties.ShouldContainKey("MSBuildExtensionsPath");
+            toolsetProperties["VCTargetsPath"].ShouldNotBeNullOrEmpty();
+            toolsetProperties["MSBuildToolsRoot"].ShouldNotBeNullOrEmpty();
+            toolsetProperties["MSBuildExtensionsPath"].ShouldNotBeNullOrEmpty();
+        }
+    }
+}
+#endif
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index 756dffdbd0e..52f699668fb 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -16,6 +16,7 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <PackageReference Include="System.Configuration.ConfigurationManager" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
     <PackageReference Include="NuGet.Frameworks" >
@@ -44,17 +45,12 @@
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MonoBuild)' == 'true'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=net5.0</SetTargetFramework>
     </ProjectReference>
-
-    <Reference Include="System.Configuration" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
   <ItemGroup>
     <Compile Include="..\Shared\FxCopExclusions\Microsoft.Build.Shared.Suppressions.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    
-    <Compile Remove="Definition\ToolsetConfigurationReaderTestHelper.cs" />
-    <Compile Include="Definition\ToolsetConfigurationReaderTestHelper.cs" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
 
     <Compile Include="..\Shared\UnitTests\BuildEventArgsExtension.cs">
       <!-- Extension methods -->
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index f7d7eca1c2c..df36e0dfd2e 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -818,16 +818,7 @@ public void EngineShouldHandleExceptionsFromCachePlugin(ExceptionLocations excep
                         </Target>
                     </Project>".Cleanup());
 
-            foreach (var enumValue in Enum.GetValues(typeof(ExceptionLocations)))
-            {
-                var typedValue = (ExceptionLocations) enumValue;
-                if (exceptionLocations.HasFlag(typedValue))
-                {
-                    var exceptionLocation = typedValue.ToString();
-                    _env.SetEnvironmentVariable(exceptionLocation, "1");
-                    _output.WriteLine($"Set exception location: {exceptionLocation}");
-                }
-            }
+            SetEnvironmentForExceptionLocations(exceptionLocations);
 
             using var buildSession = new Helpers.BuildManagerSession(
                 _env,
@@ -880,5 +871,62 @@ public void EngineShouldHandleExceptionsFromCachePlugin(ExceptionLocations excep
                 logger.FullLog.ShouldContain($"{AssemblyMockCache}: EndBuildAsync");
             }
         }
+
+        [Fact]
+        public void EndBuildShouldGetCalledOnceWhenItThrowsExceptionsFromGraphBuilds()
+        {
+            _env.DoNotLaunchDebugger();
+
+            var project = _env.CreateFile(
+                "1.proj",
+                @$"
+                    <Project>
+                        <ItemGroup>
+                            <{ItemTypeNames.ProjectCachePlugin} Include=`{SamplePluginAssemblyPath.Value}` />
+                        </ItemGroup>
+                        <Target Name=`Build`>
+                            <Message Text=`Hello EngineShouldHandleExceptionsFromCachePlugin` Importance=`High` />
+                        </Target>
+                    </Project>".Cleanup());
+
+            SetEnvironmentForExceptionLocations(ExceptionLocations.EndBuildAsync);
+
+            using var buildSession = new Helpers.BuildManagerSession(
+                _env,
+                new BuildParameters
+                {
+                    UseSynchronousLogging = true
+                });
+
+            var logger = buildSession.Logger;
+
+            GraphBuildResult? buildResult = null;
+            Should.NotThrow(
+                () =>
+                {
+                    buildResult = buildSession.BuildGraph(new ProjectGraph(project.Path));
+                });
+
+            buildResult!.OverallResult.ShouldBe(BuildResultCode.Failure);
+            buildResult.Exception.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
+
+            buildSession.Dispose();
+
+            Regex.Matches(logger.FullLog, $"{nameof(AssemblyMockCache)}: EndBuildAsync").Count.ShouldBe(1);
+        }
+
+        private void SetEnvironmentForExceptionLocations(ExceptionLocations exceptionLocations)
+        {
+            foreach (var enumValue in Enum.GetValues(typeof(ExceptionLocations)))
+            {
+                var typedValue = (ExceptionLocations) enumValue;
+                if (exceptionLocations.HasFlag(typedValue))
+                {
+                    var exceptionLocation = typedValue.ToString();
+                    _env.SetEnvironmentVariable(exceptionLocation, "1");
+                    _output.WriteLine($"Set exception location: {exceptionLocation}");
+                }
+            }
+        }
     }
 }
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index eb56df3a007..15344781043 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -272,6 +272,132 @@ private string GetTestProject(bool? treatAllWarningsAsErrors = null, string warn
             </Project>";
         }
 
+        [Theory]
+        
+        [InlineData("MSB1235", "MSB1234", "MSB1234", "MSB1234", false)] // Log MSB1234, treat as error via MSBuildWarningsAsErrors
+        [InlineData("MSB1235", "", "MSB1234", "MSB1234", true)] // Log MSB1234, expect MSB1234 as error via MSBuildTreatWarningsAsErrors
+        [InlineData("MSB1234", "MSB1234", "MSB1234", "MSB4181", true)]// Log MSB1234, MSBuildWarningsAsMessages takes priority
+        public void WarningsAsErrorsAndMessages_Tests(string WarningsAsMessages,
+                                                      string WarningsAsErrors,
+                                                      string WarningToLog,
+                                                      string LogShouldContain,
+                                                      bool allWarningsAreErrors = false)
+        {
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <UsingTask TaskName = ""CustomLogAndReturnTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <PropertyGroup>
+                        <MSBuildTreatWarningsAsErrors>{allWarningsAreErrors}</MSBuildTreatWarningsAsErrors>
+                        <MSBuildWarningsAsMessages>{WarningsAsMessages}</MSBuildWarningsAsMessages>
+                        <MSBuildWarningsAsErrors>{WarningsAsErrors}</MSBuildWarningsAsErrors>
+                    </PropertyGroup>
+                    <Target Name='Build'>
+                        <CustomLogAndReturnTask Return=""true"" ReturnHasLoggedErrors=""true"" WarningCode=""{WarningToLog}""/>
+                        <ReturnFailureWithoutLoggingErrorTask/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectFailure();
+
+                logger.WarningCount.ShouldBe(0);
+                logger.ErrorCount.ShouldBe(1);
+
+                logger.AssertLogContains(LogShouldContain);
+            }
+        }
+
+        /// <summary>
+        /// Item1 and Item2 log warnings and continue, item 3 logs a warn-> error and prevents item 4 from running in the batched build.
+        /// </summary>
+        [Fact]
+        public void TaskLogsWarningAsError_BatchedBuild()
+        {
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <UsingTask TaskName = ""CustomLogAndReturnTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <PropertyGroup>
+                        <MSBuildWarningsAsErrors>MSB1234</MSBuildWarningsAsErrors>
+                    </PropertyGroup>
+                    <ItemGroup>
+                        <SomeItem Include=""Item1"">
+                            <Return>true</Return>
+                            <ReturnHasLoggedErrors>true</ReturnHasLoggedErrors>
+                            <WarningCode>MSB1235</WarningCode>
+                        </SomeItem>
+                        <SomeItem Include=""Item2"">
+                            <Return>true</Return>
+                            <ReturnHasLoggedErrors>true</ReturnHasLoggedErrors>
+                            <WarningCode>MSB1236</WarningCode>
+                        </SomeItem>
+                        <SomeItem Include=""Item3"">
+                            <Return>true</Return>
+                            <ReturnHasLoggedErrors>true</ReturnHasLoggedErrors>
+                            <WarningCode>MSB1234</WarningCode>
+                        </SomeItem>
+                        <SomeItem Include=""Item4"">
+                            <Return>true</Return>
+                            <ReturnHasLoggedErrors>true</ReturnHasLoggedErrors>
+                            <WarningCode>MSB1237</WarningCode>
+                        </SomeItem>
+                    </ItemGroup>
+                    <Target Name='Build'>
+                        <CustomLogAndReturnTask Sources=""@(SomeItem)"" Return=""true"" ReturnHasLoggedErrors=""true"" WarningCode=""%(WarningCode)""/>
+                        <ReturnFailureWithoutLoggingErrorTask/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectFailure();
+
+                logger.WarningCount.ShouldBe(2);
+                logger.ErrorCount.ShouldBe(1);
+
+                // The build should STOP when a task logs an error, make sure ReturnFailureWithoutLoggingErrorTask doesn't run. 
+                logger.AssertLogDoesntContain("MSB1237");
+            }
+        }
+
+        /// <summary>
+        /// Task logs MSB1234 as a warning and returns true.
+        /// Test behavior with MSBuildWarningsAsErrors & MSBuildTreatWarningsAsErrors
+        /// Both builds should continue despite logging errors.
+        /// </summary>
+        [Theory]
+        [InlineData("MSB1234", false, 1, 1)]
+        [InlineData("MSB0000", true, 0, 2)]
+        public void TaskReturnsTrue_Tests(string warningsAsErrors, bool treatAllWarningsAsErrors, int warningCountShouldBe, int errorCountShouldBe)
+        {
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <UsingTask TaskName = ""CustomLogAndReturnTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <PropertyGroup>
+                        <MSBuildTreatWarningsAsErrors>{treatAllWarningsAsErrors}</MSBuildTreatWarningsAsErrors>
+                        <MSBuildWarningsAsErrors>{warningsAsErrors}</MSBuildWarningsAsErrors>
+                    </PropertyGroup>
+                    <Target Name='Build'>
+                        <CustomLogAndReturnTask Return=""true"" WarningCode=""MSB1234""/>
+                        <CustomLogAndReturnTask Return=""true"" WarningCode=""MSB1235""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectFailure();
+
+                logger.WarningCount.ShouldBe(warningCountShouldBe);
+                logger.ErrorCount.ShouldBe(errorCountShouldBe);
+
+                // The build will continue so we should see the warning MSB1235
+                logger.AssertLogContains("MSB1235");
+            }
+        }
+
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ShouldCauseBuildFailure()
         {
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 271454fb2a9..f11fec9e489 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -462,6 +462,7 @@ public void BeginBuild(BuildParameters parameters)
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildResult, BuildResult.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.NodeShutdown, NodeShutdown.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.ResolveSdkRequest, SdkResolverRequest.FactoryForDeserialization, SdkResolverService as INodePacketHandler);
+                _nodeManager.RegisterPacketHandler(NodePacketType.ResourceRequest, ResourceRequest.FactoryForDeserialization, this);
 
                 if (_threadException != null)
                 {
@@ -1537,6 +1538,11 @@ private void ProcessPacket(int node, INodePacket packet)
                         HandleResult(node, result);
                         break;
 
+                    case NodePacketType.ResourceRequest:
+                        ResourceRequest request = ExpectPacketType<ResourceRequest>(packet, NodePacketType.ResourceRequest);
+                        HandleResourceRequest(node, request);
+                        break;
+
                     case NodePacketType.NodeShutdown:
                         // Remove the node from the list of active nodes.  When they are all done, we have shut down fully
                         NodeShutdown shutdownPacket = ExpectPacketType<NodeShutdown>(packet, NodePacketType.NodeShutdown);
@@ -1945,8 +1951,14 @@ public void Dispose()
 
                 lock (_buildManager._syncLock)
                 {
-                    _buildManager._projectCacheService?.Result.ShutDown().GetAwaiter().GetResult();
-                    _buildManager._projectCacheService = null;
+                    try
+                    {
+                        _buildManager._projectCacheService?.Result.ShutDown().GetAwaiter().GetResult();
+                    }
+                    finally
+                    {
+                        _buildManager._projectCacheService = null;
+                    }
                 }
             }
         }
@@ -2168,6 +2180,30 @@ private void HandleNewRequest(int node, BuildRequestBlocker blocker)
             PerformSchedulingActions(response);
         }
 
+        /// <summary>
+        /// Handles a resource request coming from a node.
+        /// </summary>
+        private void HandleResourceRequest(int node, ResourceRequest request)
+        {
+            if (request.IsResourceAcquire)
+            {
+                // Resource request requires a response and may be blocking. Our continuation is effectively a callback
+                // to be called once at least one core becomes available.
+                _scheduler.RequestCores(request.GlobalRequestId, request.NumCores, request.IsBlocking).ContinueWith((Task<int> task) =>
+                {
+                    var response = new ResourceResponse(request.GlobalRequestId, task.Result);
+                    _nodeManager.SendData(node, response);
+                }, TaskContinuationOptions.ExecuteSynchronously);
+            }
+            else
+            {
+                // Resource release is a one-way call, no response is expected. We release the cores as instructed
+                // and kick the scheduler because there may be work waiting for cores to become available.
+                IEnumerable<ScheduleResponse> response = _scheduler.ReleaseCores(request.GlobalRequestId, request.NumCores);
+                PerformSchedulingActions(response);
+            }
+        }
+
         /// <summary>
         /// Handles a configuration request coming from a node.
         /// </summary>
@@ -2417,10 +2453,8 @@ private void ReportResultsToSubmission(BuildResult result)
             lock (_syncLock)
             {
                 // The build submission has not already been completed.
-                if (_buildSubmissions.ContainsKey(result.SubmissionId))
+                if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmission submission))
                 {
-                    BuildSubmission submission = _buildSubmissions[result.SubmissionId];
-
                     /* If the request failed because we caught an exception from the loggers, we can assume we will receive no more logging messages for
                      * this submission, therefore set the logging as complete. InternalLoggerExceptions are unhandled exceptions from the logger. If the logger author does
                      * not handle an exception the eventsource wraps all exceptions (except a logging exception) into an internal logging exception.
@@ -2453,9 +2487,8 @@ private void ReportResultsToSubmission(GraphBuildResult result)
             lock (_syncLock)
             {
                 // The build submission has not already been completed.
-                if (_graphBuildSubmissions.ContainsKey(result.SubmissionId))
+                if (_graphBuildSubmissions.TryGetValue(result.SubmissionId, out GraphBuildSubmission submission))
                 {
-                    GraphBuildSubmission submission = _graphBuildSubmissions[result.SubmissionId];
                     submission.CompleteResults(result);
 
                     _overallBuildSuccess &= submission.BuildResult.OverallResult == BuildResultCode.Success;
@@ -2545,7 +2578,11 @@ private NodeConfiguration GetNodeConfiguration()
 #if FEATURE_APPDOMAIN
                 , AppDomain.CurrentDomain.SetupInformation
 #endif
-                , new LoggingNodeConfiguration(loggingService.IncludeEvaluationMetaprojects, loggingService.IncludeEvaluationProfile, loggingService.IncludeTaskInputs)
+                , new LoggingNodeConfiguration(
+                    loggingService.IncludeEvaluationMetaprojects,
+                    loggingService.IncludeEvaluationProfile,
+                    loggingService.IncludeEvaluationPropertiesAndItems,
+                    loggingService.IncludeTaskInputs)
                 );
             }
 
diff --git a/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs b/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
index b53e331f9b0..34b563ae053 100644
--- a/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
+++ b/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
@@ -104,10 +104,7 @@ internal void UnregisterSubmissionForLegacyThread(int submissionId)
             {
                 ErrorUtilities.VerifyThrow(_legacyThreadingEventsById.ContainsKey(submissionId), "Submission {0} should have been previously registered with LegacyThreadingData", submissionId);
 
-                if (_legacyThreadingEventsById.ContainsKey(submissionId))
-                {
-                    _legacyThreadingEventsById.Remove(submissionId);
-                }
+                _legacyThreadingEventsById.Remove(submissionId);
             }
         }
 
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 05e6671a6d6..1038643d11f 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -164,6 +164,11 @@ internal BuildRequestEngine()
         /// </summary>
         public event EngineExceptionDelegate OnEngineException;
 
+        /// <summary>
+        /// Raised when resources are requested.
+        /// </summary>
+        public event ResourceRequestDelegate OnResourceRequest;
+
         /// <summary>
         /// Returns the current engine status.
         /// </summary>
@@ -454,6 +459,21 @@ public void UnblockBuildRequest(BuildRequestUnblocker unblocker)
                 isLastTask: false);
         }
 
+        /// <summary>
+        /// Notifies the engine of a resource response granting the node resources.
+        /// </summary>
+        /// <param name="response">The resource response.</param>
+        public void GrantResources(ResourceResponse response)
+        {
+            QueueAction(
+                () =>
+                {
+                    BuildRequestEntry entry = _requestsByGlobalRequestId[response.GlobalRequestId];
+                    entry.Builder.ContinueRequestWithResources(response);
+                },
+                isLastTask: false);
+        }
+
         /// <summary>
         /// Reports a configuration response to the request, allowing it to satisfy outstanding requests.
         /// <seealso cref="BuildRequestConfigurationResponse"/>
@@ -773,6 +793,7 @@ private void EvaluateRequestStates()
                 // Shut it down because we already have enough in reserve.
                 completedEntry.Builder.OnNewBuildRequests -= Builder_OnNewBuildRequests;
                 completedEntry.Builder.OnBuildRequestBlocked -= Builder_OnBlockedRequest;
+                completedEntry.Builder.OnResourceRequest -= Builder_OnResourceRequest;
                 ((IBuildComponent)completedEntry.Builder).ShutdownComponent();
 
                 BuildRequestConfiguration configuration = _configCache[completedEntry.Request.ConfigurationId];
@@ -914,6 +935,7 @@ private IRequestBuilder GetRequestBuilder()
             // state changes.
             builder.OnNewBuildRequests += Builder_OnNewBuildRequests;
             builder.OnBuildRequestBlocked += Builder_OnBlockedRequest;
+            builder.OnResourceRequest += Builder_OnResourceRequest;
 
             return builder;
         }
@@ -979,6 +1001,14 @@ private void Builder_OnBlockedRequest(BuildRequestEntry issuingEntry, int blocki
                 isLastTask: false);
         }
 
+        /// <summary>
+        /// Called when the request builder needs to request resources.
+        /// </summary>
+        private void Builder_OnResourceRequest(ResourceRequest request)
+        {
+            OnResourceRequest?.Invoke(request);
+        }
+
         #endregion
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
index c8301762adc..fec15006b64 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
@@ -230,12 +230,12 @@ public bool ResolveConfigurationRequest(int unresolvedConfigId, int configId)
         {
             lock (GlobalLock)
             {
-                if (_unresolvedConfigurations?.ContainsKey(unresolvedConfigId) != true)
+                List<BuildRequest> requests = null;
+                if (_unresolvedConfigurations?.TryGetValue(unresolvedConfigId, out requests) != true)
                 {
                     return false;
                 }
 
-                List<BuildRequest> requests = _unresolvedConfigurations[unresolvedConfigId];
                 _unresolvedConfigurations.Remove(unresolvedConfigId);
 
                 if (_unresolvedConfigurations.Count == 0)
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs
index 75cc6ef4dc9..13d40bd7c19 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/IBuildRequestEngine.cs
@@ -39,6 +39,12 @@ namespace Microsoft.Build.BackEnd
     /// <param name="config">The configuration needing an ID</param>
     internal delegate void NewConfigurationRequestDelegate(BuildRequestConfiguration config);
 
+    /// <summary>
+    /// Callback for event raised when a resource is requested.
+    /// </summary>
+    /// <param name="request">The resources being requested</param>
+    internal delegate void ResourceRequestDelegate(ResourceRequest request);
+
     /// <summary>
     /// Callback for event raised when there is an unhandled exception in the engine.
     /// </summary>
@@ -110,6 +116,11 @@ internal interface IBuildRequestEngine
         /// </summary>
         event NewConfigurationRequestDelegate OnNewConfigurationRequest;
 
+        /// <summary>
+        /// Raised when resources are requested.
+        /// </summary>
+        event ResourceRequestDelegate OnResourceRequest;
+
         /// <summary>
         /// Raised when an unhandled exception occurs in the engine.
         /// </summary>
@@ -154,6 +165,12 @@ internal interface IBuildRequestEngine
         /// <param name="unblocker">The unblocking information</param>
         void UnblockBuildRequest(BuildRequestUnblocker unblocker);
 
+        /// <summary>
+        /// Notifies the engine of a resource response granting the node resources.
+        /// </summary>
+        /// <param name="response">The resource response.</param>
+        void GrantResources(ResourceResponse response);
+
         /// <summary>
         /// Notifies the engine of a configuration response packet, typically generated by the Build Request Manager.  This packet is used to set
         /// the global configuration ID for a specific configuration.
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 0cf24b8aa14..ee236fac998 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -55,15 +55,15 @@ public void AddResult(BuildResult result)
         {
             lock (_resultsByConfiguration)
             {
-                if (_resultsByConfiguration.ContainsKey(result.ConfigurationId))
+                if (_resultsByConfiguration.TryGetValue(result.ConfigurationId, out BuildResult buildResult))
                 {
-                    if (Object.ReferenceEquals(_resultsByConfiguration[result.ConfigurationId], result))
+                    if (Object.ReferenceEquals(buildResult, result))
                     {
                         // Merging results would be meaningless as we would be merging the object with itself.
                         return;
                     }
 
-                    _resultsByConfiguration[result.ConfigurationId].MergeResults(result);
+                    buildResult.MergeResults(result);
                 }
                 else
                 {
@@ -105,9 +105,8 @@ public BuildResult GetResultForRequest(BuildRequest request)
 
             lock (_resultsByConfiguration)
             {
-                if (_resultsByConfiguration.ContainsKey(request.ConfigurationId))
+                if (_resultsByConfiguration.TryGetValue(request.ConfigurationId, out BuildResult result))
                 {
-                    BuildResult result = _resultsByConfiguration[request.ConfigurationId];
                     foreach (string target in request.Targets)
                     {
                         ErrorUtilities.VerifyThrow(result.HasResultsForTarget(target), "No results in cache for target " + target);
@@ -159,10 +158,8 @@ public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> co
 
             lock (_resultsByConfiguration)
             {
-                if (_resultsByConfiguration.ContainsKey(request.ConfigurationId))
+                if (_resultsByConfiguration.TryGetValue(request.ConfigurationId, out BuildResult allResults))
                 {
-                    BuildResult allResults = _resultsByConfiguration[request.ConfigurationId];
-
                     // Check for targets explicitly specified.
                     bool explicitTargetsSatisfied = CheckResults(allResults, request.Targets, response.ExplicitTargetsToBuild, skippedResultsDoNotCauseCacheMiss);
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 0889994b493..7528431810a 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Buffers.Binary;
 using System.Collections.Generic;
 using System.Collections.Concurrent;
 using System.Globalization;
@@ -738,7 +739,7 @@ public async Task RunPacketReadLoopAsync()
                     }
 
                     NodePacketType packetType = (NodePacketType)_headerByte[0];
-                    int packetLength = BitConverter.ToInt32(_headerByte, 1);
+                    int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(_headerByte, 1, 4));
 
                     _readBufferMemoryStream.SetLength(packetLength);
                     byte[] packetData = _readBufferMemoryStream.GetBuffer();
@@ -1027,7 +1028,7 @@ private void HeaderReadComplete(IAsyncResult result)
                     return;
                 }
 
-                int packetLength = BitConverter.ToInt32(_headerByte, 1);
+                int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(_headerByte, 1, 4));
                 MSBuildEventSource.Log.PacketReadSize(packetLength);
 
                 // Ensures the buffer is at least this length.
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index ef746ed27d7..2a917d6eaee 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -265,9 +265,9 @@ public void UnregisterPacketHandler(NodePacketType packetType)
         /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
         public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
         {
-            if (_nodeIdToPacketFactory.ContainsKey(nodeId))
+            if (_nodeIdToPacketFactory.TryGetValue(nodeId, out INodePacketFactory nodePacketFactory))
             {
-                _nodeIdToPacketFactory[nodeId].DeserializeAndRoutePacket(nodeId, packetType, translator);
+                nodePacketFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
             }
             else
             {
@@ -282,9 +282,9 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
         /// <param name="packet">The packet to route.</param>
         public void RoutePacket(int nodeId, INodePacket packet)
         {
-            if (_nodeIdToPacketFactory.ContainsKey(nodeId))
+            if (_nodeIdToPacketFactory.TryGetValue(nodeId, out INodePacketFactory nodePacketFactory))
             {
-                _nodeIdToPacketFactory[nodeId].RoutePacket(nodeId, packet);
+                nodePacketFactory.RoutePacket(nodeId, packet);
             }
             else
             {
@@ -304,9 +304,9 @@ public void RoutePacket(int nodeId, INodePacket packet)
         /// <param name="packet">The packet.</param>
         public void PacketReceived(int node, INodePacket packet)
         {
-            if (_nodeIdToPacketHandler.ContainsKey(node))
+            if (_nodeIdToPacketHandler.TryGetValue(node, out INodePacketHandler packetHandler))
             {
-                _nodeIdToPacketHandler[node].PacketReceived(node, packet);
+                packetHandler.PacketReceived(node, packet);
             }
             else
             {
diff --git a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
index b2fb277ba84..db2e6aecb4f 100644
--- a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
@@ -1,8 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections;
+using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd.Components.Logging
@@ -31,10 +34,10 @@ public void LogProjectEvaluationStarted()
         /// <summary>
         /// Log that the project has finished
         /// </summary>
-        internal void LogProjectEvaluationFinished()
+        internal void LogProjectEvaluationFinished(IEnumerable globalProperties, IEnumerable properties, IEnumerable items, ProfilerResult? profilerResult)
         {
             ErrorUtilities.VerifyThrow(IsValid, "invalid");
-            LoggingService.LogProjectEvaluationFinished(BuildEventContext, _projectFile);
+            LoggingService.LogProjectEvaluationFinished(BuildEventContext, _projectFile, globalProperties, properties, items, profilerResult);
             IsValid = false;
         }
     }
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 4c321e4a15c..97b7512d14e 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -18,7 +18,7 @@ internal sealed class EventSourceSink :
 #if FEATURE_APPDOMAIN
         MarshalByRefObject,
 #endif
-        IEventSource3, IBuildEventSink
+        IEventSource4, IBuildEventSink
     {
         #region Events
 
@@ -138,7 +138,6 @@ public bool IncludeEvaluationMetaprojects
             private set;
         }
 
-
         /// <summary>
         /// Should evaluation events include profiling information?
         /// </summary>
@@ -157,6 +156,16 @@ public bool IncludeTaskInputs
             private set;
         }
 
+        /// <summary>
+        /// Determines whether properties and items should be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>
+        /// </summary>
+        public bool IncludeEvaluationPropertiesAndItems
+        {
+            get;
+            private set;
+        }
+
         #endregion
 
         #region Methods
@@ -180,6 +189,15 @@ void IEventSource3.IncludeTaskInputs()
 
         #endregion
 
+        #region IEventSource4 Methods
+
+        void IEventSource4.IncludeEvaluationPropertiesAndItems()
+        {
+            IncludeEvaluationPropertiesAndItems = true;
+        }
+
+        #endregion
+
         #region IEventSink Methods
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 42feb90220b..ef3db37b022 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
 
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
@@ -187,6 +188,16 @@ bool IncludeEvaluationProfile
             set;
         }
 
+        /// <summary>
+        /// Should properties and items be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>?
+        /// </summary>
+        bool IncludeEvaluationPropertiesAndItems
+        {
+            get;
+            set;
+        }
+
         /// <summary>
         /// Should task events include task inputs?
         /// </summary>
@@ -219,6 +230,20 @@ bool IncludeTaskInputs
         /// <returns><code>true</code> if the build submission logged an errors, otherwise <code>false</code>.</returns>
         bool HasBuildSubmissionLoggedErrors(int submissionId);
 
+        /// <summary>
+        /// Returns a hashset of warnings to be logged as errors for the specified project instance ID.
+        /// </summary>
+        /// <param name="context">The build context through which warnings will be logged as errors.</param>
+        /// <returns>A Hashset containing warning codes that should be treated as errors.</returns>
+        ICollection<string> GetWarningsAsErrors(BuildEventContext context);
+
+        /// <summary>
+        /// Returns a hashset of warnings to be logged as messages for the specified project instance ID.
+        /// </summary>
+        /// <param name="context">The build context through which warnings will be logged as errors.</param>
+        /// <returns>A Hashset containing warning codes that should be treated as messages.</returns>
+        ICollection<string> GetWarningsAsMessages(BuildEventContext context);
+
         #region Register
 
         /// <summary>
@@ -413,8 +438,18 @@ bool IncludeTaskInputs
         /// </summary>
         /// <param name="projectEvaluationEventContext">Event context for the project.</param>
         /// <param name="projectFile">Project file being built</param>
+        /// <param name="globalProperties">Global properties used for the evaluation.</param>
+        /// <param name="properties">Properties produced by the evaluation.</param>
+        /// <param name="items">Items produced by the evaluation.</param>
+        /// <param name="profilerResult">Profiler results if evaluation profiling was enabled.</param>
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
-        void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEventContext, string projectFile);
+        void LogProjectEvaluationFinished(
+            BuildEventContext projectEvaluationEventContext,
+            string projectFile,
+            IEnumerable globalProperties,
+            IEnumerable properties,
+            IEnumerable items,
+            ProfilerResult? profilerResult);
 
         /// <summary>
         /// Log that a project has started
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 85c95d728d1..a96a169fb18 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -196,6 +196,12 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// </summary>
         private bool? _includeEvaluationProfile;
 
+        /// <summary>
+        /// Whether properties and items should be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>.
+        /// </summary>
+        private bool? _includeEvaluationPropertiesAndItems;
+
         /// <summary>
         /// Whether to include task inputs in task events.
         /// </summary>
@@ -285,6 +291,10 @@ protected LoggingService(LoggerMode loggerMode, int nodeId)
                 CreateLoggingEventQueue();
             }
 
+            // Ensure the static constructor of ItemGroupLoggingHelper runs.
+            // It is important to ensure the Message delegate on TaskParameterEventArgs is set.
+            _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
+
             _serviceState = LoggingServiceState.Instantiated;
         }
 
@@ -498,6 +508,16 @@ public bool IncludeTaskInputs
             set => _includeTaskInputs = value;
         }
 
+        /// <summary>
+        /// Should properties and items be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>?
+        /// </summary>
+        public bool IncludeEvaluationPropertiesAndItems
+        {
+            get => _includeEvaluationPropertiesAndItems ??= _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationPropertiesAndItems);
+            set => _includeEvaluationPropertiesAndItems = value;
+        }
+
         /// <summary>
         /// Determines if the specified submission has logged an errors.
         /// </summary>
@@ -515,6 +535,50 @@ public bool HasBuildSubmissionLoggedErrors(int submissionId)
             return _buildSubmissionIdsThatHaveLoggedErrors?.Contains(submissionId) == true;
         }
 
+        /// <summary>
+        /// Returns a hashset of warnings to be logged as errors for the specified build context.
+        /// </summary>
+        /// <param name="context">The build context through which warnings will be logged as errors.</param>
+        /// <returns>
+        /// </returns>
+        public ICollection<string> GetWarningsAsErrors(BuildEventContext context)
+        {
+            int key = GetWarningsAsErrorOrMessageKey(context);
+
+            if (_warningsAsErrorsByProject != null && _warningsAsErrorsByProject.TryGetValue(key, out ISet<string> warningsAsErrors))
+            {
+                if (WarningsAsErrors != null)
+                {
+                    warningsAsErrors.UnionWith(WarningsAsErrors);
+                }
+
+                return warningsAsErrors;
+            }
+            else
+            {
+                return WarningsAsErrors;
+            }
+        }
+
+        public ICollection<string> GetWarningsAsMessages(BuildEventContext context)
+        {
+            int key = GetWarningsAsErrorOrMessageKey(context);
+
+            if (_warningsAsMessagesByProject != null && _warningsAsMessagesByProject.TryGetValue(key, out ISet<string> warningsAsMessages))
+            {
+                if (WarningsAsMessages != null)
+                {
+                    warningsAsMessages.UnionWith(WarningsAsMessages);
+                }
+
+                return warningsAsMessages;
+            }
+            else
+            {
+                return WarningsAsMessages;
+            }
+        }
+
         public void AddWarningsAsErrors(BuildEventContext buildEventContext, ISet<string> codes)
         {
             lock (_lockObject)
@@ -1106,7 +1170,11 @@ internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
                 {
                     ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(projectStartedEventArgs.ProjectId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
                     BuildRequestConfiguration buildRequestConfiguration = _configCache.Value[projectStartedEventArgs.ProjectId];
-                    s_projectStartedEventArgsGlobalProperties.Value.SetValue(projectStartedEventArgs, buildRequestConfiguration.GlobalProperties.ToDictionary(), null);
+                    if (!IncludeEvaluationPropertiesAndItems)
+                    {
+                        s_projectStartedEventArgsGlobalProperties.Value.SetValue(projectStartedEventArgs, buildRequestConfiguration.GlobalProperties.ToDictionary(), null);
+                    }
+
                     s_projectStartedEventArgsToolsVersion.Value.SetValue(projectStartedEventArgs, buildRequestConfiguration.ToolsVersion, null);
                 }
             }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index b4fb5ad461c..6dcf39925d2 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -6,6 +6,7 @@
 using System.Collections.Generic;
 using System.IO;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
@@ -513,8 +514,18 @@ public void LogProjectEvaluationStarted(BuildEventContext projectEvaluationEvent
         /// </summary>
         /// <param name="projectEvaluationEventContext">Event context for the project.</param>
         /// <param name="projectFile">Project file being built</param>
+        /// <param name="globalProperties">Global properties used for the evaluation.</param>
+        /// <param name="properties">Properties produced by the evaluation.</param>
+        /// <param name="items">Items produced by the evaluation.</param>
+        /// <param name="profilerResult">Profiler results if evaluation profiling was enabled.</param>
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
-        public void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEventContext, string projectFile)
+        public void LogProjectEvaluationFinished(
+            BuildEventContext projectEvaluationEventContext,
+            string projectFile,
+            IEnumerable globalProperties,
+            IEnumerable properties,
+            IEnumerable items,
+            ProfilerResult? profilerResult)
         {
             lock (_lockObject)
             {
@@ -524,7 +535,11 @@ public void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEven
                     new ProjectEvaluationFinishedEventArgs(ResourceUtilities.GetResourceString("EvaluationFinished"), projectFile)
                     {
                         BuildEventContext = projectEvaluationEventContext,
-                        ProjectFile = projectFile
+                        ProjectFile = projectFile,
+                        ProfilerResult = profilerResult,
+                        GlobalProperties = globalProperties,
+                        Properties = properties,
+                        Items = items
                     };
                 ProcessLoggingEvent(buildEvent);
             }
@@ -579,17 +594,24 @@ public BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventConte
 
                 ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(projectInstanceId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
                 var buildRequestConfiguration = _configCache.Value[projectInstanceId];
-                ProjectStartedEventArgs buildEvent = new ProjectStartedEventArgs
+
+                IDictionary<string, string> globalProperties = null;
+                if (!IncludeEvaluationPropertiesAndItems)
+                {
+                    globalProperties = buildRequestConfiguration.GlobalProperties.ToDictionary();
+                }
+
+                var buildEvent = new ProjectStartedEventArgs
                     (
                         projectInstanceId,
                         message,
-                        null,       // no help keyword
+                        helpKeyword: null,
                         projectFile,
                         targetNames,
                         properties,
                         items,
                         parentBuildEventContext,
-                        buildRequestConfiguration.GlobalProperties.ToDictionary(),
+                        globalProperties,
                         buildRequestConfiguration.ToolsVersion
                     );
                 buildEvent.BuildEventContext = projectBuildEventContext;
@@ -626,12 +648,10 @@ public void LogProjectFinished(BuildEventContext projectBuildEventContext, strin
                 ProcessLoggingEvent(buildEvent);
 
                 // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
-                if (!_projectFileMap.ContainsKey(projectBuildEventContext.ProjectContextId))
+                if (!_projectFileMap.Remove(projectBuildEventContext.ProjectContextId))
                 {
                     ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should be in the ID-to-file mapping!", projectBuildEventContext.ProjectContextId, projectFile);
                 }
-
-                _projectFileMap.Remove(projectBuildEventContext.ProjectContextId);
             }
         }
 
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index be1a86b0229..846c0b3a643 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Shared;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.BackEnd.Logging
 {
@@ -85,7 +86,9 @@ private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submiss
             string[] propertiesToSerialize = LoggingService.PropertiesToSerialize;
 
             // If we are only logging critical events lets not pass back the items or properties
-            if (!LoggingService.OnlyLogCriticalEvents && (!LoggingService.RunningOnRemoteNode || LoggingService.SerializeAllProperties))
+            if (!LoggingService.OnlyLogCriticalEvents &&
+                !LoggingService.IncludeEvaluationPropertiesAndItems &&
+                (!LoggingService.RunningOnRemoteNode || LoggingService.SerializeAllProperties))
             {
                 if (projectProperties != null)
                 {
@@ -101,7 +104,10 @@ private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submiss
                 items = new ProjectItemInstanceEnumeratorProxy(projectItemsEnumerator);
             }
 
-            if (projectProperties != null && propertiesToSerialize?.Length > 0 && !LoggingService.SerializeAllProperties)
+            if (projectProperties != null &&
+                !LoggingService.IncludeEvaluationPropertiesAndItems &&
+                propertiesToSerialize?.Length > 0 &&
+                !LoggingService.SerializeAllProperties)
             {
                 PropertyDictionary<ProjectPropertyInstance> projectPropertiesToSerialize = new PropertyDictionary<ProjectPropertyInstance>();
                 foreach (string propertyToGet in propertiesToSerialize)
diff --git a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
index 6daf7608f20..efde35dd8af 100644
--- a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
@@ -138,6 +138,11 @@ internal TargetOutputItemsInstanceEnumeratorProxy(IEnumerable<TaskItem> backingI
                 _backingItems = backingItems;
             }
 
+            // For performance reasons we need to expose the raw items to BinaryLogger
+            // as we know we're not going to mutate anything. This allows us to bypass DeepClone
+            // for each item
+            internal IEnumerable<TaskItem> BackingItems => _backingItems;
+
             /// <summary>
             /// Returns an enumerator that provides copies of the items
             /// in the backing store.
diff --git a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
index c953ec6f226..6dc62c389ce 100644
--- a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
@@ -1,10 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
+using System;
+using System.Collections.Generic;
 
 namespace Microsoft.Build.BackEnd.Logging
 {
@@ -144,5 +145,15 @@ internal void LogTaskWarningFromException(Exception exception, BuildEventFileInf
             ErrorUtilities.VerifyThrow(IsValid, "must be valid");
             LoggingService.LogTaskWarningFromException(BuildEventContext, exception, file, taskName);
         }
+
+        internal ICollection<string> GetWarningsAsErrors()
+        {
+            return LoggingService.GetWarningsAsErrors(BuildEventContext);
+        }
+
+        internal ICollection<string> GetWarningsAsMessages()
+        {
+            return LoggingService.GetWarningsAsMessages(BuildEventContext);
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
index af194e45728..7f8a69ecbbd 100644
--- a/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
@@ -63,9 +63,9 @@ private CacheResult(
             ProxyTargets = proxyTargets;
         }
 
-        internal CacheResultType ResultType { get; }
-        internal BuildResult? BuildResult { get; }
-        internal ProxyTargets? ProxyTargets { get; }
+        public CacheResultType ResultType { get; }
+        public BuildResult? BuildResult { get; }
+        public ProxyTargets? ProxyTargets { get; }
 
         public static CacheResult IndicateCacheHit(BuildResult buildResult)
         {
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
index 2fe895fe150..5cf28808582 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
@@ -10,6 +10,7 @@ namespace Microsoft.Build.Experimental.ProjectCache
 {
     /// <summary>
     ///     Only one plugin instance can exist for a given BuildManager BeginBuild / EndBuild session.
+    ///     Any exceptions thrown by the plugin will cause MSBuild to fail the build.
     /// </summary>
     public abstract class ProjectCachePluginBase
     {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
index a0de5afca83..5db9a001e46 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
@@ -48,6 +48,11 @@ internal interface IRequestBuilder
         /// </summary>
         event BuildRequestBlockedDelegate OnBuildRequestBlocked;
 
+        /// <summary>
+        /// Raised when resources are requested.
+        /// </summary>
+        event ResourceRequestDelegate OnResourceRequest;
+
         /// <summary>
         /// Builds the request contained in the specified entry.
         /// </summary>
@@ -60,6 +65,11 @@ internal interface IRequestBuilder
         /// </summary>
         void ContinueRequest();
 
+        /// <summary>
+        /// Continues building a request which was previously waiting for a resource grant.
+        /// </summary>
+        void ContinueRequestWithResources(ResourceResponse response);
+
         /// <summary>
         /// Cancels an existing request.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilderCallback.cs b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilderCallback.cs
index 63b77897dd5..386db137259 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilderCallback.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilderCallback.cs
@@ -55,5 +55,21 @@ internal interface IRequestBuilderCallback
         /// Exits the previous MSBuild callback state.
         /// </summary>
         void ExitMSBuildCallbackState();
+
+        /// <summary>
+        /// Requests CPU resources from the scheduler.
+        /// </summary>
+        /// <param name="monitorLockObject">The object used by the caller for synchronization. The lock on this object must be taken when calling this method.</param>
+        /// <param name="requestedCores">Number of logical cores being requested.</param>
+        /// <param name="waitForCores">True to make the request block and wait for at least one core.</param>
+        /// <returns>Number of logical cores actually granted. If <paramref name="waitForCores"/> is false, the call can return
+        /// zero. Otherwise the return value is positive.</returns>
+        int RequestCores(object monitorLockObject, int requestedCores, bool waitForCores);
+
+        /// <summary>
+        /// Returns CPU resources to the scheduler.
+        /// </summary>
+        /// <param name="coresToRelease">Number of logical cores being returned.</param>
+        void ReleaseCores(int coresToRelease);
     }
 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 9b24ebd0cec..66195775b22 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -213,12 +213,12 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
 
             if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToAdd?.Count > 0)
             {
-                var itemGroupText = ItemGroupLoggingHelper.GetParameterText(
-                    ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix,
+                ItemGroupLoggingHelper.LogTaskParameter(
+                    LoggingContext,
+                    TaskParameterMessageKind.AddItem,
                     child.ItemType,
                     itemsToAdd,
                     logItemMetadata: true);
-                LoggingContext.LogCommentFromText(MessageImportance.Low, itemGroupText);
             }
 
             // Now add the items we created to the lookup.
@@ -256,12 +256,12 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
             {
                 if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToRemove.Count > 0)
                 {
-                    var itemGroupText = ItemGroupLoggingHelper.GetParameterText(
-                        ItemGroupLoggingHelper.ItemGroupRemoveLogMessage,
+                    ItemGroupLoggingHelper.LogTaskParameter(
+                        LoggingContext,
+                        TaskParameterMessageKind.RemoveItem,
                         child.ItemType,
                         itemsToRemove,
                         logItemMetadata: true);
-                    LoggingContext.LogCommentFromText(MessageImportance.Low, itemGroupText);
                 }
 
                 bucket.Lookup.RemoveItems(itemsToRemove);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
index 9aa0bfd4fce..2b8d80d306c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
@@ -5,6 +5,8 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Globalization;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
@@ -31,6 +33,17 @@ internal static class ItemGroupLoggingHelper
         internal static string OutputItemParameterMessagePrefix = ResourceUtilities.GetResourceString("OutputItemParameterMessagePrefix");
         internal static string TaskParameterPrefix = ResourceUtilities.GetResourceString("TaskParameterPrefix");
 
+        /// <summary>
+        /// <see cref="TaskParameterEventArgs"/> by itself doesn't have the implementation
+        /// to materialize the Message as that's a declaration assembly. We inject the logic
+        /// here.
+        /// </summary>
+        static ItemGroupLoggingHelper()
+        {
+            TaskParameterEventArgs.MessageGetter = GetTaskParameterText;
+            TaskParameterEventArgs.DictionaryFactory = ArrayDictionary<string, string>.Create;
+        }
+
         /// <summary>
         /// Gets a text serialized value of a parameter for logging.
         /// </summary>
@@ -203,5 +216,62 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob
                 ErrorUtilities.ThrowInternalErrorUnreachable();
             }
         }
+
+        internal static void LogTaskParameter(
+            LoggingContext loggingContext,
+            TaskParameterMessageKind messageKind,
+            string itemType,
+            IList items,
+            bool logItemMetadata)
+        {
+            var args = CreateTaskParameterEventArgs(
+                loggingContext.BuildEventContext,
+                messageKind,
+                itemType,
+                items,
+                logItemMetadata,
+                DateTime.UtcNow);
+            loggingContext.LogBuildEvent(args);
+        }
+
+        internal static TaskParameterEventArgs CreateTaskParameterEventArgs(
+            BuildEventContext buildEventContext,
+            TaskParameterMessageKind messageKind,
+            string itemType,
+            IList items,
+            bool logItemMetadata,
+            DateTime timestamp)
+        {
+            var args = new TaskParameterEventArgs(
+                messageKind,
+                itemType,
+                items,
+                logItemMetadata,
+                timestamp);
+            args.BuildEventContext = buildEventContext;
+            return args;
+        }
+
+        internal static string GetTaskParameterText(TaskParameterEventArgs args)
+            => GetTaskParameterText(args.Kind, args.ItemType, args.Items, args.LogItemMetadata);
+
+        internal static string GetTaskParameterText(TaskParameterMessageKind messageKind, string itemType, IList items, bool logItemMetadata)
+        {
+            var resourceText = messageKind switch
+            {
+                TaskParameterMessageKind.AddItem => ItemGroupIncludeLogMessagePrefix,
+                TaskParameterMessageKind.RemoveItem => ItemGroupRemoveLogMessage,
+                TaskParameterMessageKind.TaskInput => TaskParameterPrefix,
+                TaskParameterMessageKind.TaskOutput => OutputItemParameterMessagePrefix,
+                _ => throw new NotImplementedException($"Unsupported {nameof(TaskParameterMessageKind)} value: {messageKind}")
+            };
+
+            var itemGroupText = GetParameterText(
+                resourceText,
+                itemType,
+                items,
+                logItemMetadata);
+            return itemGroupText;
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index bbe8db85caf..6e0ba6a0d5f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -661,10 +661,8 @@ internal static async Task<bool> ExecuteTargets(
 
                         foreach (string targetName in nonNullTargetList)
                         {
-                            if (targetOutputsPerProject[i].ContainsKey(targetName))
+                            if (targetOutputsPerProject[i].TryGetValue(targetName, out ITaskItem[] outputItemsFromTarget))
                             {
-                                ITaskItem[] outputItemsFromTarget = targetOutputsPerProject[i][targetName];
-
                                 foreach (ITaskItem outputItemFromTarget in outputItemsFromTarget)
                                 {
                                     // No need to rebase if the calling project is the same as the callee project 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index 4d0e7f95812..71141924280 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -210,13 +210,13 @@ internal List<string> GetPropertyOverrideMessages(Dictionary<string, string> loo
 
                     string propertyName = property.Name;
                     // If the hash contains the property name, output a messages that displays the previous property value and the new property value
-                    if (lookupHash.ContainsKey(propertyName))
+                    if (lookupHash.TryGetValue(propertyName, out string propertyValue))
                     {
                         if (errorMessages == null)
                         {
                             errorMessages = new List<string>();
                         }
-                        errorMessages.Add(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("PropertyOutputOverridden", propertyName, EscapingUtilities.UnescapeAll(lookupHash[propertyName]), property.EvaluatedValue));
+                        errorMessages.Add(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("PropertyOutputOverridden", propertyName, EscapingUtilities.UnescapeAll(propertyValue), property.EvaluatedValue));
                     }
 
                     // Set the value of the hash to the new property value
@@ -945,10 +945,10 @@ private void MustNotBeInTable(ItemDictionary<ProjectItemInstance> table, Project
         /// </summary>
         private void MustNotBeInTable(ItemTypeToItemsMetadataUpdateDictionary table, ProjectItemInstance item)
         {
-            if (table?.ContainsKey(item.ItemType) == true)
+            ItemsMetadataUpdateDictionary tableOfItemsOfSameType = null;
+            if (table?.TryGetValue(item.ItemType, out tableOfItemsOfSameType) == true)
             {
-                ItemsMetadataUpdateDictionary tableOfItemsOfSameType = table[item.ItemType];
-                if (tableOfItemsOfSameType != null)
+                if (tableOfItemsOfSameType is not null)
                 {
                     ErrorUtilities.VerifyThrow(!tableOfItemsOfSameType.ContainsKey(item), "Item should not be in table");
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index d5b83a1566c..7b7f60f06cc 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
@@ -19,7 +18,6 @@
 using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
-using Microsoft.Build.Experimental.ProjectCache;
 using NodeLoggingContext = Microsoft.Build.BackEnd.Logging.NodeLoggingContext;
 using ProjectLoggingContext = Microsoft.Build.BackEnd.Logging.ProjectLoggingContext;
 
@@ -50,6 +48,11 @@ internal class RequestBuilder : IRequestBuilder, IRequestBuilderCallback, IBuild
         /// </summary>
         private IDictionary<int, BuildResult> _continueResults;
 
+        /// <summary>
+        /// Queue of actions to call when a resource request is responded to.
+        /// </summary>
+        private ConcurrentQueue<Action<ResourceResponse>> _pendingResourceRequests;
+
         /// <summary>
         /// The task representing the currently-executing build request.
         /// </summary>
@@ -107,6 +110,7 @@ internal RequestBuilder()
         {
             _terminateEvent = new ManualResetEvent(false);
             _continueEvent = new AutoResetEvent(false);
+            _pendingResourceRequests = new ConcurrentQueue<Action<ResourceResponse>>();
         }
 
         /// <summary>
@@ -124,6 +128,11 @@ internal RequestBuilder()
         /// </summary>
         public event BuildRequestBlockedDelegate OnBuildRequestBlocked;
 
+        /// <summary>
+        /// The event raised when resources are requested.
+        /// </summary>
+        public event ResourceRequestDelegate OnResourceRequest;
+
         /// <summary>
         /// The current block type
         /// </summary>
@@ -220,6 +229,19 @@ public void ContinueRequest()
             _continueEvent.Set();
         }
 
+        /// <summary>
+        /// Continues a build request after receiving a resource response.
+        /// </summary>
+        public void ContinueRequestWithResources(ResourceResponse response)
+        {
+            ErrorUtilities.VerifyThrow(HasActiveBuildRequest, "Request not building");
+            ErrorUtilities.VerifyThrow(!_terminateEvent.WaitOne(0), "Request already terminated");
+            ErrorUtilities.VerifyThrow(!_pendingResourceRequests.IsEmpty, "No pending resource requests");
+            VerifyEntryInActiveOrWaitingState();
+
+            _pendingResourceRequests.Dequeue()(response);
+        }
+
         /// <summary>
         /// Terminates the build request
         /// </summary>
@@ -460,6 +482,61 @@ public void ExitMSBuildCallbackState()
             _inMSBuildCallback = false;
         }
 
+        /// <summary>
+        /// Requests CPU resources from the scheduler.
+        /// </summary>
+        public int RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)
+        {
+            ErrorUtilities.VerifyThrow(Monitor.IsEntered(monitorLockObject), "Not running under the given lock");
+            VerifyIsNotZombie();
+
+            // The task may be calling RequestCores from multiple threads and the call may be blocking, so in general, we have to maintain
+            // a queue of pending requests.
+            ResourceResponse responseObject = null;
+            using AutoResetEvent responseEvent = new AutoResetEvent(false);
+            _pendingResourceRequests.Enqueue((ResourceResponse response) =>
+            {
+                responseObject = response;
+                responseEvent.Set();
+            });
+
+            RaiseResourceRequest(ResourceRequest.CreateAcquireRequest(_requestEntry.Request.GlobalRequestId, requestedCores, waitForCores));
+
+            // Wait for one of two events to be signaled: 1) The build was canceled, 2) The response to our request was received.
+            WaitHandle[] waitHandles = new WaitHandle[] { _terminateEvent, responseEvent };
+            int waitResult;
+
+            // Drop the lock so that the same task can call ReleaseCores from other threads to unblock itself.
+            Monitor.Exit(monitorLockObject);
+            try
+            {
+                waitResult = WaitHandle.WaitAny(waitHandles);
+            }
+            finally
+            {
+                // Now re-take the lock before continuing.
+                Monitor.Enter(monitorLockObject);
+            }
+
+            if (waitResult == 0)
+            {
+                // We've been aborted.
+                throw new BuildAbortedException();
+            }
+
+            VerifyEntryInActiveOrWaitingState();
+            return responseObject.NumCores;
+        }
+
+        /// <summary>
+        /// Returns CPU resources to the scheduler.
+        /// </summary>
+        public void ReleaseCores(int coresToRelease)
+        {
+            VerifyIsNotZombie();
+            RaiseResourceRequest(ResourceRequest.CreateReleaseRequest(_requestEntry.Request.GlobalRequestId, coresToRelease));
+        }
+
         #endregion
 
         #region IBuildComponent Members
@@ -676,6 +753,15 @@ private void VerifyEntryInActiveState()
             ErrorUtilities.VerifyThrow(_requestEntry.State == BuildRequestEntryState.Active, "Entry is not in the Active state, it is in the {0} state.", _requestEntry.State);
         }
 
+        /// <summary>
+        /// Asserts that the entry is in the active or waiting state.
+        /// </summary>
+        private void VerifyEntryInActiveOrWaitingState()
+        {
+            ErrorUtilities.VerifyThrow(_requestEntry.State == BuildRequestEntryState.Active || _requestEntry.State == BuildRequestEntryState.Waiting,
+                "Entry is not in the Active or Waiting state, it is in the {0} state.", _requestEntry.State);
+        }
+
         /// <summary>
         /// The entry point for the request builder thread.
         /// </summary>
@@ -986,6 +1072,15 @@ private void RaiseOnBlockedRequest(int blockingGlobalRequestId, string blockingT
             OnBuildRequestBlocked?.Invoke(_requestEntry, blockingGlobalRequestId, blockingTarget, partialBuildResult);
         }
 
+        /// <summary>
+        /// Invokes the OnResourceRequest event
+        /// </summary>
+        /// <param name="request"></param>
+        private void RaiseResourceRequest(ResourceRequest request)
+        {
+            OnResourceRequest?.Invoke(request);
+        }
+
         /// <summary>
         /// This method is called to reset the current directory to the one appropriate for this project.  It should be called any time
         /// the project is resumed.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index d79147775b7..79142963436 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -142,16 +142,16 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
 
             foreach (string targetName in targetNames)
             {
-                var targetExists = _projectInstance.Targets.ContainsKey(targetName);
+                var targetExists = _projectInstance.Targets.TryGetValue(targetName, out ProjectTargetInstance targetInstance);
                 if (!targetExists && entry.Request.BuildRequestDataFlags.HasFlag(BuildRequestDataFlags.SkipNonexistentTargets))
                 {
                     _projectLoggingContext.LogComment(Framework.MessageImportance.Low,
                         "TargetSkippedWhenSkipNonexistentTargets", targetName);
-
-                    continue;
                 }
-
-                targets.Add(new TargetSpecification(targetName, targetExists ? _projectInstance.Targets[targetName].Location : _projectInstance.ProjectFileLocation));
+                else
+                {
+                    targets.Add(new TargetSpecification(targetName, targetExists ? targetInstance.Location : _projectInstance.ProjectFileLocation));
+                }
             }
 
             // Push targets onto the stack.  This method will reverse their push order so that they
@@ -363,6 +363,24 @@ void IRequestBuilderCallback.ExitMSBuildCallbackState()
             _requestBuilderCallback.ExitMSBuildCallbackState();
         }
 
+        /// <summary>
+        /// Requests CPU resources from the scheduler.
+        /// </summary>
+        /// <remarks>This method is called from the <see cref="TaskHost"/>.</remarks>
+        int IRequestBuilderCallback.RequestCores(object monitorLockObject, int requestedCores, bool waitForCores)
+        {
+            return _requestBuilderCallback.RequestCores(monitorLockObject, requestedCores, waitForCores);
+        }
+
+        /// <summary>
+        /// Returns CPU resources to the scheduler.
+        /// </summary>
+        /// <remarks>This method is called from the <see cref="TaskHost"/>.</remarks>
+        void IRequestBuilderCallback.ReleaseCores(int coresToRelease)
+        {
+            _requestBuilderCallback.ReleaseCores(coresToRelease);
+        }
+
         #endregion
 
         /// <summary>
@@ -484,13 +502,7 @@ await PushTargets(errorTargets, currentTargetEntry, currentTargetEntry.Lookup, t
                             }
                             catch
                             {
-                                if (_requestEntry.RequestConfiguration.ActivelyBuildingTargets.ContainsKey(
-                                    currentTargetEntry.Name))
-                                {
-                                    _requestEntry.RequestConfiguration.ActivelyBuildingTargets.Remove(currentTargetEntry
-                                        .Name);
-                                }
-
+                                _requestEntry.RequestConfiguration.ActivelyBuildingTargets.Remove(currentTargetEntry.Name);
                                 throw;
                             }
                         }
@@ -764,7 +776,7 @@ private void ComputeAfterTargetFailures(string[] targetNames)
         {
             foreach (string targetName in targetNames)
             {
-                if (_buildResult.ResultsByTarget.ContainsKey(targetName))
+                if (_buildResult.ResultsByTarget.TryGetValue(targetName, out TargetResult targetBuildResult))
                 {
                     // Queue of targets waiting to be processed, seeded with the specific target for which we're computing AfterTargetsHaveFailed.
                     var targetsToCheckForAfterTargets = new Queue<string>();
@@ -785,7 +797,7 @@ private void ComputeAfterTargetFailures(string[] targetNames)
                             if (result?.ResultCode == TargetResultCode.Failure && !result.TargetFailureDoesntCauseBuildFailure)
                             {
                                 // Mark the target as having an after target failed, and break the loop to move to the next target.
-                                _buildResult.ResultsByTarget[targetName].AfterTargetsHaveFailed = true;
+                                targetBuildResult.AfterTargetsHaveFailed = true;
                                 targetsToCheckForAfterTargets = null;
                                 break;
                             }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 58a0e6931bc..5390d169443 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -338,9 +338,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
             {
                 _taskExecutionHost.CleanupForTask();
 
-#if FEATURE_APPDOMAIN
                 taskHost?.MarkAsInactive();
-#endif
 
                 // Now all task batches are done, apply all item adds to the outer 
                 // target batch; we do this even if the task wasn't found (in that case,
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 8d830c38a0b..9222e6e9baf 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -33,7 +33,7 @@ internal class TaskHost :
 #if FEATURE_APPDOMAIN
         MarshalByRefObject,
 #endif
-        IBuildEngine7
+        IBuildEngine9
     {
         /// <summary>
         /// True if the "secret" environment variable MSBUILDNOINPROCNODE is set.
@@ -361,6 +361,10 @@ public void Yield()
         /// </summary>
         public void Reacquire()
         {
+            // Release all cores on reacquire. The assumption here is that the task is done with CPU intensive work at this point and forgetting
+            // to release explicitly granted cores when reacquiring the node may lead to deadlocks.
+            ReleaseAllCores();
+
             lock (_callbackMonitor)
             {
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
@@ -670,10 +674,198 @@ public IReadOnlyDictionary<string, string> GetGlobalProperties()
         #endregion
 
         #region IBuildEngine7 Members
+
         /// <summary>
         /// Enables or disables emitting a default error when a task fails without logging errors
         /// </summary>
         public bool AllowFailureWithoutError { get; set; } = false;
+
+        #endregion
+
+        #region IBuildEngine8 Members
+
+        private ICollection<string> _warningsAsErrors;
+
+        /// <summary>
+        /// Contains all warnings that should be logged as errors.
+        /// Non-null empty set when all warnings should be treated as errors.
+        /// </summary>
+        private ICollection<string> WarningsAsErrors
+        {
+            get
+            {
+                // Test compatibility
+                if(_taskLoggingContext == null)
+                {
+                    return null;
+                }
+
+                return _warningsAsErrors ??= _taskLoggingContext.GetWarningsAsErrors();
+            }
+        }
+
+        private ICollection<string> _warningsAsMessages;
+
+        /// <summary>
+        /// Contains all warnings that should be logged as errors.
+        /// Non-null empty set when all warnings should be treated as errors.
+        /// </summary>
+        private ICollection<string> WarningsAsMessages
+        {
+            get
+            {
+                // Test compatibility
+                if (_taskLoggingContext == null)
+                {
+                    return null;
+                }
+
+                return _warningsAsMessages ??= _taskLoggingContext.GetWarningsAsMessages();
+            }
+        }
+
+        /// <summary>
+        /// Determines if the given warning should be treated as an error.
+        /// </summary>
+        /// <param name="warningCode"></param>
+        /// <returns>True if the warning should not be treated as a message and WarningsAsErrors is an empty set or contains the given warning code.</returns>
+        public bool ShouldTreatWarningAsError(string warningCode)
+        {
+            // Warnings as messages overrides warnings as errors.
+            if (WarningsAsErrors == null || WarningsAsMessages?.Contains(warningCode) == true)
+            {
+                return false;
+            }
+
+            // An empty set means all warnings are errors.
+            return WarningsAsErrors.Count == 0 || WarningsAsErrors.Contains(warningCode);
+        }
+
+        #endregion
+
+        #region IBuildEngine9 Members
+
+        /// <summary>
+        /// Additional cores granted to the task by the scheduler. Does not include the one implicit core automatically granted to all tasks.
+        /// </summary>
+        private int _additionalAcquiredCores = 0;
+
+        /// <summary>
+        /// True if the one implicit core has been allocated by <see cref="RequestCores"/>, false otherwise.
+        /// </summary>
+        private bool _isImplicitCoreUsed = false;
+
+        /// <summary>
+        /// Total number of cores granted to the task, including the one implicit core.
+        /// </summary>
+        private int TotalAcquiredCores => _additionalAcquiredCores + (_isImplicitCoreUsed ? 1 : 0);
+
+        /// <summary>
+        /// Allocates shared CPU resources. Called by a task when it's about to do potentially multi-threaded/multi-process work.
+        /// </summary>
+        /// <param name="requestedCores">The number of cores the task wants to use.</param>
+        /// <returns>The number of cores the task is allowed to use given the current state of the build. This number is always between
+        /// 1 and <paramref name="requestedCores"/>. If the task has allocated its one implicit core, this call may block, waiting for
+        /// at least one core to become available.</returns>
+        public int RequestCores(int requestedCores)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(requestedCores > 0, nameof(requestedCores));
+
+            lock (_callbackMonitor)
+            {
+                IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
+
+                int coresAcquired = 0;
+                bool allocatingImplicitCore = false;
+                if (_isImplicitCoreUsed)
+                {
+                    coresAcquired = builderCallback.RequestCores(_callbackMonitor, requestedCores, waitForCores: true);
+                }
+                else
+                {
+                    _isImplicitCoreUsed = true;
+                    allocatingImplicitCore = true;
+                    if (requestedCores > 1)
+                    {
+                        coresAcquired = builderCallback.RequestCores(_callbackMonitor, requestedCores - 1, waitForCores: false);
+                    }
+                }
+                _additionalAcquiredCores += coresAcquired;
+
+                if (allocatingImplicitCore)
+                {
+                    // Pad the result with the one implicit core if it was still available.
+                    // This ensures that first call never blocks and always returns >= 1.
+                    coresAcquired++;
+                }
+
+                Debug.Assert(coresAcquired >= 1);
+                if (LoggingContext.IsValid)
+                {
+                    LoggingContext.LogComment(MessageImportance.Low, "TaskAcquiredCores", _taskLoggingContext.TaskName,
+                        requestedCores, coresAcquired, TotalAcquiredCores);
+                }
+                return coresAcquired;
+            }
+        }
+
+        /// <summary>
+        /// Frees shared CPU resources. Called by a task when it's finished doing multi-threaded/multi-process work.
+        /// </summary>
+        /// <param name="coresToRelease">The number of cores the task wants to return. This number must be between 0 and the number of cores
+        /// granted and not yet released.</param>
+        public void ReleaseCores(int coresToRelease)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(coresToRelease > 0, nameof(coresToRelease));
+
+            lock (_callbackMonitor)
+            {
+                int coresBeingReleased = coresToRelease;
+                int previousTotalAcquiredCores = TotalAcquiredCores;
+
+                if (_isImplicitCoreUsed && coresBeingReleased > _additionalAcquiredCores)
+                {
+                    // Release the implicit core last, i.e. only if we're asked to release everything.
+                    coresBeingReleased -= 1;
+                    _isImplicitCoreUsed = false;
+                }
+
+                coresBeingReleased = Math.Min(coresBeingReleased, _additionalAcquiredCores);
+                if (coresBeingReleased >= 1)
+                {
+                    IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
+                    builderCallback.ReleaseCores(coresBeingReleased);
+                    _additionalAcquiredCores -= coresBeingReleased;
+                }
+
+                if (LoggingContext.IsValid)
+                {
+                    if (TotalAcquiredCores == previousTotalAcquiredCores - coresToRelease)
+                    {
+                        LoggingContext.LogComment(MessageImportance.Low, "TaskReleasedCores", _taskLoggingContext.TaskName,
+                            coresToRelease, TotalAcquiredCores);
+                    }
+                    else
+                    {
+                        LoggingContext.LogComment(MessageImportance.Low, "TaskReleasedCoresWarning", _taskLoggingContext.TaskName,
+                            coresToRelease, previousTotalAcquiredCores, TotalAcquiredCores);
+                    }
+                }
+            }
+        }
+
+        /// <summary>
+        /// Frees all CPU resources granted so far.
+        /// </summary>
+        internal void ReleaseAllCores()
+        {
+            int coresToRelease = TotalAcquiredCores;
+            if (coresToRelease > 0)
+            {
+                ReleaseCores(coresToRelease);
+            }
+        }
+
         #endregion
 
         /// <summary>
@@ -783,6 +975,7 @@ public override object InitializeLifetimeService()
                 return lease;
             }
         }
+#endif
 
         /// <summary>
         /// Indicates to the TaskHost that it is no longer needed.
@@ -795,6 +988,8 @@ internal void MarkAsInactive()
                 VerifyActiveProxy();
                 _activeProxy = false;
 
+                ReleaseAllCores();
+
                 // Since the task has a pointer to this class it may store it in a static field. Null out
                 // internal data so the leak of this object doesn't lead to a major memory leak.            
                 _host = null;
@@ -804,6 +999,7 @@ internal void MarkAsInactive()
                 _taskLoggingContext = null;
                 _targetBuilderCallback = null;
 
+#if FEATURE_APPDOMAIN
                 // Clear out the sponsor (who is responsible for keeping the EngineProxy remoting lease alive until the task is done)
                 // this will be null if the engine proxy was never sent across an AppDomain boundary.
                 if (_sponsor != null)
@@ -815,9 +1011,9 @@ internal void MarkAsInactive()
                     _sponsor.Close();
                     _sponsor = null;
                 }
+#endif
             }
         }
-#endif
 
         /// <summary>
         /// Determine if the event is serializable. If we are running with multiple nodes we need to make sure the logging events are serializable. If not
diff --git a/src/Build/BackEnd/Components/Scheduler/IScheduler.cs b/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
index eb30122e633..de90369fabb 100644
--- a/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections.Generic;
+using System.Threading.Tasks;
 using Microsoft.Build.Execution;
 
 namespace Microsoft.Build.BackEnd
@@ -68,5 +69,15 @@ internal interface IScheduler : IBuildComponent
         /// Writes a detailed summary of the build state which includes informaiton about the scheduling plan.
         /// </summary>
         void WriteDetailedSummary(int submissionId);
+
+        /// <summary>
+        /// Requests CPU resources.
+        /// </summary>
+        Task<int> RequestCores(int requestId, int requestedCores, bool waitForCores);
+
+        /// <summary>
+        /// Returns CPU resources.
+        /// </summary>
+        List<ScheduleResponse> ReleaseCores(int requestId, int coresToRelease);
     }
 }
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
index 590cc2c74a9..9305abe7c66 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
@@ -290,6 +290,11 @@ public DateTime EndTime
             }
         }
 
+        /// <summary>
+        /// Number of cores granted as part of running the build request.
+        /// </summary>
+        public int GrantedCores { get; set; }
+
         /// <summary>
         /// Gets the amount of time we spent in the specified state.
         /// </summary>
@@ -629,9 +634,7 @@ private void CleanupForCircularDependencyAndThrow(SchedulableRequest requestCaus
         /// </summary>
         internal void DisconnectRequestWeAreBlockedBy(BlockingRequestKey blockingRequestKey)
         {
-            ErrorUtilities.VerifyThrow(_requestsWeAreBlockedBy.ContainsKey(blockingRequestKey), "We are not blocked by the specified request.");
-
-            SchedulableRequest unblockingRequest = _requestsWeAreBlockedBy[blockingRequestKey];
+            ErrorUtilities.VerifyThrow(_requestsWeAreBlockedBy.TryGetValue(blockingRequestKey, out SchedulableRequest unblockingRequest), "We are not blocked by the specified request.");
             ErrorUtilities.VerifyThrow(unblockingRequest._requestsWeAreBlocking.Contains(this), "The request unblocking us doesn't think it is blocking us.");
 
             _requestsWeAreBlockedBy.Remove(blockingRequestKey);
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 0ce340f4828..1e335cedb85 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -9,6 +9,7 @@
 using System.Linq;
 using System.Text;
 using System.Threading;
+using System.Threading.Tasks;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -70,6 +71,16 @@ internal class Scheduler : IScheduler
         /// </summary>
         private int _nodeLimitOffset;
 
+        /// <summary>
+        /// The result of calling NativeMethodsShared.GetLogicalCoreCount() unless overriden with MSBUILDCORELIMIT.
+        /// </summary>
+        private int _coreLimit;
+
+        /// <summary>
+        /// The weight of busy nodes in GetAvailableCoresForExplicitRequests().
+        /// </summary>
+        private int _nodeCoreAllocationWeight;
+
         /// <summary>
         /// { nodeId -> NodeInfo }
         /// A list of nodes we know about.  For the non-distributed case, there will be no more nodes than the
@@ -94,6 +105,11 @@ internal class Scheduler : IScheduler
         /// </summary>
         private SchedulingData _schedulingData;
 
+        /// <summary>
+        /// A queue of RequestCores requests waiting for at least one core to become available.
+        /// </summary>
+        private Queue<TaskCompletionSource<int>> _pendingRequestCoresCallbacks;
+
         #endregion
 
         /// <summary>
@@ -181,6 +197,23 @@ public Scheduler()
                 }
             }
 
+            // Resource management tuning knobs:
+            // 1) MSBUILDCORELIMIT is the maximum number of cores we hand out via IBuildEngine9.RequestCores.
+            //    Note that it is independent of build parallelism as given by /m on the command line.
+            if (!int.TryParse(Environment.GetEnvironmentVariable("MSBUILDCORELIMIT"), out _coreLimit) || _coreLimit <= 0)
+            {
+                _coreLimit = NativeMethodsShared.GetLogicalCoreCount();
+            }
+            // 1) MSBUILDNODECOREALLOCATIONWEIGHT is the weight with which executing nodes reduce the number of available cores.
+            //    Example: If the weight is 50, _coreLimit is 8, and there are 4 nodes that are busy executing build requests,
+            //    then the number of cores available via IBuildEngine9.RequestCores is 8 - (0.5 * 4) = 6.
+            if (!int.TryParse(Environment.GetEnvironmentVariable("MSBUILDNODECOREALLOCATIONWEIGHT"), out _nodeCoreAllocationWeight)
+                || _nodeCoreAllocationWeight <= 0
+                || _nodeCoreAllocationWeight > 100)
+            {
+                _nodeCoreAllocationWeight = 0;
+            }
+
             if (String.IsNullOrEmpty(_debugDumpPath))
             {
                 _debugDumpPath = Path.GetTempPath();
@@ -487,6 +520,7 @@ public void Reset()
             _schedulingPlan = null;
             _schedulingData = new SchedulingData();
             _availableNodes = new Dictionary<int, NodeInfo>(8);
+            _pendingRequestCoresCallbacks = new Queue<TaskCompletionSource<int>>();
             _currentInProcNodeCount = 0;
             _currentOutOfProcNodeCount = 0;
 
@@ -516,6 +550,53 @@ public void WriteDetailedSummary(int submissionId)
             WriteNodeUtilizationGraph(loggingService, context, false /* useConfigurations */);
         }
 
+        /// <summary>
+        /// Requests CPU resources.
+        /// </summary>
+        public Task<int> RequestCores(int requestId, int requestedCores, bool waitForCores)
+        {
+            if (requestedCores == 0)
+            {
+                return Task.FromResult(0);
+            }
+
+            Func<int, int> grantCores = (int availableCores) =>
+            {
+                int grantedCores = Math.Min(requestedCores, availableCores);
+                if (grantedCores > 0)
+                {
+                    _schedulingData.GrantCoresToRequest(requestId, grantedCores);
+                }
+                return grantedCores;
+            };
+
+            int grantedCores = grantCores(GetAvailableCoresForExplicitRequests());
+            if (grantedCores > 0 || !waitForCores)
+            {
+                return Task.FromResult(grantedCores);
+            }
+            else
+            {
+                // We have no cores to grant at the moment, queue up the request.
+                TaskCompletionSource<int> completionSource = new TaskCompletionSource<int>();
+                _pendingRequestCoresCallbacks.Enqueue(completionSource);
+                return completionSource.Task.ContinueWith((Task<int> task) => grantCores(task.Result), TaskContinuationOptions.ExecuteSynchronously);
+            }
+        }
+
+        /// <summary>
+        /// Returns CPU resources.
+        /// </summary>
+        public List<ScheduleResponse> ReleaseCores(int requestId, int coresToRelease)
+        {
+            _schedulingData.RemoveCoresFromRequest(requestId, coresToRelease);
+
+            // Releasing cores means that we may be able to schedule more work.
+            List<ScheduleResponse> responses = new List<ScheduleResponse>();
+            ScheduleUnassignedRequests(responses);
+            return responses;
+        }
+
         #endregion
 
         #region IBuildComponent Members
@@ -588,7 +669,8 @@ private void ScheduleUnassignedRequests(List<ScheduleResponse> responses)
                 }
                 else
                 {
-                    // Nodes still have work, but we have no requests.  Let them proceed.
+                    // Nodes still have work, but we have no requests.  Let them proceed and only handle resource requests.
+                    HandlePendingResourceRequests();
                     TraceScheduler("{0}: Waiting for existing work to proceed.", schedulingTime);
                 }
 
@@ -1269,6 +1351,21 @@ private void AssignUnscheduledRequestToNode(SchedulableRequest request, int node
             request.ResumeExecution(nodeId);
         }
 
+        /// <summary>
+        /// Returns the maximum number of cores that can be returned from a RequestCores() call at the moment.
+        /// </summary>
+        private int GetAvailableCoresForExplicitRequests()
+        {
+            // At least one core is always implicitly granted to the node making the request.
+            // If _nodeCoreAllocationWeight is more than zero, it can increase this value by the specified fraction of executing nodes.
+            int implicitlyGrantedCores = Math.Max(1, (_schedulingData.ExecutingRequestsCount * _nodeCoreAllocationWeight) / 100);
+
+            // The number of explicitly granted cores is a sum of everything we've granted via RequestCores() so far across all nodes.
+            int explicitlyGrantedCores = _schedulingData.ExplicitlyGrantedCores;
+
+            return Math.Max(0, _coreLimit - (implicitlyGrantedCores + explicitlyGrantedCores));
+        }
+
         /// <summary>
         /// Returns true if we are at the limit of work we can schedule.
         /// </summary>
@@ -1279,6 +1376,15 @@ private bool AtSchedulingLimit()
                 return false;
             }
 
+            // We're at our limit of schedulable requests if: 
+            // (1) MaxNodeCount requests are currently executing
+            if (_schedulingData.ExecutingRequestsCount >= _componentHost.BuildParameters.MaxNodeCount)
+            {
+                return true;
+            }
+
+            // (2) Fewer than MaxNodeCount requests are currently executing but the sum of executing request,
+            //     yielding requests, and explicitly granted cores exceeds the limit set out below.
             int limit = _componentHost.BuildParameters.MaxNodeCount switch
             {
                 1 => 1,
@@ -1286,12 +1392,9 @@ private bool AtSchedulingLimit()
                 _ => _componentHost.BuildParameters.MaxNodeCount + 2 + _nodeLimitOffset,
             };
 
-            // We're at our limit of schedulable requests if: 
-            // (1) MaxNodeCount requests are currently executing
-            // (2) Fewer than MaxNodeCount requests are currently executing but the sum of executing 
-            //     and yielding requests exceeds the limit set out above.  
-            return _schedulingData.ExecutingRequestsCount + _schedulingData.YieldingRequestsCount >= limit ||
-                   _schedulingData.ExecutingRequestsCount >= _componentHost.BuildParameters.MaxNodeCount;
+            return _schedulingData.ExecutingRequestsCount +
+                   _schedulingData.YieldingRequestsCount +
+                   _schedulingData.ExplicitlyGrantedCores >= limit;
         }
 
         /// <summary>
@@ -1716,6 +1819,25 @@ private void ResolveRequestFromCacheAndResumeIfPossible(SchedulableRequest reque
             }
         }
 
+        /// <summary>
+        /// Satisfies pending resource requests. Requests are pulled from the queue in FIFO fashion and granted as many cores
+        /// as possible, optimizing for maximum number of cores granted to a single request, not for maximum number of satisfied
+        /// requests.
+        /// </summary>
+        private void HandlePendingResourceRequests()
+        {
+            while (_pendingRequestCoresCallbacks.Count > 0)
+            {
+                int availableCores = GetAvailableCoresForExplicitRequests();
+                if (availableCores == 0)
+                {
+                    return;
+                }
+                TaskCompletionSource<int> completionSource = _pendingRequestCoresCallbacks.Dequeue();
+                completionSource.SetResult(availableCores);
+            }
+        }
+
         /// <summary>
         /// Determines which work is available which must be assigned to the nodes.  This includes:
         /// 1. Ready requests - those requests which can immediately resume executing.
@@ -1723,6 +1845,9 @@ private void ResolveRequestFromCacheAndResumeIfPossible(SchedulableRequest reque
         /// </summary>
         private void ResumeRequiredWork(List<ScheduleResponse> responses)
         {
+            // If we have pending RequestCore calls, satisfy those first.
+            HandlePendingResourceRequests();
+
             // Resume any ready requests on the existing nodes.
             foreach (int nodeId in _availableNodes.Keys)
             {
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
index 804ac117b8a..0edc83f296e 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Linq;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 
@@ -86,6 +87,15 @@ internal class SchedulingData
 
         #endregion
 
+        #region Resource management
+
+        /// <summary>
+        /// The sum of number of cores explicitly granted to all build requests.
+        /// </summary>
+        private int _grantedCores;
+
+        #endregion
+
         #region Diagnostic Information
 
         /// <summary>
@@ -152,6 +162,14 @@ public int ReadyRequestsCount
             get { return _readyRequests.Count; }
         }
 
+        /// <summary>
+        /// Gets the total number of cores granted to executing and yielding build requests.
+        /// </summary>
+        public int ExplicitlyGrantedCores
+        {
+            get { return _grantedCores; }
+        }
+
         /// <summary>
         /// Retrieves all of the blocked requests.
         /// </summary>
@@ -360,9 +378,9 @@ public void UpdateFromState(SchedulableRequest request, SchedulableRequestState
                     ErrorUtilities.VerifyThrow(_configurationToRequests.ContainsKey(request.BuildRequest.ConfigurationId), "Configuration {0} never had requests assigned to it.", request.BuildRequest.ConfigurationId);
                     ErrorUtilities.VerifyThrow(_configurationToRequests[request.BuildRequest.ConfigurationId].Count > 0, "Configuration {0} has no requests assigned to it.", request.BuildRequest.ConfigurationId);
                     _configurationToRequests[request.BuildRequest.ConfigurationId].Remove(request);
-                    if (_scheduledRequestsByNode.ContainsKey(request.AssignedNode))
+                    if (_scheduledRequestsByNode.TryGetValue(request.AssignedNode, out var requests))
                     {
-                        _scheduledRequestsByNode[request.AssignedNode].Remove(request);
+                        requests.Remove(request);
                     }
 
                     request.EndTime = EventTime;
@@ -477,7 +495,7 @@ public SchedulableRequest GetReadyRequest(int globalRequestId)
         }
 
         /// <summary>
-        /// Retrieves a request which has been assigned to a node and is in the executing, blocked or ready states.
+        /// Retrieves a request which has been assigned to a node and is in the executing, yielding, blocked, or ready states.
         /// </summary>
         public SchedulableRequest GetScheduledRequest(int globalRequestId)
         {
@@ -633,6 +651,33 @@ public bool CanScheduleRequestToNode(SchedulableRequest request, int nodeId)
             return requiredNodeId == Scheduler.InvalidNodeId || requiredNodeId == nodeId;
         }
 
+        /// <summary>
+        /// Explicitly grants CPU cores to a request.
+        /// </summary>
+        public void GrantCoresToRequest(int globalRequestId, int coresToGrant)
+        {
+            // Update per-request state.
+            SchedulableRequest request = GetScheduledRequest(globalRequestId);
+            request.GrantedCores += coresToGrant;
+
+            // Update global state.
+            _grantedCores += coresToGrant;
+        }
+
+        /// <summary>
+        /// Explicitly removes previously granted CPU cores from a request.
+        /// </summary>
+        public void RemoveCoresFromRequest(int globalRequestId, int coresToRemove)
+        {
+            // Update per-request state.
+            SchedulableRequest request = GetScheduledRequest(globalRequestId);
+            coresToRemove = Math.Min(request.GrantedCores, coresToRemove);
+            request.GrantedCores -= coresToRemove;
+
+            // Update global state.
+            _grantedCores -= coresToRemove;
+        }
+
         /// <summary>
         /// Unassigns the node associated with a particular configuration.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index e0d472eea6e..97b4e83a02c 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -22,7 +22,15 @@ internal class SdkResolverLoader
 
         private readonly string IncludeDefaultResolver = Environment.GetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER");
 
-        private readonly string AdditionalResolversFolder = Environment.GetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER");
+        //  Test hook for loading SDK Resolvers from additional folders.  Support runtime-specific test hook environment variables,
+        //  as an SDK resolver built for .NET Framework probably won't work on .NET Core, and vice versa.
+        private readonly string AdditionalResolversFolder = Environment.GetEnvironmentVariable(
+#if NETFRAMEWORK
+            "MSBUILDADDITIONALSDKRESOLVERSFOLDER_NETFRAMEWORK"
+#elif NET
+            "MSBUILDADDITIONALSDKRESOLVERSFOLDER_NET"
+#endif
+            ) ?? Environment.GetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER");
 
         internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
             ElementLocation location)
diff --git a/src/Build/BackEnd/Node/InProcNode.cs b/src/Build/BackEnd/Node/InProcNode.cs
index 0a5db6abbb2..81b4ab63279 100644
--- a/src/Build/BackEnd/Node/InProcNode.cs
+++ b/src/Build/BackEnd/Node/InProcNode.cs
@@ -17,7 +17,7 @@
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
-    /// This class represents an implementation of INode for out-of-proc nodes.
+    /// This class represents an implementation of INode for in-proc nodes.
     /// </summary>
     internal class InProcNode : INode, INodePacketFactory
     {
@@ -96,6 +96,11 @@ internal class InProcNode : INode, INodePacketFactory
         /// </summary>
         private readonly RequestCompleteDelegate _requestCompleteEventHandler;
 
+        /// <summary>
+        /// Handler for resource request events.
+        /// </summary>
+        private readonly ResourceRequestDelegate _resourceRequestHandler;
+
         /// <summary>
         /// Constructor.
         /// </summary>
@@ -113,6 +118,7 @@ public InProcNode(IBuildComponentHost componentHost, INodeEndpoint inProcNodeEnd
             _newConfigurationRequestEventHandler = OnNewConfigurationRequest;
             _requestBlockedEventHandler = OnNewRequest;
             _requestCompleteEventHandler = OnRequestComplete;
+            _resourceRequestHandler = OnResourceRequest;
         }
 
         #region INode Members
@@ -260,6 +266,17 @@ private void OnNewConfigurationRequest(BuildRequestConfiguration config)
             }
         }
 
+        /// <summary>
+        /// Event handler for the BuildEngine's OnResourceRequest event.
+        /// </summary>
+        private void OnResourceRequest(ResourceRequest request)
+        {
+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
+            {
+                _nodeEndpoint.SendData(request);
+            }
+        }
+
         /// <summary>
         /// Event handler for the LoggingService's OnLoggingThreadException event.
         /// </summary>
@@ -354,6 +371,7 @@ private NodeEngineShutdownReason HandleShutdown(out Exception exception)
             _buildRequestEngine.OnNewConfigurationRequest -= _newConfigurationRequestEventHandler;
             _buildRequestEngine.OnRequestBlocked -= _requestBlockedEventHandler;
             _buildRequestEngine.OnRequestComplete -= _requestCompleteEventHandler;
+            _buildRequestEngine.OnResourceRequest -= _resourceRequestHandler;
 
             return _shutdownReason;
         }
@@ -388,6 +406,10 @@ private void HandlePacket(INodePacket packet)
                 case NodePacketType.NodeBuildComplete:
                     HandleNodeBuildComplete(packet as NodeBuildComplete);
                     break;
+
+                case NodePacketType.ResourceResponse:
+                    HandleResourceResponse(packet as ResourceResponse);
+                    break;
             }
         }
 
@@ -482,6 +504,7 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
             _buildRequestEngine.OnNewConfigurationRequest += _newConfigurationRequestEventHandler;
             _buildRequestEngine.OnRequestBlocked += _requestBlockedEventHandler;
             _buildRequestEngine.OnRequestComplete += _requestCompleteEventHandler;
+            _buildRequestEngine.OnResourceRequest += _resourceRequestHandler;
 
             if (_shutdownException != null)
             {
@@ -500,5 +523,13 @@ private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)
             _shutdownReason = buildComplete.PrepareForReuse ? NodeEngineShutdownReason.BuildCompleteReuse : NodeEngineShutdownReason.BuildComplete;
             _shutdownEvent.Set();
         }
+
+        /// <summary>
+        /// Handles the ResourceResponse packet.
+        /// </summary>
+        private void HandleResourceResponse(ResourceResponse response)
+        {
+            _buildRequestEngine.GrantResources(response);
+        }
     }
 }
diff --git a/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs b/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
index 9578394e043..2c7a47703c0 100644
--- a/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
+++ b/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
@@ -11,22 +11,27 @@ internal sealed class LoggingNodeConfiguration : ITranslatable
     {
         private bool _includeEvaluationMetaprojects;
         private bool _includeEvaluationProfiles;
+        private bool _includeEvaluationPropertiesAndItems;
         private bool _includeTaskInputs;
 
         public bool IncludeEvaluationMetaprojects => _includeEvaluationMetaprojects;
-
         public bool IncludeEvaluationProfiles => _includeEvaluationProfiles;
-
+        public bool IncludeEvaluationPropertiesAndItems => _includeEvaluationPropertiesAndItems;
         public bool IncludeTaskInputs => _includeTaskInputs;
 
         public LoggingNodeConfiguration()
         {
         }
 
-        public LoggingNodeConfiguration(bool includeEvaluationMetaprojects, bool includeEvaluationProfiles, bool includeTaskInputs)
+        public LoggingNodeConfiguration(
+            bool includeEvaluationMetaprojects,
+            bool includeEvaluationProfiles,
+            bool includeEvaluationPropertiesAndItems,
+            bool includeTaskInputs)
         {
             _includeEvaluationMetaprojects = includeEvaluationMetaprojects;
             _includeEvaluationProfiles = includeEvaluationProfiles;
+            _includeEvaluationPropertiesAndItems = includeEvaluationPropertiesAndItems;
             _includeTaskInputs = includeTaskInputs;
         }
 
@@ -34,6 +39,7 @@ void ITranslatable.Translate(ITranslator translator)
         {
             translator.Translate(ref _includeEvaluationMetaprojects);
             translator.Translate(ref _includeEvaluationProfiles);
+            translator.Translate(ref _includeEvaluationPropertiesAndItems);
             translator.Translate(ref _includeTaskInputs);
         }
     }
diff --git a/src/Build/BackEnd/Node/NodeConfiguration.cs b/src/Build/BackEnd/Node/NodeConfiguration.cs
index 5cb25db468c..029b1814605 100644
--- a/src/Build/BackEnd/Node/NodeConfiguration.cs
+++ b/src/Build/BackEnd/Node/NodeConfiguration.cs
@@ -40,7 +40,7 @@ internal class NodeConfiguration : INodePacket
         /// </summary>
         private LoggingNodeConfiguration _loggingNodeConfiguration;
 
-#if FEATURE_APPDOMAIN
+#pragma warning disable 1572 // appDomainSetup not always there
         /// <summary>
         /// Constructor
         /// </summary>
@@ -54,38 +54,21 @@ public NodeConfiguration
             int nodeId,
             BuildParameters buildParameters,
             LoggerDescription[] forwardingLoggers,
+#if FEATURE_APPDOMAIN
             AppDomainSetup appDomainSetup,
+#endif
             LoggingNodeConfiguration loggingNodeConfiguration
             )
         {
             _nodeId = nodeId;
             _buildParameters = buildParameters;
             _forwardingLoggers = forwardingLoggers;
+#if FEATURE_APPDOMAIN
             _appDomainSetup = appDomainSetup;
+#endif
             _loggingNodeConfiguration = loggingNodeConfiguration;
         }
-#else
-        /// <summary>
-        /// Constructor
-        /// </summary>
-        /// <param name="nodeId">The node id.</param>
-        /// <param name="buildParameters">The build parameters</param>
-        /// <param name="forwardingLoggers">The forwarding loggers.</param>
-        /// <param name="loggingNodeConfiguration">The logging configuration for the node.</param>
-        public NodeConfiguration
-            (
-            int nodeId,
-            BuildParameters buildParameters,
-            LoggerDescription[] forwardingLoggers,
-            LoggingNodeConfiguration loggingNodeConfiguration
-            )
-        {
-            _nodeId = nodeId;
-            _buildParameters = buildParameters;
-            _forwardingLoggers = forwardingLoggers;
-            _loggingNodeConfiguration = loggingNodeConfiguration;
-        }
-#endif
+#pragma warning restore
 
         /// <summary>
         /// Private constructor for deserialization
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 0ae529953d0..80e36648f23 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -171,6 +171,7 @@ public OutOfProcNode()
             _buildRequestEngine.OnNewConfigurationRequest += OnNewConfigurationRequest;
             _buildRequestEngine.OnRequestBlocked += OnNewRequest;
             _buildRequestEngine.OnRequestComplete += OnRequestComplete;
+            _buildRequestEngine.OnResourceRequest += OnResourceRequest;
 
             (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.BuildRequest, BuildRequest.FactoryForDeserialization, this);
             (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.BuildRequestConfiguration, BuildRequestConfiguration.FactoryForDeserialization, this);
@@ -178,6 +179,7 @@ public OutOfProcNode()
             (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.BuildRequestUnblocker, BuildRequestUnblocker.FactoryForDeserialization, this);
             (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeConfiguration, NodeConfiguration.FactoryForDeserialization, this);
             (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);
+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ResourceResponse, ResourceResponse.FactoryForDeserialization, this);
             (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ResolveSdkResponse, SdkResult.FactoryForDeserialization, _sdkResolverService as INodePacketHandler);
         }
 
@@ -398,6 +400,17 @@ private void OnNewConfigurationRequest(BuildRequestConfiguration config)
             }
         }
 
+        /// <summary>
+        /// Event handler for the BuildEngine's OnResourceRequest event.
+        /// </summary>
+        private void OnResourceRequest(ResourceRequest request)
+        {
+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
+            {
+                _nodeEndpoint.SendData(request);
+            }
+        }
+
         /// <summary>
         /// Event handler for the LoggingService's OnLoggingThreadException event.
         /// </summary>
@@ -594,6 +607,10 @@ private void HandlePacket(INodePacket packet)
                     HandleBuildRequestUnblocker(packet as BuildRequestUnblocker);
                     break;
 
+                case NodePacketType.ResourceResponse:
+                    HandleResourceResponse(packet as ResourceResponse);
+                    break;
+
                 case NodePacketType.NodeConfiguration:
                     HandleNodeConfiguration(packet as NodeConfiguration);
                     break;
@@ -636,6 +653,15 @@ private void HandleBuildRequestUnblocker(BuildRequestUnblocker unblocker)
             _buildRequestEngine.UnblockBuildRequest(unblocker);
         }
 
+        /// <summary>
+        /// Handles the ResourceResponse packet.
+        /// </summary>
+        /// <param name="response"></param>
+        private void HandleResourceResponse(ResourceResponse response)
+        {
+            _buildRequestEngine.GrantResources(response);
+        }
+
         /// <summary>
         /// Handles the NodeConfiguration packet.
         /// </summary>
@@ -716,6 +742,7 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
             {
                 _loggingService.IncludeEvaluationMetaprojects = true;
             }
+
             if (configuration.LoggingNodeConfiguration.IncludeEvaluationProfiles)
             {
                 _loggingService.IncludeEvaluationProfile = true;
@@ -726,6 +753,11 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
                 _loggingService.IncludeTaskInputs = true;
             }
 
+            if (configuration.LoggingNodeConfiguration.IncludeEvaluationPropertiesAndItems)
+            {
+                _loggingService.IncludeEvaluationPropertiesAndItems = true;
+            }
+
             try
             {
                 // If there are no node loggers to initialize dont do anything
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index ec989c4e92d..67138103af8 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -470,9 +470,9 @@ public void AddResultsForTarget(string target, TargetResult result)
                 _resultsByTarget ??= CreateTargetResultDictionary(1);
             }
 
-            if (_resultsByTarget.ContainsKey(target))
+            if (_resultsByTarget.TryGetValue(target, out TargetResult targetResult))
             {
-                ErrorUtilities.VerifyThrow(_resultsByTarget[target].ResultCode == TargetResultCode.Skipped, "Items already exist for target {0}.", target);
+                ErrorUtilities.VerifyThrow(targetResult.ResultCode == TargetResultCode.Skipped, "Items already exist for target {0}.", target);
             }
 
             _resultsByTarget[target] = result;
diff --git a/src/Build/BackEnd/Shared/ResourceRequest.cs b/src/Build/BackEnd/Shared/ResourceRequest.cs
new file mode 100644
index 00000000000..815eedb9200
--- /dev/null
+++ b/src/Build/BackEnd/Shared/ResourceRequest.cs
@@ -0,0 +1,111 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.BackEnd
+{
+    /// <summary>
+    /// This packet is sent by a node to request or release resources from/to the scheduler.
+    /// </summary>
+    internal sealed class ResourceRequest : INodePacket
+    {
+        /// <summary>
+        /// The global request id of the request which is asking for resources.
+        /// </summary>
+        private int _globalRequestId;
+
+        /// <summary>
+        /// True if this is a request to acquire resources, false if this is a request to release resources.
+        /// </summary>
+        private bool _isResourceAcquire;
+
+        /// <summary>
+        /// True if the request should be blocking until the resources become available. False if the request should
+        /// be responded to immediately even if the desired resources are not available.
+        /// </summary>
+        private bool _isBlocking;
+
+        /// <summary>
+        /// Number of CPU cores being requested or released.
+        /// </summary>
+        private int _numCores;
+
+        /// <summary>
+        /// Constructor for deserialization.
+        /// </summary>
+        internal ResourceRequest(ITranslator translator)
+        {
+            Translate(translator);
+        }
+
+        /// <summary>
+        /// Private constructor, use CreateAcquireRequest or CreateReleaseRequest to make instances.
+        /// </summary>
+        private ResourceRequest(bool isResourceAcquire, int globalRequestId, int numCores, bool isBlocking)
+        {
+            _isResourceAcquire = isResourceAcquire;
+            _isBlocking = isBlocking;
+            _globalRequestId = globalRequestId;
+            _numCores = numCores;
+        }
+
+        /// <summary>
+        /// Factory method for acquiring.
+        /// </summary>
+        public static ResourceRequest CreateAcquireRequest(int globalRequestId, int numCores, bool isBlocking)
+            => new ResourceRequest(isResourceAcquire: true, globalRequestId, numCores, isBlocking);
+
+        /// <summary>
+        /// Factory method for releasing.
+        /// </summary>
+        public static ResourceRequest CreateReleaseRequest(int globalRequestId, int numCores)
+            => new ResourceRequest(isResourceAcquire: false, globalRequestId, numCores, isBlocking: false);
+
+        /// <summary>
+        /// Returns the type of packet.
+        /// </summary>
+        public NodePacketType Type => NodePacketType.ResourceRequest;
+
+        /// <summary>
+        /// Accessor for the global request id.
+        /// </summary>
+        public int GlobalRequestId => _globalRequestId;
+
+        /// <summary>
+        /// Accessor for _isResourceAcquire.
+        /// </summary>
+        public bool IsResourceAcquire => _isResourceAcquire;
+
+        /// <summary>
+        /// Accessor fro _isBlocking.
+        /// </summary>
+        public bool IsBlocking => _isBlocking;
+
+        /// <summary>
+        /// Accessor for _numCores.
+        /// </summary>
+        public int NumCores => _numCores;
+
+        #region INodePacketTranslatable Members
+
+        /// <summary>
+        /// Serialization method.
+        /// </summary>
+        public void Translate(ITranslator translator)
+        {
+            translator.Translate(ref _globalRequestId);
+            translator.Translate(ref _isResourceAcquire);
+            translator.Translate(ref _isBlocking);
+            translator.Translate(ref _numCores);
+        }
+
+        #endregion
+
+        /// <summary>
+        /// Factory for serialization.
+        /// </summary>
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            return new ResourceRequest(translator);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Shared/ResourceResponse.cs b/src/Build/BackEnd/Shared/ResourceResponse.cs
new file mode 100644
index 00000000000..22fcefef30f
--- /dev/null
+++ b/src/Build/BackEnd/Shared/ResourceResponse.cs
@@ -0,0 +1,74 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.BackEnd
+{
+    /// <summary>
+    /// This packet is sent by the scheduler in response to <see cref="ResourceRequest"/> to grant resources to a node.
+    /// </summary>
+    internal sealed class ResourceResponse : INodePacket
+    {
+        /// <summary>
+        /// The global request id of the request which is being responded to.
+        /// </summary>
+        private int _globalRequestId;
+
+        /// <summary>
+        /// Number of CPU cores being granted.
+        /// </summary>
+        private int _numCores;
+
+        /// <summary>
+        /// Constructor for deserialization.
+        /// </summary>
+        internal ResourceResponse(ITranslator translator)
+        {
+            Translate(translator);
+        }
+
+        /// <summary>
+        /// Constructor for granting cores.
+        /// </summary>
+        internal ResourceResponse(int globalRequestId, int numCores)
+        {
+            _globalRequestId = globalRequestId;
+            _numCores = numCores;
+        }
+
+        /// <summary>
+        /// Returns the type of packet.
+        /// </summary>
+        public NodePacketType Type => NodePacketType.ResourceResponse;
+
+        /// <summary>
+        /// Accessor for the global request id.
+        /// </summary>
+        public int GlobalRequestId => _globalRequestId;
+
+        /// <summary>
+        /// Accessor for _numCores.
+        /// </summary>
+        public int NumCores => _numCores;
+
+        #region INodePacketTranslatable Members
+
+        /// <summary>
+        /// Serialization method.
+        /// </summary>
+        public void Translate(ITranslator translator)
+        {
+            translator.Translate(ref _globalRequestId);
+            translator.Translate(ref _numCores);
+        }
+
+        #endregion
+
+        /// <summary>
+        /// Factory for serialization.
+        /// </summary>
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            return new ResourceResponse(translator);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 7bf9a69aebc..dc75cd9496e 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -1333,12 +1333,12 @@ private bool InternalSetTaskParameter(TaskPropertyInfo parameter, IList paramete
                 parameterValue.Count > 0 &&
                 parameter.Log)
             {
-                string parameterText = ItemGroupLoggingHelper.GetParameterText(
-                    ItemGroupLoggingHelper.TaskParameterPrefix,
+                ItemGroupLoggingHelper.LogTaskParameter(
+                    _taskLoggingContext,
+                    TaskParameterMessageKind.TaskInput,
                     parameter.Name,
                     parameterValue,
                     parameter.LogItemMetadata);
-                _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
             }
 
             return InternalSetTaskParameter(parameter, (object)parameterValue);
@@ -1426,11 +1426,16 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
             {
                 if (outputTargetIsItem)
                 {
+                    // Only count non-null elements. We sometimes have a single-element array where the element is null
+                    bool hasElements = false;
+
                     foreach (ITaskItem output in outputs)
                     {
                         // if individual items in the array are null, ignore them
                         if (output != null)
                         {
+                            hasElements = true;
+
                             ProjectItemInstance newItem;
 
                             TaskItem outputAsProjectItem = output as TaskItem;
@@ -1474,15 +1479,14 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                         }
                     }
 
-                    if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0 && parameter.Log)
+                    if (hasElements && LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && parameter.Log)
                     {
-                        string parameterText = ItemGroupLoggingHelper.GetParameterText(
-                            ItemGroupLoggingHelper.OutputItemParameterMessagePrefix,
+                        ItemGroupLoggingHelper.LogTaskParameter(
+                            _taskLoggingContext,
+                            TaskParameterMessageKind.TaskOutput,
                             outputTargetName,
                             outputs,
                             parameter.LogItemMetadata);
-
-                        _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
                     }
                 }
                 else
@@ -1553,12 +1557,12 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
 
                     if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents && outputs.Length > 0 && parameter.Log)
                     {
-                        string parameterText = ItemGroupLoggingHelper.GetParameterText(
-                            ItemGroupLoggingHelper.OutputItemParameterMessagePrefix,
+                        ItemGroupLoggingHelper.LogTaskParameter(
+                            _taskLoggingContext,
+                            TaskParameterMessageKind.TaskOutput,
                             outputTargetName,
                             outputs,
                             parameter.LogItemMetadata);
-                        _taskLoggingContext.LogCommentFromText(MessageImportance.Low, parameterText);
                     }
                 }
                 else
diff --git a/src/Build/Collections/ArrayDictionary.cs b/src/Build/Collections/ArrayDictionary.cs
new file mode 100644
index 00000000000..01e883f6058
--- /dev/null
+++ b/src/Build/Collections/ArrayDictionary.cs
@@ -0,0 +1,265 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// Lightweight, read-only IDictionary implementation using two arrays
+    /// and O(n) lookup.
+    /// Requires specifying capacity at construction and does not
+    /// support reallocation to increase capacity.
+    /// </summary>
+    /// <typeparam name="TKey">Type of keys</typeparam>
+    /// <typeparam name="TValue">Type of values</typeparam>
+    internal class ArrayDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IDictionary, IReadOnlyDictionary<TKey, TValue>
+    {
+        private TKey[] keys;
+        private TValue[] values;
+
+        private int count;
+
+        public ArrayDictionary(int capacity)
+        {
+            keys = new TKey[capacity];
+            values = new TValue[capacity];
+        }
+
+        public static IDictionary<TKey, TValue> Create(int capacity)
+        {
+            return new ArrayDictionary<TKey, TValue>(capacity);
+        }
+
+        public TValue this[TKey key]
+        {
+            get
+            {
+                TryGetValue(key, out var value);
+                return value;
+            }
+
+            set
+            {
+                var comparer = KeyComparer;
+                for (int i = 0; i < count; i++)
+                {
+                    if (comparer.Equals(key, keys[i]))
+                    {
+                        values[i] = value;
+                        return;
+                    }
+                }
+
+                Add(key, value);
+            }
+        }
+
+        object IDictionary.this[object key]
+        {
+            get => this[(TKey)key];
+            set => this[(TKey)key] = (TValue)value;
+        }
+
+        public ICollection<TKey> Keys => keys;
+
+        IEnumerable<TKey> IReadOnlyDictionary<TKey, TValue>.Keys => keys;
+
+        IEnumerable<TValue> IReadOnlyDictionary<TKey, TValue>.Values => values;
+
+        ICollection IDictionary.Keys => keys;
+
+        public ICollection<TValue> Values => values;
+
+        ICollection IDictionary.Values => values;
+
+        private IEqualityComparer<TKey> KeyComparer => EqualityComparer<TKey>.Default;
+
+        private IEqualityComparer<TValue> ValueComparer => EqualityComparer<TValue>.Default;
+
+        public int Count => count;
+
+        public bool IsReadOnly => true;
+
+        bool IDictionary.IsFixedSize => true;
+
+        object ICollection.SyncRoot => this;
+
+        bool ICollection.IsSynchronized => false;
+
+        public void Add(TKey key, TValue value)
+        {
+            if (count < keys.Length)
+            {
+                keys[count] = key;
+                values[count] = value;
+                count += 1;
+            }
+            else
+            {
+                throw new InvalidOperationException($"ArrayDictionary is at capacity {keys.Length}");
+            }
+        }
+
+        public void Add(KeyValuePair<TKey, TValue> item)
+        {
+            Add(item.Key, item.Value);
+        }
+
+        public void Clear()
+        {
+            throw new System.NotImplementedException();
+        }
+
+        public bool Contains(KeyValuePair<TKey, TValue> item)
+        {
+            var keyComparer = KeyComparer;
+            var valueComparer = ValueComparer;
+            for (int i = 0; i < count; i++)
+            {
+                if (keyComparer.Equals(item.Key, keys[i]) && valueComparer.Equals(item.Value, values[i]))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        public bool ContainsKey(TKey key)
+        {
+            var comparer = KeyComparer;
+            for (int i = 0; i < count; i++)
+            {
+                if (comparer.Equals(key, keys[i]))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
+        {
+            for (int i = 0; i < count; i++)
+            {
+                array[arrayIndex + i] = new KeyValuePair<TKey, TValue>(keys[i], values[i]);
+            }
+        }
+
+        void ICollection.CopyTo(Array array, int index)
+        {
+            throw new NotImplementedException();
+        }
+
+        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
+        {
+            return new Enumerator(this);
+        }
+
+        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
+
+        IDictionaryEnumerator IDictionary.GetEnumerator()
+        {
+            return new Enumerator(this, emitDictionaryEntries: true);
+        }
+
+        public bool Remove(TKey key)
+        {
+            throw new System.NotImplementedException();
+        }
+
+        public bool Remove(KeyValuePair<TKey, TValue> item)
+        {
+            throw new System.NotImplementedException();
+        }
+
+        public bool TryGetValue(TKey key, out TValue value)
+        {
+            var comparer = KeyComparer;
+            for (int i = 0; i < count; i++)
+            {
+                if (comparer.Equals(key, keys[i]))
+                {
+                    value = values[i];
+                    return true;
+                }
+            }
+
+            value = default;
+            return false;
+        }
+
+        bool IDictionary.Contains(object key)
+        {
+            if (key is not TKey typedKey)
+            {
+                return false;
+            }
+
+            return ContainsKey(typedKey);
+        }
+
+        void IDictionary.Add(object key, object value)
+        {
+            if (key is TKey typedKey && value is TValue typedValue)
+            {
+                Add(typedKey, typedValue);
+            }
+
+            throw new NotSupportedException();
+        }
+
+        void IDictionary.Remove(object key)
+        {
+            throw new NotImplementedException();
+        }
+
+        private struct Enumerator : IEnumerator<KeyValuePair<TKey, TValue>>, IDictionaryEnumerator
+        {
+            private readonly ArrayDictionary<TKey, TValue> _dictionary;
+            private readonly bool _emitDictionaryEntries;
+            private int _position;
+
+            public Enumerator(ArrayDictionary<TKey, TValue> dictionary, bool emitDictionaryEntries = false)
+            {
+                this._dictionary = dictionary;
+                this._position = -1;
+                this._emitDictionaryEntries = emitDictionaryEntries;
+            }
+
+            public KeyValuePair<TKey, TValue> Current =>
+                new KeyValuePair<TKey, TValue>(
+                    _dictionary.keys[_position],
+                    _dictionary.values[_position]);
+
+            private DictionaryEntry CurrentDictionaryEntry => new DictionaryEntry(_dictionary.keys[_position], _dictionary.values[_position]);
+
+            object IEnumerator.Current => _emitDictionaryEntries ? CurrentDictionaryEntry : Current;
+
+            object IDictionaryEnumerator.Key => _dictionary.keys[_position];
+
+            object IDictionaryEnumerator.Value => _dictionary.values[_position];
+
+            DictionaryEntry IDictionaryEnumerator.Entry => CurrentDictionaryEntry;
+
+            public void Dispose()
+            {
+            }
+
+            public bool MoveNext()
+            {
+                _position += 1;
+                return _position < _dictionary.Count;
+            }
+
+            public void Reset()
+            {
+                throw new NotImplementedException();
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Build/Collections/ItemDictionary.cs b/src/Build/Collections/ItemDictionary.cs
index 84efd27c913..b0e1ab517ef 100644
--- a/src/Build/Collections/ItemDictionary.cs
+++ b/src/Build/Collections/ItemDictionary.cs
@@ -167,6 +167,30 @@ IEnumerator IEnumerable.GetEnumerator()
             return _itemLists.GetEnumerator();
         }
 
+        /// <summary>
+        /// Enumerates item lists per each item type under the lock.
+        /// </summary>
+        /// <param name="itemTypeCallback">
+        /// A delegate that accepts the item type string and a list of items of that type.
+        /// Will be called for each item type in the list.
+        /// </param>
+        internal void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)
+        {
+            lock (_itemLists)
+            {
+                foreach (var itemTypeBucket in _itemLists)
+                {
+                    if (itemTypeBucket.Value == null || itemTypeBucket.Value.Count == 0)
+                    {
+                        // skip empty markers
+                        continue;
+                    }
+
+                    itemTypeCallback(itemTypeBucket.Key, itemTypeBucket.Value);
+                }
+            }
+        }
+
         #region ItemDictionary<T> Members
 
         /// <summary>
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index e3c17b24fae..e1929f7ca58 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -492,22 +492,33 @@ internal void RemoveProperties(IEnumerable<T> other)
 
         /// <summary>
         /// Helper to convert into a read-only dictionary of string, string.
+        /// TODO: for performance, consider switching to returning IDictionary
+        /// and returning ArrayDictionary if lookup of results is not needed.
         /// </summary>
         internal Dictionary<string, string> ToDictionary()
         {
-            Dictionary<string, string> dictionary;
-
             lock (_properties)
             {
-                dictionary = new Dictionary<string, string>(_properties.Count, MSBuildNameIgnoreCaseComparer.Default);
+                var dictionary = new Dictionary<string, string>(_properties.Count, MSBuildNameIgnoreCaseComparer.Default);
 
                 foreach (T property in this)
                 {
                     dictionary[property.Key] = property.EscapedValue;
                 }
+
+                return dictionary;
             }
+        }
 
-            return dictionary;
+        internal void Enumerate(Action<string, string> keyValueCallback)
+        {
+            lock (_properties)
+            {
+                foreach (var kvp in _properties)
+                {
+                    keyValueCallback(kvp.Key, EscapingUtilities.UnescapeAll(kvp.EscapedValue));
+                }
+            }
         }
     }
 }
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 08a7def219e..80d7bdaad22 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -168,11 +168,26 @@ public string AbsolutePath
             {
                 if (_absolutePath == null)
                 {
+                    _absolutePath = Path.Combine(ParentSolution.SolutionFileDirectory, _relativePath);
+
+                    // For web site projects, Visual Studio stores the URL of the site as the relative path so it cannot be normalized.
+                    // Legacy behavior dictates that we must just return the result of Path.Combine()
+                    if (!Uri.TryCreate(_relativePath, UriKind.Absolute, out Uri _))
+                    {
+                        try
+                        {
 #if NETFRAMEWORK && !MONO
-                    _absolutePath = Path.GetFullPath(Path.Combine(ParentSolution.SolutionFileDirectory, _relativePath));
+                            _absolutePath = Path.GetFullPath(_absolutePath);
 #else
-                    _absolutePath = FileUtilities.NormalizePath(Path.Combine(ParentSolution.SolutionFileDirectory, _relativePath));
+                            _absolutePath = FileUtilities.NormalizePath(_absolutePath);
 #endif
+                        }
+                        catch (Exception)
+                        {
+                            // The call to GetFullPath() can throw if the relative path is some unsupported value or the paths are too long for the current file system
+                            // This falls back to previous behavior of returning a path that may not be correct but at least returns some value
+                        }
+                    }
                 }
 
                 return _absolutePath;
@@ -229,9 +244,9 @@ public IReadOnlyDictionary<string, ProjectConfigurationInSolution> ProjectConfig
 
         internal string TargetFrameworkMoniker { get; set; }
 
-#endregion
+        #endregion
 
-#region Methods
+        #region Methods
 
         private bool _checkedIfCanBeMSBuildProjectFile;
         private bool _canBeMSBuildProjectFile;
@@ -529,13 +544,13 @@ private static bool ElementContainsInvalidNamespaceDefitions(XmlElement mainProj
             return false;
         }
 
-#endregion
+        #endregion
 
-#region Constants
+        #region Constants
 
         internal const int DependencyLevelUnknown = -1;
         internal const int DependencyLevelBeingDetermined = -2;
 
-#endregion
+        #endregion
     }
 }
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index c365c1ee730..7de69fea0c3 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -189,6 +189,11 @@ internal int VisualStudioVersion
         /// </summary>
         public IReadOnlyDictionary<string, ProjectInSolution> ProjectsByGuid => new ReadOnlyDictionary<string, ProjectInSolution>(_projects);
 
+        /// <summary>
+        /// This is the read accessor for the solution filter file, if present. Set through FullPath.
+        /// </summary>
+        internal string SolutionFilterFilePath { get => _solutionFilterFile; }
+
         /// <summary>
         /// This is the read/write accessor for the solution file which we will parse.  This
         /// must be set before calling any other methods on this class.
@@ -612,7 +617,7 @@ internal void ParseSolution()
                 }
 
                 // Detect collision caused by unique name's normalization
-                if (projectsByUniqueName.ContainsKey(uniqueName))
+                if (projectsByUniqueName.TryGetValue(uniqueName, out ProjectInSolution project))
                 {
                     // Did normalization occur in the current project?
                     if (uniqueName != proj.ProjectName)
@@ -623,16 +628,14 @@ internal void ParseSolution()
                         uniqueName = tempUniqueName;
                     }
                     // Did normalization occur in a previous project?
-                    else if (uniqueName != projectsByUniqueName[uniqueName].ProjectName)
+                    else if (uniqueName != project.ProjectName)
                     {
-                        var projTemp = projectsByUniqueName[uniqueName];
-
                         // Generates a new unique name
-                        string tempUniqueName = $"{uniqueName}_{projTemp.GetProjectGuidWithoutCurlyBrackets()}";
-                        projTemp.UpdateUniqueProjectName(tempUniqueName);
+                        string tempUniqueName = $"{uniqueName}_{project.GetProjectGuidWithoutCurlyBrackets()}";
+                        project.UpdateUniqueProjectName(tempUniqueName);
 
                         projectsByUniqueName.Remove(uniqueName);
-                        projectsByUniqueName.Add(tempUniqueName, projTemp);
+                        projectsByUniqueName.Add(tempUniqueName, project);
                     }
                 }
 
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index d26fca3b0d3..d291d172bde 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -52,7 +52,7 @@ internal class SolutionProjectGenerator
         /// <summary>
         /// The set of properties all projects in the solution should be built with
         /// </summary>
-        private const string SolutionProperties = "BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)";
+        private const string SolutionProperties = "BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionFilterName=$(SolutionFilterName); SolutionPath=$(SolutionPath)";
 
         /// <summary>
         /// The set of properties which identify the configuration and platform to build a project with
@@ -94,6 +94,7 @@ internal class SolutionProjectGenerator
             new Tuple<string, string>("SolutionExt", null),
             new Tuple<string, string>("SolutionFileName", null),
             new Tuple<string, string>("SolutionName", null),
+            new Tuple<string, string>("SolutionFilterName", null),
             new Tuple<string, string>(SolutionPathPropertyName, null)
         };
 
@@ -499,7 +500,7 @@ bool specifyProjectToolsVersion
 
             string additionalProperties = string.Format(
                 CultureInfo.InvariantCulture,
-                "Configuration={0}; Platform={1}; BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)",
+                "Configuration={0}; Platform={1}; BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionFilterName=$(SolutionFilterName); SolutionPath=$(SolutionPath)",
                 EscapingUtilities.Escape(configurationName),
                 EscapingUtilities.Escape(platformName)
             );
@@ -782,7 +783,7 @@ private void EvaluateAndAddProjects(List<ProjectInSolution> projectsInOrder, Lis
                 AddTraversalTargetForProject(traversalInstance, project, projectConfiguration, "Publish", null, canBuildDirectly);
 
                 // Add any other targets specified by the user that were not already added
-                foreach (string targetName in _targetNames.Where(i => !traversalInstance.Targets.ContainsKey(i)))
+                foreach (string targetName in _targetNames.Except(traversalInstance.Targets.Keys, StringComparer.OrdinalIgnoreCase))
                 {
                     AddTraversalTargetForProject(traversalInstance, project, projectConfiguration, targetName, null, canBuildDirectly);
                 }
@@ -796,7 +797,7 @@ private void EvaluateAndAddProjects(List<ProjectInSolution> projectsInOrder, Lis
             }
 
             // Add any other targets specified by the user that were not already added
-            foreach (string targetName in _targetNames.Where(i => !traversalInstance.Targets.ContainsKey(i)))
+            foreach (string targetName in _targetNames.Except(traversalInstance.Targets.Keys, StringComparer.OrdinalIgnoreCase))
             {
                 AddTraversalReferencesTarget(traversalInstance, targetName, null);
             }
@@ -1201,7 +1202,7 @@ private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, Proj
                 AddMetaprojectTargetForWebProject(traversalProject, metaprojectInstance, project, "Rebuild");
                 AddMetaprojectTargetForWebProject(traversalProject, metaprojectInstance, project, "Publish");
 
-                foreach (string targetName in _targetNames.Where(i => !metaprojectInstance.Targets.ContainsKey(i)))
+                foreach (string targetName in _targetNames.Except(metaprojectInstance.Targets.Keys, StringComparer.OrdinalIgnoreCase))
                 {
                     AddMetaprojectTargetForWebProject(traversalProject, metaprojectInstance, project, targetName);
                 }
@@ -1221,7 +1222,7 @@ private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, Proj
                 AddMetaprojectTargetForManagedProject(traversalProject, metaprojectInstance, project, projectConfiguration, "Rebuild", targetOutputItemName);
                 AddMetaprojectTargetForManagedProject(traversalProject, metaprojectInstance, project, projectConfiguration, "Publish", null);
 
-                foreach (string targetName in _targetNames.Where(i => !metaprojectInstance.Targets.ContainsKey(i)))
+                foreach (string targetName in _targetNames.Except(metaprojectInstance.Targets.Keys, StringComparer.OrdinalIgnoreCase))
                 {
                     AddMetaprojectTargetForManagedProject(traversalProject, metaprojectInstance, project, projectConfiguration, targetName, null);
                 }
@@ -1233,7 +1234,7 @@ private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, Proj
                 AddMetaprojectTargetForUnknownProjectType(traversalProject, metaprojectInstance, project, "Rebuild", unknownProjectTypeErrorMessage);
                 AddMetaprojectTargetForUnknownProjectType(traversalProject, metaprojectInstance, project, "Publish", unknownProjectTypeErrorMessage);
 
-                foreach (string targetName in _targetNames.Where(i => !metaprojectInstance.Targets.ContainsKey(i)))
+                foreach (string targetName in _targetNames.Except(metaprojectInstance.Targets.Keys, StringComparer.OrdinalIgnoreCase))
                 {
                     AddMetaprojectTargetForUnknownProjectType(traversalProject, metaprojectInstance, project, targetName, unknownProjectTypeErrorMessage);
                 }
@@ -2291,6 +2292,7 @@ private void AddGlobalProperties(ProjectRootElement traversalProject)
             globalProperties.AddProperty("SolutionExt", EscapingUtilities.Escape(Path.GetExtension(_solutionFile.FullPath)));
             globalProperties.AddProperty("SolutionFileName", EscapingUtilities.Escape(Path.GetFileName(_solutionFile.FullPath)));
             globalProperties.AddProperty("SolutionName", EscapingUtilities.Escape(Path.GetFileNameWithoutExtension(_solutionFile.FullPath)));
+            globalProperties.AddProperty("SolutionFilterName", EscapingUtilities.Escape(Path.GetFileNameWithoutExtension(_solutionFile.SolutionFilterFilePath ?? string.Empty)));
 
             globalProperties.AddProperty(SolutionPathPropertyName, EscapingUtilities.Escape(Path.Combine(_solutionFile.SolutionFileDirectory, Path.GetFileName(_solutionFile.FullPath))));
 
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 285c4cc592a..f158ca5a2bb 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -2564,10 +2564,10 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
                 IEnumerable<string> removeFragmentStrings = Enumerable.Empty<string>();
                 IMSBuildGlob removeGlob = null;
 
-                if (removeElementCache.ContainsKey(itemElement.ItemType))
+                if (removeElementCache.TryGetValue(itemElement.ItemType, out CumulativeRemoveElementData removeItemElement))
                 {
-                    removeFragmentStrings = removeElementCache[itemElement.ItemType].FragmentStrings;
-                    removeGlob = new CompositeGlob(removeElementCache[itemElement.ItemType].Globs);
+                    removeFragmentStrings = removeItemElement.FragmentStrings;
+                    removeGlob = new CompositeGlob(removeItemElement.Globs);
                 }
 
                 var includeGlobWithGaps = CreateIncludeGlobWithGaps(includeGlob, excludeGlob, removeGlob);
@@ -2577,27 +2577,17 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
 
             private static IMSBuildGlob CreateIncludeGlobWithGaps(IMSBuildGlob includeGlob, IMSBuildGlob excludeGlob, IMSBuildGlob removeGlob)
             {
-                if (excludeGlob != null && removeGlob != null)
+                if (excludeGlob == null)
                 {
-                    return new MSBuildGlobWithGaps(
-                        includeGlob,
-                        new CompositeGlob(
-                            excludeGlob,
-                            removeGlob
-                        ));
+                    return removeGlob == null ? includeGlob :
+                        new MSBuildGlobWithGaps(includeGlob, removeGlob);
                 }
-
-                if (excludeGlob != null || removeGlob != null)
+                else
                 {
-                    var gapGlob = excludeGlob ?? removeGlob;
-
-                    return new MSBuildGlobWithGaps(
-                        includeGlob,
-                        gapGlob
-                    );
+                    return new MSBuildGlobWithGaps(includeGlob,
+                        removeGlob == null ? excludeGlob :
+                        new CompositeGlob(excludeGlob, removeGlob));
                 }
-
-                return includeGlob;
             }
 
             private void CacheInformationFromRemoveItem(ProjectItemElement itemElement, Dictionary<string, CumulativeRemoveElementData> removeElementCache)
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index ec52f815e3d..07519d583ba 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -1615,12 +1615,11 @@ private bool RemoveToolsetInternal(string toolsVersion)
         {
             Debug.Assert(_locker.IsWriteLockHeld);
 
-            if (!_toolsets.ContainsKey(toolsVersion))
+            if (!_toolsets.Remove(toolsVersion))
             {
                 return false;
             }
 
-            _toolsets.Remove(toolsVersion);
             _toolsetsVersion++;
             return true;
         }
@@ -1729,7 +1728,6 @@ private void CreateLoggingService(int maxCPUCount, bool onlyLogCriticalEvents)
             _loggingService.OnlyLogCriticalEvents = onlyLogCriticalEvents;
         }
 
-#if FEATURE_SYSTEM_CONFIGURATION
         /// <summary>
         /// Reset the toolsets using the provided toolset reader, used by unit tests
         /// </summary>
@@ -1737,7 +1735,6 @@ internal void ResetToolsetsForTests(ToolsetConfigurationReader configurationRead
         {
             InitializeToolsetCollection(configReader:configurationReaderForTestsOnly);
         }
-#endif
 
 #if FEATURE_WIN32_REGISTRY
         /// <summary>
@@ -1757,9 +1754,7 @@ private void InitializeToolsetCollection(
 #if FEATURE_WIN32_REGISTRY
                 ToolsetRegistryReader registryReader = null,
 #endif
-#if FEATURE_SYSTEM_CONFIGURATION
                 ToolsetConfigurationReader configReader = null
-#endif
                 )
         {
             _toolsets = new Dictionary<string, Toolset>(StringComparer.OrdinalIgnoreCase);
@@ -1769,9 +1764,7 @@ private void InitializeToolsetCollection(
 #if FEATURE_WIN32_REGISTRY
                     registryReader,
 #endif
-#if FEATURE_SYSTEM_CONFIGURATION
                     configReader,
-#endif
                     EnvironmentProperties, _globalProperties, ToolsetLocations);
 
             _toolsetsVersion++;
@@ -1801,7 +1794,7 @@ public ProjectAddedToProjectCollectionEventArgs(ProjectRootElement element)
         /// The ReusableLogger wraps a logger and allows it to be used for both design-time and build-time.  It internally swaps
         /// between the design-time and build-time event sources in response to Initialize and Shutdown events.
         /// </summary>
-        internal class ReusableLogger : INodeLogger, IEventSource3
+        internal class ReusableLogger : INodeLogger, IEventSource4
         {
             /// <summary>
             /// The logger we are wrapping.
@@ -1899,6 +1892,8 @@ internal class ReusableLogger : INodeLogger, IEventSource3
 
             private bool _includeTaskInputs;
 
+            private bool _includeEvaluationPropertiesAndItems;
+
             /// <summary>
             /// Constructor.
             /// </summary>
@@ -2038,6 +2033,22 @@ public void IncludeTaskInputs()
 
                 _includeTaskInputs = true;
             }
+
+            public void IncludeEvaluationPropertiesAndItems()
+            {
+                if (_buildTimeEventSource is IEventSource4 buildEventSource4)
+                {
+                    buildEventSource4.IncludeEvaluationPropertiesAndItems();
+                }
+
+                if (_designTimeEventSource is IEventSource4 designTimeEventSource4)
+                {
+                    designTimeEventSource4.IncludeEvaluationPropertiesAndItems();
+                }
+
+                _includeEvaluationPropertiesAndItems = true;
+            }
+
             #endregion
 
             #region ILogger Members
@@ -2170,6 +2181,7 @@ private void RegisterForEvents(IEventSource eventSource)
                     {
                         eventSource3.IncludeEvaluationMetaprojects();
                     }
+
                     if (_includeEvaluationProfiles)
                     {
                         eventSource3.IncludeEvaluationProfiles();
@@ -2180,6 +2192,14 @@ private void RegisterForEvents(IEventSource eventSource)
                         eventSource3.IncludeTaskInputs();
                     }
                 }
+
+                if (eventSource is IEventSource4 eventSource4)
+                {
+                    if (_includeEvaluationPropertiesAndItems)
+                    {
+                        eventSource4.IncludeEvaluationPropertiesAndItems();
+                    }
+                }
             }
 
             /// <summary>
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 52128c04fa6..5665b1aaf09 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -253,7 +253,11 @@ private static Configuration ReadApplicationConfiguration()
         {
             // When running from the command-line or from VS, use the msbuild.exe.config file.
             if (BuildEnvironmentHelper.Instance.Mode != BuildEnvironmentMode.None &&
+ // This FEATURE_SYSTEM_CONFIGURATION is needed as OpenExeConfiguration for net5.0 works differently, without this condition unit tests won't pass.
+ // ConfigurationManager.OpenExeConfiguration in net5.0 will find testhost.exe instead which does not contain any configuration and therefore fail.
+#if FEATURE_SYSTEM_CONFIGURATION
                 !BuildEnvironmentHelper.Instance.RunningTests &&
+#endif
                 FileSystems.Default.FileExists(BuildEnvironmentHelper.Instance.CurrentMSBuildConfigurationFile))
             {
                 var configFile = new ExeConfigurationFileMap { ExeConfigFilename = BuildEnvironmentHelper.Instance.CurrentMSBuildConfigurationFile };
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 3bcf77e90aa..869b3318ea4 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -76,7 +76,6 @@ protected abstract string DefaultOverrideToolsVersion
             get;
         }
 
-#if FEATURE_WIN32_REGISTRY || FEATURE_SYSTEM_CONFIGURATION
         /// <summary>
         /// Gathers toolset data from the registry and configuration file, if any:
         /// allows you to specify which of the registry and configuration file to
@@ -88,12 +87,9 @@ internal static string ReadAllToolsets(Dictionary<string, Toolset> toolsets, Pro
 #if FEATURE_WIN32_REGISTRY
                 null,
 #endif
-#if FEATURE_SYSTEM_CONFIGURATION
                 null,
-#endif
                 environmentProperties, globalProperties, locations);
         }
-#endif
 
         /// <summary>
         /// Gathers toolset data from the registry and configuration file, if any.
@@ -105,9 +101,7 @@ internal static string ReadAllToolsets
 #if FEATURE_WIN32_REGISTRY
             ToolsetRegistryReader registryReader,
 #endif
-#if FEATURE_SYSTEM_CONFIGURATION
             ToolsetConfigurationReader configurationReader,
-#endif
             PropertyDictionary<ProjectPropertyInstance> environmentProperties,
             PropertyDictionary<ProjectPropertyInstance> globalProperties,
             ToolsetDefinitionLocations locations
@@ -124,7 +118,6 @@ ToolsetDefinitionLocations locations
             string overrideTasksPathFromConfiguration = null;
             string defaultOverrideToolsVersionFromConfiguration = null;
 
-#if FEATURE_SYSTEM_CONFIGURATION
             if ((locations & ToolsetDefinitionLocations.ConfigurationFile) == ToolsetDefinitionLocations.ConfigurationFile)
             {
                 if (configurationReader == null)
@@ -137,7 +130,6 @@ ToolsetDefinitionLocations locations
                     initialProperties, true /* accumulate properties */, out overrideTasksPathFromConfiguration,
                     out defaultOverrideToolsVersionFromConfiguration);
             }
-#endif
 
             string defaultToolsVersionFromRegistry = null;
             string overrideTasksPathFromRegistry = null;
diff --git a/src/Build/Definition/ToolsetRegistryReader.cs b/src/Build/Definition/ToolsetRegistryReader.cs
index 7a083fbebbd..e2081dc5ad7 100644
--- a/src/Build/Definition/ToolsetRegistryReader.cs
+++ b/src/Build/Definition/ToolsetRegistryReader.cs
@@ -3,11 +3,8 @@
 
 #if FEATURE_WIN32_REGISTRY
 
-using Microsoft.Win32;
 using System;
 using System.Collections.Generic;
-using System.IO;
-using System.Security;
 
 using Microsoft.Build.Shared;
 using error = Microsoft.Build.Shared.ErrorUtilities;
@@ -346,4 +343,4 @@ private static string GetValue(RegistryKeyWrapper wrapper, string valueName)
         }
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/src/Build/Evaluation/Context/EvaluationContext.cs b/src/Build/Evaluation/Context/EvaluationContext.cs
index 633dd5404da..470b4f0cb1e 100644
--- a/src/Build/Evaluation/Context/EvaluationContext.cs
+++ b/src/Build/Evaluation/Context/EvaluationContext.cs
@@ -3,7 +3,7 @@
 
 using System;
 using System.Collections.Concurrent;
-using System.Collections.Immutable;
+using System.Collections.Generic;
 using System.Threading;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.FileSystem;
@@ -48,7 +48,7 @@ public enum SharingPolicy
         /// <summary>
         /// Key to file entry list. Example usages: cache glob expansion and intermediary directory expansions during glob expansion.
         /// </summary>
-        private ConcurrentDictionary<string, ImmutableArray<string>> FileEntryExpansionCache { get; }
+        private ConcurrentDictionary<string, IReadOnlyList<string>> FileEntryExpansionCache { get; }
 
         private EvaluationContext(SharingPolicy policy, IFileSystem fileSystem)
         {
@@ -61,7 +61,7 @@ private EvaluationContext(SharingPolicy policy, IFileSystem fileSystem)
             Policy = policy;
 
             SdkResolverService = new CachingSdkResolverService();
-            FileEntryExpansionCache = new ConcurrentDictionary<string, ImmutableArray<string>>();
+            FileEntryExpansionCache = new ConcurrentDictionary<string, IReadOnlyList<string>>();
             FileSystem = fileSystem ?? new CachingFileSystemWrapper(FileSystems.Default);
             EngineFileUtilities = new EngineFileUtilities(new FileMatcher(FileSystem, FileEntryExpansionCache));
         }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 5df077fe418..22107d15fcc 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using ObjectModel = System.Collections.ObjectModel;
@@ -777,12 +778,23 @@ private void Evaluate()
             }
 
             ErrorUtilities.VerifyThrow(_evaluationProfiler.IsEmpty(), "Evaluation profiler stack is not empty.");
-            _evaluationLoggingContext.LogBuildEvent(new ProjectEvaluationFinishedEventArgs(ResourceUtilities.GetResourceString("EvaluationFinished"), projectFile)
+
+            IEnumerable globalProperties = null;
+            IEnumerable properties = null;
+            IEnumerable items = null;
+
+            if (this._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)
             {
-                BuildEventContext = _evaluationLoggingContext.BuildEventContext,
-                ProjectFile = projectFile,
-                ProfilerResult = _evaluationProfiler.ProfiledResult
-            });
+                if (_data.GlobalPropertiesDictionary.Count > 0)
+                {
+                    globalProperties = _data.GlobalPropertiesDictionary;
+                }
+
+                properties = _data.Properties;
+                items = _data.Items;
+            }
+
+            _evaluationLoggingContext.LogProjectEvaluationFinished(globalProperties, properties, items, _evaluationProfiler.ProfiledResult);
         }
 
         private void CollectProjectCachePlugins()
@@ -849,14 +861,10 @@ private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)
                             _itemDefinitionGroupElements.Add(itemDefinitionGroup);
                             break;
                         case ProjectTargetElement target:
-                            if (_projectSupportsReturnsAttribute.ContainsKey(currentProjectOrImport))
-                            {
-                                _projectSupportsReturnsAttribute[currentProjectOrImport] |= (target.Returns != null);
-                            }
-                            else
-                            {
-                                _projectSupportsReturnsAttribute[currentProjectOrImport] = (target.Returns != null);
-                            }
+                            // Defaults to false
+                            _projectSupportsReturnsAttribute.TryGetValue(currentProjectOrImport, out NGen<bool> projectSupportsReturnsAttribute);
+
+                            _projectSupportsReturnsAttribute[currentProjectOrImport] = projectSupportsReturnsAttribute || (target.Returns != null);
                             _targetElements.Add(target);
                             break;
                         case ProjectImportElement import:
@@ -1927,17 +1935,43 @@ ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
         private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(string directoryOfImportingFile, ProjectImportElement importElement, string unescapedExpression,
                                             bool throwOnFileNotExistsError, out List<ProjectRootElement> imports)
         {
+            imports = new List<ProjectRootElement>();
+
             string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation);
             ElementLocation importLocationInProject = importElement.Location;
 
             if (String.IsNullOrWhiteSpace(importExpressionEscaped))
             {
+                if ((_loadSettings & ProjectLoadSettings.IgnoreInvalidImports) != 0)
+                {
+                    // Log message for import skipped
+                    ProjectImportedEventArgs eventArgs = new ProjectImportedEventArgs(
+                        importElement.Location.Line,
+                        importElement.Location.Column,
+                        ResourceUtilities.GetResourceString("ProjectImportSkippedExpressionEvaluatedToEmpty"),
+                        unescapedExpression,
+                        importElement.ContainingProject.FullPath,
+                        importElement.Location.Line,
+                        importElement.Location.Column)
+                    {
+                        BuildEventContext = _evaluationLoggingContext.BuildEventContext,
+                        UnexpandedProject = importElement.Project,
+                        ProjectFile = importElement.ContainingProject.FullPath,
+                        ImportedProjectFile = string.Empty,
+                        ImportIgnored = true,
+                    };
+
+                    _evaluationLoggingContext.LogBuildEvent(eventArgs);
+
+                    return LoadImportsResult.ImportExpressionResolvedToNothing;
+                }
+
                 ProjectErrorUtilities.ThrowInvalidProject(importLocationInProject, "InvalidAttributeValue", String.Empty, XMakeAttributes.project, XMakeElements.import);
             }
 
             bool atleastOneImportIgnored = false;
             bool atleastOneImportEmpty = false;
-            imports = new List<ProjectRootElement>();
+            
             foreach (string importExpressionEscapedItem in ExpressionShredder.SplitSemiColonSeparatedList(importExpressionEscaped))
             {
                 string[] importFilesEscaped = null;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index ad43ca4dc2a..5fa15be5d91 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -123,6 +123,136 @@ internal class Expander<P, I>
         where P : class, IProperty
         where I : class, IItem
     {
+        /// <summary>
+        /// A helper struct wrapping a <see cref="SpanBasedStringBuilder"/> and providing file path conversion
+        /// as used in e.g. property expansion.
+        /// </summary>
+        /// <remarks>
+        /// If exactly one value is added and no concatenation takes places, this value is returned without
+        /// conversion. In other cases values are stringified and attempted to be interpreted as file paths
+        /// before concatenation.
+        /// </remarks>
+        private struct SpanBasedConcatenator : IDisposable
+        {
+            /// <summary>
+            /// The backing <see cref="SpanBasedStringBuilder"/>, null until the second value is added.
+            /// </summary>
+            private SpanBasedStringBuilder _builder;
+
+            /// <summary>
+            /// The first value added to the concatenator. Tracked in its own field so it can be returned
+            /// without conversion if no concatenation takes place.
+            /// </summary>
+            private object _firstObject;
+
+            /// <summary>
+            /// The first value added to the concatenator if it is a span. Tracked in its own field so the
+            /// <see cref="SpanBasedStringBuilder"/> functionality doesn't have to be invoked if no concatenation
+            /// takes place.
+            /// </summary>
+            private ReadOnlyMemory<char> _firstSpan;
+
+            /// <summary>
+            /// True if this instance is already disposed.
+            /// </summary>
+            private bool _disposed;
+
+            /// <summary>
+            /// Adds an object to be concatenated.
+            /// </summary>
+            public void Add(object obj)
+            {
+                CheckDisposed();
+                FlushFirstValueIfNeeded();
+                if (_builder != null)
+                {
+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(obj.ToString()));
+                }
+                else
+                {
+                    _firstObject = obj;
+                }
+            }
+
+            /// <summary>
+            /// Adds a span to be concatenated.
+            /// </summary>
+            public void Add(ReadOnlyMemory<char> span)
+            {
+                CheckDisposed();
+                FlushFirstValueIfNeeded();
+                if (_builder != null)
+                {
+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(span));
+                }
+                else
+                {
+                    _firstSpan = span;
+                }
+            }
+
+            /// <summary>
+            /// Returns the result of the concatenation.
+            /// </summary>
+            /// <returns>
+            /// If only one value has been added and it is not a string, it is returned unchanged.
+            /// In all other cases (no value, one string value, multiple values) the result is a
+            /// concatenation of the string representation of the values, each additionally subjected
+            /// to file path adjustment.
+            /// </returns>
+            public object GetResult()
+            {
+                CheckDisposed();
+                if (_firstObject != null)
+                {
+                    return (_firstObject is string stringValue) ? FileUtilities.MaybeAdjustFilePath(stringValue) : _firstObject;
+                }
+                return _firstSpan.IsEmpty
+                    ? _builder?.ToString() ?? string.Empty
+                    : FileUtilities.MaybeAdjustFilePath(_firstSpan).ToString();
+            }
+
+            /// <summary>
+            /// Disposes of the struct by delegating the call to the underlying <see cref="SpanBasedStringBuilder"/>.
+            /// </summary>
+            public void Dispose()
+            {
+                CheckDisposed();
+                _builder?.Dispose();
+                _disposed = true;
+            }
+
+            /// <summary>
+            /// Throws <see cref="ObjectDisposedException"/> if this concatenator is already disposed.
+            /// </summary>
+            private void CheckDisposed() =>
+                ErrorUtilities.VerifyThrowObjectDisposed(!_disposed, nameof(SpanBasedConcatenator));
+
+            /// <summary>
+            /// Lazily initializes <see cref="_builder"/> and populates it with the first value
+            /// when the second value is being added.
+            /// </summary>
+            private void FlushFirstValueIfNeeded()
+            {
+                if (_firstObject != null)
+                {
+                    _builder = Strings.GetSpanBasedStringBuilder();
+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstObject.ToString()));
+                    _firstObject = null;
+                }
+                else if (!_firstSpan.IsEmpty)
+                {
+                    _builder = Strings.GetSpanBasedStringBuilder();
+#if FEATURE_SPAN
+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstSpan));
+#else
+                    _builder.Append(FileUtilities.MaybeAdjustFilePath(_firstSpan.ToString()));
+#endif
+                    _firstSpan = new ReadOnlyMemory<char>();
+                }
+            }
+        }
+
         /// <summary>
         /// A limit for truncating string expansions within an evaluated Condition. Properties, item metadata, or item groups will be truncated to N characters such as 'N...'.
         /// Enabled by ExpanderOptions.Truncate.
@@ -483,19 +613,6 @@ private static bool IsTruncationEnabled(ExpanderOptions options)
             return (options & ExpanderOptions.Truncate) != 0 && !Traits.Instance.EscapeHatches.DoNotTruncateConditions && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_8);
         }
 
-        /// <summary>
-        /// Scan for the closing bracket that matches the one we've already skipped;
-        /// essentially, pushes and pops on a stack of parentheses to do this.
-        /// Takes the expression and the index to start at.
-        /// Returns the index of the matching parenthesis, or -1 if it was not found.
-        /// </summary>
-        private static int ScanForClosingParenthesis(string expression, int index)
-        {
-            bool potentialPropertyFunction;
-            bool potentialRegistryFunction;
-            return ScanForClosingParenthesis(expression, index, out potentialPropertyFunction, out potentialRegistryFunction);
-        }
-
         /// <summary>
         /// Scan for the closing bracket that matches the one we've already skipped;
         /// essentially, pushes and pops on a stack of parentheses to do this.
@@ -512,16 +629,15 @@ private static int ScanForClosingParenthesis(string expression, int index, out b
             potentialPropertyFunction = false;
             potentialRegistryFunction = false;
 
-            unsafe
+            // Scan for our closing ')'
+            while (index < length && nestLevel > 0)
             {
-                fixed (char* pchar = expression)
+                char character = expression[index];
+                switch (character)
                 {
-                    // Scan for our closing ')'
-                    while (index < length && nestLevel > 0)
-                    {
-                        char character = pchar[index];
-
-                        if (character == '\'' || character == '`' || character == '"')
+                    case '\'':
+                    case '`':
+                    case '"':
                         {
                             index++;
                             index = ScanForClosingQuote(character, expression, index);
@@ -530,27 +646,33 @@ private static int ScanForClosingParenthesis(string expression, int index, out b
                             {
                                 return -1;
                             }
+                            break;
                         }
-                        else if (character == '(')
+                    case '(':
                         {
                             nestLevel++;
+                            break;
                         }
-                        else if (character == ')')
+                    case ')':
                         {
                             nestLevel--;
+                            break;
                         }
-                        else if (character == '.' || character == '[' || character == '$')
+                    case '.':
+                    case '[':
+                    case '$':
                         {
                             potentialPropertyFunction = true;
+                            break;
                         }
-                        else if (character == ':')
+                    case ':':
                         {
                             potentialRegistryFunction = true;
+                            break;
                         }
-
-                        index++;
-                    }
                 }
+
+                index++;
             }
 
             // We will have parsed past the ')', so step back one character
@@ -564,24 +686,8 @@ private static int ScanForClosingParenthesis(string expression, int index, out b
         /// </summary>
         private static int ScanForClosingQuote(char quoteChar, string expression, int index)
         {
-            unsafe
-            {
-                fixed (char* pchar = expression)
-                {
-                    // Scan for our closing quoteChar
-                    while (index < expression.Length)
-                    {
-                        if (pchar[index] == quoteChar)
-                        {
-                            return index;
-                        }
-
-                        index++;
-                    }
-                }
-            }
-
-            return -1;
+            // Scan for our closing quoteChar
+            return expression.IndexOf(quoteChar, index);
         }
 
         /// <summary>
@@ -666,7 +772,7 @@ void FlushCurrentArgumentToArgumentBuilder(int argumentEndIndex)
                     n += 2; // skip over the opening '$('
 
                     // Scan for the matching closing bracket, skipping any nested ones
-                    n = ScanForClosingParenthesis(argumentsString, n);
+                    n = ScanForClosingParenthesis(argumentsString, n, out _, out _);
 
                     if (n == -1)
                     {
@@ -1000,8 +1106,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 // so that we can either maintain the object's type in the event
                 // that we have a single component, or convert to a string
                 // if concatenation is required.
-                List<object> results = null;
-                object lastResult = null;
+                using Expander<P, I>.SpanBasedConcatenator results = new Expander<P, I>.SpanBasedConcatenator();
 
                 // The sourceIndex is the zero-based index into the expression,
                 // where we've essentially read up to and copied into the target string.
@@ -1011,36 +1116,18 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 // any more.
                 while (propertyStartIndex != -1)
                 {
-                    if (lastResult != null)
-                    {
-                        if (results == null)
-                        {
-                            results = new List<object>(4);
-                        }
-
-                        results.Add(lastResult);
-                    }
-
-
                     // Append the result with the portion of the expression up to
                     // (but not including) the "$(", and advance the sourceIndex pointer.
                     if (propertyStartIndex - sourceIndex > 0)
                     {
-                        if (results == null)
-                        {
-                            results = new List<object>(4);
-                        }
-
-                        results.Add(expression.Substring(sourceIndex, propertyStartIndex - sourceIndex));
+                        results.Add(expression.AsMemory(sourceIndex, propertyStartIndex - sourceIndex));
                     }
 
-                    bool tryExtractPropertyFunction;
-                    bool tryExtractRegistryFunction;
                     // Following the "$(" we need to locate the matching ')'
                     // Scan for the matching closing bracket, skipping any nested ones
                     // This is a very complete, fast validation of parenthesis matching including for nested
                     // function calls.
-                    propertyEndIndex = ScanForClosingParenthesis(expression, propertyStartIndex + 2, out tryExtractPropertyFunction, out tryExtractRegistryFunction);
+                    propertyEndIndex = ScanForClosingParenthesis(expression, propertyStartIndex + 2, out bool tryExtractPropertyFunction, out bool tryExtractRegistryFunction);
 
                     if (propertyEndIndex == -1)
                     {
@@ -1048,7 +1135,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         // isn't really a well-formed property tag.  Just literally
                         // copy the remainder of the expression (starting with the "$("
                         // that we found) into the result, and quit.
-                        lastResult = expression.Substring(propertyStartIndex, expression.Length - propertyStartIndex);
+                        results.Add(expression.AsMemory(propertyStartIndex, expression.Length - propertyStartIndex));
                         sourceIndex = expression.Length;
                     }
                     else
@@ -1125,60 +1212,20 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         // Record our result, and advance
                         // our sourceIndex pointer to the character just after the closing
                         // parenthesis.
-                        lastResult = propertyValue;
+                        results.Add(propertyValue);
                         sourceIndex = propertyEndIndex + 1;
                     }
 
                     propertyStartIndex = s_invariantCompareInfo.IndexOf(expression, "$(", sourceIndex, CompareOptions.Ordinal);
                 }
 
-                // If we have only a single result, then just return it
-                if (results == null && expression.Length == sourceIndex)
+                // If we couldn't find any more property tags in the expression just copy the remainder into the result.
+                if (expression.Length - sourceIndex > 0)
                 {
-                    var resultString = lastResult as string;
-                    return resultString != null ? FileUtilities.MaybeAdjustFilePath(resultString) : lastResult;
+                    results.Add(expression.AsMemory(sourceIndex, expression.Length - sourceIndex));
                 }
-                else
-                {
-                    // The expression is constant, return it as is
-                    if (sourceIndex == 0)
-                    {
-                        return expression;
-                    }
-
-                    // We have more than one result collected, therefore we need to concatenate
-                    // into the final result string. This does mean that we will lose type information.
-                    // However since the user wanted contatenation, then they clearly wanted that to happen.
-
-                    // Initialize our output string to empty string.
-                    // This method is called very often - of the order of 3,000 times per project.
-                    using SpanBasedStringBuilder result = Strings.GetSpanBasedStringBuilder();
-
-                    // Append our collected results
-                    if (results != null)
-                    {
-                        // Create a combined result string from the result components that we've gathered
-                        foreach (object component in results)
-                        {
-                            result.Append(FileUtilities.MaybeAdjustFilePath(component.ToString()));
-                        }
-                    }
-
-                    // Append the last result we collected (it wasn't added to the list)
-                    if (lastResult != null)
-                    {
-                        result.Append(FileUtilities.MaybeAdjustFilePath(lastResult.ToString()));
-                    }
 
-                    // And if we couldn't find anymore property tags in the expression,
-                    // so just literally copy the remainder into the result.
-                    if (expression.Length - sourceIndex > 0)
-                    {
-                        result.Append(expression, sourceIndex, expression.Length - sourceIndex);
-                    }
-
-                    return result.ToString();
-                }
+                return results.GetResult();
             }
 
             /// <summary>
@@ -1306,76 +1353,72 @@ internal static object ExpandPropertyBody(
             /// </summary>
             internal static string ConvertToString(object valueToConvert)
             {
-                if (valueToConvert != null)
+                if (valueToConvert == null)
                 {
-                    Type valueType = valueToConvert.GetType();
-                    string convertedString;
-
-                    // If the type is a string, then there is nothing to do
-                    if (valueType == typeof(string))
-                    {
-                        convertedString = (string)valueToConvert;
-                    }
-                    else if (valueToConvert is IDictionary dictionary)
-                    {
-                        // If the return type is an IDictionary, then we convert this to
-                        // a semi-colon delimited set of A=B pairs.
-                        // Key and Value are converted to string and escaped
-                        if (dictionary.Count > 0)
-                        {
-                            using SpanBasedStringBuilder builder = Strings.GetSpanBasedStringBuilder();
-
-                            foreach (DictionaryEntry entry in dictionary)
-                            {
-                                if (builder.Length > 0)
-                                {
-                                    builder.Append(";");
-                                }
-
-                                // convert and escape each key and value in the dictionary entry
-                                builder.Append(EscapingUtilities.Escape(ConvertToString(entry.Key)));
-                                builder.Append("=");
-                                builder.Append(EscapingUtilities.Escape(ConvertToString(entry.Value)));
-                            }
+                    return String.Empty;
+                }
+                // If the value is a string, then there is nothing to do
+                if (valueToConvert is string stringValue)
+                {
+                    return stringValue;
+                }
 
-                            convertedString = builder.ToString();
-                        }
-                        else
-                        {
-                            convertedString = string.Empty;
-                        }
-                    }
-                    else if (valueToConvert is IEnumerable enumerable)
+                string convertedString;
+                if (valueToConvert is IDictionary dictionary)
+                {
+                    // If the return type is an IDictionary, then we convert this to
+                    // a semi-colon delimited set of A=B pairs.
+                    // Key and Value are converted to string and escaped
+                    if (dictionary.Count > 0)
                     {
-                        // If the return is enumerable, then we'll convert to semi-colon delimited elements
-                        // each of which must be converted, so we'll recurse for each element
                         using SpanBasedStringBuilder builder = Strings.GetSpanBasedStringBuilder();
 
-                        foreach (object element in enumerable)
+                        foreach (DictionaryEntry entry in dictionary)
                         {
                             if (builder.Length > 0)
                             {
                                 builder.Append(";");
                             }
 
-                            // we need to convert and escape each element of the array
-                            builder.Append(EscapingUtilities.Escape(ConvertToString(element)));
+                            // convert and escape each key and value in the dictionary entry
+                            builder.Append(EscapingUtilities.Escape(ConvertToString(entry.Key)));
+                            builder.Append("=");
+                            builder.Append(EscapingUtilities.Escape(ConvertToString(entry.Value)));
                         }
 
                         convertedString = builder.ToString();
                     }
                     else
                     {
-                        // The fall back is always to just convert to a string directly.
-                        convertedString = valueToConvert.ToString();
+                        convertedString = string.Empty;
+                    }
+                }
+                else if (valueToConvert is IEnumerable enumerable)
+                {
+                    // If the return is enumerable, then we'll convert to semi-colon delimited elements
+                    // each of which must be converted, so we'll recurse for each element
+                    using SpanBasedStringBuilder builder = Strings.GetSpanBasedStringBuilder();
+
+                    foreach (object element in enumerable)
+                    {
+                        if (builder.Length > 0)
+                        {
+                            builder.Append(";");
+                        }
+
+                        // we need to convert and escape each element of the array
+                        builder.Append(EscapingUtilities.Escape(ConvertToString(element)));
                     }
 
-                    return convertedString;
+                    convertedString = builder.ToString();
                 }
                 else
                 {
-                    return String.Empty;
+                    // The fall back is always to just convert to a string directly.
+                    convertedString = valueToConvert.ToString();
                 }
+
+                return convertedString;
             }
 
             /// <summary>
@@ -4736,7 +4779,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
                     argumentStartIndex++;
 
                     // Scan for the matching closing bracket, skipping any nested ones
-                    int argumentsEndIndex = ScanForClosingParenthesis(expressionFunction, argumentStartIndex);
+                    int argumentsEndIndex = ScanForClosingParenthesis(expressionFunction, argumentStartIndex, out _, out _);
 
                     if (argumentsEndIndex == -1)
                     {
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index a69377a772b..7a1cb4db89b 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -211,31 +211,28 @@ private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocat
                         // The expression is not of the form "@(X)". Treat as string
 
                         //  Code corresponds to EngineFileUtilities.GetFileList
-                        var containsEscapedWildcards = EscapingUtilities.ContainsEscapedWildcards(splitEscaped);
-                        var containsRealWildcards = FileMatcher.HasWildcards(splitEscaped);
+                        if (!FileMatcher.HasWildcards(splitEscaped))
+                        {
+                            // No real wildcards means we just return the original string.  Don't even bother
+                            // escaping ... it should already be escaped appropriately since it came directly
+                            // from the project file
 
-                        // '*' is an illegal character to have in a filename.
-                        // todo: file-system assumption on legal path characters: https://github.com/Microsoft/msbuild/issues/781
-                        if (containsEscapedWildcards && containsRealWildcards)
+                            fragments.Add(new ValueFragment(splitEscaped, projectDirectory));
+                        }
+                        else if (EscapingUtilities.ContainsEscapedWildcards(splitEscaped))
                         {
+                            // '*' is an illegal character to have in a filename.
+                            // todo: file-system assumption on legal path characters: https://github.com/Microsoft/msbuild/issues/781
                             // Just return the original string.
                             fragments.Add(new ValueFragment(splitEscaped, projectDirectory));
                         }
-                        else if (!containsEscapedWildcards && containsRealWildcards)
+                        else
                         {
                             // Unescape before handing it to the filesystem.
                             var filespecUnescaped = EscapingUtilities.UnescapeAll(splitEscaped);
 
                             fragments.Add(new GlobFragment(filespecUnescaped, projectDirectory));
                         }
-                        else
-                        {
-                            // No real wildcards means we just return the original string.  Don't even bother 
-                            // escaping ... it should already be escaped appropriately since it came directly
-                            // from the project file
-
-                            fragments.Add(new ValueFragment(splitEscaped, projectDirectory));
-                        }
                     }
                 }
             }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 9934759efbf..b072a36f854 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -162,10 +162,8 @@ private string RouteCall(string itemType, string name, Func<IMetadataTable, stri
                     {
                         return getEscapedValueFunc(_operationItem, itemType, name);
                     }
-                    else if (_capturedItems.ContainsKey(itemType))
+                    else if (_capturedItems.TryGetValue(itemType, out var item))
                     {
-                        var item = _capturedItems[itemType];
-
                         return getEscapedValueFunc(item, itemType, name);
                     }
                     else
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index 4b03541b3df..0420aa9edd3 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -28,11 +28,10 @@ private readonly struct GlobState
             public string FixedDirectoryPart { get; }
             public string WildcardDirectoryPart { get; }
             public string FilenamePart { get; }
-            public string MatchFileExpression { get; }
             public bool NeedsRecursion { get; }
             public Regex Regex { get; }
 
-            public GlobState(string globRoot, string fileSpec, bool isLegal, string fixedDirectoryPart, string wildcardDirectoryPart, string filenamePart, string matchFileExpression, bool needsRecursion, Regex regex)
+            public GlobState(string globRoot, string fileSpec, bool isLegal, string fixedDirectoryPart, string wildcardDirectoryPart, string filenamePart, bool needsRecursion, Regex regex)
             {
                 GlobRoot = globRoot;
                 FileSpec = fileSpec;
@@ -40,7 +39,6 @@ public GlobState(string globRoot, string fileSpec, bool isLegal, string fixedDir
                 FixedDirectoryPart = fixedDirectoryPart;
                 WildcardDirectoryPart = wildcardDirectoryPart;
                 FilenamePart = filenamePart;
-                MatchFileExpression = matchFileExpression;
                 NeedsRecursion = needsRecursion;
                 Regex = regex;
             }
@@ -117,23 +115,20 @@ public MatchInfoResult MatchInfo(string stringToMatch)
         {
             ErrorUtilities.VerifyThrowArgumentNull(stringToMatch, nameof(stringToMatch));
 
-            if (FileUtilities.PathIsInvalid(stringToMatch) ||
-                !IsLegal)
+            if (FileUtilities.PathIsInvalid(stringToMatch) || !IsLegal)
             {
                 return MatchInfoResult.Empty;
             }
 
-            var normalizedInput = NormalizeMatchInput(stringToMatch);
+            string normalizedInput = NormalizeMatchInput(stringToMatch);
 
-            bool isMatch;
-            string fixedDirectoryPart, wildcardDirectoryPart, filenamePart;
             FileMatcher.GetRegexMatchInfo(
                 normalizedInput,
                 _state.Value.Regex,
-                out isMatch,
-                out fixedDirectoryPart,
-                out wildcardDirectoryPart,
-                out filenamePart);
+                out bool isMatch,
+                out string fixedDirectoryPart,
+                out string wildcardDirectoryPart,
+                out string filenamePart);
 
             return new MatchInfoResult(isMatch, fixedDirectoryPart, wildcardDirectoryPart, filenamePart);
         }
@@ -145,7 +140,7 @@ private string NormalizeMatchInput(string stringToMatch)
 
             // Degenerate case when the string to match is empty.
             // Ensure trailing slash because the fixed directory part has a trailing slash.
-            if (stringToMatch == string.Empty)
+            if (string.IsNullOrEmpty(stringToMatch))
             {
                 normalizedInput += Path.DirectorySeparatorChar;
             }
@@ -172,7 +167,7 @@ public static MSBuildGlob Parse(string globRoot, string fileSpec)
             ErrorUtilities.VerifyThrowArgumentNull(fileSpec, nameof(fileSpec));
             ErrorUtilities.VerifyThrowArgumentInvalidPath(globRoot, nameof(globRoot));
 
-            if (globRoot == string.Empty)
+            if (string.IsNullOrEmpty(globRoot))
             {
                 globRoot = Directory.GetCurrentDirectory();
             }
@@ -181,22 +176,13 @@ public static MSBuildGlob Parse(string globRoot, string fileSpec)
 
             var lazyState = new Lazy<GlobState>(() =>
             {
-                string fixedDirectoryPart = null;
-                string wildcardDirectoryPart = null;
-                string filenamePart = null;
-
-                string matchFileExpression;
-                bool needsRecursion;
-                bool isLegalFileSpec;
-
                 FileMatcher.Default.GetFileSpecInfo(
                     fileSpec,
-                    out fixedDirectoryPart,
-                    out wildcardDirectoryPart,
-                    out filenamePart,
-                    out matchFileExpression,
-                    out needsRecursion,
-                    out isLegalFileSpec,
+                    out string fixedDirectoryPart,
+                    out string wildcardDirectoryPart,
+                    out string filenamePart,
+                    out bool needsRecursion,
+                    out bool isLegalFileSpec,
                     (fixedDirPart, wildcardDirPart, filePart) =>
                     {
                         var normalizedFixedPart = NormalizeTheFixedDirectoryPartAgainstTheGlobRoot(fixedDirPart, globRoot);
@@ -207,6 +193,8 @@ public static MSBuildGlob Parse(string globRoot, string fileSpec)
                 Regex regex = null;
                 if (isLegalFileSpec)
                 {
+                    string matchFileExpression = FileMatcher.RegularExpressionFromFileSpec(fixedDirectoryPart, wildcardDirectoryPart, filenamePart);
+
                     lock (s_regexCache)
                     {
                         s_regexCache.TryGetValue(matchFileExpression, out regex);
@@ -226,7 +214,7 @@ public static MSBuildGlob Parse(string globRoot, string fileSpec)
                         regex ??= newRegex;
                     }
                 }
-                return new GlobState(globRoot, fileSpec, isLegalFileSpec, fixedDirectoryPart, wildcardDirectoryPart, filenamePart, matchFileExpression, needsRecursion, regex);
+                return new GlobState(globRoot, fileSpec, isLegalFileSpec, fixedDirectoryPart, wildcardDirectoryPart, filenamePart, needsRecursion, regex);
             },
             true);
 
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 856e514719a..4f9c7d0879c 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -209,18 +209,15 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
             {
                 var referencingProjectPath = solutionDependency.Key;
 
-                ErrorUtilities.VerifyThrow(projectsByPath.ContainsKey(referencingProjectPath), "nodes should include solution projects");
+                ErrorUtilities.VerifyThrow(projectsByPath.TryGetValue(referencingProjectPath, out var referencingNodes), "nodes should include solution projects");
 
                 var referencedNodes = solutionDependency.Value.SelectMany(
                     referencedProjectPath =>
                     {
-                        ErrorUtilities.VerifyThrow(projectsByPath.ContainsKey(referencedProjectPath), "nodes should include solution projects");
-
-                        return projectsByPath[referencedProjectPath];
+                        ErrorUtilities.VerifyThrow(projectsByPath.TryGetValue(referencedProjectPath, out List<ProjectGraphNode> projectToReturn), "nodes should include solution projects");
+                        return projectToReturn;
                     }).ToArray();
 
-                var referencingNodes = projectsByPath[referencingProjectPath];
-
                 foreach (var referencingNode in referencingNodes)
                 {
                     foreach (var referencedNode in referencedNodes)
@@ -310,12 +307,12 @@ IReadOnlyCollection<ProjectInSolution> GetBuildableProjects(SolutionFile solutio
 
             SolutionConfigurationInSolution SelectSolutionConfiguration(SolutionFile solutionFile, ImmutableDictionary<string, string> globalProperties)
             {
-                var solutionConfiguration = globalProperties.ContainsKey("Configuration")
-                    ? globalProperties["Configuration"]
+                var solutionConfiguration = globalProperties.TryGetValue("Configuration", out string configuration)
+                    ? configuration
                     : solutionFile.GetDefaultConfigurationName();
 
-                var solutionPlatform = globalProperties.ContainsKey("Platform")
-                    ? globalProperties["Platform"]
+                var solutionPlatform = globalProperties.TryGetValue("Platform", out string platform)
+                    ? platform
                     : solutionFile.GetDefaultPlatformName();
 
                 return new SolutionConfigurationInSolution(solutionConfiguration, solutionPlatform);
@@ -329,9 +326,9 @@ ProjectConfigurationInSolution SelectProjectConfiguration(
 
                 var solutionConfigFullName = solutionConfig.FullName;
 
-                if (projectConfigs.ContainsKey(solutionConfigFullName))
+                if (projectConfigs.TryGetValue(solutionConfigFullName, out ProjectConfigurationInSolution projectConfiguration))
                 {
-                    return projectConfigs[solutionConfigFullName];
+                    return projectConfiguration;
                 }
 
                 var partiallyMarchedConfig = projectConfigs.FirstOrDefault(pc => pc.Value.ConfigurationName.Equals(solutionConfig.ConfigurationName, StringComparison.OrdinalIgnoreCase)).Value;
@@ -417,14 +414,14 @@ private void DetectCycles(
 
             foreach (var entryPointNode in entryPointNodes)
             {
-                if (!nodeStates.ContainsKey(entryPointNode))
+                if (!nodeStates.TryGetValue(entryPointNode, out NodeVisitationState state))
                 {
                     VisitNode(entryPointNode, nodeStates);
                 }
                 else
                 {
                     ErrorUtilities.VerifyThrow(
-                        nodeStates[entryPointNode] == NodeVisitationState.Processed,
+                        state == NodeVisitationState.Processed,
                         "entrypoints should get processed after a call to detect cycles");
                 }
             }
@@ -616,8 +613,8 @@ public ProjectItemInstance this[(ProjectGraphNode node, ProjectGraphNode referen
             {
                 get
                 {
-                    ErrorUtilities.VerifyThrow(ReferenceItems.ContainsKey(key), "All requested keys should exist");
-                    return ReferenceItems[key];
+                    ErrorUtilities.VerifyThrow(ReferenceItems.TryGetValue(key, out ProjectItemInstance referenceItem), "All requested keys should exist");
+                    return referenceItem;
                 }
 
                 // First edge wins, in accordance with vanilla msbuild behaviour when multiple msbuild tasks call into the same logical project
@@ -626,9 +623,7 @@ public ProjectItemInstance this[(ProjectGraphNode node, ProjectGraphNode referen
 
             public void RemoveEdge((ProjectGraphNode node, ProjectGraphNode reference) key)
             {
-                ErrorUtilities.VerifyThrow(ReferenceItems.ContainsKey(key), "All requested keys should exist");
-
-                ReferenceItems.TryRemove(key, out _);
+                ErrorUtilities.VerifyThrow(ReferenceItems.TryRemove(key, out _), "All requested keys should exist");
             }
 
             internal bool HasEdge((ProjectGraphNode node, ProjectGraphNode reference) key) => ReferenceItems.ContainsKey(key);
diff --git a/src/Build/Instance/HostServices.cs b/src/Build/Instance/HostServices.cs
index 98c03f1fe7a..a27e5787cfb 100644
--- a/src/Build/Instance/HostServices.cs
+++ b/src/Build/Instance/HostServices.cs
@@ -181,15 +181,8 @@ public void UnregisterProject(string projectFullPath)
         {
             if (projectFullPath != null)
             {
-                if (_hostObjectMap?.ContainsKey(projectFullPath) == true)
-                {
-                    _hostObjectMap.Remove(projectFullPath);
-                }
-
-                if (_projectAffinities?.ContainsKey(projectFullPath) == true)
-                {
-                    _projectAffinities.Remove(projectFullPath);
-                }
+                _hostObjectMap?.Remove(projectFullPath);
+                _projectAffinities?.Remove(projectFullPath);
             }
         }
 
@@ -323,14 +316,15 @@ void ITranslatable.Translate(ITranslator translator)
                     var hostObjectMapPairKeyTaskName = translator.Reader.ReadString();
                     var hostObjectMapPairValueMonikerName = translator.Reader.ReadString();
                     var targetTaskKey = new HostObjects.TargetTaskKey(hostObjectMapPairKeyTargetName, hostObjectMapPairKeyTaskName);
-                    if (!hostObjectMap.ContainsKey(pairKey))
+                    if (!hostObjectMap.TryGetValue(pairKey, out HostObjects hostObject))
                     {
-                        hostObjectMap[pairKey] = new HostObjects();
+                        hostObject = new HostObjects();
+                        hostObjectMap[pairKey] = hostObject;
                     }
 
-                    if (!hostObjectMap[pairKey]._hostObjects.ContainsKey(targetTaskKey))
+                    if (!hostObject._hostObjects.ContainsKey(targetTaskKey))
                     {
-                        hostObjectMap[pairKey]._hostObjects.Add(targetTaskKey, new MonikerNameOrITaskHost(hostObjectMapPairValueMonikerName));
+                        hostObject._hostObjects.Add(targetTaskKey, new MonikerNameOrITaskHost(hostObjectMapPairValueMonikerName));
                     }
                 }
                 _hostObjectMap = hostObjectMap;
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index bd160b2f66c..e29d3346621 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -326,6 +326,59 @@ public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globa
         {
         }
 
+        /// <summary>
+        /// Creates a ProjectInstance from an external created <see cref="Project"/>.
+        /// Properties and items are cloned immediately and only the instance data is stored.
+        /// </summary>
+        public ProjectInstance(Project project, ProjectInstanceSettings settings)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(project, nameof(project));
+
+            var projectPath = project.FullPath;
+            _directory = Path.GetDirectoryName(projectPath);
+            _projectFileLocation = ElementLocation.Create(projectPath);
+            _hostServices = project.ProjectCollection.HostServices;
+
+            EvaluationId = project.EvaluationCounter;
+
+            var immutable = (settings & ProjectInstanceSettings.Immutable) == ProjectInstanceSettings.Immutable;
+            this.CreatePropertiesSnapshot(project.Properties, immutable);
+            this.CreateItemDefinitionsSnapshot(project.ItemDefinitions);
+
+            var keepEvaluationCache = (settings & ProjectInstanceSettings.ImmutableWithFastItemLookup) == ProjectInstanceSettings.ImmutableWithFastItemLookup;
+            var projectItemToInstanceMap = this.CreateItemsSnapshot(project.Items, project.ItemTypes.Count, keepEvaluationCache);
+
+            this.CreateEvaluatedIncludeSnapshotIfRequested(keepEvaluationCache, project.Items, projectItemToInstanceMap);
+
+            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(project.GlobalProperties.Count);
+            foreach (var property in project.GlobalProperties)
+            {
+                _globalProperties.Set(ProjectPropertyInstance.Create(property.Key, property.Value));
+            }
+
+            this.CreateEnvironmentVariablePropertiesSnapshot(project.ProjectCollection.EnvironmentProperties);
+            this.CreateTargetsSnapshot(project.Targets, null, null, null, null);
+            this.CreateImportsSnapshot(project.Imports, project.ImportsIncludingDuplicates);
+
+            this.Toolset = project.ProjectCollection.GetToolset(project.ToolsVersion);
+            this.SubToolsetVersion = project.SubToolsetVersion;
+            this.TaskRegistry = new TaskRegistry(Toolset, project.ProjectCollection.ProjectRootElementCache);
+
+            this.ProjectRootElementCache = project.ProjectCollection.ProjectRootElementCache;
+
+            this.EvaluatedItemElements = new List<ProjectItemElement>(project.Items.Count);
+            foreach (var item in project.Items)
+            {
+                this.EvaluatedItemElements.Add(item.Xml);
+            }
+
+            _usingDifferentToolsVersionFromProjectFile = false;
+            _originalProjectToolsVersion = project.ToolsVersion;
+            _explicitToolsVersionSpecified = project.SubToolsetVersion != null;
+
+            _isImmutable = immutable;
+        }
+
         /// <summary>
         /// Creates a ProjectInstance directly.
         /// No intermediate Project object is created.
@@ -461,18 +514,18 @@ internal ProjectInstance(Evaluation.Project.Data data, string directory, string
             EvaluationId = data.EvaluationId;
 
             var immutable = (settings & ProjectInstanceSettings.Immutable) == ProjectInstanceSettings.Immutable;
-            this.CreatePropertiesSnapshot(data, immutable);
+            this.CreatePropertiesSnapshot(new ReadOnlyCollection<ProjectProperty>(data.Properties), immutable);
 
-            this.CreateItemDefinitionsSnapshot(data);
+            this.CreateItemDefinitionsSnapshot(data.ItemDefinitions);
 
             var keepEvaluationCache = (settings & ProjectInstanceSettings.ImmutableWithFastItemLookup) == ProjectInstanceSettings.ImmutableWithFastItemLookup;
-            var projectItemToInstanceMap = this.CreateItemsSnapshot(data, keepEvaluationCache);
+            var projectItemToInstanceMap = this.CreateItemsSnapshot(new ReadOnlyCollection<ProjectItem>(data.Items), data.ItemTypes.Count, keepEvaluationCache);
 
-            this.CreateEvaluatedIncludeSnapshotIfRequested(keepEvaluationCache, data, projectItemToInstanceMap);
-            this.CreateGlobalPropertiesSnapshot(data);
+            this.CreateEvaluatedIncludeSnapshotIfRequested(keepEvaluationCache, new ReadOnlyCollection<ProjectItem>(data.Items), projectItemToInstanceMap);
+            this.CreateGlobalPropertiesSnapshot(data.GlobalPropertiesDictionary);
             this.CreateEnvironmentVariablePropertiesSnapshot(environmentVariableProperties);
-            this.CreateTargetsSnapshot(data);
-            this.CreateImportsSnapshot(data);
+            this.CreateTargetsSnapshot(data.Targets, data.DefaultTargets, data.InitialTargets, data.BeforeTargets, data.AfterTargets);
+            this.CreateImportsSnapshot(data.ImportClosure, data.ImportClosureWithDuplicates);
 
             this.Toolset = data.Toolset; // UNDONE: This isn't immutable, should be cloned or made immutable; it currently has a pointer to project collection
             this.SubToolsetVersion = data.SubToolsetVersion;
@@ -548,13 +601,13 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                 this.DefaultTargets = new List<string>(that.DefaultTargets);
                 this.InitialTargets = new List<string>(that.InitialTargets);
                 ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
-                    ProjectItemDefinitionInstance>) this).BeforeTargets = CreateCloneDictionary(
+                    ProjectItemDefinitionInstance>)this).BeforeTargets = CreateCloneDictionary(
                     ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
-                        ProjectItemDefinitionInstance>) that).BeforeTargets, StringComparer.OrdinalIgnoreCase);
+                        ProjectItemDefinitionInstance>)that).BeforeTargets, StringComparer.OrdinalIgnoreCase);
                 ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
-                    ProjectItemDefinitionInstance>) this).AfterTargets = CreateCloneDictionary(
+                    ProjectItemDefinitionInstance>)this).AfterTargets = CreateCloneDictionary(
                     ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
-                        ProjectItemDefinitionInstance>) that).AfterTargets, StringComparer.OrdinalIgnoreCase);
+                        ProjectItemDefinitionInstance>)that).AfterTargets, StringComparer.OrdinalIgnoreCase);
                 this.TaskRegistry =
                     that.TaskRegistry; // UNDONE: This isn't immutable, should be cloned or made immutable; it currently has a pointer to project collection
 
@@ -999,7 +1052,7 @@ ISet<string> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, Projec
         }
 
         /// <summary>
-        /// Gets the global properties
+        /// Gets the properties
         /// </summary>
         PropertyDictionary<ProjectPropertyInstance> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.Properties
         {
@@ -1009,7 +1062,7 @@ PropertyDictionary<ProjectPropertyInstance> IEvaluatorData<ProjectPropertyInstan
         }
 
         /// <summary>
-        /// Gets the global properties
+        /// Gets the item definitions
         /// </summary>
         IEnumerable<ProjectItemDefinitionInstance> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.ItemDefinitionsEnumerable
         {
@@ -2023,7 +2076,7 @@ private void TranslateProperties(ITranslator translator)
             translator.TranslateDictionary(ref _globalProperties, ProjectPropertyInstance.FactoryForDeserialization);
             translator.TranslateDictionary(ref _properties, ProjectPropertyInstance.FactoryForDeserialization);
 
-            var globalPropertiesToTreatAsLocal = (HashSet<string>) _globalPropertiesToTreatAsLocal;
+            var globalPropertiesToTreatAsLocal = (HashSet<string>)_globalPropertiesToTreatAsLocal;
             translator.Translate(ref globalPropertiesToTreatAsLocal);
 
             if (translator.Mode == TranslationDirection.ReadFromStream)
@@ -2378,7 +2431,7 @@ internal ProjectTargetInstance AddTarget(
                 parentProjectSupportsReturnsAttribute
                 );
 
-            _actualTargets[target.Name] = target;
+            _actualTargets[targetName] = target;
 
             return target;
         }
@@ -2583,7 +2636,7 @@ private static IDictionary<string, TValue> CreateCloneDictionary<TValue>(IDictio
             }
             else
             {
-                return new RetrievableEntryHashSet<TValue>(dictionary, StringComparer.OrdinalIgnoreCase, readOnly: true);
+                return new ObjectModel.ReadOnlyDictionary<string, TValue>(dictionary);
             }
         }
 
@@ -2727,24 +2780,29 @@ private IEnumerable<ProjectItemInstance> GetItemsByEvaluatedInclude(string evalu
         /// <summary>
         /// Create various target snapshots
         /// </summary>
-        private void CreateTargetsSnapshot(Evaluation.Project.Data data)
+        private void CreateTargetsSnapshot(
+            IDictionary<string, ProjectTargetInstance> targets,
+            List<string> defaultTargets,
+            List<string> initialTargets,
+            IDictionary<string, List<TargetSpecification>> beforeTargets,
+            IDictionary<string, List<TargetSpecification>> afterTargets)
         {
-            this.DefaultTargets = new List<string>(data.DefaultTargets);
-            this.InitialTargets = new List<string>(data.InitialTargets);
-            ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).BeforeTargets = CreateCloneDictionary(data.BeforeTargets, StringComparer.OrdinalIgnoreCase);
-            ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).AfterTargets = CreateCloneDictionary(data.AfterTargets, StringComparer.OrdinalIgnoreCase);
-
             // ProjectTargetInstances are immutable so only the dictionary must be cloned
-            _targets = CreateCloneDictionary(data.Targets);
+            _targets = CreateCloneDictionary(targets);
+
+            this.DefaultTargets = defaultTargets == null ? new List<string>(0) : new List<string>(defaultTargets);
+            this.InitialTargets = defaultTargets == null ? new List<string>(0) : new List<string>(initialTargets);
+            ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).BeforeTargets = CreateCloneDictionary(beforeTargets, StringComparer.OrdinalIgnoreCase);
+            ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).AfterTargets = CreateCloneDictionary(afterTargets, StringComparer.OrdinalIgnoreCase);
         }
 
         /// <summary>
         /// Create various imports snapshots
         /// </summary>
-        private void CreateImportsSnapshot(Evaluation.Project.Data data)
+        private void CreateImportsSnapshot(IList<ResolvedImport> importClosure, IList<ResolvedImport> importClosureWithDuplicates)
         {
-            _importPaths = new List<string>(data.ImportClosure.Count - 1 /* outer project */);
-            foreach (var resolvedImport in data.ImportClosure)
+            _importPaths = new List<string>(importClosure.Count - 1 /* outer project */);
+            foreach (var resolvedImport in importClosure)
             {
                 // Exclude outer project itself
                 if (resolvedImport.ImportingElement != null)
@@ -2755,8 +2813,8 @@ private void CreateImportsSnapshot(Evaluation.Project.Data data)
 
             ImportPaths = _importPaths.AsReadOnly();
 
-            _importPathsIncludingDuplicates = new List<string>(data.ImportClosureWithDuplicates.Count - 1 /* outer project */);
-            foreach (var resolvedImport in data.ImportClosureWithDuplicates)
+            _importPathsIncludingDuplicates = new List<string>(importClosureWithDuplicates.Count - 1 /* outer project */);
+            foreach (var resolvedImport in importClosureWithDuplicates)
             {
                 // Exclude outer project itself
                 if (resolvedImport.ImportingElement != null)
@@ -2784,11 +2842,11 @@ private void CreateEnvironmentVariablePropertiesSnapshot(PropertyDictionary<Proj
         /// <summary>
         /// Create global properties snapshot
         /// </summary>
-        private void CreateGlobalPropertiesSnapshot(Evaluation.Project.Data data)
+        private void CreateGlobalPropertiesSnapshot(PropertyDictionary<ProjectPropertyInstance> globalPropertiesDictionary)
         {
-            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(data.GlobalPropertiesDictionary.Count);
+            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(globalPropertiesDictionary.Count);
 
-            foreach (ProjectPropertyInstance globalProperty in data.GlobalPropertiesDictionary)
+            foreach (ProjectPropertyInstance globalProperty in globalPropertiesDictionary)
             {
                 _globalProperties.Set(globalProperty.DeepClone());
             }
@@ -2797,7 +2855,7 @@ private void CreateGlobalPropertiesSnapshot(Evaluation.Project.Data data)
         /// <summary>
         /// Create evaluated include cache snapshot
         /// </summary>
-        private void CreateEvaluatedIncludeSnapshotIfRequested(bool keepEvaluationCache, Evaluation.Project.Data data, Dictionary<ProjectItem, ProjectItemInstance> projectItemToInstanceMap)
+        private void CreateEvaluatedIncludeSnapshotIfRequested(bool keepEvaluationCache, ICollection<ProjectItem> items, Dictionary<ProjectItem, ProjectItemInstance> projectItemToInstanceMap)
         {
             if (!keepEvaluationCache)
             {
@@ -2805,26 +2863,22 @@ private void CreateEvaluatedIncludeSnapshotIfRequested(bool keepEvaluationCache,
             }
 
             _itemsByEvaluatedInclude = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
-            foreach (var key in data.ItemsByEvaluatedIncludeCache.Keys)
+            foreach (var item in items)
             {
-                var projectItems = data.ItemsByEvaluatedIncludeCache[key];
-                foreach (var projectItem in projectItems)
-                {
-                    _itemsByEvaluatedInclude.Add(key, projectItemToInstanceMap[projectItem]);
-                }
+                _itemsByEvaluatedInclude.Add(item.EvaluatedInclude, projectItemToInstanceMap[item]);
             }
         }
 
         /// <summary>
         /// Create Items snapshot
         /// </summary>
-        private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(Evaluation.Project.Data data, bool keepEvaluationCache)
+        private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(ICollection<ProjectItem> items, int itemTypeCount, bool keepEvaluationCache)
         {
-            _items = new ItemDictionary<ProjectItemInstance>(data.ItemTypes.Count);
+            _items = new ItemDictionary<ProjectItemInstance>(itemTypeCount);
 
-            var projectItemToInstanceMap = keepEvaluationCache ? new Dictionary<ProjectItem, ProjectItemInstance>(data.Items.Count) : null;
+            var projectItemToInstanceMap = keepEvaluationCache ? new Dictionary<ProjectItem, ProjectItemInstance>(items.Count) : null;
 
-            foreach (ProjectItem item in data.Items)
+            foreach (ProjectItem item in items)
             {
                 List<ProjectItemDefinitionInstance> inheritedItemDefinitions = null;
 
@@ -2852,7 +2906,13 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(Evaluat
                     }
                 }
 
-                ProjectItemInstance instance = new ProjectItemInstance(this, item.ItemType, ((IItem)item).EvaluatedIncludeEscaped, item.EvaluatedIncludeBeforeWildcardExpansionEscaped, directMetadata, inheritedItemDefinitions, item.Xml.ContainingProject.EscapedFullPath);
+                // For externally constructed ProjectItem, fall back to the publicly available EvaluateInclude
+                var evaluatedIncludeEscaped = ((IItem)item).EvaluatedIncludeEscaped;
+                evaluatedIncludeEscaped ??= item.EvaluatedInclude;
+                var evaluatedIncludeBeforeWildcardExpansionEscaped = item.EvaluatedIncludeBeforeWildcardExpansionEscaped;
+                evaluatedIncludeBeforeWildcardExpansionEscaped ??= item.EvaluatedInclude;
+
+                ProjectItemInstance instance = new ProjectItemInstance(this, item.ItemType, evaluatedIncludeEscaped, evaluatedIncludeBeforeWildcardExpansionEscaped, directMetadata, inheritedItemDefinitions, item.Xml.ContainingProject.EscapedFullPath);
 
                 _items.Add(instance);
 
@@ -2865,11 +2925,11 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(Evaluat
         /// <summary>
         /// Create ItemDefinitions snapshot
         /// </summary>
-        private void CreateItemDefinitionsSnapshot(Evaluation.Project.Data data)
+        private void CreateItemDefinitionsSnapshot(IDictionary<string, ProjectItemDefinition> itemDefinitions)
         {
             _itemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(MSBuildNameIgnoreCaseComparer.Default);
 
-            foreach (ProjectItemDefinition definition in data.ItemDefinitions.Values)
+            foreach (ProjectItemDefinition definition in itemDefinitions.Values)
             {
                 _itemDefinitions.Add(new ProjectItemDefinitionInstance(definition));
             }
@@ -2878,11 +2938,11 @@ private void CreateItemDefinitionsSnapshot(Evaluation.Project.Data data)
         /// <summary>
         /// create property snapshot
         /// </summary>
-        private void CreatePropertiesSnapshot(Evaluation.Project.Data data, bool isImmutable)
+        private void CreatePropertiesSnapshot(ICollection<ProjectProperty> properties, bool isImmutable)
         {
-            _properties = new PropertyDictionary<ProjectPropertyInstance>(data.Properties.Count);
+            _properties = new PropertyDictionary<ProjectPropertyInstance>(properties.Count);
 
-            foreach (ProjectProperty property in data.Properties)
+            foreach (ProjectProperty property in properties)
             {
                 // Allow reserved property names, since this is how they are added to the project instance. 
                 // The caller has prevented users setting them themselves.
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 6200da27e43..f9dc6429ec1 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -28,7 +28,13 @@ namespace Microsoft.Build.Execution
     /// and evaluation has already been performed, so it is unnecessary bulk.
     /// </remarks>
     [DebuggerDisplay("{ItemType}={EvaluatedInclude} #DirectMetadata={DirectMetadataCount})")]
-    public class ProjectItemInstance : IItem<ProjectMetadataInstance>, ITaskItem2, IMetadataTable, ITranslatable, IDeepCloneable<ProjectItemInstance>
+    public class ProjectItemInstance :
+        IItem<ProjectMetadataInstance>,
+        ITaskItem2,
+        IMetadataTable,
+        ITranslatable,
+        IDeepCloneable<ProjectItemInstance>,
+        IMetadataContainer
     {
         /// <summary>
         /// The project instance to which this item belongs.
@@ -515,6 +521,8 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()
             return ((ITaskItem2)_taskItem).CloneCustomMetadataEscaped();
         }
 
+        IEnumerable<KeyValuePair<string, string>> IMetadataContainer.EnumerateMetadata() => _taskItem.EnumerateMetadata();
+
         #region IMetadataTable Members
 
         /// <summary>
@@ -723,7 +731,11 @@ internal sealed class TaskItem :
 #if FEATURE_APPDOMAIN
             MarshalByRefObject,
 #endif
-            ITaskItem2, IItem<ProjectMetadataInstance>, ITranslatable, IEquatable<TaskItem>
+            ITaskItem2,
+            IItem<ProjectMetadataInstance>,
+            ITranslatable,
+            IEquatable<TaskItem>,
+            IMetadataContainer
         {
             /// <summary>
             /// The source file that defined this item.
@@ -1045,6 +1057,36 @@ internal int DirectMetadataCount
                 get { return (_directMetadata == null) ? 0 : _directMetadata.Count; }
             }
 
+            /// <summary>
+            /// Efficient way to retrieve metadata used by packet serialization
+            /// and binary logger.
+            /// </summary>
+            public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()
+            {
+                // If we have item definitions, call the expensive property that does the right thing.
+                // Otherwise use _directMetadata to avoid allocations caused by DeepClone().
+                var list = _itemDefinitions != null ? MetadataCollection : _directMetadata;
+                if (list != null)
+                {
+                    return EnumerateMetadata(list);
+                }
+                else
+                {
+                    return Array.Empty<KeyValuePair<string, string>>();
+                }
+            }
+
+            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
+            {
+                foreach (var projectMetadataInstance in list)
+                {
+                    if (projectMetadataInstance != null)
+                    {
+                        yield return new KeyValuePair<string, string>(projectMetadataInstance.Name, projectMetadataInstance.EvaluatedValue);
+                    }
+                }
+            }
+
             /// <summary>
             /// Unordered collection of evaluated metadata on the item.
             /// If there is no metadata, returns an empty collection.
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 07f716a438f..c080e9338e3 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -197,10 +197,8 @@ public void SetPropertyValue(TaskPropertyInfo property, object value)
         /// </summary>
         public object GetPropertyValue(TaskPropertyInfo property)
         {
-            if (_setParameters.ContainsKey(property.Name))
+            if (_setParameters.TryGetValue(property.Name, out object value))
             {
-                object value = _setParameters[property.Name];
-
                 // If we returned an exception, then we want to throw it when we 
                 // do the get.  
                 if (value is Exception)
@@ -208,7 +206,7 @@ public object GetPropertyValue(TaskPropertyInfo property)
                     throw (Exception)value;
                 }
 
-                return _setParameters[property.Name];
+                return value;
             }
             else
             {
@@ -271,7 +269,10 @@ public bool Execute()
                         _taskType.Type.FullName,
                         AssemblyUtilities.GetAssemblyLocation(_taskType.Type.GetTypeInfo().Assembly),
                         _setParameters,
-                        new Dictionary<string, string>(_buildComponentHost.BuildParameters.GlobalProperties)
+                        new Dictionary<string, string>(_buildComponentHost.BuildParameters.GlobalProperties),
+                        _taskLoggingContext.GetWarningsAsErrors(),
+                        _taskLoggingContext.GetWarningsAsMessages()
+                        
                     );
 
             try
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index aad71143328..1768e7b3145 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -527,10 +527,9 @@ internal List<DictionaryEntry> ExtractPropertyList(IEnumerable properties)
         {
             // Gather a sorted list of all the properties.
             var list = new List<DictionaryEntry>(properties.FastCountOrZero());
-            foreach (DictionaryEntry prop in properties)
-            {
-                list.Add(prop);
-            }
+
+            Internal.Utilities.EnumerateProperties(properties, kvp => list.Add(new DictionaryEntry(kvp.Key, kvp.Value)));
+
             list.Sort(new DictionaryEntryKeyComparer());
             return list;
         }
@@ -620,18 +619,19 @@ internal SortedList ExtractItemList(IEnumerable items)
             // Use a SortedList instead of an ArrayList (because we need to lookup fast)
             // and instead of a Hashtable (because we need to sort it)
             SortedList itemTypes = new SortedList(CaseInsensitiveComparer.Default);
-            foreach (DictionaryEntry item in items)
+
+            Internal.Utilities.EnumerateItems(items, item =>
             {
-                // Create a new list for this itemtype, if we haven't already
-                if (itemTypes[(string)item.Key] == null)
+                string key = (string)item.Key;
+                var bucket = itemTypes[key] as ArrayList;
+                if (bucket == null)
                 {
-                    itemTypes[(string)item.Key] = new ArrayList();
+                    bucket = new ArrayList();
+                    itemTypes[key] = bucket;
                 }
 
-                // Add the item to the list for its itemtype
-                ArrayList itemsOfAType = (ArrayList)itemTypes[(string)item.Key];
-                itemsOfAType.Add(item.Value);
-            }
+                bucket.Add(item.Value);
+            });
 
             return itemTypes;
         }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index d8c90800210..dcb22fc4979 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -27,5 +27,6 @@ internal enum BinaryLogRecordKind
         PropertyInitialValueSet,
         NameValueList,
         String,
+        TaskParameter
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
index c6456c1a759..e4dc9c80b9c 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
@@ -2,6 +2,7 @@
 using System.IO;
 using System.IO.Compression;
 using System.Threading;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -14,6 +15,14 @@ namespace Microsoft.Build.Logging
     /// <remarks>The class is public so that we can call it from MSBuild.exe when replaying a log file.</remarks>
     public sealed class BinaryLogReplayEventSource : EventArgsDispatcher
     {
+        /// Touches the <see cref="ItemGroupLoggingHelper"/> static constructor
+        /// to ensure it initializes <see cref="TaskParameterEventArgs.MessageGetter"/>
+        /// and <see cref="TaskParameterEventArgs.DictionaryFactory"/>
+        static BinaryLogReplayEventSource()
+        {
+            _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
+        }
+
         /// <summary>
         /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
         /// </summary>
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index f9e9cb0b295..c9515e817f5 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -41,7 +41,11 @@ public sealed class BinaryLogger : ILogger
         //      * NameValueList - deduplicate arrays of name-value pairs such as properties, items and metadata
         //                        in a separate record and refer to those records from regular records
         //                        where a list used to be written in-place
-        internal const int FileFormatVersion = 10;
+        // version 11:
+        //   - new record kind: TaskParameterEventArgs
+        // version 12:
+        //   - add GlobalProperties, Properties and Items on ProjectEvaluationFinished
+        internal const int FileFormatVersion = 12;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
@@ -101,6 +105,7 @@ public void Initialize(IEventSource eventSource)
             Environment.SetEnvironmentVariable("MSBUILDTARGETOUTPUTLOGGING", "true");
             Environment.SetEnvironmentVariable("MSBUILDLOGIMPORTS", "1");
             Traits.Instance.EscapeHatches.LogProjectImports = true;
+            bool logPropertiesAndItemsAfterEvaluation = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation ?? true;
 
             ProcessParameters();
 
@@ -133,6 +138,11 @@ public void Initialize(IEventSource eventSource)
                 {
                     eventSource3.IncludeEvaluationMetaprojects();
                 }
+
+                if (logPropertiesAndItemsAfterEvaluation && eventSource is IEventSource4 eventSource4)
+                {
+                    eventSource4.IncludeEvaluationPropertiesAndItems();
+                }
             }
             catch (Exception e)
             {
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index bd9ae6e9481..d6675d9eb7b 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -1,11 +1,17 @@
-﻿using System;
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
 using System.Reflection;
 using System.Text;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
 {
@@ -29,6 +35,8 @@ public class BuildEventArgsReader : IDisposable
         /// <summary>
         /// A list of dictionaries we've encountered so far. Dictionaries are referred to by their order in this list.
         /// </summary>
+        /// <remarks>This is designed to not hold on to strings. We just store the string indices and
+        /// hydrate the dictionary on demand before returning.</remarks>
         private readonly List<(int keyIndex, int valueIndex)[]> nameValueListRecords = new List<(int, int)[]>();
 
         /// <summary>
@@ -146,6 +154,9 @@ public BuildEventArgs Read()
                 case BinaryLogRecordKind.TaskCommandLine:
                     result = ReadTaskCommandLineEventArgs();
                     break;
+                case BinaryLogRecordKind.TaskParameter:
+                    result = ReadTaskParameterEventArgs();
+                    break;
                 case BinaryLogRecordKind.ProjectEvaluationStarted:
                     result = ReadProjectEvaluationStartedEventArgs();
                     break;
@@ -215,14 +226,17 @@ private IDictionary<string, string> GetNameValueList(int id)
             {
                 var list = nameValueListRecords[id];
 
-                var dictionary = new Dictionary<string, string>(list.Length);
+                // We can't cache these as they would hold on to strings.
+                // This reader is designed to not hold onto strings,
+                // so that we can fit in a 32-bit process when reading huge binlogs
+                var dictionary = ArrayDictionary<string, string>.Create(list.Length);
                 for (int i = 0; i < list.Length; i++)
                 {
                     string key = GetStringFromRecord(list[i].keyIndex);
                     string value = GetStringFromRecord(list[i].valueIndex);
                     if (key != null)
                     {
-                        dictionary[key] = value;
+                        dictionary.Add(key, value);
                     }
                 }
 
@@ -329,7 +343,9 @@ private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
             var fields = ReadBuildEventArgsFields();
             var projectFile = ReadDeduplicatedString();
 
-            var e = new ProjectEvaluationStartedEventArgs(fields.Message)
+            var e = new ProjectEvaluationStartedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationStarted"),
+                projectFile)
             {
                 ProjectFile = projectFile
             };
@@ -342,12 +358,30 @@ private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
             var fields = ReadBuildEventArgsFields();
             var projectFile = ReadDeduplicatedString();
 
-            var e = new ProjectEvaluationFinishedEventArgs(fields.Message)
+            var e = new ProjectEvaluationFinishedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationFinished"),
+                projectFile)
             {
                 ProjectFile = projectFile
             };
             SetCommonFields(e, fields);
 
+            if (fileFormatVersion >= 12)
+            {
+                IEnumerable globalProperties = null;
+                if (ReadBoolean())
+                {
+                    globalProperties = ReadStringDictionary();
+                }
+
+                var propertyList = ReadPropertyList();
+                var itemList = ReadProjectItems();
+
+                e.GlobalProperties = globalProperties;
+                e.Properties = propertyList;
+                e.Items = itemList;
+            }
+
             // ProfilerResult was introduced in version 5
             if (fileFormatVersion > 4)
             {
@@ -437,7 +471,7 @@ private BuildEventArgs ReadTargetStartedEventArgs()
             var targetFile = ReadOptionalString();
             var parentTarget = ReadOptionalString();
             // BuildReason was introduced in version 4
-            var buildReason = fileFormatVersion > 3 ? (TargetBuiltReason) ReadInt32() : TargetBuiltReason.None;
+            var buildReason = fileFormatVersion > 3 ? (TargetBuiltReason)ReadInt32() : TargetBuiltReason.None;
 
             var e = new TargetStartedEventArgs(
                 fields.Message,
@@ -596,6 +630,27 @@ private BuildEventArgs ReadTaskCommandLineEventArgs()
             return e;
         }
 
+        private BuildEventArgs ReadTaskParameterEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+            // Read unused Importance, it defaults to Low
+            ReadInt32();
+
+            var kind = (TaskParameterMessageKind)ReadInt32();
+            var itemType = ReadDeduplicatedString();
+            var items = ReadTaskItemList() as IList;
+
+            var e = ItemGroupLoggingHelper.CreateTaskParameterEventArgs(
+                fields.BuildEventContext,
+                kind,
+                itemType,
+                items,
+                logItemMetadata: true,
+                fields.Timestamp);
+            e.ProjectFile = fields.ProjectFile;
+            return e;
+        }
+
         private BuildEventArgs ReadCriticalBuildMessageEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
@@ -810,23 +865,25 @@ private void SetCommonFields(BuildEventArgs buildEventArgs, BuildEventArgsFields
 
             if ((fields.Flags & BuildEventArgsFieldFlags.Timestamp) != 0)
             {
-                buildEventArgsFieldTimestamp.SetValue(buildEventArgs, fields.Timestamp);
+                buildEventArgs.RawTimestamp = fields.Timestamp;
             }
         }
 
-        private ArrayList ReadPropertyList()
+        private IEnumerable ReadPropertyList()
         {
             var properties = ReadStringDictionary();
-            if (properties == null)
+            if (properties == null || properties.Count == 0)
             {
                 return null;
             }
 
-            var list = new ArrayList();
+            int count = properties.Count;
+            var list = new DictionaryEntry[count];
+            int i = 0;
             foreach (var property in properties)
             {
-                var entry = new DictionaryEntry(property.Key, property.Value);
-                list.Add(entry);
+                list[i] = new DictionaryEntry(property.Key, property.Value);
+                i++;
             }
 
             return list;
@@ -896,77 +953,18 @@ private IDictionary<string, string> ReadLegacyStringDictionary()
             return result;
         }
 
-        private class TaskItem : ITaskItem
-        {
-            private static readonly Dictionary<string, string> emptyMetadata = new Dictionary<string, string>();
-
-            public string ItemSpec { get; set; }
-            public IDictionary<string, string> Metadata { get; }
-
-            public TaskItem()
-            {
-                Metadata = new Dictionary<string, string>();
-            }
-
-            public TaskItem(string itemSpec, IDictionary<string, string> metadata)
-            {
-                ItemSpec = itemSpec;
-                Metadata = metadata ?? emptyMetadata;
-            }
-
-            public int MetadataCount => Metadata.Count;
-
-            public ICollection MetadataNames => (ICollection)Metadata.Keys;
-
-            public IDictionary CloneCustomMetadata()
-            {
-                return (IDictionary)Metadata;
-            }
-
-            public void CopyMetadataTo(ITaskItem destinationItem)
-            {
-                throw new NotImplementedException();
-            }
-
-            public string GetMetadata(string metadataName)
-            {
-                return Metadata[metadataName];
-            }
-
-            public void RemoveMetadata(string metadataName)
-            {
-                throw new NotImplementedException();
-            }
-
-            public void SetMetadata(string metadataName, string metadataValue)
-            {
-                throw new NotImplementedException();
-            }
-
-            public override string ToString()
-            {
-                return $"{ItemSpec} Metadata: {MetadataCount}";
-            }
-        }
-
         private ITaskItem ReadTaskItem()
         {
             string itemSpec = ReadDeduplicatedString();
             var metadata = ReadStringDictionary();
 
-            var taskItem = new TaskItem(itemSpec, metadata);
+            var taskItem = new TaskItemData(itemSpec, metadata);
             return taskItem;
         }
 
         private IEnumerable ReadProjectItems()
         {
-            int count = ReadInt32();
-            if (count == 0)
-            {
-                return null;
-            }
-
-            List<DictionaryEntry> list;
+            IList<DictionaryEntry> list;
 
             // starting with format version 10 project items are grouped by name
             // so we only have to write the name once, and then the count of items
@@ -974,27 +972,69 @@ private IEnumerable ReadProjectItems()
             // old style flat list where the name is duplicated for each item.
             if (fileFormatVersion < 10)
             {
-                list = new List<DictionaryEntry>(count);
+                int count = ReadInt32();
+                if (count == 0)
+                {
+                    return null;
+                }
+
+                list = new DictionaryEntry[count];
                 for (int i = 0; i < count; i++)
                 {
                     string itemName = ReadString();
                     ITaskItem item = ReadTaskItem();
-                    list.Add(new DictionaryEntry(itemName, item));
+                    list[i] = new DictionaryEntry(itemName, item);
                 }
             }
-            else
+            else if (fileFormatVersion < 12)
             {
+                int count = ReadInt32();
+                if (count == 0)
+                {
+                    return null;
+                }
+
                 list = new List<DictionaryEntry>();
                 for (int i = 0; i < count; i++)
                 {
-                    string itemName = ReadDeduplicatedString();
+                    string itemType = ReadDeduplicatedString();
                     var items = ReadTaskItemList();
-                    foreach (var item in items)
+                    if (items != null)
                     {
-                        list.Add(new DictionaryEntry(itemName, item));
+                        foreach (var item in items)
+                        {
+                            list.Add(new DictionaryEntry(itemType, item));
+                        }
                     }
                 }
             }
+            else
+            {
+                list = new List<DictionaryEntry>();
+
+                while (true)
+                {
+                    string itemType = ReadDeduplicatedString();
+                    if (string.IsNullOrEmpty(itemType))
+                    {
+                        break;
+                    }
+
+                    var items = ReadTaskItemList();
+                    if (items != null)
+                    {
+                        foreach (var item in items)
+                        {
+                            list.Add(new DictionaryEntry(itemType, item));
+                        }
+                    }
+                }
+
+                if (list.Count == 0)
+                {
+                    list = null;
+                }
+            }
 
             return list;
         }
@@ -1007,12 +1047,12 @@ private IEnumerable ReadTaskItemList()
                 return null;
             }
 
-            var list = new List<ITaskItem>(count);
+            var list = new ITaskItem[count];
 
             for (int i = 0; i < count; i++)
             {
                 ITaskItem item = ReadTaskItem();
-                list.Add(item);
+                list[i] = item;
             }
 
             return list;
@@ -1079,7 +1119,10 @@ private string GetStringFromRecord(int index)
 
         private int ReadInt32()
         {
-            return Read7BitEncodedInt(binaryReader);
+            // on some platforms (net5) this method was added to BinaryReader
+            // but it's not available on others. Call our own extension method
+            // explicitly to avoid ambiguity.
+            return BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
         }
 
         private long ReadInt64()
@@ -1102,30 +1145,6 @@ private TimeSpan ReadTimeSpan()
             return new TimeSpan(binaryReader.ReadInt64());
         }
 
-        private int Read7BitEncodedInt(BinaryReader reader)
-        {
-            // Read out an Int32 7 bits at a time.  The high bit
-            // of the byte when on means to continue reading more bytes.
-            int count = 0;
-            int shift = 0;
-            byte b;
-            do
-            {
-                // Check for a corrupted stream.  Read a max of 5 bytes.
-                // In a future version, add a DataFormatException.
-                if (shift == 5 * 7)  // 5 bytes max per Int32, shift += 7
-                {
-                    throw new FormatException();
-                }
-
-                // ReadByte handles end of stream cases for us.
-                b = reader.ReadByte();
-                count |= (b & 0x7F) << shift;
-                shift += 7;
-            } while ((b & 0x80) != 0);
-            return count;
-        }
-
         private ProfiledLocation ReadProfiledLocation()
         {
             var numberOfHits = ReadInt32();
@@ -1148,7 +1167,7 @@ private EvaluationLocation ReadEvaluationLocation()
             var hasLine = ReadBoolean();
             if (hasLine)
             {
-                line = ReadInt32(); 
+                line = ReadInt32();
             }
 
             // Id and parent Id were introduced in version 6
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 3b37d1404cf..5774a80a27f 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -1,13 +1,21 @@
-﻿using System;
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
 using System.Linq;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
 {
@@ -128,71 +136,33 @@ public void Write(BuildEventArgs e)
 
         private void WriteCore(BuildEventArgs e)
         {
-            // the cases are ordered by most used first for performance
-            if (e is BuildMessageEventArgs)
-            {
-                Write((BuildMessageEventArgs)e);
-            }
-            else if (e is TaskStartedEventArgs)
-            {
-                Write((TaskStartedEventArgs)e);
-            }
-            else if (e is TaskFinishedEventArgs)
-            {
-                Write((TaskFinishedEventArgs)e);
-            }
-            else if (e is TargetStartedEventArgs)
-            {
-                Write((TargetStartedEventArgs)e);
-            }
-            else if (e is TargetFinishedEventArgs)
-            {
-                Write((TargetFinishedEventArgs)e);
-            }
-            else if (e is BuildErrorEventArgs)
-            {
-                Write((BuildErrorEventArgs)e);
-            }
-            else if (e is BuildWarningEventArgs)
-            {
-                Write((BuildWarningEventArgs)e);
-            }
-            else if (e is ProjectStartedEventArgs)
-            {
-                Write((ProjectStartedEventArgs)e);
-            }
-            else if (e is ProjectFinishedEventArgs)
-            {
-                Write((ProjectFinishedEventArgs)e);
-            }
-            else if (e is BuildStartedEventArgs)
-            {
-                Write((BuildStartedEventArgs)e);
-            }
-            else if (e is BuildFinishedEventArgs)
-            {
-                Write((BuildFinishedEventArgs)e);
-            }
-            else if (e is ProjectEvaluationStartedEventArgs)
-            {
-                Write((ProjectEvaluationStartedEventArgs)e);
-            }
-            else if (e is ProjectEvaluationFinishedEventArgs)
-            {
-                Write((ProjectEvaluationFinishedEventArgs)e);
-            }
-            else
-            {
-                // convert all unrecognized objects to message
-                // and just preserve the message
-                var buildMessageEventArgs = new BuildMessageEventArgs(
-                    e.Message,
-                    e.HelpKeyword,
-                    e.SenderName,
-                    MessageImportance.Normal,
-                    e.Timestamp);
-                buildMessageEventArgs.BuildEventContext = e.BuildEventContext ?? BuildEventContext.Invalid;
-                Write(buildMessageEventArgs);
+            switch (e)
+            {
+                case BuildMessageEventArgs buildMessage: Write(buildMessage); break;
+                case TaskStartedEventArgs taskStarted: Write(taskStarted); break;
+                case TaskFinishedEventArgs taskFinished: Write(taskFinished); break;
+                case TargetStartedEventArgs targetStarted: Write(targetStarted); break;
+                case TargetFinishedEventArgs targetFinished: Write(targetFinished); break;
+                case BuildErrorEventArgs buildError: Write(buildError); break;
+                case BuildWarningEventArgs buildWarning: Write(buildWarning); break;
+                case ProjectStartedEventArgs projectStarted: Write(projectStarted); break;
+                case ProjectFinishedEventArgs projectFinished: Write(projectFinished); break;
+                case BuildStartedEventArgs buildStarted: Write(buildStarted); break;
+                case BuildFinishedEventArgs buildFinished: Write(buildFinished); break;
+                case ProjectEvaluationStartedEventArgs projectEvaluationStarted: Write(projectEvaluationStarted); break;
+                case ProjectEvaluationFinishedEventArgs projectEvaluationFinished: Write(projectEvaluationFinished); break;
+                default:
+                    // convert all unrecognized objects to message
+                    // and just preserve the message
+                    var buildMessageEventArgs = new BuildMessageEventArgs(
+                        e.Message,
+                        e.HelpKeyword,
+                        e.SenderName,
+                        MessageImportance.Normal,
+                        e.Timestamp);
+                    buildMessageEventArgs.BuildEventContext = e.BuildEventContext ?? BuildEventContext.Invalid;
+                    Write(buildMessageEventArgs);
+                    break;
             }
         }
 
@@ -250,7 +220,7 @@ private void Write(BuildFinishedEventArgs e)
         private void Write(ProjectEvaluationStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.ProjectEvaluationStarted);
-            WriteBuildEventArgsFields(e);
+            WriteBuildEventArgsFields(e, writeMessage: false);
             WriteDeduplicatedString(e.ProjectFile);
         }
 
@@ -258,15 +228,30 @@ private void Write(ProjectEvaluationFinishedEventArgs e)
         {
             Write(BinaryLogRecordKind.ProjectEvaluationFinished);
 
-            WriteBuildEventArgsFields(e);
+            WriteBuildEventArgsFields(e, writeMessage: false);
             WriteDeduplicatedString(e.ProjectFile);
 
-            Write(e.ProfilerResult.HasValue);
-            if (e.ProfilerResult.HasValue)
+            if (e.GlobalProperties == null)
             {
-                Write(e.ProfilerResult.Value.ProfiledLocations.Count);
+                Write(false);
+            }
+            else
+            {
+                Write(true);
+                WriteProperties(e.GlobalProperties);
+            }
 
-                foreach (var item in e.ProfilerResult.Value.ProfiledLocations)
+            WriteProperties(e.Properties);
+
+            WriteProjectItems(e.Items);
+
+            var result = e.ProfilerResult;
+            Write(result.HasValue);
+            if (result.HasValue)
+            {
+                Write(result.Value.ProfiledLocations.Count);
+
+                foreach (var item in result.Value.ProfiledLocations)
                 {
                     Write(item.Key);
                     Write(item.Value);
@@ -389,51 +374,57 @@ private void Write(BuildWarningEventArgs e)
 
         private void Write(BuildMessageEventArgs e)
         {
-            if (e is CriticalBuildMessageEventArgs)
+            if (e is TaskParameterEventArgs taskParameter)
+            {
+                Write(taskParameter);
+                return;
+            }
+
+            if (e is CriticalBuildMessageEventArgs criticalBuildMessage)
             {
-                Write((CriticalBuildMessageEventArgs)e);
+                Write(criticalBuildMessage);
                 return;
             }
 
-            if (e is TaskCommandLineEventArgs)
+            if (e is TaskCommandLineEventArgs taskCommandLine)
             {
-                Write((TaskCommandLineEventArgs)e);
+                Write(taskCommandLine);
                 return;
             }
 
-            if (e is ProjectImportedEventArgs)
+            if (e is ProjectImportedEventArgs projectImported)
             {
-                Write((ProjectImportedEventArgs)e);
+                Write(projectImported);
                 return;
             }
 
-            if (e is TargetSkippedEventArgs)
+            if (e is TargetSkippedEventArgs targetSkipped)
             {
-                Write((TargetSkippedEventArgs)e);
+                Write(targetSkipped);
                 return;
             }
 
-            if (e is PropertyReassignmentEventArgs)
+            if (e is PropertyReassignmentEventArgs propertyReassignment)
             {
-                Write((PropertyReassignmentEventArgs)e);
+                Write(propertyReassignment);
                 return;
             }
 
-            if (e is UninitializedPropertyReadEventArgs)
+            if (e is UninitializedPropertyReadEventArgs uninitializedPropertyRead)
             {
-                Write((UninitializedPropertyReadEventArgs)e);
+                Write(uninitializedPropertyRead);
                 return;
             }
 
-            if (e is EnvironmentVariableReadEventArgs)
+            if (e is EnvironmentVariableReadEventArgs environmentVariableRead)
             {
-                Write((EnvironmentVariableReadEventArgs)e);
+                Write(environmentVariableRead);
                 return;
             }
 
-            if (e is PropertyInitialValueSetEventArgs)
+            if (e is PropertyInitialValueSetEventArgs propertyInitialValueSet)
             {
-                Write((PropertyInitialValueSetEventArgs)e);
+                Write(propertyInitialValueSet);
                 return;
             }
 
@@ -507,9 +498,18 @@ private void Write(TaskCommandLineEventArgs e)
             WriteDeduplicatedString(e.TaskName);
         }
 
-        private void WriteBuildEventArgsFields(BuildEventArgs e)
+        private void Write(TaskParameterEventArgs e)
+        {
+            Write(BinaryLogRecordKind.TaskParameter);
+            WriteMessageFields(e, writeMessage: false);
+            Write((int)e.Kind);
+            WriteDeduplicatedString(e.ItemType);
+            WriteTaskItemList(e.Items, e.LogItemMetadata);
+        }
+
+        private void WriteBuildEventArgsFields(BuildEventArgs e, bool writeMessage = true)
         {
-            var flags = GetBuildEventArgsFieldFlags(e);
+            var flags = GetBuildEventArgsFieldFlags(e, writeMessage);
             Write((int)flags);
             WriteBaseFields(e, flags);
         }
@@ -547,9 +547,9 @@ private void WriteBaseFields(BuildEventArgs e, BuildEventArgsFieldFlags flags)
             }
         }
 
-        private void WriteMessageFields(BuildMessageEventArgs e)
+        private void WriteMessageFields(BuildMessageEventArgs e, bool writeMessage = true)
         {
-            var flags = GetBuildEventArgsFieldFlags(e);
+            var flags = GetBuildEventArgsFieldFlags(e, writeMessage);
             flags = GetMessageFlags(e, flags);
 
             Write((int)flags);
@@ -644,7 +644,7 @@ private static BuildEventArgsFieldFlags GetMessageFlags(BuildMessageEventArgs e,
             return flags;
         }
 
-        private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventArgs e)
+        private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventArgs e, bool writeMessage = true)
         {
             var flags = BuildEventArgsFieldFlags.None;
             if (e.BuildEventContext != null)
@@ -657,7 +657,7 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr
                 flags |= BuildEventArgsFieldFlags.HelpHeyword;
             }
 
-            if (!string.IsNullOrEmpty(e.Message))
+            if (writeMessage)
             {
                 flags |= BuildEventArgsFieldFlags.Message;
             }
@@ -681,21 +681,70 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr
             return flags;
         }
 
-        private void WriteTaskItemList(IEnumerable items)
+        // Both of these are used simultaneously so can't just have a single list
+        private readonly List<object> reusableItemsList = new List<object>();
+        private readonly List<object> reusableProjectItemList = new List<object>();
+
+        private void WriteTaskItemList(IEnumerable items, bool writeMetadata = true)
         {
-            var taskItems = items as IEnumerable<ITaskItem>;
-            if (taskItems == null)
+            if (items == null)
             {
                 Write(false);
                 return;
             }
 
-            Write(taskItems.Count());
+            // For target outputs bypass copying of all items to save on performance.
+            // The proxy creates a deep clone of each item to protect against writes,
+            // but since we're not writing we don't need the deep cloning.
+            // Additionally, it is safe to access the underlying List<ITaskItem> as it's allocated
+            // in a single location and noboby else mutates it after that:
+            // https://github.com/dotnet/msbuild/blob/f0eebf2872d76ab0cd43fdc4153ba636232b222f/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs#L564
+            if (items is TargetLoggingContext.TargetOutputItemsInstanceEnumeratorProxy proxy)
+            {
+                items = proxy.BackingItems;
+            }
+
+            int count;
+
+            if (items is ICollection arrayList)
+            {
+                count = arrayList.Count;
+            }
+            else if (items is ICollection<ITaskItem> genericList)
+            {
+                count = genericList.Count;
+            }
+            else
+            {
+                // enumerate only once
+                foreach (var item in items)
+                {
+                    if (item != null)
+                    {
+                        reusableItemsList.Add(item);
+                    }
+                }
+
+                items = reusableItemsList;
+                count = reusableItemsList.Count;
+            }
+
+            Write(count);
 
-            foreach (var item in taskItems)
+            foreach (var item in items)
             {
-                Write(item);
+                if (item is ITaskItem taskItem)
+                {
+                    Write(taskItem, writeMetadata);
+                }
+                else
+                {
+                    WriteDeduplicatedString(item?.ToString() ?? ""); // itemspec
+                    Write(0); // no metadata
+                }
             }
+
+            reusableItemsList.Clear();
         }
 
         private void WriteProjectItems(IEnumerable items)
@@ -706,55 +755,100 @@ private void WriteProjectItems(IEnumerable items)
                 return;
             }
 
-            var groups = items
-                .OfType<DictionaryEntry>()
-                .GroupBy(entry => entry.Key as string, entry => entry.Value as ITaskItem)
-                .Where(group => !string.IsNullOrEmpty(group.Key))
-                .ToArray();
+            if (items is ItemDictionary<ProjectItemInstance> itemInstanceDictionary)
+            {
+                // If we have access to the live data from evaluation, it exposes a special method
+                // to iterate the data structure under a lock and return results grouped by item type.
+                // There's no need to allocate or call GroupBy this way.
+                itemInstanceDictionary.EnumerateItemsPerType((itemType, itemList) =>
+                {
+                    WriteDeduplicatedString(itemType);
+                    WriteTaskItemList(itemList);
+                });
 
-            Write(groups.Length);
+                // signal the end
+                Write(0);
+            }
+            // not sure when this can get hit, but best to be safe and support this
+            else if (items is ItemDictionary<ProjectItem> itemDictionary)
+            {
+                itemDictionary.EnumerateItemsPerType((itemType, itemList) =>
+                {
+                    WriteDeduplicatedString(itemType);
+                    WriteTaskItemList(itemList);
+                });
 
-            foreach (var group in groups)
+                // signal the end
+                Write(0);
+            }
+            else
             {
-                WriteDeduplicatedString(group.Key);
-                WriteTaskItemList(group);
+                string currentItemType = null;
+
+                // Write out a sequence of items for each item type while avoiding GroupBy
+                // and associated allocations. We rely on the fact that items of each type
+                // are contiguous. For each item type, write the item type name and the list
+                // of items. Write 0 at the end (which would correspond to item type null).
+                // This is how the reader will know how to stop. We can't write out the
+                // count of item types at the beginning because we don't know how many there
+                // will be (we'd have to enumerate twice to calculate that). This scheme
+                // allows us to stream in a single pass with no allocations for intermediate
+                // results.
+                Internal.Utilities.EnumerateItems(items, dictionaryEntry =>
+                {
+                    string key = (string)dictionaryEntry.Key;
+
+                    // boundary between item types
+                    if (currentItemType != null && currentItemType != key)
+                    {
+                        WriteDeduplicatedString(currentItemType);
+                        WriteTaskItemList(reusableProjectItemList);
+                        reusableProjectItemList.Clear();
+                    }
+
+                    reusableProjectItemList.Add(dictionaryEntry.Value);
+                    currentItemType = key;
+                });
+
+                // write out the last item type
+                if (reusableProjectItemList.Count > 0)
+                {
+                    WriteDeduplicatedString(currentItemType);
+                    WriteTaskItemList(reusableProjectItemList);
+                    reusableProjectItemList.Clear();
+                }
+
+                // signal the end
+                Write(0);
             }
         }
 
-        private void Write(ITaskItem item)
+        private void Write(ITaskItem item, bool writeMetadata = true)
         {
             WriteDeduplicatedString(item.ItemSpec);
-
-            nameValueListBuffer.Clear();
-
-            IDictionary customMetadata = item.CloneCustomMetadata();
-
-            foreach (string metadataName in customMetadata.Keys)
+            if (!writeMetadata)
             {
-                string valueOrError;
+                Write((byte)0);
+                return;
+            }
 
-                try
-                {
-                    valueOrError = item.GetMetadata(metadataName);
-                }
-                catch (InvalidProjectFileException e)
-                {
-                    valueOrError = e.Message;
-                }
-                // Temporarily try catch all to mitigate frequent NullReferenceExceptions in
-                // the logging code until CopyOnWritePropertyDictionary is replaced with
-                // ImmutableDictionary. Calling into Debug.Fail to crash the process in case
-                // the exception occures in Debug builds.
-                catch (Exception e)
-                {
-                    valueOrError = e.Message;
-                    Debug.Fail(e.ToString());
-                }
+            // WARNING: Can't use AddRange here because CopyOnWriteDictionary in Microsoft.Build.Utilities.v4.0.dll
+            // is broken. Microsoft.Build.Utilities.v4.0.dll loads from the GAC by XAML markup tooling and it's
+            // implementation doesn't work with AddRange because AddRange special-cases ICollection<T> and
+            // CopyOnWriteDictionary doesn't implement it properly.
+            foreach (var kvp in item.EnumerateMetadata())
+            {
+                nameValueListBuffer.Add(kvp);
+            }
 
-                nameValueListBuffer.Add(new KeyValuePair<string, string>(metadataName, valueOrError));
+            if (nameValueListBuffer.Count > 1)
+            {
+                nameValueListBuffer.Sort((l, r) => StringComparer.OrdinalIgnoreCase.Compare(l.Key, r.Key));
             }
 
             WriteNameValueList();
+
+            nameValueListBuffer.Clear();
         }
 
         private void WriteProperties(IEnumerable properties)
@@ -765,26 +859,11 @@ private void WriteProperties(IEnumerable properties)
                 return;
             }
 
-            nameValueListBuffer.Clear();
-
-            // there are no guarantees that the properties iterator won't change, so 
-            // take a snapshot and work with the readonly copy
-            var propertiesArray = properties.OfType<DictionaryEntry>().ToArray();
-
-            for (int i = 0; i < propertiesArray.Length; i++)
-            {
-                DictionaryEntry entry = propertiesArray[i];
-                if (entry.Key is string key && entry.Value is string value)
-                {
-                    nameValueListBuffer.Add(new KeyValuePair<string, string>(key, value));
-                }
-                else
-                {
-                    nameValueListBuffer.Add(new KeyValuePair<string, string>(string.Empty, string.Empty));
-                }
-            }
+            Internal.Utilities.EnumerateProperties(properties, kvp => nameValueListBuffer.Add(kvp));
 
             WriteNameValueList();
+
+            nameValueListBuffer.Clear();
         }
 
         private void Write(BuildEventContext buildEventContext)
@@ -800,8 +879,6 @@ private void Write(BuildEventContext buildEventContext)
 
         private void Write(IEnumerable<KeyValuePair<string, string>> keyValuePairs)
         {
-            nameValueListBuffer.Clear();
-
             if (keyValuePairs != null)
             {
                 foreach (var kvp in keyValuePairs)
@@ -811,6 +888,8 @@ private void Write(IEnumerable<KeyValuePair<string, string>> keyValuePairs)
             }
 
             WriteNameValueList();
+
+            nameValueListBuffer.Clear();
         }
 
         private void WriteNameValueList()
@@ -893,7 +972,7 @@ private void Write(BinaryLogRecordKind kind)
 
         private void Write(int value)
         {
-            Write7BitEncodedInt(binaryWriter, value);
+            BinaryWriterExtensions.Write7BitEncodedInt(binaryWriter, value);
         }
 
         private void Write(long value)
@@ -901,19 +980,6 @@ private void Write(long value)
             binaryWriter.Write(value);
         }
 
-        private void Write7BitEncodedInt(BinaryWriter writer, int value)
-        {
-            // Write out an int 7 bits at a time.  The high bit of the byte,
-            // when on, tells reader to continue reading more bytes.
-            uint v = (uint)value;   // support negative numbers
-            while (v >= 0x80)
-            {
-                writer.Write((byte)(v | 0x80));
-                v >>= 7;
-            }
-            writer.Write((byte)v);
-        }
-
         private void Write(byte[] bytes)
         {
             binaryWriter.Write(bytes);
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 2a74ec78a0d..edcbe439efe 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -6,13 +6,14 @@
 using System.Collections;
 using System.Globalization;
 using System.Collections.Generic;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 using ColorSetter = Microsoft.Build.Logging.ColorSetter;
 using ColorResetter = Microsoft.Build.Logging.ColorResetter;
 using WriteHandler = Microsoft.Build.Logging.WriteHandler;
-using Microsoft.Build.Exceptions;
 
 namespace Microsoft.Build.BackEnd.Logging
 {
@@ -429,14 +430,14 @@ private void ShowErrorWarningSummary(IEnumerable<BuildEventArgs> listToProcess)
                 // Check to see if there is a bucket for the warning
                 // If there is no bucket create a new one which contains a list of all the errors which
                 // happened for a given buildEventContext / target
-                if (!groupByProjectEntryPoint.ContainsKey(key))
+                if (!groupByProjectEntryPoint.TryGetValue(key, out var errorWarningEventListByTarget))
                 {
                     // happened for a given buildEventContext / target
-                    var errorWarningEventListByTarget = new List<BuildEventArgs>();
+                    errorWarningEventListByTarget = new List<BuildEventArgs>();
                     groupByProjectEntryPoint.Add(key, errorWarningEventListByTarget);
                 }
                 // Add the error event to the correct bucket
-                groupByProjectEntryPoint[key].Add(errorWarningEventArgs);
+                errorWarningEventListByTarget.Add(errorWarningEventArgs);
             }
 
             BuildEventContext previousEntryPoint = null;
@@ -505,11 +506,11 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
             }
 
             // If there were deferred messages then we should show them now, this will cause the project started event to be shown properly
-            if (_deferredMessages.ContainsKey(e.BuildEventContext))
+            if (_deferredMessages.TryGetValue(e.BuildEventContext, out var deferredMessages))
             {
                 if (!showOnlyErrors && !showOnlyWarnings)
                 {
-                    foreach (BuildMessageEventArgs message in _deferredMessages[e.BuildEventContext])
+                    foreach (BuildMessageEventArgs message in deferredMessages)
                     {
                         // This will display the project started event before the messages is shown
                         this.MessageHandler(sender, message);
@@ -527,6 +528,7 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                 {
                     DisplayDeferredProjectStartedEvent(e.BuildEventContext);
                 }
+
                 if (e.Properties != null)
                 {
                     WriteProperties(e, e.Properties);
@@ -538,30 +540,50 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                 }
             }
 
-            if (e.BuildEventContext == null || e.Items == null)
+            ReadProjectConfigurationDescription(e.BuildEventContext, e.Items);
+        }
+
+        private void ReadProjectConfigurationDescription(BuildEventContext buildEventContext, IEnumerable items)
+        {
+            if (buildEventContext == null || items == null)
             {
                 return;
             }
 
             // node and project context ids for the propertyOutputMap key.
-            int nodeID = e.BuildEventContext.NodeId;
-            int projectContextId = e.BuildEventContext.ProjectContextId;
+            int nodeID = buildEventContext.NodeId;
+            int projectContextId = buildEventContext.ProjectContextId;
 
-            // Create the value to be added to the propertyOutputMap.
-            using var projectConfigurationDescription = new ReuseableStringBuilder();
+            ReuseableStringBuilder projectConfigurationDescription = null;
 
-            foreach (DictionaryEntry item in e.Items)
+            Internal.Utilities.EnumerateItems(items, item =>
             {
-                ITaskItem itemVal = (ITaskItem)item.Value;
                 // Determine if the LogOutputProperties item has been used.
                 if (string.Equals((string)item.Key, ItemMetadataNames.ProjectConfigurationDescription, StringComparison.OrdinalIgnoreCase))
                 {
+                    if (projectConfigurationDescription == null)
+                    {
+                        projectConfigurationDescription = new ReuseableStringBuilder();
+                    }
+
+                    string itemSpec = item.Value switch
+                    {
+                        IItem iitem => iitem.EvaluatedInclude, // ProjectItem
+                        ITaskItem taskItem => taskItem.ItemSpec, // ProjectItemInstance
+                        _ => throw new NotSupportedException(Convert.ToString(item.Value))
+                    };
+
                     // Add the item value to the string to be printed in error/warning messages.
-                    projectConfigurationDescription.Append(" ").Append(itemVal.ItemSpec);
+                    projectConfigurationDescription.Append(" ").Append(itemSpec);
                 }
-            }
+            });
+
             // Add the finished dictionary to propertyOutputMap.
-            propertyOutputMap.Add((nodeID, projectContextId), projectConfigurationDescription.ToString());
+            if (projectConfigurationDescription != null)
+            {
+                propertyOutputMap.Add((nodeID, projectContextId), projectConfigurationDescription.ToString());
+                (projectConfigurationDescription as IDisposable)?.Dispose();
+            }
         }
 
         /// <summary>
@@ -1098,12 +1120,7 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                        && IsVerbosityAtLeast(LoggerVerbosity.Normal)
                     )
                 {
-                    List<BuildMessageEventArgs> messageList;
-                    if (_deferredMessages.ContainsKey(e.BuildEventContext))
-                    {
-                        messageList = _deferredMessages[e.BuildEventContext];
-                    }
-                    else
+                    if (!_deferredMessages.TryGetValue(e.BuildEventContext, out List<BuildMessageEventArgs> messageList))
                     {
                         messageList = new List<BuildMessageEventArgs>();
                         _deferredMessages.Add(e.BuildEventContext, messageList);
@@ -1122,25 +1139,36 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
 
         public override void StatusEventHandler(object sender, BuildStatusEventArgs e)
         {
-            if (showPerfSummary)
+            if (e is ProjectEvaluationStartedEventArgs projectEvaluationStarted)
             {
-                ProjectEvaluationStartedEventArgs projectEvaluationStarted = e as ProjectEvaluationStartedEventArgs;
-
-                if (projectEvaluationStarted != null)
+                if (showPerfSummary)
                 {
                     MPPerformanceCounter counter = GetPerformanceCounter(projectEvaluationStarted.ProjectFile, ref projectEvaluationPerformanceCounters);
                     counter.AddEventStarted(null, e.BuildEventContext, e.Timestamp, s_compareContextNodeId);
-
-                    return;
                 }
-
-                ProjectEvaluationFinishedEventArgs projectEvaluationFinished = e as ProjectEvaluationFinishedEventArgs;
-
-                if (projectEvaluationFinished != null)
+            }
+            else if (e is ProjectEvaluationFinishedEventArgs projectEvaluationFinished)
+            {
+                if (showPerfSummary)
                 {
                     MPPerformanceCounter counter = GetPerformanceCounter(projectEvaluationFinished.ProjectFile, ref projectEvaluationPerformanceCounters);
                     counter.AddEventFinished(null, e.BuildEventContext, e.Timestamp);
                 }
+
+                if (Verbosity == LoggerVerbosity.Diagnostic && showItemAndPropertyList)
+                {
+                    if (projectEvaluationFinished.Properties != null)
+                    {
+                        WriteProperties(projectEvaluationFinished, projectEvaluationFinished.Properties);
+                    }
+
+                    if (projectEvaluationFinished.Items != null)
+                    {
+                        WriteItems(projectEvaluationFinished, projectEvaluationFinished.Items);
+                    }
+                }
+
+                ReadProjectConfigurationDescription(projectEvaluationFinished.BuildEventContext, projectEvaluationFinished.Items);
             }
         }
 
@@ -1689,11 +1717,11 @@ internal void AddEventFinished(string projectTargetNames, BuildEventContext buil
 
                 ErrorUtilities.VerifyThrow(_startedEvent != null, "Cannot have finished counter without started counter. ");
 
-                if (_startedEvent.ContainsKey(buildEventContext))
+                if (_startedEvent.TryGetValue(buildEventContext, out object time))
                 {
                     // Calculate the amount of time spent in the event based on the time stamp of when
                     // the started event was created and when the finished event was created
-                    elapsedTime += (TimeSpan.FromTicks(eventTimeStamp.Ticks - (long)_startedEvent[buildEventContext]));
+                    elapsedTime += (TimeSpan.FromTicks(eventTimeStamp.Ticks - (long)time));
                     _startedEvent.Remove(buildEventContext);
                 }
             }
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index 9e25d8e62e7..8b9c74e5085 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -47,23 +47,18 @@ internal void AddProjectStartedEvent(ProjectStartedEventArgs e, bool requireTime
                     int projectTargetKeyLocal = 1;
                     int projectIncrementKeyLocal;
                     // If we haven't seen this project before (by full path) then
-                    // allocate a new key for it and save it away
-                    if (!_projectKey.ContainsKey(e.ProjectFile))
+                    // allocate a new key for it and save it away. Otherwise, retrieve it.
+                    if (!_projectKey.TryGetValue(e.ProjectFile, out projectIncrementKeyLocal))
                     {
                         _projectIncrementKey++;
 
                         _projectKey[e.ProjectFile] = _projectIncrementKey;
                         projectIncrementKeyLocal = _projectIncrementKey;
                     }
-                    else
-                    {
-                        // We've seen this project before, so retrieve it
-                        projectIncrementKeyLocal = _projectKey[e.ProjectFile];
-                    }
 
                     // If we haven't seen any entrypoint for the current project (by full path) then
                     // allocate a new entry point key
-                    if (!_projectTargetKey.ContainsKey(e.ProjectFile))
+                    if (!_projectTargetKey.TryGetValue(e.ProjectFile, out int tempProjectTargetKeyLocal))
                     {
                         _projectTargetKey[e.ProjectFile] = projectTargetKeyLocal;
                     }
@@ -71,7 +66,7 @@ internal void AddProjectStartedEvent(ProjectStartedEventArgs e, bool requireTime
                     {
                         // We've seen this project before, but not this entrypoint, so increment
                         // the entrypoint key that we have.
-                        projectTargetKeyLocal = _projectTargetKey[e.ProjectFile] + 1;
+                        projectTargetKeyLocal = tempProjectTargetKeyLocal + 1;
                         _projectTargetKey[e.ProjectFile] = projectTargetKeyLocal;
                     }
 
@@ -173,15 +168,7 @@ internal string[] ProjectCallStackFromProject(BuildEventContext e)
         /// </summary>
         internal ProjectStartedEventMinimumFields GetProjectStartedEvent(BuildEventContext e)
         {
-            ProjectStartedEventMinimumFields buildEvent;
-            if (_projectStartedEvents.ContainsKey(e))
-            {
-                buildEvent = _projectStartedEvents[e];
-            }
-            else
-            {
-                buildEvent = null;
-            }
+            _projectStartedEvents.TryGetValue(e, out ProjectStartedEventMinimumFields buildEvent);
             return buildEvent;
         }
 
@@ -190,15 +177,7 @@ internal ProjectStartedEventMinimumFields GetProjectStartedEvent(BuildEventConte
         /// </summary>
         internal TargetStartedEventMinimumFields GetTargetStartedEvent(BuildEventContext e)
         {
-            TargetStartedEventMinimumFields buildEvent;
-            if (_targetStartedEvents.ContainsKey(e))
-            {
-                buildEvent = _targetStartedEvents[e];
-            }
-            else
-            {
-                buildEvent = null;
-            }
+            _targetStartedEvents.TryGetValue(e, out TargetStartedEventMinimumFields buildEvent);
             return buildEvent;
         }
 
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 50dd953d5e3..c47c5ed976d 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -571,25 +571,36 @@ public override void CustomEventHandler(object sender, CustomBuildEventArgs e)
 
         public override void StatusEventHandler(object sender, BuildStatusEventArgs e)
         {
-            if (showPerfSummary)
+            if (e is ProjectEvaluationStartedEventArgs projectEvaluationStarted)
             {
-                ProjectEvaluationStartedEventArgs projectEvaluationStarted = e as ProjectEvaluationStartedEventArgs;
-
-                if (projectEvaluationStarted != null)
+                if (showPerfSummary)
                 {
                     PerformanceCounter counter = GetPerformanceCounter(projectEvaluationStarted.ProjectFile, ref projectEvaluationPerformanceCounters);
                     counter.InScope = true;
-
-                    return;
                 }
-
-                ProjectEvaluationFinishedEventArgs projectEvaluationFinished = e as ProjectEvaluationFinishedEventArgs;
-
-                if (projectEvaluationFinished != null)
+            }
+            else if (e is ProjectEvaluationFinishedEventArgs projectEvaluationFinished)
+            {
+                if (showPerfSummary)
                 {
                     PerformanceCounter counter = GetPerformanceCounter(projectEvaluationFinished.ProjectFile, ref projectEvaluationPerformanceCounters);
                     counter.InScope = false;
                 }
+
+                if (Verbosity == LoggerVerbosity.Diagnostic && showItemAndPropertyList)
+                {
+                    if (projectEvaluationFinished.Properties != null)
+                    {
+                        var propertyList = ExtractPropertyList(projectEvaluationFinished.Properties);
+                        WriteProperties(propertyList);
+                    }
+
+                    if (projectEvaluationFinished.Items != null)
+                    {
+                        SortedList itemList = ExtractItemList(projectEvaluationFinished.Items);
+                        WriteItems(itemList);
+                    }
+                }
             }
         }
 
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 01a5fd018d2..2dff53cc972 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -31,6 +31,7 @@
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
 
     <PackageReference Include="System.Collections.Immutable" />
+    <PackageReference Include="System.Configuration.ConfigurationManager" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
     <PackageReference Include="System.Text.Json" />
 
@@ -39,7 +40,6 @@
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" />
-    <Reference Include="System.Configuration" />
     <Reference Include="System.IO.Compression" />
     <PackageReference Include="System.Memory" />
   </ItemGroup>
@@ -333,6 +333,8 @@
     <Compile Include="BackEnd\Shared\BuildRequestBlocker.cs" />
     <Compile Include="BackEnd\Shared\BuildRequestConfiguration.cs" />
     <Compile Include="BackEnd\Shared\BuildResult.cs" />
+    <Compile Include="BackEnd\Shared\ResourceRequest.cs" />
+    <Compile Include="BackEnd\Shared\ResourceResponse.cs" />
     <Compile Include="BackEnd\Shared\CircularDependencyException.cs" />
     <Compile Include="BackEnd\Shared\BuildRequestUnblocker.cs" />
     <Compile Include="BackEnd\Shared\IBuildResults.cs" />
@@ -375,6 +377,7 @@
     <Compile Include="Collections\ReadOnlyConvertingDictionary.cs" />
     <!-- ######################## -->
     <Compile Include="Collections\WeakValueDictionary.cs" />
+    <Compile Include="Collections\ArrayDictionary.cs" />
     <!-- #### CONSTRUCTION MODEL ### -->
     <Compile Include="Construction\ProjectElement.cs" />
     <Compile Include="Construction\ProjectElementContainer.cs" />
@@ -419,8 +422,8 @@
     <Compile Include="Definition\ResolvedImport.cs" />
     <Compile Include="Definition\SubToolset.cs" />
     <Compile Include="Definition\Toolset.cs" />
-    <Compile Include="Definition\ToolsetConfigurationReader.cs" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
-    <Compile Include="..\Shared\ToolsetElement.cs" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
+    <Compile Include="Definition\ToolsetConfigurationReader.cs" />
+    <Compile Include="..\Shared\ToolsetElement.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="Definition\ToolsetPropertyDefinition.cs" />
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 5c71c76765a..ed692c7d2c3 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1070,6 +1070,15 @@
   <data name="OutputPropertyLogMessage" xml:space="preserve">
     <value>Output Property: {0}={1}</value>
   </data>
+  <data name="TaskAcquiredCores" xml:space="preserve">
+    <value>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</value>
+  </data>
+  <data name="TaskReleasedCores" xml:space="preserve">
+    <value>Task "{0}" released {1} cores and now holds {2} cores total.</value>
+  </data>
+  <data name="TaskReleasedCoresWarning" xml:space="preserve">
+    <value>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</value>
+  </data>
   <data name="TaskContinuedDueToContinueOnError" xml:space="preserve">
     <value>Build continuing because "{0}" on the task "{1}" is set to "{2}".</value>
   </data>
@@ -1699,6 +1708,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="ProjectImportSkippedMissingFile" xml:space="preserve">
     <value>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the file not existing.</value>
   </data>
+  <data name="ProjectImportSkippedExpressionEvaluatedToEmpty" xml:space="preserve">
+    <value>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</value>
+  </data>
   <data name="ProjectImported" xml:space="preserve">
     <value>Importing project "{0}" into project "{1}" at ({2},{3}).</value>
   </data>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 97c6ae7d7fe..460d8c51045 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -129,12 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">Objekty EvaluationContext vytvořené pomocí SharingPolicy.Isolated nepodporují předávání souborového systému MSBuildFileSystemBase.</target>
+        <target state="translated">Objekty EvaluationContext vytvořené pomocí SharingPolicy.Isolated nepodporují předávání souborového systému MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
-        <target state="new">Killing process with pid = {0}.</target>
+        <target state="translated">Ukončuje se proces s pid = {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -191,7 +191,7 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
         <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only item types may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Při odebírání pomocí MatchOnMetadata je možné odkazovat jen na typy položek.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -242,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">{1} neimportoval projekt {0} v ({2},{3}), protože se výraz vyhodnocuje na prázdný řetězec.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Počáteční hodnota vlastnosti: $({0})={1} Zdroj: {2}</target>
@@ -268,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">Statický graf se načetl za {0} s: počet uzlů: {1}, počet hraničních uzlů: {2}</target>
+        <target state="translated">Statický graf se načetl za {0} s: počet uzlů: {1}, počet hraničních uzlů: {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -293,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: Úloha {0} vrátila false, ale do protokolu se nezaznamenala chyba.</target>
@@ -1676,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: Úloha {1} načtená ze sestavení {2} na cestě {3} nepodporuje parametr {0}. Zkontrolujte, že parametr v úloze existuje, že &lt;UsingTask&gt; odkazuje na správné sestavení a že se jedná o nastavitelnou vlastnost veřejné instance.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 0d28f1e35f5..7856dd8038a 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -129,12 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"Die Übergabe eines MSBuildFileSystemBase-Dateisystems wird von EvaluationContext-Objekten, die mit SharingPolicy.Isolated erstellt wurden, nicht unterstützt."</target>
+        <target state="translated">Die Übergabe eines MSBuildFileSystemBase-Dateisystems an EvaluationContext-Objekte, die mit "SharingPolicy.Isolated" erstellt wurden, wird nicht unterstützt.</target>
         <note />
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
-        <target state="new">Killing process with pid = {0}.</target>
+        <target state="translated">Der Prozess mit PID {0} wird beendet.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -191,7 +191,7 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
         <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only item types may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Beim Entfernen mit "MatchOnMetadata" können nur Elementtypen referenziert werden.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -242,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">Das Projekt "{0}" wurde nicht von "{1}" bei ({2},{3}) importiert, weil der Ausdruck in eine leere Zeichenfolge ausgewertet wurde.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Anfangswert der Eigenschaft: $({0})="{1}", Quelle: {2}</target>
@@ -268,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"Statisches Diagramm in {0} Sekunden geladen: {1} Knoten, {2} Edges"</target>
+        <target state="translated">Statisches Diagramm in {0} Sekunden geladen: {1} Knoten, {2} Edges</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -293,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: Die Aufgabe "{0}" hat FALSE zurückgegeben, jedoch keinen Fehler protokolliert.</target>
@@ -1676,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: Der Parameter "{0}" wird von der Aufgabe "{1}", die aus der Assembly "{2}" und dem Pfad "{3}" geladen wurde, nicht unterstützt. Stellen Sie sicher, dass der Parameter für die Aufgabe vorhanden ist, dass &lt;UsingTask&gt; auf die richtige Assembly verweist und dass die Eigenschaft der öffentlichen Instanz festgelegt werden kann.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index ba6514d2b02..a030cd7e6bd 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -242,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="new">Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
@@ -293,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="new">MSB4181: The "{0}" task returned false but did not log an error.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index fee1eccec2b..10135514f9e 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -129,12 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"Los objetos EvaluationContext creados con SharingPolicy.Isolated no admiten que se les pase un sistema de archivos MSBuildFileSystemBase".</target>
+        <target state="translated">Los objetos EvaluationContext creados con SharingPolicy.Isolated no admiten que se les pase un sistema de archivos MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
-        <target state="new">Killing process with pid = {0}.</target>
+        <target state="translated">Terminando el proceso con el PID = {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -191,7 +191,7 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
         <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only item types may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Solo se puede hacer referencia a los objetos de tipo elemento al quitar con MatchOnMetadata</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -242,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">"{1}" no importó el proyecto "{0}" en ({2},{3}) porque la expresión se evalúa en una cadena vacía.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Valor inicial de la propiedad: $({0})="{1}" Origen: {2}</target>
@@ -268,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"Grafo estático cargado en {0} segundos: {1} nodos, {2} bordes"</target>
+        <target state="translated">Grafo estático cargado en {0} segundos: {1} nodos, {2} bordes</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -293,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: La tarea "{0}" devolvió false, pero no registró un error.</target>
@@ -1676,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: El parámetro "{0}" no es compatible con la tarea "{1}" que se cargó desde el ensamblado {2} desde la ruta de acceso {3}. Compruebe que el parámetro existe en la tarea, que &lt;UsingTask&gt; apunta al ensamblado correcto y que es una propiedad de instancia pública que puede establecerse.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 039fc62e433..77795f49d65 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -129,12 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"Les objets EvaluationContext créés avec SharingPolicy.Isolated ne prennent pas en charge le passage d'un système de fichiers MSBuildFileSystemBase."</target>
+        <target state="translated">Les objets EvaluationContext créés avec SharingPolicy.Isolated ne prennent pas en charge le passage d'un système de fichiers MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
-        <target state="new">Killing process with pid = {0}.</target>
+        <target state="translated">Arrêt du processus ayant le PID = {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -191,7 +191,7 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
         <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only item types may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Seuls les types d'élément peuvent être référencés pour la suppression à l'aide de MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -242,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">Le projet "{0}" n'a pas été importé par "{1}" sur ({2},{3}), car l'expression a la valeur d'une chaîne vide.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Valeur initiale de la propriété : $({0})="{1}" Source : {2}</target>
@@ -268,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"Graphe statique chargé en {0} secondes : {1} nœuds, {2} arêtes"</target>
+        <target state="translated">Graphe statique chargé en {0} secondes : {1} nœuds, {2} arêtes</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -293,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: la tâche "{0}" a retourné false mais n'a pas journalisé d'erreur.</target>
@@ -1676,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: le paramètre "{0}" n'est pas pris en charge par la tâche "{1}" chargée à partir de l'assembly {2} depuis le chemin {3}. Vérifiez que le paramètre existe pour la tâche, que &lt;UsingTask&gt; pointe vers l'assembly approprié et qu'il s'agit d'une propriété d'instance publique définissable.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 9fe35b095d5..2c8d2e9d4ae 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -129,12 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"Agli oggetti EvaluationContext creati con SharingPolicy.Isolated non è possibile passare un file system MSBuildFileSystemBase."</target>
+        <target state="translated">Agli oggetti EvaluationContext creati con SharingPolicy.Isolated non è possibile passare un file system MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
-        <target state="new">Killing process with pid = {0}.</target>
+        <target state="translated">Terminazione del processo con PID = {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -191,7 +191,7 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
         <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only item types may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Durante la rimozione con MatchOnMetadata è possibile fare riferimento a tipi di elemento.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -242,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">Il progetto "{0}" non è stato importato da "{1}" alla posizione ({2},{3}) perché l'espressione restituisce una stringa vuota.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Valore iniziale della proprietà: $({0})="{1}". Origine: {2}</target>
@@ -268,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"Il grafo statico è stato caricato in {0} secondi: {1} nodi, {2} vertici"</target>
+        <target state="translated">Il grafo statico è stato caricato in {0} secondi: {1} nodi, {2} vertici</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -293,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: l'attività "{0}" ha restituito false, ma non è stato registrato alcun errore.</target>
@@ -1676,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: il parametro "{0}" non è supportato dall'attività "{1}" caricata dall'assembly {2} e dal percorso {3}. Verificare che il parametro sia presente per l'attività, che &lt;UsingTask&gt; punti all'assembly corretto e che si tratti di un'istanza pubblica e impostabile della proprietà.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 53381475528..f91a15b4459 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -129,12 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"SharingPolicy.Isolated を指定して作成された EvaluationContext オブジェクトに MSBuildFileSystemBase ファイル システムを渡すことはサポートされていません。"</target>
+        <target state="translated">SharingPolicy.Isolated を指定して作成された EvaluationContext オブジェクトに MSBuildFileSystemBase ファイル システムを渡すことはサポートされていません。</target>
         <note />
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
-        <target state="new">Killing process with pid = {0}.</target>
+        <target state="translated">PID = {0} のプロセスを中止しています。</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -191,7 +191,7 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
         <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only item types may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadata で削除する場合、参照できるのは項目の種類のみです。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -242,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">式の評価結果が空の文字列になったため、プロジェクト "{0}" は "{1}" によって ({2},{3}) でインポートされませんでした。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">プロパティの初期値: $({0})="{1}" ソース: {2}</target>
@@ -268,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"{0} 秒で読み込まれた静的グラフ: {1} ノード、{2} エッジ"</target>
+        <target state="translated">{0} 秒で読み込まれた静的グラフ: {1} ノード、{2} エッジ</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -293,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: "{0}" タスクから false が返されましたが、エラーがログに記録されませんでした。</target>
@@ -1676,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: "{0}" パラメーターは、パス {3} のアセンブリ {2} から読み込まれた "{1}" タスクではサポートされていません。タスクにこのパラメーターが存在すること、&lt;UsingTask&gt; が適切なアセンブリを指していること、それが設定可能なパブリック インスタンス プロパティであることを確認してください。</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 0c24346a7b3..3480d5aa9e1 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -129,12 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"SharingPolicy.Isolated로 만든 EvaluationContext 개체는 MSBuildFileSystemBase 파일 시스템 전달을 지원하지 않습니다."</target>
+        <target state="translated">SharingPolicy.Isolated로 만든 EvaluationContext 개체는 MSBuildFileSystemBase 파일 시스템 전달을 지원하지 않습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
-        <target state="new">Killing process with pid = {0}.</target>
+        <target state="translated">pid가 {0}인 프로세스를 종료하는 중입니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -191,7 +191,7 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
         <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only item types may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadata를 사용하여 제거하는 경우 항목 종류를 하나만 참조할 수 있습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -242,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">빈 문자열로 평가되는 식 때문에 ({2},{3})의 "{1}"이(가) 프로젝트 "{0}"을(를) 가져오지 않았습니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">속성 초기 값: $({0})="{1}" 소스: {2}</target>
@@ -268,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"정적 그래프가 {0}초 안에 로드됨: {1}개 노드, {2}개 에지"</target>
+        <target state="translated">정적 그래프가 {0}초 안에 로드됨: {1}개 노드, {2}개 에지</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -293,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: "{0}" 작업이 false를 반환했지만 오류를 기록하지 않았습니다.</target>
@@ -1676,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: "{0}" 매개 변수는 경로: {3}의 어셈블리: {2} 어셈블리에서 로드한 "{1}" 작업에서 지원되지 않습니다. 작업에 매개 변수가 있고, &lt;UsingTask&gt;가 올바른 어셈블리를 가리키며, 설정 가능한 public 인스턴스 속성인지 확인하세요.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index aa5266f9494..f2ae7700434 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -129,12 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">„Obiekty EvaluationContext utworzone za pomocą elementu SharingPolicy.Isolated nie obsługują przekazywania za pomocą systemu plików MSBuildFileSystemBase.”</target>
+        <target state="translated">Obiekty EvaluationContext utworzone za pomocą elementu SharingPolicy.Isolated nie obsługują przekazywania za pomocą systemu plików MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
-        <target state="new">Killing process with pid = {0}.</target>
+        <target state="translated">Kasowanie procesu z identyfikatorem pid = {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -191,7 +191,7 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
         <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only item types may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Tylko typy elementów mogą być przywoływane podczas usuwania przy użyciu elementu MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -242,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">Projekt „{0}” nie został zaimportowany przez projekt „{1}” o ({2},{3}) z powodu wyrażenia ocenianego jako pusty ciąg.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Wartość początkowa właściwości: $({0})=„{1}” Źródło: {2}</target>
@@ -268,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">„Wykres statyczny załadowany w {0} s, węzły: {1}, krawędzie: {2}”</target>
+        <target state="translated">Wykres statyczny załadowany w {0} s, węzły: {1}, krawędzie: {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -293,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: Zadanie „{0}” zwróciło wartość false, ale nie zarejestrowało błędu.</target>
@@ -1676,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: parametr „{0}” nie jest obsługiwany przez zadanie „{1}” załadowane z zestawu: {2} ze ścieżki: {3}. Sprawdź, czy parametr istnieje w zadaniu, element &lt;UsingTask&gt; wskazuje poprawny zestaw i jest to ustawialna właściwość wystąpienia publicznego.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 6a68c83bc50..d386fdc902b 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -129,12 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"Os objetos EvaluationContext criados com SharingPolicy.Isolable não são compatíveis com o recebimento de um sistema de arquivos MSBuildFileSystemBase."</target>
+        <target state="translated">Os objetos EvaluationContext criados com SharingPolicy.Isolated não são compatíveis com o recebimento de um sistema de arquivos MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
-        <target state="new">Killing process with pid = {0}.</target>
+        <target state="translated">Encerrando o processo com o PID = {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -191,7 +191,7 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
         <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only item types may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Somente tipos de item podem ser referenciados durante a remoção com MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -242,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">O projeto "{0}" não foi importado por "{1}" em ({2},{3}), porque a expressão foi avaliada como uma cadeia de caracteres vazia.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Valor inicial da propriedade: $({0})="{1}" Origem: {2}</target>
@@ -268,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"Grafo estático carregado em {0} segundos: {1} nós, {2} bordas"</target>
+        <target state="translated">Grafo estático carregado em {0} segundos: {1} nós, {2} bordas</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -293,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: A tarefa "{0}" retornou false, mas não registrou um erro.</target>
@@ -1676,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: o parâmetro "{0}" não é compatível com a tarefa "{1}" carregada do assembly: {2} do caminho: {3}. Verifique se o parâmetro existe na tarefa, se a tarefa &lt;UsingTask&gt; aponta para o assembly correto e se é uma propriedade de instância pública configurável.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 1b96d782976..a2a3ffc13fb 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -129,12 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"Объекты EvaluationContext, созданные с помощью SharingPolicy.Isolated, не поддерживают передачу в файловую систему MSBuildFileSystemBase."</target>
+        <target state="translated">Объекты EvaluationContext, созданные с помощью SharingPolicy.Isolated, не поддерживают передачу в файловую систему MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
-        <target state="new">Killing process with pid = {0}.</target>
+        <target state="translated">Завершение процесса с идентификатором {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -191,7 +191,7 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
         <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only item types may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">При удалении с помощью MatchOnMetadata можно ссылаться только на типы элементов.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -242,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">Проект "{0}" не был импортирован "{1}" в ({2},{3}), так как результатом вычисления выражения была пустая строка.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Начальное значение свойства: $({0})="{1}" Источник: {2}</target>
@@ -268,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"Статический граф загружен за {0} с: узлов — {1}, ребер — {2}."</target>
+        <target state="translated">Статический граф загружен за {0} с: узлов — {1}, ребер — {2}.</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -293,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: задача "{0}" возвратила значение false, но не зарегистрировала ошибку.</target>
@@ -1676,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: параметр "{0}" не поддерживается задачей "{1}", загруженной из сборки {2} (путь: {3}). Убедитесь, что параметр существует в задаче, что &lt;UsingTask&gt; указывает на правильную сборку и что этот параметр является устанавливаемым свойством открытого экземпляра.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 6881e585760..0e7ece86344 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -129,12 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"SharingPolicy.Isolated ile oluşturulan EvaluationContext nesneleri bir MSBuildFileSystemBase dosya sisteminin geçirilmesini desteklemez."</target>
+        <target state="translated">SharingPolicy.Isolated ile oluşturulan EvaluationContext nesneleri bir MSBuildFileSystemBase dosya sisteminin geçirilmesini desteklemez.</target>
         <note />
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
-        <target state="new">Killing process with pid = {0}.</target>
+        <target state="translated">PID = {0} işlemi sonlandırılıyor.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -191,7 +191,7 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
         <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only item types may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadata ile kaldırırken yalnızca öğe türlerine başvurulabilir.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -242,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">"{0}" adlı proje, ifadenin boş dize olarak değerlendirilmesi nedeniyle ({2},{3}) konumundaki "{1}" tarafından içeri aktarılmadı.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Özellik başlangıç değeri: $({0})="{1}" Kaynak: {2}</target>
@@ -268,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"Statik graf {0} saniye içinde yüklendi: {1} düğüm, {2} uç"</target>
+        <target state="translated">Statik graf {0} saniye içinde yüklendi: {1} düğüm, {2} uç</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -293,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: "{0}" görevi false değerini döndürdü ancak günlüğe hata kaydetmedi.</target>
@@ -1676,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: "{0}" parametresi, {2} derlemesinin {3} yolundan yüklenmiş "{1}" görevi tarafından desteklenmiyor. Parametrenin görevde bulunduğunu, &lt;UsingTask&gt; öğesinin doğru derlemeyi işaret ettiğini ve bu özelliğin ayarlanabilir bir ortak örnek özelliği olduğunu doğrulayın.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 2c5d49b27bd..7157572b7e0 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -129,12 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">“使用 SharingPolicy.Isolated 创建的 EvaluationContext 对象不支持通过 MSBuildFileSystemBase 文件系统传递。”</target>
+        <target state="translated">使用 SharingPolicy.Isolated 创建的 EvaluationContext 对象不支持通过 MSBuildFileSystemBase 文件系统传递。</target>
         <note />
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
-        <target state="new">Killing process with pid = {0}.</target>
+        <target state="translated">正在终止进程，pid = {0}。</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -191,7 +191,7 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
         <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only item types may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">使用 MatchOnMetadata 删除时，只能引用项类型。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -242,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">由于表达式评估为空字符串，因此项目“{0}”不由 ({2}、{3}) 处的“{1}”导入。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">属性初始值: $({0})=“{1}”，源: {2}</target>
@@ -268,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">“静态图形已在 {0} 秒内加载: {1} 个节点、{2} 个边”</target>
+        <target state="translated">静态图形已在 {0} 秒内加载: {1} 个节点、{2} 个边</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -293,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: “{0}”任务返回了 false，但未记录错误。</target>
@@ -1676,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: 从路径 {3} 处的程序集 {2} 加载的“{1}”任务不支持“{0}”参数。请验证任务上是否存在该参数、&lt;UsingTask&gt; 是否指向正确的程序集，以及它是否是可设置的公共实例属性。</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index bc1a6b8f5be..d8fb2e4baa4 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -129,12 +129,12 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="needs-review-translation">"使用 SharingPolicy.Isolated 建立的 EvaluationContext 物件不支援以 MSBuildFileSystemBase 檔案系統傳遞。"</target>
+        <target state="translated">使用 SharingPolicy.Isolated 建立的 EvaluationContext 物件不支援以 MSBuildFileSystemBase 檔案系統傳遞。</target>
         <note />
       </trans-unit>
       <trans-unit id="KillingProcessWithPid">
         <source>Killing process with pid = {0}.</source>
-        <target state="new">Killing process with pid = {0}.</target>
+        <target state="translated">正在終止 pid = {0} 的處理序。</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -191,7 +191,7 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToReferencedItems">
         <source>Only item types may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only item types may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">使用 MatchOnMetadata 移除時，只能參考項目類型。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
@@ -242,6 +242,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="ProjectImportSkippedExpressionEvaluatedToEmpty">
+        <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to the expression evaluating to an empty string.</source>
+        <target state="translated">因為運算式評估為空字串，所以專案 "{0}" 未在 ({2},{3}) 由 "{1}" 匯入。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">屬性初始值: $({0})="{1}" 來源: {2}</target>
@@ -268,7 +273,7 @@
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
         <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
-        <target state="needs-review-translation">"在 {0} 秒內載入的靜態圖形: {1} 個節點、{2} 個邊緣"</target>
+        <target state="translated">在 {0} 秒內載入的靜態圖形: {1} 個節點、{2} 個邊緣</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -293,6 +298,21 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskAcquiredCores">
+        <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCores">
+        <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
+        <target state="new">Task "{0}" released {1} cores and now holds {2} cores total.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="TaskReleasedCoresWarning">
+        <source>Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</source>
+        <target state="new">Task "{0}" asked to release {1} cores while holding only {2} and now holds {3} cores total.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
         <target state="translated">MSB4181: "{0}" 工作傳回了 False，但未記錄錯誤。</target>
@@ -1676,7 +1696,7 @@
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
         <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
+        <target state="translated">MSB4064: 從路徑 {3} 中組件 {2} 所載入的 "{1}" 工作不支援 "{0}" 參數。請確認該參數存在於該工作中、&lt;UsingTask&gt; 指向正確的組件，且為可設定的公用執行個體屬性。</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 509be5de918..02b46c31efa 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -53,17 +53,15 @@ public EngineFileUtilities(FileMatcher fileMatcher)
         /// </summary>
         /// <param name="directoryEscaped">The directory to evaluate, escaped.</param>
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
-        /// <param name="forceEvaluate">Whether to force file glob expansion when eager expansion is turned off</param>
         /// <returns>Array of file paths, unescaped.</returns>
         internal string[] GetFileListUnescaped
             (
             string directoryEscaped,
-            string filespecEscaped,
-            bool forceEvaluate = false
+            string filespecEscaped
             )
 
         {
-            return GetFileList(directoryEscaped, filespecEscaped, false /* returnEscaped */, forceEvaluate);
+            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: false, forceEvaluateWildCards: false);
         }
 
         /// <summary>
@@ -89,31 +87,21 @@ internal string[] GetFileListEscaped
             bool forceEvaluate = false
             )
         {
-            return GetFileList(directoryEscaped, filespecEscaped, true /* returnEscaped */, forceEvaluate, excludeSpecsEscaped);
+            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: true, forceEvaluate, excludeSpecsEscaped);
         }
 
         internal static bool FilespecHasWildcards(string filespecEscaped)
         {
-            bool containsEscapedWildcards = EscapingUtilities.ContainsEscapedWildcards(filespecEscaped);
-            bool containsRealWildcards = FileMatcher.HasWildcards(filespecEscaped);
-
-            if (containsEscapedWildcards && containsRealWildcards)
-            {
-                // Umm, this makes no sense.  The item's Include has both escaped wildcards and 
-                // real wildcards.  What does he want us to do?  Go to the file system and find
-                // files that literally have '*' in their filename?  Well, that's not going to 
-                // happen because '*' is an illegal character to have in a filename.
-
-                return false;
-            }
-            else if (!containsEscapedWildcards && containsRealWildcards)
-            {
-                return true;
-            }
-            else
+            if (!FileMatcher.HasWildcards(filespecEscaped))
             {
                 return false;
             }
+
+            // If the item's Include has both escaped wildcards and real wildcards, then it's
+            // not clear what they are asking us to do.  Go to the file system and find
+            // files that literally have '*' in their filename?  Well, that's not going to
+            // happen because '*' is an illegal character to have in a filename.
+            return !EscapingUtilities.ContainsEscapedWildcards(filespecEscaped);
         }
 
         /// <summary>
@@ -143,11 +131,6 @@ private string[] GetFileList
         {
             ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
 
-            if (excludeSpecsEscaped == null)
-            {
-                excludeSpecsEscaped = Enumerable.Empty<string>();
-            }
-
             string[] fileList;
 
             if (!FilespecHasWildcards(filespecEscaped) ||
@@ -166,7 +149,7 @@ private string[] GetFileList
                 // Unescape before handing it to the filesystem.
                 var directoryUnescaped = EscapingUtilities.UnescapeAll(directoryEscaped);
                 var filespecUnescaped = EscapingUtilities.UnescapeAll(filespecEscaped);
-                var excludeSpecsUnescaped = excludeSpecsEscaped.Where(IsValidExclude).Select(i => EscapingUtilities.UnescapeAll(i)).ToList();
+                var excludeSpecsUnescaped = excludeSpecsEscaped?.Where(IsValidExclude).Select(i => EscapingUtilities.UnescapeAll(i)).ToList();
 
                 // Get the list of actual files which match the filespec.  Put
                 // the list into a string array.  If the filespec started out
diff --git a/src/Build/Utilities/FileSpecMatchTester.cs b/src/Build/Utilities/FileSpecMatchTester.cs
index e48fca39e77..41aaea15e97 100644
--- a/src/Build/Utilities/FileSpecMatchTester.cs
+++ b/src/Build/Utilities/FileSpecMatchTester.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Shared;
+using System;
 using System.Diagnostics;
 using System.IO;
 using System.Text.RegularExpressions;
@@ -12,36 +13,58 @@ internal readonly struct FileSpecMatcherTester
     {
         private readonly string _currentDirectory;
         private readonly string _unescapedFileSpec;
+        private readonly string _filenamePattern;
         private readonly Regex _regex;
         
-        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, Regex regex)
+        private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, string filenamePattern, Regex regex)
         {
             Debug.Assert(!string.IsNullOrEmpty(unescapedFileSpec));
+            Debug.Assert(currentDirectory != null);
 
             _currentDirectory = currentDirectory;
             _unescapedFileSpec = unescapedFileSpec;
+            _filenamePattern = filenamePattern;
             _regex = regex;
         }
 
         public static FileSpecMatcherTester Parse(string currentDirectory, string fileSpec)
         {
             string unescapedFileSpec = EscapingUtilities.UnescapeAll(fileSpec);
-            Regex regex = EngineFileUtilities.FilespecHasWildcards(fileSpec) ? CreateRegex(unescapedFileSpec, currentDirectory) : null;
+            string filenamePattern = null;
+            Regex regex = null;
 
-            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, regex);
+            if (EngineFileUtilities.FilespecHasWildcards(fileSpec))
+            {
+                CreateRegexOrFilenamePattern(unescapedFileSpec, currentDirectory, out filenamePattern, out regex);
+            }
+
+            return new FileSpecMatcherTester(currentDirectory, unescapedFileSpec, filenamePattern, regex);
         }
 
         public bool IsMatch(string fileToMatch)
         {
             Debug.Assert(!string.IsNullOrEmpty(fileToMatch));
 
-            // check if there is a regex matching the file
+            // We do the matching using one of three code paths, depending on the value of _filenamePattern and _regex.
             if (_regex != null)
             {
-                var normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));
+                string normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));
                 return _regex.IsMatch(normalizedFileToMatch);
             }
 
+            if (_filenamePattern != null)
+            {
+                // Check file name first as it's more likely to not match.
+                string filename = Path.GetFileName(fileToMatch);
+                if (!FileMatcher.IsMatch(filename, _filenamePattern))
+                {
+                    return false;
+                }
+
+                var normalizedFileToMatch = FileUtilities.GetFullPathNoThrow(Path.Combine(_currentDirectory, fileToMatch));
+                return normalizedFileToMatch.StartsWith(_currentDirectory, StringComparison.OrdinalIgnoreCase);
+            }
+
             return FileUtilities.ComparePathsNoThrow(_unescapedFileSpec, fileToMatch, _currentDirectory, alwaysIgnoreCase: true);
         }
 
@@ -49,17 +72,27 @@ public bool IsMatch(string fileToMatch)
         // without this normalization step, strings pointing outside the globbing cone would still match when they shouldn't
         // for example, we dont want "**/*.cs" to match "../Shared/Foo.cs"
         // todo: glob rooting knowledge partially duplicated with MSBuildGlob.Parse and FileMatcher.ComputeFileEnumerationCacheKey
-        private static Regex CreateRegex(string unescapedFileSpec, string currentDirectory)
+        private static void CreateRegexOrFilenamePattern(string unescapedFileSpec, string currentDirectory, out string filenamePattern, out Regex regex)
         {
             FileMatcher.Default.SplitFileSpec(
-            unescapedFileSpec,
-            out string fixedDirPart,
-            out string wildcardDirectoryPart,
-            out string filenamePart);
+                unescapedFileSpec,
+                out string fixedDirPart,
+                out string wildcardDirectoryPart,
+                out string filenamePart);
 
             if (FileUtilities.PathIsInvalid(fixedDirPart))
             {
-                return null;
+                filenamePattern = null;
+                regex = null;
+                return;
+            }
+
+            // Most file specs have "**" as their directory specification so we special case these and make matching faster.
+            if (string.IsNullOrEmpty(fixedDirPart) && FileMatcher.IsRecursiveDirectoryMatch(wildcardDirectoryPart))
+            {
+                filenamePattern = filenamePart;
+                regex = null;
+                return;
             }
 
             var absoluteFixedDirPart = Path.Combine(currentDirectory, fixedDirPart);
@@ -74,11 +107,12 @@ private static Regex CreateRegex(string unescapedFileSpec, string currentDirecto
 
             FileMatcher.Default.GetFileSpecInfoWithRegexObject(
                 recombinedFileSpec,
-                out Regex regex,
+                out Regex regexObject,
                 out bool _,
                 out bool isLegal);
 
-            return isLegal ? regex : null;
+            filenamePattern = null;
+            regex = isLegal ? regexObject : null;
         }
     }
 }
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index e60c3a07af2..373a024e26c 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -32,7 +32,11 @@ public NuGetFrameworkWrapper()
                 BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
             try
             {
+#if FEATURE_ASSEMBLYLOADCONTEXT
                 var NuGetAssembly = Assembly.LoadFrom(Path.Combine(assemblyDirectory, "NuGet.Frameworks.dll"));
+#else
+                var NuGetAssembly = Assembly.LoadFile(Path.Combine(assemblyDirectory, "NuGet.Frameworks.dll"));
+#endif
                 var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
                 var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
                 var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
diff --git a/src/Build/Utilities/RegistryKeyWrapper.cs b/src/Build/Utilities/RegistryKeyWrapper.cs
index 5db9a22e37c..c1503c698ef 100644
--- a/src/Build/Utilities/RegistryKeyWrapper.cs
+++ b/src/Build/Utilities/RegistryKeyWrapper.cs
@@ -3,10 +3,6 @@
 #if FEATURE_WIN32_REGISTRY
 
 using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.IO;
-using System.Security;
 
 using Microsoft.Build.Shared;
 using Microsoft.Win32;
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index 6aae23a460e..325dc50740a 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -2,14 +2,16 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Xml;
+using System.Diagnostics;
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
 using System.Text.RegularExpressions;
+using System.Xml;
 
 using Microsoft.Build.Collections;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 using Toolset = Microsoft.Build.Evaluation.Toolset;
@@ -613,5 +615,116 @@ public static T[] ToArray<T>(this IEnumerator<T> enumerator)
         {
             return enumerator.ToEnumerable().ToArray();
         }
+
+        public static void EnumerateProperties(IEnumerable properties, Action<KeyValuePair<string, string>> callback)
+        {
+            if (properties == null)
+            {
+                return;
+            }
+
+            if (properties is PropertyDictionary<ProjectPropertyInstance> propertyInstanceDictionary)
+            {
+                propertyInstanceDictionary.Enumerate((key, value) =>
+                {
+                    callback(new KeyValuePair<string, string>(key, value));
+                });
+            }
+            else if (properties is PropertyDictionary<ProjectProperty> propertyDictionary)
+            {
+                propertyDictionary.Enumerate((key, value) =>
+                {
+                    callback(new KeyValuePair<string, string>(key, value));
+                });
+            }
+            else
+            {
+                foreach (var item in properties)
+                {
+                    if (item is IProperty property && !string.IsNullOrEmpty(property.Name))
+                    {
+                        callback(new KeyValuePair<string, string>(property.Name, property.EvaluatedValue ?? string.Empty));
+                    }
+                    else if (item is DictionaryEntry dictionaryEntry && dictionaryEntry.Key is string key && !string.IsNullOrEmpty(key))
+                    {
+                        callback(new KeyValuePair<string, string>(key, dictionaryEntry.Value as string ?? string.Empty));
+                    }
+                    else if (item is KeyValuePair<string, string> kvp)
+                    {
+                        callback(kvp);
+                    }
+                    else
+                    {
+                        if (item == null)
+                        {
+                            Debug.Fail($"In {nameof(EnumerateProperties)}(): Unexpected: property is null");
+                        }
+                        else
+                        {
+                            Debug.Fail($"In {nameof(EnumerateProperties)}(): Unexpected property {item} of type {item?.GetType().ToString()}");
+                        }
+                    }
+                }
+            }
+        }
+
+        public static void EnumerateItems(IEnumerable items, Action<DictionaryEntry> callback)
+        {
+            if (items is ItemDictionary<ProjectItemInstance> projectItemInstanceDictionary)
+            {
+                projectItemInstanceDictionary.EnumerateItemsPerType((itemType, itemList) =>
+                {
+                    foreach (var item in itemList)
+                    {
+                        callback(new DictionaryEntry(itemType, item));
+                    }
+                });
+            }
+            else if (items is ItemDictionary<ProjectItem> projectItemDictionary)
+            {
+                projectItemDictionary.EnumerateItemsPerType((itemType, itemList) =>
+                {
+                    foreach (var item in itemList)
+                    {
+                        callback(new DictionaryEntry(itemType, item));
+                    }
+                });
+            }
+            else
+            {
+                foreach (var item in items)
+                {
+                    string itemType = default;
+                    object itemValue = null;
+
+                    if (item is IItem iitem)
+                    {
+                        itemType = iitem.Key;
+                        itemValue = iitem;
+                    }
+                    else if (item is DictionaryEntry dictionaryEntry)
+                    {
+                        itemType = dictionaryEntry.Key as string;
+                        itemValue = dictionaryEntry.Value;
+                    }
+                    else
+                    {
+                        if (item == null)
+                        {
+                            Debug.Fail($"In {nameof(EnumerateItems)}(): Unexpected: {nameof(item)} is null");
+                        }
+                        else
+                        {
+                            Debug.Fail($"In {nameof(EnumerateItems)}(): Unexpected {nameof(item)} {item} of type {item?.GetType().ToString()}");
+                        }
+                    }
+
+                    if (!String.IsNullOrEmpty(itemType))
+                    {
+                        callback(new DictionaryEntry(itemType, itemValue));
+                    }
+                }
+            }
+        }
     }
 }
diff --git a/src/Deprecated/Engine/Resources/xlf/Strings.ru.xlf b/src/Deprecated/Engine/Resources/xlf/Strings.ru.xlf
index 40f34cac944..14c6ab53128 100644
--- a/src/Deprecated/Engine/Resources/xlf/Strings.ru.xlf
+++ b/src/Deprecated/Engine/Resources/xlf/Strings.ru.xlf
@@ -769,7 +769,7 @@
       </trans-unit>
       <trans-unit id="FatalTaskError">
         <source>MSB4018: The "{0}" task failed unexpectedly.</source>
-        <target state="translated">MSB4018: непредвиденная ошибка при выполнении задачи {0}".</target>
+        <target state="translated">MSB4018: непредвиденная ошибка при выполнении задачи "{0}".</target>
         <note>{StrBegin="MSB4018: "}UE: This message is shown when a task terminates because of an unhandled exception. The cause is most likely a
     programming error in the task; however, it is also possible that the unhandled exception originated in the engine, and was
     surfaced through the task when the task called into the engine.</note>
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index 6dc05efbbac..1c9c9b38965 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -519,7 +519,7 @@ bool specifyProjectToolsVersion
 
             string additionalProperties = string.Format(
                 CultureInfo.InvariantCulture,
-                "Configuration={0}; Platform={1}; BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)",
+                "Configuration={0}; Platform={1}; BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionFilterName=$(SolutionFilterName); SolutionPath=$(SolutionPath)",
                 EscapingUtilities.Escape(configurationName),
                 EscapingUtilities.Escape(platformName)
             );
@@ -1608,7 +1608,7 @@ Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
                 BuildTask msbuildTask = newTarget.AddNewTask("MSBuild");
                 msbuildTask.Condition = buildItemReference + " != ''";
                 msbuildTask.SetParameterValue("Projects", buildItemReference);
-                msbuildTask.SetParameterValue("Properties", "Configuration=%(Configuration); Platform=%(Platform); BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)");
+                msbuildTask.SetParameterValue("Properties", "Configuration=%(Configuration); Platform=%(Platform); BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionFilterName=$(SolutionFilterName); SolutionPath=$(SolutionPath)");
 
                 if (!string.IsNullOrEmpty(subTargetName))
                 {
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index 1592e8fd480..06e71865122 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -111,6 +111,17 @@ public DateTime Timestamp
             }
         }
 
+        /// <summary>
+        /// Exposes the private <see cref="timestamp"/> field to derived types.
+        /// Used for serialization. Avoids the side effects of calling the
+        /// <see cref="Timestamp"/> getter.
+        /// </summary>
+        protected internal DateTime RawTimestamp
+        {
+            get => timestamp;
+            set => timestamp = value;
+        }
+
         /// <summary>
         /// The thread that raised event.  
         /// </summary>
@@ -155,24 +166,8 @@ internal virtual void WriteToStream(BinaryWriter writer)
             writer.WriteOptionalString(helpKeyword);
             writer.WriteOptionalString(senderName);
             writer.WriteTimestamp(timestamp);
-
-            writer.Write((Int32)threadId);
-
-            if (buildEventContext == null)
-            {
-                writer.Write((byte)0);
-            }
-            else
-            {
-                writer.Write((byte)1);
-                writer.Write((Int32)buildEventContext.NodeId);
-                writer.Write((Int32)buildEventContext.ProjectContextId);
-                writer.Write((Int32)buildEventContext.TargetId);
-                writer.Write((Int32)buildEventContext.TaskId);
-                writer.Write((Int32)buildEventContext.SubmissionId);
-                writer.Write((Int32)buildEventContext.ProjectInstanceId);
-                writer.Write((Int32)buildEventContext.EvaluationId);
-            }
+            writer.Write(threadId);
+            writer.WriteOptionalBuildEventContext(buildEventContext);
         }
 
         /// <summary>
@@ -182,9 +177,9 @@ internal virtual void WriteToStream(BinaryWriter writer)
         /// <param name="version">The version of the runtime the message packet was created from</param>
         internal virtual void CreateFromStream(BinaryReader reader, int version)
         {
-            message = reader.ReadByte() == 0 ? null : reader.ReadString();
-            helpKeyword = reader.ReadByte() == 0 ? null : reader.ReadString();
-            senderName = reader.ReadByte() == 0 ? null : reader.ReadString();
+            message = reader.ReadOptionalString();
+            helpKeyword = reader.ReadOptionalString();
+            senderName = reader.ReadOptionalString();
 
             long timestampTicks = reader.ReadInt64();
 
diff --git a/src/Framework/IBuildEngine8.cs b/src/Framework/IBuildEngine8.cs
new file mode 100644
index 00000000000..0caaad46678
--- /dev/null
+++ b/src/Framework/IBuildEngine8.cs
@@ -0,0 +1,20 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// This interface extends <see cref="IBuildEngine7" /> to let tasks know if a warning
+    /// they are about to log will be converted into an error.
+    /// </summary>
+    public interface IBuildEngine8 : IBuildEngine7
+    {
+        /// <summary>
+        /// Determines whether the logging service will convert the specified
+        /// warning code into an error.
+        /// </summary>
+        /// <param name="warningCode">The warning code to check.</param>
+        /// <returns>A boolean to determine whether the warning should be treated as an error.</returns>
+        public bool ShouldTreatWarningAsError(string warningCode);
+    }
+}
diff --git a/src/Framework/IBuildEngine9.cs b/src/Framework/IBuildEngine9.cs
new file mode 100644
index 00000000000..6e44be92834
--- /dev/null
+++ b/src/Framework/IBuildEngine9.cs
@@ -0,0 +1,25 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// This interface extends <see cref="IBuildEngine8" /> to provide resource management API to tasks.
+    /// </summary>
+    public interface IBuildEngine9 : IBuildEngine8
+    {
+        /// <summary>
+        /// If a task launches multiple parallel processes, it should ask how many cores it can use.
+        /// </summary>
+        /// <param name="requestedCores">The number of cores a task can potentially use.</param>
+        /// <returns>The number of cores a task is allowed to use.</returns>
+        int RequestCores(int requestedCores);
+
+        /// <summary>
+        /// A task should notify the build manager when all or some of the requested cores are not used anymore.
+        /// When task is finished, the cores it requested are automatically released.
+        /// </summary>
+        /// <param name="coresToRelease">Number of cores no longer in use.</param>
+        void ReleaseCores(int coresToRelease);
+    }
+}
diff --git a/src/Framework/IEventSource4.cs b/src/Framework/IEventSource4.cs
new file mode 100644
index 00000000000..3b6cc009be4
--- /dev/null
+++ b/src/Framework/IEventSource4.cs
@@ -0,0 +1,19 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// This interface defines the events raised by the build engine.
+    /// Loggers use this interface to subscribe to the events they
+    /// are interested in receiving.
+    /// </summary>
+    public interface IEventSource4 : IEventSource3
+    {
+        /// <summary>
+        /// Determines whether properties and items should be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>.
+        /// </summary>
+        void IncludeEvaluationPropertiesAndItems();
+    }
+}
diff --git a/src/Framework/IMetadataContainer.cs b/src/Framework/IMetadataContainer.cs
new file mode 100644
index 00000000000..169130cdef3
--- /dev/null
+++ b/src/Framework/IMetadataContainer.cs
@@ -0,0 +1,22 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Provides a way to efficiently enumerate item metadata
+    /// </summary>
+    internal interface IMetadataContainer
+    {
+        /// <summary>
+        /// Returns a list of metadata names and unescaped values, including
+        /// metadata from item definition groups, but not including built-in
+        /// metadata. Implementations should be low-overhead as the method
+        /// is used for serialization (in node packet translator) as well as
+        /// in the binary logger.
+        /// </summary>
+        IEnumerable<KeyValuePair<string, string>> EnumerateMetadata();
+    }
+}
diff --git a/src/Framework/ITaskItemExtensions.cs b/src/Framework/ITaskItemExtensions.cs
new file mode 100644
index 00000000000..53a5e0d5b42
--- /dev/null
+++ b/src/Framework/ITaskItemExtensions.cs
@@ -0,0 +1,65 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+namespace Microsoft.Build.Framework
+{
+    internal static class ITaskItemExtensions
+    {
+        /// <summary>
+        /// Provides a way to efficiently enumerate custom metadata of an item, without built-in metadata.
+        /// </summary>
+        /// <param name="taskItem">TaskItem implementation to return metadata from</param>
+        /// <remarks>WARNING: do NOT use List`1.AddRange to iterate over this collection.
+        /// CopyOnWriteDictionary from Microsoft.Build.Utilities.v4.0.dll is broken.</remarks>
+        /// <returns>A non-null (but possibly empty) enumerable of item metadata.</returns>
+        public static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(this ITaskItem taskItem)
+        {
+            if (taskItem is IMetadataContainer container)
+            {
+                // This is the common case: most implementations should implement this for quick access
+                return container.EnumerateMetadata();
+            }
+
+            // This runs if ITaskItem is Microsoft.Build.Utilities.TaskItem from Microsoft.Build.Utilities.v4.0.dll
+            // that is loaded from the GAC.
+            IDictionary customMetadata = taskItem.CloneCustomMetadata();
+            if (customMetadata is IEnumerable<KeyValuePair<string, string>> enumerableMetadata)
+            {
+                return enumerableMetadata;
+            }
+
+            // In theory this should never be reachable.
+            var list = new KeyValuePair<string, string>[customMetadata.Count];
+            int i = 0;
+
+            foreach (string metadataName in customMetadata.Keys)
+            {
+                string valueOrError;
+
+                try
+                {
+                    valueOrError = taskItem.GetMetadata(metadataName);
+                }
+                // Temporarily try catch all to mitigate frequent NullReferenceExceptions in
+                // the logging code until CopyOnWritePropertyDictionary is replaced with
+                // ImmutableDictionary. Calling into Debug.Fail to crash the process in case
+                // the exception occurres in Debug builds.
+                catch (Exception e)
+                {
+                    valueOrError = e.Message;
+                    Debug.Fail(e.ToString());
+                }
+
+                list[i] = new KeyValuePair<string, string>(metadataName, valueOrError);
+                i += 1;
+            }
+
+            return list;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index 59296adc225..939d7db72f7 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -8,9 +8,6 @@
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <ApplyNgenOptimization Condition="'$(TargetFramework)' == '$(FullFrameworkTFM)'">partial</ApplyNgenOptimization>
   </PropertyGroup>
-  <ItemGroup>
-    <Compile Remove="BinaryWriterExtensions.cs" />
-  </ItemGroup>
 
   <ItemGroup>
     <PackageReference Include="System.Security.Permissions" Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'" />
@@ -21,6 +18,9 @@
     <Compile Include="..\Shared\Constants.cs">
       <Link>Shared\Constants.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\BinaryReaderExtensions.cs">
+      <Link>Shared\BinaryReaderExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\BinaryWriterExtensions.cs">
       <Link>Shared\BinaryWriterExtensions.cs</Link>
     </Compile>
diff --git a/src/Framework/ProjectEvaluationFinishedEventArgs.cs b/src/Framework/ProjectEvaluationFinishedEventArgs.cs
index 1d900b49c03..88073ecf3ac 100644
--- a/src/Framework/ProjectEvaluationFinishedEventArgs.cs
+++ b/src/Framework/ProjectEvaluationFinishedEventArgs.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using Microsoft.Build.Framework.Profiler;
 
 namespace Microsoft.Build.Framework
@@ -23,7 +24,7 @@ public ProjectEvaluationFinishedEventArgs()
         /// Initializes a new instance of the ProjectEvaluationFinishedEventArgs class.
         /// </summary>
         public ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs)
-            : base(message, null, null, DateTime.UtcNow, messageArgs)
+            : base(message, helpKeyword: null, senderName: null, DateTime.UtcNow, messageArgs)
         {
         }
 
@@ -32,12 +33,27 @@ public ProjectEvaluationFinishedEventArgs(string message, params object[] messag
         /// </summary>
         public string ProjectFile { get; set; }
 
+        /// <summary>
+        /// Global properties used during this evaluation.
+        /// </summary>
+        public IEnumerable GlobalProperties { get; set; }
+
+        /// <summary>
+        /// Final set of properties produced by this evaluation.
+        /// </summary>
+        public IEnumerable Properties { get; set; }
+
+        /// <summary>
+        /// Final set of items produced by this evaluation.
+        /// </summary>
+        public IEnumerable Items { get; set; }
+
         /// <summary>
         /// The result of profiling a project.
         /// </summary>
         /// <remarks>
         /// Null if profiling is not turned on
         /// </remarks>
-        public ProfilerResult? ProfilerResult { get; set; } 
+        public ProfilerResult? ProfilerResult { get; set; }
     }
 }
diff --git a/src/Framework/ProjectEvaluationStartedEventArgs.cs b/src/Framework/ProjectEvaluationStartedEventArgs.cs
index 80332d2c4f4..14100183747 100644
--- a/src/Framework/ProjectEvaluationStartedEventArgs.cs
+++ b/src/Framework/ProjectEvaluationStartedEventArgs.cs
@@ -22,7 +22,7 @@ public ProjectEvaluationStartedEventArgs()
         /// Initializes a new instance of the ProjectEvaluationStartedEventArgs class.
         /// </summary>
         public ProjectEvaluationStartedEventArgs(string message, params object[] messageArgs)
-            : base(message, null, null, DateTime.UtcNow, messageArgs)
+            : base(message, helpKeyword: null, senderName: null, DateTime.UtcNow, messageArgs)
         {
         }
 
diff --git a/src/Framework/TaskItemData.cs b/src/Framework/TaskItemData.cs
new file mode 100644
index 00000000000..8441badb819
--- /dev/null
+++ b/src/Framework/TaskItemData.cs
@@ -0,0 +1,68 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Lightweight specialized implementation of <see cref="ITaskItem"/> only used for deserializing items.
+    /// The goal is to minimize overhead when representing deserialized items.
+    /// Used by node packet translator and binary logger.
+    /// </summary>
+    internal class TaskItemData : ITaskItem, IMetadataContainer
+    {
+        private static readonly Dictionary<string, string> _emptyMetadata = new Dictionary<string, string>();
+
+        public string ItemSpec { get; set; }
+        public IDictionary<string, string> Metadata { get; }
+
+        public TaskItemData(string itemSpec, IDictionary<string, string> metadata)
+        {
+            ItemSpec = itemSpec;
+            Metadata = metadata ?? _emptyMetadata;
+        }
+
+        IEnumerable<KeyValuePair<string, string>> IMetadataContainer.EnumerateMetadata() => Metadata;
+
+        public int MetadataCount => Metadata.Count;
+
+        public ICollection MetadataNames => (ICollection)Metadata.Keys;
+
+        public IDictionary CloneCustomMetadata()
+        {
+            // against the guidance for CloneCustomMetadata this returns the original collection.
+            // Since this is only to be used for serialization and logging, consumers should not
+            // modify the collection. We need to minimize allocations so avoid cloning here.
+            return (IDictionary)Metadata;
+        }
+
+        public void CopyMetadataTo(ITaskItem destinationItem)
+        {
+            throw new NotImplementedException();
+        }
+
+        public string GetMetadata(string metadataName)
+        {
+            Metadata.TryGetValue(metadataName, out var result);
+            return result;
+        }
+
+        public void RemoveMetadata(string metadataName)
+        {
+            throw new NotImplementedException();
+        }
+
+        public void SetMetadata(string metadataName, string metadataValue)
+        {
+            throw new NotImplementedException();
+        }
+
+        public override string ToString()
+        {
+            return $"{ItemSpec} Metadata: {MetadataCount}";
+        }
+    }
+}
diff --git a/src/Framework/TaskParameterEventArgs.cs b/src/Framework/TaskParameterEventArgs.cs
new file mode 100644
index 00000000000..f53363237ce
--- /dev/null
+++ b/src/Framework/TaskParameterEventArgs.cs
@@ -0,0 +1,227 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Text;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework
+{
+    public enum TaskParameterMessageKind
+    {
+        TaskInput,
+        TaskOutput,
+        AddItem,
+        RemoveItem,
+    }
+
+    /// <summary>
+    /// This class is used by tasks to log their parameters (input, output).
+    /// The intrinsic ItemGroupIntrinsicTask to add or remove items also
+    /// uses this class.
+    /// </summary>
+    public class TaskParameterEventArgs : BuildMessageEventArgs
+    {
+        /// <summary>
+        /// Creates an instance of this class for the given task parameter.
+        /// </summary>
+        public TaskParameterEventArgs
+        (
+            TaskParameterMessageKind kind,
+            string itemType,
+            IList items,
+            bool logItemMetadata,
+            DateTime eventTimestamp
+        )
+            : base(null, null, null, MessageImportance.Low, eventTimestamp)
+        {
+            Kind = kind;
+            ItemType = itemType;
+            Items = items;
+            LogItemMetadata = logItemMetadata;
+        }
+
+        public TaskParameterMessageKind Kind { get; private set; }
+        public string ItemType { get; private set; }
+        public IList Items { get; private set; }
+        public bool LogItemMetadata { get; private set; }
+
+        /// <summary>
+        /// The <see cref="TaskParameterEventArgs"/> type is declared in Microsoft.Build.Framework.dll
+        /// which is a declarations assembly. The logic to realize the Message is in Microsoft.Build.dll
+        /// which is an implementations assembly. This seems like the easiest way to inject the
+        /// implementation for realizing the Message.
+        /// </summary>
+        /// <remarks>
+        /// Note that the current implementation never runs and is provided merely
+        /// as a safeguard in case MessageGetter isn't set for some reason.
+        /// </remarks>
+        internal static Func<TaskParameterEventArgs, string> MessageGetter = args =>
+        {
+            var sb = new StringBuilder();
+            sb.AppendLine($"{args.Kind}: {args.ItemType}");
+            foreach (var item in args.Items)
+            {
+                sb.AppendLine(item.ToString());
+            }
+
+            return sb.ToString();
+        };
+
+        /// <summary>
+        /// Provides a way for Microsoft.Build.dll to provide a more efficient dictionary factory
+        /// (using ArrayDictionary`2). Since that is an implementation detail, it is not included
+        /// in Microsoft.Build.Framework.dll so we need this extensibility point here.
+        /// </summary>
+        internal static Func<int, IDictionary<string, string>> DictionaryFactory = capacity => new Dictionary<string, string>(capacity);
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            RawTimestamp = reader.ReadTimestamp();
+            BuildEventContext = reader.ReadOptionalBuildEventContext();
+            Kind = (TaskParameterMessageKind)reader.Read7BitEncodedInt();
+            ItemType = reader.ReadString();
+            Items = ReadItems(reader);
+        }
+
+        private IList ReadItems(BinaryReader reader)
+        {
+            var list = new ArrayList();
+
+            int count = reader.Read7BitEncodedInt();
+            for (int i = 0; i < count; i++)
+            {
+                var item = ReadItem(reader);
+                list.Add(item);
+            }
+
+            return list;
+        }
+
+        private object ReadItem(BinaryReader reader)
+        {
+            string itemSpec = reader.ReadString();
+            int metadataCount = reader.Read7BitEncodedInt();
+            if (metadataCount == 0)
+            {
+                return new TaskItemData(itemSpec, metadata: null);
+            }
+
+            var metadata = DictionaryFactory(metadataCount);
+            for (int i = 0; i < metadataCount; i++)
+            {
+                string key = reader.ReadString();
+                string value = reader.ReadString();
+                if (key != null)
+                {
+                    metadata.Add(key, value);
+                }
+            }
+
+            var taskItem = new TaskItemData(itemSpec, metadata);
+            return taskItem;
+        }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            writer.WriteTimestamp(RawTimestamp);
+            writer.WriteOptionalBuildEventContext(BuildEventContext);
+            writer.Write7BitEncodedInt((int)Kind);
+            writer.Write(ItemType);
+            WriteItems(writer, Items);
+        }
+
+        private void WriteItems(BinaryWriter writer, IList items)
+        {
+            if (items == null)
+            {
+                writer.Write7BitEncodedInt(0);
+                return;
+            }
+
+            int count = items.Count;
+            writer.Write7BitEncodedInt(count);
+
+            for (int i = 0; i < count; i++)
+            {
+                var item = items[i];
+                WriteItem(writer, item);
+            }
+        }
+
+        private void WriteItem(BinaryWriter writer, object item)
+        {
+            if (item is ITaskItem taskItem)
+            {
+                writer.Write(taskItem.ItemSpec);
+                if (LogItemMetadata)
+                {
+                    WriteMetadata(writer, taskItem);
+                }
+                else
+                {
+                    writer.Write7BitEncodedInt(0);
+                }
+            }
+            else // string or ValueType
+            {
+                writer.Write(item?.ToString() ?? "");
+                writer.Write7BitEncodedInt(0);
+            }
+        }
+
+        [ThreadStatic]
+        private static List<KeyValuePair<string, string>> reusableMetadataList;
+
+        private void WriteMetadata(BinaryWriter writer, ITaskItem taskItem)
+        {
+            if (reusableMetadataList == null)
+            {
+                reusableMetadataList = new List<KeyValuePair<string, string>>();
+            }
+
+            // WARNING: Can't use AddRange here because CopyOnWriteDictionary in Microsoft.Build.Utilities.v4.0.dll
+            // is broken. Microsoft.Build.Utilities.v4.0.dll loads from the GAC by XAML markup tooling and it's
+            // implementation doesn't work with AddRange because AddRange special-cases ICollection<T> and
+            // CopyOnWriteDictionary doesn't implement it properly.
+            foreach (var kvp in taskItem.EnumerateMetadata())
+            {
+                reusableMetadataList.Add(kvp);
+            }
+
+            writer.Write7BitEncodedInt(reusableMetadataList.Count);
+            if (reusableMetadataList.Count == 0)
+            {
+                return;
+            }
+
+            foreach (var kvp in reusableMetadataList)
+            {
+                writer.Write(kvp.Key);
+                writer.Write(kvp.Value);
+            }
+
+            reusableMetadataList.Clear();
+        }
+
+        public override string Message
+        {
+            get
+            {
+                lock (this)
+                {
+                    if (base.Message == null)
+                    {
+                        base.Message = MessageGetter(this);
+                    }
+
+                    return base.Message;
+                }
+            }
+        }
+    }
+}
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index be9203b581a..d84158d112e 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -74,4 +74,10 @@
     <Service Include="{82a7f48d-3b50-4b1e-b82e-3ada8210c358}" />
   </ItemGroup>
 
+  <Target Name="CreateTaskDir" AfterTargets="Build" Condition="'$(TargetFrameworkIdentifier)' != ''">
+    <ItemGroup>
+      <OutputAssemblyList Include="$(TargetDir)Microsoft.Build.CommandLine.UnitTests.dll" />
+    </ItemGroup>
+    <Copy SourceFiles="@(OutputAssemblyList)" DestinationFolder="$(TargetDir)Task" />
+  </Target>
 </Project>
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 630890e9085..b3c65a114a6 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -2237,7 +2237,8 @@ public void EndToEndWarnAsErrors()
 
 #if FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
-        /// Ensure that tasks get loaded into their own <see cref="System.Runtime.Loader.AssemblyLoadContext"/>.
+        /// Ensure that tasks get loaded into their own <see cref="System.Runtime.Loader.AssemblyLoadContext"/>
+        /// if they are in a directory other than the MSBuild directory.
         /// </summary>
         /// <remarks>
         /// When loading a task from a test assembly in a test within that assembly, the assembly is already loaded
@@ -2247,7 +2248,10 @@ public void EndToEndWarnAsErrors()
         [Fact]
         public void TasksGetAssemblyLoadContexts()
         {
-            string customTaskPath = Assembly.GetExecutingAssembly().Location;
+            string customTaskPath = Path.Combine(
+                Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location),
+                "Task",
+                Path.GetFileName(Assembly.GetExecutingAssembly().Location));
 
             string projectContents = $@"<Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <UsingTask TaskName=`ValidateAssemblyLoadContext` AssemblyFile=`{customTaskPath}` />
@@ -2259,7 +2263,6 @@ public void TasksGetAssemblyLoadContexts()
 
             ExecuteMSBuildExeExpectSuccess(projectContents);
         }
-
 #endif
 
         private string CopyMSBuild()
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 7d990720a96..912ca4f12ef 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -40,6 +40,7 @@
     <AddAppConfigToBuildOutputs>false</AddAppConfigToBuildOutputs>
 
     <DebugType Condition="'$(Platform)' == 'x64'">full</DebugType><!-- Setting DebugType here goes hand in hand with eng\AfterSigning.targets. This is to prompt the x64 build to produce a 'full' .pdb that's `more compatible` then 'portable' and 'embedded' .pdbs. This doesn't get set on 32 bit architecture, which will default to 'embedded' and 'pdb2pdb' will convert those as needed. See https://github.com/microsoft/msbuild/pull/5070 for context. -->
+    <DefineConstants>$(DefineConstants);MSBUILDENTRYPOINTEXE</DefineConstants>
   </PropertyGroup>
 
   <PropertyGroup>
@@ -221,12 +222,14 @@
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
   </ItemGroup>
+  <ItemGroup>
+    <PackageReference Include="System.Configuration.ConfigurationManager" />
+  </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <!-- File for Assemblies we depend on -->
     <Reference Include="System" />
     <Reference Include="System.Core" />
     <Reference Include="System.Xml" />
-    <Reference Include="System.Configuration" />
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 4810afd35e9..61749a966c9 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1796,6 +1796,7 @@ elementFormDefault="qualified">
     <xs:element name="SolutionExt" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="SolutionFileName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="SolutionName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="SolutionFilterName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="SolutionPath" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="StartAction" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="StartArguments" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index e7604d0970b..34adcd7cb25 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -27,38 +27,38 @@ namespace Microsoft.Build.CommandLine
     /// </summary>
     internal class OutOfProcTaskHostNode :
 #if FEATURE_APPDOMAIN
-        MarshalByRefObject, 
+        MarshalByRefObject,
 #endif
         INodePacketFactory, INodePacketHandler,
 #if CLR2COMPATIBILITY
         IBuildEngine3
 #else
-        IBuildEngine7
+        IBuildEngine9
 #endif
     {
         /// <summary>
         /// Keeps a record of all environment variables that, on startup of the task host, have a different
-        /// value from those that are passed to the task host in the configuration packet for the first task.  
-        /// These environments are assumed to be effectively identical, so the only difference between the 
-        /// two sets of values should be any environment variables that differ between e.g. a 32-bit and a 64-bit 
-        /// process.  Those are the variables that this dictionary should store.  
-        /// 
-        /// - The key into the dictionary is the name of the environment variable. 
-        /// - The Key of the KeyValuePair is the value of the variable in the parent process -- the value that we 
-        ///   wish to ensure is replaced by whatever the correct value in our current process is. 
-        /// - The Value of the KeyValuePair is the value of the variable in the current process -- the value that 
-        ///   we wish to replay the Key value with in the environment that we receive from the parent before 
-        ///   applying it to the current process. 
-        ///   
-        /// Note that either value in the KeyValuePair can be null, as it is completely possible to have an 
-        /// environment variable that is set in 32-bit processes but not in 64-bit, or vice versa.  
-        /// 
-        /// This dictionary must be static because otherwise, if a node is sitting around waiting for reuse, it will 
-        /// have inherited the environment from the previous build, and any differences between the two will be seen 
-        /// as "legitimate".  There is no way for us to know what the differences between the startup environment of 
-        /// the previous build and the environment of the first task run in the task host in this build -- so we 
-        /// must assume that the 4ish system environment variables that this is really meant to catch haven't 
-        /// somehow magically changed between two builds spaced no more than 15 minutes apart.  
+        /// value from those that are passed to the task host in the configuration packet for the first task.
+        /// These environments are assumed to be effectively identical, so the only difference between the
+        /// two sets of values should be any environment variables that differ between e.g. a 32-bit and a 64-bit
+        /// process.  Those are the variables that this dictionary should store.
+        ///
+        /// - The key into the dictionary is the name of the environment variable.
+        /// - The Key of the KeyValuePair is the value of the variable in the parent process -- the value that we
+        ///   wish to ensure is replaced by whatever the correct value in our current process is.
+        /// - The Value of the KeyValuePair is the value of the variable in the current process -- the value that
+        ///   we wish to replay the Key value with in the environment that we receive from the parent before
+        ///   applying it to the current process.
+        ///
+        /// Note that either value in the KeyValuePair can be null, as it is completely possible to have an
+        /// environment variable that is set in 32-bit processes but not in 64-bit, or vice versa.
+        ///
+        /// This dictionary must be static because otherwise, if a node is sitting around waiting for reuse, it will
+        /// have inherited the environment from the previous build, and any differences between the two will be seen
+        /// as "legitimate".  There is no way for us to know what the differences between the startup environment of
+        /// the previous build and the environment of the first task run in the task host in this build -- so we
+        /// must assume that the 4ish system environment variables that this is really meant to catch haven't
+        /// somehow magically changed between two builds spaced no more than 15 minutes apart.
         /// </summary>
         private static IDictionary<string, KeyValuePair<string, string>> s_mismatchedEnvironmentValues;
 
@@ -108,13 +108,13 @@ internal class OutOfProcTaskHostNode :
         private bool _isTaskExecuting;
 
         /// <summary>
-        /// The event which is set when a task has completed.  
+        /// The event which is set when a task has completed.
         /// </summary>
         private AutoResetEvent _taskCompleteEvent;
 
         /// <summary>
-        /// Packet containing all the information relating to the 
-        /// completed state of the task.  
+        /// Packet containing all the information relating to the
+        /// completed state of the task.
         /// </summary>
         private TaskHostTaskComplete _taskCompletePacket;
 
@@ -145,15 +145,15 @@ internal class OutOfProcTaskHostNode :
         private bool _debugCommunications;
 
         /// <summary>
-        /// Flag indicating whether we should modify the environment based on any differences we find between that of the 
-        /// task host at startup and the environment passed to us in our initial task configuration packet.  
+        /// Flag indicating whether we should modify the environment based on any differences we find between that of the
+        /// task host at startup and the environment passed to us in our initial task configuration packet.
         /// </summary>
         private bool _updateEnvironment;
 
         /// <summary>
-        /// An interim step between MSBuildTaskHostDoNotUpdateEnvironment=1 and the default update behavior:  go ahead and 
-        /// do all the updates that we would otherwise have done by default, but log any updates that are made (at low 
-        /// importance) so that the user is aware.  
+        /// An interim step between MSBuildTaskHostDoNotUpdateEnvironment=1 and the default update behavior:  go ahead and
+        /// do all the updates that we would otherwise have done by default, but log any updates that are made (at low
+        /// importance) so that the user is aware.
         /// </summary>
         private bool _updateEnvironmentAndLog;
 
@@ -169,9 +169,9 @@ internal class OutOfProcTaskHostNode :
         /// </summary>
         public OutOfProcTaskHostNode()
         {
-            // We don't know what the current build thinks this variable should be until RunTask(), but as a fallback in case there are 
+            // We don't know what the current build thinks this variable should be until RunTask(), but as a fallback in case there are
             // communications before we get the configuration set up, just go with what was already in the environment from when this node
-            // was initially launched. 
+            // was initially launched.
             _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
 
             _receivedPackets = new Queue<INodePacket>();
@@ -194,7 +194,7 @@ public OutOfProcTaskHostNode()
         #region IBuildEngine Implementation (Properties)
 
         /// <summary>
-        /// Returns the value of ContinueOnError for the currently executing task. 
+        /// Returns the value of ContinueOnError for the currently executing task.
         /// </summary>
         public bool ContinueOnError
         {
@@ -206,7 +206,7 @@ public bool ContinueOnError
         }
 
         /// <summary>
-        /// Returns the line number of the location in the project file of the currently executing task. 
+        /// Returns the line number of the location in the project file of the currently executing task.
         /// </summary>
         public int LineNumberOfTaskNode
         {
@@ -218,7 +218,7 @@ public int LineNumberOfTaskNode
         }
 
         /// <summary>
-        /// Returns the column number of the location in the project file of the currently executing task. 
+        /// Returns the column number of the location in the project file of the currently executing task.
         /// </summary>
         public int ColumnNumberOfTaskNode
         {
@@ -230,7 +230,7 @@ public int ColumnNumberOfTaskNode
         }
 
         /// <summary>
-        /// Returns the project file of the currently executing task. 
+        /// Returns the project file of the currently executing task.
         /// </summary>
         public string ProjectFileOfTaskNode
         {
@@ -246,8 +246,8 @@ public string ProjectFileOfTaskNode
         #region IBuildEngine2 Implementation (Properties)
 
         /// <summary>
-        /// Stub implementation of IBuildEngine2.IsRunningMultipleNodes.  The task host does not support this sort of 
-        /// IBuildEngine callback, so error. 
+        /// Stub implementation of IBuildEngine2.IsRunningMultipleNodes.  The task host does not support this sort of
+        /// IBuildEngine callback, so error.
         /// </summary>
         public bool IsRunningMultipleNodes
         {
@@ -267,12 +267,34 @@ public bool IsRunningMultipleNodes
         public bool AllowFailureWithoutError { get; set; } = false;
         #endregion
 
+        #region IBuildEngine8 Implementation
+
+        /// <summary>
+        /// Contains all warnings that should be logged as errors.
+        /// Non-null empty set when all warnings should be treated as errors.
+        /// </summary>
+        private ICollection<string> WarningsAsErrors { get; set; }
+
+        private ICollection<string> WarningsAsMessages { get; set; }
+
+        public bool ShouldTreatWarningAsError(string warningCode)
+        {
+            // Warnings as messages overrides warnings as errors.
+            if (WarningsAsErrors == null || WarningsAsMessages?.Contains(warningCode) == true)
+            {
+                return false;
+            }
+
+            return WarningsAsErrors.Count == 0 || WarningsAsErrors.Contains(warningCode);
+        }
+        #endregion
+
         #region IBuildEngine Implementation (Methods)
 
         /// <summary>
-        /// Sends the provided error back to the parent node to be logged, tagging it with 
-        /// the parent node's ID so that, as far as anyone is concerned, it might as well have 
-        /// just come from the parent node to begin with. 
+        /// Sends the provided error back to the parent node to be logged, tagging it with
+        /// the parent node's ID so that, as far as anyone is concerned, it might as well have
+        /// just come from the parent node to begin with.
         /// </summary>
         public void LogErrorEvent(BuildErrorEventArgs e)
         {
@@ -280,9 +302,9 @@ public void LogErrorEvent(BuildErrorEventArgs e)
         }
 
         /// <summary>
-        /// Sends the provided warning back to the parent node to be logged, tagging it with 
-        /// the parent node's ID so that, as far as anyone is concerned, it might as well have 
-        /// just come from the parent node to begin with. 
+        /// Sends the provided warning back to the parent node to be logged, tagging it with
+        /// the parent node's ID so that, as far as anyone is concerned, it might as well have
+        /// just come from the parent node to begin with.
         /// </summary>
         public void LogWarningEvent(BuildWarningEventArgs e)
         {
@@ -290,9 +312,9 @@ public void LogWarningEvent(BuildWarningEventArgs e)
         }
 
         /// <summary>
-        /// Sends the provided message back to the parent node to be logged, tagging it with 
-        /// the parent node's ID so that, as far as anyone is concerned, it might as well have 
-        /// just come from the parent node to begin with. 
+        /// Sends the provided message back to the parent node to be logged, tagging it with
+        /// the parent node's ID so that, as far as anyone is concerned, it might as well have
+        /// just come from the parent node to begin with.
         /// </summary>
         public void LogMessageEvent(BuildMessageEventArgs e)
         {
@@ -300,9 +322,9 @@ public void LogMessageEvent(BuildMessageEventArgs e)
         }
 
         /// <summary>
-        /// Sends the provided custom event back to the parent node to be logged, tagging it with 
-        /// the parent node's ID so that, as far as anyone is concerned, it might as well have 
-        /// just come from the parent node to begin with. 
+        /// Sends the provided custom event back to the parent node to be logged, tagging it with
+        /// the parent node's ID so that, as far as anyone is concerned, it might as well have
+        /// just come from the parent node to begin with.
         /// </summary>
         public void LogCustomEvent(CustomBuildEventArgs e)
         {
@@ -310,8 +332,8 @@ public void LogCustomEvent(CustomBuildEventArgs e)
         }
 
         /// <summary>
-        /// Stub implementation of IBuildEngine.BuildProjectFile.  The task host does not support IBuildEngine 
-        /// callbacks for the purposes of building projects, so error.  
+        /// Stub implementation of IBuildEngine.BuildProjectFile.  The task host does not support IBuildEngine
+        /// callbacks for the purposes of building projects, so error.
         /// </summary>
         public bool BuildProjectFile(string projectFileName, string[] targetNames, IDictionary globalProperties, IDictionary targetOutputs)
         {
@@ -324,8 +346,8 @@ public bool BuildProjectFile(string projectFileName, string[] targetNames, IDict
         #region IBuildEngine2 Implementation (Methods)
 
         /// <summary>
-        /// Stub implementation of IBuildEngine2.BuildProjectFile.  The task host does not support IBuildEngine 
-        /// callbacks for the purposes of building projects, so error.  
+        /// Stub implementation of IBuildEngine2.BuildProjectFile.  The task host does not support IBuildEngine
+        /// callbacks for the purposes of building projects, so error.
         /// </summary>
         public bool BuildProjectFile(string projectFileName, string[] targetNames, IDictionary globalProperties, IDictionary targetOutputs, string toolsVersion)
         {
@@ -334,8 +356,8 @@ public bool BuildProjectFile(string projectFileName, string[] targetNames, IDict
         }
 
         /// <summary>
-        /// Stub implementation of IBuildEngine2.BuildProjectFilesInParallel.  The task host does not support IBuildEngine 
-        /// callbacks for the purposes of building projects, so error.  
+        /// Stub implementation of IBuildEngine2.BuildProjectFilesInParallel.  The task host does not support IBuildEngine
+        /// callbacks for the purposes of building projects, so error.
         /// </summary>
         public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IDictionary[] targetOutputsPerProject, string[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion)
         {
@@ -348,8 +370,8 @@ public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targ
         #region IBuildEngine3 Implementation
 
         /// <summary>
-        /// Stub implementation of IBuildEngine3.BuildProjectFilesInParallel.  The task host does not support IBuildEngine 
-        /// callbacks for the purposes of building projects, so error.  
+        /// Stub implementation of IBuildEngine3.BuildProjectFilesInParallel.  The task host does not support IBuildEngine
+        /// callbacks for the purposes of building projects, so error.
         /// </summary>
         public BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, IDictionary[] globalProperties, IList<string>[] removeGlobalProperties, string[] toolsVersion, bool returnTargetOutputs)
         {
@@ -359,7 +381,7 @@ public BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames,
 
         /// <summary>
         /// Stub implementation of IBuildEngine3.Yield.  The task host does not support yielding, so just go ahead and silently
-        /// return, letting the task continue. 
+        /// return, letting the task continue.
         /// </summary>
         public void Yield()
         {
@@ -367,8 +389,8 @@ public void Yield()
         }
 
         /// <summary>
-        /// Stub implementation of IBuildEngine3.Reacquire. The task host does not support yielding, so just go ahead and silently 
-        /// return, letting the task continue. 
+        /// Stub implementation of IBuildEngine3.Reacquire. The task host does not support yielding, so just go ahead and silently
+        /// return, letting the task continue.
         /// </summary>
         public void Reacquire()
         {
@@ -454,6 +476,22 @@ public IReadOnlyDictionary<string, string> GetGlobalProperties()
         }
 
         #endregion
+
+        #region IBuildEngine9 Implementation
+
+        public int RequestCores(int requestedCores)
+        {
+            // No resource management in OOP nodes
+            throw new NotImplementedException();
+        }
+
+        public void ReleaseCores(int coresToRelease)
+        {
+            // No resource management in OOP nodes
+            throw new NotImplementedException();
+        }
+
+        #endregion
 #endif
 
         #region INodePacketFactory Members
@@ -613,7 +651,7 @@ private void HandlePacket(INodePacket packet)
         }
 
         /// <summary>
-        /// Configure the task host according to the information received in the 
+        /// Configure the task host according to the information received in the
         /// configuration packet
         /// </summary>
         private void HandleTaskHostConfiguration(TaskHostConfiguration taskHostConfiguration)
@@ -649,10 +687,10 @@ private void CompleteTask()
 
             _currentConfiguration = null;
 
-            // If the task has been canceled, the event will still be set.  
-            // If so, now that we've completed the task, we want to shut down 
-            // this node -- with no reuse, since we don't know whether the 
-            // task we canceled left the node in a good state or not. 
+            // If the task has been canceled, the event will still be set.
+            // If so, now that we've completed the task, we want to shut down
+            // this node -- with no reuse, since we don't know whether the
+            // task we canceled left the node in a good state or not.
             if (_taskCancelledEvent.WaitOne(0))
             {
                 _shutdownReason = NodeEngineShutdownReason.BuildComplete;
@@ -680,7 +718,7 @@ private void CancelTask()
                     if (_isTaskExecuting)
                     {
 #if FEATURE_THREAD_ABORT
-                        // The thread will be terminated crudely so our environment may be trashed but it's ok since we are 
+                        // The thread will be terminated crudely so our environment may be trashed but it's ok since we are
                         // shutting down ASAP.
                         _taskRunnerThread.Abort();
 #endif
@@ -787,13 +825,14 @@ private void RunTask(object state)
             TaskHostConfiguration taskConfiguration = state as TaskHostConfiguration;
             IDictionary<string, TaskParameter> taskParams = taskConfiguration.TaskParameters;
 
-            // We only really know the values of these variables for sure once we see what we received from our parent 
-            // environment -- otherwise if this was a completely new build, we could lose out on expected environment 
-            // variables.  
+            // We only really know the values of these variables for sure once we see what we received from our parent
+            // environment -- otherwise if this was a completely new build, we could lose out on expected environment
+            // variables.
             _debugCommunications = taskConfiguration.BuildProcessEnvironment.ContainsValueAndIsEqual("MSBUILDDEBUGCOMM", "1", StringComparison.OrdinalIgnoreCase);
             _updateEnvironment = !taskConfiguration.BuildProcessEnvironment.ContainsValueAndIsEqual("MSBuildTaskHostDoNotUpdateEnvironment", "1", StringComparison.OrdinalIgnoreCase);
             _updateEnvironmentAndLog = taskConfiguration.BuildProcessEnvironment.ContainsValueAndIsEqual("MSBuildTaskHostUpdateEnvironmentAndLog", "1", StringComparison.OrdinalIgnoreCase);
-
+            WarningsAsErrors = taskConfiguration.WarningsAsErrors;
+            WarningsAsMessages = taskConfiguration.WarningsAsMessages;
             try
             {
                 // Change to the startup directory
@@ -903,9 +942,9 @@ private void RunTask(object state)
         }
 
         /// <summary>
-        /// Set the environment for the task host -- includes possibly munging the given 
-        /// environment somewhat to account for expected environment differences between, 
-        /// e.g. parent processes and task hosts of different bitnesses. 
+        /// Set the environment for the task host -- includes possibly munging the given
+        /// environment somewhat to account for expected environment differences between,
+        /// e.g. parent processes and task hosts of different bitnesses.
         /// </summary>
         private void SetTaskHostEnvironment(IDictionary<string, string> environment)
         {
@@ -919,7 +958,7 @@ private void SetTaskHostEnvironment(IDictionary<string, string> environment)
                     string oldValue = s_mismatchedEnvironmentValues[variable].Key;
                     string newValue = s_mismatchedEnvironmentValues[variable].Value;
 
-                    // We don't check the return value, because having the variable not exist == be 
+                    // We don't check the return value, because having the variable not exist == be
                     // null is perfectly valid, and mismatchedEnvironmentValues stores those values
                     // as null as well, so the String.Equals should still return that they are equal.
                     string environmentValue = null;
@@ -954,8 +993,8 @@ private void SetTaskHostEnvironment(IDictionary<string, string> environment)
                 }
             }
 
-            // if it's still null here, there were no changes necessary -- so just 
-            // set it to what was already passed in. 
+            // if it's still null here, there were no changes necessary -- so just
+            // set it to what was already passed in.
             if (updatedEnvironment == null)
             {
                 updatedEnvironment = environment;
@@ -965,10 +1004,10 @@ private void SetTaskHostEnvironment(IDictionary<string, string> environment)
         }
 
         /// <summary>
-        /// Given the environment of the task host at the end of task execution, make sure that any 
-        /// processor-specific variables have been re-applied in the correct form for the main node, 
-        /// so that when we pass this dictionary back to the main node, all it should have to do 
-        /// is just set it.  
+        /// Given the environment of the task host at the end of task execution, make sure that any
+        /// processor-specific variables have been re-applied in the correct form for the main node,
+        /// so that when we pass this dictionary back to the main node, all it should have to do
+        /// is just set it.
         /// </summary>
         private IDictionary<string, string> UpdateEnvironmentForMainNode(IDictionary<string, string> environment)
         {
@@ -979,14 +1018,14 @@ private IDictionary<string, string> UpdateEnvironmentForMainNode(IDictionary<str
             {
                 foreach (string variable in s_mismatchedEnvironmentValues.Keys)
                 {
-                    // Since this is munging the property list for returning to the parent process, 
-                    // then the value we wish to replace is the one that is in this process, and the 
-                    // replacement value is the one that originally came from the parent process, 
+                    // Since this is munging the property list for returning to the parent process,
+                    // then the value we wish to replace is the one that is in this process, and the
+                    // replacement value is the one that originally came from the parent process,
                     // instead of the other way around.
                     string oldValue = s_mismatchedEnvironmentValues[variable].Value;
                     string newValue = s_mismatchedEnvironmentValues[variable].Key;
 
-                    // We don't check the return value, because having the variable not exist == be 
+                    // We don't check the return value, because having the variable not exist == be
                     // null is perfectly valid, and mismatchedEnvironmentValues stores those values
                     // as null as well, so the String.Equals should still return that they are equal.
                     string environmentValue = null;
@@ -1011,8 +1050,8 @@ private IDictionary<string, string> UpdateEnvironmentForMainNode(IDictionary<str
                 }
             }
 
-            // if it's still null here, there were no changes necessary -- so just 
-            // set it to what was already passed in. 
+            // if it's still null here, there were no changes necessary -- so just
+            // set it to what was already passed in.
             if (updatedEnvironment == null)
             {
                 updatedEnvironment = environment;
@@ -1022,20 +1061,20 @@ private IDictionary<string, string> UpdateEnvironmentForMainNode(IDictionary<str
         }
 
         /// <summary>
-        /// Make sure the mismatchedEnvironmentValues table has been populated.  Note that this should 
-        /// only do actual work on the very first run of a task in the task host -- otherwise, it should 
-        /// already have been populated. 
+        /// Make sure the mismatchedEnvironmentValues table has been populated.  Note that this should
+        /// only do actual work on the very first run of a task in the task host -- otherwise, it should
+        /// already have been populated.
         /// </summary>
         private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> environment)
         {
             if (s_mismatchedEnvironmentValues == null)
             {
-                // This is the first time that we have received a TaskHostConfiguration packet, so we 
-                // need to construct the mismatched environment table based on our current environment 
+                // This is the first time that we have received a TaskHostConfiguration packet, so we
+                // need to construct the mismatched environment table based on our current environment
                 // (assumed to be effectively identical to startup) and the environment we were given
-                // via the task host configuration, assumed to be effectively identical to the startup 
+                // via the task host configuration, assumed to be effectively identical to the startup
                 // environment of the task host, given that the configuration packet is sent immediately
-                // after the node is launched.  
+                // after the node is launched.
                 s_mismatchedEnvironmentValues = new Dictionary<string, KeyValuePair<string, string>>(StringComparer.OrdinalIgnoreCase);
 
                 foreach (string variable in _savedEnvironment.Keys)
@@ -1075,7 +1114,7 @@ private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> en
         }
 
         /// <summary>
-        /// Sends the requested packet across to the main node. 
+        /// Sends the requested packet across to the main node.
         /// </summary>
         private void SendBuildEvent(BuildEventArgs e)
         {
@@ -1084,7 +1123,7 @@ private void SendBuildEvent(BuildEventArgs e)
                 if (!e.GetType().GetTypeInfo().IsSerializable)
                 {
                     // log a warning and bail.  This will end up re-calling SendBuildEvent, but we know for a fact
-                    // that the warning that we constructed is serializable, so everything should be good.  
+                    // that the warning that we constructed is serializable, so everything should be good.
                     LogWarningFromResource("ExpectedEventToBeSerializable", e.GetType().Name);
                     return;
                 }
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 5f2b1ab2330..f991888ab0c 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -135,8 +135,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </comment>
   </data>
   <data name="HelpMessage_3_SwitchesHeader" UESanitized="true" Visibility="Public">
-    <value>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+    <value>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </value>
     <comment>
       LOCALIZATION: The following should not be localized:
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index ea203edd619..3357d17f9e5 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -235,11 +235,11 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">Přepínače:            Přepínače můžete zadat ve tvaru
-                     -switch i /switch.
+        <target state="translated">Přepínače:            Přepínače můžete zadat pomocí
+                     -switch, /switch a --switch.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -964,7 +964,7 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: Hodnota sestavení grafu není platná.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index dfbf6409b2d..25bbe5047ee 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -235,11 +235,11 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">Schalter:            Beachten Sie, dass Sie Schalter über
-                     "-schalter" und "/schalter" angeben können.
+        <target state="translated">Optionen:            Beachten Sie, dass Sie Optionen über
+                     "-option", "/option" und "--option" angeben können.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -956,7 +956,7 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: Der Wert für die Diagrammerstellung ist nicht gültig.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.en.xlf b/src/MSBuild/Resources/xlf/Strings.en.xlf
index 813d56eb252..0a83c78326a 100644
--- a/src/MSBuild/Resources/xlf/Strings.en.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.en.xlf
@@ -245,11 +245,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="new">Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <target state="new">Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index be5821b7ddb..9c43f2e54c7 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -235,11 +235,11 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
         <target state="translated">Modificadores:            Observe que puede especificar modificadores mediante
-                     "-switch" y "/switch".
+                     "-switch", "/switch" y "--switch".
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -965,7 +965,7 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: El valor de compilación del grafo no es válido.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 1e9052ab0ec..8dffc1dcb1f 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -235,11 +235,11 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">Commutateurs :            Notez que vous pouvez spécifier des commutateurs avec
-                     "-switch" et "/switch".
+        <target state="translated">Commutateurs :            Vous pouvez spécifier des commutateurs avec
+                     "-switch", "/switch" et "--switch".
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -957,7 +957,7 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: la valeur de build du graphe n'est pas valide.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 3576dee6f26..86e4bea0a6f 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -242,11 +242,11 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
         <target state="translated">Opzioni:            Tenere presente che è possibile specificare le opzioni
-                     usando "-switch" e "/switch".
+                     usando "-switch", "/switch" e "--switch".
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -977,7 +977,7 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: il valore di graphBuild non è valido.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index d64a16c977d..1e8e62c4691 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -235,11 +235,11 @@ Copyright (C) Microsoft Corporation.All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">スイッチ:            スイッチは "-switch" と "/switch" のどちらを使用して
-                     指定しても構いません。
+        <target state="translated">スイッチ:            スイッチは "-switch"、"/switch"、"--switch" を使用して
+                     指定できます。
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -956,7 +956,7 @@ Copyright (C) Microsoft Corporation.All rights reserved.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: Graph build 値が無効です。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index b627ff1eef4..365eb71c56d 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -235,11 +235,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">스위치:            스위치를 지정하는 데 "-switch" 및 "/switch"를
-                     둘 다 사용할 수 있습니다.
+        <target state="translated">스위치:            스위치를 지정하는 데 "-switch", "/switch" 및 "--switch"를
+                     사용할 수 있습니다.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -956,7 +956,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: 그래프 빌드 값이 잘못되었습니다.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 8f1ee8b37b8..160f1b243b0 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -242,11 +242,11 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
         <target state="translated">Przełączniki:            Należy pamiętać, że przełączniki można określać
-                     zarówno za pomocą składni „-przełącznik”, jak i „/przełącznik”.
+                     za pomocą składni „-przełącznik”, „/przełącznik” i „--przełącznik”.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -969,7 +969,7 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: Wartość kompilacji grafu jest nieprawidłowa.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 5d4dd910080..fae30f6dafe 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -236,11 +236,11 @@ isoladamente.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">Switches:            Você pode especificar as opções usando
-                     "-switch" e "/switch".
+        <target state="translated">Opções:            Observe que você pode especificar as opções usando
+                     "-switch", "/switch" e "--switch".
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -957,7 +957,7 @@ isoladamente.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: o valor de build do grafo não é válido.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index b04ff45fb56..2bdd38238f4 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -234,11 +234,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">Параметры:            Вы можете указывать параметры с помощью
-                     "-switch" и "/switch".
+        <target state="translated">Параметры:            Вы можете указывать параметры с использованием синтаксиса
+                     "-switch", "/switch" и "--switch".
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -956,7 +956,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: значение сборки графа является недопустимым.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 73a7f281be0..202406cbc31 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -235,11 +235,11 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">Anahtarlar:            Hem "-switch" hem de "/switch" değerini kullanarak
-                     anahtar beliretebileceğinizi unutmayın.
+        <target state="translated">Anahtarlar:            Hem "-switch" hem de "/switch" ve "--switch" değerini kullanarak
+                     anahtar belirtebileceğinizi unutmayın.
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -960,7 +960,7 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: Grafik derleme değeri geçerli değil.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index dcc8024c787..4ce44b14456 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -235,8 +235,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
         <target state="translated">开关:            请注意，使用 "-switch" 和 "/switch" 均可
                      指定开关。
@@ -956,7 +956,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: 关系图生成值无效。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 0e54b0e7198..8b0536d6981 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -235,11 +235,11 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
     </note>
       </trans-unit>
       <trans-unit id="HelpMessage_3_SwitchesHeader">
-        <source>Switches:            Note that you can specify switches using both
-                     "-switch" and "/switch".
+        <source>Switches:            Note that you can specify switches using
+                     "-switch", "/switch" and "--switch".
 </source>
-        <target state="translated">參數:            請注意，您可以同時使用 "-switch" 和 "/switch"
-                     來指定參數。
+        <target state="translated">參數:            請注意，您可以同時使用 "-switch"、"/switch"，
+以及 "--switch"                     來指定參數。
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
@@ -956,7 +956,7 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
         <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
+        <target state="translated">MSBUILD : error MSB1057: 圖形組建值無效。</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 7891c7923dd..f6e3bc27f4b 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -4,9 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.ComponentModel;
-#if FEATURE_SYSTEM_CONFIGURATION
 using System.Configuration;
-#endif
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 0437fdcbb36..37d0b1c70d6 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -5,7 +5,7 @@
   <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(MonoBuild)' == 'true'" />
 
   <PropertyGroup>
-    <TargetFramework>net35</TargetFramework>    
+    <TargetFramework>net35</TargetFramework>
     <OutputType>Exe</OutputType>
     <PlatformTarget Condition="'$(Platform)' == 'x64'">x64</PlatformTarget>
     <PlatformTarget Condition="'$(Platform)' == 'AnyCPU'">x86</PlatformTarget>
@@ -14,12 +14,12 @@
          This is important for the MSBuild.VSSetup project, which "references" both the x86 and x64
          versions of this project -->
     <RuntimeIdentifiers>win7-x86;win7-x64</RuntimeIdentifiers>
-    
+
     <EnableDefaultItems>false</EnableDefaultItems>
-    <DefineConstants>$(DefineConstants);CLR2COMPATIBILITY</DefineConstants>
+    <DefineConstants>$(DefineConstants);CLR2COMPATIBILITY;TASKHOST</DefineConstants>
     <!-- Need pointers for getting environment block -->
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
-    <!-- It is vital that msbuildtaskhost.exe is allowed to use the full 4GB on 64 bit machines in order to help avoid 
+    <!-- It is vital that msbuildtaskhost.exe is allowed to use the full 4GB on 64 bit machines in order to help avoid
          out of memory problems on large trees -->
     <LargeAddressAware>true</LargeAddressAware>
     <ApplicationIcon>..\MSBuild\MSBuild.ico</ApplicationIcon>
@@ -209,7 +209,7 @@
     <PackageReference Include="PdbGit" /> -->
     <PackageReference Include="SourceLink.Create.CommandLine" />
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
-    <PackageReference Include="jnm2.ReferenceAssemblies.net35" />
+    <PackageReference Include="jnm2.ReferenceAssemblies.net35" PrivateAssets="All" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
     <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
new file mode 100644
index 00000000000..f1a1c16c587
--- /dev/null
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -0,0 +1,79 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.IO;
+using System.Runtime.CompilerServices;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Shared
+{
+    internal static class BinaryReaderExtensions
+    {
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static string ReadOptionalString(this BinaryReader reader)
+        {
+            return reader.ReadByte() == 0 ? null : reader.ReadString();
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static int Read7BitEncodedInt(this BinaryReader reader)
+        {
+            // Read out an Int32 7 bits at a time.  The high bit
+            // of the byte when on means to continue reading more bytes.
+            int count = 0;
+            int shift = 0;
+            byte b;
+            do
+            {
+                // Check for a corrupted stream.  Read a max of 5 bytes.
+                // In a future version, add a DataFormatException.
+                if (shift == 5 * 7)  // 5 bytes max per Int32, shift += 7
+                {
+                    throw new FormatException();
+                }
+
+                // ReadByte handles end of stream cases for us.
+                b = reader.ReadByte();
+                count |= (b & 0x7F) << shift;
+                shift += 7;
+            } while ((b & 0x80) != 0);
+            return count;
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static DateTime ReadTimestamp(this BinaryReader reader)
+        {
+            long timestampTicks = reader.ReadInt64();
+            DateTimeKind kind = (DateTimeKind)reader.ReadInt32();
+            var timestamp = new DateTime(timestampTicks, kind);
+            return timestamp;
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static BuildEventContext ReadOptionalBuildEventContext(this BinaryReader reader)
+        {
+            if (reader.ReadByte() == 0)
+            {
+                return null;
+            }
+
+            return reader.ReadBuildEventContext();
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static BuildEventContext ReadBuildEventContext(this BinaryReader reader)
+        {
+            int nodeId = reader.ReadInt32();
+            int projectContextId = reader.ReadInt32();
+            int targetId = reader.ReadInt32();
+            int taskId = reader.ReadInt32();
+            int submissionId = reader.ReadInt32();
+            int projectInstanceId = reader.ReadInt32();
+            int evaluationId = reader.ReadInt32();
+
+            var buildEventContext = new BuildEventContext(submissionId, nodeId, evaluationId, projectInstanceId, projectContextId, targetId, taskId);
+            return buildEventContext;
+        }
+    }
+}
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index 1a6c9e3c39c..6c2b6337393 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -293,6 +293,32 @@ public void Translate<T, L>(ref IList<T> list, ObjectTranslator<T> objectTransla
                 }
             }
 
+            /// <summary>
+            /// Translates a collection of T into the specified type using an <see cref="ObjectTranslator{T}"/> and <see cref="NodePacketCollectionCreator{L}"/>
+            /// </summary>
+            /// <param name="collection">The collection to be translated.</param>
+            /// <param name="objectTranslator">The translator to use for the values in the collection.</param>
+            /// <param name="collectionFactory">The factory to create the ICollection.</param>
+            /// <typeparam name="T">The type contained in the collection.</typeparam>
+            /// <typeparam name="L">The type of collection to be created.</typeparam>
+            public void Translate<T, L>(ref ICollection<T> collection, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<L> collectionFactory) where L : ICollection<T>
+            {
+                if (!TranslateNullable(collection))
+                {
+                    return;
+                }
+
+                int count = _reader.ReadInt32();
+                collection = collectionFactory(count);
+
+                for (int i = 0; i < count; i++)
+                {
+                    T value = default(T);
+                    objectTranslator(this, ref value);
+                    collection.Add(value);
+                }
+            }
+
             /// <summary>
             /// Translates a DateTime.
             /// </summary>
@@ -883,6 +909,30 @@ public void Translate<T, L>(ref IList<T> list, ObjectTranslator<T> objectTransla
                 }
             }
 
+            /// <summary>
+            /// Translates a collection of T into the specified type using an <see cref="ObjectTranslator{T}"/> and <see cref="NodePacketCollectionCreator{L}"/>
+            /// </summary>
+            /// <param name="collection">The collection to be translated.</param>
+            /// <param name="objectTranslator">The translator to use for the values in the collection.</param>
+            /// <param name="collectionFactory">The factory to create the ICollection.</param>
+            /// <typeparam name="T">The type contained in the collection.</typeparam>
+            /// <typeparam name="L">The type of collection to be created.</typeparam>
+            public void Translate<T, L>(ref ICollection<T> collection, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<L> collectionFactory) where L : ICollection<T>
+            {
+                if (!TranslateNullable(collection))
+                {
+                    return;
+                }
+
+                _writer.Write(collection.Count);
+
+                foreach (T item in collection)
+                {
+                    T value = item;
+                    objectTranslator(this, ref value);
+                }
+            }
+
             /// <summary>
             /// Translates a DateTime.
             /// </summary>
diff --git a/src/Shared/BinaryWriterExtensions.cs b/src/Shared/BinaryWriterExtensions.cs
index f4f5b00d73b..946eb483eaa 100644
--- a/src/Shared/BinaryWriterExtensions.cs
+++ b/src/Shared/BinaryWriterExtensions.cs
@@ -1,6 +1,10 @@
-﻿using System;
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
 using System.IO;
 using System.Runtime.CompilerServices;
+using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Shared
 {
@@ -23,8 +27,49 @@ public static void WriteOptionalString(this BinaryWriter writer, string value)
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
         public static void WriteTimestamp(this BinaryWriter writer, DateTime timestamp)
         {
-            writer.Write((Int64)timestamp.Ticks);
+            writer.Write(timestamp.Ticks);
             writer.Write((Int32)timestamp.Kind);
         }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static void Write7BitEncodedInt(this BinaryWriter writer, int value)
+        {
+            // Write out an int 7 bits at a time.  The high bit of the byte,
+            // when on, tells reader to continue reading more bytes.
+            uint v = (uint)value;   // support negative numbers
+            while (v >= 0x80)
+            {
+                writer.Write((byte)(v | 0x80));
+                v >>= 7;
+            }
+
+            writer.Write((byte)v);
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static void WriteOptionalBuildEventContext(this BinaryWriter writer, BuildEventContext context)
+        {
+            if (context == null)
+            {
+                writer.Write((byte)0);
+            }
+            else
+            {
+                writer.Write((byte)1);
+                writer.WriteBuildEventContext(context);
+            }
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static void WriteBuildEventContext(this BinaryWriter writer, BuildEventContext context)
+        {
+            writer.Write(context.NodeId);
+            writer.Write(context.ProjectContextId);
+            writer.Write(context.TargetId);
+            writer.Write(context.TaskId);
+            writer.Write(context.SubmissionId);
+            writer.Write(context.ProjectInstanceId);
+            writer.Write(context.EvaluationId);
+        }
     }
 }
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 26859071fc0..e5333429e68 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -478,11 +478,11 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
                 }
                 else
                 {
-                    ErrorUtilities.VerifyThrow(taskHostParameters.ContainsKey(XMakeAttributes.runtime), "Should always have an explicit runtime when we call this method.");
-                    ErrorUtilities.VerifyThrow(taskHostParameters.ContainsKey(XMakeAttributes.architecture), "Should always have an explicit architecture when we call this method.");
+                    ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.runtime, out string runtimeVersion), "Should always have an explicit runtime when we call this method.");
+                    ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.architecture, out string architecture), "Should always have an explicit architecture when we call this method.");
 
-                    clrVersion = taskHostParameters[XMakeAttributes.runtime].Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ? 4 : 2;
-                    is64Bit = taskHostParameters[XMakeAttributes.architecture].Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
+                    clrVersion = runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ? 4 : 2;
+                    is64Bit = architecture.Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
                 }
             }
 
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index d8b2c66c98d..eea2401dca9 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -166,6 +166,10 @@ internal static class ItemMetadataNames
         internal const string subType = "SubType";
         internal const string executableExtension = "ExecutableExtension";
         internal const string embedInteropTypes = "EmbedInteropTypes";
+
+        /// <summary>
+        /// The output path for a given item.
+        /// </summary>
         internal const string targetPath = "TargetPath";
         internal const string dependentUpon = "DependentUpon";
         internal const string msbuildSourceProjectFile = "MSBuildSourceProjectFile";
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index 14cd04a244d..385c5c878e8 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -23,8 +23,15 @@ internal sealed class CoreClrAssemblyLoader
 
         private bool _resolvingHandlerHookedUp = false;
 
+        private static readonly string _msbuildDirPath;
         private static readonly Version _currentAssemblyVersion = new Version(Microsoft.Build.Shared.MSBuildConstants.CurrentAssemblyVersion);
 
+        static CoreClrAssemblyLoader()
+        {
+            _msbuildDirPath = FileUtilities.NormalizePath(typeof(CoreClrAssemblyLoader).Assembly.Location);
+            _msbuildDirPath = Path.GetDirectoryName(_msbuildDirPath);
+        }
+
         public void AddDependencyLocation(string fullPath)
         {
             if (fullPath == null)
@@ -52,7 +59,12 @@ public Assembly LoadFromPath(string fullPath)
             // folders in a NuGet package).
             fullPath = FileUtilities.NormalizePath(fullPath);
 
-            if (Traits.Instance.EscapeHatches.UseSingleLoadContext)
+            // If the requested load comes from the same directory as MSBuild, assume that
+            // the load is part of the platform, and load it using the Default ALC.
+            string assemblyDir = Path.GetDirectoryName(fullPath);
+
+            if (Traits.Instance.EscapeHatches.UseSingleLoadContext ||
+                FileUtilities.ComparePathsNoThrow(assemblyDir, _msbuildDirPath, string.Empty))
             {
                 return LoadUsingLegacyDefaultContext(fullPath);
             }
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index be59150401f..2731c90b61a 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -850,6 +850,20 @@ internal static void VerifyThrowArgumentArraysSameLength(Array parameter1, Array
         }
 
         #endregion
+
+        #region VerifyThrowObjectDisposed
+
+        internal static void VerifyThrowObjectDisposed(bool condition, string objectName)
+        {
+            {
+                if (s_throwExceptions && !condition)
+                {
+                    throw new ObjectDisposedException(objectName);
+                }
+            }
+        }
+
+        #endregion
 #endif
     }
 }
diff --git a/src/Shared/EscapingUtilities.cs b/src/Shared/EscapingUtilities.cs
index 2f0082459b3..309e39a2988 100644
--- a/src/Shared/EscapingUtilities.cs
+++ b/src/Shared/EscapingUtilities.cs
@@ -26,11 +26,25 @@ static internal class EscapingUtilities
         /// </summary>
         private static Dictionary<string, string> s_unescapedToEscapedStrings = new Dictionary<string, string>(StringComparer.Ordinal);
 
-        private static bool IsHexDigit(char character)
+        private static bool TryDecodeHexDigit(char character, out int value)
         {
-            return ((character >= '0') && (character <= '9'))
-                || ((character >= 'A') && (character <= 'F'))
-                || ((character >= 'a') && (character <= 'f'));
+            if (character >= '0' && character <= '9')
+            {
+                value = character - '0';
+                return true;
+            }
+            if (character >= 'A' && character <= 'F')
+            {
+                value = character - 'A' + 10;
+                return true;
+            }
+            if (character >= 'a' && character <= 'f')
+            {
+                value = character - 'a' + 10;
+                return true;
+            }
+            value = default;
+            return false;
         }
 
         /// <summary>
@@ -85,8 +99,8 @@ internal static string UnescapeAll(string escapedString, bool trim = false)
                 // for us to even consider doing anything with this.
                 if (
                         (indexOfPercent <= (escapedStringLength - 3)) &&
-                        IsHexDigit(escapedString[indexOfPercent + 1]) &&
-                        IsHexDigit(escapedString[indexOfPercent + 2])
+                        TryDecodeHexDigit(escapedString[indexOfPercent + 1], out int digit1) &&
+                        TryDecodeHexDigit(escapedString[indexOfPercent + 2], out int digit2)
                     )
                 {
                     // First copy all the characters up to the current percent sign into
@@ -94,9 +108,7 @@ internal static string UnescapeAll(string escapedString, bool trim = false)
                     unescapedString.Append(escapedString, currentPosition, indexOfPercent - currentPosition);
 
                     // Convert the %XX to an actual real character.
-                    string hexString = escapedString.Substring(indexOfPercent + 1, 2);
-                    char unescapedCharacter = (char)int.Parse(hexString, System.Globalization.NumberStyles.HexNumber,
-                        CultureInfo.InvariantCulture);
+                    char unescapedCharacter = (char)((digit1 << 4) + digit2);
 
                     // if the unescaped character is not on the exception list, append it
                     unescapedString.Append(unescapedCharacter);
@@ -214,28 +226,30 @@ string unescapedString
         /// </summary>
         /// <param name="escapedString"></param>
         /// <returns></returns>
-        internal static bool ContainsEscapedWildcards
-            (
-            string escapedString
-            )
+        internal static bool ContainsEscapedWildcards(string escapedString)
         {
-            if (-1 != escapedString.IndexOf('%'))
+            if (escapedString.Length < 3)
             {
-                // It has a '%' sign.  We have promise.
-                if (
-                        (-1 != escapedString.IndexOf("%2", StringComparison.Ordinal)) ||
-                        (-1 != escapedString.IndexOf("%3", StringComparison.Ordinal))
-                    )
+                return false;
+            }
+            // Look for the first %. We know that it has to be followed by at least two more characters so we subtract 2
+            // from the length to search.
+            int index = escapedString.IndexOf('%', 0, escapedString.Length - 2);
+            while (index != -1)
+            {
+                if (escapedString[index + 1] == '2' && (escapedString[index + 2] == 'a' || escapedString[index + 2] == 'A'))
+                {
+                    // %2a or %2A
+                    return true;
+                }
+                if (escapedString[index + 1] == '3' && (escapedString[index + 2] == 'f' || escapedString[index + 2] == 'F'))
                 {
-                    // It has either a '%2' or a '%3'.  This is looking very promising.
-                    return
-
-                            (-1 != escapedString.IndexOf("%2a", StringComparison.Ordinal)) ||
-                            (-1 != escapedString.IndexOf("%2A", StringComparison.Ordinal)) ||
-                            (-1 != escapedString.IndexOf("%3f", StringComparison.Ordinal)) ||
-                            (-1 != escapedString.IndexOf("%3F", StringComparison.Ordinal))
-                        ;
+                    // %3f or %3F
+                    return true;
                 }
+                // Continue searching for % starting at (index + 1). We know that it has to be followed by at least two
+                // more characters so we subtract 2 from the length of the substring to search.
+                index = escapedString.IndexOf('%', index + 1, escapedString.Length - (index + 1) - 2);
             }
             return false;
         }
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index ba1fbfd01d3..1bfdc57490e 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -9,7 +9,6 @@
 using System.Linq;
 using System.Text.RegularExpressions;
 using System.Collections.Generic;
-using System.Collections.Immutable;
 using System.Threading.Tasks;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
@@ -34,14 +33,13 @@ internal class FileMatcher
         private static readonly string[] s_propertyAndItemReferences = { "$(", "@(" };
 
         // on OSX both System.IO.Path separators are '/', so we have to use the literals
-        internal static readonly char[] directorySeparatorCharacters = { '/', '\\' };
-        internal static readonly string[] directorySeparatorStrings = directorySeparatorCharacters.Select(c => c.ToString()).ToArray();
+        internal static readonly char[] directorySeparatorCharacters = FileUtilities.Slashes;
 
         // until Cloudbuild switches to EvaluationContext, we need to keep their dependence on global glob caching via an environment variable
-        private static readonly Lazy<ConcurrentDictionary<string, ImmutableArray<string>>> s_cachedGlobExpansions = new Lazy<ConcurrentDictionary<string, ImmutableArray<string>>>(() => new ConcurrentDictionary<string, ImmutableArray<string>>(StringComparer.OrdinalIgnoreCase));
+        private static readonly Lazy<ConcurrentDictionary<string, IReadOnlyList<string>>> s_cachedGlobExpansions = new Lazy<ConcurrentDictionary<string, IReadOnlyList<string>>>(() => new ConcurrentDictionary<string, IReadOnlyList<string>>(StringComparer.OrdinalIgnoreCase));
         private static readonly Lazy<ConcurrentDictionary<string, object>> s_cachedGlobExpansionsLock = new Lazy<ConcurrentDictionary<string, object>>(() => new ConcurrentDictionary<string, object>(StringComparer.OrdinalIgnoreCase));
 
-        private readonly ConcurrentDictionary<string, ImmutableArray<string>> _cachedGlobExpansions;
+        private readonly ConcurrentDictionary<string, IReadOnlyList<string>> _cachedGlobExpansions;
         private readonly Lazy<ConcurrentDictionary<string, object>> _cachedGlobExpansionsLock = new Lazy<ConcurrentDictionary<string, object>>(() => new ConcurrentDictionary<string, object>(StringComparer.OrdinalIgnoreCase));
 
         /// <summary>
@@ -83,7 +81,7 @@ private static class FileSpecRegexParts
         /// </summary>
         public static FileMatcher Default = new FileMatcher(FileSystems.Default, null);
 
-        public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary<string, ImmutableArray<string>> fileEntryExpansionCache = null) : this(
+        public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary<string, IReadOnlyList<string>> fileEntryExpansionCache = null) : this(
             fileSystem,
             (entityType, path, pattern, projectDirectory, stripProjectDirectory) => GetAccessibleFileSystemEntries(
                 fileSystem,
@@ -91,12 +89,12 @@ public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary<string, Immutabl
                 path,
                 pattern,
                 projectDirectory,
-                stripProjectDirectory),
+                stripProjectDirectory).ToArray(),
             fileEntryExpansionCache)
         {
         }
 
-        public FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemEntries, ConcurrentDictionary<string, ImmutableArray<string>> getFileSystemDirectoryEntriesCache = null)
+        internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemEntries, ConcurrentDictionary<string, IReadOnlyList<string>> getFileSystemDirectoryEntriesCache = null)
         {
             if (Traits.Instance.MSBuildCacheFileEnumerations)
             {
@@ -112,21 +110,51 @@ public FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemEnt
 
             _getFileSystemEntries = getFileSystemDirectoryEntriesCache == null
                 ? getFileSystemEntries
-                : (type, path, pattern, directory, projectDirectory) =>
+                : (type, path, pattern, directory, stripProjectDirectory) =>
                 {
-                    // Cache only directories, for files we won't hit the cache because the file name patterns tend to be unique
-                    if (type == FileSystemEntity.Directories)
+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))
                     {
-                        return getFileSystemDirectoryEntriesCache.GetOrAdd(
-                            $"{path};{pattern ?? "*"}",
-                            s => getFileSystemEntries(
-                                type,
-                                path,
-                                pattern,
-                                directory,
-                                projectDirectory));
+                        // New behavior:
+                        // Always hit the filesystem with "*" pattern, cache the results, and do the filtering here.
+                        string cacheKey = type switch
+                        {
+                            FileSystemEntity.Files => "F",
+                            FileSystemEntity.Directories => "D",
+                            FileSystemEntity.FilesAndDirectories => "A",
+                            _ => throw new NotImplementedException()
+                        } + ";" + path;
+                        IReadOnlyList<string> allEntriesForPath = getFileSystemDirectoryEntriesCache.GetOrAdd(
+                                cacheKey,
+                                s => getFileSystemEntries(
+                                    type,
+                                    path,
+                                    "*",
+                                    directory,
+                                    false));
+                        IEnumerable<string> filteredEntriesForPath = (pattern != null && pattern != "*" && pattern != "*.*")
+                            ? allEntriesForPath.Where(o => IsMatch(Path.GetFileName(o), pattern))
+                            : allEntriesForPath;
+                        return stripProjectDirectory
+                            ? RemoveProjectDirectory(filteredEntriesForPath, directory).ToArray()
+                            : filteredEntriesForPath.ToArray();
+                    }
+                    else
+                    {
+                        // Legacy behavior:
+                        // Cache only directories, for files we won't hit the cache because the file name patterns tend to be unique
+                        if (type == FileSystemEntity.Directories)
+                        {
+                            return getFileSystemDirectoryEntriesCache.GetOrAdd(
+                                $"D;{path};{pattern ?? "*"}",
+                                s => getFileSystemEntries(
+                                    type,
+                                    path,
+                                    pattern,
+                                    directory,
+                                    stripProjectDirectory).ToArray());
+                        }
                     }
-                    return getFileSystemEntries(type, path, pattern, directory, projectDirectory);
+                    return getFileSystemEntries(type, path, pattern, directory, stripProjectDirectory);
                 };
         }
 
@@ -149,8 +177,8 @@ internal enum FileSystemEntity
         /// <param name="pattern">The file pattern.</param>
         /// <param name="projectDirectory"></param>
         /// <param name="stripProjectDirectory"></param>
-        /// <returns>An immutable array of filesystem entries.</returns>
-        internal delegate ImmutableArray<string> GetFileSystemEntries(FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory);
+        /// <returns>An enumerable of filesystem entries.</returns>
+        internal delegate IReadOnlyList<string> GetFileSystemEntries(FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory);
 
         internal static void ClearFileEnumerationsCache()
         {
@@ -179,14 +207,6 @@ internal static bool HasWildcards(string filespec)
             return -1 != filespec.LastIndexOfAny(s_wildcardCharacters);
         }
 
-        /// <summary>
-        /// Determines whether the given path has any wild card characters or semicolons.
-        /// </summary>
-        internal static bool HasWildcardsOrSemicolon(string filespec)
-        {
-            return -1 != filespec.LastIndexOfAny(s_wildcardAndSemicolonCharacters);
-        }
-
         /// <summary>
         /// Determines whether the given path has any wild card characters, any semicolons or any property references.
         /// </summary>
@@ -217,7 +237,7 @@ internal static bool HasPropertyOrItemReferences(string filespec)
         /// <param name="stripProjectDirectory">If true the project directory should be stripped</param>
         /// <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
         /// <returns></returns>
-        private static ImmutableArray<string> GetAccessibleFileSystemEntries(IFileSystem fileSystem, FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
+        private static IReadOnlyList<string> GetAccessibleFileSystemEntries(IFileSystem fileSystem, FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
         {
             path = FileUtilities.FixFilePath(path);
             switch (entityType)
@@ -229,18 +249,18 @@ private static ImmutableArray<string> GetAccessibleFileSystemEntries(IFileSystem
                     ErrorUtilities.VerifyThrow(false, "Unexpected filesystem entity type.");
                     break;
             }
-            return ImmutableArray<string>.Empty;
+            return Array.Empty<string>();
         }
 
         /// <summary>
-        /// Returns an immutable array of file system entries matching the specified search criteria. Inaccessible or non-existent file
+        /// Returns an enumerable of file system entries matching the specified search criteria. Inaccessible or non-existent file
         /// system entries are skipped.
         /// </summary>
         /// <param name="path"></param>
         /// <param name="pattern"></param>
         /// <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
-        /// <returns>An immutable array of matching file system entries (can be empty).</returns>
-        private static ImmutableArray<string> GetAccessibleFilesAndDirectories(IFileSystem fileSystem, string path, string pattern)
+        /// <returns>An enumerable of matching file system entries (can be empty).</returns>
+        private static IReadOnlyList<string> GetAccessibleFilesAndDirectories(IFileSystem fileSystem, string path, string pattern)
         {
             if (fileSystem.DirectoryExists(path))
             {
@@ -248,9 +268,9 @@ private static ImmutableArray<string> GetAccessibleFilesAndDirectories(IFileSyst
                 {
                     return (ShouldEnforceMatching(pattern)
                         ? fileSystem.EnumerateFileSystemEntries(path, pattern)
-                            .Where(o => IsMatch(Path.GetFileName(o), pattern, true))
+                            .Where(o => IsMatch(Path.GetFileName(o), pattern))
                         : fileSystem.EnumerateFileSystemEntries(path, pattern)
-                        ).ToImmutableArray();
+                        ).ToArray();
                 }
                 // for OS security
                 catch (UnauthorizedAccessException)
@@ -264,7 +284,7 @@ private static ImmutableArray<string> GetAccessibleFilesAndDirectories(IFileSyst
                 }
             }
 
-            return ImmutableArray<string>.Empty;
+            return Array.Empty<string>();
         }
 
         /// <summary>
@@ -306,7 +326,7 @@ private static bool ShouldEnforceMatching(string searchPattern)
         /// <param name="stripProjectDirectory"></param>
         /// <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
         /// <returns>Files that can be accessed.</returns>
-        private static ImmutableArray<string> GetAccessibleFiles
+        private static IReadOnlyList<string> GetAccessibleFiles
         (
             IFileSystem fileSystem,
             string path,
@@ -331,7 +351,7 @@ bool stripProjectDirectory
                     files = fileSystem.EnumerateFiles(dir, filespec);
                     if (ShouldEnforceMatching(filespec))
                     {
-                        files = files.Where(o => IsMatch(Path.GetFileName(o), filespec, true));
+                        files = files.Where(o => IsMatch(Path.GetFileName(o), filespec));
                     }
                 }
                 // If the Item is based on a relative path we need to strip
@@ -350,17 +370,17 @@ bool stripProjectDirectory
                     files = RemoveInitialDotSlash(files);
                 }
 
-                return files.ToImmutableArray();
+                return files.ToArray();
             }
             catch (System.Security.SecurityException)
             {
                 // For code access security.
-                return ImmutableArray<string>.Empty;
+                return Array.Empty<string>();
             }
             catch (System.UnauthorizedAccessException)
             {
                 // For OS security.
-                return ImmutableArray<string>.Empty;
+                return Array.Empty<string>();
             }
         }
 
@@ -374,7 +394,7 @@ bool stripProjectDirectory
         /// <param name="pattern">Pattern to match</param>
         /// <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
         /// <returns>Accessible directories.</returns>
-        private static ImmutableArray<string> GetAccessibleDirectories
+        private static IReadOnlyList<string> GetAccessibleDirectories
         (
             IFileSystem fileSystem,
             string path,
@@ -394,7 +414,7 @@ string pattern
                     directories = fileSystem.EnumerateDirectories((path.Length == 0) ? s_thisDirectory : path, pattern);
                     if (ShouldEnforceMatching(pattern))
                     {
-                        directories = directories.Where(o => IsMatch(Path.GetFileName(o), pattern, true));
+                        directories = directories.Where(o => IsMatch(Path.GetFileName(o), pattern));
                     }
                 }
 
@@ -408,17 +428,17 @@ string pattern
                     directories = RemoveInitialDotSlash(directories);
                 }
 
-                return directories.ToImmutableArray();
+                return directories.ToArray();
             }
             catch (System.Security.SecurityException)
             {
                 // For code access security.
-                return ImmutableArray<string>.Empty;
+                return Array.Empty<string>();
             }
             catch (System.UnauthorizedAccessException)
             {
                 // For OS security.
-                return ImmutableArray<string>.Empty;
+                return Array.Empty<string>();
             }
         }
 
@@ -508,10 +528,10 @@ GetFileSystemEntries getFileSystemEntries
                     }
                     else
                     {
-                        // getFileSystemEntries(...) returns an empty array if longPath doesn't exist.
-                        ImmutableArray<string> entries = getFileSystemEntries(FileSystemEntity.FilesAndDirectories, longPath, parts[i], null, false);
+                        // getFileSystemEntries(...) returns an empty enumerable if longPath doesn't exist.
+                        IReadOnlyList<string> entries = getFileSystemEntries(FileSystemEntity.FilesAndDirectories, longPath, parts[i], null, false);
 
-                        if (0 == entries.Length)
+                        if (0 == entries.Count)
                         {
                             // The next part doesn't exist. Therefore, no more of the path will exist.
                             // Just return the rest.
@@ -522,10 +542,10 @@ GetFileSystemEntries getFileSystemEntries
                             break;
                         }
 
-                        // Since we know there are no wild cards, this should be length one.
-                        ErrorUtilities.VerifyThrow(entries.Length == 1,
+                        // Since we know there are no wild cards, this should be length one, i.e. MoveNext should return false.
+                        ErrorUtilities.VerifyThrow(entries.Count == 1,
                             "Unexpected number of entries ({3}) found when enumerating '{0}' under '{1}'. Original path was '{2}'",
-                            parts[i], longPath, path, entries.Length);
+                            parts[i], longPath, path, entries.Count);
 
                         // Entries[0] contains the full path.
                         longPath = entries[0];
@@ -759,11 +779,13 @@ class FilesSearchData
         {
             public FilesSearchData(
                 string filespec,                // can be null
+                string directoryPattern,        // can be null
                 Regex regexFileMatch,           // can be null
                 bool needsRecursion
                 )
             {
                 Filespec = filespec;
+                DirectoryPattern = directoryPattern;
                 RegexFileMatch = regexFileMatch;
                 NeedsRecursion = needsRecursion;
             }
@@ -773,6 +795,13 @@ bool needsRecursion
             /// </summary>
             public string Filespec { get; }
             /// <summary>
+            /// Holds the directory pattern for globs like **/{pattern}/**, i.e. when we're looking for a matching directory name
+            /// regardless of where on the path it is. This field is used only if the wildcard directory part has this shape. In
+            /// other cases such as **/{pattern1}/**/{pattern2}/**, we don't use this optimization and instead rely on
+            /// <see cref="RegexFileMatch"/> to test if a file path matches the glob or not.
+            /// </summary>
+            public string DirectoryPattern { get; }
+            /// <summary>
             /// Wild-card matching.
             /// </summary>
             public Regex RegexFileMatch { get; }
@@ -793,9 +822,18 @@ struct RecursionState
             /// </summary>
             public string RemainingWildcardDirectory;
             /// <summary>
+            /// True if SearchData.DirectoryPattern is non-null and we have descended into a directory that matches the pattern.
+            /// </summary>
+            public bool IsInsideMatchingDirectory;
+            /// <summary>
             /// Data about a search that does not change as the search recursively traverses directories
             /// </summary>
             public FilesSearchData SearchData;
+
+            /// <summary>
+            /// True if a SearchData.DirectoryPattern is specified but we have not descended into a matching directory.
+            /// </summary>
+            public bool IsLookingForMatchingDirectory => (SearchData.DirectoryPattern != null && !IsInsideMatchingDirectory);
         }
 
         /// <summary>
@@ -841,6 +879,8 @@ private void GetFilesRecursive(
 
                     //  We can exclude all results in this folder if:
                     if (
+                        //  We are not looking for a directory matching the pattern given in SearchData.DirectoryPattern
+                        !searchToExclude.IsLookingForMatchingDirectory &&
                         //  We are matching files based on a filespec and not a regular expression
                         searchToExclude.SearchData.Filespec != null &&
                         //  The wildcard path portion of the excluded search matches the include search
@@ -901,6 +941,12 @@ private void GetFilesRecursive(
                 newRecursionState.BaseDirectory = subdir;
                 newRecursionState.RemainingWildcardDirectory = nextStep.RemainingWildcardDirectory;
 
+                if (newRecursionState.IsLookingForMatchingDirectory &&
+                    DirectoryEndsWithPattern(subdir, recursionState.SearchData.DirectoryPattern))
+                {
+                    newRecursionState.IsInsideMatchingDirectory = true;
+                }
+
                 List<RecursionState> newSearchesToExclude = null;
 
                 if (excludeNextSteps != null)
@@ -910,11 +956,16 @@ private void GetFilesRecursive(
                     for (int i = 0; i < excludeNextSteps.Length; i++)
                     {
                         if (excludeNextSteps[i].NeedsDirectoryRecursion &&
-                            (excludeNextSteps[i].DirectoryPattern == null || IsMatch(Path.GetFileName(subdir), excludeNextSteps[i].DirectoryPattern, true)))
+                            (excludeNextSteps[i].DirectoryPattern == null || IsMatch(Path.GetFileName(subdir), excludeNextSteps[i].DirectoryPattern)))
                         {
                             RecursionState thisExcludeStep = searchesToExclude[i];
                             thisExcludeStep.BaseDirectory = subdir;
                             thisExcludeStep.RemainingWildcardDirectory = excludeNextSteps[i].RemainingWildcardDirectory;
+                            if (thisExcludeStep.IsLookingForMatchingDirectory &&
+                                DirectoryEndsWithPattern(subdir, thisExcludeStep.SearchData.DirectoryPattern))
+                            {
+                                thisExcludeStep.IsInsideMatchingDirectory = true;
+                            }
                             newSearchesToExclude.Add(thisExcludeStep);
                         }
                     }
@@ -1012,8 +1063,24 @@ private IEnumerable<string> GetFilesForStep(
             {
                 return Enumerable.Empty<string>();
             }
+
+            // Back-compat hack: We don't use case-insensitive file enumeration I/O on Linux so the behavior is different depending
+            // on the NeedsToProcessEachFile flag. If the flag is false and matching is done within the _getFileSystemEntries call,
+            // it is case sensitive. If the flag is true and matching is handled with MatchFileRecursionStep, it is case-insensitive.
+            // TODO: Can we fix this by using case-insensitive file I/O on Linux?
+            string filespec;
+            if (NativeMethodsShared.IsLinux && recursionState.SearchData.DirectoryPattern != null)
+            {
+                filespec = "*.*";
+                stepResult.NeedsToProcessEachFile = true;
+            }
+            else
+            {
+                filespec = recursionState.SearchData.Filespec;
+            }
+
             IEnumerable<string> files = _getFileSystemEntries(FileSystemEntity.Files, recursionState.BaseDirectory,
-                recursionState.SearchData.Filespec, projectDirectory, stripProjectDirectory);
+                filespec, projectDirectory, stripProjectDirectory);
 
             if (!stepResult.NeedsToProcessEachFile)
             {
@@ -1026,7 +1093,7 @@ private static bool MatchFileRecursionStep(RecursionState recursionState, string
         {
             if (recursionState.SearchData.Filespec != null)
             {
-                return IsMatch(Path.GetFileName(file), recursionState.SearchData.Filespec, true);
+                return IsMatch(Path.GetFileName(file), recursionState.SearchData.Filespec);
             }
 
             // if no file-spec provided, match the file to the regular expression
@@ -1047,9 +1114,14 @@ RecursionState recursionState
             bool considerFiles = false;
 
             // Only consider files if...
-            if (recursionState.RemainingWildcardDirectory.Length == 0)
+            if (recursionState.SearchData.DirectoryPattern != null)
             {
-                // We've reached the end of the wildcard directory elements.
+                // We are looking for a directory pattern and have descended into a matching directory,
+                considerFiles = recursionState.IsInsideMatchingDirectory;
+            }
+            else if (recursionState.RemainingWildcardDirectory.Length == 0)
+            {
+                // or we've reached the end of the wildcard directory elements,
                 considerFiles = true;
             }
             else if (recursionState.RemainingWildcardDirectory.IndexOf(recursiveDirectoryMatch, StringComparison.Ordinal) == 0)
@@ -1121,21 +1193,14 @@ RecursionState recursionState
         /// <param name="fixedDirectoryPart">The fixed directory part.</param>
         /// <param name="wildcardDirectoryPart">The wildcard directory part.</param>
         /// <param name="filenamePart">The filename part.</param>
-        /// <param name="isLegalFileSpec">Receives whether this pattern is legal or not.</param>
         /// <returns>The regular expression string.</returns>
-        private static string RegularExpressionFromFileSpec
+        internal static string RegularExpressionFromFileSpec
         (
             string fixedDirectoryPart,
             string wildcardDirectoryPart,
-            string filenamePart,
-            out bool isLegalFileSpec
+            string filenamePart
         )
         {
-            isLegalFileSpec = IsLegalFileSpec(wildcardDirectoryPart, filenamePart);
-            if (!isLegalFileSpec)
-            {
-                return string.Empty;
-            }
 #if DEBUG
             ErrorUtilities.VerifyThrow(
                 FileSpecRegexMinLength == FileSpecRegexParts.FixedDirGroupStart.Length
@@ -1460,19 +1525,19 @@ internal void GetFileSpecInfoWithRegexObject(
             out bool needsRecursion,
             out bool isLegalFileSpec)
         {
-            string fixedDirectoryPart;
-            string wildcardDirectoryPart;
-            string filenamePart;
-            string matchFileExpression;
-
             GetFileSpecInfo(filespec,
-                out fixedDirectoryPart, out wildcardDirectoryPart, out filenamePart,
-                out matchFileExpression, out needsRecursion, out isLegalFileSpec);
+                out string fixedDirectoryPart, out string wildcardDirectoryPart, out string filenamePart,
+                out needsRecursion, out isLegalFileSpec);
 
-            
-            regexFileMatch = isLegalFileSpec
-                ? new Regex(matchFileExpression, DefaultRegexOptions)
-                : null;
+            if (isLegalFileSpec)
+            {
+                string matchFileExpression = RegularExpressionFromFileSpec(fixedDirectoryPart, wildcardDirectoryPart, filenamePart);
+                regexFileMatch = new Regex(matchFileExpression, DefaultRegexOptions);
+            }
+            else
+            {
+                regexFileMatch = null;
+            }
         }
 
         internal delegate (string fixedDirectoryPart, string recursiveDirectoryPart, string fileNamePart) FixupParts(
@@ -1487,7 +1552,6 @@ internal delegate (string fixedDirectoryPart, string recursiveDirectoryPart, str
         /// <param name="fixedDirectoryPart">Receives the fixed directory part.</param>
         /// <param name="wildcardDirectoryPart">Receives the wildcard directory part.</param>
         /// <param name="filenamePart">Receives the filename part.</param>
-        /// <param name="matchFileExpression">Receives the regular expression.</param>
         /// <param name="needsRecursion">Receives the flag that is true if recursion is required.</param>
         /// <param name="isLegalFileSpec">Receives the flag that is true if the filespec is legal.</param>
         /// <param name="fixupParts">hook method to further change the parts</param>
@@ -1496,7 +1560,6 @@ internal void GetFileSpecInfo(
             out string fixedDirectoryPart,
             out string wildcardDirectoryPart,
             out string filenamePart,
-            out string matchFileExpression,
             out bool needsRecursion,
             out bool isLegalFileSpec,
             FixupParts fixupParts = null)
@@ -1505,7 +1568,6 @@ internal void GetFileSpecInfo(
             fixedDirectoryPart = String.Empty;
             wildcardDirectoryPart = String.Empty;
             filenamePart = String.Empty;
-            matchFileExpression = null;
 
             if (!RawFileSpecIsValid(filespec))
             {
@@ -1527,14 +1589,10 @@ internal void GetFileSpecInfo(
                 filenamePart = newParts.fileNamePart;
             }
 
-            /*
-             *  Get a regular expression for matching files that will be found.
-             */
-            matchFileExpression = RegularExpressionFromFileSpec(fixedDirectoryPart, wildcardDirectoryPart, filenamePart, out isLegalFileSpec);
-
             /*
              * Was the filespec valid? If not, then just return now.
              */
+            isLegalFileSpec = IsLegalFileSpec(wildcardDirectoryPart, filenamePart);
             if (!isLegalFileSpec)
             {
                 return;
@@ -1611,8 +1669,7 @@ internal Result()
         /// </summary>
         /// <param name="input">String which is matched against the pattern.</param>
         /// <param name="pattern">Pattern against which string is matched.</param>
-        /// <param name="ignoreCase">Determines whether ignoring case when comparing two characters</param>
-        internal static bool IsMatch(string input, string pattern, bool ignoreCase)
+        internal static bool IsMatch(string input, string pattern)
         {
             if (input == null)
             {
@@ -1651,26 +1708,20 @@ internal static bool IsMatch(string input, string pattern, bool ignoreCase)
             bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
 #endif
             {
-                // We will mostly be comparing ASCII characters, check this first
-                if (inputChar < 128 && patternChar < 128)
+                // We will mostly be comparing ASCII characters, check English letters first.
+                char inputCharLower = (char)(inputChar | 0x20);
+                if (inputCharLower >= 'a' && inputCharLower <= 'z')
                 {
-                    if (inputChar >= 'A' && inputChar <= 'Z' && patternChar >= 'a' && patternChar <= 'z')
-                    {
-                        return inputChar + 32 == patternChar;
-                    }
-                    if (inputChar >= 'a' && inputChar <= 'z' && patternChar >= 'A' && patternChar <= 'Z')
-                    {
-                        return inputChar == patternChar + 32;
-                    }
-                    return inputChar == patternChar;
+                    // This test covers all combinations of lower/upper as both sides are converted to lower case.
+                    return inputCharLower == (patternChar | 0x20);
                 }
-                if (inputChar > 128 && patternChar > 128)
+                if (inputChar < 128 || patternChar < 128)
                 {
-                    return string.Compare(input, iIndex, pattern, pIndex, 1, StringComparison.OrdinalIgnoreCase) == 0;
+                    // We don't need to compare, an ASCII character cannot have its lowercase/uppercase outside the ASCII table
+                    // and a non ASCII character cannot have its lowercase/uppercase inside the ASCII table
+                    return inputChar == patternChar;
                 }
-                // We don't need to compare, an ASCII character cannot have its lowercase/uppercase outside the ASCII table
-                // and a non ASCII character cannot have its lowercase/uppercase inside the ASCII table
-                return false;
+                return string.Compare(input, iIndex, pattern, pIndex, 1, StringComparison.OrdinalIgnoreCase) == 0;
             }
 #if MONO
             ; // The end of the CompareIgnoreCase anonymous function
@@ -1710,10 +1761,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                                     break;
                                 }
                                 // If the tail doesn't match, we can safely return e.g. ("aaa", "*b")
-                                if ((
-                                        (!ignoreCase && input[inputTailIndex] != pattern[patternTailIndex]) ||
-                                        (ignoreCase && !CompareIgnoreCase(input[inputTailIndex], pattern[patternTailIndex], patternTailIndex, inputTailIndex))
-                                    ) &&
+                                if (!CompareIgnoreCase(input[inputTailIndex], pattern[patternTailIndex], patternTailIndex, inputTailIndex) &&
                                     pattern[patternTailIndex] != '?')
                                 {
                                     return false;
@@ -1733,9 +1781,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                         // The ? wildcard cannot be skipped as we will have a wrong result for e.g. ("aab" "*?b")
                         if (pattern[patternIndex] != '?')
                         {
-                            while (
-                                (!ignoreCase && input[inputIndex] != pattern[patternIndex]) ||
-                                (ignoreCase && !CompareIgnoreCase(input[inputIndex], pattern[patternIndex], inputIndex, patternIndex)))
+                            while (!CompareIgnoreCase(input[inputIndex], pattern[patternIndex], inputIndex, patternIndex))
                             {
                                 // Return if there is no character that match e.g. ("aa", "*b")
                                 if (++inputIndex >= inputLength)
@@ -1750,9 +1796,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                     }
 
                     // If we have a match, step to the next character
-                    if (
-                        (!ignoreCase && input[inputIndex] == pattern[patternIndex]) ||
-                        (ignoreCase && CompareIgnoreCase(input[inputIndex], pattern[patternIndex], inputIndex, patternIndex)) ||
+                    if (CompareIgnoreCase(input[inputIndex], pattern[patternIndex], inputIndex, patternIndex) ||
                         pattern[patternIndex] == '?')
                     {
                         patternIndex++;
@@ -1893,7 +1937,7 @@ internal string[] GetFiles
 
             var enumerationKey = ComputeFileEnumerationCacheKey(projectDirectoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
 
-            ImmutableArray<string> files;
+            IReadOnlyList<string> files;
             if (!_cachedGlobExpansions.TryGetValue(enumerationKey, out files))
             {
                 // avoid parallel evaluations of the same wildcard by using a unique lock for each wildcard
@@ -1909,8 +1953,7 @@ internal string[] GetFiles
                                     GetFilesImplementation(
                                         projectDirectoryUnescaped,
                                         filespecUnescaped,
-                                        excludeSpecsUnescaped)
-                                        .ToImmutableArray());
+                                        excludeSpecsUnescaped));
                     }
                 }
             }
@@ -2012,21 +2055,14 @@ private SearchAction GetFileSearchData(
             stripProjectDirectory = false;
             result = new RecursionState();
 
-            string fixedDirectoryPart;
-            string wildcardDirectoryPart;
-            string filenamePart;
-            string matchFileExpression;
-            bool needsRecursion;
-            bool isLegalFileSpec;
             GetFileSpecInfo
             (
                 filespecUnescaped,
-                out fixedDirectoryPart,
-                out wildcardDirectoryPart,
-                out filenamePart,
-                out matchFileExpression,
-                out needsRecursion,
-                out isLegalFileSpec
+                out string fixedDirectoryPart,
+                out string wildcardDirectoryPart,
+                out string filenamePart,
+                out bool needsRecursion,
+                out bool isLegalFileSpec
             );
 
             /*
@@ -2039,11 +2075,11 @@ out isLegalFileSpec
 
             // The projectDirectory is not null only if we are running the evaluation from
             // inside the engine (i.e. not from a task)
+            string oldFixedDirectoryPart = fixedDirectoryPart;
             if (projectDirectoryUnescaped != null)
             {
                 if (fixedDirectoryPart != null)
                 {
-                    string oldFixedDirectoryPart = fixedDirectoryPart;
                     try
                     {
                         fixedDirectoryPart = Path.Combine(projectDirectoryUnescaped, fixedDirectoryPart);
@@ -2071,11 +2107,37 @@ out isLegalFileSpec
                 return SearchAction.ReturnEmptyList;
             }
 
+            string directoryPattern = null;
+            if (wildcardDirectoryPart.Length > 0)
+            {
+                // If the wildcard directory part looks like "**/{pattern}/**", we are essentially looking for files that have
+                // a matching directory anywhere on their path. This is commonly used when excluding hidden directories using
+                // "**/.*/**" for example, and is worth special-casing so it doesn't fall into the slow regex logic.
+                string wildcard = wildcardDirectoryPart.TrimTrailingSlashes();
+                int wildcardLength = wildcard.Length;
+                if (wildcardLength > 6 &&
+                    wildcard[0] == '*' &&
+                    wildcard[1] == '*' &&
+                    FileUtilities.IsAnySlash(wildcard[2]) &&
+                    FileUtilities.IsAnySlash(wildcard[wildcardLength - 3]) &&
+                    wildcard[wildcardLength - 2] == '*' &&
+                    wildcard[wildcardLength - 1] == '*')
+                {
+                    // Check that there are no other slashes in the wildcard.
+                    if (wildcard.IndexOfAny(FileUtilities.Slashes, 3, wildcardLength - 6) == -1)
+                    {
+                        directoryPattern = wildcard.Substring(3, wildcardLength - 6);
+                    }
+                }
+            }
+
             // determine if we need to use the regular expression to match the files
             // PERF NOTE: Constructing a Regex object is expensive, so we avoid it whenever possible
             bool matchWithRegex =
                 // if we have a directory specification that uses wildcards, and
                 (wildcardDirectoryPart.Length > 0) &&
+                // the directory pattern is not a simple "**/{pattern}/**", and
+                directoryPattern == null &&
                 // the specification is not a simple "**"
                 !IsRecursiveDirectoryMatch(wildcardDirectoryPart);
             // then we need to use the regular expression
@@ -2083,8 +2145,9 @@ out isLegalFileSpec
             var searchData = new FilesSearchData(
                 // if using the regular expression, ignore the file pattern
                 matchWithRegex ? null : filenamePart,
+                directoryPattern,
                 // if using the file pattern, ignore the regular expression
-                matchWithRegex ? new Regex(matchFileExpression, RegexOptions.IgnoreCase) : null,
+                matchWithRegex ? new Regex(RegularExpressionFromFileSpec(oldFixedDirectoryPart, wildcardDirectoryPart, filenamePart), RegexOptions.IgnoreCase) : null,
                 needsRecursion);
 
             result.SearchData = searchData;
@@ -2110,12 +2173,12 @@ internal static string Normalize(string aString)
             var index = 0;
 
             // preserve meaningful roots and their slashes
-            if (aString.Length >= 2 && IsValidDriveChar(aString[0]) && aString[1] == ':')
+            if (aString.Length >= 2 && aString[1] == ':' && IsValidDriveChar(aString[0]))
             {
                 sb.Append(aString[0]);
                 sb.Append(aString[1]);
 
-                var i = SkipCharacters(aString, 2, c => FileUtilities.IsAnySlash(c));
+                var i = SkipSlashes(aString, 2);
 
                 if (index != i)
                 {
@@ -2127,22 +2190,22 @@ internal static string Normalize(string aString)
             else if (aString.StartsWith("/", StringComparison.Ordinal))
             {
                 sb.Append('/');
-                index = SkipCharacters(aString, 1, c => FileUtilities.IsAnySlash(c));
+                index = SkipSlashes(aString, 1);
             }
             else if (aString.StartsWith(@"\\", StringComparison.Ordinal))
             {
                 sb.Append(@"\\");
-                index = SkipCharacters(aString, 2, c => FileUtilities.IsAnySlash(c));
+                index = SkipSlashes(aString, 2);
             }
             else if (aString.StartsWith(@"\", StringComparison.Ordinal))
             {
                 sb.Append(@"\");
-                index = SkipCharacters(aString, 1, c => FileUtilities.IsAnySlash(c));
+                index = SkipSlashes(aString, 1);
             }
 
             while (index < aString.Length)
             {
-                var afterSlashesIndex = SkipCharacters(aString, index, c => FileUtilities.IsAnySlash(c));
+                var afterSlashesIndex = SkipSlashes(aString, index);
 
                 // do not append separator at the end of the string
                 if (afterSlashesIndex >= aString.Length)
@@ -2155,7 +2218,9 @@ internal static string Normalize(string aString)
                     sb.Append(s_directorySeparator);
                 }
 
-                var afterNonSlashIndex = SkipCharacters(aString, afterSlashesIndex, c => !FileUtilities.IsAnySlash(c));
+                // skip non-slashes
+                var indexOfAnySlash = aString.IndexOfAny(directorySeparatorCharacters, afterSlashesIndex);
+                var afterNonSlashIndex = indexOfAnySlash == -1 ? aString.Length : indexOfAnySlash;
 
                 sb.Append(aString, afterSlashesIndex, afterNonSlashIndex - afterSlashesIndex);
 
@@ -2166,16 +2231,16 @@ internal static string Normalize(string aString)
         }
 
         /// <summary>
-        /// Skips characters that satisfy the condition <param name="jumpOverCharacter"></param>
+        /// Skips slash characters in a string.
         /// </summary>
         /// <param name="aString">The working string</param>
         /// <param name="startingIndex">Offset in string to start the search in</param>
-        /// <returns>First index that does not satisfy the condition. Returns the string's length if end of string is reached</returns>
-        private static int SkipCharacters(string aString, int startingIndex, Func<char, bool> jumpOverCharacter)
+        /// <returns>First index that is not a slash. Returns the string's length if end of string is reached</returns>
+        private static int SkipSlashes(string aString, int startingIndex)
         {
             var index = startingIndex;
 
-            while (index < aString.Length && jumpOverCharacter(aString[index]))
+            while (index < aString.Length && FileUtilities.IsAnySlash(aString[index]))
             {
                 index++;
             }
@@ -2187,12 +2252,12 @@ private static int SkipCharacters(string aString, int startingIndex, Func<char,
         /// <summary>
         /// Returns true if the given character is a valid drive letter
         /// </summary>
-        internal static bool IsValidDriveChar(char value)
+        private static bool IsValidDriveChar(char value)
         {
             return (value >= 'A' && value <= 'Z') || (value >= 'a' && value <= 'z');
         }
 
-        static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped, List<string> excludeSpecsUnescaped)
+        private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped, List<string> excludeSpecsUnescaped)
         {
             if (excludeSpecsUnescaped != null)
             {
@@ -2235,10 +2300,8 @@ private string[] GetFilesImplementation(
             /*
              * Analyze the file spec and get the information we need to do the matching.
              */
-            bool stripProjectDirectory;
-            RecursionState state;
             var action = GetFileSearchData(projectDirectoryUnescaped, filespecUnescaped,
-                out stripProjectDirectory, out state);
+                out bool stripProjectDirectory, out RecursionState state);
 
             if (action == SearchAction.ReturnEmptyList)
             {
@@ -2267,11 +2330,8 @@ private string[] GetFilesImplementation(
                 foreach (string excludeSpec in excludeSpecsUnescaped)
                 {
                     //  This is ignored, we always use the include pattern's value for stripProjectDirectory
-                    bool excludeStripProjectDirectory;
-
-                    RecursionState excludeState;
                     var excludeAction = GetFileSearchData(projectDirectoryUnescaped, excludeSpec,
-                        out excludeStripProjectDirectory, out excludeState);
+                        out _, out RecursionState excludeState);
 
                     if (excludeAction == SearchAction.ReturnFileSpec)
                     {
@@ -2370,7 +2430,8 @@ private string[] GetFilesImplementation(
                                 //  BaseDirectory to be the same as the exclude BaseDirectory, and change the wildcard part to be "**\"
                                 //  because we don't know where the different parts of the exclude wildcard part would be matched.
                                 //  Example: include="c:\git\msbuild\src\Framework\**\*.*" exclude="c:\git\msbuild\**\bin\**\*.*"
-                                Debug.Assert(excludeState.SearchData.RegexFileMatch != null, "Expected Regex to be used for exclude file matching");
+                                Debug.Assert(excludeState.SearchData.RegexFileMatch != null || excludeState.SearchData.DirectoryPattern != null,
+                                    "Expected Regex or directory pattern to be used for exclude file matching");
                                 excludeState.BaseDirectory = state.BaseDirectory;
                                 excludeState.RemainingWildcardDirectory = recursiveDirectoryMatch + s_directorySeparator;
                                 searchesToExclude.Add(excludeState);
@@ -2379,7 +2440,25 @@ private string[] GetFilesImplementation(
                     }
                     else
                     {
-                        searchesToExclude.Add(excludeState);
+                        // Optimization: ignore excludes whose file names can never match our filespec. For example, if we're looking
+                        // for "**/*.cs", we don't have to worry about excluding "{anything}/*.sln" as the intersection of the two will
+                        // always be empty.
+                        string includeFilespec = state.SearchData.Filespec ?? string.Empty;
+                        string excludeFilespec = excludeState.SearchData.Filespec ?? string.Empty;
+                        int compareLength = Math.Min(
+                            includeFilespec.Length - includeFilespec.LastIndexOfAny(s_wildcardCharacters) - 1,
+                            excludeFilespec.Length - excludeFilespec.LastIndexOfAny(s_wildcardCharacters) - 1);
+                        if (string.Compare(
+                                includeFilespec,
+                                includeFilespec.Length - compareLength,
+                                excludeFilespec,
+                                excludeFilespec.Length - compareLength,
+                                compareLength,
+                                StringComparison.OrdinalIgnoreCase) == 0)
+                        {
+                            // The suffix is the same so there is a possibility that the two will match the same files.
+                            searchesToExclude.Add(excludeState);
+                        }
                     }
                 }
             }
@@ -2455,7 +2534,6 @@ private static bool IsSubdirectoryOf(string possibleChild, string possibleParent
             }
 
             bool prefixMatch = possibleChild.StartsWith(possibleParent, StringComparison.OrdinalIgnoreCase);
-
             if (!prefixMatch)
             {
                 return false;
@@ -2473,6 +2551,19 @@ private static bool IsSubdirectoryOf(string possibleChild, string possibleParent
             }
         }
 
-        private static bool IsRecursiveDirectoryMatch(string path) => path.TrimTrailingSlashes() == recursiveDirectoryMatch;
+        /// <summary>
+        /// Returns true if the last component of the given directory path (assumed to not have any trailing slashes)
+        /// matches the given pattern.
+        /// </summary>
+        /// <param name="directoryPath">The path to test.</param>
+        /// <param name="pattern">The pattern to test against.</param>
+        /// <returns>True in case of a match (e.g. directoryPath = "dir/subdir" and pattern = "s*"), false otherwise.</returns>
+        private static bool DirectoryEndsWithPattern(string directoryPath, string pattern)
+        {
+            int index = directoryPath.LastIndexOfAny(FileUtilities.Slashes);
+            return (index != -1 && IsMatch(directoryPath.Substring(index + 1), pattern));
+        }
+
+        internal static bool IsRecursiveDirectoryMatch(string path) => path.TrimTrailingSlashes() == recursiveDirectoryMatch;
     }
 }
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index f35269ebf38..707657933d1 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -481,6 +481,38 @@ internal static string MaybeAdjustFilePath(string value, string baseDirectory =
             return shouldAdjust ? newValue.ToString() : value;
         }
 
+        /// <summary>
+        /// If on Unix, convert backslashes to slashes for strings that resemble paths.
+        /// This overload takes and returns ReadOnlyMemory of characters.
+        /// </summary>
+        internal static ReadOnlyMemory<char> MaybeAdjustFilePath(ReadOnlyMemory<char> value, string baseDirectory = "")
+        {
+            if (NativeMethodsShared.IsWindows || value.IsEmpty)
+            {
+                return value;
+            }
+
+            // Don't bother with arrays or properties or network paths.
+            if (value.Length >= 2)
+            {
+                var span = value.Span;
+
+                // The condition is equivalent to span.StartsWith("$(") || span.StartsWith("@(") || span.StartsWith("\\\\")
+                if ((span[1] == '(' && (span[0] == '$' || span[0] == '@')) ||
+                    (span[1] == '\\' && span[0] == '\\'))
+                {
+                    return value;
+                }
+            }
+
+            // For Unix-like systems, we may want to convert backslashes to slashes
+            Span<char> newValue = ConvertToUnixSlashes(value.ToArray());
+
+            // Find the part of the name we want to check, that is remove quotes, if present
+            bool shouldAdjust = newValue.IndexOf('/') != -1 && LooksLikeUnixFilePath(RemoveQuotes(newValue), baseDirectory);
+            return shouldAdjust ? newValue.ToString().AsMemory() : value;
+        }
+
         private static Span<char> ConvertToUnixSlashes(Span<char> path)
         {
             return path.IndexOf('\\') == -1 ? path : CollapseSlashes(path);
@@ -999,27 +1031,55 @@ internal static string MakeRelative(string basePath, string path)
             ErrorUtilities.VerifyThrowArgumentNull(basePath, nameof(basePath));
             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
 
-            if (basePath.Length == 0)
-            {
-                return path;
-            }
+            string fullBase = Path.GetFullPath(basePath);
+            string fullPath = Path.GetFullPath(path);
 
-            Uri baseUri = new Uri(EnsureTrailingSlash(basePath), UriKind.Absolute); // May throw UriFormatException
+            string[] splitBase = fullBase.Split(MSBuildConstants.DirectorySeparatorChar, StringSplitOptions.RemoveEmptyEntries);
+            string[] splitPath = fullPath.Split(MSBuildConstants.DirectorySeparatorChar, StringSplitOptions.RemoveEmptyEntries);
 
-            Uri pathUri = CreateUriFromPath(path);
+            ErrorUtilities.VerifyThrow(splitPath.Length > 0, "Cannot call MakeRelative on a path of only slashes.");
+
+            // On a mac, the path could start with any number of slashes and still be valid. We have to check them all.
+            int indexOfFirstNonSlashChar = 0;
+            while (path[indexOfFirstNonSlashChar] == Path.DirectorySeparatorChar)
+            {
+                indexOfFirstNonSlashChar++;
+            }
+            if (path.IndexOf(splitPath[0]) != indexOfFirstNonSlashChar)
+            {
+                // path was already relative so just return it
+                return FixFilePath(path);
+            }
 
-            if (!pathUri.IsAbsoluteUri)
+            int index = 0;
+            while (index < splitBase.Length && index < splitPath.Length && splitBase[index].Equals(splitPath[index], PathComparison))
             {
-                // the path is already a relative url, we will just normalize it...
-                pathUri = new Uri(baseUri, pathUri);
+                index++;
             }
 
-            Uri relativeUri = baseUri.MakeRelativeUri(pathUri);
-            string relativePath = Uri.UnescapeDataString(relativeUri.IsAbsoluteUri ? relativeUri.LocalPath : relativeUri.ToString());
+            if (index == splitBase.Length && index == splitPath.Length)
+            {
+                return ".";
+            }
+            
+            // If the paths have no component in common, the only valid relative path is the full path.
+            if (index == 0)
+            {
+                return fullPath;
+            }
 
-            string result = relativePath.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
+            StringBuilder sb = StringBuilderCache.Acquire();
 
-            return result;
+            for (int i = index; i < splitBase.Length; i++)
+            {
+                sb.Append("..").Append(Path.DirectorySeparatorChar);
+            }
+            for (int i = index; i < splitPath.Length; i++)
+            {
+                sb.Append(splitPath[i]).Append(Path.DirectorySeparatorChar);
+            }
+            sb.Length--;
+            return StringBuilderCache.GetStringAndRelease(sb);
         }
 
         /// <summary>
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index bacbc95e936..006e0587bf1 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -4,17 +4,11 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-#if FEATURE_SYSTEM_CONFIGURATION
-using System.Configuration;
-#endif
 using System.IO;
 using System.Linq;
 using System.Runtime.Versioning;
 using Microsoft.Win32;
 
-#if FEATURE_SYSTEM_CONFIGURATION
-using PropertyElement = Microsoft.Build.Evaluation.ToolsetElement.PropertyElement;
-#endif
 using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
@@ -1074,14 +1068,14 @@ private static string FindRegistryValueUnderKey
 
         private static VisualStudioSpec GetVisualStudioSpec(Version version)
         {
-            ErrorUtilities.VerifyThrowArgument(s_visualStudioSpecDict.ContainsKey(version), "FrameworkLocationHelper.UnsupportedVisualStudioVersion", version);
-            return s_visualStudioSpecDict[version];
+            ErrorUtilities.VerifyThrowArgument(s_visualStudioSpecDict.TryGetValue(version, out VisualStudioSpec spec), "FrameworkLocationHelper.UnsupportedVisualStudioVersion", version);
+            return spec;
         }
 
         private static DotNetFrameworkSpec GetDotNetFrameworkSpec(Version version)
         {
-            ErrorUtilities.VerifyThrowArgument(s_dotNetFrameworkSpecDict.ContainsKey(version), "FrameworkLocationHelper.UnsupportedFrameworkVersion", version);
-            return s_dotNetFrameworkSpecDict[version];
+            ErrorUtilities.VerifyThrowArgument(s_dotNetFrameworkSpecDict.TryGetValue(version, out DotNetFrameworkSpec spec), "FrameworkLocationHelper.UnsupportedFrameworkVersion", version);
+            return spec;
         }
 
         /// <summary>
diff --git a/src/Shared/INodePacket.cs b/src/Shared/INodePacket.cs
index 7ae2da0fc2e..501402c8756 100644
--- a/src/Shared/INodePacket.cs
+++ b/src/Shared/INodePacket.cs
@@ -174,9 +174,19 @@ internal enum NodePacketType : byte
         ResolveSdkRequest,
 
         /// <summary>
-        /// Message sent from back to a node when an SDK has been resolved.
+        /// Message sent back to a node when an SDK has been resolved.
         /// </summary>
         ResolveSdkResponse,
+
+        /// <summary>
+        /// Message sent from a node when a task is requesting or returning resources from the scheduler.
+        /// </summary>
+        ResourceRequest,
+
+        /// <summary>
+        /// Message sent back to a node informing it about the resource that were granted by the scheduler.
+        /// </summary>
+        ResourceResponse,
     }
     #endregion
 
diff --git a/src/Shared/ITranslator.cs b/src/Shared/ITranslator.cs
index 6fec218805e..b1acb85ec2f 100644
--- a/src/Shared/ITranslator.cs
+++ b/src/Shared/ITranslator.cs
@@ -180,6 +180,16 @@ BinaryWriter Writer
         /// <param name="collectionFactory">factory to create a collection</param>
         void Translate<T, L>(ref IList<T> list, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<L> collectionFactory) where L : IList<T>;
 
+        /// <summary>
+        /// Translates a collection of T into the specified type using an <see cref="ObjectTranslator{T}"/> and <see cref="NodePacketCollectionCreator{L}"/>
+        /// </summary>
+        /// <param name="collection">The collection to be translated.</param>
+        /// <param name="objectTranslator">The translator to use for the values in the collection.</param>
+        /// <param name="collectionFactory">The factory to create the ICollection.</param>
+        /// <typeparam name="T">The type contained in the collection.</typeparam>
+        /// <typeparam name="L">The type of collection to be created.</typeparam>
+        void Translate<T, L>(ref ICollection<T> collection, ObjectTranslator<T> objectTranslator, NodePacketCollectionCreator<L> collectionFactory) where L : ICollection<T>;
+
         /// <summary>
         /// Translates a DateTime.
         /// </summary>
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 497be9de813..449f54c4dd2 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -2,12 +2,21 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
 using System.IO;
 using System.Reflection;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Framework;
+
+#if !TASKHOST
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework.Profiler;
+using Microsoft.Build.Execution;
+#endif
+
 #if FEATURE_APPDOMAIN
 using TaskEngineAssemblyResolver = Microsoft.Build.BackEnd.Logging.TaskEngineAssemblyResolver;
 #endif
@@ -89,7 +98,22 @@ internal enum LoggingEventType : int
         /// <summary>
         /// Event is a TaskCommandLineEventArgs
         /// </summary>
-        TaskCommandLineEvent = 12
+        TaskCommandLineEvent = 12,
+
+        /// <summary>
+        /// Event is a TaskParameterEventArgs
+        /// </summary>
+        TaskParameterEvent = 13,
+
+        /// <summary>
+        /// Event is a ProjectEvaluationStartedEventArgs
+        /// </summary>
+        ProjectEvaluationStartedEvent = 14,
+
+        /// <summary>
+        /// Event is a ProjectEvaluationFinishedEventArgs
+        /// </summary>
+        ProjectEvaluationFinishedEvent = 15
     }
     #endregion
 
@@ -291,6 +315,17 @@ internal void WriteToStream(ITranslator translator)
                 translator.Translate(ref packetVersion);
 
                 bool eventCanSerializeItself = methodInfo != null;
+
+#if !TASKHOST && !MSBUILDENTRYPOINTEXE
+                if (_buildEvent is ProjectEvaluationStartedEventArgs ||
+                    _buildEvent is ProjectEvaluationFinishedEventArgs)
+                {
+                    // switch to serialization methods that we provide in this file
+                    // and don't use the WriteToStream inherited from LazyFormattedBuildEventArgs
+                    eventCanSerializeItself = false;
+                }
+#endif
+
                 translator.Translate(ref eventCanSerializeItself);
 
                 if (eventCanSerializeItself)
@@ -459,36 +494,27 @@ private static Delegate CreateDelegateRobust(Type type, Object firstArgument, Me
         /// </summary>
         private BuildEventArgs GetBuildEventArgFromId()
         {
-            switch (_eventType)
+            return _eventType switch
             {
-                case LoggingEventType.BuildErrorEvent:
-                    return new BuildErrorEventArgs(null, null, null, -1, -1, -1, -1, null, null, null);
-                case LoggingEventType.BuildFinishedEvent:
-                    return new BuildFinishedEventArgs(null, null, false);
-                case LoggingEventType.BuildMessageEvent:
-                    return new BuildMessageEventArgs(null, null, null, MessageImportance.Normal);
-                case LoggingEventType.BuildStartedEvent:
-                    return new BuildStartedEventArgs(null, null);
-                case LoggingEventType.BuildWarningEvent:
-                    return new BuildWarningEventArgs(null, null, null, -1, -1, -1, -1, null, null, null);
-                case LoggingEventType.ProjectFinishedEvent:
-                    return new ProjectFinishedEventArgs(null, null, null, false);
-                case LoggingEventType.ProjectStartedEvent:
-                    return new ProjectStartedEventArgs(null, null, null, null, null, null);
-                case LoggingEventType.TargetStartedEvent:
-                    return new TargetStartedEventArgs(null, null, null, null, null);
-                case LoggingEventType.TargetFinishedEvent:
-                    return new TargetFinishedEventArgs(null, null, null, null, null, false);
-                case LoggingEventType.TaskStartedEvent:
-                    return new TaskStartedEventArgs(null, null, null, null, null);
-                case LoggingEventType.TaskFinishedEvent:
-                    return new TaskFinishedEventArgs(null, null, null, null, null, false);
-                case LoggingEventType.TaskCommandLineEvent:
-                    return new TaskCommandLineEventArgs(null, null, MessageImportance.Normal);
-                default:
-                    ErrorUtilities.VerifyThrow(false, "Should not get to the default of GetBuildEventArgFromId ID: " + _eventType);
-                    return null;
-            }
+                LoggingEventType.BuildErrorEvent => new BuildErrorEventArgs(null, null, null, -1, -1, -1, -1, null, null, null),
+                LoggingEventType.BuildFinishedEvent => new BuildFinishedEventArgs(null, null, false),
+                LoggingEventType.BuildMessageEvent => new BuildMessageEventArgs(null, null, null, MessageImportance.Normal),
+                LoggingEventType.BuildStartedEvent => new BuildStartedEventArgs(null, null),
+                LoggingEventType.BuildWarningEvent => new BuildWarningEventArgs(null, null, null, -1, -1, -1, -1, null, null, null),
+                LoggingEventType.ProjectFinishedEvent => new ProjectFinishedEventArgs(null, null, null, false),
+                LoggingEventType.ProjectStartedEvent => new ProjectStartedEventArgs(null, null, null, null, null, null),
+                LoggingEventType.TargetStartedEvent => new TargetStartedEventArgs(null, null, null, null, null),
+                LoggingEventType.TargetFinishedEvent => new TargetFinishedEventArgs(null, null, null, null, null, false),
+                LoggingEventType.TaskStartedEvent => new TaskStartedEventArgs(null, null, null, null, null),
+                LoggingEventType.TaskFinishedEvent => new TaskFinishedEventArgs(null, null, null, null, null, false),
+                LoggingEventType.TaskCommandLineEvent => new TaskCommandLineEventArgs(null, null, MessageImportance.Normal),
+#if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
+                LoggingEventType.TaskParameterEvent => new TaskParameterEventArgs(0, null, null, true, default),
+                LoggingEventType.ProjectEvaluationStartedEvent => new ProjectEvaluationStartedEventArgs(),
+                LoggingEventType.ProjectEvaluationFinishedEvent => new ProjectEvaluationFinishedEventArgs(),
+#endif
+                _ => throw new InternalErrorException("Should not get to the default of GetBuildEventArgFromId ID: " + _eventType)
+            };
         }
 
         /// <summary>
@@ -509,6 +535,12 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.TaskCommandLineEvent;
             }
+#if !TASKHOST
+            else if (eventType == typeof(TaskParameterEventArgs))
+            {
+                return LoggingEventType.TaskParameterEvent;
+            }
+#endif
             else if (eventType == typeof(ProjectFinishedEventArgs))
             {
                 return LoggingEventType.ProjectFinishedEvent;
@@ -517,6 +549,16 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.ProjectStartedEvent;
             }
+#if !TASKHOST
+            else if (eventType == typeof(ProjectEvaluationFinishedEventArgs))
+            {
+                return LoggingEventType.ProjectEvaluationFinishedEvent;
+            }
+            else if (eventType == typeof(ProjectEvaluationStartedEventArgs))
+            {
+                return LoggingEventType.ProjectEvaluationStartedEvent;
+            }
+#endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
                 return LoggingEventType.TargetStartedEvent;
@@ -561,6 +603,19 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
         /// </summary>
         private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType eventType, ITranslator translator)
         {
+#if !TASKHOST && !MSBUILDENTRYPOINTEXE
+            if (eventType == LoggingEventType.ProjectEvaluationStartedEvent)
+            {
+                WriteProjectEvaluationStartedEventToStream((ProjectEvaluationStartedEventArgs)buildEvent, translator);
+                return;
+            }
+            else if (eventType == LoggingEventType.ProjectEvaluationFinishedEvent)
+            {
+                WriteProjectEvaluationFinishedEventToStream((ProjectEvaluationFinishedEventArgs)buildEvent, translator);
+                return;
+            }
+#endif
+
             string message = buildEvent.Message;
             string helpKeyword = buildEvent.HelpKeyword;
             string senderName = buildEvent.SenderName;
@@ -700,6 +755,207 @@ private void WriteBuildMessageEventToStream(BuildMessageEventArgs buildMessageEv
             translator.TranslateEnum(ref importance, (int)importance);
         }
 
+#if !TASKHOST && !MSBUILDENTRYPOINTEXE
+        private void WriteProjectEvaluationStartedEventToStream(ProjectEvaluationStartedEventArgs args, ITranslator translator)
+        {
+            WriteEvaluationEvent(args, args.ProjectFile, args.RawTimestamp, translator);
+        }
+
+        private void WriteProjectEvaluationFinishedEventToStream(ProjectEvaluationFinishedEventArgs args, ITranslator translator)
+        {
+            WriteEvaluationEvent(args, args.ProjectFile, args.RawTimestamp, translator);
+
+            WriteProperties(args.GlobalProperties, translator);
+            WriteProperties(args.Properties, translator);
+            WriteItems(args.Items, translator);
+            WriteProfileResult(args.ProfilerResult, translator);
+        }
+
+        private static void WriteEvaluationEvent(BuildStatusEventArgs args, string projectFile, DateTime timestamp, ITranslator translator)
+        {
+            var buildEventContext = args.BuildEventContext;
+            translator.Translate(ref buildEventContext);
+            translator.Translate(ref timestamp);
+            translator.Translate(ref projectFile);
+        }
+
+        private void WriteProfileResult(ProfilerResult? result, ITranslator translator)
+        {
+            bool hasValue = result.HasValue;
+            translator.Translate(ref hasValue);
+            if (hasValue)
+            {
+                var value = result.Value;
+                var count = value.ProfiledLocations.Count;
+                translator.Translate(ref count);
+
+                foreach (var item in value.ProfiledLocations)
+                {
+                    WriteEvaluationLocation(translator, item.Key);
+                    WriteProfiledLocation(translator, item.Value);
+                }
+            }
+        }
+
+        private void WriteEvaluationLocation(ITranslator translator, EvaluationLocation evaluationLocation)
+        {
+            string elementName = evaluationLocation.ElementName;
+            string elementDescription = evaluationLocation.ElementDescription;
+            string evaluationPassDescription = evaluationLocation.EvaluationPassDescription;
+            string file = evaluationLocation.File;
+            int kind = (int)evaluationLocation.Kind;
+            int evaluationPass = (int)evaluationLocation.EvaluationPass;
+            bool lineHasValue = evaluationLocation.Line.HasValue;
+            int line = lineHasValue ? evaluationLocation.Line.Value : 0;
+            long id = evaluationLocation.Id;
+            bool parentIdHasValue = evaluationLocation.ParentId.HasValue;
+            long parentId = parentIdHasValue ? evaluationLocation.ParentId.Value : 0;
+
+            translator.Translate(ref elementName);
+            translator.Translate(ref elementDescription);
+            translator.Translate(ref evaluationPassDescription);
+            translator.Translate(ref file);
+
+            translator.Translate(ref kind);
+            translator.Translate(ref evaluationPass);
+
+            translator.Translate(ref lineHasValue);
+            if (lineHasValue)
+            {
+                translator.Translate(ref line);
+            }
+
+            translator.Translate(ref id);
+            translator.Translate(ref parentIdHasValue);
+            if (parentIdHasValue)
+            {
+                translator.Translate(ref parentId);
+            }
+        }
+
+        private void WriteProfiledLocation(ITranslator translator, ProfiledLocation profiledLocation)
+        {
+            int numberOfHits = profiledLocation.NumberOfHits;
+            TimeSpan exclusiveTime = profiledLocation.ExclusiveTime;
+            TimeSpan inclusiveTime = profiledLocation.InclusiveTime;
+            translator.Translate(ref numberOfHits);
+            translator.Translate(ref exclusiveTime);
+            translator.Translate(ref inclusiveTime);
+        }
+
+        [ThreadStatic]
+        private static List<KeyValuePair<string, string>> reusablePropertyList;
+
+        [ThreadStatic]
+        private static List<(string itemType, object item)> reusableItemList;
+
+        private void WriteProperties(IEnumerable properties, ITranslator translator)
+        {
+            var writer = translator.Writer;
+            if (properties == null)
+            {
+                writer.Write((byte)0);
+                return;
+            }
+
+            if (reusablePropertyList == null)
+            {
+                reusablePropertyList = new List<KeyValuePair<string, string>>();
+            }
+
+            // it is expensive to access a ThreadStatic field every time
+            var list = reusablePropertyList;
+
+            Internal.Utilities.EnumerateProperties(properties, kvp => list.Add(kvp));
+
+            BinaryWriterExtensions.Write7BitEncodedInt(writer, list.Count);
+
+            foreach (var item in list)
+            {
+                writer.Write(item.Key);
+                writer.Write(item.Value);
+            }
+
+            list.Clear();
+        }
+
+        private void WriteItems(IEnumerable items, ITranslator translator)
+        {
+            var writer = translator.Writer;
+            if (items == null)
+            {
+                writer.Write((byte)0);
+                return;
+            }
+
+            if (reusableItemList == null)
+            {
+                reusableItemList = new List<(string itemType, object item)>();
+            }
+
+            var list = reusableItemList;
+
+            Internal.Utilities.EnumerateItems(items, dictionaryEntry =>
+            {
+                list.Add((dictionaryEntry.Key as string, dictionaryEntry.Value));
+            });
+
+            BinaryWriterExtensions.Write7BitEncodedInt(writer, list.Count);
+
+            foreach (var kvp in list)
+            {
+                writer.Write(kvp.itemType);
+                if (kvp.item is ITaskItem taskItem)
+                {
+                    writer.Write(taskItem.ItemSpec);
+                    WriteMetadata(taskItem, writer);
+                }
+                else
+                {
+                    writer.Write(kvp.item?.ToString() ?? "");
+                    writer.Write((byte)0);
+                }
+            }
+
+            list.Clear();
+        }
+
+        private void WriteMetadata(object metadataContainer, BinaryWriter writer)
+        {
+            if (metadataContainer is ITaskItem taskItem)
+            {
+                var metadata = taskItem.EnumerateMetadata();
+
+                if (reusablePropertyList == null)
+                {
+                    reusablePropertyList = new List<KeyValuePair<string, string>>();
+                }
+
+                // it is expensive to access a ThreadStatic field every time
+                var list = reusablePropertyList;
+
+                foreach (var item in metadata)
+                {
+                    list.Add(item);
+                }
+
+                BinaryWriterExtensions.Write7BitEncodedInt(writer, list.Count);
+                foreach (var kvp in list)
+                {
+                    writer.Write(kvp.Key ?? string.Empty);
+                    writer.Write(kvp.Value ?? string.Empty);
+                }
+
+                list.Clear();
+            }
+            else
+            {
+                writer.Write((byte)0);
+            }
+        }
+
+#endif
+
         #endregion
 
         #region Reads from Stream
@@ -710,6 +966,17 @@ private void WriteBuildMessageEventToStream(BuildMessageEventArgs buildMessageEv
         /// </summary>
         private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslator translator)
         {
+#if !TASKHOST && !MSBUILDENTRYPOINTEXE
+            if (eventType == LoggingEventType.ProjectEvaluationStartedEvent)
+            {
+                return ReadProjectEvaluationStartedEventFromStream(translator);
+            }
+            else if (eventType == LoggingEventType.ProjectEvaluationFinishedEvent)
+            {
+                return ReadProjectEvaluationFinishedEventFromStream(translator);
+            }
+#endif
+
             string message = null;
             string helpKeyword = null;
             string senderName = null;
@@ -906,6 +1173,213 @@ private BuildMessageEventArgs ReadBuildMessageEventFromStream(ITranslator transl
             return buildEvent;
         }
 
+#if !TASKHOST && !MSBUILDENTRYPOINTEXE
+        private ProjectEvaluationStartedEventArgs ReadProjectEvaluationStartedEventFromStream(ITranslator translator)
+        {
+            var (buildEventContext, timestamp, projectFile) = ReadEvaluationEvent(translator);
+
+            var args = new ProjectEvaluationStartedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationStarted"), projectFile);
+
+            args.BuildEventContext = buildEventContext;
+            args.RawTimestamp = timestamp;
+            args.ProjectFile = projectFile;
+
+            return args;
+        }
+
+        private ProjectEvaluationFinishedEventArgs ReadProjectEvaluationFinishedEventFromStream(ITranslator translator)
+        {
+            var (buildEventContext, timestamp, projectFile) = ReadEvaluationEvent(translator);
+
+            var args = new ProjectEvaluationFinishedEventArgs(
+                ResourceUtilities.GetResourceString("EvaluationFinished"), projectFile);
+
+            args.BuildEventContext = buildEventContext;
+            args.RawTimestamp = timestamp;
+            args.ProjectFile = projectFile;
+
+            args.GlobalProperties = ReadProperties(translator);
+            args.Properties = ReadProperties(translator);
+            args.Items = ReadItems(translator);
+            args.ProfilerResult = ReadProfileResult(translator);
+
+            return args;
+        }
+
+        private (BuildEventContext buildEventContext, DateTime timestamp, string projectFile)
+            ReadEvaluationEvent(ITranslator translator)
+        {
+            BuildEventContext buildEventContext = null;
+            translator.Translate(ref buildEventContext);
+
+            DateTime timestamp = default;
+            translator.Translate(ref timestamp);
+
+            string projectFile = null;
+            translator.Translate(ref projectFile);
+
+            return (buildEventContext, timestamp, projectFile);
+        }
+
+        private IEnumerable ReadProperties(ITranslator translator)
+        {
+            var reader = translator.Reader;
+            int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
+            if (count == 0)
+            {
+                return Array.Empty<DictionaryEntry>();
+            }
+
+            var list = new ArrayList(count);
+            for (int i = 0; i < count; i++)
+            {
+                string key = reader.ReadString();
+                string value = reader.ReadString();
+                var entry = new DictionaryEntry(key, value);
+                list.Add(entry);
+            }
+
+            return list;
+        }
+
+        private IEnumerable ReadItems(ITranslator translator)
+        {
+            var reader = translator.Reader;
+
+            int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
+            if (count == 0)
+            {
+                return Array.Empty<DictionaryEntry>();
+            }
+
+            var list = new ArrayList(count);
+            for (int i = 0; i < count; i++)
+            {
+                string itemType = reader.ReadString();
+                string evaluatedValue = reader.ReadString();
+                var metadata = ReadMetadata(reader);
+                var taskItemData = new TaskItemData(evaluatedValue, metadata);
+                var entry = new DictionaryEntry(itemType, taskItemData);
+                list.Add(entry);
+            }
+
+            return list;
+        }
+
+        private IDictionary<string, string> ReadMetadata(BinaryReader reader)
+        {
+            int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
+            if (count == 0)
+            {
+                return null;
+            }
+
+            var list = ArrayDictionary<string, string>.Create(count);
+            for (int i = 0; i < count; i++)
+            {
+                string key = reader.ReadString();
+                string value = reader.ReadString();
+                list.Add(key, value);
+            }
+
+            return list;
+        }
+
+        private ProfilerResult? ReadProfileResult(ITranslator translator)
+        {
+            bool hasValue = false;
+            translator.Translate(ref hasValue);
+            if (!hasValue)
+            {
+                return null;
+            }
+
+            int count = 0;
+            translator.Translate(ref count);
+
+            var dictionary = new ArrayDictionary<EvaluationLocation, ProfiledLocation>(count);
+
+            for (int i = 0; i < count; i++)
+            {
+                var evaluationLocation = ReadEvaluationLocation(translator);
+                var profiledLocation = ReadProfiledLocation(translator);
+                dictionary.Add(evaluationLocation, profiledLocation);
+            }
+
+            var result = new ProfilerResult(dictionary);
+            return result;
+        }
+
+        private EvaluationLocation ReadEvaluationLocation(ITranslator translator)
+        {
+            string elementName = default;
+            string elementDescription = default;
+            string evaluationPassDescription = default;
+            string file = default;
+            int kind = default;
+            int evaluationPass = default;
+            bool lineHasValue = default;
+            int line = default;
+            long id = default;
+            bool parentIdHasValue = default;
+            long parentId = default;
+
+            translator.Translate(ref elementName);
+            translator.Translate(ref elementDescription);
+            translator.Translate(ref evaluationPassDescription);
+            translator.Translate(ref file);
+
+            translator.Translate(ref kind);
+            translator.Translate(ref evaluationPass);
+
+            translator.Translate(ref lineHasValue);
+            if (lineHasValue)
+            {
+                translator.Translate(ref line);
+            }
+
+            translator.Translate(ref id);
+            translator.Translate(ref parentIdHasValue);
+            if (parentIdHasValue)
+            {
+                translator.Translate(ref parentId);
+            }
+
+            var evaluationLocation = new EvaluationLocation(
+                id,
+                parentIdHasValue ? parentId : null,
+                (EvaluationPass)evaluationPass,
+                evaluationPassDescription,
+                file,
+                lineHasValue ? line : null,
+                elementName,
+                elementDescription,
+                (EvaluationLocationKind)kind);
+
+            return evaluationLocation;
+        }
+
+        private ProfiledLocation ReadProfiledLocation(ITranslator translator)
+        {
+            int numberOfHits = default;
+            TimeSpan exclusiveTime = default;
+            TimeSpan inclusiveTime = default;
+
+            translator.Translate(ref numberOfHits);
+            translator.Translate(ref exclusiveTime);
+            translator.Translate(ref inclusiveTime);
+
+            var profiledLocation = new ProfiledLocation(
+                inclusiveTime,
+                exclusiveTime,
+                numberOfHits);
+
+            return profiledLocation;
+        }
+
+#endif
+
         #endregion
 
         #endregion
diff --git a/src/Shared/MSBuildNameIgnoreCaseComparer.cs b/src/Shared/MSBuildNameIgnoreCaseComparer.cs
index e5f0f0ad199..d0930cc0e19 100644
--- a/src/Shared/MSBuildNameIgnoreCaseComparer.cs
+++ b/src/Shared/MSBuildNameIgnoreCaseComparer.cs
@@ -149,7 +149,14 @@ public int GetHashCode(string obj, int start, int length)
                             // the string, and not the null terminator etc.
                             if (length == 1)
                             {
-                                val &= 0xFFFF;
+                                if (BitConverter.IsLittleEndian)
+                                {
+                                    val &= 0xFFFF;
+                                }
+                                else
+                                {
+                                    val &= unchecked((int)0xFFFF0000);
+                                }
                             }
 
                             hash1 = ((hash1 << 5) + hash1 + (hash1 >> 27)) ^ val;
@@ -162,7 +169,14 @@ public int GetHashCode(string obj, int start, int length)
                             val = pint[1] & 0x00DF00DF;
                             if (length == 3)
                             {
-                                val &= 0xFFFF;
+                                if (BitConverter.IsLittleEndian)
+                                {
+                                    val &= 0xFFFF;
+                                }
+                                else
+                                {
+                                    val &= unchecked((int)0xFFFF0000);
+                                }
                             }
 
                             hash2 = ((hash2 << 5) + hash2 + (hash2 >> 27)) ^ val;
diff --git a/src/Shared/NodePacketFactory.cs b/src/Shared/NodePacketFactory.cs
index 25d4851fc82..17b3e52c8f7 100644
--- a/src/Shared/NodePacketFactory.cs
+++ b/src/Shared/NodePacketFactory.cs
@@ -48,12 +48,11 @@ public void UnregisterPacketHandler(NodePacketType packetType)
         public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
         {
             // PERF: Not using VerifyThrow to avoid boxing of packetType in the non-error case
-            if (!_packetFactories.ContainsKey(packetType))
+            if (!_packetFactories.TryGetValue(packetType, out PacketFactoryRecord record))
             {
                 ErrorUtilities.ThrowInternalError("No packet handler for type {0}", packetType);
             }
 
-            PacketFactoryRecord record = _packetFactories[packetType];
             record.DeserializeAndRoutePacket(nodeId, translator);
         }
 
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index 45d007d25b3..1bcae1d7574 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -85,6 +85,10 @@ internal class TaskHostConfiguration : INodePacket
 
         private Dictionary<string, string> _globalParameters;
 
+        private ICollection<string> _warningsAsErrors;
+
+        private ICollection<string> _warningsAsMessages;
+
 #if FEATURE_APPDOMAIN
         /// <summary>
         /// Constructor
@@ -103,6 +107,8 @@ internal class TaskHostConfiguration : INodePacket
         /// <param name="taskLocation">Location of the assembly the task is to be loaded from.</param>
         /// <param name="taskParameters">Parameters to apply to the task.</param>
         /// <param name="globalParameters">global properties for the current project.</param>
+        /// <param name="warningsAsErrors">Warning codes to be treated as errors for the current project.</param>
+        /// <param name="warningsAsMessages">Warning codes to be treated as messages for the current project.</param>
 #else
         /// <summary>
         /// Constructor
@@ -120,6 +126,8 @@ internal class TaskHostConfiguration : INodePacket
         /// <param name="taskLocation">Location of the assembly the task is to be loaded from.</param>
         /// <param name="taskParameters">Parameters to apply to the task.</param>
         /// <param name="globalParameters">global properties for the current project.</param>
+        /// <param name="warningsAsErrors">Warning codes to be logged as errors for the current project.</param>
+        /// <param name="warningsAsMessages">Warning codes to be treated as messages for the current project.</param>
 #endif
         public TaskHostConfiguration
             (
@@ -138,7 +146,9 @@ public TaskHostConfiguration
                 string taskName,
                 string taskLocation,
                 IDictionary<string, object> taskParameters,
-                Dictionary<string, string> globalParameters
+                Dictionary<string, string> globalParameters,
+                ICollection<string> warningsAsErrors,
+                ICollection<string> warningsAsMessages
             )
         {
             ErrorUtilities.VerifyThrowInternalLength(taskName, nameof(taskName));
@@ -168,6 +178,8 @@ Dictionary<string, string> globalParameters
             _continueOnError = continueOnError;
             _taskName = taskName;
             _taskLocation = taskLocation;
+            _warningsAsErrors = warningsAsErrors;
+            _warningsAsMessages = warningsAsMessages;
 
             if (taskParameters != null)
             {
@@ -342,6 +354,24 @@ public NodePacketType Type
             { return NodePacketType.TaskHostConfiguration; }
         }
 
+        public ICollection<string> WarningsAsErrors
+        {
+            [DebuggerStepThrough]
+            get
+            {
+                return _warningsAsErrors;
+            }
+        }
+
+        public ICollection<string> WarningsAsMessages
+        {
+            [DebuggerStepThrough]
+            get
+            {
+                return _warningsAsMessages;
+            }
+        }
+
         /// <summary>
         /// Translates the packet to/from binary form.
         /// </summary>
@@ -364,6 +394,20 @@ public void Translate(ITranslator translator)
             translator.TranslateDictionary(ref _taskParameters, StringComparer.OrdinalIgnoreCase, TaskParameter.FactoryForDeserialization);
             translator.Translate(ref _continueOnError);
             translator.TranslateDictionary(ref _globalParameters, StringComparer.OrdinalIgnoreCase);
+            translator.Translate(collection: ref _warningsAsErrors,
+                                 objectTranslator: (ITranslator t, ref string s) => t.Translate(ref s),
+#if CLR2COMPATIBILITY
+                                 collectionFactory: count => new HashSet<string>(StringComparer.OrdinalIgnoreCase));
+#else
+                                 collectionFactory: count => new HashSet<string>(count, StringComparer.OrdinalIgnoreCase));
+#endif
+            translator.Translate(collection: ref _warningsAsMessages,
+                                 objectTranslator: (ITranslator t, ref string s) => t.Translate(ref s),
+#if CLR2COMPATIBILITY
+                                 collectionFactory: count => new HashSet<string>(StringComparer.OrdinalIgnoreCase));
+#else
+                                 collectionFactory: count => new HashSet<string>(count, StringComparer.OrdinalIgnoreCase));
+#endif
         }
 
         /// <summary>
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 7592c784fc0..a4f4a164193 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -1016,6 +1016,28 @@ params object[] messageArgs
             // that gives the user something.
             bool fillInLocation = (String.IsNullOrEmpty(file) && (lineNumber == 0) && (columnNumber == 0));
 
+            // This warning will be converted to an error if:
+            // 1. Its code exists within WarningsAsErrors
+            // 2. If WarningsAsErrors is a non-null empty set (treat all warnings as errors)
+            if (BuildEngine is IBuildEngine8 be8 && be8.ShouldTreatWarningAsError(warningCode))
+            {
+                LogError
+                (
+                    subcategory: subcategory,
+                    errorCode: warningCode,
+                    helpKeyword: helpKeyword,
+                    helpLink: helpLink,
+                    file: fillInLocation ? BuildEngine.ProjectFileOfTaskNode : file,
+                    lineNumber: fillInLocation ? BuildEngine.LineNumberOfTaskNode : lineNumber,
+                    columnNumber: fillInLocation ? BuildEngine.ColumnNumberOfTaskNode : columnNumber,
+                    endLineNumber: endLineNumber,
+                    endColumnNumber: endColumnNumber,
+                    message: message,
+                    messageArgs: messageArgs
+                );
+                return;
+            }
+
             var e = new BuildWarningEventArgs
                 (
                     subcategory,
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index ead8151a85b..17cc1269cca 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -1,14 +1,15 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Linq;
+using System.Reflection;
 using System.Security;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using System.Reflection;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -492,7 +493,11 @@ private class TaskParameterTaskItem :
 #if FEATURE_APPDOMAIN
             MarshalByRefObject,
 #endif
-            ITaskItem, ITaskItem2
+            ITaskItem,
+            ITaskItem2
+#if !TASKHOST
+            ,IMetadataContainer
+#endif
         {
             /// <summary>
             /// The item spec 
@@ -751,6 +756,20 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()
                 IDictionary clonedDictionary = new Dictionary<string, string>(_customEscapedMetadata);
                 return clonedDictionary;
             }
+
+            public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()
+            {
+                if (_customEscapedMetadata == null)
+                {
+                    yield break;
+                }
+
+                foreach (var kvp in _customEscapedMetadata)
+                {
+                    var unescaped = new KeyValuePair<string, string>(kvp.Key, EscapingUtilities.UnescapeAll(kvp.Value));
+                    yield return unescaped;
+                }
+            }
         }
     }
 }
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index 7453ed33cb3..feb3acb6a5c 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -3,17 +3,13 @@
 
 using System;
 using System.Collections.Generic;
-#if FEATURE_SYSTEM_CONFIGURATION
 using System.Configuration;
-#endif
 using System.IO;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Evaluation
 {
-#if FEATURE_SYSTEM_CONFIGURATION
-
     /// <summary>
     /// Helper class for reading toolsets out of the configuration file.
     /// </summary>
@@ -708,5 +704,4 @@ public string DefaultOverrideToolsVersion
             }
         }
     }
-#endif
 }
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index 7aa78f0bbeb..09cca604107 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -175,6 +175,32 @@ public bool LogTaskInputs
             }
         }
 
+        private bool? _logPropertiesAndItemsAfterEvaluation;
+        private bool _logPropertiesAndItemsAfterEvaluationInitialized = false;
+        public bool? LogPropertiesAndItemsAfterEvaluation
+        {
+            get
+            {
+                if (!_logPropertiesAndItemsAfterEvaluationInitialized)
+                {
+                    _logPropertiesAndItemsAfterEvaluationInitialized = true;
+                    var variable = Environment.GetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION");
+                    if (!string.IsNullOrEmpty(variable))
+                    {
+                        _logPropertiesAndItemsAfterEvaluation = variable == "1" || string.Equals(variable, "true", StringComparison.OrdinalIgnoreCase);
+                    }
+                }
+
+                return _logPropertiesAndItemsAfterEvaluation;
+            }
+
+            set
+            {
+                _logPropertiesAndItemsAfterEvaluationInitialized = true;
+                _logPropertiesAndItemsAfterEvaluation = value;
+            }
+        }
+
         /// <summary>
         /// Read information only once per file per ResolveAssemblyReference invocation.
         /// </summary>
diff --git a/src/Shared/UnitTests/EscapingUtilities_Tests.cs b/src/Shared/UnitTests/EscapingUtilities_Tests.cs
index 627de15dff6..b02c378e2eb 100644
--- a/src/Shared/UnitTests/EscapingUtilities_Tests.cs
+++ b/src/Shared/UnitTests/EscapingUtilities_Tests.cs
@@ -75,13 +75,18 @@ public void EscapeUnescape()
         public void ContainsEscapedWildcards()
         {
             Assert.False(EscapingUtilities.ContainsEscapedWildcards("NoStarOrQMark"));
+            Assert.False(EscapingUtilities.ContainsEscapedWildcards("%"));
+            Assert.False(EscapingUtilities.ContainsEscapedWildcards("%%"));
+            Assert.False(EscapingUtilities.ContainsEscapedWildcards("%2"));
             Assert.False(EscapingUtilities.ContainsEscapedWildcards("%4"));
-            Assert.False(EscapingUtilities.ContainsEscapedWildcards("%3B"));
+            Assert.False(EscapingUtilities.ContainsEscapedWildcards("%3A"));
             Assert.False(EscapingUtilities.ContainsEscapedWildcards("%2B"));
             Assert.True(EscapingUtilities.ContainsEscapedWildcards("%2a"));
             Assert.True(EscapingUtilities.ContainsEscapedWildcards("%2A"));
             Assert.True(EscapingUtilities.ContainsEscapedWildcards("%3F"));
             Assert.True(EscapingUtilities.ContainsEscapedWildcards("%3f"));
+            Assert.True(EscapingUtilities.ContainsEscapedWildcards("%%3f"));
+            Assert.True(EscapingUtilities.ContainsEscapedWildcards("%3%3f"));
         }
     }
 }
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index 418a51b91db..c3d200829e3 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -5,7 +5,7 @@
 using Shouldly;
 using System;
 using System.Collections.Generic;
-using System.Collections.Immutable;
+using System.Collections.Concurrent;
 using System.IO;
 using System.Linq;
 using System.Text.RegularExpressions;
@@ -78,9 +78,9 @@ public void GetFilesComplexGlobbingMatching(GetFilesComplexGlobbingMatchingInfo
                 File.WriteAllBytes(fullPath, new byte[1]);
             }
 
-            void Verify(string include, string[] excludes, bool shouldHaveNoMatches = false, string customMessage = null)
+            void VerifyImpl(FileMatcher fileMatcher, string include, string[] excludes, bool shouldHaveNoMatches = false, string customMessage = null)
             {
-                string[] matchedFiles = FileMatcher.Default.GetFiles(testFolder.Path, include, excludes?.ToList());
+                string[] matchedFiles = fileMatcher.GetFiles(testFolder.Path, include, excludes?.ToList());
 
                 if (shouldHaveNoMatches)
                 {
@@ -100,6 +100,18 @@ void Verify(string include, string[] excludes, bool shouldHaveNoMatches = false,
                 }
             }
 
+            var fileMatcherWithCache = new FileMatcher(FileSystems.Default, new ConcurrentDictionary<string, IReadOnlyList<string>>());
+
+            void Verify(string include, string[] excludes, bool shouldHaveNoMatches = false, string customMessage = null)
+            {
+                // Verify using the default non-caching FileMatcher.
+                VerifyImpl(FileMatcher.Default, include, excludes, shouldHaveNoMatches, customMessage);
+
+                // Verify using a caching FileMatcher and do it twice to exercise the cache.
+                VerifyImpl(fileMatcherWithCache, include, excludes, shouldHaveNoMatches, customMessage);
+                VerifyImpl(fileMatcherWithCache, include, excludes, shouldHaveNoMatches, customMessage);
+            }
+
             // Normal matching
             Verify(info.Include, info.Excludes);
 
@@ -154,7 +166,7 @@ public class GetFilesComplexGlobbingMatchingInfo
                 @"subdirectory\subdirectory.cs",
                 @"build\baz\foo.cs",
                 @"readme.txt",
-                @"licence.md"
+                @"licence"
             };
 
             /// <summary>
@@ -356,7 +368,7 @@ public static IEnumerable<object[]> GetTestData()
                         ExpectedMatches = new[]
                         {
                             @"readme.txt",
-                            @"licence.md"
+                            @"licence"
                         }
                     }
                 };
@@ -409,6 +421,44 @@ public static IEnumerable<object[]> GetTestData()
                         ExpectNoMatches = NativeMethodsShared.IsLinux,
                     }
                 };
+
+                // Hits the early elimination of exclude file patterns that do not intersect with the include.
+                // The exclude is redundant and can be eliminated before starting the file system walk.
+                yield return new object[]
+                {
+                    new GetFilesComplexGlobbingMatchingInfo
+                    {
+                        Include = @"src\foo\**\*.cs",
+                        Excludes = new[]
+                        {
+                            @"src\foo\**\foo\**",
+                            @"src\foo\**\*.vb" // redundant exclude
+                        },
+                        ExpectedMatches = new[]
+                        {
+                            @"src\foo\foo.cs",
+                            @"src\foo\inner\foo.cs",
+                            @"src\foo\inner\bar\bar.cs"
+                        },
+                        ExpectNoMatches = NativeMethodsShared.IsLinux,
+                    }
+                };
+
+                // Hits the early elimination of exclude file patterns that do not intersect with the include.
+                // The exclude is not redundant and must not be eliminated.
+                yield return new object[]
+                {
+                    new GetFilesComplexGlobbingMatchingInfo
+                    {
+                        Include = @"src\foo\**\*.cs",
+                        Excludes = new[]
+                        {
+                            @"src\foo\**\*.*" // effective exclude
+                        },
+                        ExpectedMatches = Array.Empty<string>(),
+                        ExpectNoMatches = NativeMethodsShared.IsLinux,
+                    }
+                };
             }
         }
 
@@ -486,10 +536,9 @@ public void WildcardMatching()
             {
                 try
                 {
-                    Assert.Equal(input.Item3, FileMatcher.IsMatch(input.Item1, input.Item2, false));
-                    Assert.Equal(input.Item3, FileMatcher.IsMatch(input.Item1, input.Item2, true));
-                    Assert.Equal(input.Item3, FileMatcher.IsMatch(input.Item1.ToUpperInvariant(), input.Item2, true));
-                    Assert.Equal(input.Item3, FileMatcher.IsMatch(input.Item1, input.Item2.ToUpperInvariant(), true));
+                    Assert.Equal(input.Item3, FileMatcher.IsMatch(input.Item1, input.Item2));
+                    Assert.Equal(input.Item3, FileMatcher.IsMatch(input.Item1.ToUpperInvariant(), input.Item2));
+                    Assert.Equal(input.Item3, FileMatcher.IsMatch(input.Item1, input.Item2.ToUpperInvariant()));
                 }
                 catch (Exception)
                 {
@@ -505,7 +554,7 @@ public void WildcardMatching()
          * Simulate Directories.GetFileSystemEntries where file names are short.
          *
          */
-        private static ImmutableArray<string> GetFileSystemEntries(FileMatcher.FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
+        private static IReadOnlyList<string> GetFileSystemEntries(FileMatcher.FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
         {
             if
             (
@@ -513,7 +562,7 @@ private static ImmutableArray<string> GetFileSystemEntries(FileMatcher.FileSyste
                 && (@"D:\" == path || @"\\server\share\" == path || path.Length == 0)
             )
             {
-                return ImmutableArray.Create(Path.Combine(path, "LongDirectoryName"));
+                return new string[] { Path.Combine(path, "LongDirectoryName") };
             }
             else if
             (
@@ -521,7 +570,7 @@ private static ImmutableArray<string> GetFileSystemEntries(FileMatcher.FileSyste
                 && (@"D:\LongDirectoryName" == path || @"\\server\share\LongDirectoryName" == path || @"LongDirectoryName" == path)
             )
             {
-                return ImmutableArray.Create(Path.Combine(path, "LongSubDirectory"));
+                return new string[] { Path.Combine(path, "LongSubDirectory") };
             }
             else if
             (
@@ -529,7 +578,7 @@ private static ImmutableArray<string> GetFileSystemEntries(FileMatcher.FileSyste
                 && (@"D:\LongDirectoryName\LongSubDirectory" == path || @"\\server\share\LongDirectoryName\LongSubDirectory" == path || @"LongDirectoryName\LongSubDirectory" == path)
             )
             {
-                return ImmutableArray.Create(Path.Combine(path, "LongFileName.txt"));
+                return new string[] { Path.Combine(path, "LongFileName.txt") };
             }
             else if
             (
@@ -537,7 +586,7 @@ private static ImmutableArray<string> GetFileSystemEntries(FileMatcher.FileSyste
                 && @"c:\apple\banana\tomato" == path
             )
             {
-                return ImmutableArray.Create(Path.Combine(path, "pomegranate"));
+                return new string[] { Path.Combine(path, "pomegranate") };
             }
             else if
             (
@@ -545,14 +594,14 @@ private static ImmutableArray<string> GetFileSystemEntries(FileMatcher.FileSyste
             )
             {
                 // No files exist here. This is an empty directory.
-                return ImmutableArray<string>.Empty;
+                return Array.Empty<string>();
             }
             else
             {
                 Console.WriteLine("GetFileSystemEntries('{0}', '{1}')", path, pattern);
                 Assert.True(false, "Unexpected input into GetFileSystemEntries");
             }
-            return ImmutableArray.Create("<undefined>");
+            return new string[] { "<undefined>" };
         }
 
         private static readonly char S = Path.DirectorySeparatorChar;
@@ -1588,7 +1637,7 @@ public void ExcludeComplexPattern(string include, string[] exclude, string[] mat
             "",
             "",
             "",
-            null,
+            "",
             false,
             false
         )]
@@ -1598,7 +1647,7 @@ public void ExcludeComplexPattern(string include, string[] exclude, string[] mat
             "",
             "",
             "",
-            null,
+            "",
             false,
             false
         )]
@@ -1839,10 +1888,13 @@ bool expectedIsLegalFileSpec
                 out string fixedDirectoryPart,
                 out string wildcardDirectoryPart,
                 out string filenamePart,
-                out string matchFileExpression,
                 out bool needsRecursion,
                 out bool isLegalFileSpec
             );
+            string matchFileExpression = isLegalFileSpec
+                ? FileMatcher.RegularExpressionFromFileSpec(fixedDirectoryPart, wildcardDirectoryPart, filenamePart)
+                : string.Empty;
+
             fixedDirectoryPart.ShouldBe(expectedFixedDirectoryPart);
             wildcardDirectoryPart.ShouldBe(expectedWildcardDirectoryPart);
             filenamePart.ShouldBe(expectedFilenamePart);
@@ -2081,7 +2133,7 @@ private void GetMatchingDirectories(string[] candidates, string path, string pat
             /// <param name="path">The path to search.</param>
             /// <param name="pattern">The pattern to search (may be null)</param>
             /// <returns>The matched files or folders.</returns>
-            internal ImmutableArray<string> GetAccessibleFileSystemEntries(FileMatcher.FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
+            internal IReadOnlyList<string> GetAccessibleFileSystemEntries(FileMatcher.FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
             {
                 string normalizedPath = Normalize(path);
 
@@ -2100,7 +2152,7 @@ internal ImmutableArray<string> GetAccessibleFileSystemEntries(FileMatcher.FileS
                     GetMatchingDirectories(_fileSet3, normalizedPath, pattern, files);
                 }
 
-                return files.ToImmutableArray();
+                return files.ToList();
             }
 
             /// <summary>
@@ -2353,9 +2405,9 @@ private static void MatchDriver(string filespec, string[] excludeFilespecs, stri
         /// <param name="path"></param>
         /// <param name="pattern"></param>
         /// <returns>Array of matching file system entries (can be empty).</returns>
-        private static ImmutableArray<string> GetFileSystemEntriesLoopBack(FileMatcher.FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
+        private static IReadOnlyList<string> GetFileSystemEntriesLoopBack(FileMatcher.FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)
         {
-            return ImmutableArray.Create(Path.Combine(path, pattern));
+            return new string[] { Path.Combine(path, pattern) };
         }
 
         /*************************************************************************************
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index 636c41df025..7080a2e7ccc 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -83,9 +83,6 @@ private static void TestGetItemSpecModifier(string currentDirectory)
         }
 
         [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
         public void MakeRelativeTests()
         {
             if (NativeMethodsShared.IsWindows)
@@ -97,20 +94,17 @@ public void MakeRelativeTests()
                 Assert.Equal(@"e:\abc\def\foo.cpp", FileUtilities.MakeRelative(@"c:\abc\def", @"e:\abc\def\foo.cpp"));
                 Assert.Equal(@"foo.cpp", FileUtilities.MakeRelative(@"\\aaa\abc\def", @"\\aaa\abc\def\foo.cpp"));
                 Assert.Equal(@"foo.cpp", FileUtilities.MakeRelative(@"c:\abc\def", @"foo.cpp"));
-                Assert.Equal(@"foo.cpp", FileUtilities.MakeRelative(@"c:\abc\def", @"..\def\foo.cpp"));
                 Assert.Equal(@"\\host\path\file", FileUtilities.MakeRelative(@"c:\abc\def", @"\\host\path\file"));
                 Assert.Equal(@"\\host\d$\file", FileUtilities.MakeRelative(@"c:\abc\def", @"\\host\d$\file"));
                 Assert.Equal(@"..\fff\ggg.hh", FileUtilities.MakeRelative(@"c:\foo\bar\..\abc\cde", @"c:\foo\bar\..\abc\fff\ggg.hh"));
             }
             else
             {
-                Assert.Equal(@"foo.cpp", FileUtilities.MakeRelative(@"/abc/def", @"/abc/def/foo.cpp"));
+                Assert.Equal(@"bar.cpp", FileUtilities.MakeRelative(@"/abc/def", @"/abc/def/bar.cpp"));
                 Assert.Equal(@"def/foo.cpp", FileUtilities.MakeRelative(@"/abc/", @"/abc/def/foo.cpp"));
-                Assert.Equal(@"..\foo.cpp", FileUtilities.MakeRelative(@"/abc/def/xyz", @"/abc/def/foo.cpp"));
-                Assert.Equal(@"..\ttt\foo.cpp", FileUtilities.MakeRelative(@"/abc/def/xyz/", @"/abc/def/ttt/foo.cpp"));
-                Assert.Equal(@"/abc/def/foo.cpp", FileUtilities.MakeRelative(@"/abc/def", @"/abc/def/foo.cpp"));
+                Assert.Equal(@"../foo.cpp", FileUtilities.MakeRelative(@"/abc/def/xyz", @"/abc/def/foo.cpp"));
+                Assert.Equal(@"../ttt/foo.cpp", FileUtilities.MakeRelative(@"/abc/def/xyz/", @"/abc/def/ttt/foo.cpp"));
                 Assert.Equal(@"foo.cpp", FileUtilities.MakeRelative(@"/abc/def", @"foo.cpp"));
-                Assert.Equal(@"foo.cpp", FileUtilities.MakeRelative(@"/abc/def", @"../def/foo.cpp"));
                 Assert.Equal(@"../fff/ggg.hh", FileUtilities.MakeRelative(@"/foo/bar/../abc/cde", @"/foo/bar/../abc/fff/ggg.hh"));
             }
         }
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 5c721b50c7e..a9bdd429d16 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1944,12 +1944,17 @@ public BuildResult BuildProjectFile(
 
                 return buildResult;
             }
-			
-			public GraphBuildResult BuildGraphSubmission(GraphBuildRequestData requestData)
+
+            public GraphBuildResult BuildGraphSubmission(GraphBuildRequestData requestData)
             {
                 return _buildManager.BuildRequest(requestData);
             }
 
+            public GraphBuildResult BuildGraph(ProjectGraph graph, string[] entryTargets = null)
+            {
+                return _buildManager.BuildRequest(new GraphBuildRequestData(graph, entryTargets ?? new string[0]));
+            }
+
             public void Dispose()
             {
                 if (_disposed)
@@ -1962,11 +1967,6 @@ public void Dispose()
                 _buildManager.EndBuild();
                 _buildManager.Dispose();
             }
-
-            public GraphBuildResult BuildGraph(ProjectGraph graph, string[] entryTargets = null)
-            {
-                return _buildManager.BuildRequest(new GraphBuildRequestData(graph, entryTargets ?? new string[0]));
-            }
         }
 
         internal class LoggingFileSystem : MSBuildFileSystemBase
diff --git a/src/Shared/VersionUtilities.cs b/src/Shared/VersionUtilities.cs
index ab4a2a2ba5c..fe113266894 100644
--- a/src/Shared/VersionUtilities.cs
+++ b/src/Shared/VersionUtilities.cs
@@ -39,9 +39,8 @@ internal static SortedDictionary<Version, List<string>> GatherVersionStrings(Ver
 
                     if (candidateVersion != null && (targetPlatformVersion == null || (candidateVersion <= targetPlatformVersion)))
                     {
-                        if (versionValues.ContainsKey(candidateVersion))
+                        if (versionValues.TryGetValue(candidateVersion, out List<string> versionList))
                         {
-                            List<string> versionList = versionValues[candidateVersion];
                             if (!versionList.Contains(version))
                             {
                                 versionList.Add(version);
@@ -128,4 +127,4 @@ int IComparer<Version>.Compare(Version x, Version y)
             return y.CompareTo(x);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/StringTools/SpanBasedStringBuilder.cs b/src/StringTools/SpanBasedStringBuilder.cs
index 2d388641f85..8bb5a13cc09 100644
--- a/src/StringTools/SpanBasedStringBuilder.cs
+++ b/src/StringTools/SpanBasedStringBuilder.cs
@@ -188,6 +188,19 @@ public void Append(string value, int startIndex, int count)
             }
         }
 
+        /// <summary>
+        /// Appends a character span represented by <see cref="ReadOnlyMemory{T}" />.
+        /// </summary>
+        /// <param name="span">The character span to append.</param>
+        public void Append(ReadOnlyMemory<char> span)
+        {
+            if (!span.IsEmpty)
+            {
+                _spans.Add(span);
+                Length += span.Length;
+            }
+        }
+
         /// <summary>
         /// Removes leading white-space characters from the string.
         /// </summary>
diff --git a/src/StringTools/StringTools.csproj b/src/StringTools/StringTools.csproj
index 1bead8c7ed9..e7713cb359a 100644
--- a/src/StringTools/StringTools.csproj
+++ b/src/StringTools/StringTools.csproj
@@ -28,7 +28,7 @@
     <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
   </ItemGroup>
   <ItemGroup>
-    <PackageReference Include="jnm2.ReferenceAssemblies.net35" />
+    <PackageReference Include="jnm2.ReferenceAssemblies.net35" PrivateAssets="All" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFramework)' == 'net35'">
diff --git a/src/Tasks.UnitTests/AssignTargetPath_Tests.cs b/src/Tasks.UnitTests/AssignTargetPath_Tests.cs
index 8f159985a94..3f9dc087274 100644
--- a/src/Tasks.UnitTests/AssignTargetPath_Tests.cs
+++ b/src/Tasks.UnitTests/AssignTargetPath_Tests.cs
@@ -1,10 +1,12 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -20,15 +22,10 @@ public void Regress314791()
                           { new TaskItem(NativeMethodsShared.IsWindows ? @"c:\bin2\abc.efg" : "/bin2/abc.efg") };
             t.RootFolder = NativeMethodsShared.IsWindows ? @"c:\bin" : "/bin";
 
-            bool success = t.Execute();
-
-            Assert.True(success);
-
-            Assert.Single(t.AssignedFiles);
-            Assert.Equal(
-                NativeMethodsShared.IsWindows ? @"c:\bin2\abc.efg" : "/bin2/abc.efg",
-                t.AssignedFiles[0].ItemSpec);
-            Assert.Equal(@"abc.efg", t.AssignedFiles[0].GetMetadata("TargetPath"));
+            t.Execute().ShouldBeTrue();
+            t.AssignedFiles.Length.ShouldBe(1);
+            t.AssignedFiles[0].ItemSpec.ShouldBe(NativeMethodsShared.IsWindows ? @"c:\bin2\abc.efg" : "/bin2/abc.efg");
+            t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe("abc.efg");
         }
 
         [Fact]
@@ -40,12 +37,9 @@ public void AtConeRoot()
                           { new TaskItem(NativeMethodsShared.IsWindows ? @"c:\f1\f2\file.txt" : "/f1/f2/file.txt") };
             t.RootFolder = NativeMethodsShared.IsWindows ? @"c:\f1\f2" : "/f1/f2";
 
-            bool success = t.Execute();
-
-            Assert.True(success);
-
-            Assert.Single(t.AssignedFiles);
-            Assert.Equal(@"file.txt", t.AssignedFiles[0].GetMetadata("TargetPath"));
+            t.Execute().ShouldBeTrue();
+            t.AssignedFiles.Length.ShouldBe(1);
+            t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe("file.txt");
         }
 
         [Fact]
@@ -64,12 +58,9 @@ public void OutOfCone()
             // /f1 to /x1
             t.RootFolder = NativeMethodsShared.IsWindows ? @"c:\f1" : "/x1";
 
-            bool success = t.Execute();
-
-            Assert.True(success);
-
-            Assert.Single(t.AssignedFiles);
-            Assert.Equal("file.txt", t.AssignedFiles[0].GetMetadata("TargetPath"));
+            t.Execute().ShouldBeTrue();
+            t.AssignedFiles.Length.ShouldBe(1);
+            t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe("file.txt");
         }
 
         [Fact]
@@ -84,14 +75,69 @@ public void InConeButAbsolute()
                           };
             t.RootFolder = NativeMethodsShared.IsWindows ? @"c:\f1\f2" : "/f1/f2";
 
-            bool success = t.Execute();
+            t.Execute().ShouldBeTrue();
+            t.AssignedFiles.Length.ShouldBe(1);
+            t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe(NativeMethodsShared.IsWindows ? @"f3\f4\file.txt" : "f3/f4/file.txt");
+        }
+
+        [Theory]
+        [InlineData("c:/fully/qualified/path.txt")]
+        [InlineData("test/output/file.txt")]
+        [InlineData(@"some\dir\to\file.txt")]
+        [InlineData("file.txt")]
+        [InlineData("file")]
+        public void TargetPathAlreadySet(string targetPath)
+        {
+            AssignTargetPath t = new AssignTargetPath();
+            t.BuildEngine = new MockEngine();
+            Dictionary<string, string> metaData = new Dictionary<string, string>();
+            metaData.Add("TargetPath", targetPath);
+            metaData.Add("Link", "c:/foo/bar");
+            t.Files = new ITaskItem[]
+                          {
+                              new TaskItem(
+                                  itemSpec: NativeMethodsShared.IsWindows ? @"c:\f1\f2\file.txt" : "/f1/f2/file.txt",
+                                  itemMetadata: metaData)
+                          };
+            t.RootFolder = NativeMethodsShared.IsWindows ? @"c:\f1\f2" : "/f1/f2";
+
+            t.Execute().ShouldBeTrue();
+            t.AssignedFiles.Length.ShouldBe(1);
+            t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe(targetPath);
+        }
+
+        [Theory]
+        [InlineData("c:/fully/qualified/path.txt")]
+        [InlineData("test/output/file.txt")]
+        [InlineData(@"some\dir\to\file.txt")]
+        [InlineData("file.txt")]
+        [InlineData("file")]
+        public void TargetPathAlreadySet_DisabledUnderChangeWave16_10(string targetPath)
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string link = "c:/some/path";
+
+            ChangeWaves.ResetStateForTests();
+            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave16_10.ToString());
+            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
-            Assert.True(success);
+            AssignTargetPath t = new AssignTargetPath();
+            t.BuildEngine = new MockEngine();
+            Dictionary<string, string> metaData = new Dictionary<string, string>();
+            metaData.Add("TargetPath", targetPath);
+            metaData.Add("Link", link);
+            t.Files = new ITaskItem[]
+                          {
+                              new TaskItem(
+                                  itemSpec: NativeMethodsShared.IsWindows ? @"c:\f1\f2\file.txt" : "/f1/f2/file.txt",
+                                  itemMetadata: metaData)
+                          };
+            t.RootFolder = NativeMethodsShared.IsWindows ? @"c:\f1\f2" : "/f1/f2";
 
-            Assert.Single(t.AssignedFiles);
-            Assert.Equal(
-                NativeMethodsShared.IsWindows ? @"f3\f4\file.txt" : "f3/f4/file.txt",
-                t.AssignedFiles[0].GetMetadata("TargetPath"));
+            t.Execute().ShouldBeTrue();
+            t.AssignedFiles.Length.ShouldBe(1);
+            t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe(link);
+            ChangeWaves.ResetStateForTests();
         }
     }
 }
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index edd0c80b6e4..6d48ace8c4b 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -2397,7 +2397,9 @@ public void CopyToDestinationFolderWithSymbolicLinkCheck()
 
             if (NativeMethodsShared.IsWindows)
             {
+#pragma warning disable CA1416 // Suppress Warning saying that WindowsPrincipal might not be compatible on Windows (Which shouldn't be an issue...)
                 if (!new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(new SecurityIdentifier(WellKnownSidType.BuiltinAdministratorsSid, null)))
+#pragma warning restore CA1416 // Suppress Warning saying that WindowsPrincipal might not be compatible on Windows (Which shouldn't be an issue...)
                 {
                     isPrivileged = false;
                     Assert.True(true, "It seems that you don't have the permission to create symbolic links. Try to run this test again with higher privileges");
diff --git a/src/Tasks.UnitTests/OutputPathTests.cs b/src/Tasks.UnitTests/OutputPathTests.cs
index f2bc410bbbd..6b4da05750a 100644
--- a/src/Tasks.UnitTests/OutputPathTests.cs
+++ b/src/Tasks.UnitTests/OutputPathTests.cs
@@ -61,7 +61,7 @@ public void BothBaseOutputPathAndOutputPathWereNotSpecified()
             project.Build(new MockLogger(_output)).ShouldBeFalse();
 
             // Assert
-            project.GetPropertyValue("BaseOutputPath").ShouldBe(baseOutputPath.WithTrailingSlash());
+            project.GetPropertyValue("BaseOutputPath").ShouldBe(baseOutputPath + '\\');
             project.GetPropertyValue("BaseOutputPathWasSpecified").ShouldBe(string.Empty);
             project.GetPropertyValue("_OutputPathWasMissing").ShouldBe("true");
         }
diff --git a/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs b/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
new file mode 100644
index 00000000000..11c0a395500
--- /dev/null
+++ b/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
@@ -0,0 +1,142 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+using Microsoft.Build.Framework;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.Utilities;
+using Shouldly;
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Xunit;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    public class RARPrecomputedCache_Tests
+    {
+        [Fact]
+        public void TestPrecomputedCacheOutput()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile standardCache = env.CreateFile(".cache");
+                ResolveAssemblyReference t = new ResolveAssemblyReference()
+                {
+                    _cache = new SystemState()
+                };
+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {
+                    { Path.Combine(standardCache.Path, "assembly1"), new SystemState.FileState(DateTime.Now) },
+                    { Path.Combine(standardCache.Path, "assembly2"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension("hi") } } };
+                t._cache.IsDirty = true;
+                t.StateFile = standardCache.Path;
+                t.WriteStateFile();
+                int standardLen = File.ReadAllText(standardCache.Path).Length;
+                File.Delete(standardCache.Path);
+                standardLen.ShouldBeGreaterThan(0);
+
+                string precomputedPath = standardCache.Path + ".cache";
+                t._cache.IsDirty = true;
+                t.AssemblyInformationCacheOutputPath = precomputedPath;
+                t.WriteStateFile();
+                File.Exists(standardCache.Path).ShouldBeFalse();
+                int preLen = File.ReadAllText(precomputedPath).Length;
+                preLen.ShouldBeGreaterThan(0);
+                preLen.ShouldNotBe(standardLen);
+            }
+        }
+
+        [Fact]
+        public void StandardCacheTakesPrecedence()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile standardCache = env.CreateFile(".cache");
+                ResolveAssemblyReference rarWriterTask = new ResolveAssemblyReference()
+                {
+                    _cache = new SystemState()
+                };
+                rarWriterTask._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>();
+                rarWriterTask.StateFile = standardCache.Path;
+                rarWriterTask._cache.IsDirty = true;
+                // Write standard cache
+                rarWriterTask.WriteStateFile();
+
+                string dllName = Path.Combine(Path.GetDirectoryName(standardCache.Path), "randomFolder", "dll.dll");
+                rarWriterTask._cache.instanceLocalFileStateCache.Add(dllName,
+                    new SystemState.FileState(DateTime.Now)
+                    {
+                        Assembly = null,
+                        RuntimeVersion = "v4.0.30319",
+                        FrameworkNameAttribute = new System.Runtime.Versioning.FrameworkName(".NETFramework", Version.Parse("4.7.2"), "Profile"),
+                        scatterFiles = new string[] { "first", "second" }
+                    });
+                string precomputedCachePath = standardCache.Path + ".cache";
+                rarWriterTask.AssemblyInformationCacheOutputPath = precomputedCachePath;
+                rarWriterTask._cache.IsDirty = true;
+                // Write precomputed cache
+                rarWriterTask.WriteStateFile();
+
+                ResolveAssemblyReference rarReaderTask = new ResolveAssemblyReference();
+                rarReaderTask.StateFile = standardCache.Path;
+                rarReaderTask.AssemblyInformationCachePaths = new ITaskItem[]
+                {
+                    new TaskItem(precomputedCachePath)
+                };
+
+                // At this point, we should have created two cache files: one "normal" one and one "precomputed" one.
+                // When we read the state file, it should read from the caches produced in a normal build. In this case,
+                // the normal cache does not have dll.dll, whereas the precomputed cache does, so it should not be
+                // present when we read it.
+                rarReaderTask.ReadStateFile(p => true);
+                rarReaderTask._cache.instanceLocalFileStateCache.ShouldNotContainKey(dllName);
+            }
+        }
+
+        [Fact]
+        public void TestPreComputedCacheInputMatchesOutput()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile precomputedCache = env.CreateFile(".cache");
+                ResolveAssemblyReference rarWriterTask = new ResolveAssemblyReference()
+                {
+                    _cache = new SystemState()
+                };
+                string dllName = Path.Combine(Path.GetDirectoryName(precomputedCache.Path), "randomFolder", "dll.dll");
+                rarWriterTask._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {
+                    { Path.Combine(precomputedCache.Path, "..", "assembly1", "assembly1"), new SystemState.FileState(DateTime.Now) },
+                    { Path.Combine(precomputedCache.Path, "assembly2"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension("hi") } },
+                    { dllName, new SystemState.FileState(DateTime.Now) {
+                        Assembly = null,
+                        RuntimeVersion = "v4.0.30319",
+                        FrameworkNameAttribute = new System.Runtime.Versioning.FrameworkName(".NETFramework", Version.Parse("4.7.2"), "Profile"),
+                        scatterFiles = new string[] { "first", "second" } } } };
+
+                rarWriterTask.AssemblyInformationCacheOutputPath = precomputedCache.Path;
+                rarWriterTask._cache.IsDirty = true;
+
+                // Throws an exception because precomputedCache.Path already exists.
+                Should.Throw<InvalidOperationException>(() => rarWriterTask.WriteStateFile());
+                File.Delete(precomputedCache.Path);
+                rarWriterTask.WriteStateFile();
+
+                ResolveAssemblyReference rarReaderTask = new ResolveAssemblyReference();
+                rarReaderTask.StateFile = precomputedCache.Path.Substring(0, precomputedCache.Path.Length - 6); // Not a real path; should not be used.
+                rarReaderTask.AssemblyInformationCachePaths = new ITaskItem[]
+                {
+                    new TaskItem(precomputedCache.Path)
+                };
+
+                // At this point, the standard cache does not exist, so it defaults to reading the "precomputed" cache.
+                // Then we verify that the information contained in that cache matches what we'd expect.
+                rarReaderTask.ReadStateFile(p => true);
+                rarReaderTask._cache.instanceLocalFileStateCache.ShouldContainKey(dllName);
+                SystemState.FileState assembly3 = rarReaderTask._cache.instanceLocalFileStateCache[dllName];
+                assembly3.Assembly.ShouldBeNull();
+                assembly3.RuntimeVersion.ShouldBe("v4.0.30319");
+                assembly3.FrameworkNameAttribute.Version.ShouldBe(Version.Parse("4.7.2"));
+                assembly3.scatterFiles.Length.ShouldBe(2);
+                assembly3.scatterFiles[1].ShouldBe("second");
+            }
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index fa551927b4f..3c304324122 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -10,6 +10,7 @@
 using Xunit;
 using Xunit.Abstractions;
 using System.IO;
+using System.Threading;
 using Shouldly;
 
 namespace Microsoft.Build.UnitTests.GenerateResource_Tests.OutOfProc
@@ -1942,7 +1943,7 @@ public void StateFileUnwritable()
                 t.Execute();
 
                 // "cannot read state file (opening for read/write)"
-                Utilities.AssertLogContains(t, "MSB3088");
+                Utilities.AssertLogContainsResourceWithUnspecifiedReplacements(t, "General.CouldNotReadStateFileMessage");
                 // "cannot write state file (opening for read/write)"
                 Utilities.AssertLogContains(t, "MSB3101");
             }
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 2beea1736da..558b16bf131 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -15,6 +15,7 @@
 using Xunit;
 using Xunit.Abstractions;
 using System.Collections.Generic;
+using System.Text.RegularExpressions;
 
 namespace Microsoft.Build.UnitTests.GenerateResource_Tests.InProc
 {
@@ -2316,7 +2317,7 @@ public void StateFileUnwritable()
                 t.Execute();
 
                 // "cannot read state file (opening for read/write)"
-                Utilities.AssertLogContains(t, "MSB3088");
+                Utilities.AssertLogContainsResourceWithUnspecifiedReplacements(t, "General.CouldNotReadStateFileMessage");
                 // "cannot write state file (opening for read/write)"
                 Utilities.AssertLogContains(t, "MSB3101");
             }
@@ -3395,8 +3396,42 @@ public static void AssertLogContainsResource(GenerateResource t, string messageI
         {
             Assert.Contains(
                 String.Format(AssemblyResources.GetString(messageID), replacements),
-                ((MockEngine)t.BuildEngine).Log
-                );
+                ((MockEngine) t.BuildEngine).Log
+            );
+        }
+
+        /// <summary>
+        /// Looks for a formatted message in the output log for the task execution, with unknown formatted parameters.
+        /// If verifies that all constant segments of unformatted message are present.
+        /// </summary>
+        public static void AssertLogContainsResourceWithUnspecifiedReplacements(GenerateResource t, string messageID)
+        {
+            var unformattedMessage = AssemblyResources.GetString(messageID);
+            var matches = Regex.Matches(unformattedMessage, @"\{\d+.*?\}");
+            if (matches.Count > 0)
+            {
+                var sb = new StringBuilder();
+                int i = 0;
+
+                foreach (Match match in matches)
+                {
+                    string segment = unformattedMessage.Substring(i, match.Index - i);
+                    sb.Append(Regex.Escape(segment));
+                    sb.Append(".*");
+
+                    i = match.Index + match.Length;
+                }
+                if (i < unformattedMessage.Length)
+                {
+                    sb.Append(Regex.Escape(unformattedMessage.Substring(i)));
+                }
+
+                Assert.Matches(sb.ToString(), ((MockEngine)t.BuildEngine).Log);
+            }
+            else
+            {
+                Assert.Contains(unformattedMessage, ((MockEngine)t.BuildEngine).Log);
+            }
         }
 
         /// <summary>
diff --git a/src/Tasks.UnitTests/ResourceManagement_Tests.cs b/src/Tasks.UnitTests/ResourceManagement_Tests.cs
new file mode 100644
index 00000000000..d75cdd4e120
--- /dev/null
+++ b/src/Tasks.UnitTests/ResourceManagement_Tests.cs
@@ -0,0 +1,157 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.UnitTests;
+using System.Collections.Generic;
+using System.Linq;
+using Xunit;
+using Shouldly;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    public class ResourceManagement_Tests
+    {
+        [Fact]
+        public void SingleCoreRequest()
+        {
+            var messages = AssertBuildSucceededAndGetMessages(@"
+                {
+                    int grantedCores = BuildEngine9.RequestCores(1337);
+                    Log.LogMessage(""Number of cores acquired: "" + grantedCores);
+                    BuildEngine9.ReleaseCores(grantedCores);
+                }", "<UseCores />");
+
+            var filteredMessages = messages.Where(m => m.Message.StartsWith("Number of cores acquired: ")).ToArray();
+            filteredMessages.Count().ShouldBe(1);
+            GetTrailingIntegerFromMessage(filteredMessages[0]).ShouldBeGreaterThan(0);
+        }
+
+        [Fact]
+        public void SingleCoreRequestWithNoRelease()
+        {
+            var messages = AssertBuildSucceededAndGetMessages(@"
+                {
+                    int grantedCores = BuildEngine9.RequestCores(1337);
+                    Log.LogMessage(""Number of cores acquired: "" + grantedCores);
+                    // Note that we're missing a call to ReleaseCores() so we rely on cores being released after the task is finished.
+                }", "<UseCores /> <UseCores />");
+
+            var filteredMessages = messages.Where(m => m.Message.StartsWith("Number of cores acquired: ")).ToArray();
+            filteredMessages.Count().ShouldBe(2);
+
+            int grantedCores1 = GetTrailingIntegerFromMessage(filteredMessages[0]);
+            int grantedCores2 = GetTrailingIntegerFromMessage(filteredMessages[1]);
+
+            // Both tasks were able to get the same number of cores because cores were auto-released.
+            grantedCores1.ShouldBeGreaterThan(0);
+            grantedCores2.ShouldBe(grantedCores1);
+        }
+
+        [Fact]
+        public void SingleCoreRequestWithReacquire()
+        {
+            var messages = AssertBuildSucceededAndGetMessages(@"
+                {
+                    int grantedCores1 = BuildEngine9.RequestCores(1337);
+                    Log.LogMessage(""Number of cores acquired: "" + grantedCores1);
+
+                    BuildEngine9.Yield();
+                    // Reacquire releases all cores.
+                    BuildEngine9.Reacquire();
+
+                    int grantedCores2 = BuildEngine9.RequestCores(1337);
+                    Log.LogMessage(""Number of cores acquired: "" + grantedCores2);
+                }", "<UseCores />");
+
+            var filteredMessages = messages.Where(m => m.Message.StartsWith("Number of cores acquired: ")).ToArray();
+            filteredMessages.Count().ShouldBe(2);
+
+            int grantedCores1 = GetTrailingIntegerFromMessage(filteredMessages[0]);
+            int grantedCores2 = GetTrailingIntegerFromMessage(filteredMessages[1]);
+
+            // Both tasks were able to get the same number of cores because cores were auto-released.
+            grantedCores1.ShouldBeGreaterThan(0);
+            grantedCores2.ShouldBe(grantedCores1);
+        }
+
+        [Fact]
+        public void MultipleCoreRequests()
+        {
+            // Exercise concurrent RequestCores() and ReleaseCores() calls.
+            AssertBuildSucceededAndGetMessages(@"
+                {
+                    const int coresToAcquire = 1337;
+                    int acquiredCores = 0;
+                    int done = 0;
+                    System.Threading.Thread requestThread = new System.Threading.Thread(() =>
+                    {
+                        for (int i = 0; i &lt; coresToAcquire; i++)
+                        {
+                            BuildEngine9.RequestCores(1);
+                            System.Threading.Interlocked.Increment(ref acquiredCores);
+                        }
+                        System.Threading.Thread.VolatileWrite(ref done, 1);
+                    });
+                    System.Threading.Thread releaseThread = new System.Threading.Thread(() =>
+                    {
+                            while (System.Threading.Thread.VolatileRead(ref done) == 0 || System.Threading.Thread.VolatileRead(ref acquiredCores) > 0)
+                            {
+                                if (System.Threading.Thread.VolatileRead(ref acquiredCores) > 0)
+                                {
+                                    BuildEngine9.ReleaseCores(1);
+                                    System.Threading.Interlocked.Decrement(ref acquiredCores);
+                                }
+                                else
+                                {
+                                    System.Threading.Thread.Yield();
+                                }
+                            }
+                    });
+
+                    // One thread is acquiring cores, the other is releasing them. The releasing thread is running with a lower
+                    // priority to increase the chances of contention where all cores are allocated and RequestCores() blocks.
+                    requestThread.Start();
+                    releaseThread.Priority = System.Threading.ThreadPriority.BelowNormal;
+                    releaseThread.Start();
+
+                    requestThread.Join();
+                    releaseThread.Join();
+                }", "<UseCores />");
+        }
+
+        private List<BuildMessageEventArgs> AssertBuildSucceededAndGetMessages(string taskCode, string targetContent)
+        {
+            string text = $@"
+<Project>
+  <UsingTask
+    TaskName=""UseCores""
+    TaskFactory=""RoslynCodeTaskFactory""
+    AssemblyFile=""$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"" >
+    <Task>
+      <Reference Include=""{typeof(Enumerable).Assembly.Location}"" />
+      <Code Type=""Fragment"" Language=""cs"">
+        {taskCode}
+      </Code>
+    </Task>
+  </UsingTask>
+
+  <Target Name=""Build"">
+        {targetContent}
+  </Target>
+</Project>";
+            using var env = TestEnvironment.Create();
+
+            var projectFile = env.CreateTestProjectWithFiles("test.proj", text);
+            var logger = projectFile.BuildProjectExpectSuccess();
+            return logger.BuildMessageEvents;
+        }
+
+        private int GetTrailingIntegerFromMessage(BuildMessageEventArgs msg)
+        {
+            string[] messageComponents = msg.Message.Split(' ');
+            int.TryParse(messageComponents.Last(), out int trailingInteger).ShouldBeTrue();
+            return trailingInteger;
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests2/AssemblyIdentityTest.cs b/src/Tasks.UnitTests2/AssemblyIdentityTest.cs
deleted file mode 100644
index 5425479a9a6..00000000000
--- a/src/Tasks.UnitTests2/AssemblyIdentityTest.cs
+++ /dev/null
@@ -1,125 +0,0 @@
-﻿using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
-using Microsoft.VisualStudio.TestTools.UnitTesting;
-using System.Collections.Generic;
-namespace XMakeTasksUnitTests
-{
-    
-    
-    /// <summary>
-    ///This is a test class for AssemblyIdentityTest and is intended
-    ///to contain all AssemblyIdentityTest Unit Tests
-    ///</summary>
-    [TestClass()]
-    public class AssemblyIdentityTest
-    {
-
-
-        private TestContext testContextInstance;
-
-        /// <summary>
-        ///Gets or sets the test context which provides
-        ///information about and functionality for the current test run.
-        ///</summary>
-        public TestContext TestContext
-        {
-            get
-            {
-                return testContextInstance;
-            }
-            set
-            {
-                testContextInstance = value;
-            }
-        }
-
-        #region Additional test attributes
-        // 
-        //You can use the following additional attributes as you write your tests:
-        //
-        //Use ClassInitialize to run code before running the first test in the class
-        //[ClassInitialize()]
-        //public static void MyClassInitialize(TestContext testContext)
-        //{
-        //}
-        //
-        //Use ClassCleanup to run code after all tests in a class have run
-        //[ClassCleanup()]
-        //public static void MyClassCleanup()
-        //{
-        //}
-        //
-        //Use TestInitialize to run code before running each test
-        //[TestInitialize()]
-        //public void MyTestInitialize()
-        //{
-        //}
-        //
-        //Use TestCleanup to run code after each test has run
-        //[TestCleanup()]
-        //public void MyTestCleanup()
-        //{
-        //}
-        //
-        #endregion
-
-
-        /// <summary>
-        ///A test for IsFrameworkAssembly
-        ///</summary>
-        [TestMethod()]
-        public void IsFrameworkAssemblyTest()
-        {
-            bool actual;
-            IList<string> listOfInstalledFrameworks = FrameworkMultiTargeting.GetSupportedTargetFrameworks();
-
-            // if 2.0 is installed on this computer, we will test IsFrameworkAssembly for 2.0 assemblies.
-            if (hasVersion(listOfInstalledFrameworks, "Version=v2.0"))
-            {
-                //if (hasVersion(listOfInstalledFrameworks
-                // Test 2.0 CLR binary
-                // "Microsoft.Build.Engine" Version="2.0.0.0" PublicKeyToken="b03f5f7f11d50a3a" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="2.0.50727.3026" InGAC="true" />
-                AssemblyIdentity clr2Binary = new AssemblyIdentity("Microsoft.Build.Engine", "2.0.0.0", "b03f5f7f11d50a3a", "neutral", "MSIL");
-                actual = clr2Binary.IsFrameworkAssembly;
-                Assert.IsTrue(actual);
-            }
-
-            if (hasVersion(listOfInstalledFrameworks, "Version=v3.0"))
-            {
-                // Test 3.0 CLR binary
-                // AssemblyName="System.ServiceModel" Version="3.0.0.0" PublicKeyToken="b77a5c561934e089" Culture="neutral" ProcessorArchitecture="MSIL" InGAC="false" IsRedistRoot="true" />
-                AssemblyIdentity clr3Binary = new AssemblyIdentity("System.ServiceModel", "3.0.0.0", "b77a5c561934e089", "neutral", "MSIL");
-                actual = clr3Binary.IsFrameworkAssembly;
-                Assert.IsTrue(actual);
-            }
-
-            if (hasVersion(listOfInstalledFrameworks, "Version=v3.5"))
-            {
-                // Test 3.5 CLR binary
-                // AssemblyName="Microsoft.Build.Tasks.v3.5" Version="3.5.0.0" PublicKeyToken="b03f5f7f11d50a3a" Culture="neutral" ProcessorArchitecture="MSIL" InGAC="false" />
-                AssemblyIdentity clr35Binary = new AssemblyIdentity("Microsoft.Build.Tasks.v3.5", "3.5.0.0", "b03f5f7f11d50a3a", "neutral", "MSIL");
-                actual = clr35Binary.IsFrameworkAssembly;
-                Assert.IsTrue(actual);
-            }
-
-            if (hasVersion(listOfInstalledFrameworks, "Version=v4.0"))
-            {
-                // Test 4.0 CLR binary
-                // AssemblyName="Microsoft.VisualBasic" Version="10.0.0.0" PublicKeyToken="b03f5f7f11d50a3a" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="4.0.41117.0" InGAC="true" />
-                AssemblyIdentity clr4Binary = new AssemblyIdentity("Microsoft.VisualBasic", "10.0.0.0", "b03f5f7f11d50a3a", "neutral", "MSIL");
-                actual = clr4Binary.IsFrameworkAssembly;
-                Assert.IsTrue(actual);
-            }
-        }
-
-        private bool hasVersion(IList<string> listOfInstalledFrameworks, string p)
-        {
-            foreach (string fx in listOfInstalledFrameworks)
-            {
-                if (fx.Contains(p))
-                    return true;
-            }
-
-            return false;
-        }
-    }
-}
diff --git a/src/Tasks.UnitTests2/AuthoringTests.txt b/src/Tasks.UnitTests2/AuthoringTests.txt
deleted file mode 100644
index 3eb1fca8202..00000000000
--- a/src/Tasks.UnitTests2/AuthoringTests.txt
+++ /dev/null
@@ -1,136 +0,0 @@
-﻿==========================================================================
-    Visual Studio Team System: Overview of Authoring and Running Tests    
-==========================================================================
-
-This overview describes the features for authoring and running tests in 
-Visual Studio Team System and Visual Studio Team Edition for Software Testers.
-
-Opening Tests
--------------
-To open a test, open a test project or a test metadata file (a file with
-extension .vsmdi) that contains the definition of the test. You can find
-test projects and metadata files in Solution Explorer.
-
-Viewing Tests
--------------
-To see which tests are available to you, open the Test View window. Or,
-if you have installed Team Edition for Software Testers, you can also open
-the Test List Editor window to view tests.
-
-To open the Test View window, click the Test menu, point to Windows, and
-then click Test View. To open the Test List Editor window (if you have
-installed Team Edition for Software Testers), click Test, point to Windows,
-and then click Test List Editor.
-
-Running Tests
--------------
-You can run tests from the Test View window and the Test List Editor window.
-See Viewing Tests to learn how to open these windows. To run one or more
-tests displayed in the Test View window, first select the tests in that
-window; to select multiple tests, hold either the Shift or CTRL key while
-clicking tests. Then click the Run Tests button in the Test View window
-toolbar.
-
-If you have installed Visual Studio Team Edition for Software Testers, you can
-also use the Test List Editor window to run tests. To run tests in Test List Editor,
-select the check box next to each test that you want to run. Then click the
-Run Tests button in the Test List Editor window toolbar.
-
-Viewing Test Results
---------------------
-When you run a test or a series of tests, the results of the test run will be
-shown in the Test Results window. Each individual test in the run is shown on
-a separate line so that you can see its status. The window contains an
-embedded status bar in the top half of the window that provides you with
-summary details of the complete test run.
-
-To see more detailed results for a particular test result, double-click it in
-the Test Results window. This opens a window that provides more information
-about the particular test result, such as any specific error messages returned
-by the test.
-
-Changing the way that tests are run
------------------------------------
-Each time you run one or more tests, a collection of settings is used to
-determine how those tests are run. These settings are contained in a “test
-settings” file.
-
-Here is a partial list of the changes you can make with a test settings file:
-
- - Change the naming scheme for each test run.
- - Change the test controller that the tests are run on so that you can run
-   tests remotely.
- - Gather code coverage data for the code being tested so that you can see
-   which lines of code are covered by your tests.
- - Enable and disable test deployment. 
- - Specify additional files to deploy before tests are run.
- - Select a different host, ASP.NET, for running ASP.NET unit tests.
- - Select a different host, the smart device test host, for running smart device unit tests.
- - Set various properties for the test agents that run your tests.
- - Specify to use data collectors that can collect various information as
-   the tests are running.
- - Run custom scripts at the start and end of each test run so that you can
-   set up the test environment exactly as required each time tests are run.
- - Set time limits for tests and test runs.
- - Set the browser mix and the number of times to repeat Web tests in the
-   test run.
-
-By default, a test settings file is created whenever you create a new test
-project. You make changes to this file by double-clicking it in Solution
-Explorer and then changing the test settings. (Test settings files have the
-extension .testsettings.)
-
-A solution can contain multiple test settings files. Only one of those
-files, known as the “Active” test settings file, is used to determine the
-settings that are currently used for test runs. You select the active test
-settings by clicking Select Active Test Settings on the Test menu.
-
--------------------------------------------------------------------------------
-
-Test Types
-----------
-Using Visual Studio Team Edition for Software Testers, you can create a number
-of different test types:
-
-Unit test: Use a unit test to create a programmatic test in C++, Visual C# or
-Visual Basic that exercises source code. A unit test calls the methods of a
-class, passing suitable parameters, and verifies that the returned value is
-what you expect.
-There are three specialized variants of unit tests:
- - Data-driven unit tests are created when you configure a unit test to be
-   called repeatedly for each row of a data source. The data from each row
-   is used by the unit test as input data.
- - ASP.NET unit tests are unit tests that exercise code in an ASP.NET Web
-   application.
- - Smart device unit tests are unit tests that are deployed to a smart device
-   or emulator and then executed by the smart device test host.  
-
-Web Test: Web tests consist of an ordered series of HTTP requests that you
-record in a browser session using Microsoft Internet Explorer. You can have
-the test report specific details about the pages or sites it requests, such
-as whether a particular page contains a specified string.
-
-Load Test: You use a load test to encapsulate non-manual tests, such as
-unit, Web, and generic tests, and then run them simultaneously by using
-virtual users. Running these tests under load generates test results,
-including performance and other counters, in tables and in graphs.
-
-Generic test: A generic test is an existing program wrapped to function as a
-test in Visual Studio. The following are examples of tests or programs that
-you can turn into generic tests:
- - An existing test that uses process exit codes to communicate whether the
-   test passed or failed. 0 indicates passing and any other value indicates
-   a failure.
- - A general program to obtain specific functionality during a test scenario.
- - A test or program that uses a special XML file (called a “summary results
-   file”), to communicate detailed results.
-
-Manual test: The manual test type is used when the test tasks are to be
-completed by a test engineer as opposed to an automated script.
-
-Ordered test: Use an ordered test to execute a set of tests in an order you
-specify.
-
--------------------------------------------------------------------------------
-
-
diff --git a/src/Tasks.UnitTests2/Properties/AssemblyInfo.cs b/src/Tasks.UnitTests2/Properties/AssemblyInfo.cs
deleted file mode 100644
index ca470e18458..00000000000
--- a/src/Tasks.UnitTests2/Properties/AssemblyInfo.cs
+++ /dev/null
@@ -1,33 +0,0 @@
-﻿using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-
-// General Information about an assembly is controlled through the following 
-// set of attributes. Change these attribute values to modify the information
-// associated with an assembly.
-[assembly: AssemblyTitle("XMakeTasksUnitTests")]
-[assembly: AssemblyDescription("")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyProduct("XMakeTasksUnitTests")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-// Setting ComVisible to false makes the types in this assembly not visible 
-// to COM componenets.  If you need to access a type in this assembly from 
-// COM, set the ComVisible attribute to true on that type.
-[assembly: ComVisible(false)]
-
-// The following GUID is for the ID of the typelib if this project is exposed to COM
-[assembly: Guid("de6f3aea-4f78-444d-9f24-6955d929c1f9")]
-
-// Version information for an assembly consists of the following four values:
-//
-//      Major Version
-//      Minor Version 
-//      Build Number
-//      Revision
-//
-// You can specify all the values or you can default the Revision and Build Numbers 
-// by using the '*' as shown below:
-[assembly: AssemblyVersion("1.0.0.0")]
-[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/src/Tasks.UnitTests2/UtilTest.cs b/src/Tasks.UnitTests2/UtilTest.cs
deleted file mode 100644
index ff01de06a76..00000000000
--- a/src/Tasks.UnitTests2/UtilTest.cs
+++ /dev/null
@@ -1,96 +0,0 @@
-﻿using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
-using Microsoft.VisualStudio.TestTools.UnitTesting;
-namespace XMakeTasksUnitTests
-{
-    
-    
-    /// <summary>
-    ///This is a test class for UtilTest and is intended
-    ///to contain all UtilTest Unit Tests
-    ///</summary>
-    [TestClass()]
-    public class UtilTest
-    {
-
-
-        private TestContext testContextInstance;
-
-        /// <summary>
-        ///Gets or sets the test context which provides
-        ///information about and functionality for the current test run.
-        ///</summary>
-        public TestContext TestContext
-        {
-            get
-            {
-                return testContextInstance;
-            }
-            set
-            {
-                testContextInstance = value;
-            }
-        }
-
-        #region Additional test attributes
-        // 
-        //You can use the following additional attributes as you write your tests:
-        //
-        //Use ClassInitialize to run code before running the first test in the class
-        //[ClassInitialize()]
-        //public static void MyClassInitialize(TestContext testContext)
-        //{
-        //}
-        //
-        //Use ClassCleanup to run code after all tests in a class have run
-        //[ClassCleanup()]
-        //public static void MyClassCleanup()
-        //{
-        //}
-        //
-        //Use TestInitialize to run code before running each test
-        //[TestInitialize()]
-        //public void MyTestInitialize()
-        //{
-        //}
-        //
-        //Use TestCleanup to run code after each test has run
-        //[TestCleanup()]
-        //public void MyTestCleanup()
-        //{
-        //}
-        //
-        #endregion
-
-
-        /// <summary>
-        ///A test for GetClrVersion
-        ///</summary>
-        [TestMethod()]
-        [DeploymentItem("Microsoft.Build.Tasks.v4.0.dll")]
-        public void GetClrVersionTest()
-        {
-            string targetFrameworkVersion = "v3.5";
-            string expected = "2.0.50727.0"; 
-            string actual;
-            actual = Util_Accessor.GetClrVersion(targetFrameworkVersion);
-            Assert.AreEqual(expected, actual);
-
-            targetFrameworkVersion = "3.5";
-            actual = Util_Accessor.GetClrVersion(targetFrameworkVersion);
-            Assert.AreEqual(expected, actual);
-
-            System.Version currentVersion = System.Environment.Version;
-            System.Version clr4Version = new System.Version(currentVersion.Major, currentVersion.Minor, currentVersion.Build, 0);
-            
-            targetFrameworkVersion = "v4.0";
-            actual = Util_Accessor.GetClrVersion(targetFrameworkVersion);
-            expected = clr4Version.ToString();
-            Assert.AreEqual(expected, actual);
-
-            targetFrameworkVersion = "v4.2";
-            actual = Util_Accessor.GetClrVersion(targetFrameworkVersion);
-            expected = clr4Version.ToString();
-            Assert.AreEqual(expected, actual);
-        }
-    }
-}
diff --git a/src/Tasks.UnitTests2/XMakeTasksUnitTests.csproj b/src/Tasks.UnitTests2/XMakeTasksUnitTests.csproj
deleted file mode 100644
index 78562a2f182..00000000000
--- a/src/Tasks.UnitTests2/XMakeTasksUnitTests.csproj
+++ /dev/null
@@ -1,100 +0,0 @@
-﻿<Project ToolsVersion="dogfood" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <Import Project="$(_NTDRIVE)$(_NTROOT)\tools\Microsoft.DevDiv.Settings.targets" />  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>10.0.10911</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{9EA71CF9-9A62-4ED8-AFE8-DD5753EE377B}</ProjectGuid>
-    <OutputType>Library</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>XMakeTasksUnitTests</RootNamespace>
-    <AssemblyName>XMakeTasksUnitTests</AssemblyName>
-    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
-    <FileAlignment>512</FileAlignment>
-    <ProjectTypeGuids>{3AC096D0-A1C2-E12C-1390-A8335801FDAB};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugSymbols>true</DebugSymbols>
-    <DebugType>full</DebugType>
-    <Optimize>false</Optimize>
-    <OutputPath>bin\Debug\</OutputPath>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>pdbonly</DebugType>
-    <Optimize>true</Optimize>
-    <OutputPath>bin\Release\</OutputPath>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="Microsoft.Build.Framework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\Framework\objr\i386\Microsoft.Build.Framework.dll</HintPath>
-    </Reference>
-    <Reference Include="Microsoft.Build.Tasks.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\objr\i386\Microsoft.Build.Tasks.v4.0.dll</HintPath>
-    </Reference>
-    <Reference Include="Microsoft.Build.Utilities.v4.0, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\Utilities\objr\i386\Microsoft.Build.Utilities.v4.0.dll</HintPath>
-    </Reference>
-    <Reference Include="Microsoft.VisualStudio.QualityTools.UnitTestFramework, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL" />
-    <Reference Include="System">
-      <HintPath>$(SdkRefPath)\System.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Configuration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.Configuration.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Core">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.Core.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.Data.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.Design.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.Drawing.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.Security.dll</HintPath>
-    </Reference>
-    <Reference Include="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.Windows.Forms.dll</HintPath>
-    </Reference>
-    <Reference Include="System.XML, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL">
-      <SpecificVersion>False</SpecificVersion>
-      <HintPath>..\..\..\..\public\sdk\ref\v4.0\System.XML.dll</HintPath>
-    </Reference>
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="AssemblyIdentityTest.cs" />
-    <Compile Include="Properties\AssemblyInfo.cs" />
-    <Compile Include="UtilTest.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <Content Include="AuthoringTests.txt" />
-  </ItemGroup>
-  <ItemGroup>
-    <Shadow Include="Test References\Microsoft.Build.Tasks.v3.5.accessor" />
-  </ItemGroup>
-  <Import Project="$(_NTDRIVE)$(_NTROOT)\tools\x86\managed\v4.0\Microsoft.CSharp.targets" />
-  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
-       Other similar extension points exist, see Microsoft.Common.targets.
-  <Target Name="BeforeBuild">
-  </Target>
-  <Target Name="AfterBuild">
-  </Target>
-  -->
-</Project>
\ No newline at end of file
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index b7c394ebe42..4af1396f59e 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -361,6 +361,25 @@ private void CorePopulateMetadata()
                 using (var stream = File.OpenRead(_sourceFile))
                 using (var peFile = new PEReader(stream))
                 {
+                    bool hasMetadata = false;
+                    try
+                    {
+                        // This can throw if the stream is too small, which means
+                        // the assembly doesn't have metadata.
+                        hasMetadata = peFile.HasMetadata;
+                    }
+                    finally
+                    {
+                        // If the file does not contain PE metadata, throw BadImageFormatException to preserve
+                        // behavior from AssemblyName.GetAssemblyName(). RAR will deal with this correctly.
+                        if (!hasMetadata)
+                        {
+                            throw new BadImageFormatException(string.Format(CultureInfo.CurrentCulture,
+                                AssemblyResources.GetString("ResolveAssemblyReference.AssemblyDoesNotContainPEMetadata"),
+                                _sourceFile));
+                        }
+                    }
+
                     var metadataReader = peFile.GetMetadataReader();
 
                     var assemblyReferences = metadataReader.AssemblyReferences;
diff --git a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
index b0da1661f29..147a65313eb 100644
--- a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
+++ b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
@@ -280,9 +280,8 @@ bool specificVersion
                 }
                 else
                 {
-                    if (fusionNameToResolvedPath.ContainsKey(strongName))
+                    if (fusionNameToResolvedPath.TryGetValue(strongName, out string fusionName))
                     {
-                        fusionNameToResolvedPath.TryGetValue(strongName, out string fusionName);
                         return fusionName;
                     }
                 }
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index c9761c6d469..e5b3b361455 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -148,8 +148,7 @@ internal Reference(IsWinMDFile isWinMDFile, FileExists fileExists, GetAssemblyRu
         internal void AddSourceItem(ITaskItem sourceItem)
         {
             string itemSpec = sourceItem.ItemSpec;
-            bool sourceItemAlreadyInList = _sourceItems.ContainsKey(itemSpec);
-            if (!sourceItemAlreadyInList)
+            if (!_sourceItems.ContainsKey(itemSpec))
             {
                 _sourceItems[itemSpec] = sourceItem;
                 PropagateSourceItems(sourceItem);
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index dcc38343d3c..5967f4c1cdf 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -327,14 +327,7 @@ internal ReferenceTable
 
                     if (sdkName.Length > 0)
                     {
-                        if (!_resolvedSDKReferences.ContainsKey(sdkName))
-                        {
-                            _resolvedSDKReferences.Add(sdkName, resolvedSDK);
-                        }
-                        else
-                        {
-                            _resolvedSDKReferences[sdkName] = resolvedSDK;
-                        }
+                        _resolvedSDKReferences[sdkName] = resolvedSDK;
                     }
                 }
             }
@@ -406,9 +399,8 @@ internal ReferenceTable
         internal void AddReference(AssemblyNameExtension assemblyName, Reference reference)
         {
             ErrorUtilities.VerifyThrow(assemblyName.Name != null, "Got an empty assembly name.");
-            if (References.ContainsKey(assemblyName))
+            if (References.TryGetValue(assemblyName, out Reference referenceGoingToBeReplaced))
             {
-                Reference referenceGoingToBeReplaced = References[assemblyName];
                 foreach (AssemblyRemapping pair in referenceGoingToBeReplaced.RemappedAssemblyNames())
                 {
                     reference.AddRemapping(pair.From, pair.To);
@@ -3197,15 +3189,12 @@ internal bool MarkReferencesForExclusion(Dictionary<string, string> exclusionLis
                 if (!reference.CheckForSpecificVersionMetadataOnParentsReference(false))
                 {
                     // Check to see if the reference is not in a profile or subset
-                    if (exclusionList != null)
+                    if (exclusionList?.ContainsKey(assemblyFullName) == true)
                     {
-                        if (exclusionList.ContainsKey(assemblyFullName))
-                        {
-                            anyMarkedReference = true;
-                            reference.ExclusionListLoggingProperties.ExclusionReasonLogDelegate = LogProfileExclusionUnresolve;
-                            reference.ExclusionListLoggingProperties.IsInExclusionList = true;
-                            ListOfExcludedAssemblies.Add(assemblyFullName);
-                        }
+                        anyMarkedReference = true;
+                        reference.ExclusionListLoggingProperties.ExclusionReasonLogDelegate = LogProfileExclusionUnresolve;
+                        reference.ExclusionListLoggingProperties.IsInExclusionList = true;
+                        ListOfExcludedAssemblies.Add(assemblyFullName);
                     }
 
                     // Check to see if the reference is in the current target framework but has a higher version than what exists in the target framework
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 4844d757611..f0062776ba5 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -49,7 +49,7 @@ public class ResolveAssemblyReference : TaskExtension
         /// <summary>
         /// Cache of system state information, used to optimize performance.
         /// </summary>
-        private SystemState _cache = null;
+        internal SystemState _cache = null;
 
         /// <summary>
         /// Construct
@@ -1569,7 +1569,7 @@ private void LogReferenceErrors(Reference reference, MessageImportance importanc
                 }
                 else if (itemError is BadImageReferenceException)
                 {
-                    message = Log.FormatResourceString("ResolveAssemblyReference.FailedWithException", itemError.Message);
+                    message = Log.FormatResourceString("ResolveAssemblyReference.FailedWithException", itemError.InnerException?.ToString() ?? itemError.ToString());
                     helpKeyword = "MSBuild.ResolveAssemblyReference.FailedWithException";
                     dependencyProblem = false;
                 }
@@ -1578,8 +1578,7 @@ private void LogReferenceErrors(Reference reference, MessageImportance importanc
                     Debug.Assert(false, "Unexpected exception type.");
                 }
 
-                string messageOnly;
-                string warningCode = Log.ExtractMessageCode(message, out messageOnly);
+                string warningCode = Log.ExtractMessageCode(message, out string messageOnly);
 
                 // Treat as warning if this is primary and the problem wasn't with a dependency, otherwise, make it a comment.
                 if (reference.IsPrimary && !dependencyProblem)
@@ -1884,11 +1883,16 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l
         /// <summary>
         /// Reads the state file (if present) into the cache.
         /// </summary>
-        private void ReadStateFile()
+        internal void ReadStateFile(FileExists fileExists)
         {
             _cache = SystemState.DeserializeCacheByTranslator(_stateFile, Log);
 
-            // Construct the cache if necessary.
+            // Construct the cache only if we can't find any caches.
+            if (_cache == null && AssemblyInformationCachePaths != null && AssemblyInformationCachePaths.Length > 0)
+            {
+                _cache = SystemState.DeserializePrecomputedCachesByTranslator(AssemblyInformationCachePaths, Log, fileExists);
+            }
+
             if (_cache == null)
             {
                 _cache = new SystemState();
@@ -1898,9 +1902,13 @@ private void ReadStateFile()
         /// <summary>
         /// Write out the state file if a state name was supplied and the cache is dirty.
         /// </summary>
-        private void WriteStateFile()
+        internal void WriteStateFile()
         {
-            if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)
+            if (!String.IsNullOrEmpty(AssemblyInformationCacheOutputPath))
+            {
+                _cache.SerializePrecomputedCacheByTranslator(AssemblyInformationCacheOutputPath, Log);
+            }
+            else if (!String.IsNullOrEmpty(_stateFile) && _cache.IsDirty)
             {
                 _cache.SerializeCacheByTranslator(_stateFile, Log);
             }
@@ -2132,7 +2140,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     }
 
                     // Load any prior saved state.
-                    ReadStateFile();
+                    ReadStateFile(fileExists);
                     _cache.SetGetLastWriteTime(getLastWriteTime);
                     _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);
 
diff --git a/src/Tasks/AssignTargetPath.cs b/src/Tasks/AssignTargetPath.cs
index ffb085cfcf6..6b033ae1fb0 100644
--- a/src/Tasks/AssignTargetPath.cs
+++ b/src/Tasks/AssignTargetPath.cs
@@ -71,13 +71,19 @@ public override bool Execute()
 
                 for (int i = 0; i < Files.Length; ++i)
                 {
-                    string link = Files[i].GetMetadata(ItemMetadataNames.link);
                     AssignedFiles[i] = new TaskItem(Files[i]);
 
-                    // If file has a link, use that.
-                    string targetPath = link;
+                    // If TargetPath is already set, it takes priority.
+                    // https://github.com/dotnet/msbuild/issues/2795
+                    string targetPath =  ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10) ? Files[i].GetMetadata(ItemMetadataNames.targetPath) : null;
 
-                    if (string.IsNullOrEmpty(link))
+                    // If TargetPath not already set, fall back to default behavior.
+                    if (string.IsNullOrEmpty(targetPath))
+                    {
+                        targetPath = Files[i].GetMetadata(ItemMetadataNames.link);
+                    }
+
+                    if (string.IsNullOrEmpty(targetPath))
                     {
                         if (// if the file path is relative
                             !Path.IsPathRooted(Files[i].ItemSpec) &&
diff --git a/src/Tasks/DefaultTasks.bat b/src/Tasks/DefaultTasks.bat
deleted file mode 100644
index df9739c3429..00000000000
--- a/src/Tasks/DefaultTasks.bat
+++ /dev/null
@@ -1,23 +0,0 @@
-﻿if exist ..\..\..\XMakeCommandLine\bin\Debug copy ..\..\Microsoft.Common.tasks ..\..\..\XMakeCommandLine\bin\Debug
-if exist ..\..\..\XMakeCommandLine\bin\Release copy ..\..\Microsoft.Common.tasks ..\..\..\XMakeCommandLine\bin\Release
-
-rem Deprecated -- remove
-if exist ..\..\..\XMakeCommandLine\bin\Debug copy ..\..\CSharp.targets ..\..\..\XMakeCommandLine\bin\Debug
-if exist ..\..\..\XMakeCommandLine\bin\Release copy ..\..\CSharp.targets ..\..\..\XMakeCommandLine\bin\Release
-
-rem Deprecated -- remove
-if exist ..\..\..\XMakeCommandLine\bin\Debug copy ..\..\VisualBasic.targets ..\..\..\XMakeCommandLine\bin\Debug
-if exist ..\..\..\XMakeCommandLine\bin\Release copy ..\..\VisualBasic.targets ..\..\..\XMakeCommandLine\bin\Release
-
-rem Deprecated -- remove
-if exist ..\..\..\XMakeCommandLine\bin\Debug copy ..\..\Framework.targets ..\..\..\XMakeCommandLine\bin\Debug
-if exist ..\..\..\XMakeCommandLine\bin\Release copy ..\..\Framework.targets ..\..\..\XMakeCommandLine\bin\Release
-
-if exist ..\..\..\XMakeCommandLine\bin\Debug copy ..\..\Microsoft.CSharp.targets ..\..\..\XMakeCommandLine\bin\Debug
-if exist ..\..\..\XMakeCommandLine\bin\Release copy ..\..\Microsoft.CSharp.targets ..\..\..\XMakeCommandLine\bin\Release
-
-if exist ..\..\..\XMakeCommandLine\bin\Debug copy ..\..\Microsoft.VisualBasic.targets ..\..\..\XMakeCommandLine\bin\Debug
-if exist ..\..\..\XMakeCommandLine\bin\Release copy ..\..\Microsoft.VisualBasic.targets ..\..\..\XMakeCommandLine\bin\Release
-
-if exist ..\..\..\XMakeCommandLine\bin\Debug copy ..\..\Microsoft.Common.targets ..\..\..\XMakeCommandLine\bin\Debug
-if exist ..\..\..\XMakeCommandLine\bin\Release copy ..\..\Microsoft.Common.targets ..\..\..\XMakeCommandLine\bin\Release
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index 5ea744bf9ad..77fa495a484 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -126,14 +126,6 @@ public string CustomWarningRegularExpression
         /// </summary>
         protected override Encoding StandardErrorEncoding => _standardErrorEncoding;
 
-        /// <summary>
-        /// Whether or not to use UTF8 encoding for the cmd file and console window.
-        /// Values: Always, Never, Detect
-        /// If set to Detect, the current code page will be used unless it cannot represent 
-        /// the Command string. In that case, UTF-8 is used.
-        /// </summary>
-        public string UseUtf8Encoding { get; set; }
-
         /// <summary>
         /// Project visible property specifying the encoding of the captured task standard output stream
         /// </summary>
diff --git a/src/Tasks/GenerateBootstrapper.cs b/src/Tasks/GenerateBootstrapper.cs
index 98ffca90a5e..ff94ae73668 100644
--- a/src/Tasks/GenerateBootstrapper.cs
+++ b/src/Tasks/GenerateBootstrapper.cs
@@ -118,10 +118,9 @@ public override bool Execute()
 
                 foreach (Product product in products)
                 {
-                    if (items.ContainsKey(product.ProductCode))
+                    if (items.Remove(product.ProductCode))
                     {
                         settings.ProductBuilders.Add(product.ProductBuilder);
-                        items.Remove(product.ProductCode);
                     }
                 }
 
diff --git a/src/Tasks/InstalledSDKResolver.cs b/src/Tasks/InstalledSDKResolver.cs
index 427cc8c86eb..ac0ff362d0b 100644
--- a/src/Tasks/InstalledSDKResolver.cs
+++ b/src/Tasks/InstalledSDKResolver.cs
@@ -52,10 +52,8 @@ out bool userRequestedSpecificFile
             if (assemblyName != null)
             {
                 // We have found a resolved SDK item that matches the one on the reference items.
-                if (_resolvedSDKs.ContainsKey(sdkName))
+                if (_resolvedSDKs.TryGetValue(sdkName, out ITaskItem resolvedSDK))
                 {
-                    ITaskItem resolvedSDK = _resolvedSDKs[sdkName];
-
                     string sdkDirectory = resolvedSDK.ItemSpec;
                     string configuration = resolvedSDK.GetMetadata("TargetedSDKConfiguration");
                     string architecture = resolvedSDK.GetMetadata("TargetedSDKArchitecture");
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index de2da27930b..0d5fe24e603 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -611,10 +611,8 @@ string toolsVersion
 
                         foreach (string targetName in nonNullTargetList)
                         {
-                            if (targetOutputsPerProject[i].ContainsKey(targetName))
+                            if (targetOutputsPerProject[i].TryGetValue(targetName, out ITaskItem[] outputItemsFromTarget))
                             {
-                                ITaskItem[] outputItemsFromTarget = targetOutputsPerProject[i][targetName];
-
                                 foreach (ITaskItem outputItemFromTarget in outputItemsFromTarget)
                                 {
                                     // No need to rebase if the calling project is the same as the callee project 
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index d5a7628a245..55ca4152e4e 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -65,9 +65,11 @@ public ApplicationManifest(string targetFrameworkVersion)
         }
 
         /// <summary>
-        /// Indicates the application configuration file.
-        /// For a Win32 native manifest, this input is ignored.
+        /// Gets or sets the application configuration file.
         /// </summary>
+        /// <remarks>
+        /// For a Win32 native manifest, this input is ignored.
+        /// </remarks>
         [XmlIgnore]
         public string ConfigFile
         {
@@ -91,7 +93,7 @@ public override AssemblyReference EntryPoint
         }
 
         /// <summary>
-        /// Specifies the target framework version
+        /// Gets or sets the target framework version
         /// </summary>
         [XmlIgnore]
         public string TargetFrameworkVersion
@@ -101,7 +103,7 @@ public string TargetFrameworkVersion
         }
 
         /// <summary>
-        /// Specifies the link to use if there is a failure launching the application.
+        /// Gets or sets the link to use if there is a failure launching the application.
         /// The specified value should be a fully qualified URL or UNC path.
         /// </summary>
         [XmlIgnore]
@@ -162,8 +164,9 @@ private bool WinXPRequired
                                                              (_fileAssociationList = new FileAssociationCollection(_fileAssociations));
 
         /// <summary>
-        /// If true, the application will run in IE using WPF's xbap application model.
+        /// Gets or sets a value that indicates whether the application will run in IE using WPF's XBAP application model.
         /// </summary>
+        /// <value><see langword="true" /> if the application will run in IE using WPF's XBAP application model; otherwise, <see langword="false" />.</value>
         [XmlIgnore]
         public bool HostInBrowser
         {
@@ -172,11 +175,13 @@ public bool HostInBrowser
         }
 
         /// <summary>
-        /// Indicates the application icon file.
+        /// Gets or sets the application icon file.
+        /// </summary>
+        /// <remarks>
         /// The application icon is expressed in the generated application manifest and is used for the start menu and Add/Remove Programs dialog.
         /// If this input is not specified then a default icon is used.
         /// For a Win32 native manifest, this input is ignored.
-        /// </summary>
+        /// </remarks>
         [XmlIgnore]
         public string IconFile
         {
@@ -185,7 +190,7 @@ public string IconFile
         }
 
         /// <summary>
-        /// Indicates whether the manifest is a ClickOnce application manifest or a native Win32 application manifest.
+        /// Gets or sets a value that indicates whether the manifest is a ClickOnce application manifest or a native Win32 application manifest.
         /// </summary>
         [XmlIgnore]
         public bool IsClickOnceManifest
@@ -195,12 +200,14 @@ public bool IsClickOnceManifest
         }
 
         /// <summary>
-        /// Specifies the maximum allowable length of a file path in a ClickOnce application deployment.
+        /// Gets or sets the maximum allowable length of a file path in a ClickOnce application deployment.
+        /// </summary>
+        /// <remarks>
         /// If this value is specified, then the length of each file path in the application is checked against this limit.
         /// Any items that exceed the limit will result in a warning message.
         /// If this input is not specified or is zero, then no checking is performed.
         /// For a Win32 native manifest, this input is ignored.
-        /// </summary>
+        /// </remarks>
         [XmlIgnore]
         public int MaxTargetPath
         {
@@ -235,7 +242,7 @@ internal override void OnBeforeSave()
         }
 
         /// <summary>
-        /// Specifies a textual description for the OS dependency.
+        /// Gets or sets a textual description for the OS dependency.
         /// </summary>
         [XmlIgnore]
         public string OSDescription
@@ -245,7 +252,7 @@ public string OSDescription
         }
 
         /// <summary>
-        /// Specifies a support URL for the OS dependency.
+        /// Gets or sets a support URL for the OS dependency.
         /// </summary>
         [XmlIgnore]
         public string OSSupportUrl
@@ -255,13 +262,15 @@ public string OSSupportUrl
         }
 
         /// <summary>
-        /// Specifies the minimum required OS version required by the application.
-        /// An example value is "5.1.2600.0" for Windows XP.
-        /// If this input is not specified a default value is used.
-        /// The default value is the minimum supported OS of the .NET Framework, which is "4.10.0.0" for Windows 98SE.
-        /// However, if the application contains any native or Reg-Free COM references, then the default will be the Windows XP version.
-        /// For a Win32 native manifest, this input is ignored.
+        /// Gets or sets the minimum OS version required by the application.
         /// </summary>
+        /// <remarks>
+        /// An example value is "5.1.2600.0" for Windows XP.        
+        /// If you don't specify a value, a default value is used.
+        /// The default value is the minimum supported OS of the .NET Framework, which is "4.10.0.0" for Windows 98 Second Edition.
+        /// However, if the application contains any native or Reg-Free COM references, then the default is the Windows XP version, which is "5.1.2600.0".
+        /// For a Win32 native manifest, this input is ignored.
+        /// </remarks>
         [XmlIgnore]
         public string OSVersion
         {
@@ -304,10 +313,12 @@ public string OSVersion
         }
 
         /// <summary>
-        /// Specifies the name of the application.
+        /// Gets or sets the name of the application.
+        /// </summary>
+        /// <remarks>
         /// If this input is not specified then the Product is not written into the Application Manifest
         /// This name is used for the shortcut name on the Start menu and is part of the name that appears in the Add/Remove Programs dialog.
-        /// </summary>
+        /// </remarks>
         [XmlIgnore]
         public string Product
         {
@@ -316,10 +327,12 @@ public string Product
         }
 
         /// <summary>
-        /// Specifies the publisher of the application.
-        /// If this input is not specified then the Publisher is not written into the Application Manifest
-        /// This name is used for the folder name on the Start menu and is part of the name that appears in the Add/Remove Programs dialog.
+        /// Gets or sets the publisher of the application.
         /// </summary>
+        /// <remarks>
+        /// If this input is not, specified then the Publisher is not written into the Application Manifest
+        /// This name is used for the folder name on the Start menu and is part of the name that appears in the Add/Remove Programs dialog.
+        /// </remarks>
         [XmlIgnore]
         public string Publisher
         {
@@ -328,9 +341,11 @@ public string Publisher
         }
 
         /// <summary>
-        /// Specifies the suite name of the application.
-        /// This name is used for the sub-folder name on the Start menu (as a child of the publisher)
+        /// Gets or sets the suite name of the application.
         /// </summary>
+        /// <remarks>
+        /// This name is used for the sub-folder name on the Start menu (as a child of the publisher)
+        /// </remarks>
         [XmlIgnore]
         public string SuiteName
         {
@@ -339,9 +354,11 @@ public string SuiteName
         }
 
         /// <summary>
-        /// Specifies the link that appears in the Add/Remove Programs dialog for the application.
-        /// The specified value should be a fully qualified URL or UNC path.
+        /// Gets or sets the link that appears in the Add/Remove Programs dialog for the application.
         /// </summary>
+        /// <remarks>
+        /// The specified value should be a fully qualified URL or UNC path.
+        /// </remarks>
         [XmlIgnore]
         public string SupportUrl
         {
@@ -350,7 +367,7 @@ public string SupportUrl
         }
 
         /// <summary>
-        /// Specifies a trust object defining the application security.
+        /// Gets or sets a trust object defining the application security.
         /// </summary>
         [XmlIgnore]
         public TrustInfo TrustInfo
@@ -360,8 +377,11 @@ public TrustInfo TrustInfo
         }
 
         /// <summary>
-        /// If true, the install will use the settings in the application manifest in the trust prompt.
+        /// Gets or sets a value that indicates whether the install will use the settings in the application manifest in the trust prompt.
         /// </summary>
+        /// <value>
+        /// <see langword="true" /> to use the settings in the application manifest in the trust prompt; otherwise, <see langword="false" />.
+        /// </value>
         [XmlIgnore]
         public bool UseApplicationTrust
         {
@@ -421,25 +441,25 @@ private void ValidateCom()
                             if (!String.IsNullOrEmpty(comInfo.ClsId))
                             {
                                 string key = comInfo.ClsId.ToLowerInvariant();
-                                if (!clsidList.ContainsKey(key))
+                                if (!clsidList.TryGetValue(key, out ComInfo info))
                                 {
                                     clsidList.Add(key, comInfo);
                                 }
                                 else
                                 {
-                                    OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "clsid", comInfo.ComponentFileName, comInfo.ClsId, comInfo.ManifestFileName, clsidList[key].ManifestFileName);
+                                    OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "clsid", comInfo.ComponentFileName, comInfo.ClsId, comInfo.ManifestFileName, info.ManifestFileName);
                                 }
                             }
                             if (!String.IsNullOrEmpty(comInfo.TlbId))
                             {
                                 string key = comInfo.TlbId.ToLowerInvariant();
-                                if (!tlbidList.ContainsKey(key))
+                                if (!tlbidList.TryGetValue(key, out ComInfo info))
                                 {
                                     tlbidList.Add(key, comInfo);
                                 }
                                 else
                                 {
-                                    OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "tlbid", comInfo.ComponentFileName, comInfo.TlbId, comInfo.ManifestFileName, tlbidList[key].ManifestFileName);
+                                    OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "tlbid", comInfo.ComponentFileName, comInfo.TlbId, comInfo.ManifestFileName, info.ManifestFileName);
                                 }
                             }
                         }
@@ -455,13 +475,13 @@ private void ValidateCom()
                     foreach (ComClass comClass in file.ComClasses)
                     {
                         string key = comClass.ClsId.ToLowerInvariant();
-                        if (!clsidList.ContainsKey(key))
+                        if (!clsidList.TryGetValue(key, out ComInfo info))
                         {
                             clsidList.Add(key, new ComInfo(outputFileName, file.TargetPath, comClass.ClsId, null));
                         }
                         else
                         {
-                            OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "clsid", file.ToString(), comClass.ClsId, outputFileName, clsidList[key].ManifestFileName);
+                            OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "clsid", file.ToString(), comClass.ClsId, outputFileName, info.ManifestFileName);
                         }
                     }
                 }
@@ -470,13 +490,13 @@ private void ValidateCom()
                     foreach (TypeLib typeLib in file.TypeLibs)
                     {
                         string key = typeLib.TlbId.ToLowerInvariant();
-                        if (!tlbidList.ContainsKey(key))
+                        if (!tlbidList.TryGetValue(key, out ComInfo info))
                         {
                             tlbidList.Add(key, new ComInfo(outputFileName, file.TargetPath, null, typeLib.TlbId));
                         }
                         else
                         {
-                            OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "tlbid", file.ToString(), typeLib.TlbId, outputFileName, tlbidList[key].ManifestFileName);
+                            OutputMessages.AddErrorMessage("GenerateManifest.DuplicateComDefinition", "tlbid", file.ToString(), typeLib.TlbId, outputFileName, info.ManifestFileName);
                         }
                     }
                 }
diff --git a/src/Tasks/Microsoft.CSharp.CrossTargeting.targets b/src/Tasks/Microsoft.CSharp.CrossTargeting.targets
index 68d1aa0797a..26ae23579d9 100644
--- a/src/Tasks/Microsoft.CSharp.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.CSharp.CrossTargeting.targets
@@ -17,6 +17,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
      <CSharpDesignTimeTargetsPath Condition="'$(CSharpDesignTimeTargetsPath)'==''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\Managed\Microsoft.CSharp.DesignTime.targets</CSharpDesignTimeTargetsPath>
   </PropertyGroup>
+
   <Import Project="$(CSharpDesignTimeTargetsPath)" Condition="'$(CSharpDesignTimeTargetsPath)' != '' and Exists('$(CSharpDesignTimeTargetsPath)')" />
 
   <Import Project="Microsoft.Common.CrossTargeting.targets" />
diff --git a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
index a14d5b42df4..f5955642de1 100644
--- a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
@@ -8,7 +8,7 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 
 This file defines the steps in the standard build process specific for C# .NET projects.
 For example, it contains the step that actually calls the C# compiler.  The remainder
-of the build process is defined in Microsoft.Common.targets, which is imported by 
+of the build process is defined in Microsoft.Common.targets, which is imported by
 this file.
 
 Copyright (C) Microsoft Corporation. All rights reserved.
@@ -66,14 +66,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <!--
     The CreateManifestResourceNames target create the manifest resource names from the .RESX
     files.
-    
+
         [IN]
         @(EmbeddedResource) - The list of EmbeddedResource items that have been pre-processed to add metadata about resource type
                               Expected Metadata "Type" can either be "Resx" or "Non-Resx"
 
         [OUT]
-        @(EmbeddedResource) - EmbeddedResource items with metadata         
-        
+        @(EmbeddedResource) - EmbeddedResource items with metadata
+
     For C# applications the transformation is like:
 
         Resources1.resx => RootNamespace.Resources1 => Build into main assembly
@@ -83,30 +83,29 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     For other project systems, this transformation may be different.
     -->
+
     <PropertyGroup>
         <CreateManifestResourceNamesDependsOn></CreateManifestResourceNamesDependsOn>
     </PropertyGroup>
+
     <Target
         Name="CreateManifestResourceNames"
         Condition="'@(EmbeddedResource)' != ''"
         DependsOnTargets="$(CreateManifestResourceNamesDependsOn)"
         >
-
         <ItemGroup>
             <_Temporary Remove="@(_Temporary)" />
         </ItemGroup>
-        
+
         <!-- Create manifest names for culture and non-culture Resx files, and for non-culture Non-Resx resources -->
         <CreateCSharpManifestResourceName
               ResourceFiles="@(EmbeddedResource)"
               RootNamespace="$(RootNamespace)"
               UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)"
               Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and ('%(EmbeddedResource.WithCulture)' == 'false' or '%(EmbeddedResource.Type)' == 'Resx')">
-
             <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
-
         </CreateCSharpManifestResourceName>
-        
+
         <!-- Create manifest names for all culture non-resx resources -->
         <CreateCSharpManifestResourceName
               ResourceFiles="@(EmbeddedResource)"
@@ -114,9 +113,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               PrependCultureAsDirectory="false"
               UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)"
               Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and '%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
-
             <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
-
         </CreateCSharpManifestResourceName>
 
         <ItemGroup>
@@ -124,23 +121,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.
             <EmbeddedResource Include="@(_Temporary)" />
             <_Temporary Remove="@(_Temporary)" />
         </ItemGroup>
-              
     </Target>
 
     <Target
         Name="ResolveCodeAnalysisRuleSet"
         Condition="'$(CodeAnalysisRuleSet)' != ''"
         >
-
         <ResolveCodeAnalysisRuleSet
             CodeAnalysisRuleSet="$(CodeAnalysisRuleSet)"
             CodeAnalysisRuleSetDirectories="$(CodeAnalysisRuleSetDirectories)"
             MSBuildProjectDirectory="$(MSBuildProjectDirectory)">
-
             <Output TaskParameter="ResolvedCodeAnalysisRuleSet" PropertyName="ResolvedCodeAnalysisRuleSet" />
-
         </ResolveCodeAnalysisRuleSet>
-
     </Target>
 
     <ItemGroup>
@@ -167,7 +159,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <CoreCompileDependsOn>$(CoreCompileDependsOn);_ComputeNonExistentFileProperty;ResolveCodeAnalysisRuleSet</CoreCompileDependsOn>
         <ExportWinMDFile Condition="'$(ExportWinMDFile)' == '' and '$(OutputType)' == 'WinMDObj'">true</ExportWinMDFile>
     </PropertyGroup>
- 
+
 <!--
       The XamlPreCompile target must remain identical to
       the CoreCompile target in Microsoft.CSharp.Core.targets.
@@ -183,14 +175,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                 @(ReferencePath);
                 @(CompiledLicenseFile);
                 @(LinkResource);
-                @(EmbeddedDocumentation); 
+                @(EmbeddedDocumentation);
                 $(Win32Resource);
                 $(Win32Manifest);
                 @(CustomAdditionalCompileInputs);
                 @(Page);
                 @(ApplicationDefinition);
                 $(ResolvedCodeAnalysisRuleSet)"
-                  
+
         Outputs="@(DocFileItem);
                  @(XamlIntermediateAssembly);
                  @(_DebugSymbolsIntermediatePath);
@@ -217,13 +209,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                 <EmbedInteropTypes/>
             </ReferencePath>
         </ItemGroup>
-        
+
         <PropertyGroup>
             <!-- If the user has specified AppConfigForCompiler, we'll use it. If they have not, but they set UseAppConfigForCompiler,
                  then we'll use AppConfig -->
             <AppConfigForCompiler Condition="'$(AppConfigForCompiler)' == '' and '$(UseAppConfigForCompiler)' == 'true'">$(AppConfig)</AppConfigForCompiler>
-            
-            <!-- If we are targeting winmdobj we want to specifically the pdbFile property since we do not want it to collide with the output of winmdexp--> 
+
+            <!-- If we are targeting winmdobj we want to specifically the pdbFile property since we do not want it to collide with the output of winmdexp-->
             <PdbFile Condition="'$(PdbFile)' == '' and '$(OutputType)' == 'winmdobj' and '$(_DebugSymbolsProduced)' == 'true'">$(IntermediateOutputPath)$(TargetName).compile.pdb</PdbFile>
         </PropertyGroup>
 
@@ -231,12 +223,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <PropertyGroup Condition="('$(TargetFrameworkVersion)' == 'v4.0')">
             <Prefer32Bit>false</Prefer32Bit>
         </PropertyGroup>
-       
+
         <ItemGroup Condition="('$(AdditionalFileItemNames)' != '')">
           <AdditionalFileItems Include="$(AdditionalFileItemNames)" />
           <AdditionalFiles Include="@(%(AdditionalFileItems.Identity))" />
         </ItemGroup>
-        
+
        <PropertyGroup Condition="'$(UseSharedCompilation)' == ''">
          <UseSharedCompilation>true</UseSharedCompilation>
        </PropertyGroup>
@@ -259,7 +251,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               DisabledWarnings="$(NoWarn)"
               DocumentationFile="@(DocFileItem)"
               EmitDebugInformation="$(DebugSymbols)"
-              EnvironmentVariables="$(CscEnvironment)"              
+              EnvironmentVariables="$(CscEnvironment)"
               ErrorEndLocation="$(ErrorEndLocation)"
               ErrorLog="$(ErrorLog)"
               ErrorReport="$(ErrorReport)"
@@ -279,7 +271,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               Nullable="$(Nullable)"
               Optimize="$(Optimize)"
               OutputAssembly="@(XamlIntermediateAssembly)"
-              PdbFile="$(PdbFile)" 
+              PdbFile="$(PdbFile)"
               Platform="$(PlatformTarget)"
               Prefer32Bit="$(Prefer32Bit)"
               PreferredUILang="$(PreferredUILang)"
@@ -322,15 +314,17 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </PropertyGroup>
 
     <Import Project="$(CSharpCoreTargetsPath)" />
-    
+
     <!-- Import design time targets for Roslyn Project System. These are only available if Visual Studio is installed. -->
     <!-- Import design time targets before the common targets, which import targets from Nuget. -->
     <PropertyGroup>
        <CSharpDesignTimeTargetsPath Condition="'$(CSharpDesignTimeTargetsPath)'==''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\Managed\Microsoft.CSharp.DesignTime.targets</CSharpDesignTimeTargetsPath>
     </PropertyGroup>
+
     <Import Project="$(CSharpDesignTimeTargetsPath)" Condition="'$(CSharpDesignTimeTargetsPath)' != '' and Exists('$(CSharpDesignTimeTargetsPath)')" />
 
     <Import Project="Microsoft.Common.targets" />
+
     <Import Project="$(MSBuildToolsPath)\Microsoft.ServiceModel.targets" Condition="('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.0' and '$(TargetFrameworkVersion)' != 'v3.5') and Exists('$(MSBuildToolsPath)\Microsoft.ServiceModel.targets')"/>
 
     <Target Name="_SetTargetFrameworkMonikerAttribute" BeforeTargets="GenerateTargetFrameworkMonikerAttribute">
@@ -346,7 +340,6 @@ using System.Reflection%3b
 
     <PropertyGroup>
        <Utf8Output Condition="'$(Utf8Output)' == ''">true</Utf8Output>
-
       <!-- NoCompilerStandardLib maps to the compiler's /nostdlib option. By default we always
            want that switch to be passed to the compiler so that either we or the user
            provides the references
@@ -354,18 +347,16 @@ using System.Reflection%3b
            so only if NoStdLib isn't set to true, will we provide the standard references
       -->
       <NoCompilerStandardLib Condition=" '$(NoCompilerStandardLib)' == '' ">true</NoCompilerStandardLib>
-
       <ErrorEndLocation Condition="'$(BuildingInsideVisualStudio)' == 'true' and '$(ErrorEndLocation)' == ''">true</ErrorEndLocation>
-
        <!-- When building inside VS, by default use the same language for compiler messages as VS itself does. -->
        <PreferredUILang Condition="'$(BuildingInsideVisualStudio)' == 'true' and '$(PreferredUILang)' == ''">$([System.Globalization.CultureInfo]::CurrentUICulture.Name)</PreferredUILang>
     </PropertyGroup>
-    
+
     <!-- Add any "automatic" compiler references that need to be resolved when NoCompilerStandardLib is set
          but the user hasn't told us to not include standard references -->
     <ItemGroup Condition=" '$(NoCompilerStandardLib)' == 'true' and '$(NoStdLib)' != 'true' ">
       <!-- Note that unlike VB, C# does not automatically locate System.dll as a "standard library"
-           instead the reference is always passed from the project. Also, for mscorlib.dll 
+           instead the reference is always passed from the project. Also, for mscorlib.dll
            we need to provide the explicit location in order to avoid resolving from, e.g.,
            {CandidateAssemblyFiles}.
       -->
diff --git a/src/Tasks/Microsoft.CSharp.targets b/src/Tasks/Microsoft.CSharp.targets
index beda9624db2..80361f7c441 100644
--- a/src/Tasks/Microsoft.CSharp.targets
+++ b/src/Tasks/Microsoft.CSharp.targets
@@ -8,7 +8,7 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 
 This file defines the steps in the standard build process specific for C# .NET projects.
 For example, it contains the step that actually calls the C# compiler.  The remainder
-of the build process is defined in Microsoft.Common.targets, which is imported by 
+of the build process is defined in Microsoft.Common.targets, which is imported by
 this file.
 
 Copyright (C) Microsoft Corporation. All rights reserved.
@@ -16,26 +16,26 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
    <!--
-        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed 
-        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead 
-        just used whatever ToolsVersion was in the project file if it existed on the machine, and 
-        only forced 4.0 if that ToolsVersion did not exist.  
-
-        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio, 
-        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected 
-        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved 
-        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist 
+        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed
+        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead
+        just used whatever ToolsVersion was in the project file if it existed on the machine, and
+        only forced 4.0 if that ToolsVersion did not exist.
+
+        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio,
+        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected
+        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved
+        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist
         as part of the .NET Framework.  Only if we're using the new MSBuild will we point to the current
-        targets. 
+        targets.
    -->
 
    <Choose>
       <When Condition="'$(MSBuildAssemblyVersion)' == ''">
          <PropertyGroup>
             <CSharpTargetsPath>$(MSBuildFrameworkToolsPath)\Microsoft.CSharp.targets</CSharpTargetsPath>
-
-            <!-- Same condition as in .NET 4.5 C# targets so that we can override the behavior where it defaults to 
+            <!-- Same condition as in .NET 4.5 C# targets so that we can override the behavior where it defaults to
                  MSBuildToolsPath, which would be incorrect in this case -->
             <CscToolPath Condition="'$(CscToolPath)' == '' and '$(BuildingInsideVisualStudio)' != 'true'">$(MsBuildFrameworkToolsPath)</CscToolPath>
          </PropertyGroup>
@@ -54,14 +54,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
 
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
-      <!-- 
-           Overrides for the Microsoft.Common.targets extension targets. Used to make sure that only the imports we specify 
-           (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Defined here because 
-           Microsoft.CSharp.targets imports Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath, 
+      <!--
+           Overrides for the Microsoft.Common.targets extension targets. Used to make sure that only the imports we specify
+           (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Defined here because
+           Microsoft.CSharp.targets imports Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath,
            so defining these in Microsoft.Common.targets alone would not suffice for C# projects.
 
            NOTE: This logic is duplicated in Microsoft.VisualBasic.targets (VB has the same problem) and in Microsoft.Common.targets
-           (for anyone who DOES import it directly), so for any changes to this logic in this file, please also edit the other two. 
+           (for anyone who DOES import it directly), so for any changes to this logic in this file, please also edit the other two.
        -->
       <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">$(ImportByWildcardBeforeMicrosoftCommonTargets)</ImportByWildcardBefore40MicrosoftCommonTargets>
       <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">true</ImportByWildcardBefore40MicrosoftCommonTargets>
@@ -106,15 +106,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
    </PropertyGroup>
 
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == '' and ('$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == 'Silverlight' or ('$(TargetFrameworkIdentifier)' == '' and ('$(TargetRuntime)' == 'Managed' or '$(TargetRuntime)' == '')))">
-       <!-- 
-            Overrides for the Microsoft.NETFramework.props extension targets. Used to make sure that only the imports we specify 
-            (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Required because 
-            Microsoft.Common.targets imports it from the current directory, so we don't get a chance to redirect these in its 
+       <!--
+            Overrides for the Microsoft.NETFramework.props extension targets. Used to make sure that only the imports we specify
+            (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Required because
+            Microsoft.Common.targets imports it from the current directory, so we don't get a chance to redirect these in its
             own redirection targets.
 
             NOTE: This logic is duplicated in Microsoft.VisualBasic.targets and in Microsoft.Common.targets because VB and C#
-            import Microsoft.Common.targets from the current directory and thus don't get the benefit of these redirections either, 
-            so for any changes to this logic in this file, please also edit the other two. 
+            import Microsoft.Common.targets from the current directory and thus don't get the benefit of these redirections either,
+            so for any changes to this logic in this file, please also edit the other two.
         -->
       <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">$(ImportByWildcardBeforeMicrosoftNetFrameworkProps)</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
       <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">true</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
@@ -137,24 +137,24 @@ Copyright (C) Microsoft Corporation. All rights reserved.
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportBefore')"/>
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportBefore')"/>
-   </ImportGroup> 
+   </ImportGroup>
 
-   <!-- Really should be imported right before Microsoft.Common.targets, but because Microsoft.CSharp.targets imports 
+   <!-- Really should be imported right before Microsoft.Common.targets, but because Microsoft.CSharp.targets imports
         Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-        targets), we're stuck doing it this way instead. --> 
+        targets), we're stuck doing it this way instead. -->
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')"/>
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')"/>
-   </ImportGroup> 
+   </ImportGroup>
 
-   <!-- Really should be imported right before Microsoft.NETFramework.props, but because Microsoft.CSharp.targets imports 
+   <!-- Really should be imported right before Microsoft.NETFramework.props, but because Microsoft.CSharp.targets imports
         Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-        targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this 
-        way instead. --> 
+        targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this
+        way instead. -->
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')"/>
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')"/>
-   </ImportGroup> 
+   </ImportGroup>
 
    <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.Before.targets" />
 
@@ -164,31 +164,32 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
    <!-- Really should be imported right after Microsoft.NETFramework.props, but because Microsoft.CSharp.targets imports
         Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-        targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this 
-        way instead. --> 
+        targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this
+        way instead. -->
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')"/>
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')"/>
-   </ImportGroup> 
+   </ImportGroup>
 
-   <!-- Really should be imported right after Microsoft.Common.targets, but because Microsoft.CSharp.targets imports 
+   <!-- Really should be imported right after Microsoft.Common.targets, but because Microsoft.CSharp.targets imports
         Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-        targets), we're stuck doing it this way instead. --> 
+        targets), we're stuck doing it this way instead. -->
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')"/>
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')"/>
-    </ImportGroup> 
+    </ImportGroup>
 
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportAfter')"/>
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCSharpTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.CSharp.targets\ImportAfter')"/>
-   </ImportGroup> 
+   </ImportGroup>
 
-   <!-- Fix up FrameworkPathOverride, which is primarily used to determine the location of mscorlib.dll in the 
-        (relatively uncommon) situation where the reference assemblies, in which it's usually found, are not 
-        installed.  Defined here rather than in Microsoft.Common.targets because the .NET Microsoft.CSharp.targets 
+   <!-- Fix up FrameworkPathOverride, which is primarily used to determine the location of mscorlib.dll in the
+        (relatively uncommon) situation where the reference assemblies, in which it's usually found, are not
+        installed.  Defined here rather than in Microsoft.Common.targets because the .NET Microsoft.CSharp.targets
         imports Microsoft.Common.targets from the current directory. -->
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <FrameworkPathOverride Condition="!Exists('$(FrameworkPathOverride)\mscorlib.dll')">$(MSBuildFrameworkToolsPath)</FrameworkPathOverride>
    </PropertyGroup>
+
 </Project>
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index c5ce7a2d79e..f59b407d959 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -11,10 +11,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
   <PropertyGroup>
     <BuildInParallel Condition="'$(BuildInParallel)' == ''">true</BuildInParallel>
     <ImportByWildcardBeforeMicrosoftCommonCrossTargetingTargets Condition="'$(ImportByWildcardBeforeMicrosoftCommonCrossTargetingTargets)' == ''">true</ImportByWildcardBeforeMicrosoftCommonCrossTargetingTargets>
   </PropertyGroup>
+
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.CrossTargeting.targets\ImportBefore\*.targets"
           Condition="'$(ImportByWildcardBeforeMicrosoftCommonCrossTargetingTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.CrossTargeting.targets\ImportBefore')"/>
 
@@ -33,21 +35,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="Result"
         PropertyName="_AdditionalPropertiesFromProject"/>
     </CombineXmlElements>
-    
+
     <ItemGroup>
       <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
         <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
         <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
         <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
         <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>
-
         <HasSingleTargetFramework>false</HasSingleTargetFramework>
-
         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
         <IsRidAgnostic>false</IsRidAgnostic>
         <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
+
   </Target>
 
   <Target Name="_ComputeTargetFrameworkItems" Returns="@(InnerOutput)">
@@ -178,7 +179,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <ImportByWildcardAfterMicrosoftCommonCrossTargetingTargets Condition="'$(ImportByWildcardAfterMicrosoftCommonCrossTargetingTargets)' == ''">true</ImportByWildcardAfterMicrosoftCommonCrossTargetingTargets>
   </PropertyGroup>
-  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.CrossTargeting.targets\ImportAfter\*.targets" 
+
+  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.CrossTargeting.targets\ImportAfter\*.targets"
           Condition="'$(ImportByWildcardAfterMicrosoftCommonCrossTargetingTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.CrossTargeting.targets\ImportAfter')"/>
 
   <!--
@@ -188,8 +190,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     Each package management system should use a unique moniker to avoid collisions.  It is a wild-card iport so the package
     management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
 
-    This is the same import that would happen in an inner (non-cross targeting) build. Package management systems are responsible for generating 
-    appropriate conditions based on $(IsCrossTargetingBuild) to pull in only those package targets that are meant to participate in a cross-targeting 
+    This is the same import that would happen in an inner (non-cross targeting) build. Package management systems are responsible for generating
+    appropriate conditions based on $(IsCrossTargetingBuild) to pull in only those package targets that are meant to participate in a cross-targeting
     build.
   -->
   <PropertyGroup>
@@ -202,19 +204,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ImportDirectoryBuildTargets Condition="'$(ImportDirectoryBuildTargets)' == ''">true</ImportDirectoryBuildTargets>
   </PropertyGroup>
 
-  <!-- 
+  <!--
         Determine the path to the directory build targets file if the user did not disable $(ImportDirectoryBuildTargets) and
         they did not already specify an absolute path to use via $(DirectoryBuildTargetsPath)
     -->
   <PropertyGroup Condition="'$(ImportDirectoryBuildTargets)' == 'true' and '$(DirectoryBuildTargetsPath)' == ''">
     <_DirectoryBuildTargetsFile Condition="'$(_DirectoryBuildTargetsFile)' == ''">Directory.Build.targets</_DirectoryBuildTargetsFile>
     <_DirectoryBuildTargetsBasePath Condition="'$(_DirectoryBuildTargetsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), '$(_DirectoryBuildTargetsFile)'))</_DirectoryBuildTargetsBasePath>
-    <DirectoryBuildTargetsPath Condition="'$(_DirectoryBuildTargetsBasePath)' != '' and '$(_DirectoryBuildTargetsFile)' != ''">$([MSBuild]::NormalizePath('$(_DirectoryBuildTargetsBasePath)', '$(_DirectoryBuildTargetsFile)'))</DirectoryBuildTargetsPath>
+    <DirectoryBuildTargetsPath Condition="'$(_DirectoryBuildTargetsBasePath)' != '' and '$(_DirectoryBuildTargetsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildTargetsBasePath)', '$(_DirectoryBuildTargetsFile)'))</DirectoryBuildTargetsPath>
   </PropertyGroup>
 
   <Import Project="$(DirectoryBuildTargetsPath)" Condition="'$(ImportDirectoryBuildTargets)' == 'true' and exists('$(DirectoryBuildTargetsPath)')"/>
 
   <!-- TODO: https://github.com/Microsoft/msbuild/issues/1062: Remove this temporary hook when possible. -->
-  <Import Project="$(CoreCrossTargetingTargetsPath)" 
+  <Import Project="$(CoreCrossTargetingTargetsPath)"
           Condition="'$(CoreCrossTargetingTargetsPath)' != '' and Exists('$(CoreCrossTargetingTargetsPath)')" />
+
 </Project>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 18d7712ad5c..668684ed3c6 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -30,7 +30,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(MSBuildProjectFullPath).user" Condition="Exists('$(MSBuildProjectFullPath).user')"/>
 
-
   <!-- VS10 without SP1 and without VS11 will not have VisualStudioVersion set, so do that here -->
   <PropertyGroup>
     <VisualStudioVersion Condition="'$(VisualStudioVersion)' == ''">10.0</VisualStudioVersion>
@@ -151,19 +150,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <Configuration Condition="'$(Configuration)' == ''">Debug</Configuration>
     <ConfigurationName Condition="'$(ConfigurationName)' == ''">$(Configuration)</ConfigurationName>
 
-    <BaseOutputPath>$([MSBuild]::EnsureTrailingSlash($([MSBuild]::ValueOrDefault('$(BaseOutputPath)', 'bin'))))</BaseOutputPath>
-    <OutputPath Condition="'$(OutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">$([System.IO.Path]::Combine('$(BaseOutputPath)', '$(Configuration)'))</OutputPath>
-    <OutputPath Condition="'$(OutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">$([System.IO.Path]::Combine('$(BaseOutputPath)', '$(PlatformName)', '$(Configuration)'))</OutputPath>
-    <OutputPath>$([MSBuild]::EnsureTrailingSlash('$(OutputPath)'))</OutputPath>
-
-    <BaseIntermediateOutputPath>$([MSBuild]::EnsureTrailingSlash($([MSBuild]::ValueOrDefault('$(BaseIntermediateOutputPath)', 'obj'))))</BaseIntermediateOutputPath>
-    <IntermediateOutputPath Condition="'$(IntermediateOutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">$([System.IO.Path]::Combine('$(BaseIntermediateOutputPath)', '$(Configuration)'))</IntermediateOutputPath>
-    <IntermediateOutputPath Condition="'$(IntermediateOutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">$([System.IO.Path]::Combine('$(BaseIntermediateOutputPath)', '$(PlatformName)', '$(Configuration)'))</IntermediateOutputPath>
-    <IntermediateOutputPath>$([MSBuild]::EnsureTrailingSlash('$(IntermediateOutputPath)'))</IntermediateOutputPath>
+    <BaseOutputPath Condition="'$(BaseOutputPath)' == ''">bin\</BaseOutputPath>
+    <BaseOutputPath Condition="!HasTrailingSlash('$(BaseOutputPath)')">$(BaseOutputPath)\</BaseOutputPath>
+    <OutputPath Condition="'$(OutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">$(BaseOutputPath)$(Configuration)\</OutputPath>
+    <OutputPath Condition="'$(OutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">$(BaseOutputPath)$(PlatformName)\$(Configuration)\</OutputPath>
+    <OutputPath Condition="!HasTrailingSlash('$(OutputPath)')">$(OutputPath)\</OutputPath>
+
+    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)' == ''">obj\</BaseIntermediateOutputPath>
+    <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
+    <IntermediateOutputPath Condition="'$(IntermediateOutputPath)' == '' and '$(PlatformName)' == 'AnyCPU'">$(BaseIntermediateOutputPath)$(Configuration)\</IntermediateOutputPath>
+    <IntermediateOutputPath Condition="'$(IntermediateOutputPath)' == '' and '$(PlatformName)' != 'AnyCPU'">$(BaseIntermediateOutputPath)$(PlatformName)\$(Configuration)\</IntermediateOutputPath>
+    <IntermediateOutputPath Condition="!HasTrailingSlash('$(IntermediateOutputPath)')">$(IntermediateOutputPath)\</IntermediateOutputPath>
   </PropertyGroup>
 
   <PropertyGroup>
-
     <!-- Determine OutputType property from the legacy TargetType property -->
     <OutputType Condition=" '$(TargetType)' != ''">$(TargetType)</OutputType>
     <OutputType Condition=" '$(TargetType)' == 'Container' or '$(TargetType)' == 'DocumentContainer' ">library</OutputType>
@@ -221,18 +221,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <PropertyGroup>
-
     <!-- Required for enabling Team Build for packaging app package-generating projects -->
     <OutDirWasSpecified Condition=" '$(OutDir)'!='' and '$(OutDirWasSpecified)'=='' ">true</OutDirWasSpecified>
 
+    <OutDir Condition=" '$(OutDir)' == '' ">$(OutputPath)</OutDir>
     <!-- Example, bin\Debug\ -->
     <!-- Ensure OutDir has a trailing slash, so it can be concatenated -->
-    <OutDir>$([MSBuild]::EnsureTrailingSlash($([MSBuild]::ValueOrDefault('$(OutDir)', '$(OutputPath)'))))</OutDir>
+    <OutDir Condition="'$(OutDir)' != '' and !HasTrailingSlash('$(OutDir)')">$(OutDir)\</OutDir>
     <ProjectName Condition=" '$(ProjectName)' == '' ">$(MSBuildProjectName)</ProjectName>
     <!-- Example, MyProject -->
 
     <!-- For projects that generate app packages or ones that want a per-project output directory, update OutDir to include the project name -->
-    <OutDir Condition="'$(OutDir)' != '' and '$(OutDirWasSpecified)' == 'true' and (('$(WindowsAppContainer)' == 'true' and '$(GenerateProjectSpecificOutputFolder)' != 'false') or '$(GenerateProjectSpecificOutputFolder)' == 'true')">$([MSBuild]::EnsureTrailingSlash('$(OutDir)$(ProjectName)'))</OutDir>
+    <OutDir Condition="'$(OutDir)' != '' and '$(OutDirWasSpecified)' == 'true' and (('$(WindowsAppContainer)' == 'true' and '$(GenerateProjectSpecificOutputFolder)' != 'false') or '$(GenerateProjectSpecificOutputFolder)' == 'true')">$(OutDir)$(ProjectName)\</OutDir>
 
     <AssemblyName Condition=" '$(AssemblyName)'=='' ">$(MSBuildProjectName)</AssemblyName>
     <TargetName Condition="'$(TargetName)' == '' and '$(OutputType)' == 'winmdobj' and '$(RootNamespace)' != ''">$(RootNamespace)</TargetName>
@@ -318,7 +318,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         Condition intentionally omitted on this one, because it causes problems
         when we pick up the value of an environment variable named TargetDir
         -->
-    <TargetDir Condition="'$(OutDir)' != ''">$([MSBuild]::NormalizeDirectory('$(MSBuildProjectDirectory)', '$(OutDir)'))</TargetDir>
+    <TargetDir Condition="'$(OutDir)' != ''">$([MSBuild]::Escape($([System.IO.Path]::GetFullPath(`$([System.IO.Path]::Combine(`$(MSBuildProjectDirectory)`, `$(OutDir)`))`))))</TargetDir>
 
     <!-- Example, C:\MyProjects\MyProject\bin\Debug\MyAssembly.dll -->
     <TargetPath Condition=" '$(TargetPath)' == '' ">$(TargetDir)$(TargetFileName)</TargetPath>
@@ -346,6 +346,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <DevEnvDir Condition="'$(DevEnvDir)'==''">*Undefined*</DevEnvDir>
     <SolutionName Condition="'$(SolutionName)'==''">*Undefined*</SolutionName>
+    <SolutionFilterName Condition="'$(SolutionFilterName)'==''">*Undefined*</SolutionFilterName>
     <!-- Example, MySolution -->
     <SolutionFileName Condition="'$(SolutionFileName)'==''">*Undefined*</SolutionFileName>
     <!-- Example, MySolution.sln -->
@@ -362,10 +363,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <!-- It would be a breaking change to automatically turn on binding redirects for existing projects, so turn them on only when opting into a new framework. -->
     <AutoGenerateBindingRedirects Condition="'$(AutoGenerateBindingRedirects)' == '' and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetFrameworkVersion.TrimStart(vV))' >= '4.7.2'">true</AutoGenerateBindingRedirects>
   </PropertyGroup>
+
   <PropertyGroup Condition="'$(AutoUnifyAssemblyReferences)' == ''">
     <AutoUnifyAssemblyReferences>true</AutoUnifyAssemblyReferences>
     <AutoUnifyAssemblyReferences Condition="'$(GenerateBindingRedirectsOutputType)' == 'true' and '$(AutoGenerateBindingRedirects)' != 'true'">false</AutoUnifyAssemblyReferences>
   </PropertyGroup>
+
   <PropertyGroup>
     <CleanFile Condition="'$(CleanFile)'==''">$(MSBuildProjectFile).FileListAbsolute.txt</CleanFile>
     <!-- During DesignTime Builds, skip project reference build as Design time is only queueing information.-->
@@ -382,6 +385,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <_GenerateBindingRedirectsIntermediateAppConfig>$(IntermediateOutputPath)$(TargetFileName).config</_GenerateBindingRedirectsIntermediateAppConfig>
   </PropertyGroup>
+
   <ItemGroup>
     <IntermediateAssembly Include="$(IntermediateOutputPath)$(TargetName)$(TargetExt)"/>
     <FinalDocFile Include="@(DocFileItem->'$(OutDir)%(Filename)%(Extension)')"/>
@@ -402,12 +406,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <PropertyGroup Condition="'$(_DebugSymbolsProduced)' == 'true' and '$(OutputType)' == 'winmdobj'">
     <WinMDExpOutputPdb Condition="'$(WinMDExpOutputPdb)' == ''">$(IntermediateOutputPath)$(TargetName).pdb</WinMDExpOutputPdb>
-    <_WinMDDebugSymbolsOutputPath>$(OutDir)$([System.IO.Path]::GetFileName('$(WinMDExpOutputPdb)'))</_WinMDDebugSymbolsOutputPath>
+    <_WinMDDebugSymbolsOutputPath>$([System.IO.Path]::Combine('$(OutDir)', $([System.IO.Path]::GetFileName('$(WinMDExpOutputPdb)'))))</_WinMDDebugSymbolsOutputPath>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(OutputType)' == 'winmdobj' and '$(DocumentationFile)'!=''">
     <WinMDOutputDocumentationFile Condition="'$(WinMDOutputDocumentationFile)' == ''">$(IntermediateOutputPath)$(TargetName).xml</WinMDOutputDocumentationFile>
-    <_WinMDDocFileOutputPath>$(OutDir)$([System.IO.Path]::GetFileName('$(WinMDOutputDocumentationFile)'))</_WinMDDocFileOutputPath>
+    <_WinMDDocFileOutputPath>$([System.IO.Path]::Combine('$(OutDir)', $([System.IO.Path]::GetFileName('$(WinMDOutputDocumentationFile)'))))</_WinMDDocFileOutputPath>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(WinMDExpOutputWindowsMetadataFilename)' != ''">
@@ -479,7 +483,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <!-- Output location for publish target. -->
   <PropertyGroup>
-    <PublishDir>$([MSBuild]::EnsureTrailingSlash($([MSBuild]::ValueOrDefault('$(PublishDir)', '$(OutputPath)app.publish'))))</PublishDir>
+    <PublishDir Condition="'$(PublishDir)' != '' and !HasTrailingSlash('$(PublishDir)')">$(PublishDir)\</PublishDir>
+    <PublishDir Condition="'$(PublishDir)'==''">$(OutputPath)app.publish\</PublishDir>
   </PropertyGroup>
 
   <!--
@@ -522,7 +527,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ProcessorArchitecture Condition="'$(ProcessorArchitecture)'==''">$(PROCESSOR_ARCHITECTURE)</ProcessorArchitecture>
   </PropertyGroup>
 
-
   <!-- Sensible defaults for the most-commonly-desired MSBuildRuntime and MSBuildArchitecture values. The Core and Mono runtimes do not currently support specifying task architecture or runtime.
        If support for out-of-proc task execution is added on other runtimes, make sure each task's logic is checked against the current state of support. -->
   <PropertyGroup Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' == 'Full'">
@@ -924,6 +928,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       PostBuildEvent
     </CoreBuildDependsOn>
   </PropertyGroup>
+
   <Target
       Name="CoreBuild"
       DependsOnTargets="$(CoreBuildDependsOn)">
@@ -941,7 +946,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
     -->
   <PropertyGroup>
-
     <_ProjectDefaultTargets Condition="'$(MSBuildProjectDefaultTargets)' != ''">$(MSBuildProjectDefaultTargets)</_ProjectDefaultTargets>
     <_ProjectDefaultTargets Condition="'$(MSBuildProjectDefaultTargets)' == ''">Build</_ProjectDefaultTargets>
 
@@ -1086,6 +1090,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <RunDependsOn></RunDependsOn>
   </PropertyGroup>
+
   <Target
       Name="Run"
       DependsOnTargets="$(RunDependsOn)">
@@ -1096,9 +1101,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -1117,6 +1119,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <BuildingProject>false</BuildingProject>
   </PropertyGroup>
+
   <Target
       Name="BuildOnlySettings">
     <PropertyGroup>
@@ -1124,9 +1127,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </PropertyGroup>
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -1145,6 +1145,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <PrepareForBuildDependsOn>$(PrepareForBuildDependsOn);GetFrameworkPaths;GetReferenceAssemblyPaths;AssignLinkMetadata</PrepareForBuildDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PrepareForBuild"
       DependsOnTargets="$(PrepareForBuildDependsOn)">
@@ -1253,6 +1254,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <PropertyGroup Condition="'$(_TargetFrameworkDirectories)' == ''">
       <TargetFrameworkProfile/>
     </PropertyGroup>
+
   </Target>
 
    <!-- Returns target framework moniker. E.g. ".NETFramework,Version=v4.0.1" -->
@@ -1280,6 +1282,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
     -->
   <Target Name="AssignLinkMetadata" Condition=" '$(SynthesizeLinkMetadata)' == 'true' ">
+
     <!-- NONE ITEMS -->
     <AssignLinkMetadata Items="@(None)"
                         Condition="'@(None)' != '' and '%(None.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
@@ -1304,7 +1307,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_Temp Remove="@(_Temp)" />
     </ItemGroup>
 
-
     <!-- PAGE ITEMS -->
     <AssignLinkMetadata Items="@(Page)"
                         Condition="'@(Page)' != '' and '%(Page.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
@@ -1317,7 +1319,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_Temp Remove="@(_Temp)" />
     </ItemGroup>
 
-
     <!-- APPLICATIONDEFINITION ITEMS -->
     <AssignLinkMetadata Items="@(ApplicationDefinition)"
                         Condition="'@(ApplicationDefinition)' != '' and '%(ApplicationDefinition.DefiningProjectFullPath)' != '$(MSBuildProjectFullPath)'">
@@ -1341,6 +1342,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <EmbeddedResource Include="@(_Temp)" />
       <_Temp Remove="@(_Temp)" />
     </ItemGroup>
+
   </Target>
 
   <!--
@@ -1361,6 +1363,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <PreBuildEventDependsOn></PreBuildEventDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PreBuildEvent"
       Condition="'$(PreBuildEvent)'!=''"
@@ -1370,9 +1373,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -1392,6 +1392,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <UnmanagedUnregistrationDependsOn></UnmanagedUnregistrationDependsOn>
   </PropertyGroup>
+
   <Target
       Name="UnmanagedUnregistration"
       Condition="(('$(_AssemblyTimestampBeforeCompile)' != '$(_AssemblyTimestampAfterCompile)' or '$(RegisterForComInterop)' != 'true' or '$(OutputType)' != 'library') or
@@ -1416,16 +1417,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <UnregisterAssemblyMSBuildRuntime Condition="'$(UnregisterAssemblyMSBuildRuntime)' == ''">CurrentRuntime</UnregisterAssemblyMSBuildRuntime>
     </PropertyGroup>
 
-
     <UnregisterAssembly AssemblyListFile="@(_UnmanagedRegistrationCache)"
                         MSBuildArchitecture="$(UnregisterAssemblyMSBuildArchitecture)"
                         MSBuildRuntime="$(UnregisterAssemblyMSBuildRuntime)" />
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -1557,6 +1554,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <ReferenceOutputAssembly Condition="'%(ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == ''">true</ReferenceOutputAssembly>
       </ProjectReferenceWithConfiguration>
     </ItemGroup>
+
   </Target>
 
   <!--
@@ -1784,21 +1782,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="Result"
         PropertyName="_AdditionalPropertiesFromProject"/>
     </CombineXmlElements>
-    
+
     <ItemGroup>
       <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
         <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
         <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
         <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
         <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>
-
         <HasSingleTargetFramework>true</HasSingleTargetFramework>
-
         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
         <IsRidAgnostic>false</IsRidAgnostic>
         <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
+
   </Target>
 
   <Target Name="GetTargetFrameworksWithPlatformForSingleTargetFramework"
@@ -1866,6 +1863,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       _GetProjectReferenceTargetFrameworkProperties
     </PrepareProjectReferencesDependsOn>
   </PropertyGroup>
+
   <Target Name="PrepareProjectReferences" DependsOnTargets="$(PrepareProjectReferencesDependsOn)" />
 
   <!--
@@ -2146,6 +2144,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       ExpandSDKReferences;
     </ResolveAssemblyReferencesDependsOn>
   </PropertyGroup>
+
   <Target
       Name="ResolveAssemblyReferences"
       Returns="@(ReferencePath)"
@@ -2161,7 +2160,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         expensive to write the newly created cache file.
         -->
     <PropertyGroup>
-      <ResolveAssemblyReferencesStateFile Condition="'$(DisableRarCache)'!='true' and '$(ResolveAssemblyReferencesStateFile)' == ''">$(IntermediateOutputPath)$(MSBuildProjectFile)AssemblyReference.cache</ResolveAssemblyReferencesStateFile>
+      <ResolveAssemblyReferencesStateFile Condition="'$(DisableRarCache)'!='true' and '$(ResolveAssemblyReferencesStateFile)' == ''">$(IntermediateOutputPath)$(MSBuildProjectFile).AssemblyReference.cache</ResolveAssemblyReferencesStateFile>
     </PropertyGroup>
 
     <!-- Make an App.Config item that exists when AutoUnify is false. -->
@@ -2227,6 +2226,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         TargetFrameworkMonikerDisplayName="$(TargetFrameworkMonikerDisplayName)"
         TargetedRuntimeVersion="$(TargetedRuntimeVersion)"
         StateFile="$(ResolveAssemblyReferencesStateFile)"
+        AssemblyInformationCachePaths="$(AssemblyInformationCachePaths)"
+        AssemblyInformationCacheOutputPath="$(AssemblyInformationCacheOutputPath)"
         InstalledAssemblySubsetTables="@(InstalledAssemblySubsetTables)"
         TargetFrameworkSubsets="@(_ReferenceInstalledAssemblySubsets)"
         FullTargetFrameworkSubsetNames="$(FullReferenceAssemblyNames)"
@@ -2259,6 +2260,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="DependsOnNETStandard" PropertyName="_DependsOnNETStandard"/>
       <Output TaskParameter="UnresolvedAssemblyConflicts" ItemName="ResolveAssemblyReferenceUnresolvedAssemblyConflicts"/>
     </ResolveAssemblyReference>
+
   </Target>
 
   <!--
@@ -2323,9 +2325,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       OutputAppConfigFile="$(_GenerateBindingRedirectsIntermediateAppConfig)"
       SuggestedRedirects="@(SuggestedBindingRedirects)"
       >
-
       <Output TaskParameter="OutputAppConfigFile" ItemName="FileWrites" />
-
     </GenerateBindingRedirects>
 
   </Target>
@@ -2345,6 +2345,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <PropertyGroup>
       <AppConfig>$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
     </PropertyGroup>
+
     <ItemGroup>
       <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
       <AppConfigWithTargetPath Include="$(AppConfig)">
@@ -2469,7 +2470,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       Name="ResolveSDKReferences"
       Returns="@(ResolvedSDKReference)"
       DependsOnTargets="$(ResolveSDKReferencesDependsOn)">
-
     <ResolveSDKReference
            SDKReferences="@(SDKReference)"
            RuntimeReferenceOnlySDKDependencies="@(RuntimeReferenceOnlySDKDependencies)"
@@ -2544,7 +2544,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       BuildInParallel="$(BuildInParallel)"
       ContinueOnError="!$(BuildingProject)"
       RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
-
       <Output TaskParameter="TargetOutputs" ItemName="TargetPathWithTargetPlatformMoniker" />
     </MSBuild>
   </Target>
@@ -2617,7 +2616,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
           Inputs="@(IntermediateAssembly);@(DocFileItem);@(_DebugSymbolsIntermediatePath);@(ReferencePathWithRefAssemblies);$(MSBuildAllProjects)"
           Outputs="$(_IntermediateWindowsMetadataPath);$(WinMDExpOutputPdb);$(WinMDOutputDocumentationFile)"
   >
-
       <PropertyGroup>
         <!-- Will be copied by the "copy WinMD artifacts" step instead -->
         <CopyBuildOutputToOutputDirectory>false</CopyBuildOutputToOutputDirectory>
@@ -2650,6 +2648,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          <WinMDExpArtifacts Include="$(WinMDExpOutputPdb)"/>
          <FileWrites Include="$(WinMDOutputDocumentationFile);$(WinMDExpOutputPdb)"/>
     </ItemGroup>
+
   </Target>
 
   <Target
@@ -2661,6 +2660,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ItemGroup>
       <_ReferencesFromRAR Include="@(ReferencePath->WithMetadataValue('ReferenceSourceTarget', 'ResolveAssemblyReference'))"/>
     </ItemGroup>
+
   </Target>
 
   <PropertyGroup>
@@ -2687,7 +2687,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         [IN]
         @(DesignTimeReference) - List of assembly references as simple/fusion names.
 
-
         [OUT]
         @(ReferencePath) - Paths to resolved primary files.
 
@@ -2778,6 +2777,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="ResolvedFiles" ItemName="DesignTimeReferencePath"/>
       <Output TaskParameter="FilesWritten" ItemName="FileWrites"/>
     </ResolveAssemblyReference>
+
   </Target>
 
   <!--
@@ -2897,6 +2897,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       CompileLicxFiles
     </PrepareResourcesDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PrepareResources"
       DependsOnTargets="$(PrepareResourcesDependsOn)"/>
@@ -2916,6 +2917,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       CreateCustomManifestResourceNames
     </PrepareResourceNamesDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PrepareResourceNames"
       DependsOnTargets="$(PrepareResourceNamesDependsOn)"/>
@@ -2931,6 +2933,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <AssignTargetPathsDependsOn></AssignTargetPathsDependsOn>
   </PropertyGroup>
+
   <Target
       Name="AssignTargetPaths"
       DependsOnTargets="$(AssignTargetPathsDependsOn)">
@@ -2944,7 +2947,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="AssignedFiles" ItemName="_Temporary" />
     </AssignTargetPath>
 
-
     <ItemGroup>
       <!-- Replace items in EmbeddedResource with the items emitted by the AssignTargetPath task that have the TargetPath metadata -->
       <EmbeddedResource Remove="@(_Temporary)" />
@@ -3075,6 +3077,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <CreateCustomManifestResourceNamesDependsOn></CreateCustomManifestResourceNamesDependsOn>
   </PropertyGroup>
+
   <Target
       Name="CreateCustomManifestResourceNames"
       DependsOnTargets="$(CreateCustomManifestResourceNamesDependsOn)"/>
@@ -3093,6 +3096,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <UseSourcePath Condition="'$(UseSourcePath)'==''">true</UseSourcePath>
     <ResGenExecuteAsTool Condition="'$(ResGenExecuteAsTool)'==''">false</ResGenExecuteAsTool>
   </PropertyGroup>
+
   <Target
       Name="ResGen"
       DependsOnTargets="$(ResGenDependsOn)"/>
@@ -3255,6 +3259,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <CompileLicxFilesDependsOn></CompileLicxFilesDependsOn>
   </PropertyGroup>
+
   <Target
       Name="CompileLicxFiles"
       Condition="'@(_LicxFile)'!=''"
@@ -3287,9 +3292,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -3366,6 +3368,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       AfterCompile;
     </CompileDependsOn>
   </PropertyGroup>
+
   <Target
       Name="Compile"
       DependsOnTargets="$(CompileDependsOn)"/>
@@ -3412,7 +3415,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup Condition="'$(TargetFrameworkMoniker)' != ''">
     <!-- Do not clean if we are going to default the path to the temp directory -->
     <TargetFrameworkMonikerAssemblyAttributesFileClean Condition="'$(TargetFrameworkMonikerAssemblyAttributesFileClean)' == '' and '$(TargetFrameworkMonikerAssemblyAttributesPath)' != ''">true</TargetFrameworkMonikerAssemblyAttributesFileClean>
-    <TargetFrameworkMonikerAssemblyAttributesPath Condition="'$(TargetFrameworkMonikerAssemblyAttributesPath)' == ''">$(IntermediateOutputPath)$(TargetFrameworkMoniker).AssemblyAttributes$(DefaultLanguageSourceExtension)</TargetFrameworkMonikerAssemblyAttributesPath>
+    <TargetFrameworkMonikerAssemblyAttributesPath Condition="'$(TargetFrameworkMonikerAssemblyAttributesPath)' == ''">$([System.IO.Path]::Combine('$(IntermediateOutputPath)','$(TargetFrameworkMoniker).AssemblyAttributes$(DefaultLanguageSourceExtension)'))</TargetFrameworkMonikerAssemblyAttributesPath>
   </PropertyGroup>
 
   <PropertyGroup>
@@ -3444,8 +3447,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Compile Include="$(TargetFrameworkMonikerAssemblyAttributesPath)"/>
       <!-- Do not put in FileWrites: this is a file shared between projects in %temp%, and cleaning it would create a race between projects during rebuild -->
     </ItemGroup>
-  </Target>
 
+  </Target>
 
   <!--
     ============================================================
@@ -3473,7 +3476,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
           AssemblyAttributes="@(AssemblyAttributes)"
           OutputFile="$(AssemblyAttributesPath)"
           Language="$(Language)">
-
       <Output TaskParameter="OutputFile" ItemName="Compile"/>
       <Output TaskParameter="OutputFile" ItemName="FileWrites"/>
     </WriteCodeFragment>
@@ -3595,9 +3597,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -3689,6 +3688,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       GenerateSatelliteAssemblies
     </CreateSatelliteAssembliesDependsOn>
   </PropertyGroup>
+
   <Target
       Name="CreateSatelliteAssemblies"
       DependsOnTargets="$(CreateSatelliteAssembliesDependsOn)" />
@@ -3721,6 +3721,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </_SatelliteAssemblyResourceInputs>
 
     </ItemGroup>
+
   </Target>
 
   <!--
@@ -3735,6 +3736,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
           Outputs="$(IntermediateOutputPath)%(Culture)\$(TargetName).resources.dll"
           Condition="'@(_SatelliteAssemblyResourceInputs)' != '' and '$(GenerateSatelliteAssembliesForCore)' != 'true'">
 
+    <PropertyGroup>
+      <_ALExeToolPath>$(TargetFrameworkSDKToolsDirectory)</_ALExeToolPath>
+      <_ALExeToolPath Condition="'$(PlatformTarget)' == 'x64'">$(TargetFrameworkSDKToolsDirectory)$(PlatformTarget)\</_ALExeToolPath>
+    </PropertyGroup>
+
     <MakeDir
         Directories="@(EmbeddedResource->'$(IntermediateOutputPath)%(Culture)')" />
 
@@ -3767,7 +3773,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         Title="$(Satellite_Title)"
         ToolPath="$(AlToolPath)"
         ToolExe ="$(AlToolExe)"
-        SdkToolsPath="$(TargetFrameworkSDKToolsDirectory)"
+        SdkToolsPath="$(SdkToolsPathMaybeWithx64Architecture)"
         Trademark="$(Satellite_Trademark)"
         Version="$(Satellite_Version)"
         Win32Icon="$(Satellite_Win32Icon)"
@@ -3791,6 +3797,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       CreateManifestResourceNames
     </ComputeIntermediateSatelliteAssembliesDependsOn>
   </PropertyGroup>
+
   <Target
       Name="ComputeIntermediateSatelliteAssemblies"
       Condition="@(EmbeddedResource->'%(WithCulture)') != ''"
@@ -3803,6 +3810,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <TargetPath>%(EmbeddedResource.Culture)\$(TargetName).resources.dll</TargetPath>
       </IntermediateSatelliteAssembliesWithTargetPath>
     </ItemGroup>
+
   </Target>
 
   <!--
@@ -3869,9 +3877,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -3905,6 +3910,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     -->
   <Target
       Name="_GenerateResolvedDeploymentManifestEntryPoint">
+
     <ItemGroup>
       <_DeploymentPublishFileOfTypeManifestEntryPoint Include="@(PublishFile)" Condition="'%(FileType)'=='ManifestEntryPoint'"/>
     </ItemGroup>
@@ -3915,10 +3921,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         SigningManifests="$(SignManifests)"
         DeploymentManifestEntryPoint="@(ApplicationManifest)"
         PublishFiles="@(_DeploymentPublishFileOfTypeManifestEntryPoint)">
-
       <Output TaskParameter="OutputDeploymentManifestEntryPoint" ItemName="_DeploymentResolvedDeploymentManifestEntryPoint"/>
-
     </ResolveManifestFiles>
+
   </Target>
 
   <Target
@@ -4124,6 +4129,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_DeploymentManifestEntryPoint Remove="@(_DeploymentManifestEntryPoint)"/>
       <_DeploymentManifestEntryPoint Include="@(_DeploymentManifestLauncherEntryPoint)"/>
     </ItemGroup>
+
   </Target>
 
   <!--
@@ -4208,16 +4214,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!-- Include the following files in clickonce manifest only if single file publish is false -->
     <ItemGroup Condition="'$(PublishSingleFile)' != 'true'">
-      <!-- 
-      _ClickOnceRuntimeCopyLocalItems group contains any runtimes folder assets of Nuget packages that are not included in 
-      _DeploymentReferencePaths (e.g. pdbs). They are populated from the RuntimeTargetsCopyLocalItems and NativeCopyLocalItems 
-      group that contain the RID-specific assets that go in runtimes folder on publish. They are output groups of the 
+      <!--
+      _ClickOnceRuntimeCopyLocalItems group contains any runtimes folder assets of Nuget packages that are not included in
+      _DeploymentReferencePaths (e.g. pdbs). They are populated from the RuntimeTargetsCopyLocalItems and NativeCopyLocalItems
+      group that contain the RID-specific assets that go in runtimes folder on publish. They are output groups of the
       ResolvePackageAssets target in dotnet/sdk
       -->
       <_ClickOnceRuntimeCopyLocalItems Include="@(RuntimeTargetsCopyLocalItems)"
                                       Condition="'%(RuntimeTargetsCopyLocalItems.CopyLocal)' == 'true'" />
 
-      <_ClickOnceRuntimeCopyLocalItems Include="@(NativeCopyLocalItems)" 
+      <_ClickOnceRuntimeCopyLocalItems Include="@(NativeCopyLocalItems)"
                                       Condition="'%(NativeCopyLocalItems.CopyLocal)' == 'true'" />
       <_ClickOnceRuntimeCopyLocalItems Remove="@(_DeploymentReferencePaths)" />
       <_ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems)"/>
@@ -4239,6 +4245,27 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       Condition="'$(_DeploymentSignClickOnceManifests)'=='true' and '$(_DeploymentLauncherBased)' == 'true' and '$(PublishSingleFile)' == 'true'"
       />
 
+    <!--
+    If ReadyToRun is enabled in loose files scenario, we need to remove entries of the IL images that have gone through R2R
+    compiler and replace them with the entries for their R2R images. The R2R application image also needs to be signed if necessary.
+    -->
+
+    <ItemGroup Condition="'$(PublishReadyToRun)' == 'true' and '$(PublishSingleFile)' != 'true'">
+      <_ManifestManagedReferences Remove="@(_ReadyToRunCompileList)" />
+      <_ClickOnceFiles Remove="@(_ReadyToRunCompileList)" />
+      <_ClickOnceFiles Include="@(_ReadyToRunFilesToPublish)" />
+      <_ClickOnceTargetFile Include="@(_ReadyToRunFilesToPublish)" Condition="'%(Filename)%(Extension)' == '$(TargetFileName)'" />
+    </ItemGroup>
+
+    <!-- Sign application image created by R2R -->
+    <SignFile
+        CertificateThumbprint="$(_DeploymentResolvedManifestCertificateThumbprint)"
+        TimestampUrl="$(ManifestTimestampUrl)"
+        SigningTarget="@(_ClickOnceTargetFile)"
+        TargetFrameworkVersion="$(TargetFrameworkVersion)"
+        TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
+        Condition="'$(_DeploymentSignClickOnceManifests)' == 'true' and '$(PublishReadyToRun)' == 'true' and '$(PublishSingleFile)' != 'true'" />
+
     <!-- Copy the application executable from Obj folder to app.publish folder.
     This is being done to avoid Windows Forms designer memory issues that can arise while operating directly on files located in Obj directory. -->
     <Copy
@@ -4404,9 +4431,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -4432,6 +4456,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       CopyFilesToOutputDirectory
     </PrepareForRunDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PrepareForRun"
       DependsOnTargets="$(PrepareForRunDependsOn)"/>
@@ -4629,7 +4654,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Output TaskParameter="DestinationFiles" ItemName="FinalWinmdExpArtifacts" />
     </Copy>
 
-    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; $([MSBuild]::NormalizePath('$(_WindowsMetadataOutputPath)'))" Condition="'$(SkipCopyWinMDArtifact)' != 'true' and '$(_WindowsMetadataOutputPath)' != ''" />
+    <Message Importance="High" Text="$(MSBuildProjectName) -&gt; $([System.IO.Path]::GetFullPath('$(_WindowsMetadataOutputPath)'))" Condition="'$(SkipCopyWinMDArtifact)' != 'true' and '$(_WindowsMetadataOutputPath)' != ''" />
 
   </Target>
 
@@ -4691,8 +4716,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
             GetCopyToOutputDirectoryItems;
             _CopyOutOfDateSourceItemsToOutputDirectory;
             _CopyOutOfDateSourceItemsToOutputDirectoryAlways"/>
-
-
   <!--
     ============================================================
                                         GetCopyToOutputDirectoryItems
@@ -4919,6 +4942,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <CopyToPublishDirectory>%(CopyToOutputDirectory)</CopyToPublishDirectory>
       </AllPublishItemsFullPathWithTargetPath>
     </ItemGroup>
+
   </Target>
 
   <!--
@@ -5103,6 +5127,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ItemGroup>
       <FileWrites Include="@(_DebugSymbolsIntermediatePath)" Condition="'$(_DebugSymbolsProduced)'=='true'"/>
     </ItemGroup>
+
   </Target>
 
   <!--
@@ -5129,9 +5154,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -5150,6 +5172,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <UnmanagedRegistrationDependsOn></UnmanagedRegistrationDependsOn>
   </PropertyGroup>
+
   <Target
       Name="UnmanagedRegistration"
       Condition="'$(RegisterForComInterop)'=='true' and '$(OutputType)'=='library'"
@@ -5185,11 +5208,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ItemGroup>
       <FileWrites Include="@(_OutputPathItem->'%(FullPath)$(TargetName).tlb')"/>
     </ItemGroup>
-  </Target>
-
-
-
 
+  </Target>
 
   <!--
     ***********************************************************************************************
@@ -5417,6 +5437,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <CoreCleanDependsOn></CoreCleanDependsOn>
   </PropertyGroup>
+
   <Target
       Name="CoreClean"
       DependsOnTargets="$(CoreCleanDependsOn)">
@@ -5515,9 +5536,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -5548,6 +5566,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <PostBuildEventDependsOn></PostBuildEventDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PostBuildEvent"
       Condition="'$(PostBuildEvent)' != '' and ('$(RunPostBuildEvent)' != 'OnOutputUpdated' or '$(_AssemblyTimestampBeforeCompile)' != '$(_AssemblyTimestampAfterCompile)')"
@@ -5557,9 +5576,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-
-
-
   <!--
     ***********************************************************************************************
     ***********************************************************************************************
@@ -5585,6 +5601,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       _DeploymentUnpublishable
     </PublishDependsOn>
   </PropertyGroup>
+
   <Target
       Name="Publish"
       DependsOnTargets="$(PublishDependsOn)"/>
@@ -5644,6 +5661,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       AfterPublish
     </PublishOnlyDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PublishOnly"
       DependsOnTargets="$(PublishOnlyDependsOn)"/>
@@ -5684,6 +5702,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       CreateSatelliteAssemblies;
     </PublishBuildDependsOn>
   </PropertyGroup>
+
   <Target
       Name="PublishBuild"
       DependsOnTargets="$(PublishBuildDependsOn)"/>
@@ -5861,8 +5880,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         TimestampUrl="$(ManifestTimestampUrl)"
         SigningTarget="$(PublishDir)\setup.exe"
         Condition="'$(BootstrapperEnabled)'=='true' and '$(_DeploymentSignClickOnceManifests)'=='true'" />
-  </Target>
 
+  </Target>
 
   <!--
     ***********************************************************************************************
@@ -5931,6 +5950,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <BuiltProjectOutputGroupDependsOn>PrepareForBuild</BuiltProjectOutputGroupDependsOn>
     <AddAppConfigToBuildOutputs Condition="('$(AddAppConfigToBuildOutputs)'=='') and ('$(OutputType)'!='library' and '$(OutputType)'!='winmdobj')">true</AddAppConfigToBuildOutputs>
   </PropertyGroup>
+
   <Target
       Name="BuiltProjectOutputGroup"
       Returns="@(BuiltProjectOutputGroupOutput)"
@@ -5984,12 +6004,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <DebugSymbolsProjectOutputGroupDependsOn></DebugSymbolsProjectOutputGroupDependsOn>
   </PropertyGroup>
+
   <ItemGroup Condition="'$(_DebugSymbolsProduced)' != 'false' and '$(OutputType)' != 'winmdobj'">
     <DebugSymbolsProjectOutputGroupOutput Include="@(_DebugSymbolsIntermediatePath->'%(FullPath)')">
       <FinalOutputPath>@(_DebugSymbolsOutputPath->'%(FullPath)')</FinalOutputPath>
       <TargetPath>@(_DebugSymbolsIntermediatePath->'%(Filename)%(Extension)')</TargetPath>
     </DebugSymbolsProjectOutputGroupOutput>
   </ItemGroup>
+
   <ItemGroup Condition="'$(_DebugSymbolsProduced)' != 'false' and '$(OutputType)' == 'winmdobj'">
     <WinMDExpOutputPdbItem Include="$(WinMDExpOutputPdb)" Condition="'$(WinMDExpOutputPdb)' != ''" />
     <WinMDExpFinalOutputPdbItem Include="$(_WinMDDebugSymbolsOutputPath)" Condition="'$(_WinMDDebugSymbolsOutputPath)' != ''" />
@@ -5998,6 +6020,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <TargetPath>@(WinMDExpOutputPdbItem->'%(Filename)%(Extension)')</TargetPath>
     </DebugSymbolsProjectOutputGroupOutput>
   </ItemGroup>
+
   <Target
       Name="DebugSymbolsProjectOutputGroup"
       Returns="@(DebugSymbolsProjectOutputGroupOutput)"
@@ -6013,6 +6036,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <DocumentationProjectOutputGroupDependsOn></DocumentationProjectOutputGroupDependsOn>
   </PropertyGroup>
+
   <ItemGroup Condition="'$(DocumentationFile)'!='' and '$(OutputType)' != 'winmdobj'">
     <DocumentationProjectOutputGroupOutput Include="@(DocFileItem->'%(FullPath)')">
       <FinalOutputPath>@(FinalDocFile->'%(FullPath)')</FinalOutputPath>
@@ -6020,6 +6044,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <TargetPath>@(DocFileItem->'%(Filename)%(Extension)')</TargetPath>
     </DocumentationProjectOutputGroupOutput>
   </ItemGroup>
+
   <ItemGroup Condition="'$(DocumentationFile)' != '' and '$(OutputType)' == 'winmdobj'">
     <WinMDOutputDocumentationFileItem Include="$(WinMDOutputDocumentationFile)" Condition="'$(WinMDOutputDocumentationFile)' != ''" />
     <WinMDExpFinalOutputDocItem Include="$(_WinMDDocFileOutputPath)" Condition="'$(_WinMDDocFileOutputPath)' != ''" />
@@ -6028,6 +6053,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <TargetPath>@(WinMDOutputDocumentationFileItem->'%(Filename)%(Extension)')</TargetPath>
     </DocumentationProjectOutputGroupOutput>
   </ItemGroup>
+
   <Target
       Name="DocumentationProjectOutputGroup"
       Returns="@(DocumentationProjectOutputGroupOutput)"
@@ -6043,6 +6069,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <SatelliteDllsProjectOutputGroupDependsOn>PrepareForBuild;PrepareResourceNames</SatelliteDllsProjectOutputGroupDependsOn>
   </PropertyGroup>
+
   <Target
       Name="SatelliteDllsProjectOutputGroup"
       Returns="@(SatelliteDllsProjectOutputGroupOutput)"
@@ -6078,6 +6105,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <SourceFilesProjectOutputGroupDependsOn>PrepareForBuild;AssignTargetPaths</SourceFilesProjectOutputGroupDependsOn>
   </PropertyGroup>
+
   <Target
       Name="SourceFilesProjectOutputGroup"
       Returns="@(SourceFilesProjectOutputGroupOutput)"
@@ -6115,6 +6143,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <ContentFilesProjectOutputGroupDependsOn>PrepareForBuild;AssignTargetPaths</ContentFilesProjectOutputGroupDependsOn>
   </PropertyGroup>
+
   <Target
       Name="ContentFilesProjectOutputGroup"
       Returns="@(ContentFilesProjectOutputGroupOutput)"
@@ -6138,6 +6167,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <SGenFilesOutputGroupDependsOn></SGenFilesOutputGroupDependsOn>
   </PropertyGroup>
+
   <ItemGroup
       Condition="'$(_SGenGenerateSerializationAssembliesConfig)' == 'On' or ('@(WebReferenceUrl)'!='' and '$(_SGenGenerateSerializationAssembliesConfig)' == 'Auto')">
     <SGenFilesOutputGroupOutput Include="@(_OutputPathItem->'%(FullPath)$(_SGenDllName)')">
@@ -6145,6 +6175,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <TargetPath>$(_SGenDllName)</TargetPath>
     </SGenFilesOutputGroupOutput>
   </ItemGroup>
+
   <Target
       Name="SGenFilesOutputGroup"
       Returns="@(SGenFilesOutputGroupOutput)"
diff --git a/src/Tasks/Microsoft.Common.overridetasks b/src/Tasks/Microsoft.Common.overridetasks
index 730d63c037c..f9bc7334290 100644
--- a/src/Tasks/Microsoft.Common.overridetasks
+++ b/src/Tasks/Microsoft.Common.overridetasks
@@ -1,30 +1,39 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 
-    <!-- This file lists UsingTask elements that we wish to override 
+    <!-- This file lists UsingTask elements that we wish to override
          any other UsingTask elements -->
-    
+
     <!-- NOTE: Listing a <UsingTask> tag in a *.tasks file like this one rather than in a project or targets file
                can give a significant performance advantage in a large build, because every time a <UsingTask> tag
                is encountered, it will cause the task to be rediscovered next time the task is used. -->
     <!-- NOTE: Using the fully qualified class name in a <UsingTask> tag is faster than using a partially qualified name. -->
 
     <UsingTask TaskName="Microsoft.Build.Tasks.ResolveComReference"  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5'" />
+
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"     AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+
     <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
     <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"     AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+
     <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
     <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"   AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+
     <UsingTask TaskName="ResolveComReference"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0'" />
+
     <UsingTask TaskName="GenerateResource"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
     <UsingTask TaskName="GenerateResource"                           AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+
     <UsingTask TaskName="RegisterAssembly"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
     <UsingTask TaskName="RegisterAssembly"                           AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+
     <UsingTask TaskName="UnregisterAssembly"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and ('$(DisableOutOfProcTaskHost)' != '' or !$([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`)))" />
     <UsingTask TaskName="UnregisterAssembly"                         AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '2.0' and '$(DisableOutOfProcTaskHost)' == '' and $([MSBuild]::DoesTaskHostExist(`CLR2`,`CurrentArchitecture`))" Runtime="CLR2" />
+
     <UsingTask TaskName="ReadLinesFromFile"                          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
     <UsingTask TaskName="FindUnderPath"                              AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
     <UsingTask TaskName="ConvertToAbsolutePath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
     <UsingTask TaskName="MSBuild"                                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '3.5' or '$(MSBuildToolsVersion)' == '2.0'" />
     <UsingTask TaskName="ResolveAssemblyReference"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildToolsVersion)' == '4.0'" />
+
 </Project>
diff --git a/src/Tasks/Microsoft.Common.props b/src/Tasks/Microsoft.Common.props
index 942daa68814..32f5f05ab9f 100644
--- a/src/Tasks/Microsoft.Common.props
+++ b/src/Tasks/Microsoft.Common.props
@@ -11,6 +11,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
   <PropertyGroup>
     <ImportByWildcardBeforeMicrosoftCommonProps Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == ''">true</ImportByWildcardBeforeMicrosoftCommonProps>
     <ImportByWildcardAfterMicrosoftCommonProps Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == ''">true</ImportByWildcardAfterMicrosoftCommonProps>
@@ -19,22 +20,22 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ImportDirectoryBuildProps Condition="'$(ImportDirectoryBuildProps)' == ''">true</ImportDirectoryBuildProps>
   </PropertyGroup>
 
-  <!-- 
+  <!--
         Determine the path to the directory build props file if the user did not disable $(ImportDirectoryBuildProps) and
         they did not already specify an absolute path to use via $(DirectoryBuildPropsPath)
     -->
   <PropertyGroup Condition="'$(ImportDirectoryBuildProps)' == 'true' and '$(DirectoryBuildPropsPath)' == ''">
     <_DirectoryBuildPropsFile Condition="'$(_DirectoryBuildPropsFile)' == ''">Directory.Build.props</_DirectoryBuildPropsFile>
     <_DirectoryBuildPropsBasePath Condition="'$(_DirectoryBuildPropsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), '$(_DirectoryBuildPropsFile)'))</_DirectoryBuildPropsBasePath>
-    <DirectoryBuildPropsPath Condition="'$(_DirectoryBuildPropsBasePath)' != '' and '$(_DirectoryBuildPropsFile)' != ''">$([MSBuild]::NormalizePath('$(_DirectoryBuildPropsBasePath)', '$(_DirectoryBuildPropsFile)'))</DirectoryBuildPropsPath>
+    <DirectoryBuildPropsPath Condition="'$(_DirectoryBuildPropsBasePath)' != '' and '$(_DirectoryBuildPropsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildPropsBasePath)', '$(_DirectoryBuildPropsFile)'))</DirectoryBuildPropsPath>
   </PropertyGroup>
 
   <Import Project="$(DirectoryBuildPropsPath)" Condition="'$(ImportDirectoryBuildProps)' == 'true' and exists('$(DirectoryBuildPropsPath)')"/>
 
-  <!-- 
+  <!--
         Prepare to import project extensions which usually come from packages.  Package management systems will create a file at:
           $(MSBuildProjectExtensionsPath)\$(MSBuildProjectFile).<SomethingUnique>.props
-          
+
         Each package management system should use a unique moniker to avoid collisions.  It is a wild-card import so the package
         management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
     -->
@@ -43,28 +44,30 @@ Copyright (C) Microsoft Corporation. All rights reserved.
             The declaration of $(BaseIntermediateOutputPath) had to be moved up from Microsoft.Common.CurrentVersion.targets
             in order for the $(MSBuildProjectExtensionsPath) to use it as a default.
         -->
-    <BaseIntermediateOutputPath>$([MSBuild]::EnsureTrailingSlash($([MSBuild]::ValueOrDefault('$(BaseIntermediateOutputPath)', 'obj'))))</BaseIntermediateOutputPath>
+    <BaseIntermediateOutputPath Condition="'$(BaseIntermediateOutputPath)'=='' ">obj\</BaseIntermediateOutputPath>
+    <BaseIntermediateOutputPath Condition="!HasTrailingSlash('$(BaseIntermediateOutputPath)')">$(BaseIntermediateOutputPath)\</BaseIntermediateOutputPath>
     <_InitialBaseIntermediateOutputPath>$(BaseIntermediateOutputPath)</_InitialBaseIntermediateOutputPath>
 
-    <MSBuildProjectExtensionsPath>$([MSBuild]::EnsureTrailingSlash($([MSBuild]::ValueOrDefault('$(MSBuildProjectExtensionsPath)', '$(BaseIntermediateOutputPath)'))))</MSBuildProjectExtensionsPath>
+    <MSBuildProjectExtensionsPath Condition="'$(MSBuildProjectExtensionsPath)' == '' ">$(BaseIntermediateOutputPath)</MSBuildProjectExtensionsPath>
     <!--
         Import paths that are relative default to be relative to the importing file.  However, since MSBuildExtensionsPath
         defaults to BaseIntermediateOutputPath we expect it to be relative to the project directory.  So if the path is relative
         it needs to be made absolute based on the project directory.
       -->
-    <MSBuildProjectExtensionsPath Condition="!$([System.IO.Path]::IsPathRooted('$(MSBuildProjectExtensionsPath)'))">$([MSBuild]::NormalizeDirectory('$(MSBuildProjectDirectory)', '$(MSBuildProjectExtensionsPath)'))</MSBuildProjectExtensionsPath>
+    <MSBuildProjectExtensionsPath Condition="'$([System.IO.Path]::IsPathRooted($(MSBuildProjectExtensionsPath)))' == 'false'">$([System.IO.Path]::Combine('$(MSBuildProjectDirectory)', '$(MSBuildProjectExtensionsPath)'))</MSBuildProjectExtensionsPath>
+    <MSBuildProjectExtensionsPath Condition="!HasTrailingSlash('$(MSBuildProjectExtensionsPath)')">$(MSBuildProjectExtensionsPath)\</MSBuildProjectExtensionsPath>
     <ImportProjectExtensionProps Condition="'$(ImportProjectExtensionProps)' == ''">true</ImportProjectExtensionProps>
     <_InitialMSBuildProjectExtensionsPath Condition=" '$(ImportProjectExtensionProps)' == 'true' ">$(MSBuildProjectExtensionsPath)</_InitialMSBuildProjectExtensionsPath>
   </PropertyGroup>
 
   <Import Project="$(MSBuildProjectExtensionsPath)$(MSBuildProjectFile).*.props" Condition="'$(ImportProjectExtensionProps)' == 'true' and exists('$(MSBuildProjectExtensionsPath)')" />
 
-  <!-- 
+  <!--
         Import wildcard "ImportBefore" props files if we're actually in a 12.0+ project (rather than a project being
         treated as 4.0)
     -->
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' != ''">
-    <!-- 
+    <!--
             Wildcard imports come from $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props.d folder.
             This is very similar to the same extension point used in Microsoft.Common.targets, which is located in
             the $(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ directory. Unfortunately, there
@@ -75,34 +78,34 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore')"/>
   </ImportGroup>
 
-  <!-- 
-        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed 
-        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead 
-        just used whatever ToolsVersion was in the project file if it existed on the machine, and 
-        only forced 4.0 if that ToolsVersion did not exist.  
+  <!--
+        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed
+        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead
+        just used whatever ToolsVersion was in the project file if it existed on the machine, and
+        only forced 4.0 if that ToolsVersion did not exist.
 
-        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio, 
-        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected 
-        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved 
-        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist 
+        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio,
+        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected
+        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved
+        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist
         as part of the .NET Framework.  Only if we're using the new MSBuild will we point to the current
-        targets. 
+        targets.
    -->
   <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == '' and ('$(VisualStudioVersion)' != '' and '$(VisualStudioVersion)' &gt;= '12.0')">
     <!--
-           Reset VisualStudioVersion if it's 12.0+: Should be 10.0 if VS 2010 is installed or 11.0 otherwise, 
-           but since we don't have a good way of telling whether VS 2010 is installed, make it 11.0 if 
-           VS 2012 is installed or 10.0 otherwise.  The reset should be safe because if it was already 
-           set to something (e.g. 11.0 in a VS 2012 command prompt) then MSBuild's internal 
-           VisualStudioVersion-defaulting code should never come into the picture, so the only way it could 
-           be 12.0+ when building a TV 12.0 project (because we're in this file) using MSBuild 4.5 (because 
-           MSBuildAssemblyVersion hasn't been set) is if it's a TV 12.0 project on an empty command prompt. 
+           Reset VisualStudioVersion if it's 12.0+: Should be 10.0 if VS 2010 is installed or 11.0 otherwise,
+           but since we don't have a good way of telling whether VS 2010 is installed, make it 11.0 if
+           VS 2012 is installed or 10.0 otherwise.  The reset should be safe because if it was already
+           set to something (e.g. 11.0 in a VS 2012 command prompt) then MSBuild's internal
+           VisualStudioVersion-defaulting code should never come into the picture, so the only way it could
+           be 12.0+ when building a TV 12.0 project (because we're in this file) using MSBuild 4.5 (because
+           MSBuildAssemblyVersion hasn't been set) is if it's a TV 12.0 project on an empty command prompt.
       -->
     <VisualStudioVersion Condition="Exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props')">11.0</VisualStudioVersion>
     <VisualStudioVersion Condition="!Exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props')">10.0</VisualStudioVersion>
   </PropertyGroup>
 
-  <!-- If building using 4.X MSBuild, we want to act like this project is TV 4.0, so override 
+  <!-- If building using 4.X MSBuild, we want to act like this project is TV 4.0, so override
          the custom extensibility target locations with the hard-coded 4.0 equivalent. -->
   <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <CustomBeforeMicrosoftCommonProps Condition="'$(CustomBeforeMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v4.0\Custom.Before.$(MSBuildThisFile)</CustomBeforeMicrosoftCommonProps>
@@ -110,7 +113,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <!-- If building using 4.X MSBuild, we want to act like this project is TV 4.0, so import
-         Microsoft.Common.props from the 4.0 location, and make sure everything else in here is 
+         Microsoft.Common.props from the 4.0 location, and make sure everything else in here is
          set up such that if it's defaulted to something there, it won't be overridden here. -->
   <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props" Condition="'$(MSBuildAssemblyVersion)' == '' and Exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props')" />
 
@@ -119,15 +122,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <CustomAfterMicrosoftCommonProps Condition="'$(CustomAfterMicrosoftCommonProps)'==''">$(MSBuildExtensionsPath)\v$(MSBuildToolsVersion)\Custom.After.$(MSBuildThisFile)</CustomAfterMicrosoftCommonProps>
   </PropertyGroup>
 
-  <!-- 
-         Only import the extension targets if we're actually in a 12.0 project here (rather than one we're attempting 
-         to treat as 4.0) OR if the Dev11 Microsoft.Common.props don't exist.  If it's a 12.0 project we're redirecting 
-         to 4.0 and the Dev11 Microsoft.Common.props do exist, the extension targets will have been imported already 
+  <!--
+         Only import the extension targets if we're actually in a 12.0 project here (rather than one we're attempting
+         to treat as 4.0) OR if the Dev11 Microsoft.Common.props don't exist.  If it's a 12.0 project we're redirecting
+         to 4.0 and the Dev11 Microsoft.Common.props do exist, the extension targets will have been imported already
          so there's no need to import them twice.
      -->
   <Import Project="$(CustomBeforeMicrosoftCommonProps)" Condition="'$(CustomBeforeMicrosoftCommonProps)' != '' and Exists('$(CustomBeforeMicrosoftCommonProps)') and ('$(MSBuildAssemblyVersion)' != '' or !Exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props'))" />
 
-  <!-- This is used to determine whether Microsoft.Common.targets needs to import 
+  <!-- This is used to determine whether Microsoft.Common.targets needs to import
          Microsoft.Common.props itself, or whether it has been imported previously,
          e.g. by the project itself. -->
   <PropertyGroup>
@@ -146,15 +149,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualStudioVersion.v*.Common.props" Condition="'$(VisualStudioVersion)' == ''" />
 
-  <!-- 
-         Only import the extension targets if we're actually in a 12.0 project here (rather than one we're attempting 
-         to treat as 4.0) OR if the Dev11 Microsoft.Common.props don't exist.  If it's a 12.0 project we're redirecting 
-         to 4.0 and the Dev11 Microsoft.Common.props do exist, the extension targets will have been imported already 
+  <!--
+         Only import the extension targets if we're actually in a 12.0 project here (rather than one we're attempting
+         to treat as 4.0) OR if the Dev11 Microsoft.Common.props don't exist.  If it's a 12.0 project we're redirecting
+         to 4.0 and the Dev11 Microsoft.Common.props do exist, the extension targets will have been imported already
          so there's no need to import them twice.
      -->
   <Import Project="$(CustomAfterMicrosoftCommonProps)" Condition="'$(CustomAfterMicrosoftCommonProps)' != '' and Exists('$(CustomAfterMicrosoftCommonProps)') and ('$(MSBuildAssemblyVersion)' != '' or !Exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.props'))" />
 
-  <!-- 
+  <!--
         Import wildcard "ImportAfter" props files if we're actually in a 12.0+ project (rather than a project being
         treated as 4.0)
     -->
@@ -163,7 +166,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter')"/>
   </ImportGroup>
 
-  <!-- 
+  <!--
         Import NuGet.props file.
     -->
   <PropertyGroup>
@@ -171,6 +174,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <NuGetPropsFile Condition="'$(NuGetPropsFile)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$(MSBuildToolsPath32)\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.props</NuGetPropsFile>
     <NuGetPropsFile Condition="'$(NuGetPropsFile)'==''">$(MSBuildToolsPath)\NuGet.props</NuGetPropsFile>
   </PropertyGroup>
+
   <Import Condition="Exists('$(NuGetPropsFile)')" Project="$(NuGetPropsFile)" />
 
   <PropertyGroup Condition=" '$(MSBuildLogVerboseTaskParameters)' != 'true' ">
@@ -188,4 +192,5 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>true</DisableLogTaskParameterItemMetadata_RemoveDuplicates_Filtered>
     <DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>true</DisableLogTaskParameterItemMetadata_WriteLinesToFile_Lines>
   </PropertyGroup>
+
 </Project>
diff --git a/src/Tasks/Microsoft.Common.targets b/src/Tasks/Microsoft.Common.targets
index b3e9be1fa09..753dad7cfaf 100644
--- a/src/Tasks/Microsoft.Common.targets
+++ b/src/Tasks/Microsoft.Common.targets
@@ -15,18 +15,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <!-- 
-       In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed 
-       as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead 
-       just used whatever ToolsVersion was in the project file if it existed on the machine, and 
-       only forced 4.0 if that ToolsVersion did not exist.  
-
-       Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio, 
-       but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected 
-       the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved 
-       property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist 
+
+  <!--
+       In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed
+       as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead
+       just used whatever ToolsVersion was in the project file if it existed on the machine, and
+       only forced 4.0 if that ToolsVersion did not exist.
+
+       Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio,
+       but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected
+       the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved
+       property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist
        as part of the .NET Framework.  Only if we're using the new MSBuild will we point to the current
-       targets. 
+       targets.
    -->
 
   <Choose>
@@ -43,13 +44,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </Choose>
 
   <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
-     <!-- 
-          Overrides for the Microsoft.Common.targets extension targets. Used to make sure that only the imports we specify 
-          (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. 
+     <!--
+          Overrides for the Microsoft.Common.targets extension targets. Used to make sure that only the imports we specify
+          (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default.
 
-          NOTE: This logic is duplicated in Microsoft.VisualBasic.targets and in Microsoft.CSharp.targets because those two files 
-          import Microsoft.Common.targets from the current directory and thus don't get the benefit of the redirections, so for 
-          any changes to this logic in this file, please also edit the other two. 
+          NOTE: This logic is duplicated in Microsoft.VisualBasic.targets and in Microsoft.CSharp.targets because those two files
+          import Microsoft.Common.targets from the current directory and thus don't get the benefit of the redirections, so for
+          any changes to this logic in this file, please also edit the other two.
       -->
     <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">$(ImportByWildcardBeforeMicrosoftCommonTargets)</ImportByWildcardBefore40MicrosoftCommonTargets>
     <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">true</ImportByWildcardBefore40MicrosoftCommonTargets>
@@ -73,15 +74,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == '' and ('$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == 'Silverlight' or ('$(TargetFrameworkIdentifier)' == '' and ('$(TargetRuntime)' == 'Managed' or '$(TargetRuntime)' == '')))">
-     <!-- 
-          Overrides for the Microsoft.NETFramework.props extension targets. Used to make sure that only the imports we specify 
-          (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Required because 
-          Microsoft.Common.targets imports it from the current directory, so we don't get a chance to redirect these in its 
-          own redirection targets. 
-
-          NOTE: This logic is duplicated in Microsoft.VisualBasic.targets and in Microsoft.CSharp.targets because those two files 
-          import Microsoft.Common.targets from the current directory and thus don't get the benefit of these redirections either, 
-          so for any changes to this logic in this file, please also edit the other two. 
+     <!--
+          Overrides for the Microsoft.NETFramework.props extension targets. Used to make sure that only the imports we specify
+          (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Required because
+          Microsoft.Common.targets imports it from the current directory, so we don't get a chance to redirect these in its
+          own redirection targets.
+
+          NOTE: This logic is duplicated in Microsoft.VisualBasic.targets and in Microsoft.CSharp.targets because those two files
+          import Microsoft.Common.targets from the current directory and thus don't get the benefit of these redirections either,
+          so for any changes to this logic in this file, please also edit the other two.
       -->
     <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">$(ImportByWildcardBeforeMicrosoftNetFrameworkProps)</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
     <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">true</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
@@ -104,7 +105,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')"/>
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')"/>
@@ -116,7 +117,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <!--
       Prepare to import project extensions which usually come from packages.  Package management systems will create a file at:
           $(MSBuildProjectExtensionsPath)\$(MSBuildProjectFile).<SomethingUnique>.targets
-          
+
         Each package management system should use a unique moniker to avoid collisions.  It is a wild-card import so the package
         management system can write out multiple files but the order of the import is alphabetic because MSBuild sorts the list.
     -->
@@ -130,14 +131,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ImportDirectoryBuildTargets Condition="'$(ImportDirectoryBuildTargets)' == ''">true</ImportDirectoryBuildTargets>
   </PropertyGroup>
 
-  <!-- 
+  <!--
         Determine the path to the directory build targets file if the user did not disable $(ImportDirectoryBuildTargets) and
         they did not already specify an absolute path to use via $(DirectoryBuildTargetsPath)
     -->
   <PropertyGroup Condition="'$(ImportDirectoryBuildTargets)' == 'true' and '$(DirectoryBuildTargetsPath)' == ''">
     <_DirectoryBuildTargetsFile Condition="'$(_DirectoryBuildTargetsFile)' == ''">Directory.Build.targets</_DirectoryBuildTargetsFile>
     <_DirectoryBuildTargetsBasePath Condition="'$(_DirectoryBuildTargetsBasePath)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildProjectDirectory), '$(_DirectoryBuildTargetsFile)'))</_DirectoryBuildTargetsBasePath>
-    <DirectoryBuildTargetsPath Condition="'$(_DirectoryBuildTargetsBasePath)' != '' and '$(_DirectoryBuildTargetsFile)' != ''">$([MSBuild]::NormalizePath('$(_DirectoryBuildTargetsBasePath)', '$(_DirectoryBuildTargetsFile)'))</DirectoryBuildTargetsPath>
+    <DirectoryBuildTargetsPath Condition="'$(_DirectoryBuildTargetsBasePath)' != '' and '$(_DirectoryBuildTargetsFile)' != ''">$([System.IO.Path]::Combine('$(_DirectoryBuildTargetsBasePath)', '$(_DirectoryBuildTargetsFile)'))</DirectoryBuildTargetsPath>
   </PropertyGroup>
 
   <Import Project="$(DirectoryBuildTargetsPath)" Condition="'$(ImportDirectoryBuildTargets)' == 'true' and exists('$(DirectoryBuildTargetsPath)')"/>
@@ -145,17 +146,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')"/>
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')"/>
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')"/>
   </ImportGroup>
 
-   <!-- Fix up FrameworkPathOverride, which is primarily used to determine the location of mscorlib.dll in the 
-        (relatively uncommon) situation where the reference assemblies, in which it's usually found, are not 
+   <!-- Fix up FrameworkPathOverride, which is primarily used to determine the location of mscorlib.dll in the
+        (relatively uncommon) situation where the reference assemblies, in which it's usually found, are not
         installed.  -->
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <FrameworkPathOverride Condition="!Exists('$(FrameworkPathOverride)\mscorlib.dll')">$(MSBuildFrameworkToolsPath)</FrameworkPathOverride>
    </PropertyGroup>
+
 </Project>
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index a1eb793d5ee..6cef8ef8661 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -1,6 +1,7 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
     <!-- This file lists all the tasks that ship by default with MSBuild -->
-    
+
     <!-- NOTE: Listing a <UsingTask> tag in a *.tasks file like this one rather than in a project or targets file
                can give a significant performance advantage in a large build, because every time a <UsingTask> tag
                is encountered, it will cause the task to be rediscovered next time the task is used. -->
@@ -110,7 +111,7 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.FindAppConfigFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.FindInList"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.FindInvalidProjectReferences"          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
-    
+
     <UsingTask TaskName="Microsoft.Build.Tasks.FindUnderPath"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.FormatUrl"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.FormatVersion"                         AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
@@ -181,5 +182,5 @@
     <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Csc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Vbc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly"           AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" Condition="'$(MSBuildAssemblyVersion)' != ''" />
-</Project>
 
+</Project>
diff --git a/src/Tasks/Microsoft.Data.Entity.targets b/src/Tasks/Microsoft.Data.Entity.targets
index 4052db0deb8..534b0e4c192 100644
--- a/src/Tasks/Microsoft.Data.Entity.targets
+++ b/src/Tasks/Microsoft.Data.Entity.targets
@@ -1,12 +1,13 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
+
+   <!--
         With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  
+        outside of the .NET Framework.  As a result of this, there were several targets files, of which
+        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
-        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
+        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+        consumers of them are not broken, but since the targets files themselves are still part of .NET,
+        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
    -->
 
    <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.Data.Entity.targets" Condition="Exists('$(MSBuildFrameworkToolsPath)\Microsoft.Data.Entity.targets')" />
diff --git a/src/Tasks/Microsoft.Managed.Before.targets b/src/Tasks/Microsoft.Managed.Before.targets
index e7154e0a2f9..d8bde6bb9a2 100644
--- a/src/Tasks/Microsoft.Managed.Before.targets
+++ b/src/Tasks/Microsoft.Managed.Before.targets
@@ -12,6 +12,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project>
+
    <!--
         We are doing a cross-targeting build if there is a non-empty list of target frameworks specified
         and there is no current target framework being built individually. In that case, a multitargeting
diff --git a/src/Tasks/Microsoft.NET.props b/src/Tasks/Microsoft.NET.props
index 6c3062ab1e5..12ee616dbce 100644
--- a/src/Tasks/Microsoft.NET.props
+++ b/src/Tasks/Microsoft.NET.props
@@ -29,7 +29,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <!--
     ============================================================
                                         SetHighEntropyVA
-    Set HighEntropyVA according to the TargetFramework 
+    Set HighEntropyVA according to the TargetFramework
     ============================================================
     -->
 
diff --git a/src/Tasks/Microsoft.NETFramework.CurrentVersion.props b/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
index 3433452ee28..10000e46364 100644
--- a/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
+++ b/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
@@ -28,9 +28,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <!-- By default we want to replace subsets with profiles, but we do need a way to turning off this "upgrade" in case a user needs to target a subset-->
     <UpgradeSubsetToProfile Condition="'$(UpgradeSubsetToProfile)' == '' ">true</UpgradeSubsetToProfile>
-
     <TargetFrameworkProfile Condition="'$(UpgradeSubsetToProfile)' == 'true' and '$(TargetFrameworkSubset)' != '' and '$(TargetFrameworkProfile)' == ''">$(TargetFrameworkSubset)</TargetFrameworkProfile>
-
     <!-- If we are not upgrading the Subset to a profile this means we want to target a subset, do not wipe out the subset name-->
     <TargetFrameworkSubset Condition="'$(UpgradeTargetFrameworkSubsetToProfile)' == 'true'"></TargetFrameworkSubset>
   </PropertyGroup>
@@ -41,7 +39,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetFrameworkVersion)' == 'v4.0' and '$(FrameworkPathOverride)' == ''">
-
     <!-- The FrameworkPathOverride property is required for the IDE Visual Basic compiler to initialize.
              This location contains reference assemblies for mscorlib.dll and other key VB assemblies.
              This property is required during project evaluation, since the IDE compilers need to initialize before
@@ -62,7 +59,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <MSBuildFrameworkToolsRoot Condition="'$(MSBuildFrameworkToolsRoot)' == '' and '$(MSBuildRuntimeType)' != 'Core'">$(Registry:HKEY_LOCAL_MACHINE\Software\Microsoft\.NETFramework@InstallRoot)</MSBuildFrameworkToolsRoot>
     <_DeploymentSignClickOnceManifests Condition="'$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(SignManifests)' == 'true'">true</_DeploymentSignClickOnceManifests>
-
     <!-- Assembly names added to the AdditionalExplicitAssemblyReferences property will be added as references to the resolve assembly reference call by default this is done because when upgrading from
          a project targeting 2.0 to 3.5 the system.core reference is not added, therefore we need to add it automatically -->
     <AddAdditionalExplicitAssemblyReferences Condition="'$(AddAdditionalExplicitAssemblyReferences)' == ''">true</AddAdditionalExplicitAssemblyReferences>
@@ -79,17 +75,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <PropertyGroup>
     <TargetingClr2Framework Condition="'$(TargetFrameworkVersion)' == 'v2.0' or '$(TargetFrameworkVersion)' == 'v3.0' or '$(TargetFrameworkVersion)' == 'v3.5'">true</TargetingClr2Framework>
-
     <MSBuildManagedCompilerPath Condition="'$(TargetingClr2Framework)' == 'true'">$(MSBuildFrameworkToolsRoot)\v3.5</MSBuildManagedCompilerPath >
-
     <TargetFrameworkSDKToolsDirectory Condition="'$(TargetingClr2Framework)' == 'true'">$(SDK35ToolsPath)</TargetFrameworkSDKToolsDirectory>
     <!-- If the sdk path is not 3.5 or lower set it to the 40 sdk tools path. This will allow future target framework versions to use the 4.0 sdk tool set
              When a new windows SDK revs they will inplace update the location pointed to by this property. When a new sdk is release this target will have to be
              revised along with another toolsversion. -->
-
     <TargetedRuntimeVersion Condition="'$(TargetedRuntimeVersion)' == '' and ('$(TargetingClr2Framework)' == 'true')">v2.0.50727</TargetedRuntimeVersion>
     <TargetedRuntimeVersion Condition="'$(TargetedRuntimeVersion)' == ''">v$(MSBuildRuntimeVersion)</TargetedRuntimeVersion>
-
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0' and ('$(OutputType)' == 'exe' or '$(OutputType)' == 'winexe' or '$(OutputType)' == 'appcontainerexe' or '$(OutputType)' == '')">
diff --git a/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets b/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets
index e39ebb16d75..5e79387e8cd 100644
--- a/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.NETFramework.CurrentVersion.targets
@@ -24,12 +24,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportBefore')"/>
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportBefore\*" Condition="'$(ImportByWildcardBeforeMicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportBefore')"/>
-  
+
   <Target
       Name="GetFrameworkPaths"
       DependsOnTargets="$(GetFrameworkPathsDependsOn)">
 
-    <!-- For backwards compatibility of targets who replaced this target we cannot move these values outside the target even though they 
+    <!-- For backwards compatibility of targets who replaced this target we cannot move these values outside the target even though they
              now only depend on statically availiable values-->
 
     <ItemGroup>
@@ -58,7 +58,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
       <_CombinedTargetFrameworkDirectoriesItem Condition=" '@(_CombinedTargetFrameworkDirectoriesItem)' == ''"
                                                  Include="@(_TargetedFrameworkDirectoryItem)" />
-
     </ItemGroup>
 
     <PropertyGroup>
@@ -69,6 +68,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ItemGroup>
       <_TargetFrameworkSDKDirectoryItem Include="$(TargetFrameworkSDKDirectory)"/>
     </ItemGroup>
+
   </Target>
 
   <PropertyGroup>
@@ -82,14 +82,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       GetReferenceAssemblyPaths
     </ImplicitlyExpandDesignTimeFacadesDependsOn>
   </PropertyGroup>
-  
+
   <!-- Implicitly references all portable design-time facades if the user is referencing a System.Runtime-based portable library -->
   <Target Name="ImplicitlyExpandDesignTimeFacades" Condition="'$(ImplicitlyExpandDesignTimeFacades)' == 'true'" DependsOnTargets="$(ImplicitlyExpandDesignTimeFacadesDependsOn)">
 
     <PropertyGroup>
       <!-- Does one of our dependencies reference a System.Runtime-based portable library? -->
       <_HasReferenceToSystemRuntime Condition="'$(DependsOnSystemRuntime)' == 'true'">true</_HasReferenceToSystemRuntime>
-
       <_HasReferenceToSystemRuntime Condition="'%(_ResolvedProjectReferencePaths.TargetPlatformIdentifier)' == 'Portable'">true</_HasReferenceToSystemRuntime>
       <_HasReferenceToSystemRuntime Condition="'%(_ResolvedProjectReferencePaths.TargetFrameworkIdentifier)' == '.NETStandard' and '%(_ResolvedProjectReferencePaths.TargetFrameworkVersion)' &lt; '2.0'">true</_HasReferenceToSystemRuntime>
 
@@ -100,10 +99,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ItemGroup Condition="'$(_HasReferenceToSystemRuntime)' == 'true'">
       <_DesignTimeFacadeAssemblies Include="%(DesignTimeFacadeDirectories.Identity)*.dll"/>
     </ItemGroup>
+
     <ItemGroup Condition="'$(_HasReferenceToNETStandard)' == 'true' And '$(_HasReferenceToSystemRuntime)' != 'true'">
       <_DesignTimeFacadeAssemblies Include="%(DesignTimeFacadeDirectories.Identity)netstandard.dll"
                                    Condition="Exists('%(DesignTimeFacadeDirectories.Identity)netstandard.dll')"/>
     </ItemGroup>
+
     <ItemGroup Condition="'$(_HasReferenceToSystemRuntime)' == 'true' Or '$(_HasReferenceToNETStandard)' == 'true' ">
       <_DesignTimeFacadeAssemblies_Names Include="@(_DesignTimeFacadeAssemblies->'%(FileName)')">
           <OriginalIdentity>%(_DesignTimeFacadeAssemblies.Identity)</OriginalIdentity>
@@ -120,6 +121,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <CopyLocal>false</CopyLocal>
         <ResolvedFrom>ImplicitlyExpandDesignTimeFacades</ResolvedFrom>
       </ReferencePath>
+
       <_ResolveAssemblyReferenceResolvedFiles Include="@(ReferencePath)" Condition="'%(ReferencePath.ResolvedFrom)' == 'ImplicitlyExpandDesignTimeFacades'" />
     </ItemGroup>
 
@@ -128,7 +130,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(MSBuildToolsPath)\Microsoft.WinFX.targets" Condition="'$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetCompactFramework)' != 'true' and Exists('$(MSBuildToolsPath)\Microsoft.WinFX.targets')"/>
   <Import Project="$(MSBuildToolsPath)\Microsoft.Data.Entity.targets" Condition="'$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' !=  'v3.0' and Exists('$(MSBuildToolsPath)\Microsoft.Data.Entity.targets')"/>
-  
+
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter')"/>
   <Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.NETFramework.targets\ImportAfter')"/>
 
diff --git a/src/Tasks/Microsoft.NETFramework.props b/src/Tasks/Microsoft.NETFramework.props
index d33d74e017b..ed2109fb069 100644
--- a/src/Tasks/Microsoft.NETFramework.props
+++ b/src/Tasks/Microsoft.NETFramework.props
@@ -14,18 +14,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
-        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed 
-        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead 
-        just used whatever ToolsVersion was in the project file if it existed on the machine, and 
-        only forced 4.0 if that ToolsVersion did not exist.  
-
-        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio, 
-        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected 
-        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved 
-        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist 
+
+   <!--
+        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed
+        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead
+        just used whatever ToolsVersion was in the project file if it existed on the machine, and
+        only forced 4.0 if that ToolsVersion did not exist.
+
+        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio,
+        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected
+        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved
+        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist
         as part of the .NET Framework.  Only if we're using the new MSBuild will we point to the current
-        targets. 
+        targets.
    -->
 
    <Choose>
diff --git a/src/Tasks/Microsoft.NETFramework.targets b/src/Tasks/Microsoft.NETFramework.targets
index 83a06860838..47f919f678d 100644
--- a/src/Tasks/Microsoft.NETFramework.targets
+++ b/src/Tasks/Microsoft.NETFramework.targets
@@ -14,18 +14,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
-        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed 
-        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead 
-        just used whatever ToolsVersion was in the project file if it existed on the machine, and 
-        only forced 4.0 if that ToolsVersion did not exist.  
-
-        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio, 
-        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected 
-        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved 
-        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist 
+
+   <!--
+        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed
+        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead
+        just used whatever ToolsVersion was in the project file if it existed on the machine, and
+        only forced 4.0 if that ToolsVersion did not exist.
+
+        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio,
+        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected
+        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved
+        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist
         as part of the .NET Framework.  Only if we're using the new MSBuild will we point to the current
-        targets. 
+        targets.
    -->
 
    <Choose>
@@ -43,8 +44,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <!--
-           Overrides for the Microsoft.NETFramework.targets extension targets.  Used to make sure that only the imports we specify 
-           (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. 
+           Overrides for the Microsoft.NETFramework.targets extension targets.  Used to make sure that only the imports we specify
+           (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default.
        -->
       <ImportByWildcardBefore40MicrosoftNetFrameworkTargets Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkTargets)' == ''">$(ImportByWildcardBeforeMicrosoftNetFrameworkTargets)</ImportByWildcardBefore40MicrosoftNetFrameworkTargets>
       <ImportByWildcardBefore40MicrosoftNetFrameworkTargets Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkTargets)' == ''">true</ImportByWildcardBefore40MicrosoftNetFrameworkTargets>
@@ -67,13 +68,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportBefore')"/>
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportBefore')"/>
-   </ImportGroup> 
+   </ImportGroup>
 
    <Import Project="$(NetFrameworkTargetsPath)" />
 
    <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportAfter')"/>
       <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.targets\ImportAfter')"/>
-   </ImportGroup> 
+   </ImportGroup>
 
 </Project>
diff --git a/src/Tasks/Microsoft.ServiceModel.targets b/src/Tasks/Microsoft.ServiceModel.targets
index 2a443dbb90b..10579ef15e2 100644
--- a/src/Tasks/Microsoft.ServiceModel.targets
+++ b/src/Tasks/Microsoft.ServiceModel.targets
@@ -1,12 +1,13 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
+
+   <!--
         With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  
+        outside of the .NET Framework.  As a result of this, there were several targets files, of which
+        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
-        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
+        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+        consumers of them are not broken, but since the targets files themselves are still part of .NET,
+        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
    -->
 
    <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.ServiceModel.targets" Condition="Exists('$(MSBuildFrameworkToolsPath)\Microsoft.ServiceModel.targets')" />
diff --git a/src/Tasks/Microsoft.VisualBasic.CrossTargeting.targets b/src/Tasks/Microsoft.VisualBasic.CrossTargeting.targets
index e0c0b18d373..6d0ca32d78f 100644
--- a/src/Tasks/Microsoft.VisualBasic.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.VisualBasic.CrossTargeting.targets
@@ -17,6 +17,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
      <VisualBasicDesignTimeTargetsPath Condition="'$(VisualBasicDesignTimeTargetsPath)'==''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\Managed\Microsoft.VisualBasic.DesignTime.targets</VisualBasicDesignTimeTargetsPath>
   </PropertyGroup>
+
   <Import Project="$(VisualBasicDesignTimeTargetsPath)" Condition="'$(VisualBasicDesignTimeTargetsPath)' != '' and Exists('$(VisualBasicDesignTimeTargetsPath)')" />
 
   <Import Project="Microsoft.Common.CrossTargeting.targets" />
diff --git a/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets b/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
index 5bb53d681e2..512fa288efc 100644
--- a/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.VisualBasic.CurrentVersion.targets
@@ -8,7 +8,7 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 
 This file defines the steps in the standard build process specific for VB .NET projects.
 For example, it contains the step that actually calls the VB compiler.  The remainder
-of the build process is defined in Microsoft.Common.targets, which is imported by 
+of the build process is defined in Microsoft.Common.targets, which is imported by
 this file.
 
 Copyright (C) Microsoft Corporation. All rights reserved.
@@ -21,7 +21,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
        <ImportByWildcardBeforeMicrosoftVisualBasicTargets Condition="'$(ImportByWildcardBeforeMicrosoftVisualBasicTargets)' == ''">true</ImportByWildcardBeforeMicrosoftVisualBasicTargets>
        <ImportByWildcardAfterMicrosoftVisualBasicTargets Condition="'$(ImportByWildcardAfterMicrosoftVisualBasicTargets)' == ''">true</ImportByWildcardAfterMicrosoftVisualBasicTargets>
        <ImportUserLocationsByWildcardBeforeMicrosoftVisualBasicTargets Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftVisualBasicTargets)' == ''">true</ImportUserLocationsByWildcardBeforeMicrosoftVisualBasicTargets>
-       <ImportUserLocationsByWildcardAfterMicrosoftVisualBasicTargets Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftVisualBasicTargets)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftVisualBasicTargets>    
+       <ImportUserLocationsByWildcardAfterMicrosoftVisualBasicTargets Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftVisualBasicTargets)' == ''">true</ImportUserLocationsByWildcardAfterMicrosoftVisualBasicTargets>
     </PropertyGroup>
 
     <Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualBasic.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBeforeMicrosoftVisualBasicTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.VisualBasic.targets\ImportBefore')"/>
@@ -65,14 +65,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!--
     The CreateManifestResourceNames target create the manifest resource names from the .RESX
-    files.      
-    
+    files.
+
         [IN]
         @(EmbeddedResource) - The list of EmbeddedResource items that have been pre-processed to add metadata about resource type
                               Expected Metadata "Type" can either be "Resx" or "Non-Resx"
 
         [OUT]
-        @(EmbeddedResource) - EmbeddedResource items with metadata    
+        @(EmbeddedResource) - EmbeddedResource items with metadata
 
     For VB applications the transformation is like:
 
@@ -83,30 +83,29 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     For other project systems, this transformation may be different.
     -->
+
     <PropertyGroup>
         <CreateManifestResourceNamesDependsOn></CreateManifestResourceNamesDependsOn>
     </PropertyGroup>
+
     <Target
         Name="CreateManifestResourceNames"
         Condition="'@(EmbeddedResource)' != ''"
         DependsOnTargets="$(CreateManifestResourceNamesDependsOn)"
         >
-        
         <ItemGroup>
             <_Temporary Remove="@(_Temporary)" />
         </ItemGroup>
-        
+
         <!-- Create manifest names for culture and non-culture Resx files, and for non-culture Non-Resx resources -->
         <CreateVisualBasicManifestResourceName
               ResourceFiles="@(EmbeddedResource)"
               RootNamespace="$(RootNamespace)"
               UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)"
               Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and ('%(EmbeddedResource.WithCulture)' == 'false' or '%(EmbeddedResource.Type)' == 'Resx')">
-
             <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
-
         </CreateVisualBasicManifestResourceName>
-        
+
         <!-- Create manifest names for all culture non-resx resources -->
         <CreateVisualBasicManifestResourceName
               ResourceFiles="@(EmbeddedResource)"
@@ -114,9 +113,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               PrependCultureAsDirectory="false"
               UseDependentUponConvention="$(EmbeddedResourceUseDependentUponConvention)"
               Condition="'%(EmbeddedResource.ManifestResourceName)' == '' and '%(EmbeddedResource.WithCulture)' == 'true' and '%(EmbeddedResource.Type)' == 'Non-Resx'">
-
             <Output TaskParameter="ResourceFilesWithManifestResourceNames" ItemName="_Temporary" />
-
         </CreateVisualBasicManifestResourceName>
 
         <ItemGroup>
@@ -124,23 +121,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.
             <EmbeddedResource Include="@(_Temporary)" />
             <_Temporary Remove="@(_Temporary)" />
         </ItemGroup>
-      
     </Target>
 
     <Target
         Name="ResolveCodeAnalysisRuleSet"
         Condition="'$(CodeAnalysisRuleSet)' != ''"
         >
-
         <ResolveCodeAnalysisRuleSet
             CodeAnalysisRuleSet="$(CodeAnalysisRuleSet)"
             CodeAnalysisRuleSetDirectories="$(CodeAnalysisRuleSetDirectories)"
             MSBuildProjectDirectory="$(MSBuildProjectDirectory)">
-
             <Output TaskParameter="ResolvedCodeAnalysisRuleSet" PropertyName="ResolvedCodeAnalysisRuleSet" />
-
         </ResolveCodeAnalysisRuleSet>
-
     </Target>
 
     <PropertyGroup>
@@ -205,8 +197,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <PropertyGroup>
             <_NoWarnings Condition=" '$(WarningLevel)' == '0' ">true</_NoWarnings>
             <_NoWarnings Condition=" '$(WarningLevel)' == '1' ">false</_NoWarnings>
-        </PropertyGroup> 
-        
+        </PropertyGroup>
+
         <PropertyGroup>
           <!-- If we are targeting winmdobj we want to specifically set the pdbFile property so that it does not collide with the output of winmdexp which we will run subsequently -->
           <PdbFile Condition="'$(PdbFile)' == '' and '$(OutputType)' == 'winmdobj' and '$(DebugSymbols)' == 'true'">$(IntermediateOutputPath)$(TargetName).compile.pdb</PdbFile>
@@ -227,7 +219,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
           <AdditionalFileItems Include="$(AdditionalFileItemNames)" />
           <AdditionalFiles Include="@(%(AdditionalFileItems.Identity))" />
         </ItemGroup>
-      
+
         <!-- Don't run analyzers for Vbc task on XamlPrecompile pass, we only want to run them on core compile. -->
         <!-- Analyzers="@(Analyzer)" -->
 
@@ -272,7 +264,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               OptionExplicit="$(OptionExplicit)"
               OptionInfer="$(OptionInfer)"
               OptionStrict="$(OptionStrict)"
-              OptionStrictType="$(OptionStrictType)" 
+              OptionStrictType="$(OptionStrictType)"
               OutputAssembly="@(XamlIntermediateAssembly)"
               Platform="$(PlatformTarget)"
               Prefer32Bit="$(Prefer32Bit)"
@@ -308,12 +300,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
  <!-- Only Applicable to the regular CoreCompile:
               <ItemGroup>
-                  <_CoreCompileResourceInputs Remove="@(_CoreCompileResourceInputs)" />                  
-              </ItemGroup>    
-              
-              <CallTarget Targets="$(TargetsTriggeredByCompilation)" Condition="'$(TargetsTriggeredByCompilation)' != ''"/>         
- -->         
-        <OnError Condition="'$(OnXamlPreCompileErrorTarget)' != ''" ExecuteTargets="$(OnXamlPreCompileErrorTarget)" />    
+                  <_CoreCompileResourceInputs Remove="@(_CoreCompileResourceInputs)" />
+              </ItemGroup>
+
+              <CallTarget Targets="$(TargetsTriggeredByCompilation)" Condition="'$(TargetsTriggeredByCompilation)' != ''"/>
+ -->
+        <OnError Condition="'$(OnXamlPreCompileErrorTarget)' != ''" ExecuteTargets="$(OnXamlPreCompileErrorTarget)" />
     </Target>
 
     <PropertyGroup>
@@ -328,9 +320,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <PropertyGroup>
        <VisualBasicDesignTimeTargetsPath Condition="'$(VisualBasicDesignTimeTargetsPath)'==''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\Managed\Microsoft.VisualBasic.DesignTime.targets</VisualBasicDesignTimeTargetsPath>
     </PropertyGroup>
+
     <Import Project="$(VisualBasicDesignTimeTargetsPath)" Condition="'$(VisualBasicDesignTimeTargetsPath)' != '' and Exists('$(VisualBasicDesignTimeTargetsPath)')" />
 
     <Import Project="Microsoft.Common.targets" />
+
     <Import Project="$(MSBuildToolsPath)\Microsoft.ServiceModel.targets" Condition="('$(TargetFrameworkVersion)' != 'v2.0' and '$(TargetFrameworkVersion)' != 'v3.0' and '$(TargetFrameworkVersion)' != 'v3.5') and Exists('$(MSBuildToolsPath)\Microsoft.ServiceModel.targets')"/>
 
     <Target Name="_SetTargetFrameworkMonikerAttribute" BeforeTargets="GenerateTargetFrameworkMonikerAttribute">
@@ -350,7 +344,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <PropertyGroup>
        <Utf8Output Condition="'$(Utf8Output)' == ''">true</Utf8Output>
-
       <!-- NoCompilerStandardLib maps to the compiler's /nostdlib option. By default we always
            want that switch to be passed to the compiler so that either we or the user
            provides the references
@@ -358,7 +351,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
            so only if NoStdLib isn't set to true, will we provide the standard references
       -->
       <NoCompilerStandardLib Condition=" '$(NoCompilerStandardLib)' == '' ">true</NoCompilerStandardLib>
-
        <!-- When building inside VS, by default use the same language for compiler messages as VS itself does. -->
        <PreferredUILang Condition="'$(BuildingInsideVisualStudio)' == 'true' and '$(PreferredUILang)' == ''">$([System.Globalization.CultureInfo]::CurrentUICulture.Name)</PreferredUILang>
     </PropertyGroup>
diff --git a/src/Tasks/Microsoft.VisualBasic.targets b/src/Tasks/Microsoft.VisualBasic.targets
index 3e597e1f304..9e3824ca1b2 100644
--- a/src/Tasks/Microsoft.VisualBasic.targets
+++ b/src/Tasks/Microsoft.VisualBasic.targets
@@ -9,7 +9,7 @@ WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and
 
 This file defines the steps in the standard build process specific for VB .NET projects.
 For example, it contains the step that actually calls the VB compiler.  The remainder
-of the build process is defined in Microsoft.Common.targets, which is imported by 
+of the build process is defined in Microsoft.Common.targets, which is imported by
 this file.
 
 Copyright (C) Microsoft Corporation. All rights reserved.
@@ -17,26 +17,26 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 -->
 
 <Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
    <!--
-        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed 
-        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead 
-        just used whatever ToolsVersion was in the project file if it existed on the machine, and 
-        only forced 4.0 if that ToolsVersion did not exist.  
-
-        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio, 
-        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected 
-        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved 
-        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist 
+        In VS 2010 SP1 and VS 2012, both supported for asset compatibility, the MSBuild installed
+        as part of them did not enforce using the local ToolsVersion (4.0) in all cases, but instead
+        just used whatever ToolsVersion was in the project file if it existed on the machine, and
+        only forced 4.0 if that ToolsVersion did not exist.
+
+        Moving forward, we do want to enforce a single acting ToolsVersion per version of Visual Studio,
+        but in order to approximate this behavior on VS 2010 SP1 and VS 2012 as well, we've redirected
+        the targets:  If we're building using 4.X MSBuild (which doesn't define the new reserved
+        property, MSBuildAssemblyVersion), we'll point right back at the 4.0 targets, which still exist
         as part of the .NET Framework.  Only if we're using the new MSBuild will we point to the current
-        targets. 
+        targets.
    -->
 
   <Choose>
     <When Condition="'$(MSBuildAssemblyVersion)' == ''">
       <PropertyGroup>
         <VisualBasicTargetsPath>$(MSBuildFrameworkToolsPath)\Microsoft.VisualBasic.targets</VisualBasicTargetsPath>
-
-        <!-- Same condition as in .NET 4.5 VB targets so that we can override the behavior where it defaults to 
+        <!-- Same condition as in .NET 4.5 VB targets so that we can override the behavior where it defaults to
              MSBuildToolsPath, which would be incorrect in this case -->
         <VbcToolPath Condition="'$(VbcToolPath)' == '' and '$(BuildingInsideVisualStudio)' != 'true'">$(MsBuildFrameworkToolsPath)</VbcToolPath>
       </PropertyGroup>
@@ -54,14 +54,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </Choose>
 
   <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
-    <!-- 
-         Overrides for the Microsoft.Common.targets extension targets. Used to make sure that only the imports we specify 
-         (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Defined here because 
-         Microsoft.VisualBasic.targets imports Microsoft.Common.targets from the current directory rather than using 
+    <!--
+         Overrides for the Microsoft.Common.targets extension targets. Used to make sure that only the imports we specify
+         (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Defined here because
+         Microsoft.VisualBasic.targets imports Microsoft.Common.targets from the current directory rather than using
          MSBuildToolsPath, so defining these in Microsoft.Common.targets alone would not suffice for VB projects.
 
          NOTE: This logic is duplicated in Microsoft.CSharp.targets (C# has the same problem) and in Microsoft.Common.targets
-         (for anyone who DOES import it directly), so for any changes to this logic in this file, please also edit the other two. 
+         (for anyone who DOES import it directly), so for any changes to this logic in this file, please also edit the other two.
      -->
     <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">$(ImportByWildcardBeforeMicrosoftCommonTargets)</ImportByWildcardBefore40MicrosoftCommonTargets>
     <ImportByWildcardBefore40MicrosoftCommonTargets Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == ''">true</ImportByWildcardBefore40MicrosoftCommonTargets>
@@ -106,15 +106,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == '' and ('$(TargetFrameworkIdentifier)' == '.NETFramework' or '$(TargetFrameworkIdentifier)' == 'Silverlight' or ('$(TargetFrameworkIdentifier)' == '' and ('$(TargetRuntime)' == 'Managed' or '$(TargetRuntime)' == '')))">
-     <!-- 
-          Overrides for the Microsoft.NETFramework.props extension targets. Used to make sure that only the imports we specify 
-          (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Required because 
-          Microsoft.Common.targets imports it from the current directory, so we don't get a chance to redirect these in its 
+     <!--
+          Overrides for the Microsoft.NETFramework.props extension targets. Used to make sure that only the imports we specify
+          (hard-coded to 4.0 locations) are used, not the 12.0 locations that would be used by default. Required because
+          Microsoft.Common.targets imports it from the current directory, so we don't get a chance to redirect these in its
           own redirection targets.
 
           NOTE: This logic is duplicated in Microsoft.CSharp.targets and in Microsoft.Common.targets because VB and C#
-          import Microsoft.Common.targets from the current directory and thus don't get the benefit of these redirections either, 
-          so for any changes to this logic in this file, please also edit the other two. 
+          import Microsoft.Common.targets from the current directory and thus don't get the benefit of these redirections either,
+          so for any changes to this logic in this file, please also edit the other two.
       -->
     <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">$(ImportByWildcardBeforeMicrosoftNetFrameworkProps)</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
     <ImportByWildcardBefore40MicrosoftNetFrameworkProps Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == ''">true</ImportByWildcardBefore40MicrosoftNetFrameworkProps>
@@ -137,24 +137,24 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftVisualBasicTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportBefore')"/>
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftVisualBasicTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportBefore')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
-  <!-- Really should be imported right before Microsoft.Common.targets, but because Microsoft.VisualBasic.targets imports 
+  <!-- Really should be imported right before Microsoft.Common.targets, but because Microsoft.VisualBasic.targets imports
        Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-       targets), we're stuck doing it this way instead. --> 
+       targets), we're stuck doing it this way instead. -->
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')"/>
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportBefore')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
-  <!-- Really should be imported right before Microsoft.NETFramework.props, but because Microsoft.VisualBasic.targets imports 
+  <!-- Really should be imported right before Microsoft.NETFramework.props, but because Microsoft.VisualBasic.targets imports
        Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-       targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this 
-       way instead. --> 
+       targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this
+       way instead. -->
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportUserLocationsByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')"/>
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
   <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.Before.targets" />
 
@@ -164,31 +164,32 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <!-- Really should be imported right after Microsoft.NETFramework.props, but because Microsoft.VisualBasic.targets imports
        Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-       targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this 
-       way instead. --> 
+       targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this
+       way instead. -->
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')"/>
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportAfter')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
-  <!-- Really should be imported right after Microsoft.Common.targets, but because Microsoft.VisualBasic.targets imports 
+  <!-- Really should be imported right after Microsoft.Common.targets, but because Microsoft.VisualBasic.targets imports
        Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
-       targets), we're stuck doing it this way instead. --> 
+       targets), we're stuck doing it this way instead. -->
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')"/>
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.Common.targets\ImportAfter')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
   <ImportGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfter40MicrosoftVisualBasicTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportAfter')"/>
     <Import Project="$(MSBuildUserExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfter40MicrosoftVisualBasicTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\4.0\Microsoft.VisualBasic.targets\ImportAfter')"/>
-  </ImportGroup> 
+  </ImportGroup>
 
-   <!-- Fix up FrameworkPathOverride, which is primarily used to determine the location of mscorlib.dll in the 
-        (relatively uncommon) situation where the reference assemblies, in which it's usually found, are not 
-        installed.  Defined here rather than in Microsoft.Common.targets because the .NET Microsoft.VisualBasic.targets 
+   <!-- Fix up FrameworkPathOverride, which is primarily used to determine the location of mscorlib.dll in the
+        (relatively uncommon) situation where the reference assemblies, in which it's usually found, are not
+        installed.  Defined here rather than in Microsoft.Common.targets because the .NET Microsoft.VisualBasic.targets
         imports Microsoft.Common.targets from the current directory. -->
    <PropertyGroup Condition="'$(MSBuildAssemblyVersion)' == ''">
       <FrameworkPathOverride Condition="!Exists('$(FrameworkPathOverride)\mscorlib.dll')">$(MSBuildFrameworkToolsPath)</FrameworkPathOverride>
    </PropertyGroup>
+
 </Project>
diff --git a/src/Tasks/Microsoft.WinFx.targets b/src/Tasks/Microsoft.WinFx.targets
index d42da660988..4cf77fc6f3c 100644
--- a/src/Tasks/Microsoft.WinFx.targets
+++ b/src/Tasks/Microsoft.WinFx.targets
@@ -1,12 +1,13 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
+
+   <!--
         With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  
+        outside of the .NET Framework.  As a result of this, there were several targets files, of which
+        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
-        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
+        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+        consumers of them are not broken, but since the targets files themselves are still part of .NET,
+        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
    -->
 
    <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.WinFx.targets" Condition="'$(ImportFrameworkWinFXTargets)' != 'false' and Exists('$(MSBuildFrameworkToolsPath)\Microsoft.WinFx.targets')" />
diff --git a/src/Tasks/Microsoft.WorkflowBuildExtensions.targets b/src/Tasks/Microsoft.WorkflowBuildExtensions.targets
index b2f1480fadc..448174b8eab 100644
--- a/src/Tasks/Microsoft.WorkflowBuildExtensions.targets
+++ b/src/Tasks/Microsoft.WorkflowBuildExtensions.targets
@@ -12,14 +12,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
 <Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 
-   <!-- 
+   <!--
         With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  
+        outside of the .NET Framework.  As a result of this, there were several targets files, of which
+        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
-        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
+        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+        consumers of them are not broken, but since the targets files themselves are still part of .NET,
+        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
    -->
 
    <Import Project="$(MSBuildFrameworkToolsPath)\Microsoft.WorkflowBuildExtensions.targets" Condition="Exists('$(MSBuildFrameworkToolsPath)\Microsoft.WorkflowBuildExtensions.targets')" />
@@ -35,4 +35,5 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          overriding it with a no-op implementation here.
    -->
    <Target Name="GenerateCompiledExpressionsTempFile" />
+
 </Project>
diff --git a/src/Tasks/Microsoft.Xaml.targets b/src/Tasks/Microsoft.Xaml.targets
index 70a1c2079eb..78f4055b273 100644
--- a/src/Tasks/Microsoft.Xaml.targets
+++ b/src/Tasks/Microsoft.Xaml.targets
@@ -1,17 +1,18 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
+
+   <!--
         With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  
+        outside of the .NET Framework.  As a result of this, there were several targets files, of which
+        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
-        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
+        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+        consumers of them are not broken, but since the targets files themselves are still part of .NET,
+        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
    -->
 
-   <!-- In the original Microsoft.Xaml.targets this is mapped to MSBuildBinPath, which is no longer 
+   <!-- In the original Microsoft.Xaml.targets this is mapped to MSBuildBinPath, which is no longer
         the .NET Framework directory and thus will no longer be the right answer. Override it to point
-        to the correct .NET Framework location. --> 
+        to the correct .NET Framework location. -->
    <PropertyGroup>
       <XamlBuildTaskPath Condition="'$(XamlBuildTaskPath)' == ''">$(MSBuildToolsPath64)</XamlBuildTaskPath>
    </PropertyGroup>
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index 51ddc6acde9..74d9ab45c2c 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -901,23 +901,23 @@ public MultipleVersionSupport SupportsMultipleVersions
             /// </summary>
             public void Resolve(Dictionary<string, ITaskItem> sdks, string targetConfiguration, string targetArchitecture, HashSet<string> sdkNamesOnReferenceItems, bool treatErrorsAsWarnings, bool prefer32Bit, string identifierTargetPlatform, Version versionTargetPlatform, string projectName, bool enableMaxPlatformVersionEmptyWarning)
             {
-                if (sdks.ContainsKey(SDKName))
+                if (sdks.TryGetValue(SDKName, out ITaskItem sdk))
                 {
                     _prefer32BitFromProject = prefer32Bit;
 
                     // There must be a trailing slash or else the ExpandSDKReferenceAssemblies will not work.
-                    ResolvedPath = FileUtilities.EnsureTrailingSlash(sdks[SDKName].ItemSpec);
+                    ResolvedPath = FileUtilities.EnsureTrailingSlash(sdk.ItemSpec);
 
-                    System.Version.TryParse(sdks[SDKName].GetMetadata(SDKPlatformVersion), out Version targetPlatformVersionFromItem);
+                    System.Version.TryParse(sdk.GetMetadata(SDKPlatformVersion), out Version targetPlatformVersionFromItem);
 
                     GetSDKManifestAttributes();
 
                     CreateResolvedReferenceItem(targetConfiguration, targetArchitecture, sdkNamesOnReferenceItems, identifierTargetPlatform, versionTargetPlatform, targetPlatformVersionFromItem, projectName, enableMaxPlatformVersionEmptyWarning);
 
                     // Need to pass these along so we can unroll the platform via GetMatchingPlatformSDK when we get reference files
-                    ResolvedItem.SetMetadata(GetInstalledSDKLocations.DirectoryRootsMetadataName, sdks[SDKName].GetMetadata(GetInstalledSDKLocations.DirectoryRootsMetadataName));
-                    ResolvedItem.SetMetadata(GetInstalledSDKLocations.ExtensionDirectoryRootsMetadataName, sdks[SDKName].GetMetadata(GetInstalledSDKLocations.ExtensionDirectoryRootsMetadataName));
-                    ResolvedItem.SetMetadata(GetInstalledSDKLocations.RegistryRootMetadataName, sdks[SDKName].GetMetadata(GetInstalledSDKLocations.RegistryRootMetadataName));
+                    ResolvedItem.SetMetadata(GetInstalledSDKLocations.DirectoryRootsMetadataName, sdk.GetMetadata(GetInstalledSDKLocations.DirectoryRootsMetadataName));
+                    ResolvedItem.SetMetadata(GetInstalledSDKLocations.ExtensionDirectoryRootsMetadataName, sdk.GetMetadata(GetInstalledSDKLocations.ExtensionDirectoryRootsMetadataName));
+                    ResolvedItem.SetMetadata(GetInstalledSDKLocations.RegistryRootMetadataName, sdk.GetMetadata(GetInstalledSDKLocations.RegistryRootMetadataName));
 
                     if (!treatErrorsAsWarnings && ResolutionErrors.Count > 0)
                     {
@@ -1377,7 +1377,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
                                         continue;
                                 }
 
-                                bool containsKey = architectureLocations.ContainsKey(architectureComponent);
+                                bool containsKey = architectureLocations.TryGetValue(architectureComponent, out string architectureLocation);
 
                                 // If we have not seen this architecture before (and it has a compatible configuration with what we are targeting) then add it. 
                                 // Also, replace the entry if we have already added an entry for a non configuration specific entry and we now have a configuration specific entry that matches what we are targeting.
@@ -1387,7 +1387,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
 
                                     if (containsKey)
                                     {
-                                        AddStatusMessage("ResolveSDKReference.ReplaceAppxLocation", architectureComponent, architectureLocations[architectureComponent], appxLocation.Value);
+                                        AddStatusMessage("ResolveSDKReference.ReplaceAppxLocation", architectureComponent, architectureLocation, appxLocation.Value);
                                     }
 
                                     architectureLocations[architectureComponent] = appxLocation.Value;
@@ -1517,10 +1517,8 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
             /// </summary>
             private string FindFrameworkIdentity(string frameworkIdentityKey)
             {
-                string frameworkIdentityValue = null;
-                if (FrameworkIdentitiesFromManifest.ContainsKey(frameworkIdentityKey))
+                if (FrameworkIdentitiesFromManifest.TryGetValue(frameworkIdentityKey, out string frameworkIdentityValue))
                 {
-                    frameworkIdentityValue = FrameworkIdentitiesFromManifest[frameworkIdentityKey];
                     AddStatusMessage("ResolveSDKReference.FoundFrameworkIdentity", frameworkIdentityValue);
                 }
                 else
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index a054ea6c65a..e986acba46b 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -451,6 +451,10 @@
     <value>MSB3101: Could not write state file "{0}". {1}</value>
     <comment>{StrBegin="MSB3101: "}</comment>
   </data>
+  <data name="General.StateFileAlreadyPresent">
+    <value>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</value>
+    <comment>{StrBegin="MSB3667: "}</comment>
+  </data>
   <data name="General.DuplicateItemsNotSupported">
     <value>MSB3105: The item "{0}" was specified more than once in the "{1}" parameter.  Duplicate items are not supported by the "{1}" parameter.</value>
     <comment>{StrBegin="MSB3105: "}</comment>
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index c6ebbc2bf98..9ce911f55c9 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Globální vlastnosti:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: V {0} už nějaký soubor existuje. Pokud se pokoušíte vytvořit předvypočítanou mezipaměť, ujistěte se, že sestavujete jeden projekt, který závisí na sestaveních, nikoli sestavení samotná. Pokud spouštíte úlohu ResolveAssemblyReference běžným způsobem, nenastavujte v úloze ResolveAssemblyReference parametr AssemblyInformationCacheOutputPath.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Odstraňování vlastností:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">Soubor {0} se nerozzipoval, protože neodpovídá filtru zahrnutí nebo odpovídá filtru vyloučení.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: Nepovedlo se parsovat vzor {0}, protože obsahuje neplatný znak cesty.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: Nepovedlo se parsovat vzor {0}, protože obsahuje odkaz na vlastnost, která se nepodporuje.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 9d261b2b46f..bd86221569c 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Globale Eigenschaften:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: Unter "{0}" ist bereits eine Datei vorhanden. Wenn Sie einen vorab berechneten Cache erstellen möchten, stellen Sie sicher, dass Sie ein einzelnes Projekt erstellen, das von Ihren Assemblys abhängt, statt Ihre Assemblys selbst zu erstellen. Wenn Sie die Aufgabe "ResolveAssemblyReference" normal ausführen, legen Sie den Parameter "AssemblyInformationCacheOutputPath" der Aufgabe "ResolveAssemblyReference" nicht fest.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Eigenschaften werden entfernt:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">Die Datei "{0}" wurde nicht extrahiert, weil sie nicht dem Einschlussfilter entsprach oder weil sie dem Ausschlussfilter entsprach.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: Fehler beim Analysieren des Musters "{0}", weil es ein ungültiges Pfadzeichen enthält.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: Fehler beim Analysieren des Musters "{0}", weil es einen Eigenschaftsverweis enthält, der nicht unterstützt wird.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.en.xlf b/src/Tasks/Resources/xlf/Strings.en.xlf
index df627557c4a..afa8f0dbdc1 100644
--- a/src/Tasks/Resources/xlf/Strings.en.xlf
+++ b/src/Tasks/Resources/xlf/Strings.en.xlf
@@ -554,6 +554,11 @@
         <target state="new">Global Properties:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="new">Removing Properties:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 8a28657818f..aa643b920a8 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Propiedades globales:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: Ya hay un archivo en "{0}". Si está intentando crear una memoria caché precalculada, asegúrese de estar compilando un solo proyecto que dependa de sus ensamblados, en lugar de compilar los ensamblados en sí. Si está ejecutando la tarea ResolveAssemblyReference normalmente, no establezca el parámetro "AssemblyInformationCacheOutputPath" de la tarea ResolveAssemblyReference.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Quitando propiedades:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">El archivo "{0}" no se ha descomprimido porque no coincidía con el filtro de inclusión o coincidía con el filtro de exclusión.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: No se pudo analizar el patrón "{0}" porque contiene un carácter de ruta de acceso no válido.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: No se pudo analizar el patrón "{0}" porque contiene una referencia de propiedad que no se admite.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 3854fcf0c19..898ff0fc132 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Propriétés globales :</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: il existe déjà un fichier sur "{0}". Si vous essayez de créer un cache précalculé, vérifiez que vous générez un seul projet qui dépend de vos assemblys au lieu de générer les assemblys eux-mêmes. Si vous exécutez la tâche ResolveAssemblyReference normalement, ne définissez pas le paramètre "AssemblyInformationCacheOutputPath" de la tâche ResolveAssemblyReference.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Suppression des propriétés :</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">Impossible de décompresser le fichier "{0}", car il ne correspond pas au filtre d'inclusion, ou il correspond au filtre d'exclusion.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: échec de l'analyse du modèle "{0}", car il contient un caractère de chemin non valide.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: échec de l'analyse du modèle "{0}", car il contient une référence de propriété non prise en charge.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 14bdb0e8baf..9edcf49c294 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Proprietà globali:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Rimozione proprietà:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">Il file "{0}" non è stato decompresso perché non corrisponde al filtro di inclusione oppure perché corrisponde al filtro di esclusione.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: non è stato possibile analizzare il modello "{0}" perché contiene un carattere di percorso non valido.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: non è stato possibile analizzare il modello "{0}" perché contiene un riferimento a proprietà che non è supportato.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index a4b07fadb16..dea0a0ac56e 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -509,6 +509,11 @@
         <target state="translated">グローバル プロパティ:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: "{0}" には既にファイルが存在します。事前計算済みキャッシュを作成しようとしている場合は、アセンブリ自体をビルドするのではなく、アセンブリに依存する単一のプロジェクトをビルドしてください。ResolveAssemblyReference タスクを正常に実行している場合は、ResolveAssemblyReference タスクの "AssemblyInformationCacheOutputPath" パラメーターを設定しないでください。</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">プロパティの削除:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">包含フィルターと一致しなかったか、除外フィルターと一致したため、ファイル "{0}" を解凍できませんでした。</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: 無効なパス文字が含まれているため、パターン "{0}" を解析できませんでした。</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: サポートされていないプロパティ参照が含まれているため、パターン "{0}" を解析できませんでした。</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index e801bdd91a6..172ee98d265 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -509,6 +509,11 @@
         <target state="translated">전역 속성:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: "{0}"에 파일이 이미 있습니다. 사전 계산 캐시를 만들려면 어셈블리 자체를 빌드하는 대신 어셈블리에 종속되는 단일 프로젝트를 빌드하고 있는지 확인하세요. ResolveAssemblyReference 작업을 정상적으로 실행 중인 경우 ResolveAssemblyReference 작업의 "AssemblyInformationCacheOutputPath" 매개 변수를 설정하지 마세요.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">속성 제거:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">파일 "{0}"이(가) 포함 필터와 일치하지 않거나 제외 필터와 일치하므로 압축을 풀지 않았습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: 잘못된 경로 문자가 포함되어 있기 때문에 패턴 "{0}"을(를) 구문 분석하지 못했습니다.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: 지원되지 않는 속성 참조가 포함되어 있기 때문에 패턴 "{0}"을(를) 구문 분석하지 못했습니다.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 4251be9ff36..4522a89c716 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Właściwości globalne:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: W lokalizacji „{0}” już istnieje plik. Jeśli próbujesz utworzyć wstępnie obliczoną pamięć podręczną, upewnij się, że kompilujesz pojedynczy projekt zależący od zestawów, a nie same zestawy. Jeśli uruchamiasz zadanie ResolveAssemblyReference w normalny sposób, nie ustawiaj parametru „AssemblyInformationCacheOutputPath” zadania ResolveAssemblyReference.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Usuwanie właściwości:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">Nie rozpakowano pliku „{0}”, ponieważ nie pasował do filtru uwzględniania lub był zgodny z filtrem wykluczania.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: nie można przeanalizować wzorca „{0}”, ponieważ zawiera on nieprawidłowy znak ścieżki.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: nie można przeanalizować wzorca „{0}”, ponieważ zawiera on odwołanie do właściwości, które nie jest obsługiwane.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 1dfff7329b4..9ce92ec7bd3 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Propriedades globais:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: já existe um arquivo em "{0}". Se você está tentando criar um cache pré-computado, crie um projeto que dependa dos assemblies em vez de criar seus assemblies sozinhos. Se você está executando a tarefa ResolveAssemblyReference normalmente, não defina o parâmetro "AssemblyInformationCacheOutputPath" da tarefa ResolveAssemblyReference.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Removendo Propriedades:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">O arquivo "{0}" não foi descompactado porque não correspondeu ao filtro de inclusão ou porque correspondeu ao filtro de exclusão.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: falha ao analisar o padrão "{0}" porque ele contém um caractere de caminho inválido.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: falha ao analisar o padrão "{0}" porque ele contém uma referência de propriedade sem suporte.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 9e883f29af7..c68d9cb8fd2 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Глобальные свойства:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: в "{0}" уже существует файл. Если вы пытаетесь создать предварительно вычисляемый кэш, убедитесь, что выполняется сборка отдельного проекта, который зависит от ваших сборок, а не создание самих сборок. Если вы выполняете задачу ResolveAssemblyReference обычным образом, не устанавливайте параметр "AssemblyInformationCacheOutputPath" задачи ResolveAssemblyReference.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Удаление свойств:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">Файл "{0}" не был распакован, так как он не соответствует фильтру включения или соответствует фильтру исключения.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: не удалось проанализировать шаблон "{0}", так как он содержит недопустимый символ пути.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: не удалось проанализировать шаблон "{0}", так как он содержит ссылку на свойство, которое не поддерживается.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 194e8b3f3e1..ab7742f6560 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Genel Özellikler:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: "{0}" konumunda zaten bir dosya var. Önceden hesaplanan bir önbellek oluşturmayı deniyorsanız bütünleştirilmiş kodlarınızı derlemek yerine bütünleştirilmiş kodlarınızı temel alan tek bir proje derlediğinizden emin olun. ResolveAssemblyReference görevini normal bir şekilde çalıştırıyorsanız ResolveAssemblyReference görevinin "AssemblyInformationCacheOutputPath" parametresini ayarlamayın.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Özellikler kaldırılıyor:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">"{0}" dosyası, ekleme filtresiyle eşleşmediğinden veya dışlama filtresiyle eşleştiği için açılmadı.</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: Geçersiz bir yol karakteri içerdiğinden "{0}" deseni ayrıştırılamadı.</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: Desteklenmeyen bir özellik başvurusu içerdiğinden "{0}" deseni ayrıştırılamadı.</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 44e2fce72d4..5760ad9edcc 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -509,6 +509,11 @@
         <target state="translated">全局属性:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">移除属性:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">未解压缩文件“{0}”，因为它与包含筛选器不匹配，或者它与排除筛选器匹配。</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: 未能分析模式“{0}”，因为它包含无效的路径字符。</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: 未能分析模式“{0}”，因为它包含不受支持的属性引用。</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index a70ec8fb257..41cfdaac75b 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -509,6 +509,11 @@
         <target state="translated">全域屬性:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="translated">MSB3667: "{0}" 上已有檔案。若要嘗試建立預先計算的快取，請務必建立一個需要使用組件的專案，而非建立組件本身。若是正常執行 ResolveAssemblyReference 工作，請勿為 ResolveAssemblyReference 工作設定 "AssemblyInformationCacheOutputPath" 參數。</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">正在移除屬性:</target>
@@ -2482,7 +2487,7 @@
       </trans-unit>
       <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
         <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
-        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <target state="translated">因為檔案 "{0}" 與包含篩選器不相符，或與排除篩選器相符，所以未將該檔案解壓縮。</target>
         <note />
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
@@ -2517,12 +2522,12 @@
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
         <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
-        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <target state="translated">MSB3937: 因為模式 "{0}" 包含無效的路徑字元，所以無法加以剖析。</target>
         <note>{StrBegin="MSB3937: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
         <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
-        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <target state="translated">MSB3938: 因為模式 "{0}" 包含不支援的屬性參考，所以無法加以剖析。</target>
         <note>{StrBegin="MSB3938: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.FileComment">
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index f4649bab663..069d4272c99 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -113,7 +113,6 @@ public sealed class RoslynCodeTaskFactory : ITaskFactory
         /// <inheritdoc cref="ITaskFactory.FactoryName"/>
         public string FactoryName => "Roslyn Code Task Factory";
 
-        /// <inheritdoc />
         /// <summary>
         /// Gets the <see cref="T:System.Type" /> of the compiled task.
         /// </summary>
@@ -468,11 +467,11 @@ internal static bool TryLoadTaskBody(TaskLoggingHelper log, string taskName, str
                     bool foundValidCodeLanguage = false;
 
                     // Attempt to map the user specified value as an alias to our vernacular for code languages
-                    foreach (string validLanguage in ValidCodeLanguages.Keys)
+                    foreach (KeyValuePair<string, ISet<string>> validLanguage in ValidCodeLanguages)
                     {
-                        if (ValidCodeLanguages[validLanguage].Contains(languageAttribute.Value))
+                        if (validLanguage.Value.Contains(languageAttribute.Value))
                         {
-                            taskInfo.CodeLanguage = validLanguage;
+                            taskInfo.CodeLanguage = validLanguage.Key;
                             foundValidCodeLanguage = true;
                             break;
                         }
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index cbeac2a38cf..b5b34a31b0b 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -91,7 +91,7 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
 
                         if ((retVal != null) && (!requiredReturnType.IsInstanceOfType(retVal)))
                         {
-                            log.LogWarningWithCodeFromResources("General.CouldNotReadStateFile", stateFile,
+                            log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile,
                                 log.FormatResourceString("General.IncompatibleStateFileType"));
                             retVal = null;
                         }
@@ -116,7 +116,7 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
                 // any exception imaginable.  Catch them all here.
                 // Not being able to deserialize the cache is not an error, but we let the user know anyway.
                 // Don't want to hold up processing just because we couldn't read the file.
-                log.LogWarningWithCodeFromResources("General.CouldNotReadStateFile", stateFile, e.Message);
+                log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, e.Message);
             }
 
             return retVal;
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index b4f422959a2..3f5ea428b0c 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -10,6 +10,7 @@
 using System.Linq;
 using System.Runtime.Versioning;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.AssemblyDependency;
@@ -35,7 +36,7 @@ internal sealed class SystemState : StateFileBase, ITranslatable
         /// <summary>
         /// Cache at the SystemState instance level. It is serialized and reused between instances.
         /// </summary>
-        private Dictionary<string, FileState> instanceLocalFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
+        internal Dictionary<string, FileState> instanceLocalFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// LastModified information is purely instance-local. It doesn't make sense to
@@ -112,7 +113,7 @@ internal sealed class SystemState : StateFileBase, ITranslatable
         /// Class that holds the current file state.
         /// </summary>
         [Serializable]
-        private sealed class FileState : ITranslatable
+        internal sealed class FileState : ITranslatable
         {
             /// <summary>
             /// The last modified time for this file.
@@ -309,7 +310,7 @@ internal static SystemState DeserializeCacheByTranslator(string stateFile, TaskL
                 // any exception imaginable.  Catch them all here.
                 // Not being able to deserialize the cache is not an error, but we let the user know anyway.
                 // Don't want to hold up processing just because we couldn't read the file.
-                log.LogWarningWithCodeFromResources("General.CouldNotReadStateFile", stateFile, e.Message);
+                log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, e.Message);
             }
 
             return null;
@@ -337,6 +338,7 @@ public void Translate(ITranslator translator)
         internal bool IsDirty
         {
             get { return isDirty; }
+            set { isDirty = value; }
         }
 
         /// <summary>
@@ -596,6 +598,73 @@ out fileState.frameworkName
             frameworkName = fileState.frameworkName;
         }
 
+        /// <summary>
+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.
+        /// </summary>
+        /// <param name="stateFiles">List of locations of caches on disk.</param>
+        /// <param name="log">How to log</param>
+        /// <param name="fileExists">Whether a file exists</param>
+        /// <returns>A cache representing key aspects of file states.</returns>
+        internal static SystemState DeserializePrecomputedCachesByTranslator(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists)
+        {
+            SystemState retVal = new SystemState();
+            retVal.isDirty = stateFiles.Length > 0;
+            HashSet<string> assembliesFound = new HashSet<string>();
+
+            foreach (ITaskItem stateFile in stateFiles)
+            {
+                // Verify that it's a real stateFile. Log message but do not error if not.
+                SystemState sysState = DeserializeCacheByTranslator(stateFile.ToString(), log);
+                if (sysState == null)
+                {
+                    continue;
+                }
+                foreach (KeyValuePair<string, FileState> kvp in sysState.instanceLocalFileStateCache)
+                {
+                    string relativePath = kvp.Key;
+                    if (!assembliesFound.Contains(relativePath))
+                    {
+                        FileState fileState = kvp.Value;
+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));
+                        if (fileExists(fullPath))
+                        {
+                            // Correct file path
+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;
+                            assembliesFound.Add(relativePath);
+                        }
+                    }
+                }
+            }
+
+            return retVal;
+        }
+
+        /// <summary>
+        /// Modifies this object to be more portable across machines, then writes it to filePath.
+        /// </summary>
+        /// <param name="stateFile">Path to which to write the precomputed cache</param>
+        /// <param name="log">How to log</param>
+        internal void SerializePrecomputedCacheByTranslator(string stateFile, TaskLoggingHelper log)
+        {
+            // Save a copy of instanceLocalFileStateCache so we can restore it later. SerializeCacheByTranslator serializes
+            // instanceLocalFileStateCache by default, so change that to the relativized form, then change it back.
+            Dictionary<string, FileState> oldFileStateCache = instanceLocalFileStateCache;
+            instanceLocalFileStateCache = instanceLocalFileStateCache.ToDictionary(kvp => FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key), kvp => kvp.Value);
+
+            try
+            {
+                if (FileUtilities.FileExistsNoThrow(stateFile))
+                {
+                    log.LogWarningWithCodeFromResources("General.StateFileAlreadyPresent", stateFile);
+                }
+                SerializeCacheByTranslator(stateFile, log);
+            }
+            finally
+            {
+                instanceLocalFileStateCache = oldFileStateCache;
+            }
+        }
+
         /// <summary>
         /// Cached implementation of GetDirectories.
         /// </summary>
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index 4e00a677831..01544039194 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -243,12 +243,12 @@ private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry)
 
             if (_includePatterns.Length > 0)
             {
-                result = _includePatterns.All(pattern => !FileMatcher.IsMatch(FileMatcher.Normalize(zipArchiveEntry.FullName), pattern, true));
+                result = _includePatterns.All(pattern => !FileMatcher.IsMatch(FileMatcher.Normalize(zipArchiveEntry.FullName), pattern));
             }
 
             if (_excludePatterns.Length > 0)
             {
-                result |= _excludePatterns.Any(pattern => FileMatcher.IsMatch(FileMatcher.Normalize(zipArchiveEntry.FullName), pattern, true));
+                result |= _excludePatterns.Any(pattern => FileMatcher.IsMatch(FileMatcher.Normalize(zipArchiveEntry.FullName), pattern));
             }
 
             return result;
diff --git a/src/Tasks/Workflow.VisualBasic.targets b/src/Tasks/Workflow.VisualBasic.targets
index 9e13597f2c3..d9ea4e9e3b8 100644
--- a/src/Tasks/Workflow.VisualBasic.targets
+++ b/src/Tasks/Workflow.VisualBasic.targets
@@ -1,14 +1,15 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
+
+   <!--
         With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  
+        outside of the .NET Framework.  As a result of this, there were several targets files, of which
+        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
-        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
+        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+        consumers of them are not broken, but since the targets files themselves are still part of .NET,
+        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
    -->
 
    <Import Project="$(MSBuildFrameworkToolsPath)\Workflow.VisualBasic.targets" />
 
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/Tasks/Workflow.targets b/src/Tasks/Workflow.targets
index 03a86174d6d..11ca5885ec4 100644
--- a/src/Tasks/Workflow.targets
+++ b/src/Tasks/Workflow.targets
@@ -1,14 +1,15 @@
 ﻿<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-   <!-- 
+
+   <!--
         With MSBuild 12, we've changed MSBuildToolsPath to for the first time point to a directory
-        outside of the .NET Framework.  As a result of this, there were several targets files, of which 
-        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.  
+        outside of the .NET Framework.  As a result of this, there were several targets files, of which
+        this was one, that were being referenced as out of MSBuildToolsPath that are now no longer there.
 
-        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that 
-        consumers of them are not broken, but since the targets files themselves are still part of .NET, 
-        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework. 
+        Thus, we are shimming those targets files so that they do still appear in MSBuildToolsPath, so that
+        consumers of them are not broken, but since the targets files themselves are still part of .NET,
+        the shim will internally simply redirect to the real copy of the targets file in the .NET Framework.
    -->
 
    <Import Project="$(MSBuildFrameworkToolsPath)\Workflow.targets" />
 
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/Tasks/XamlTaskFactory/RelationsParser.cs b/src/Tasks/XamlTaskFactory/RelationsParser.cs
index aaf6072e5a0..4ce861ca530 100644
--- a/src/Tasks/XamlTaskFactory/RelationsParser.cs
+++ b/src/Tasks/XamlTaskFactory/RelationsParser.cs
@@ -416,10 +416,7 @@ private static bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations
             }
 
             // generate the list of parameters in order
-            if (!switchRelationsList.ContainsKey(switchRelationsToAdd.SwitchValue))
-            {
-                switchRelationsList.Remove(switchRelationsToAdd.SwitchValue);
-            }
+            switchRelationsList.Remove(switchRelationsToAdd.SwitchValue);
 
             // build the dependencies and the values for a parameter
             XmlNode child = node.FirstChild;
@@ -463,14 +460,14 @@ private static bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations
                         }
                         else
                         {
-                            if (!switchRelationsToAdd.ExternalRequires.ContainsKey(tool))
+                            if (!switchRelationsToAdd.ExternalRequires.TryGetValue(tool, out List<string> switches))
                             {
-                                var switches = new List<string> { Switch };
+                                switches = new List<string> { Switch };
                                 switchRelationsToAdd.ExternalRequires.Add(tool, switches);
                             }
                             else
                             {
-                                switchRelationsToAdd.ExternalRequires[tool].Add(Switch);
+                                switches.Add(Switch);
                             }
                         }
                     }
diff --git a/src/Tasks/XamlTaskFactory/TaskGenerator.cs b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
index b0aeb1c7198..76547bf0e52 100644
--- a/src/Tasks/XamlTaskFactory/TaskGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
@@ -966,9 +966,8 @@ private bool ContainsCurrentPlatform(string SwitchValue)
             if (Platform == null)
                 return true;
 
-            if (_relationsParser.SwitchRelationsList.ContainsKey(SwitchValue))
+            if (_relationsParser.SwitchRelationsList.TryGetValue(SwitchValue, out SwitchRelations rel))
             {
-                SwitchRelations rel = _relationsParser.SwitchRelationsList[SwitchValue];
                 if (rel.ExcludedPlatforms.Count > 0)
                 {
                     foreach (string excludedPlatform in rel.ExcludedPlatforms)
@@ -996,9 +995,8 @@ private bool ContainsCurrentPlatform(string SwitchValue)
         /// </summary>
         private void GenerateOverrides(Property property, CodeMemberProperty propertyName)
         {
-            if (_relationsParser.SwitchRelationsList.ContainsKey(property.SwitchName))
+            if (_relationsParser.SwitchRelationsList.TryGetValue(property.SwitchName, out SwitchRelations rel))
             {
-                SwitchRelations rel = _relationsParser.SwitchRelationsList[property.SwitchName];
                 if (rel.Overrides.Count > 0)
                 {
                     foreach (string overrided in rel.Overrides)
diff --git a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
index a6483ae584e..b0f61b5746d 100644
--- a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
+++ b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
@@ -102,12 +102,7 @@ private string CommandLine
         /// </summary>
         public bool IsPropertySet(string propertyName)
         {
-            if (!String.IsNullOrEmpty(propertyName))
-            {
-                return ActiveToolSwitches.ContainsKey(propertyName);
-            }
-
-            return false;
+            return !String.IsNullOrEmpty(propertyName) && ActiveToolSwitches.ContainsKey(propertyName);
         }
 
         /// <summary>
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 8c4526c39b6..87d1b12e2dc 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -22,12 +22,11 @@
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
 
     <PackageReference Include="System.Collections.Immutable" />
+    <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETStandard'">
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" />
-
-    <Reference Include="System.Configuration" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index fd31a3cf970..fdb9263ac2e 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -130,6 +130,12 @@ public MuxLogger()
         /// </summary>
         public bool IncludeTaskInputs { get; set; }
 
+        /// <summary>
+        /// Should properties and items be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>?
+        /// </summary>
+        public bool IncludeEvaluationPropertiesAndItems { get; set; }
+
         /// <summary>
         /// Initialize the logger.
         /// </summary>
@@ -159,6 +165,7 @@ public void Initialize(IEventSource eventSource, int maxNodeCount)
                 {
                     eventSource3.IncludeEvaluationMetaprojects();
                 }
+
                 if (IncludeEvaluationProfiles)
                 {
                     eventSource3.IncludeEvaluationProfiles();
@@ -169,6 +176,14 @@ public void Initialize(IEventSource eventSource, int maxNodeCount)
                     eventSource3.IncludeTaskInputs();
                 }
             }
+
+            if (_eventSourceForBuild is IEventSource4 eventSource4)
+            {
+                if (IncludeEvaluationPropertiesAndItems)
+                {
+                    eventSource4.IncludeEvaluationPropertiesAndItems();
+                }
+            }
         }
 
         /// <summary>
@@ -302,10 +317,7 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
                 _submissionProjectsInProgress.Remove(e.BuildEventContext.SubmissionId);
                 lock (_submissionRecords)
                 {
-                    if (_submissionRecords.ContainsKey(e.BuildEventContext.SubmissionId))
-                    {
-                        _submissionRecords.Remove(e.BuildEventContext.SubmissionId);
-                    }
+                    _submissionRecords.Remove(e.BuildEventContext.SubmissionId);
                 }
             }
             else
diff --git a/src/Utilities/Task.cs b/src/Utilities/Task.cs
index 39846721d3c..2ca6e4a10d9 100644
--- a/src/Utilities/Task.cs
+++ b/src/Utilities/Task.cs
@@ -94,6 +94,16 @@ protected Task(ResourceManager taskResources, string helpKeywordPrefix)
         /// </summary>
         public IBuildEngine7 BuildEngine7 => (IBuildEngine7)BuildEngine;
 
+        /// <summary>
+        /// Retrieves the <see cref="IBuildEngine8" /> version of the build engine interface provided by the host.
+        /// </summary>
+        public IBuildEngine8 BuildEngine8 => (IBuildEngine8)BuildEngine;
+
+        /// <summary>
+        /// Retrieves the <see cref="IBuildEngine9" /> version of the build engine interface provided by the host.
+        /// </summary>
+        public IBuildEngine9 BuildEngine9 => (IBuildEngine9)BuildEngine;
+
         /// <summary>
         /// The build engine sets this property if the host IDE has associated a host object with this particular task.
         /// </summary>
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index a2bb6693c41..1aadd08bfde 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -1,9 +1,10 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Linq;
 using System.Security;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
@@ -30,7 +31,8 @@ public sealed class TaskItem :
 #if FEATURE_APPDOMAIN
         MarshalByRefObject,
 #endif
-        ITaskItem2
+        ITaskItem2,
+        IMetadataContainer // expose direct underlying metadata for fast access in binary logger
     {
         #region Member Data
 
@@ -460,5 +462,19 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped() => _metadata == null
             : _metadata.Clone();
 
         #endregion
+
+        IEnumerable<KeyValuePair<string, string>> IMetadataContainer.EnumerateMetadata()
+        {
+            if (_metadata == null)
+            {
+                yield break;
+            }
+
+            foreach (var kvp in _metadata)
+            {
+                var unescaped = new KeyValuePair<string, string>(kvp.Key, EscapingUtilities.UnescapeAll(kvp.Value));
+                yield return unescaped;
+            }
+        }
     }
-}
+}
\ No newline at end of file
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 5ccd30763e2..e7766038d11 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -182,6 +182,14 @@ public virtual string ToolExe
         /// <value>Path to tool.</value>
         public string ToolPath { set; get; }
 
+        /// <summary>
+        /// Whether or not to use UTF8 encoding for the cmd file and console window.
+        /// Values: Always, Never, Detect
+        /// If set to Detect, the current code page will be used unless it cannot represent 
+        /// the Command string. In that case, UTF-8 is used.
+        /// </summary>
+        public string UseUtf8Encoding { get; set; } = EncodingUtilities.UseUtf8Detect;
+
         /// <summary>
         /// Array of equals-separated pairs of environment
         /// variables that should be passed to the spawned executable,
@@ -1372,7 +1380,7 @@ public override bool Execute()
                         }
                         else
                         {
-                            encoding = EncodingUtilities.BatchFileEncoding(commandLineCommands + _temporaryBatchFile, EncodingUtilities.UseUtf8Detect);
+                            encoding = EncodingUtilities.BatchFileEncoding(commandLineCommands + _temporaryBatchFile, UseUtf8Encoding);
 
                             if (encoding.CodePage != EncodingUtilities.CurrentSystemOemEncoding.CodePage)
                             {
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index 86b3892f2a2..1784b4d751a 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -605,10 +605,7 @@ private void ConstructDependencyTable()
                 {
                     // The tracking logs are not available, they may have been deleted at some point.
                     // Be safe and remove any references from the cache.
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                 }
                 return;
             }
@@ -832,11 +829,7 @@ private void ConstructDependencyTable()
                 // sure that we essentially force a rebuild of this particular root.
                 if (encounteredInvalidTLogContents || exceptionCaught)
                 {
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
-
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                     DependencyTable = new Dictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);
                 }
                 else
@@ -874,10 +867,7 @@ public void SaveTlog(DependencyFilter includeInTLog)
                 {
                     // The tracking logs in the cache will be invalidated by this compaction
                     // remove the cached entries
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                 }
 
                 string firstTlog = _tlogFiles[0].ItemSpec;
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index f69120d591e..2dd952fa1ec 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -116,10 +116,7 @@ private void ConstructOutputTable()
                 {
                     // The tracking logs are not available, they may have been deleted at some point.
                     // Be safe and remove any references from the cache.
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                 }
                 return;
             }
@@ -246,11 +243,7 @@ private void ConstructOutputTable()
                 // sure that we essentially force a rebuild of this particular root.
                 if (encounteredInvalidTLogContents)
                 {
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
-
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                     DependencyTable = new Dictionary<string, Dictionary<string, DateTime>>(StringComparer.OrdinalIgnoreCase);
                 }
                 else
@@ -320,9 +313,9 @@ public string[] RemoveRootsWithSharedOutputs(ITaskItem[] sources)
         /// <param name="outputPathToRemove">The output path to be removed</param>
         public bool RemoveOutputForSourceRoot(string sourceRoot, string outputPathToRemove)
         {
-            if (DependencyTable.ContainsKey(sourceRoot))
+            if (DependencyTable.TryGetValue(sourceRoot, out var outputPaths))
             {
-                bool removed = DependencyTable[sourceRoot].Remove(outputPathToRemove);
+                bool removed = outputPaths.Remove(outputPathToRemove);
                 // If we just removed the last entry for this root, remove the root.
                 if (DependencyTable[sourceRoot].Count == 0)
                 {
@@ -584,10 +577,7 @@ public void SaveTlog(DependencyFilter includeInTLog)
                 {
                     // The tracking logs in the cache will be invalidated by this compaction
                     // remove the cached entries to be sure
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                 }
 
                 string firstTlog = _tlogFiles[0].ItemSpec;
diff --git a/src/Utilities/TrackedDependencies/DependencyTableCache.cs b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
index 0767897c772..c87fcaf16fd 100644
--- a/src/Utilities/TrackedDependencies/DependencyTableCache.cs
+++ b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
@@ -60,9 +60,8 @@ private static bool DependencyTableIsUpToDate(DependencyTableCacheEntry dependen
         /// <returns>The cached table entry</returns>
         internal static DependencyTableCacheEntry GetCachedEntry(string tLogRootingMarker)
         {
-            if (DependencyTable.ContainsKey(tLogRootingMarker))
+            if (DependencyTable.TryGetValue(tLogRootingMarker, out DependencyTableCacheEntry cacheEntry))
             {
-                DependencyTableCacheEntry cacheEntry = DependencyTable[tLogRootingMarker];
                 if (DependencyTableIsUpToDate(cacheEntry))
                 {
                     return cacheEntry;
diff --git a/src/Utilities/TrackedDependencies/FlatTrackingData.cs b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
index f69c68b7a08..49d2531a2b4 100644
--- a/src/Utilities/TrackedDependencies/FlatTrackingData.cs
+++ b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
@@ -359,10 +359,7 @@ private void ConstructFileTable()
                 {
                     // The tracking logs are not available, they may have been deleted at some point.
                     // Be safe and remove any references from the cache.
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                 }
                 return;
             }
@@ -480,11 +477,7 @@ private void ConstructFileTable()
                 // sure that we essentially force a rebuild of this particular root. 
                 if (encounteredInvalidTLogContents)
                 {
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
-
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                     DependencyTable = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);
                 }
                 else
@@ -619,10 +612,7 @@ public void SaveTlog(DependencyFilter includeInTLog)
                 {
                     // The tracking logs in the cache will be invalidated by this write
                     // remove the cached entries to be sure
-                    if (DependencyTableCache.DependencyTable.ContainsKey(tLogRootingMarker))
-                    {
-                        DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
-                    }
+                    DependencyTableCache.DependencyTable.Remove(tLogRootingMarker);
                 }
 
                 string firstTlog = TlogFiles[0].ItemSpec;
