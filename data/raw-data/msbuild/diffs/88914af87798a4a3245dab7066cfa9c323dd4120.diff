diff --git a/.github/CODEOWNERS b/.github/CODEOWNERS
new file mode 100644
index 00000000000..e6e7f272b6d
--- /dev/null
+++ b/.github/CODEOWNERS
@@ -0,0 +1,14 @@
+# Users referenced in this file will automatically be requested as reviewers for PRs that modify the given paths.
+# See https://help.github.com/articles/about-code-owners/
+
+/eng/SourceBuild*       @dotnet/source-build-internal
+/eng/                   @dotnet/kitten
+/.github/               @dotnet/kitten
+/global.json            @dotnet/kitten
+/.exp-insertions.yml    @dotnet/kitten
+/.opt-prof.yml          @dotnet/kitten
+/.vsts-dotnet-ci.yml    @dotnet/kitten
+/.vsts-dotnet.yml       @dotnet/kitten
+/NuGet.config           @dotnet/kitten
+/Directory.Build*       @dotnet/kitten
+/.git*                  @dotnet/kitten
\ No newline at end of file
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index d538f655a85..922df9717a7 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -35,6 +35,11 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
+  - task: CmdLine@2
+    displayName: 'Set flag to publish Verify *.received.* files when test step fails'
+    condition: failed()
+    inputs:
+      script: 'echo "##vso[task.setvariable variable=publishverify]Yes"'
   - task: PublishBuildArtifacts@1
     displayName: 'Publish Artifact: logs'
     inputs:
@@ -49,6 +54,22 @@ jobs:
       ArtifactName: 'FullOnWindows test logs'
     continueOnError: true
     condition: always()
+  - task: CopyFiles@2
+    condition: eq(variables['publishverify'], 'Yes')
+    displayName: 'Copy Verify *.received.* files to Artifact Staging'
+    inputs:
+      contents: '**\*.received.*'
+      targetFolder: '$(Build.ArtifactStagingDirectory)\Verify'
+      cleanTargetFolder: true
+      overWrite: true
+  - task: PublishBuildArtifacts@1
+    displayName: 'Publish Verify *.received.* files as Artifacts'
+    name: 'verifypublish'
+    condition: eq(variables['publishverify'], 'Yes')
+    inputs:
+      PathtoPublish: '$(Build.ArtifactStagingDirectory)\Verify'
+      ArtifactName: 'Windows-on-full Verify $(System.JobAttempt)'
+
 
 - job: BootstrapMSBuildOnCoreWindows
   displayName: "Windows Core"
@@ -185,6 +206,11 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
+  - task: CmdLine@2
+    displayName: 'Set flag to publish Verify *.received.* files when test step fails'
+    condition: failed()
+    inputs:
+      script: 'echo "##vso[task.setvariable variable=publishverify]Yes"'
   - task: PublishBuildArtifacts@1
     displayName: 'Publish Artifact: logs'
     inputs:
@@ -199,6 +225,21 @@ jobs:
       ArtifactName: 'CoreOnLinux test logs'
     continueOnError: true
     condition: always()
+  - task: CopyFiles@2
+    condition: eq(variables['publishverify'], 'Yes')
+    displayName: 'Copy Verify *.received.* files to Artifact Staging'
+    inputs:
+      contents: '**/*.received.*'
+      targetFolder: '$(Build.ArtifactStagingDirectory)/Verify'
+      cleanTargetFolder: true
+      overWrite: true
+  - task: PublishBuildArtifacts@1
+    displayName: 'Publish Verify *.received.* files as Artifacts'
+    name: 'verifypublish'
+    condition: eq(variables['publishverify'], 'Yes')
+    inputs:
+      PathtoPublish: '$(Build.ArtifactStagingDirectory)/Verify'
+      ArtifactName: 'Linux Verify $(System.JobAttempt)'
 
 - job: CoreOnMac
   displayName: "macOS Core"
@@ -219,6 +260,11 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: always()
+  - task: CmdLine@2
+    displayName: 'Set flag to publish Verify *.received.* files when test step fails'
+    condition: failed()
+    inputs:
+      script: 'echo "##vso[task.setvariable variable=publishverify]Yes"'
   - task: PublishBuildArtifacts@1
     displayName: 'Publish Artifact: logs'
     inputs:
@@ -233,5 +279,20 @@ jobs:
       ArtifactName: 'CoreOnMac test logs'
     continueOnError: true
     condition: always()
+  - task: CopyFiles@2
+    condition: eq(variables['publishverify'], 'Yes')
+    displayName: 'Copy Verify *.received.* files to Artifact Staging'
+    inputs:
+      contents: '**/*.received.*'
+      targetFolder: '$(Build.ArtifactStagingDirectory)/Verify'
+      cleanTargetFolder: true
+      overWrite: true
+  - task: PublishBuildArtifacts@1
+    displayName: 'Publish Verify *.received.* files as Artifacts'
+    name: 'verifypublish'
+    condition: eq(variables['publishverify'], 'Yes')
+    inputs:
+      PathtoPublish: '$(Build.ArtifactStagingDirectory)/Verify'
+      ArtifactName: 'macOS Verify $(System.JobAttempt)'
 
 - template: /eng/common/templates/jobs/source-build.yml
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index ea163193844..661671069c9 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -94,13 +94,10 @@ stages:
       value: 'int.main'
     - name: VisualStudio.DropName
       value: Products/$(System.TeamProject)/$(Build.Repository.Name)/$(Build.SourceBranchName)/$(Build.BuildNumber)
-    - name: NUGET_PACKAGES
-      value:
 
     steps:
-    - task: NuGetToolInstaller@0
-      inputs:
-        versionSpec: '4.9.2'
+    - task: NuGetToolInstaller@1
+      displayName: 'Install NuGet.exe'
 
     - task: NuGetCommand@2
       displayName: Restore internal tools
diff --git a/documentation/Built-in-Propeties.md b/documentation/Built-in-Properties.md
similarity index 100%
rename from documentation/Built-in-Propeties.md
rename to documentation/Built-in-Properties.md
diff --git a/documentation/NETFramework-NGEN.md b/documentation/NETFramework-NGEN.md
new file mode 100644
index 00000000000..c7ec1412d8d
--- /dev/null
+++ b/documentation/NETFramework-NGEN.md
@@ -0,0 +1,119 @@
+# .NET Framework NGEN Considerations
+
+NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,
+NGEN has the following key characteristics:
+- Native code is always stored in separate images located in a machine-wide cache.
+- Native images are generated on user machines, typically during app installation, by an elevated process.
+- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.
+
+Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.
+
+## NGEN in Visual Studio
+
+Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be
+compiled makes it impractical for native image generation to occur synchronously during installation. Instead,
+VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the
+machine is idle. To force native images to be generated, one can execute the following command in an elevated
+terminal window:
+
+```
+C:\Windows\Microsoft.NET\Framework64\v4.0.30319\ngen eqi
+```
+
+The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`
+in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild
+is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.
+Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\MSBuild\Current\Bin`
+or `[VS install dir]\MSBuild\Current\Bin\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -
+we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.
+The special `[installDir]\Common7\IDE\vsn.exe` entry represents devenv.
+
+The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or
+`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good
+thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected
+by the VS PR gates so they are fixed before MSBuild is inserted into the product.
+
+## NGEN image loading rules
+
+The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of "NGEN rejections" where a native
+image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly
+and JITting code on demand, leading to sub-optimal performance.
+
+One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice
+it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.
+This is bad news for any app with an add-in system where extension assemblies are loaded by path.
+
+## SDK resolvers
+
+One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover
+the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually
+exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is
+loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to
+include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions
+of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.
+It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)
+entry pointing to the right assemblies, because this requires knowing the exact assembly versions. 
+
+### Microsoft.DotNet.MSBuildSdkResolver
+
+This is the most-commonly-used resolver, capable of resolving "in-box" SDKs that ship with the .NET SDK and .NET SDK workloads. Since the resolver assembly
+is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to
+freeze the version of the resolver plus dependencies, so that their full names can be specified in `MSBuild.exe.config`, e.g.
+
+```xml
+    <dependentAssembly>
+      <assemblyIdentity name="Microsoft.DotNet.MSBuildSdkResolver" culture="neutral" publicKeyToken="adb9793829ddae60" />
+      <codeBase version="8.0.100.0" href=".\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Microsoft.DotNet.MSBuildSdkResolver.dll" />
+    </dependentAssembly>
+```
+
+Additionally, `MSBuild.exe.config` has the following entry, which enables us to refer to the resolver by simple name.
+
+```xml
+<qualifyAssembly partialName="Microsoft.DotNet.MSBuildSdkResolver" fullName="Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60" />
+```
+
+This has a small advantage compared to hardcoding `Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60`
+directly in the code, as it can be modified to work in non-standard environments just by editing the app config appropriately.
+
+The resolver loading logic in MSBuild [has been updated](https://github.com/dotnet/msbuild/pull/9439) to call `Assembly.Load(AssemblyName)` where the `AssemblyName` specifies the
+simple name of the assembly, e.g. `Microsoft.DotNet.MSBuildSdkResolver`, as well as its `CodeBase` (file path). This way the CLR assembly
+loader will try to load the assembly into the default context first - a necessary condition for the native image to be used - and fall back
+to LoadFrom if the simple name wasn't resolved.
+
+### Microsoft.Build.NuGetSdkResolver
+
+The NuGet resolver has many dependencies and its version is frequently changing, so the technique used for `Microsoft.DotNet.MSBuildSdkResolver`
+does not apply in its current state. However, the NuGet team is [looking to address this](https://github.com/NuGet/Home/issues/11441) by:
+
+1) ILMerge'ing the resolver with its dependencies into a single assembly.
+2) Freezing the version of the assembly.
+
+When this happens, the cost of JITting `Microsoft.Build.NuGetSdkResolver` will be eliminated as well.
+
+## NuGet.Frameworks
+
+When evaluating certain property functions, MSBuild requires functionality from `NuGet.Frameworks.dll`, which is not part of MSBuild proper.
+The assembly is loaded lazily from a path calculated based on the environment where MSBuild is running and the functionality is invoked
+via reflection. Similar to the NuGet resolver, the version is changing and it is not easy to know it statically at MSBuild's build time.
+But, since there are only a handful of APIs used by MSBuild and they take simple types such as strings and versions, this has been
+addressed by loading the assembly into a separate AppDomain. The AppDomain's config file is created in memory on the fly to contain the
+right binding redirects, allowing MSBuild to use `Assembly.Load` and get the native image loaded if it exists.
+
+This approach has some small startup cost (building the config, creating AppDomain & a `MarshalByRefObject`) and a small run-time overhead
+of cross-domain calls. The former is orders of magnitude smaller that the startup hit of JITting and the latter is negligible as long as
+the types moved across the AppDomain boundary do not require expensive marshaling.
+
+## Task assemblies
+
+This is the proverbial elephant in the room. MSBuild learns about tasks dynamically as it parses project files. The `UsingTask`
+element tends to specify the `AssemblyFile` attribute, pointing to the task assembly by path. Consequently MSBuild uses
+`Assembly.LoadFrom` and no native images are loaded. Even task assemblies located in the SDK are problematic because MSBuild is
+paired with an SDK on users machine at run-time. Unlike SDK resolvers and NuGet.Frameworks, which are part of the same installation
+unit, this is a true dynamic inter-product dependency. Additionally, the task API is complex and involves a lot of functionality
+provided to tasks via callbacks (e.g. logging) so the overhead of cross-domain calls may be significant. And that's assuming that
+suitable native images exist in the first place, something that both VS and SDK installers would need to handle (task assemblies
+in each installed SDK would need to be NGENed against each installed version of VS).
+
+Hosting task assemblies in separate AppDomains looks like a major piece of work with uncertain outcome. We haven't tried it yet
+and most task code is JITted.
diff --git a/documentation/specs/project-cache.md b/documentation/specs/project-cache.md
index 7c3a2fad63a..b0ce961313d 100644
--- a/documentation/specs/project-cache.md
+++ b/documentation/specs/project-cache.md
@@ -1,10 +1,10 @@
 # Summary
 
-Project cache is a new assembly-based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and/or distribution](https://github.com/dotnet/msbuild/blob/main/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).
+Project cache is a new assembly-based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and/or distribution](static-graph.md#weakness-of-the-old-model-caching-and-distributability).
 
 # Motivation
 
-As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/main/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, large and complex repos expose the weaknesses in MSBuild's scheduling and incrementality models as build times elongate. This project cache plugin lets MSBuild natively communicate with existing tools that enable build caching and/or distribution, enabling true scalability.
+As the introduction to [static graph](static-graph.md#what-is-static-graph-for) suggests, large and complex repos expose the weaknesses in MSBuild's scheduling and incrementality models as build times elongate. This project cache plugin lets MSBuild natively communicate with existing tools that enable build caching and/or distribution, enabling true scalability.
 
 Visual Studio is one beneficiary. This plugin inverts dependencies among build systems: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild calls into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.
 
@@ -14,106 +14,185 @@ This change also simplifies and unifies user experiences. MSBuild works the same
 
 - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:
   - it makes the filesystem look as if the project built
-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [BuildResult](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.
+  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.
 
 # High-level design
-- For each [BuildRequestData](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([ProjectInstance](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [BuildManager](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.
-  - If the BuildRequestData is based on a project path instead of a ProjectInstance, the project is evaluated by the BuildManager.
-- If the plugin decides to build, then MSBuild proceeds building the project as usual.
-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets.
-  - MSBuild injects the BuildResult into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.
+
+Conceptually, there are two parts of caching: "cache get" and "cache add". "Cache get" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. "Cache add" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin to add the results to its cache and safely be able to retrieve it for some future build.
+
+The "cache get" functionality was introduced in 16.9, while "cache add" was added in 17.8.
+
+## Plugin discovery
+
 - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).
   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.
   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.
-- Plugin instances reside only in the BuildManager node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the ProjectInstance between nodes, which is expensive.
-- The plugin instance will get called in reverse topo sort order (from dependencies up towards dependents). Building in reverse topo sort order is common between Visual Studio solution builds and higher build engines.
-- Plugins can function with and without a static graph. When a static graph is not provided, hints about the graph entry points are provided (details in Defining the "graph" when static graph is not available).
-- A single plugin is supported (for now).
-
-# APIs and calling patterns
-- Plugin APIs are found [here](https://github.com/cdmihai/msbuild/tree/projectCache/src/Build/BackEnd/Components/ProjectCache).
-
-## From BuildManager API users who have a project dependency graph at hand and want to manually issue builds for each graph node in reverse topo sort order.
-- Users set [BuildParameters.ProjectCacheDescriptor](https://github.com/cdmihai/msbuild/blob/projectCache/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptor.cs) which triggers MSBuild to instantiate the plugin and call `ProjectCacheBase.BeginBuildAsync` on it in `BuildManager.BeginBuild`.
-  - `BuildManager.BeginBuild` does not wait for the plugin to initialize. The first query on the plugin will wait for plugin initialization.
-- All the build requests submitted in the current `BuildManager.BeginBuild/EndBuild` session will get checked against the plugin instance.
-- Only the user provided top level build requests are checked against the cache. The build requests issued recursively from the top level requests are not checked against the cache, since it is assumed that users issue build requests in reverse toposort order. Therefore when a project builds its references, those references should have already been built and present in MSBuild's internal cache, provided either by the project cache plugin or real builds.
-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync`.
-- There is no static graph instantiated by MSBuild in this case and the user needs to set `ProjectCacheDescriptor.EntryPoints`.
-
-## From command line
-- Requires /graph. It is the easiest way to implement the plugin:
-  - The static graph has all the project instances in the same process, makes it easy to find and keep plugin instances in one process.
-  - Builds bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.
-- User calls msbuild /graph.
-- MSBuild constructs the static graph.
-- The graph builder finds and loads the plugin into the `BuildManager`.
-  - Each graph node has a ProjectInstance, which is used to search for the plugin.
-  - If a project defines a plugin, then all projects in the graph must define that same plugin.
-  - The `ProjectGraph` is passed to the plugin upon initialization, so the plugin can avoid building its own static graph (in case it needs a graph).
-- From this point on the calling patterns are similar to the `BuildParameters.ProjectCacheDescriptor` flow described [above](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order). The only difference is that the plugin is not instantiated in `BuildManager.BeginBuild`, but between graph construction and graph build.
-  - However, if `BuildParameters.ProjectCacheDescriptor` was set and a plugin was instantiated, it will take precedence. In this case graph build will not even search the graph nodes for plugins.
-
-## From Visual Studio, a temporary workaround
-- Ideally, Visual Studio would use the [above APIs](#from-buildmanager-api-users-who-have-a-project-dependency-graph-at-hand-and-want-to-manually-issue-builds-for-each-graph-node-in-reverse-topo-sort-order) to set project cache plugins. Since VS evaluates all projects in a solution, it could search for `ProjectCachePlugin` items and provide them back to MSBuild during real builds via `BuildParameters.ProjectCacheDescriptor`. Until that happens, a workaround will be used:
-  - The workaround logic activates only when MSBuild detects that it's running under VS.
-  - Plugin discovery
-    - When VS evaluates projects via "new Project(..)" (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.
-  - Plugin usage:
-    - The first build request will check the static state for the presence of plugins. If there's a plugin, it will instantiate it via plugin.BeginBuild.
-
-# Details
-- Plugin discovery
-  - Each project defines an item containing the path to the plugin DLL:
 ```xml
-<ProjectCachePlugin Include="..\..\QuickbuildProjectCachePlugin.dll">
+<ItemGroup>
+  <ProjectCachePlugin Include="$(SomePath)\MyAmazingCachePlugin.dll" />
+</ItemGroup>
 ```
-- Plugin acquisition
-  - Via the dependency manager of choice. PackageReference / Nuget for managed projects, pacman / vcpkg / nuget on packages.config for C++. The package contents injects the plugin item into the project import graph.
-- Defining the "graph" when static graph is not available
-  - Plugins need to know the top level entry point for various reasons, but without a static graph the entry points need to be explicitly declared or inferred.
-  - Entry points are set via `ProjectCacheDescriptor.EntryPoints`.
-    - The Visual Studio workaround will use the `SolutionPath` global property as the graph entry point.
-- Returning a valid BuildResult object on cache hits.
-  - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).
+- Programmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.
+
+## Plugin lifetime
+
+- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.
+- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a "fire-and-forget" call at this point. The first query on the plugin will wait for plugin initialization.
+  - `BeginBuildAsync` may be called with or without a `ProjectGraph`, depending on MSBuild has one to provide. When it is not provided, hints about the graph entry points are provided with which the plugin may decide to construct the `ProjectGraph` itself, if desired.
+- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before the build can complete.
+- The plugin instance will get called in reverse topological sort order (from referenced projects up towards referencing projects). This happens when performing a graph build (`/graph`), Visual Studio solution builds, and commonly in higher build engines.
+- Only the top-level build requests are checked against the cache. Build requests issued recursively from the top-level requests, for example a project building its dependencies, are not checked against the cache. However, because the build requests are assumed to be issued in reverse topological sort order, those requests should have already been built and present in MSBuild's internal result cache, provided either by the project cache plugin or real builds. A consequence of this is that projects which are not well-described in the graph (e.g. using `<MSBuild>` tasks directly) will not benefit from the cache.
+
+## Cache get scenario
+
+- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.
+  
+  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.
+- If the plugin decides to build, then MSBuild proceeds building the project as usual.
+- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets ("proxy targets").
+  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.
   - Plugins have three options:
-    - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.
-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.
+    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.
+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.
       - Proxy target assumptions:
         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).
         - They do not mutate state (file system, environment variables, etc).
         - They do not MSBuild task call into other projects.
-      - The BuildManager schedules the proxy targets to build on the in proc node to avoid ProjectInstance serialization costs.
-    - Best: when the plugin's infrastructure (e.g. cloudbuild or anybuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the BuildResult and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever the build did, that's what's returned.
-      - This is not yet possible. Outputting results cache files needs to first be decoupled from `/isolate`.
-      - Potential Issue: serialization format may change between runtime msbuild and the cache results file, especially if binary serialization is used.
-- Configuring plugins
-  - Plugin configuration options can be provided as metadata on the `ProjectCachePlugin` item.
+      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.
+    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.
+      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.
+
+## Cache add scenario
+
+- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.
+- MSBuild uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. To facilitate the plugin being able to handle future builds, it forwards this information as well as the build result to the plugin for it to use as desired, for example to add to a cache.
+  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programmatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.
+  - The in-proc node is disabled since MSBuild is unable to use Detours on the currently running process. It also would not want to capture the file accesses of the plugins themselves.
+  - Detours adds some overhead to file accesses. Based on initial experimentation, it's around 10-15%. There's the overhead of the plugin adding to the cache. Caching becomes valuable if it can save more than the overhead on average.
+- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`), only for the x64 flavor (not x86 or arm64), and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.
+- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.
+
+# APIs and calling patterns
+
+## Plugin API
+[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass.
+
+See the [Plugin implementation guidance and simple example design](#plugin-implementation-guidance-and-simple-example-design) section for guidance for plugin implementations.
+
+## Configuring plugins
+
+Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:
+
 ```xml
-<ProjectCachePlugin Update="@(ProjectCachePlugin)" setting1="val1" setting2="val2" />
+<ItemGroup>
+  <ProjectCachePlugin Include="$(SomePath)\MyAmazingCachePlugin.dll">
+    <PluginSetting1>$(PluginSetting1)</PluginSetting1>
+    <PluginSetting2>$(PluginSetting2)</PluginSetting2>
+    <PluginSetting3>$(PluginSetting3)</PluginSetting3>
+  </ProjectCachePlugin>
+</ItemGroup>
 ```
-- Configuring MSBuild to query the caches but not do any builds (bin-place from the cache without building anything):
-  - From command line: `msbuild /graph:NoBuild`
-  - From APIs: `GraphBuildRequestData.GraphBuildRequestDataFlags.{NoBuild}`
-- Logging
-  - Log messages from `Plugin.{BeginBuild, EndBuild}` do not have a parent build event context and get displayed at the top level in the binlog.
-  - Log messages from querying a project get parented under that project's logging context.
-    - This is not yet implemented. For now, all plugin log messages do not have a parent event context.
+
+This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.
+
+Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.
+
+## Enabling from command line
+
+- Requires `/graph` to light up cache get scenarios.
+- Requires `/reportfileaccesses` to light up cache add scenarios.
+- The static graph has all the project instances in the same process, making it easy to find and keep plugin instances in one process.
+- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.
+
+## Enabling from Visual Studio, a temporary workaround
+
+- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.
+- The workaround logic activates only when MSBuild detects that it's running under VS.
+- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.
+- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.
+- Plugins will be given the graph entry points instead of the entire graph in this scenario.
+- There is currently no way to enable cache add scenarios in Visual Studio.
+
+# Detours (cache add scenario)
+
+In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will emit events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.
+
+Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.
+
+## Pipe synchronization
+
+Because the Detours implementation being used communicates over a pipe, and nodes communicate over a pipe as well, and pipes are async, there is some coordination required to ensure that file accesses are associated with the proper build request. For example, if a "project finished" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.
+
+To address this problem, when a worker node finishes a project it will emit a dummy file access with a specific format known to MSBuild. When the scheduler node receives as "project finished" event over the node communication pipe, it will wait to determine that the project is actually finished until it also receives the dummy file access. This ensures that the all file accesses associated with the project have fully flushed from the pipe before the scheduler determines the project is finished and schedules new work to the worker node (which would trigger new file accesses).
+
+# Plugin implementation guidance and simple example design
+
+The following will describe a very basic (and not very correct) plugin implementation.
+
+In practice, plugins will have to choose the specific level of correctness they're willing to trade off for the ability to get cache hits. Any machine state *could* impact build results, and the plugin implementation will need to determine what state matters and what doesn't. An obvious example to consider would be the content of the project file. An example which has trade-offs would be the processes' environment variables. Even the current time could possibly impact the build ("if Tuesday copy this file"), but if considered caching would be quite infeasible.
+
+## Fingerprinting
+
+A "fingerprint" describes each unique input which went into the building a build request. The more granular the fingerprint, the more "correct" the caching is, as described above.
+
+In this example, we will only consider the following as inputs, and thus part of the fingerprint:
+- The global properties of the build request (eg `Configuration=Debug`, `Platform=AnyCPU`)
+- The content hash of the project file
+- The content hash of files defined in specific items we know contribute to the build, like `<Compile>` and `<Content>`
+- The fingerprint of referenced projects
+
+Again, this is for illustrative purposes and a real implementation will want to use additional state for fingerprinting depending on the environment in which it runs and the correctness requirements.
+
+It can make sense for a fingerprint to be a hash of its inputs, so effectively is a byte array which can be represented by a string.
+
+At the beginning of the build, the plugin's `BeginBuildAsync` method will be called. As part of the `CacheContext`, the plugin is either given the graph or the entry points to the graph for which it can create a graph from. The plugin can use this graph to do some initial processing, like predicting various inputs which a project is likely to use. This information can then be stored to help construct a fingerprint for a build request later.
+
+## Cache storage
+
+Any storage mechanism can be used as a cache implementation, for example [Azure Blob Storage](https://azure.microsoft.com/products/storage/blobs/), or even just the local filesystem. At least in this example the only real requirement is that it can be used effectively as a key-value store. In many cases it can be useful for content to be keyed by its hash, and for the metadata file to be keyed by the fingerprint. In particular when content is keyed by hash, it is effectively deduplicated across multiple copies of the same file, which is common in builds.
+
+For illustration purposes, consider our cache implementation is based on a simple filesystem with a separate metadata and content directory inside it. Under the metadata dir, each file is a metadata file where the filename matches the fingerprint it's describing. Under the content dir, each file is a content file where the filename matches the hash of the content itself.
+
+## First build (cache population)
+
+In the very first build there will be no cache hits so the "cache add" scenario will be most relevant here.
+
+For a given project, `GetCacheResultAsync` will be invoked, but will end up returning a cache miss since the cache is empty.
+
+MSBuild will then build the project normally but under a detoured worker node. Because of this, the plugin will recieve `HandleFileAccess` and `HandleProcess` events. In this example implementation we will ignore `HandleProcess`. For `HandleFileAccess`, the plugin will simply store all `FileAccessData`s for a `FileAccessContext` to build up a list of all file accesses during the build. The plugin may decide to avoid storing the entire `FileAccessData` and instead just peel off the data it finds relevant (eg. paths, whether it was a read or write, etc).
+
+Once MSBuild is done building the project, it will call the plugin's `HandleProjectFinishedAsync`. Now the plugin knows the project is done and can process the results and add them to a cache. In general it's only useful to cache successful results, so the plugin should filter out non-success results. The `FileAccessContext` provided can then be used to retrieve the list of `FileAccessData` the plugin recieved. These `FileAccessData` can be processed to understand which files were read and written as part of the build.
+
+In our example, we can use the read files to construct a fingerprint for the build request. We can then add the files written during the build ("outputs") to some cache implementation.
+
+The plugin would then create some metadata describing the outputs (eg. the paths and hashes) and the serialized `BuildResult`, and associate it with the fingerprint and put that assocation in the cache.
+
+To illustrate this, consider a project with fingerprint `F` which wrote a single file `O` with hash `H` and had `BuildResult R`. The plugin could create a metadata file `M` which describes the outputs of the build (the path and hash of `O`) as well as the serialized `R`. Using the cache implementation described above, the plugin would write the following two files to the cache:
+ - `metadata/F -> M:"{outputs: [{path: 'path/to/O', hash: H}], result: R}"`
+ - `content/H -> O`
+
+This can then be used for future builds.
+
+ ## Second Build (cache hits)
+ 
+ In the second build we have a populated cache and so it could be possible to get cache hits.
+
+ For a given project, `GetCacheResultAsync` will be invoked. The plugin can fingerprint the request and use that fingerprint to look up in its cache. If the cache entry exists, it can declare a cache hit.
+
+In the example above, if all inputs are the same as in the first build, we should end up with a fingerprint `F`. We look up in the metadata part of the cache (file `metadata/F`) and find that it exists. This means we have a cache hit. We can fetch that metadata `M` from the cache and find that it describes the output with path `O` and hash `H`. The plugin would then copy `content/H` to `O` and return the deserialized `BuildResult R` contained in `M` to MSBuild.
+
+If the inputs were not the same as in the first build, for example if a `Compile` item (a .cs file) changed, the fingerprint would be something else besides `F` and so would not have corresponding cache entries for it, indicating a cache miss. This will then go through the "cache add" scenario described above to populate the cache with the new fingerprint.
 
 # Caveats
+- Without the "cache add" scenario enabled, the content which powers "cache get" must be populated by some external entity, for example some higher-order build engine.
 - Absolute paths circulating through the saved build results
   - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.
+  - Plugins can attempt to normalize well-known paths, like the repo root, but this can be brittle and there may be unknown path types.
 - Slow connections. In a coffee shop it might be faster to build everything instead of downloading from the cache. Consider racing plugin checks and building: if the bottom up build traversal reaches a node that's still querying the cache, cancel the cache query and build the node instead.
 - Inferring what targets to run on each node when using /graph
-  - Msbuild /graph requires that the [target inference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/specs/static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.
+  - Msbuild /graph requires that the [target inference protocol](static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.
 - Small repos will probably be slower with plugin implementations that access the network. Remote distribution and caching will only be worth it for repos that are large enough.
 
-# Future work
-- On cache misses plugins can build the project with IO monitoring and write to the local cache. As far as we can tell there are two main possibilities:
-  - plugins build the projects themselves in isolation (without projects building their reference, probably by setting `BuildProjectReferences` to false) by calling msbuild.exe.
-  - plugins request msbuild to build the projects on special out of proc nodes whose IO system calls can be monitored.
-
-# Potential work of dubious value
-- Allow multiple plugin instances and query them based on some priority, similar to sdk resolvers.
+# Potential future work of dubious value
 - Enable plugins to work with the just-in-time top down msbuild traversal that msbuild natively does when it's not using `/graph`.
 - Extend the project cache API to allow skipping individual targets or tasks instead of entire projects. This would allow for smaller specialized plugins, like plugins that only know to distribute, cache, and skip CSC.exe calls.
diff --git a/documentation/wiki/Binary-Log.md b/documentation/wiki/Binary-Log.md
index 9edcddc6fd4..d9bb101159f 100644
--- a/documentation/wiki/Binary-Log.md
+++ b/documentation/wiki/Binary-Log.md
@@ -84,7 +84,7 @@ It is a `GZipStream`-compressed binary stream of serialized `BuildEventArgs` obj
 
 ## Incrementing the file format
 
-Every .binlog file has the first three bytes that indicate the file version. The current file format version is 9 (`00 00 09`).
+Every .binlog file has the first four bytes that indicate the file version. The current file format is indicated in [`BinaryLogger.cs`](/src/Build/Logging/BinaryLogger/BinaryLogger.cs).
 
 When incrementing the file format, keep this in mind:
  * Increment the version and add a summary of the changes: https://github.com/dotnet/msbuild/blob/main/src/Build/Logging/BinaryLogger/BinaryLogger.cs#L22
@@ -94,4 +94,98 @@ When incrementing the file format, keep this in mind:
 
 The format is backwards compatible, i.e. MSBuild will be able to play back .binlog files created with an older version of MSBuild. The Viewer will also be able to open files of any older version. Since the viewer updates automatically and I can push out updates easily, we can consider the Viewer is always able to read all .binlogs.
 
-However MSBuild of version 15.3 won't be able to read .binlogs created with MSBuild version 15.6. This means the format is unfortunately not forwards-compatible. It is not self-describing, i.e. it doesn't carry its schema around for performance and compactness reasons. This is not a problem with a Viewer because Viewer is always up-to-date (there isn't an "old version" of the Viewer unless people go to great lengths to prevent it from auto-updating).
+## Forward compatibility reading
+
+From version 18, the binlog contains as well the minimum version of reader that can interpret it (stored in bytes 4 to 8). Support for best effort forward compatibility is added by this version. It is best effort only because the binlog format is not self-describing, i.e. it doesn't carry its schema around for performance and compactness reasons.
+
+This is not of a high importance for users of the Viewer because Viewer is always up-to-date (there isn't an "old version" of the Viewer unless people go to great lengths to prevent it from auto-updating).
+
+## Reading API
+
+We recommend usage of `BinaryLogReplayEventSource`. It provides simplified helpers for creating and configuring `BuildEventArgsReader` and subscribing to the events.
+
+```csharp
+var logReader = new BinaryLogReplayEventSource()
+{
+    AllowForwardCompatibility = true
+};
+
+// Handling of the structured events contained within the log
+logReader.AnyEventRaised += (_, e) =>
+{
+    if (e is BuildErrorEventArgs error)
+    {
+        //...
+    }
+
+    // ...
+};
+
+// Starts the synchronous log reading loop.
+logReader.Replay(path_to_binlog_file);
+
+```
+
+### Handling the recoverable reading errors
+
+In compatibility mode (default for `BinaryLogReplayEventSource`. Only supported for binlogs of version 18 and higher) reader is capable of skipping unknown event types and unknown parts of known events (`BuildEventArgsReader` can configure the behavior via 2 separate properties - `SkipUnknownEvents` and `SkipUnknownEventParts`).
+
+The unknown events and event parts are regarded as recoverable errors, since the reader is able to continue reading subsequent records in the binlog. However the specific user logic should have the last call in deciding whether errors are really recoverable (e.g. is presence of unrecognized or unparseable event ok? It might be fine when searching only for specific events - e.g. errors but not acceptable when trying to provide definitive overview of the built).
+
+To allow the calling code to decide - based on the type of error, type of events getting the error, or the number of errors - the `RecoverableReadError` event is exposed (from both `BinaryLogReplayEventSource` and `BuildEventArgsReader`).
+
+```csharp
+/// <summary>
+/// An event args for <see cref="IBinaryLogReaderErrors.RecoverableReadError"/> event.
+/// </summary>
+public sealed class BinaryLogReaderErrorEventArgs : EventArgs
+{
+    /// <summary>
+    /// Type of the error that occurred during reading.
+    /// </summary>
+    public ReaderErrorType ErrorType { get; }
+
+    /// <summary>
+    /// Kind of the record that encountered the error.
+    /// </summary>
+    public BinaryLogRecordKind RecordKind { get; }
+
+    /// <summary>
+    /// Materializes the error message.
+    /// Until it's called the error message is not materialized and no string allocations are made.
+    /// </summary>
+    /// <returns>The error message.</returns>
+    public string GetFormattedMessage() => _formatErrorMessage();
+}
+
+/// <summary>
+/// Receives recoverable errors during reading.
+/// Communicates type of the error, kind of the record that encountered the error and the message detailing the error.
+/// In case of <see cref="ReaderErrorType.UnknownEventData"/> this is raised before returning the structured representation of a build event
+/// that has some extra unknown data in the binlog. In case of other error types this event is raised and the offending build event is skipped and not returned.
+/// </summary>
+event Action<BinaryLogReaderErrorEventArgs>? RecoverableReadError;
+```
+
+Our sample usage of the [Reading API](#reading-api) can be enhanced with recoverable errors handling e.g. as such:
+
+```csharp
+
+// Those can be raised only during forward compatibility reading mode.
+logReader.RecoverableReadError += errorEventArgs =>
+{
+    // ...
+
+    // e.g. we can decide to ignore the error and continue reading or break reading
+    //  based on the type of the error or/and type of the record or/and the frequency of the error
+
+    // Would we decide to completely ignore some errors - we can aid better performance by not materializing the actual error message.
+    // Otherwise the error message can be materialized via the provided method on the event argument:
+    Console.WriteLine($"Recoverable reader error: {errorEventArgs.GetFormattedMessage()}");
+};
+
+```
+
+When authoring changes to the specific BuildEventArg types - it is always strongly recommended to **prefer append-only changes**. 
+
+This prevents the possibility of collision where some fields are removed in one version and then different fields with same binary size are added in future version. Such a sequence of format changes might not be caught by the decoder and might lead to unnoticed corrupt interpretation of data. For this reason the author of specific OM changes should always check whether there is a possibility of unrecognizable format collision (same binary size, different representation) within binlog versions of a same [minimum reader version support](#forward-compatibility-reading). If this is possible, the [minimum reader version support](#forward-compatibility-reading) should be incremented.
\ No newline at end of file
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index b8db25764a7..fbbc8868cc1 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -29,8 +29,13 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Cache SDK resolver data process-wide](https://github.com/dotnet/msbuild/pull/9335)
 - [Target parameters will be unquoted](https://github.com/dotnet/msbuild/pull/9452), meaning  the ';' symbol in the parameter target name will always be treated as separator
 - [Add Link metadata to Resources in AssignLinkMetadata target](https://github.com/dotnet/msbuild/pull/9464)
+- [Change Version switch output to finish with a newline](https://github.com/dotnet/msbuild/pull/9485)
+- [Load Microsoft.DotNet.MSBuildSdkResolver into default load context (MSBuild.exe only)](https://github.com/dotnet/msbuild/pull/9439)
+- [Load NuGet.Frameworks into secondary AppDomain (MSBuild.exe only)](https://github.com/dotnet/msbuild/pull/9446)
+- [ResultsCache ignores some of the BuildRequest data, may return incorrect results](https://github.com/dotnet/msbuild/pull/9565)
 - [Update Traits when environment has been changed](https://github.com/dotnet/msbuild/pull/9655)
 
+
 ### 17.8
 - [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
 - [Delete destination file before copy](https://github.com/dotnet/msbuild/pull/8685)
diff --git a/eng/Packages.props b/eng/Packages.props
index ac8df77f629..b84d22149d7 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -28,6 +28,7 @@
     <PackageVersion Include="System.Security.Principal.Windows" Version="$(SystemSecurityPrincipalWindowsVersion)" />
     <PackageVersion Include="System.Text.Encoding.CodePages" Version="$(SystemTextEncodingCodePagesVersion)" />
     <PackageVersion Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
+    <PackageVersion Include="System.Threading.Channels" Version="$(SystemThreadingChannelsVersion)" />
     <PackageVersion Include="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
     <PackageVersion Include="xunit.console" Version="$(XUnitVersion)" />
   </ItemGroup>
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index 169f6532fb8..b341b5e5b5a 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -5,11 +5,15 @@
   <IgnorePatterns>
     <!-- Baseline 7.0 dependencies until msbuild targets net8 and uses a net8 arcade, SBRP, etc.
          These cannot be added to 7.0 SBRP, because they would are produced in the 7.0 build. -->
-    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*7.0.0*" />
-    <UsagePattern IdentityGlob="System.Text.Json/*7.0.3*" />
+    <UsagePattern IdentityGlob="System.Collections.Immutable/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.Metadata/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Resources.Extensions/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Json/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*8.0.0*" />
   </IgnorePatterns>
   <Usages>
   </Usages>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index eb1785053a5..f77cac23edc 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,85 +1,93 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ProductDependencies>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.23565.1">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.24061.1">
       <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>95f83e27806330fec09edd96e06bba3acabe3f35</Sha>
+      <Sha>453a37ef7ae6c335cd49b3b9ab7713c87faeb265</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.CodeDom" Version="7.0.0">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.CodeDom" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
     <!-- Necessary for source-build due to being a transitive dependency of System.Reflection.MetadataLoadContext.
       This allows the package to be retrieved from previously-source-built artifacts and flow in as dependencies
       of the packages produced by msbuild. -->
-    <Dependency Name="System.Collections.Immutable" Version="7.0.0">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.Collections.Immutable" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
       and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Configuration.ConfigurationManager" Version="7.0.0">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.Configuration.ConfigurationManager" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
       and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Reflection.Metadata" Version="7.0.0">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.Reflection.Metadata" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
       and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Reflection.MetadataLoadContext" Version="7.0.0">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.Reflection.MetadataLoadContext" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.Resources.Extensions" Version="7.0.0">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.Resources.Extensions" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
       and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Security.Cryptography.Pkcs" Version="7.0.2">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.Security.Cryptography.Pkcs" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.Security.Cryptography.Xml" Version="7.0.1">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    <Dependency Name="System.Security.Cryptography.Xml" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
-    <Dependency Name="System.Text.Json" Version="7.0.3">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha>5b20af47d99620150c53eaf5db8636fdf730b126</Sha>
+    <Dependency Name="System.Text.Json" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    </Dependency>
+    <Dependency Name="System.Threading.Tasks.Dataflow" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    </Dependency>
+    <Dependency Name="System.Threading.Channels" Version="8.0.0">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.23463.1">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24060.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>1d451c32dda2314c721adbf8829e1c0cd4e681ff</Sha>
+      <Sha>888985fb9a9ae4cb30bca75f98af9126c839e660</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23426.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23475.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
       <Uri>https://github.com/dotnet/xliff-tasks</Uri>
-      <Sha>194f32828726c3f1f63f79f3dc09b9e99c157b11</Sha>
+      <Sha>73f0850939d96131c28cf6ea6ee5aacb4da0083a</Sha>
       <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.9.0-preview.1.45">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.9.0-preview.1.70">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>707c46e558b2b027d7ae942028c369e26545f10a</Sha>
+      <Sha>6a82332d4936d893fb1e22fd86f2e3cb4d54c471</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.9.0-3.23602.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.9.0-3.23629.3">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>e7eb348845964a221e1636e404a295f95f35e1aa</Sha>
+      <Sha>ebb588725e707db23d8723b633258e7eb918277b</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.23463.1">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24060.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>1d451c32dda2314c721adbf8829e1c0cd4e681ff</Sha>
+      <Sha>888985fb9a9ae4cb30bca75f98af9126c839e660</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index bb23f848821..272bb34097c 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -26,8 +26,8 @@
   </PropertyGroup>
   <!-- Production Dependencies -->
   <PropertyGroup>
-    <SystemCollectionsImmutableVersion>7.0.0</SystemCollectionsImmutableVersion>
-    <SystemConfigurationConfigurationManagerVersion>7.0.0</SystemConfigurationConfigurationManagerVersion>
+    <SystemCollectionsImmutableVersion>8.0.0</SystemCollectionsImmutableVersion>
+    <SystemConfigurationConfigurationManagerVersion>8.0.0</SystemConfigurationConfigurationManagerVersion>
     <!--
         Modifying the version of System.Memory is very high impact and causes downstream breaks in third-party tooling that uses the MSBuild API.
         When updating the version of System.Memory file a breaking change here: https://github.com/dotnet/docs/issues/new?assignees=gewarren&labels=breaking-change%2CPri1%2Cdoc-idea&template=breaking-change.yml&title=%5BBreaking+change%5D%3A+
@@ -35,11 +35,13 @@
     -->
     <SystemMemoryVersion>4.5.5</SystemMemoryVersion>
     <SystemNetHttpVersion>4.3.4</SystemNetHttpVersion>
-    <SystemReflectionMetadataLoadContextVersion>7.0.0</SystemReflectionMetadataLoadContextVersion>
-    <SystemReflectionMetadataVersion>7.0.0</SystemReflectionMetadataVersion>
-    <SystemResourcesExtensionsPackageVersion>7.0.0</SystemResourcesExtensionsPackageVersion>
+    <SystemReflectionMetadataLoadContextVersion>8.0.0</SystemReflectionMetadataLoadContextVersion>
+    <SystemReflectionMetadataVersion>8.0.0</SystemReflectionMetadataVersion>
+    <SystemResourcesExtensionsPackageVersion>8.0.0</SystemResourcesExtensionsPackageVersion>
     <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
     <SystemTextEncodingCodePagesVersion>7.0.0</SystemTextEncodingCodePagesVersion>
+    <SystemThreadingChannelsVersion>8.0.0</SystemThreadingChannelsVersion>
+    <SystemThreadingTasksDataflowVersion>8.0.0</SystemThreadingTasksDataflowVersion>
   </PropertyGroup>
   <!-- Toolset Dependencies -->
   <PropertyGroup>
@@ -47,14 +49,13 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.23463.1</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24060.4</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.9.0-3.23602.1</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.9.0-preview.1.45</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.9.0-3.23629.3</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.9.0-preview.1.70</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
-    <SystemTextJsonVersion>7.0.3</SystemTextJsonVersion>
-    <SystemThreadingTasksDataflowVersion>7.0.0</SystemThreadingTasksDataflowVersion>
+    <SystemTextJsonVersion>8.0.0</SystemTextJsonVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/common/darc-init.ps1 b/eng/common/darc-init.ps1
index 435e7641341..8fda30bdce2 100644
--- a/eng/common/darc-init.ps1
+++ b/eng/common/darc-init.ps1
@@ -1,6 +1,6 @@
 param (
     $darcVersion = $null,
-    $versionEndpoint = 'https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16',
+    $versionEndpoint = 'https://maestro.dot.net/api/assets/darc-version?api-version=2019-01-16',
     $verbosity = 'minimal',
     $toolpath = $null
 )
diff --git a/eng/common/darc-init.sh b/eng/common/darc-init.sh
index 84c1d0cc2e7..c305ae6bd77 100755
--- a/eng/common/darc-init.sh
+++ b/eng/common/darc-init.sh
@@ -2,7 +2,7 @@
 
 source="${BASH_SOURCE[0]}"
 darcVersion=''
-versionEndpoint='https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16'
+versionEndpoint='https://maestro.dot.net/api/assets/darc-version?api-version=2019-01-16'
 verbosity='minimal'
 
 while [[ $# > 0 ]]; do
diff --git a/eng/common/post-build/add-build-to-channel.ps1 b/eng/common/post-build/add-build-to-channel.ps1
index de2d957922a..49938f0c89f 100644
--- a/eng/common/post-build/add-build-to-channel.ps1
+++ b/eng/common/post-build/add-build-to-channel.ps1
@@ -2,7 +2,7 @@ param(
   [Parameter(Mandatory=$true)][int] $BuildId,
   [Parameter(Mandatory=$true)][int] $ChannelId,
   [Parameter(Mandatory=$true)][string] $MaestroApiAccessToken,
-  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro-prod.westus2.cloudapp.azure.com',
+  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro.dot.net',
   [Parameter(Mandatory=$false)][string] $MaestroApiVersion = '2019-01-16'
 )
 
diff --git a/eng/common/post-build/publish-using-darc.ps1 b/eng/common/post-build/publish-using-darc.ps1
index 8508397d776..1e779fec4dd 100644
--- a/eng/common/post-build/publish-using-darc.ps1
+++ b/eng/common/post-build/publish-using-darc.ps1
@@ -3,7 +3,7 @@ param(
   [Parameter(Mandatory=$true)][int] $PublishingInfraVersion,
   [Parameter(Mandatory=$true)][string] $AzdoToken,
   [Parameter(Mandatory=$true)][string] $MaestroToken,
-  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro-prod.westus2.cloudapp.azure.com',
+  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro.dot.net',
   [Parameter(Mandatory=$true)][string] $WaitPublishingFinish,
   [Parameter(Mandatory=$false)][string] $ArtifactsPublishingAdditionalParameters,
   [Parameter(Mandatory=$false)][string] $SymbolPublishingAdditionalParameters
diff --git a/eng/common/post-build/trigger-subscriptions.ps1 b/eng/common/post-build/trigger-subscriptions.ps1
index 55dea518ac5..ac9a95778fc 100644
--- a/eng/common/post-build/trigger-subscriptions.ps1
+++ b/eng/common/post-build/trigger-subscriptions.ps1
@@ -2,7 +2,7 @@ param(
   [Parameter(Mandatory=$true)][string] $SourceRepo,
   [Parameter(Mandatory=$true)][int] $ChannelId,
   [Parameter(Mandatory=$true)][string] $MaestroApiAccessToken,
-  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro-prod.westus2.cloudapp.azure.com',
+  [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro.dot.net',
   [Parameter(Mandatory=$false)][string] $MaestroApiVersion = '2019-01-16'
 )
 
diff --git a/eng/common/sdk-task.ps1 b/eng/common/sdk-task.ps1
index 6c4ac6fec1a..73828dd30d3 100644
--- a/eng/common/sdk-task.ps1
+++ b/eng/common/sdk-task.ps1
@@ -64,7 +64,7 @@ try {
       $GlobalJson.tools | Add-Member -Name "vs" -Value (ConvertFrom-Json "{ `"version`": `"16.5`" }") -MemberType NoteProperty
     }
     if( -not ($GlobalJson.tools.PSObject.Properties.Name -match "xcopy-msbuild" )) {
-      $GlobalJson.tools | Add-Member -Name "xcopy-msbuild" -Value "17.6.0-2" -MemberType NoteProperty
+      $GlobalJson.tools | Add-Member -Name "xcopy-msbuild" -Value "17.8.1-2" -MemberType NoteProperty
     }
     if ($GlobalJson.tools."xcopy-msbuild".Trim() -ine "none") {
         $xcopyMSBuildToolsFolder = InitializeXCopyMSBuild $GlobalJson.tools."xcopy-msbuild" -install $true
diff --git a/eng/common/templates/job/job.yml b/eng/common/templates/job/job.yml
index e20ee3a983c..e24ca2f46f9 100644
--- a/eng/common/templates/job/job.yml
+++ b/eng/common/templates/job/job.yml
@@ -136,7 +136,7 @@ jobs:
         condition: and(succeeded(), in(variables['_SignType'], 'real', 'test'), eq(variables['Agent.Os'], 'Windows_NT'))
 
   - ${{ if and(eq(parameters.runAsPublic, 'false'), eq(variables['System.TeamProject'], 'internal')) }}:
-    - task: NuGetAuthenticate@0
+    - task: NuGetAuthenticate@1
 
   - ${{ if and(ne(parameters.artifacts.download, 'false'), ne(parameters.artifacts.download, '')) }}:
     - task: DownloadPipelineArtifact@2
diff --git a/eng/common/templates/job/publish-build-assets.yml b/eng/common/templates/job/publish-build-assets.yml
index 42017109f37..fa5446c093d 100644
--- a/eng/common/templates/job/publish-build-assets.yml
+++ b/eng/common/templates/job/publish-build-assets.yml
@@ -72,7 +72,7 @@ jobs:
       condition: ${{ parameters.condition }}
       continueOnError: ${{ parameters.continueOnError }}
     
-    - task: NuGetAuthenticate@0
+    - task: NuGetAuthenticate@1
 
     - task: PowerShell@2
       displayName: Publish Build Assets
@@ -81,7 +81,7 @@ jobs:
         arguments: -task PublishBuildAssets -restore -msbuildEngine dotnet
           /p:ManifestsPath='$(Build.StagingDirectory)/Download/AssetManifests'
           /p:BuildAssetRegistryToken=$(MaestroAccessToken)
-          /p:MaestroApiEndpoint=https://maestro-prod.westus2.cloudapp.azure.com
+          /p:MaestroApiEndpoint=https://maestro.dot.net
           /p:PublishUsingPipelines=${{ parameters.publishUsingPipelines }}
           /p:OfficialBuildId=$(Build.BuildNumber)
       condition: ${{ parameters.condition }}
diff --git a/eng/common/templates/post-build/common-variables.yml b/eng/common/templates/post-build/common-variables.yml
index c24193acfc9..173914f2364 100644
--- a/eng/common/templates/post-build/common-variables.yml
+++ b/eng/common/templates/post-build/common-variables.yml
@@ -7,7 +7,7 @@ variables:
 
   # Default Maestro++ API Endpoint and API Version
   - name: MaestroApiEndPoint
-    value: "https://maestro-prod.westus2.cloudapp.azure.com"
+    value: "https://maestro.dot.net"
   - name: MaestroApiAccessToken
     value: $(MaestroAccessToken)
   - name: MaestroApiVersion
diff --git a/eng/common/templates/post-build/post-build.yml b/eng/common/templates/post-build/post-build.yml
index ef720f9d781..3f74abf7ce0 100644
--- a/eng/common/templates/post-build/post-build.yml
+++ b/eng/common/templates/post-build/post-build.yml
@@ -169,7 +169,7 @@ stages:
         # This is necessary whenever we want to publish/restore to an AzDO private feed
         # Since sdk-task.ps1 tries to restore packages we need to do this authentication here
         # otherwise it'll complain about accessing a private feed.
-        - task: NuGetAuthenticate@0
+        - task: NuGetAuthenticate@1
           displayName: 'Authenticate to AzDO Feeds'
 
         # Signing validation will optionally work with the buildmanifest file which is downloaded from
@@ -266,7 +266,7 @@ stages:
             BARBuildId: ${{ parameters.BARBuildId }}
             PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
 
-        - task: NuGetAuthenticate@0
+        - task: NuGetAuthenticate@1
 
         - task: PowerShell@2
           displayName: Publish Using Darc
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index aa74ab4a81e..eb188cfda41 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -379,13 +379,13 @@ function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements =
   }
 
   # Minimum VS version to require.
-  $vsMinVersionReqdStr = '17.6'
+  $vsMinVersionReqdStr = '17.7'
   $vsMinVersionReqd = [Version]::new($vsMinVersionReqdStr)
 
   # If the version of msbuild is going to be xcopied,
   # use this version. Version matches a package here:
-  # https://dev.azure.com/dnceng/public/_artifacts/feed/dotnet-eng/NuGet/RoslynTools.MSBuild/versions/17.6.0-2
-  $defaultXCopyMSBuildVersion = '17.6.0-2'
+  # https://dev.azure.com/dnceng/public/_artifacts/feed/dotnet-eng/NuGet/RoslynTools.MSBuild/versions/17.8.1-2
+  $defaultXCopyMSBuildVersion = '17.8.1-2'
 
   if (!$vsRequirements) {
     if (Get-Member -InputObject $GlobalJson.tools -Name 'vs') {
@@ -601,7 +601,15 @@ function InitializeBuildTool() {
       ExitWithExitCode 1
     }
     $dotnetPath = Join-Path $dotnetRoot (GetExecutableFileName 'dotnet')
-    $buildTool = @{ Path = $dotnetPath; Command = 'msbuild'; Tool = 'dotnet'; Framework = 'net8.0' }
+
+    # Use override if it exists - commonly set by source-build
+    if ($null -eq $env:_OverrideArcadeInitializeBuildToolFramework) {
+      $initializeBuildToolFramework="net8.0"
+    } else {
+      $initializeBuildToolFramework=$env:_OverrideArcadeInitializeBuildToolFramework
+    }
+
+    $buildTool = @{ Path = $dotnetPath; Command = 'msbuild'; Tool = 'dotnet'; Framework = $initializeBuildToolFramework }
   } elseif ($msbuildEngine -eq "vs") {
     try {
       $msbuildPath = InitializeVisualStudioMSBuild -install:$restore
diff --git a/eng/common/tools.sh b/eng/common/tools.sh
index e8d47894334..3392e3a9992 100755
--- a/eng/common/tools.sh
+++ b/eng/common/tools.sh
@@ -341,7 +341,12 @@ function InitializeBuildTool {
   # return values
   _InitializeBuildTool="$_InitializeDotNetCli/dotnet"
   _InitializeBuildToolCommand="msbuild"
-  _InitializeBuildToolFramework="net8.0"
+  # use override if it exists - commonly set by source-build
+  if [[ "${_OverrideArcadeInitializeBuildToolFramework:-x}" == "x" ]]; then
+    _InitializeBuildToolFramework="net8.0"
+  else
+    _InitializeBuildToolFramework="${_OverrideArcadeInitializeBuildToolFramework}"
+  fi
 }
 
 # Set RestoreNoCache as a workaround for https://github.com/NuGet/Home/issues/3116
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index ef064473a14..224676be2db 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -19,7 +19,7 @@
     <PackageVersion Include="LargeAddressAware" Version="1.0.5" />
     <PackageVersion Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
 
-    <PackageVersion Include="Microsoft.BuildXL.Processes" Version="0.1.0-20231128.3" />
+    <PackageVersion Include="Microsoft.BuildXL.Processes" Version="0.1.0-20240113.1" />
     <PackageVersion Update="Microsoft.BuildXL.Processes" Condition="'$(BuildXLProcessesVersion)' != ''" Version="$(BuildXLProcessesVersion)" />
 
     <PackageVersion Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.8.2112" />
diff --git a/global.json b/global.json
index fc9267598cd..111f7c04db7 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "8.0.100-rc.1.23463.5",
+    "dotnet": "8.0.101",
     "vs": {
-      "version": "17.7.0"
+      "version": "17.8.0"
     },
-    "xcopy-msbuild": "17.7.4"
+    "xcopy-msbuild": "17.8.1-2"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.23463.1"
+    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.24060.4"
   }
 }
diff --git a/src/BannedSymbols.txt b/src/BannedSymbols.txt
index c369fe9d42b..1713f85376d 100644
--- a/src/BannedSymbols.txt
+++ b/src/BannedSymbols.txt
@@ -5,3 +5,5 @@ M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings);Do not
 M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext);Do not pass paths to XmlReader.Create--use the Stream overload
 M:System.Xml.XPath.XPathDocument.#ctor(System.String);Do not pass string paths to XPathDocument ctor--use the Stream overload
 M:System.Xml.XPath.XPathDocument.#ctor(System.String,System.Xml.XmlSpace);Do not pass string paths to XPathDocument ctor--use the Stream overload
+M:System.Xml.Linq.XDocument.Load(System.String);Do not pass uri to XDocument.Load, use overload with XmlReader instead
+M:System.Xml.Linq.XDocument.Load(System.String, System.Xml.Linq.LoadOptions);Do not pass uri to XDocument.Load, use overload with XmlReader instead
diff --git a/src/Build.UnitTests/BackEnd/KnownTelemetry_Tests.cs b/src/Build.UnitTests/BackEnd/KnownTelemetry_Tests.cs
index 3b7b1987f96..cfbf63deebd 100644
--- a/src/Build.UnitTests/BackEnd/KnownTelemetry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/KnownTelemetry_Tests.cs
@@ -49,8 +49,7 @@ public void BuildTelemetryConstructedHasNoProperties()
         buildTelemetry.Target.ShouldBeNull();
         buildTelemetry.Version.ShouldBeNull();
 
-        buildTelemetry.UpdateEventProperties();
-        buildTelemetry.Properties.ShouldBeEmpty();
+        buildTelemetry.GetProperties().ShouldBeEmpty();
     }
 
     [Fact]
@@ -75,22 +74,23 @@ public void BuildTelemetryCreateProperProperties()
         buildTelemetry.Target = "clean";
         buildTelemetry.Version = new Version(1, 2, 3, 4);
 
-        buildTelemetry.UpdateEventProperties();
-        buildTelemetry.Properties.Count.ShouldBe(11);
+        var properties = buildTelemetry.GetProperties();
 
-        buildTelemetry.Properties["BuildEngineDisplayVersion"].ShouldBe("Some Display Version");
-        buildTelemetry.Properties["BuildEngineFrameworkName"].ShouldBe("new .NET");
-        buildTelemetry.Properties["BuildEngineHost"].ShouldBe("Host description");
-        buildTelemetry.Properties["InitialMSBuildServerState"].ShouldBe("hot");
-        buildTelemetry.Properties["ProjectPath"].ShouldBe(@"C:\\dev\\theProject");
-        buildTelemetry.Properties["ServerFallbackReason"].ShouldBe("busy");
-        buildTelemetry.Properties["BuildSuccess"].ShouldBe("True");
-        buildTelemetry.Properties["BuildTarget"].ShouldBe("clean");
-        buildTelemetry.Properties["BuildEngineVersion"].ShouldBe("1.2.3.4");
+        properties.Count.ShouldBe(11);
+
+        properties["BuildEngineDisplayVersion"].ShouldBe("Some Display Version");
+        properties["BuildEngineFrameworkName"].ShouldBe("new .NET");
+        properties["BuildEngineHost"].ShouldBe("Host description");
+        properties["InitialMSBuildServerState"].ShouldBe("hot");
+        properties["ProjectPath"].ShouldBe(@"C:\\dev\\theProject");
+        properties["ServerFallbackReason"].ShouldBe("busy");
+        properties["BuildSuccess"].ShouldBe("True");
+        properties["BuildTarget"].ShouldBe("clean");
+        properties["BuildEngineVersion"].ShouldBe("1.2.3.4");
 
         // verify computed
-        buildTelemetry.Properties["BuildDurationInMilliseconds"] = (finishedAt - startAt).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
-        buildTelemetry.Properties["InnerBuildDurationInMilliseconds"] = (finishedAt - innerStartAt).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+        properties["BuildDurationInMilliseconds"] = (finishedAt - startAt).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+        properties["InnerBuildDurationInMilliseconds"] = (finishedAt - innerStartAt).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
     }
 
     [Fact]
@@ -100,22 +100,18 @@ public void BuildTelemetryHandleNullsInRecordedTimes()
 
         buildTelemetry.StartAt = DateTime.MinValue;
         buildTelemetry.FinishedAt = null;
-        buildTelemetry.UpdateEventProperties();
-        buildTelemetry.Properties.ShouldBeEmpty();
+        buildTelemetry.GetProperties().ShouldBeEmpty();
 
         buildTelemetry.StartAt = null;
         buildTelemetry.FinishedAt = DateTime.MaxValue;
-        buildTelemetry.UpdateEventProperties();
-        buildTelemetry.Properties.ShouldBeEmpty();
+        buildTelemetry.GetProperties().ShouldBeEmpty();
 
         buildTelemetry.InnerStartAt = DateTime.MinValue;
         buildTelemetry.FinishedAt = null;
-        buildTelemetry.UpdateEventProperties();
-        buildTelemetry.Properties.ShouldBeEmpty();
+        buildTelemetry.GetProperties().ShouldBeEmpty();
 
         buildTelemetry.InnerStartAt = null;
         buildTelemetry.FinishedAt = DateTime.MaxValue;
-        buildTelemetry.UpdateEventProperties();
-        buildTelemetry.Properties.ShouldBeEmpty();
+        buildTelemetry.GetProperties().ShouldBeEmpty();
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs
index 27b30d71997..d6e66cc6ecd 100644
--- a/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs
@@ -40,8 +40,7 @@ public void BuildTelemetryConstructedHasNoProperties()
         telemetry.BinaryLogger.ShouldBe(false);
         telemetry.BinaryLoggerUsedDefaultName.ShouldBe(false);
 
-        telemetry.UpdateEventProperties();
-        telemetry.Properties.Where(kv => kv.Value != bool.FalseString).ShouldBeEmpty();
+        telemetry.GetProperties().Where(kv => kv.Value != bool.FalseString).ShouldBeEmpty();
     }
 
     [Fact]
@@ -65,21 +64,20 @@ public void BuildTelemetryCreateProperProperties()
             BinaryLoggerUsedDefaultName = true
         };
 
-        telemetry.UpdateEventProperties();
-
-        telemetry.Properties["TerminalLogger"].ShouldBe(bool.TrueString);
-        telemetry.Properties["TerminalLoggerUserIntent"].ShouldBe("on");
-        telemetry.Properties["TerminalLoggerUserIntentSource"].ShouldBe("arg");
-        telemetry.Properties["TerminalLoggerDefault"].ShouldBe("auto");
-        telemetry.Properties["TerminalLoggerDefaultSource"].ShouldBe("sdk");
-        telemetry.Properties["ConsoleLogger"].ShouldBe(bool.TrueString);
-        telemetry.Properties["ConsoleLoggerType"].ShouldBe("serial");
-        telemetry.Properties["ConsoleLoggerVerbosity"].ShouldBe("minimal");
-        telemetry.Properties["FileLogger"].ShouldBe(bool.TrueString);
-        telemetry.Properties["FileLoggerType"].ShouldBe("serial");
-        telemetry.Properties["FileLoggersCount"].ShouldBe("2");
-        telemetry.Properties["FileLoggerVerbosity"].ShouldBe("normal");
-        telemetry.Properties["BinaryLogger"].ShouldBe(bool.TrueString);
-        telemetry.Properties["BinaryLoggerUsedDefaultName"].ShouldBe(bool.TrueString);
+        var properties = telemetry.GetProperties();
+        properties["TerminalLogger"].ShouldBe(bool.TrueString);
+        properties["TerminalLoggerUserIntent"].ShouldBe("on");
+        properties["TerminalLoggerUserIntentSource"].ShouldBe("arg");
+        properties["TerminalLoggerDefault"].ShouldBe("auto");
+        properties["TerminalLoggerDefaultSource"].ShouldBe("sdk");
+        properties["ConsoleLogger"].ShouldBe(bool.TrueString);
+        properties["ConsoleLoggerType"].ShouldBe("serial");
+        properties["ConsoleLoggerVerbosity"].ShouldBe("minimal");
+        properties["FileLogger"].ShouldBe(bool.TrueString);
+        properties["FileLoggerType"].ShouldBe("serial");
+        properties["FileLoggersCount"].ShouldBe("2");
+        properties["FileLoggerVerbosity"].ShouldBe("normal");
+        properties["BinaryLogger"].ShouldBe(bool.TrueString);
+        properties["BinaryLoggerUsedDefaultName"].ShouldBe(bool.TrueString);
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
index 0dfff488ff0..39f61d819a9 100644
--- a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
@@ -13,8 +13,6 @@
 using Shouldly;
 using Xunit;
 
-
-
 #nullable disable
 
 namespace Microsoft.Build.UnitTests.BackEnd
@@ -190,6 +188,127 @@ public void TestRetrieveSubsetTargetsFromResult()
             Assert.Equal(BuildResultCode.Success, response.Results.OverallResult);
         }
 
+        [Fact]
+        public void TestCacheOnDifferentBuildFlagsPerRequest_ProvideProjectStateAfterBuild()
+        {
+            string targetName = "testTarget1";
+            int submissionId = 1;
+            int nodeRequestId = 0;
+            int configurationId = 1;
+
+            BuildRequest requestWithNoBuildDataFlags = new BuildRequest(
+               submissionId,
+               nodeRequestId,
+               configurationId,
+               new string[1] { targetName } /* escapedTargets */,
+               null /* hostServices */,
+               BuildEventContext.Invalid /* parentBuildEventContext */,
+               null /* parentRequest */,
+               BuildRequestDataFlags.None);
+
+            BuildRequest requestWithProjectStateFlag = new BuildRequest(
+               submissionId,
+               nodeRequestId,
+               configurationId,
+               new string[1] { targetName } /* escapedTargets */,
+               null /* hostServices */,
+               BuildEventContext.Invalid /* parentBuildEventContext */,
+               null /* parentRequest */,
+               BuildRequestDataFlags.ProvideProjectStateAfterBuild);
+
+            BuildRequest requestWithNoBuildDataFlags2 = new BuildRequest(
+               submissionId,
+               nodeRequestId,
+               configurationId,
+               new string[1] { targetName } /* escapedTargets */,
+               null /* hostServices */,
+               BuildEventContext.Invalid /* parentBuildEventContext */,
+               null /* parentRequest */,
+               BuildRequestDataFlags.None);
+
+            BuildResult resultForRequestWithNoBuildDataFlags = new(requestWithNoBuildDataFlags);
+            resultForRequestWithNoBuildDataFlags.AddResultsForTarget(targetName, BuildResultUtilities.GetEmptySucceedingTargetResult());
+            ResultsCache cache = new();
+            cache.AddResult(resultForRequestWithNoBuildDataFlags);
+
+            ResultsCacheResponse cacheResponseForRequestWithNoBuildDataFlags = cache.SatisfyRequest(
+               requestWithNoBuildDataFlags,
+               new List<string>(),
+               new List<string>(new string[] { targetName }),
+               skippedResultsDoNotCauseCacheMiss: false);
+
+            ResultsCacheResponse cachedResponseForProjectState = cache.SatisfyRequest(
+               requestWithProjectStateFlag,
+               new List<string>(),
+               new List<string>(new string[] { targetName }),
+               skippedResultsDoNotCauseCacheMiss: false);
+
+            ResultsCacheResponse cacheResponseForNoBuildDataFlags2 = cache.SatisfyRequest(
+               requestWithNoBuildDataFlags2,
+               new List<string>(),
+               new List<string>(new string[] { targetName }),
+               skippedResultsDoNotCauseCacheMiss: false);
+
+            Assert.Equal(ResultsCacheResponseType.Satisfied, cacheResponseForRequestWithNoBuildDataFlags.Type);
+
+            // Because ProvideProjectStateAfterBuildFlag was provided as a part of BuildRequest
+            Assert.Equal(ResultsCacheResponseType.NotSatisfied, cachedResponseForProjectState.Type);
+
+            Assert.Equal(ResultsCacheResponseType.Satisfied, cacheResponseForNoBuildDataFlags2.Type);
+        }
+
+        [Fact]
+        public void TestCacheOnDifferentBuildFlagsPerRequest_ProvideSubsetOfStateAfterBuild()
+        {
+            string targetName = "testTarget1";
+            int submissionId = 1;
+            int nodeRequestId = 0;
+            int configurationId = 1;
+
+            BuildRequest requestWithSubsetFlag1 = new BuildRequest(
+                submissionId,
+                nodeRequestId,
+                configurationId,
+                new string[1] { targetName } /* escapedTargets */,
+                null /* hostServices */,
+                BuildEventContext.Invalid /* parentBuildEventContext */,
+                null /* parentRequest */,
+                BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild);
+
+            BuildRequest requestWithSubsetFlag2 = new BuildRequest(
+                submissionId,
+                nodeRequestId,
+                configurationId,
+                new string[1] { targetName } /* escapedTargets */,
+                null /* hostServices */,
+                BuildEventContext.Invalid /* parentBuildEventContext */,
+                null /* parentRequest */,
+                BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild);
+
+            BuildResult resultForRequestWithSubsetFlag1 = new(requestWithSubsetFlag1);
+            resultForRequestWithSubsetFlag1.AddResultsForTarget(targetName, BuildResultUtilities.GetEmptySucceedingTargetResult());
+            ResultsCache cache = new();
+            cache.AddResult(resultForRequestWithSubsetFlag1);
+
+            ResultsCacheResponse cachedResponseWithSubsetFlag1 = cache.SatisfyRequest(
+            requestWithSubsetFlag1,
+            new List<string>(),
+            new List<string>(new string[] { targetName }),
+            skippedResultsDoNotCauseCacheMiss: false);
+
+            ResultsCacheResponse cachedResponseWithSubsetFlag2 = cache.SatisfyRequest(
+                requestWithSubsetFlag2,
+                new List<string>(),
+                new List<string>(new string[] { targetName }),
+                skippedResultsDoNotCauseCacheMiss: false);
+
+            // It was agreed not to return cache results if ProvideSubsetOfStateAfterBuild is passed,
+            // because RequestedProjectState may have different user filters defined.
+            // It is more reliable to ignore the cached value. 
+            Assert.Equal(ResultsCacheResponseType.NotSatisfied, cachedResponseWithSubsetFlag1.Type);
+            Assert.Equal(ResultsCacheResponseType.NotSatisfied, cachedResponseWithSubsetFlag2.Type);    
+        }
+
         [Fact]
         public void TestClearResultsCache()
         {
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index bb2cf8e7019..831ec4a4091 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -111,7 +111,6 @@ public void AssertResolverThrows()
             e.Sdk.Name.ShouldBe("1sdkName");
         }
 
-
         [Fact]
         // Scenario: MockSdkResolverWithResolvableSdkPattern2 is a specific resolver (i.e. resolver with pattern)
         // and it successfully resolves sdk.
@@ -184,6 +183,21 @@ public void AssertFirstResolverWithPatternCanResolve()
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolver1 running");
         }
 
+        [Fact]
+        public void AssertSdkResolutionMessagesAreLogged()
+        {
+            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy());
+            SdkReference sdk = new SdkReference("1sdkName", "referencedVersion", "minimumVersion");
+
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
+
+            // First resolver attempted to resolve, but failed.
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("SDKResolverAttempt", nameof(MockResolverReturnsNull), sdk.ToString(), "null",
+                ResourceUtilities.FormatResourceStringStripCodeAndKeyword("SDKResolverReturnedNull", nameof(MockResolverReturnsNull))));
+            // Second resolver succeeded.
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("SucceededToResolveSDK", sdk.ToString(), nameof(MockSdkResolver1), result.Path, result.Version));
+        }
+
         [Fact]
         public void AssertFirstResolverErrorsSupressedWhenResolved()
         {
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index 4928a8d29f8..ccd837ef921 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -5,8 +5,10 @@
 using System.Collections.Generic;
 using System.IO;
 using System.IO.Compression;
+using System.Linq;
+using System.Reflection;
 using System.Text;
-
+using FluentAssertions;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -83,10 +85,21 @@ public BinaryLoggerTests(ITestOutputHelper output)
             _logFile = _env.ExpectFile(".binlog").Path;
         }
 
+        public enum BinlogRoundtripTestReplayMode
+        {
+            NoReplay,
+            Structured,
+            RawEvents
+        }
+
         [Theory]
-        [InlineData(s_testProject)]
-        [InlineData(s_testProject2)]
-        public void TestBinaryLoggerRoundtrip(string projectText)
+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.NoReplay)]
+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.Structured)]
+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.RawEvents)]
+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.NoReplay)]
+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.Structured)]
+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.RawEvents)]
+        public void TestBinaryLoggerRoundtrip(string projectText, BinlogRoundtripTestReplayMode replayMode)
         {
             var binaryLogger = new BinaryLogger();
 
@@ -110,6 +123,36 @@ public void TestBinaryLoggerRoundtrip(string projectText)
                 project.Build(new ILogger[] { binaryLogger, mockLogFromBuild, serialFromBuild, parallelFromBuild }).ShouldBeTrue();
             }
 
+            string fileToReplay;
+            switch (replayMode)
+            {
+                case BinlogRoundtripTestReplayMode.NoReplay:
+                    fileToReplay = _logFile;
+                    break;
+                case BinlogRoundtripTestReplayMode.Structured:
+                case BinlogRoundtripTestReplayMode.RawEvents:
+                    {
+                        var logReader = new BinaryLogReplayEventSource();
+                        fileToReplay = _env.ExpectFile(".binlog").Path;
+                        if (replayMode == BinlogRoundtripTestReplayMode.Structured)
+                        {
+                            // need dummy handler to force structured replay
+                            logReader.BuildFinished += (_, _) => { };
+                        }
+
+                        BinaryLogger outputBinlog = new BinaryLogger()
+                        {
+                            Parameters = fileToReplay
+                        };
+                        outputBinlog.Initialize(logReader);
+                        logReader.Replay(_logFile);
+                        outputBinlog.Shutdown();
+                    }
+                    break;
+                default:
+                    throw new ArgumentOutOfRangeException(nameof(replayMode), replayMode, null);
+            }
+
             var mockLogFromPlayback = new MockLogger();
 
             var serialFromPlaybackText = new StringBuilder();
@@ -126,7 +169,10 @@ public void TestBinaryLoggerRoundtrip(string projectText)
             parallelFromPlayback.Initialize(binaryLogReader);
 
             // read the binary log and replay into mockLogger2
-            binaryLogReader.Replay(_logFile);
+            binaryLogReader.Replay(fileToReplay);
+            mockLogFromPlayback.Shutdown();
+            serialFromPlayback.Shutdown();
+            parallelFromPlayback.Shutdown();
 
             // the binlog will have more information than recorded by the text log
             mockLogFromPlayback.FullLog.ShouldContainWithoutWhitespace(mockLogFromBuild.FullLog);
@@ -140,6 +186,138 @@ public void TestBinaryLoggerRoundtrip(string projectText)
             parallelActual.ShouldContainWithoutWhitespace(parallelExpected);
         }
 
+        /// <summary>
+        /// This test validate that binlog file content is identical upon replaying.
+        /// The identity can be defined via 3 ways:
+        ///   * byte-for-byte equality
+        ///   * byte-for-byte equality of unzipped content
+        ///   * structured equality of events
+        ///
+        /// They are ordered by their strength (the byte-for-byte equality implies the other two, etc.),
+        ///  but we mainly care about the structured equality. If the more strong equalities are broken -
+        ///  the assertions can be simply removed.
+        /// However the structured equality is important - it guarantees that binlog reading and writing functionality
+        ///  is not dropping or altering any information.
+        /// </summary>
+        /// <param name="projectText"></param>
+        /// <param name="replayMode"></param>
+        [Theory]
+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.Structured)]
+        [InlineData(s_testProject, BinlogRoundtripTestReplayMode.RawEvents)]
+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.Structured)]
+        [InlineData(s_testProject2, BinlogRoundtripTestReplayMode.RawEvents)]
+        public void TestBinaryLoggerRoundtripEquality(string projectText, BinlogRoundtripTestReplayMode replayMode)
+        {
+            var binaryLogger = new BinaryLogger();
+
+            binaryLogger.Parameters = _logFile;
+
+            // build and log into binary logger
+            using (ProjectCollection collection = new())
+            {
+                Project project = ObjectModelHelpers.CreateInMemoryProject(collection, projectText);
+                // make sure the project file makes it to the binlog (it has file existence check)
+                File.WriteAllText(project.FullPath, projectText);
+                project.Build(new ILogger[] { binaryLogger }).ShouldBeTrue();
+                File.Delete(project.FullPath);
+            }
+
+            var logReader = new BinaryLogReplayEventSource();
+            string replayedLogFile = _env.ExpectFile(".binlog").Path;
+            if (replayMode == BinlogRoundtripTestReplayMode.Structured)
+            {
+                // need dummy handler to force structured replay
+                logReader.BuildFinished += (_, _) => { };
+            }
+
+            BinaryLogger outputBinlog = new BinaryLogger()
+            {
+                Parameters = $"LogFile={replayedLogFile};OmitInitialInfo"
+            };
+            outputBinlog.Initialize(logReader);
+            logReader.Replay(_logFile);
+            outputBinlog.Shutdown();
+
+            AssertBinlogsHaveEqualContent(_logFile, replayedLogFile);
+            // If this assertation complicates development - it can possibly be removed
+            // The structured equality above should be enough.
+            AssertFilesAreBinaryEqualAfterUnpack(_logFile, replayedLogFile);
+        }
+
+        private static void AssertFilesAreBinaryEqualAfterUnpack(string firstPath, string secondPath)
+        {
+            using var br1 = BinaryLogReplayEventSource.OpenReader(firstPath);
+            using var br2 = BinaryLogReplayEventSource.OpenReader(secondPath);
+            const int bufferSize = 4096;
+
+            int readCount = 0;
+            while (br1.ReadBytes(bufferSize) is { Length: > 0 } bytes1)
+            {
+                var bytes2 = br2.ReadBytes(bufferSize);
+
+                bytes1.SequenceEqual(bytes2).ShouldBeTrue(
+                    $"Buffers starting at position {readCount} differ. First:{Environment.NewLine}{string.Join(",", bytes1)}{Environment.NewLine}Second:{Environment.NewLine}{string.Join(",", bytes2)}");
+                readCount += bufferSize;
+            }
+
+            br2.ReadBytes(bufferSize).Length.ShouldBe(0, "Second buffer contains bytes after first file end");
+        }
+
+        private static void AssertBinlogsHaveEqualContent(string firstPath, string secondPath)
+        {
+            using var reader1 = BinaryLogReplayEventSource.OpenBuildEventsReader(firstPath);
+            using var reader2 = BinaryLogReplayEventSource.OpenBuildEventsReader(secondPath);
+
+            Dictionary<string, string> embedFiles1 = new();
+            Dictionary<string, string> embedFiles2 = new();
+
+            reader1.ArchiveFileEncountered += arg
+                => AddArchiveFile(embedFiles1, arg);
+
+            // This would be standard subscribe:
+            // reader2.ArchiveFileEncountered += arg
+            //    => AddArchiveFile(embedFiles2, arg);
+
+            // We however use the AddArchiveFileFromStringHandler - to exercise it
+            // and to assert it's equality with ArchiveFileEncountered handler
+            string currentFileName = null;
+            reader2.ArchiveFileEncountered +=
+                ((Action<StringReadEventArgs>)AddArchiveFileFromStringHandler).ToArchiveFileHandler();
+
+            int i = 0;
+            while (reader1.Read() is { } ev1)
+            {
+                i++;
+                var ev2 = reader2.Read();
+
+                ev1.Should().BeEquivalentTo(ev2,
+                    $"Binlogs ({firstPath} and {secondPath}) should be equal at event {i}");
+            }
+            // Read the second reader - to confirm there are no more events
+            //  and to force the embedded files to be read.
+            reader2.Read().ShouldBeNull($"Binlogs ({firstPath} and {secondPath}) are not equal - second has more events >{i + 1}");
+
+            Assert.Equal(embedFiles1, embedFiles2);
+
+            void AddArchiveFile(Dictionary<string, string> files, ArchiveFileEventArgs arg)
+            {
+                ArchiveFile embedFile = arg.ArchiveData.ToArchiveFile();
+                files.Add(embedFile.FullPath, embedFile.Content);
+            }
+
+            void AddArchiveFileFromStringHandler(StringReadEventArgs args)
+            {
+                if (currentFileName == null)
+                {
+                    currentFileName = args.OriginalString;
+                    return;
+                }
+
+                embedFiles2.Add(currentFileName, args.OriginalString);
+                currentFileName = null;
+            }
+        }
+
         [Fact]
         public void BinaryLoggerShouldSupportFilePathExplicitParameter()
         {
@@ -172,12 +350,13 @@ public void UnusedEnvironmentVariablesDoNotAppearInBinaryLog()
 </Project>";
                 TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
                 TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
-                BinaryLogger logger = new();
-                logger.Parameters = _logFile;
-                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -bl:{logger.Parameters}", out bool success);
+                
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -bl:{_logFile}", out bool success);
                 success.ShouldBeTrue();
-                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic", out success);
+
+                RunnerUtilities.ExecMSBuild($"{_logFile} -flp:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic", out success);
                 success.ShouldBeTrue();
+
                 string text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile.log"));
                 text.ShouldContain("EnvVar2");
                 text.ShouldContain("value2");
@@ -230,10 +409,9 @@ private void AssemblyLoadsDuringTaskRun(string additionalEventText)
                     """;
                 TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
                 TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
-                BinaryLogger logger = new();
-                logger.Parameters = _logFile;
+                
                 env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
-                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -nr:False -bl:{logger.Parameters} -flp1:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile2.log")};verbosity=normal", out bool success);
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -nr:False -bl:{_logFile} -flp1:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile2.log")};verbosity=normal", out bool success);
                 success.ShouldBeTrue();
 
                 string assemblyLoadedEventText =
@@ -245,7 +423,7 @@ private void AssemblyLoadsDuringTaskRun(string additionalEventText)
                 string text2 = File.ReadAllText(Path.Combine(logFolder.Path, "logFile2.log"));
                 text2.ShouldNotContain(assemblyLoadedEventText);
                 text2.ShouldNotContain(additionalEventText);
-                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp1:logfile={Path.Combine(logFolder.Path, "logFile3.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile4.log")};verbosity=normal", out success);
+                RunnerUtilities.ExecMSBuild($"{_logFile} -flp1:logfile={Path.Combine(logFolder.Path, "logFile3.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile4.log")};verbosity=normal", out success);
                 success.ShouldBeTrue();
                 text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile3.log"));
                 text.ShouldContain(assemblyLoadedEventText);
@@ -438,22 +616,22 @@ public void SuppressCommandOutputForNonDiagVerbosity()
                             <Exec Command='echo a'/>
                         </Target>
                     </Project>";
-                BinaryLogger logger = new();
-                logger.Parameters = _logFile;
+
+
                 TransientTestFolder testFolder = env.CreateFolder(createFolder: true);
 
                 TransientTestFile projectFile1 = env.CreateFile(testFolder, "testProject01.proj", contents);
-                string consoleOutput1 = RunnerUtilities.ExecMSBuild($"{projectFile1.Path} -bl:{logger.Parameters} -verbosity:diag -nologo", out bool success1);
+                string consoleOutput1 = RunnerUtilities.ExecMSBuild($"{projectFile1.Path} -bl:{_logFile} -verbosity:diag -nologo", out bool success1);
                 success1.ShouldBeTrue();
-                var expected1 = $"-nologo -bl:{logger.Parameters} -verbosity:diag {projectFile1.Path}";
+                var expected1 = $"-nologo -bl:{_logFile} -verbosity:diag {projectFile1.Path}";
                 consoleOutput1.ShouldContain(expected1);
 
                 foreach (var verbosity in new string[] { "q", "m", "n", "d" })
                 {
                     TransientTestFile projectFile2 = env.CreateFile(testFolder, $"testProject_{verbosity}.proj", contents);
-                    string consoleOutput2 = RunnerUtilities.ExecMSBuild($"{projectFile2.Path} -bl:{logger.Parameters} -verbosity:{verbosity} -nologo", out bool success2);
+                    string consoleOutput2 = RunnerUtilities.ExecMSBuild($"{projectFile2.Path} -bl:{_logFile} -verbosity:{verbosity} -nologo", out bool success2);
                     success2.ShouldBeTrue();
-                    var expected2 = $"-nologo -bl:{logger.Parameters} -verbosity:{verbosity} {projectFile2.Path}";
+                    var expected2 = $"-nologo -bl:{_logFile} -verbosity:{verbosity} {projectFile2.Path}";
                     consoleOutput2.ShouldNotContain(expected2);
                 }
             }
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index faacc88379f..99474115048 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -7,6 +7,7 @@
 using System.IO;
 using System.Linq;
 using System.Text;
+using FluentAssertions;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
@@ -894,6 +895,232 @@ public void ReadingCorruptedStreamThrows()
             }
         }
 
+        [Fact]
+        public void ForwardCompatibleRead_HandleAppendOnlyChanges()
+        {
+            // Let's not write any strings prior the first event - to make locating (and overwriting) the size byte(s) easier.
+            BuildErrorEventArgs error = new(null, null, null, 1, 2, 3, 4, null, null, null);
+            BuildFinishedEventArgs finished = new("Message", "HelpKeyword", true);
+
+            var memoryStream = new MemoryStream();
+            var binaryWriter = new BinaryWriter(memoryStream);
+            var binaryReader = new BinaryReader(memoryStream);
+            var buildEventArgsWriter = new BuildEventArgsWriter(binaryWriter);
+
+            buildEventArgsWriter.Write(error);
+
+            // Some future data that are not known in current version
+            binaryWriter.Write(new byte[] { 1, 2, 3, 4 });
+
+
+            int positionAfterFirstEvent = (int)memoryStream.Position;
+            memoryStream.Position = 0;
+            // event type
+            Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
+            int eventSizePos = (int)memoryStream.Position;
+            int eventSize = Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
+            int positionAfterFirstEventSize = (int)memoryStream.Position;
+            memoryStream.Position = eventSizePos;
+            // the extra 4 bytes
+            Microsoft.Build.Shared.BinaryWriterExtensions.Write7BitEncodedInt(binaryWriter, eventSize + 4);
+            memoryStream.Position.ShouldBe(positionAfterFirstEventSize, "The event size need to be overwritten in place - without overwriting any bytes after the size info");
+            memoryStream.Position = positionAfterFirstEvent;
+
+            buildEventArgsWriter.Write(finished);
+
+            // Remember num of bytes written - we should read them all.
+            long length = memoryStream.Length;
+            // Now move back to the beginning of the stream and start reading.
+            memoryStream.Position = 0;
+
+            using var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion)
+            {
+                SkipUnknownEventParts = true
+            };
+
+            List<BinaryLogReaderErrorEventArgs> readerErrors = new();
+            buildEventArgsReader.RecoverableReadError += readerErrors.Add;
+
+            var deserializedError = (BuildErrorEventArgs)buildEventArgsReader.Read();
+
+            readerErrors.Count.ShouldBe(1);
+            readerErrors[0].ErrorType.ShouldBe(ReaderErrorType.UnknownEventData);
+            readerErrors[0].RecordKind.ShouldBe(BinaryLogRecordKind.Error);
+
+            deserializedError.Should().BeEquivalentTo(error);
+
+            var deserializedFinished = (BuildFinishedEventArgs)buildEventArgsReader.Read();
+
+            readerErrors.Count.ShouldBe(1);
+
+            deserializedFinished.Should().BeEquivalentTo(finished);
+
+            // There is nothing else in the stream
+            memoryStream.Position.Should().Be(length);
+        }
+
+        [Fact]
+        public void ForwardCompatibleRead_HandleUnknownEvent()
+        {
+            // Let's not write any strings prior the first event - to make locating (and overwriting) the event type byte(s) easier.
+            BuildErrorEventArgs error = new(null, null, null, 1, 2, 3, 4, null, null, null);
+            BuildFinishedEventArgs finished = new("Message", "HelpKeyword", true);
+
+            var memoryStream = new MemoryStream();
+            var binaryWriter = new BinaryWriter(memoryStream);
+            var binaryReader = new BinaryReader(memoryStream);
+            var buildEventArgsWriter = new BuildEventArgsWriter(binaryWriter);
+
+            buildEventArgsWriter.Write(error);
+
+            int positionAfterFirstEvent = (int)memoryStream.Position;
+            memoryStream.Position = 0;
+            // event type
+            Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
+            int eventSizePos = (int)memoryStream.Position;
+            memoryStream.Position = 0;
+
+            // some future type that is not known in current version
+            BinaryLogRecordKind unknownType = (BinaryLogRecordKind) Enum.GetValues(typeof(BinaryLogRecordKind)).Cast<BinaryLogRecordKind>().Select(e => (int)e).Max() + 2;
+            Microsoft.Build.Shared.BinaryWriterExtensions.Write7BitEncodedInt(binaryWriter, (int)unknownType);
+            memoryStream.Position.ShouldBe(eventSizePos, "The event type need to be overwritten in place - without overwriting any bytes after the type info");
+            memoryStream.Position = positionAfterFirstEvent;
+
+            buildEventArgsWriter.Write(finished);
+
+            // Remember num of bytes written - we should read them all.
+            long length = memoryStream.Length;
+            // Now move back to the beginning of the stream and start reading.
+            memoryStream.Position = 0;
+
+            List<BinaryLogReaderErrorEventArgs> readerErrors = new();
+            using var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion)
+            {
+                SkipUnknownEvents = true
+            };
+
+            buildEventArgsReader.RecoverableReadError += readerErrors.Add;
+
+            var deserializedEvent = buildEventArgsReader.Read();
+
+            readerErrors.Count.ShouldBe(1);
+            readerErrors[0].ErrorType.ShouldBe(ReaderErrorType.UnknownEventType);
+            readerErrors[0].RecordKind.ShouldBe(unknownType);
+
+            deserializedEvent.Should().BeEquivalentTo(finished);
+
+            // There is nothing else in the stream
+            memoryStream.Position.Should().Be(length);
+        }
+
+        [Fact]
+        public void ForwardCompatibleRead_HandleMismatchedFormatOfEvent()
+        {
+            // BuildErrorEventArgs error = new("Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "SenderName");
+            BuildErrorEventArgs error = new(null, null, null, 1, 2, 3, 4, null, null, null);
+            BuildFinishedEventArgs finished = new("Message", "HelpKeyword", true);
+
+            var memoryStream = new MemoryStream();
+            var binaryWriter = new BinaryWriter(memoryStream);
+            var binaryReader = new BinaryReader(memoryStream);
+            var buildEventArgsWriter = new BuildEventArgsWriter(binaryWriter);
+
+            buildEventArgsWriter.Write(error);
+
+            int positionAfterFirstEvent = (int)memoryStream.Position;
+            memoryStream.Position = 0;
+            // event type
+            Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
+            int eventSize = Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
+            // overwrite the entire event with garbage
+            binaryWriter.Write(Enumerable.Repeat(byte.MaxValue, eventSize).ToArray());
+
+            memoryStream.Position.ShouldBe(positionAfterFirstEvent, "The event need to be overwritten in place - without overwriting any bytes after the size info");
+
+            buildEventArgsWriter.Write(finished);
+
+            // Remember num of bytes written - we should read them all.
+            long length = memoryStream.Length;
+            // Now move back to the beginning of the stream and start reading.
+            memoryStream.Position = 0;
+
+            using var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion)
+            {
+                SkipUnknownEvents = true
+            };
+
+            List<BinaryLogReaderErrorEventArgs> readerErrors = new();
+            buildEventArgsReader.RecoverableReadError += readerErrors.Add;
+
+            var deserializedEvent = buildEventArgsReader.Read();
+
+            readerErrors.Count.ShouldBe(1);
+            readerErrors[0].ErrorType.ShouldBe(ReaderErrorType.UnknownFormatOfEventData);
+            readerErrors[0].RecordKind.ShouldBe(BinaryLogRecordKind.Error);
+            readerErrors[0].GetFormattedMessage().ShouldContain("FormatException");
+
+            deserializedEvent.Should().BeEquivalentTo(finished);
+
+            // There is nothing else in the stream
+            memoryStream.Position.Should().Be(length);
+        }
+
+        [Fact]
+        public void ForwardCompatibleRead_HandleRemovalOfDataFromEventDefinition()
+        {
+            // BuildErrorEventArgs error = new("Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "SenderName");
+            BuildErrorEventArgs error = new(null, null, null, 1, 2, 3, 4, null, null, null);
+            BuildFinishedEventArgs finished = new("Message", "HelpKeyword", true);
+
+            var memoryStream = new MemoryStream();
+            var binaryWriter = new BinaryWriter(memoryStream);
+            var binaryReader = new BinaryReader(memoryStream);
+            var buildEventArgsWriter = new BuildEventArgsWriter(binaryWriter);
+
+            buildEventArgsWriter.Write(error);
+
+            int positionAfterFirstEvent = (int)memoryStream.Position;
+            memoryStream.Position = 0;
+            // event type
+            Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
+            int eventSizePos = (int)memoryStream.Position;
+            int eventSize = Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
+            int positionAfterFirstEventSize = (int)memoryStream.Position;
+            memoryStream.Position = eventSizePos;
+            // simulate there are 4 bytes less in the future version of the event - while our reader expects those
+            Microsoft.Build.Shared.BinaryWriterExtensions.Write7BitEncodedInt(binaryWriter, eventSize - 4);
+            memoryStream.Position.ShouldBe(positionAfterFirstEventSize, "The event size need to be overwritten in place - without overwriting any bytes after the size info");
+            // remove the 4 bytes - so that actual size of event is inline with it's written size.
+            memoryStream.Position = positionAfterFirstEvent - 4;
+
+            buildEventArgsWriter.Write(finished);
+
+            // Remember num of bytes written - we should read them all.
+            long length = memoryStream.Length;
+            // Now move back to the beginning of the stream and start reading.
+            memoryStream.Position = 0;
+
+            using var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion)
+            {
+                SkipUnknownEvents = true
+            };
+
+            List<BinaryLogReaderErrorEventArgs> readerErrors = new();
+            buildEventArgsReader.RecoverableReadError += readerErrors.Add;
+
+            var deserializedEvent = buildEventArgsReader.Read();
+
+            readerErrors.Count.ShouldBe(1);
+            readerErrors[0].ErrorType.ShouldBe(ReaderErrorType.UnknownFormatOfEventData);
+            readerErrors[0].RecordKind.ShouldBe(BinaryLogRecordKind.Error);
+            readerErrors[0].GetFormattedMessage().ShouldContain("EndOfStreamException");
+
+            deserializedEvent.Should().BeEquivalentTo(finished);
+
+            // There is nothing else in the stream
+            memoryStream.Position.Should().Be(length);
+        }
+
         private string ToString(BuildEventContext context)
         {
             return $"{context.BuildRequestId} {context.NodeId} {context.ProjectContextId} {context.ProjectInstanceId} {context.SubmissionId} {context.TargetId} {context.TaskId}";
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 825bbea6598..f2bc8fd22a8 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -681,13 +681,14 @@ public void ConstructGraphWithSolution()
             /*
              * This test exercises various key features of solution-based builds:
              *      From AssignProjectConfiguration:
-             *          Adding synthetic project references
+             *          Adding synthetic project references (defined both before and after the depending project)
              *          Resolving project configuration based on the sln
              *          Handling unresolved project references with ShouldUnsetParentConfigurationAndPlatform=true
              *          Handling unresolved project references with ShouldUnsetParentConfigurationAndPlatform=false
              *      Project types other than "well-known" MSBuild project types:
              *          Buildable project (wapproj)
              *          Solution folder
+             *      Project not included in build (also has solution dependencies as a regression test)
              * 
              */
             using (var env = TestEnvironment.Create())
@@ -697,9 +698,12 @@ public void ConstructGraphWithSolution()
                     # Visual Studio Version 17
                     VisualStudioVersion = 17.0.31903.59
                     MinimumVisualStudioVersion = 17.0.31903.59
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Project8", "Project8.csproj", "{2022C11A-1405-4983-BEC2-3A8B0233108F}"
+                    EndProject
                     Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Project1", "Project1.csproj", "{8761499A-7280-43C4-A32F-7F41C47CA6DF}"
                         ProjectSection(ProjectDependencies) = postProject
                             {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98} = {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F} = {2022C11A-1405-4983-BEC2-3A8B0233108F}
                         EndProjectSection
                     EndProject
                     Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Project2", "Project2.vcxproj", "{D638A8EF-3A48-45F2-913C-88B29FED03CB}"
@@ -708,6 +712,11 @@ public void ConstructGraphWithSolution()
                     EndProject
                     Project("{C7167F0D-BC9F-4E6E-AFE1-012C56B48DB5}") = "Project6", "Project6.wapproj", "{CA5CAD1A-224A-4171-B13A-F16E576FDD12}"
                     EndProject
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Project7", "Project7.csproj", "{28C7025E-2AB6-4962-A001-1E5B2271837C}"
+                        ProjectSection(ProjectDependencies) = postProject
+                            {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98} = {52B2ED64-1CFC-401B-8C5B-6D1E1DEADF98}
+                        EndProjectSection
+                    EndProject
                     Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{0392E290-973E-4086-A58E-F927AAA65B9A}"
                         ProjectSection(SolutionItems) = preProject
                             SomeSolutionItemsFile = SomeSolutionItemsFile
@@ -723,6 +732,18 @@ public void ConstructGraphWithSolution()
                             Release|x86 = Release|x86
                         EndGlobalSection
                         GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|Win32.ActiveCfg = Debug|x86
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|Win32.Build.0 = Debug|x86
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x64.ActiveCfg = Debug|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x64.Build.0 = Debug|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x86.ActiveCfg = Debug|x86
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x86.Build.0 = Debug|x86
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|Win32.ActiveCfg = Release|x86
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|Win32.Build.0 = Release|x86
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x64.ActiveCfg = Release|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x64.Build.0 = Release|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x86.ActiveCfg = Release|x86
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x86.Build.0 = Release|x86
                             {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|Win32.ActiveCfg = Debug|x86
                             {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|Win32.Build.0 = Debug|x86
                             {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.ActiveCfg = Debug|x64
@@ -777,14 +798,14 @@ public void ConstructGraphWithSolution()
                             {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Debug|x86.Build.0 = Debug|x86
                             {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Debug|x86.Deploy.0 = Debug|x86
                             {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Release|Win32.ActiveCfg = Release|x86
-                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Release|Win32.Build.0 = Release|x86
-                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Release|Win32.Deploy.0 = Release|x86
                             {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Release|x64.ActiveCfg = Release|x64
-                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Release|x64.Build.0 = Release|x64
-                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Release|x64.Deploy.0 = Release|x64
                             {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Release|x86.ActiveCfg = Release|x86
-                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Release|x86.Build.0 = Release|x86
-                            {CA5CAD1A-224A-4171-B13A-F16E576FDD12}.Release|x86.Deploy.0 = Release|x86
+                            {28C7025E-2AB6-4962-A001-1E5B2271837C}.Debug|Win32.ActiveCfg = Debug|x86
+                            {28C7025E-2AB6-4962-A001-1E5B2271837C}.Debug|x64.ActiveCfg = Debug|x64
+                            {28C7025E-2AB6-4962-A001-1E5B2271837C}.Debug|x86.ActiveCfg = Debug|x86
+                            {28C7025E-2AB6-4962-A001-1E5B2271837C}.Release|Win32.ActiveCfg = Release|x86
+                            {28C7025E-2AB6-4962-A001-1E5B2271837C}.Release|x64.ActiveCfg = Release|x64
+                            {28C7025E-2AB6-4962-A001-1E5B2271837C}.Release|x86.ActiveCfg = Release|x86
                         EndGlobalSection
                         GlobalSection(SolutionProperties) = preSolution
                             HideSolutionNode = FALSE
@@ -796,7 +817,7 @@ public void ConstructGraphWithSolution()
 
                 ProjectRootElement project1Xml = ProjectRootElement.Create();
 
-                // Project 1 depends on Project 2 using ProjectReference but there is a sln-based dependency defined on Project 3 as well.
+                // Project 1 depends on Project 2 using ProjectReference but there is a sln-based dependency defined on Project 3 and 8 as well.
                 project1Xml.AddItem("ProjectReference", "Project2.vcxproj");
 
                 ProjectRootElement project2Xml = ProjectRootElement.Create();
@@ -814,6 +835,8 @@ public void ConstructGraphWithSolution()
                 ProjectRootElement project4Xml = ProjectRootElement.Create();
                 ProjectRootElement project5Xml = ProjectRootElement.Create();
                 ProjectRootElement project6Xml = ProjectRootElement.Create();
+                ProjectRootElement project7Xml = ProjectRootElement.Create();
+                ProjectRootElement project8Xml = ProjectRootElement.Create();
 
                 string project1Path = Path.Combine(env.DefaultTestDirectory.Path, "Project1.csproj");
                 string project2Path = Path.Combine(env.DefaultTestDirectory.Path, "Project2.vcxproj");
@@ -821,6 +844,8 @@ public void ConstructGraphWithSolution()
                 string project4Path = Path.Combine(env.DefaultTestDirectory.Path, "Project4.vcxproj");
                 string project5Path = Path.Combine(env.DefaultTestDirectory.Path, "Project5.vcxproj");
                 string project6Path = Path.Combine(env.DefaultTestDirectory.Path, "Project6.wapproj");
+                string project7Path = Path.Combine(env.DefaultTestDirectory.Path, "Project7.csproj");
+                string project8Path = Path.Combine(env.DefaultTestDirectory.Path, "Project8.csproj");
 
                 project1Xml.Save(project1Path);
                 project2Xml.Save(project2Path);
@@ -828,27 +853,33 @@ public void ConstructGraphWithSolution()
                 project4Xml.Save(project4Path);
                 project5Xml.Save(project5Path);
                 project6Xml.Save(project6Path);
+                project7Xml.Save(project7Path);
+                project8Xml.Save(project8Path);
 
                 var projectGraph = new ProjectGraph(slnFile.Path);
-                projectGraph.EntryPointNodes.Count.ShouldBe(4);
+                projectGraph.EntryPointNodes.Count.ShouldBe(5);
+                projectGraph.EntryPointNodes.Select(node => node.ProjectInstance.FullPath).ShouldBe(new[] { project1Path, project2Path, project3Path, project6Path, project8Path }, ignoreOrder: true);
                 projectGraph.GraphRoots.Count.ShouldBe(2);
                 projectGraph.GraphRoots.Select(node => node.ProjectInstance.FullPath).ShouldBe(new[] { project1Path, project6Path }, ignoreOrder: true);
-                projectGraph.ProjectNodes.Count.ShouldBe(6);
+                projectGraph.ProjectNodes.Count.ShouldBe(7);
 
                 ProjectGraphNode project1Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project1Path);
                 project1Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
                 project1Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
-                project1Node.ProjectReferences.Count.ShouldBe(2);
+                project1Node.ProjectReferences.Count.ShouldBe(3);
+                project1Node.ProjectReferences.Select(node => node.ProjectInstance.FullPath).ShouldBe(new[] { project2Path, project3Path, project8Path }, ignoreOrder: true);
 
                 ProjectGraphNode project2Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project2Path);
                 project2Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
                 project2Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
                 project2Node.ProjectReferences.Count.ShouldBe(1);
+                project2Node.ProjectReferences.Select(node => node.ProjectInstance.FullPath).ShouldBe(new[] { project4Path }, ignoreOrder: true);
 
                 ProjectGraphNode project3Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project3Path);
                 project3Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
                 project3Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
                 project3Node.ProjectReferences.Count.ShouldBe(1);
+                project3Node.ProjectReferences.Select(node => node.ProjectInstance.FullPath).ShouldBe(new[] { project5Path }, ignoreOrder: true);
 
                 // Configuration and Platform get unset
                 ProjectGraphNode project4Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project4Path);
@@ -867,6 +898,14 @@ public void ConstructGraphWithSolution()
                 project6Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
                 project6Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
                 project6Node.ProjectReferences.Count.ShouldBe(0);
+
+                // Project not included in the build
+                Assert.DoesNotContain(projectGraph.ProjectNodes, node => node.ProjectInstance.FullPath == project7Path);
+
+                ProjectGraphNode project8Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project8Path);
+                project8Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project8Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+                project8Node.ProjectReferences.Count.ShouldBe(0);
             }
         }
 
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 758c98729ac..c994283bdbe 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -557,6 +557,7 @@ public void ProjectCacheByVsScenarioIgnoresSlnDisabledProjects()
                         currentBuildEnvironment.Mode,
                         currentBuildEnvironment.CurrentMSBuildExePath,
                         currentBuildEnvironment.RunningTests,
+                        currentBuildEnvironment.RunningInMSBuildExe,
                         runningInVisualStudio: true,
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
@@ -674,6 +675,7 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
                         currentBuildEnvironment.Mode,
                         currentBuildEnvironment.CurrentMSBuildExePath,
                         currentBuildEnvironment.RunningTests,
+                        currentBuildEnvironment.RunningInMSBuildExe,
                         runningInVisualStudio: true,
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
@@ -1440,6 +1442,7 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
                         currentBuildEnvironment.Mode,
                         currentBuildEnvironment.CurrentMSBuildExePath,
                         currentBuildEnvironment.RunningTests,
+                        currentBuildEnvironment.RunningInMSBuildExe,
                         runningInVisualStudio: true,
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
diff --git a/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
index 791bd5332ee..6266cb6e4c7 100644
--- a/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
+++ b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
@@ -70,8 +70,7 @@ public void TerminalLoggerOn(string tlValue)
             FileLogger = false,
         };
 
-        expectedTelemetry.UpdateEventProperties();
-        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.GetProperties())
         {
             output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
         }
@@ -101,8 +100,7 @@ public void TerminalLoggerWithTlAutoIsOff(string tlValue)
             FileLogger = false,
         };
 
-        expectedTelemetry.UpdateEventProperties();
-        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.GetProperties())
         {
             output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
         }
@@ -129,8 +127,7 @@ public void TerminalLoggerDefaultByEnv()
             FileLogger = false,
         };
 
-        expectedTelemetry.UpdateEventProperties();
-        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.GetProperties())
         {
             output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
         }
@@ -159,8 +156,7 @@ public void TerminalLoggerOnByEnv(string envVarSource)
             FileLogger = false,
         };
 
-        expectedTelemetry.UpdateEventProperties();
-        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.GetProperties())
         {
             output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
         }
@@ -188,8 +184,7 @@ public void TerminalLoggerDefaultOn(string defaultValue)
             FileLogger = false,
         };
 
-        expectedTelemetry.UpdateEventProperties();
-        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.GetProperties())
         {
             output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
         }
@@ -219,8 +214,7 @@ public void TerminalLoggerDefaultOff(string defaultValue)
             FileLogger = false,
         };
 
-        expectedTelemetry.UpdateEventProperties();
-        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.GetProperties())
         {
             output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
         }
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index bc1e535abab..3d2088d264c 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -576,8 +576,7 @@ public void BeginBuild(BuildParameters parameters)
                 LogDeferredMessages(loggingService, _deferredBuildMessages);
 
                 // Log known deferred telemetry
-                KnownTelemetry.LoggingConfigurationTelemetry.UpdateEventProperties();
-                loggingService.LogTelemetry(buildEventContext: null, KnownTelemetry.LoggingConfigurationTelemetry.EventName, KnownTelemetry.LoggingConfigurationTelemetry.Properties);
+                loggingService.LogTelemetry(buildEventContext: null, KnownTelemetry.LoggingConfigurationTelemetry.EventName, KnownTelemetry.LoggingConfigurationTelemetry.GetProperties());
 
                 InitializeCaches();
 
@@ -1090,8 +1089,7 @@ public void EndBuild()
                             }
                             _buildTelemetry.Host = host;
 
-                            _buildTelemetry.UpdateEventProperties();
-                            loggingService.LogTelemetry(buildEventContext: null, _buildTelemetry.EventName, _buildTelemetry.Properties);
+                            loggingService.LogTelemetry(buildEventContext: null, _buildTelemetry.EventName, _buildTelemetry.GetProperties());
                             // Clean telemetry to make it ready for next build submission.
                             _buildTelemetry = null;
                         }
@@ -1334,6 +1332,7 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
                             _projectCacheService.InitializePluginsForVsScenario(
                                 ProjectCacheDescriptors.Values,
                                 resolvedConfiguration,
+                                submission.BuildRequestData.TargetNames,
                                 _executionCancellationTokenSource.Token);
                         }
 
@@ -1453,13 +1452,20 @@ private void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, Bui
             }
 
             ErrorUtilities.VerifyThrow(FileUtilities.IsSolutionFilename(config.ProjectFullPath), "{0} is not a solution", config.ProjectFullPath);
+
+            var buildEventContext = request.BuildEventContext;
+            if (buildEventContext == BuildEventContext.Invalid)
+            {
+                buildEventContext = new BuildEventContext(request.SubmissionId, 0, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+            }
+
             var instances = ProjectInstance.LoadSolutionForBuild(
                 config.ProjectFullPath,
                 config.GlobalProperties,
                 config.ExplicitToolsVersionSpecified ? config.ToolsVersion : null,
                 _buildParameters,
                 ((IBuildComponentHost)this).LoggingService,
-                request.BuildEventContext,
+                buildEventContext,
                 false /* loaded by solution parser*/,
                 config.RequestedTargets,
                 SdkResolverService,
@@ -1948,7 +1954,7 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
 
             if (submission.BuildRequestData.GraphBuildOptions.Build)
             {
-                _projectCacheService.InitializePluginsForGraph(projectGraph, _executionCancellationTokenSource.Token);
+                _projectCacheService.InitializePluginsForGraph(projectGraph, submission.BuildRequestData.TargetNames, _executionCancellationTokenSource.Token);
 
                 var targetListTask = projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames);
 
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index d8167fe45b0..ec5c888265a 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -6,6 +6,7 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -17,6 +18,15 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal class ResultsCache : IResultsCache
     {
+        /// <summary>
+        /// The presence of any of these flags affects build result for the specified request.
+        /// </summary>
+        private const BuildRequestDataFlags FlagsAffectingBuildResults =
+            BuildRequestDataFlags.ProvideProjectStateAfterBuild
+            | BuildRequestDataFlags.SkipNonexistentTargets
+            | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports
+            | BuildRequestDataFlags.FailOnUnresolvedSdk;
+
         /// <summary>
         /// The table of all build results.  This table is indexed by configuration id and
         /// contains BuildResult objects which have all of the target information.
@@ -139,13 +149,14 @@ public BuildResult GetResultsForConfiguration(int configurationId)
 
         /// <summary>
         /// Attempts to satisfy the request from the cache.  The request can be satisfied only if:
-        /// 1. All specified targets in the request have successful results in the cache or if the sequence of target results
+        /// 1. The passed BuildRequestDataFlags can not affect the result data.
+        /// 2. All specified targets in the request have successful results in the cache or if the sequence of target results
         ///    includes 0 or more successful targets followed by at least one failed target.
-        /// 2. All initial targets in the configuration for the request have non-skipped results in the cache.
-        /// 3. If there are no specified targets, then all default targets in the request must have non-skipped results
+        /// 3. All initial targets in the configuration for the request have non-skipped results in the cache.
+        /// 4. If there are no specified targets, then all default targets in the request must have non-skipped results
         ///    in the cache.
         /// </summary>
-        /// <param name="request">The request whose results we should return</param>
+        /// <param name="request">The request whose results we should return.</param>
         /// <param name="configInitialTargets">The initial targets for the request's configuration.</param>
         /// <param name="configDefaultTargets">The default targets for the request's configuration.</param>
         /// <param name="skippedResultsDoNotCauseCacheMiss">If false, a cached skipped target will cause this method to return "NotSatisfied".
@@ -156,60 +167,61 @@ public BuildResult GetResultsForConfiguration(int configurationId)
         public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> configInitialTargets, List<string> configDefaultTargets, bool skippedResultsDoNotCauseCacheMiss)
         {
             ErrorUtilities.VerifyThrow(request.IsConfigurationResolved, "UnresolvedConfigurationInRequest");
-            ResultsCacheResponse response = new ResultsCacheResponse(ResultsCacheResponseType.NotSatisfied);
+            ResultsCacheResponse response = new(ResultsCacheResponseType.NotSatisfied);
 
             lock (_resultsByConfiguration)
             {
                 if (_resultsByConfiguration.TryGetValue(request.ConfigurationId, out BuildResult allResults))
                 {
-                    // Check for targets explicitly specified.
-                    bool explicitTargetsSatisfied = CheckResults(allResults, request.Targets, response.ExplicitTargetsToBuild, skippedResultsDoNotCauseCacheMiss);
+                    bool buildDataFlagsSatisfied = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)
+                        ? CheckBuildDataFlagsResults(request.BuildRequestDataFlags, allResults.BuildRequestDataFlags) : true;
 
-                    if (explicitTargetsSatisfied)
+                    if (buildDataFlagsSatisfied)
                     {
-                        // All of the explicit targets, if any, have been satisfied
-                        response.Type = ResultsCacheResponseType.Satisfied;
+                        // Check for targets explicitly specified.
+                        bool explicitTargetsSatisfied = CheckResults(allResults, request.Targets, response.ExplicitTargetsToBuild, skippedResultsDoNotCauseCacheMiss);
 
-                        // Check for the initial targets.  If we don't know what the initial targets are, we assume they are not satisfied.
-                        if (configInitialTargets == null || !CheckResults(allResults, configInitialTargets, null, skippedResultsDoNotCauseCacheMiss))
+                        if (explicitTargetsSatisfied)
                         {
-                            response.Type = ResultsCacheResponseType.NotSatisfied;
-                        }
+                            // All of the explicit targets, if any, have been satisfied
+                            response.Type = ResultsCacheResponseType.Satisfied;
 
-                        // We could still be missing implicit targets, so check those...
-                        if (request.Targets.Count == 0)
-                        {
-                            // Check for the default target, if necessary.  If we don't know what the default targets are, we
-                            // assume they are not satisfied.
-                            if (configDefaultTargets == null || !CheckResults(allResults, configDefaultTargets, null, skippedResultsDoNotCauseCacheMiss))
+                            // Check for the initial targets.  If we don't know what the initial targets are, we assume they are not satisfied.
+                            if (configInitialTargets == null || !CheckResults(allResults, configInitialTargets, null, skippedResultsDoNotCauseCacheMiss))
                             {
                                 response.Type = ResultsCacheResponseType.NotSatisfied;
                             }
-                        }
-
-                        // Now report those results requested, if they are satisfied.
-                        if (response.Type == ResultsCacheResponseType.Satisfied)
-                        {
-                            List<string> targetsToAddResultsFor = new List<string>(configInitialTargets);
 
-                            // Now report either the explicit targets or the default targets
-                            if (request.Targets.Count > 0)
+                            // We could still be missing implicit targets, so check those...
+                            if (request.Targets.Count == 0)
                             {
-                                targetsToAddResultsFor.AddRange(request.Targets);
+                                // Check for the default target, if necessary.  If we don't know what the default targets are, we
+                                // assume they are not satisfied.
+                                if (configDefaultTargets == null || !CheckResults(allResults, configDefaultTargets, null, skippedResultsDoNotCauseCacheMiss))
+                                {
+                                    response.Type = ResultsCacheResponseType.NotSatisfied;
+                                }
                             }
-                            else
+
+                            // Now report those results requested, if they are satisfied.
+                            if (response.Type == ResultsCacheResponseType.Satisfied)
                             {
-                                targetsToAddResultsFor.AddRange(configDefaultTargets);
+                                List<string> targetsToAddResultsFor = new List<string>(configInitialTargets);
+
+                                // Now report either the explicit targets or the default targets
+                                if (request.Targets.Count > 0)
+                                {
+                                    targetsToAddResultsFor.AddRange(request.Targets);
+                                }
+                                else
+                                {
+                                    targetsToAddResultsFor.AddRange(configDefaultTargets);
+                                }
+
+                                response.Results = new BuildResult(request, allResults, targetsToAddResultsFor.ToArray(), null);
                             }
-
-                            response.Results = new BuildResult(request, allResults, targetsToAddResultsFor.ToArray(), null);
                         }
                     }
-                    else
-                    {
-                        // Some targets were not satisfied.
-                        response.Type = ResultsCacheResponseType.NotSatisfied;
-                    }
                 }
             }
 
@@ -332,6 +344,20 @@ private static bool CheckResults(BuildResult result, List<string> targets, HashS
             return returnValue;
         }
 
+        /// <summary>
+        /// Checks results for the specified build flags.
+        /// </summary>
+        /// <param name="buildRequestDataFlags">The current request build flags.</param>
+        /// <param name="buildResultDataFlags">The existing build result data flags.</param>
+        /// <returns>False if there is any difference in the data flags that can cause missed build data, true otherwise.</returns>
+        private static bool CheckBuildDataFlagsResults(BuildRequestDataFlags buildRequestDataFlags, BuildRequestDataFlags buildResultDataFlags) =>
+
+            // Even if both buildRequestDataFlags and buildResultDataFlags have ProvideSubsetOfStateAfterBuild flag,
+            // the underlying RequestedProjectState may have different user filters defined.
+            // It is more reliable to ignore the cached value. 
+            !buildRequestDataFlags.HasFlag(BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild)
+            && (buildRequestDataFlags & FlagsAffectingBuildResults) == (buildResultDataFlags & FlagsAffectingBuildResults);
+
         public IEnumerator<BuildResult> GetEnumerator()
         {
             return _resultsByConfiguration.Values.GetEnumerator();
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 5e5e883ff08..340dfafc495 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -537,15 +537,11 @@ private void RaiseProjectStartedEvent(object sender, ProjectStartedEventArgs bui
                     // if a logger has failed politely, abort immediately
                     // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
                     // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
+                    UnregisterAllEventHandlers();
                     throw;
                 }
                 catch (Exception exception)
                 {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
                     if (ExceptionHandling.IsCriticalException(exception))
                     {
                         throw;
@@ -873,9 +869,9 @@ private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent)
                     // if a logger has failed politely, abort immediately
                     // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
                     // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
+                    UnregisterAllEventHandlers();
 
-                    // We ought to dump this farther up the stack, but if for example a task is logging an event within a
+                    // We ought to dump this further up the stack, but if for example a task is logging an event within a
                     // catch(Exception) block and not rethrowing it, there's the possibility that this exception could
                     // just get silently eaten.  So better to have duplicates than to not log the problem at all. :)
                     ExceptionHandling.DumpExceptionToFile(exception);
@@ -884,11 +880,7 @@ private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent)
                 }
                 catch (Exception exception)
                 {
-                    // first unregister all loggers, since other loggers may receive remaining events in unexpected orderings
-                    // if a fellow logger is throwing in an event handler.
-                    this.UnregisterAllEventHandlers();
-
-                    // We ought to dump this farther up the stack, but if for example a task is logging an event within a
+                    // We ought to dump this further up the stack, but if for example a task is logging an event within a
                     // catch(Exception) block and not rethrowing it, there's the possibility that this exception could
                     // just get silently eaten.  So better to have duplicates than to not log the problem at all. :)
                     ExceptionHandling.DumpExceptionToFile(exception);
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 1058ee7f8b1..eaf5e31be4f 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -81,7 +81,7 @@ private ProjectLoggingContext(
             List<string> targets,
             string toolsVersion,
             PropertyDictionary<ProjectPropertyInstance> projectProperties,
-            ItemDictionary<ProjectItemInstance> projectItems,
+            IItemDictionary<ProjectItemInstance> projectItems,
             BuildEventContext parentBuildEventContext,
             int evaluationId,
             int projectContextId)
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
index 256102d0d86..d7b5ea98cca 100644
--- a/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using System.Collections.Generic;
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Graph;
@@ -22,12 +23,23 @@ public class CacheContext
         public IReadOnlyCollection<ProjectGraphEntryPoint>? GraphEntryPoints { get; }
         public string? MSBuildExePath { get; }
         public MSBuildFileSystemBase FileSystem { get; }
+        public IReadOnlyCollection<string> RequestedTargets { get; }
 
         public CacheContext(
             IReadOnlyDictionary<string, string> pluginSettings,
             MSBuildFileSystemBase fileSystem,
             ProjectGraph? graph = null,
             IReadOnlyCollection<ProjectGraphEntryPoint>? graphEntryPoints = null)
+            : this(pluginSettings, fileSystem, requestedTargets: Array.Empty<string>(), graph, graphEntryPoints)
+        {
+        }
+
+        public CacheContext(
+            IReadOnlyDictionary<string, string> pluginSettings,
+            MSBuildFileSystemBase fileSystem,
+            IReadOnlyCollection<string> requestedTargets,
+            ProjectGraph? graph = null,
+            IReadOnlyCollection<ProjectGraphEntryPoint>? graphEntryPoints = null)
         {
             ErrorUtilities.VerifyThrow(
                 (graph != null) ^ (graphEntryPoints != null),
@@ -38,6 +50,7 @@ public CacheContext(
             GraphEntryPoints = graphEntryPoints;
             MSBuildExePath = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
             FileSystem = fileSystem;
+            RequestedTargets = requestedTargets;
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
index 3a954dec21b..fb23fdf63e8 100644
--- a/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
@@ -47,8 +47,11 @@ public enum CacheResultType
     public class CacheResult
     {
         public CacheResultType ResultType { get; }
+
         public BuildResult? BuildResult { get; }
+
         public ProxyTargets? ProxyTargets { get; }
+
         internal Exception? Exception { get; }
 
         private CacheResult(
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 4d695e99076..e53d28292d1 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -95,7 +95,10 @@ public ProjectCacheService(
         /// <summary>
         /// Optimization which frontloads plugin initialization since we have an entire graph.
         /// </summary>
-        public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationToken cancellationToken)
+        public void InitializePluginsForGraph(
+            ProjectGraph projectGraph,
+            ICollection<string> requestedTargets,
+            CancellationToken cancellationToken)
         {
             EnsureNotDisposed();
 
@@ -111,7 +114,7 @@ public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationTok
                             foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
                             {
                                 // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                                _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)
+                                _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, requestedTargets, cancellationToken)
                                     .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
                             }
                         });
@@ -122,6 +125,7 @@ public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationTok
         public void InitializePluginsForVsScenario(
             IEnumerable<ProjectCacheDescriptor> projectCacheDescriptors,
             BuildRequestConfiguration buildRequestConfiguration,
+            ICollection<string> requestedTargets,
             CancellationToken cancellationToken)
         {
             EnsureNotDisposed();
@@ -144,7 +148,7 @@ public void InitializePluginsForVsScenario(
                         projectCacheDescriptor =>
                         {
                             // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                            _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)
+                            _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, requestedTargets, cancellationToken)
                                 .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
                         });
                 },
@@ -155,12 +159,13 @@ private Task<ProjectCachePlugin> GetProjectCachePluginAsync(
             ProjectCacheDescriptor projectCacheDescriptor,
             ProjectGraph? projectGraph,
             BuildRequestConfiguration? buildRequestConfiguration,
+            ICollection<string> requestedTargets,
             CancellationToken cancellationToken)
             => _projectCachePlugins.GetOrAdd(
                 projectCacheDescriptor,
                 // The use of Lazy is because ConcurrentDictionary doesn't guarantee the value factory executes only once if there are multiple simultaneous callers,
                 // so this ensures that CreateAndInitializePluginAsync is only called exactly once.
-                descriptor => new Lazy<Task<ProjectCachePlugin>>(() => CreateAndInitializePluginAsync(descriptor, projectGraph, buildRequestConfiguration, cancellationToken)))
+                descriptor => new Lazy<Task<ProjectCachePlugin>>(() => CreateAndInitializePluginAsync(descriptor, projectGraph, buildRequestConfiguration, requestedTargets, cancellationToken)))
                .Value;
 
         private IEnumerable<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectInstance projectInstance)
@@ -189,6 +194,7 @@ private async Task<ProjectCachePlugin> CreateAndInitializePluginAsync(
             ProjectCacheDescriptor projectCacheDescriptor,
             ProjectGraph? projectGraph,
             BuildRequestConfiguration? buildRequestConfiguration,
+            ICollection<string> requestedTargets,
             CancellationToken cancellationToken)
         {
             BuildEventContext buildEventContext = BuildEventContext.Invalid;
@@ -241,6 +247,9 @@ private async Task<ProjectCachePlugin> CreateAndInitializePluginAsync(
                 ? GetGraphEntryPoints(buildRequestConfiguration)
                 : null;
 
+            // In practice, the underlying type of the ICollection is a List<string> so attempt to cast first
+            IReadOnlyList<string> requestedTargetsList = requestedTargets as List<string> ?? requestedTargets.ToList();
+
             _loggingService.LogComment(buildEventContext, MessageImportance.High, "LoadingProjectCachePlugin", pluginTypeName);
             MSBuildEventSource.Log.ProjectCacheBeginBuildStart(pluginTypeName);
 
@@ -250,6 +259,7 @@ await pluginInstance.BeginBuildAsync(
                     new CacheContext(
                         projectCacheDescriptor.PluginSettings,
                         DefaultMSBuildFileSystem.Instance,
+                        requestedTargetsList,
                         projectGraph,
                         graphEntryPoints),
                     pluginLogger,
@@ -517,7 +527,8 @@ private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildReques
                     continue;
                 }
 
-                ProjectCachePlugin plugin = await GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken);
+                ICollection<string> requestedTargetsList = buildRequestConfiguration.RequestedTargets as ICollection<string> ?? buildRequestConfiguration.RequestedTargets.ToList();
+                ProjectCachePlugin plugin = await GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, requestedTargetsList, cancellationToken);
                 try
                 {
                     // Rethrow any initialization exception.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index b5bcf7ca165..e0bcc5eff38 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -88,7 +88,7 @@ internal class Lookup : IPropertyProvider<ProjectPropertyInstance>, IItemProvide
         /// <summary>
         /// Construct a lookup over specified items and properties.
         /// </summary>
-        internal Lookup(ItemDictionary<ProjectItemInstance> projectItems, PropertyDictionary<ProjectPropertyInstance> properties)
+        internal Lookup(IItemDictionary<ProjectItemInstance> projectItems, PropertyDictionary<ProjectPropertyInstance> properties)
         {
             ErrorUtilities.VerifyThrowInternalNull(projectItems, nameof(projectItems));
             ErrorUtilities.VerifyThrowInternalNull(properties, nameof(properties));
@@ -120,7 +120,7 @@ private Lookup(Lookup that)
         // Convenience private properties
         // "Primary" is the "top" or "innermost" scope
         // "Secondary" is the next from the top.
-        private ItemDictionary<ProjectItemInstance> PrimaryTable
+        private IItemDictionary<ProjectItemInstance> PrimaryTable
         {
             get { return _lookupScopes.First.Value.Items; }
             set { _lookupScopes.First.Value.Items = value; }
@@ -150,7 +150,7 @@ private PropertyDictionary<ProjectPropertyInstance> PrimaryPropertySets
             set { _lookupScopes.First.Value.PropertySets = value; }
         }
 
-        private ItemDictionary<ProjectItemInstance> SecondaryTable
+        private IItemDictionary<ProjectItemInstance> SecondaryTable
         {
             get { return _lookupScopes.First.Next.Value.Items; }
             set { _lookupScopes.First.Next.Value.Items = value; }
@@ -870,7 +870,7 @@ private ProjectItemInstance RetrieveOriginalFromCloneTable(ProjectItemInstance i
         /// Applies a list of modifications to the appropriate <see cref="ItemDictionary{ProjectItemInstance}" /> in a main table.
         /// If any modifications conflict, these modifications win.
         /// </summary>
-        private void ApplyModificationsToTable(ItemDictionary<ProjectItemInstance> table, string itemType, ItemsMetadataUpdateDictionary modify)
+        private void ApplyModificationsToTable(IItemDictionary<ProjectItemInstance> table, string itemType, ItemsMetadataUpdateDictionary modify)
         {
             ICollection<ProjectItemInstance> existing = table[itemType];
             if (existing != null)
@@ -1295,7 +1295,7 @@ internal class Scope
             /// <summary>
             /// Contains all of the original items at this level in the Lookup
             /// </summary>
-            private ItemDictionary<ProjectItemInstance> _items;
+            private IItemDictionary<ProjectItemInstance> _items;
 
             /// <summary>
             /// Contains all of the items which have been added at this level in the Lookup
@@ -1344,7 +1344,7 @@ internal class Scope
             /// </summary>
             private bool _truncateLookupsAtThisScope;
 
-            internal Scope(Lookup lookup, string description, ItemDictionary<ProjectItemInstance> items, PropertyDictionary<ProjectPropertyInstance> properties)
+            internal Scope(Lookup lookup, string description, IItemDictionary<ProjectItemInstance> items, PropertyDictionary<ProjectPropertyInstance> properties)
             {
                 _owningLookup = lookup;
                 _description = description;
@@ -1364,7 +1364,7 @@ internal Scope(Lookup lookup, string description, ItemDictionary<ProjectItemInst
             /// include adds or removes unless it's the table in
             /// the outermost scope.
             /// </summary>
-            internal ItemDictionary<ProjectItemInstance> Items
+            internal IItemDictionary<ProjectItemInstance> Items
             {
                 get { return _items; }
                 set { _items = value; }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index e2c2e7cc772..0d98b32f5a8 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -842,13 +842,20 @@ private async Task BuildAndReport()
                 {
                     // The build was likely cancelled. We do not need to log an error in this case.
                 }
-                else if (_projectLoggingContext is null)
+                else if (ex is InternalLoggerException)
                 {
-                    _nodeLoggingContext.LogError(BuildEventFileInfo.Empty, "UnhandledMSBuildError", ex.ToString());
+                    string realMessage = TaskLoggingHelper.GetInnerExceptionMessageString(ex);
+                    LoggingContext loggingContext = ((LoggingContext)_projectLoggingContext) ?? _nodeLoggingContext;
+                    loggingContext.LogError(
+                        BuildEventFileInfo.Empty,
+                        "FatalErrorWhileLoggingWithInnerException",
+                        realMessage);
+
+                    loggingContext.LogCommentFromText(MessageImportance.Low, ex.ToString());
                 }
                 else
                 {
-                    _projectLoggingContext.LogError(BuildEventFileInfo.Empty, "UnhandledMSBuildError", ex.ToString());
+                    (((LoggingContext)_projectLoggingContext) ?? _nodeLoggingContext).LogError(BuildEventFileInfo.Empty, "UnhandledMSBuildError", ex.ToString());
                 }
 
                 if (ExceptionHandling.IsCriticalException(ex))
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index 3c5349611c1..25039ccd712 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -226,6 +226,20 @@ protected virtual IEnumerable<Type> GetResolverTypes(Assembly assembly)
         protected virtual Assembly LoadResolverAssembly(string resolverPath)
         {
 #if !FEATURE_ASSEMBLYLOADCONTEXT
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))
+            {
+                string resolverFileName = Path.GetFileNameWithoutExtension(resolverPath);
+                if (resolverFileName.Equals("Microsoft.DotNet.MSBuildSdkResolver", StringComparison.OrdinalIgnoreCase))
+                {
+                    // This will load the resolver assembly into the default load context if possible, and fall back to LoadFrom context.
+                    // We very much prefer the default load context because it allows native images to be used by the CLR, improving startup perf.
+                    AssemblyName assemblyName = new AssemblyName(resolverFileName)
+                    {
+                        CodeBase = resolverPath,
+                    };
+                    return Assembly.Load(assemblyName);
+                }
+            }
             return Assembly.LoadFrom(resolverPath);
 #else
             return s_loader.LoadFromPath(resolverPath);
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index a9e03193f11..79c899b4dc2 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -312,8 +312,6 @@ private bool TryResolveSdkUsingSpecifiedResolvers(
             // Loop through resolvers which have already been sorted by priority, returning the first result that was successful
             SdkLogger buildEngineLogger = new SdkLogger(loggingContext);
 
-            loggingContext.LogComment(MessageImportance.Low, "SdkResolving", sdk.ToString());
-
             foreach (SdkResolver sdkResolver in resolvers)
             {
                 SdkResolverContext context = new SdkResolverContext(buildEngineLogger, projectPath, solutionPath, ProjectCollection.Version, interactive, isRunningInVisualStudio)
@@ -355,6 +353,8 @@ private bool TryResolveSdkUsingSpecifiedResolvers(
 
                 if (result.Success)
                 {
+                    loggingContext.LogComment(MessageImportance.Low, "SucceededToResolveSDK", sdk.ToString(), sdkResolver.Name, result.Path ?? "null", result.Version ?? "null");
+
                     LogWarnings(loggingContext, sdkReferenceLocation, result.Warnings);
 
                     if (!IsReferenceSameVersion(sdk, result.Version))
@@ -369,6 +369,13 @@ private bool TryResolveSdkUsingSpecifiedResolvers(
                     sdkResult = result;
                     return true;
                 }
+                else if (loggingContext.LoggingService.MinimumRequiredMessageImportance >= MessageImportance.Low)
+                {
+                    string resultWarnings = result.Warnings?.Any() == true ? string.Join(Environment.NewLine, result.Warnings) : "null";
+                    string resultErrors = result.Errors?.Any() == true ? string.Join(Environment.NewLine, result.Errors) : "null";
+
+                    loggingContext.LogComment(MessageImportance.Low, "SDKResolverAttempt", sdkResolver.Name, sdk.ToString(), resultWarnings, resultErrors);
+                }
 
                 results.Add(result);
             }
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index 428eea19656..8951500b8d6 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -119,6 +119,11 @@ private BuildRequest(
             _nodeRequestId = nodeRequestId;
             _buildRequestDataFlags = buildRequestDataFlags;
             _requestedProjectState = requestedProjectState;
+
+            if (_requestedProjectState != null)
+            {
+                _buildRequestDataFlags |= BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild;
+            }
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 68aa197381f..cee4212033e 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -116,6 +116,11 @@ public class BuildResult : INodePacket, IBuildResults
         /// </summary>
         private ProjectInstance _projectStateAfterBuild;
 
+        /// <summary>
+        /// The flags provide additional control over the build results and may affect the cached value.
+        /// </summary>
+        private BuildRequestDataFlags _buildRequestDataFlags;
+
         private string _schedulerInducedError;
 
         private HashSet<string> _projectTargets;
@@ -204,6 +209,7 @@ internal BuildResult(BuildRequest request, BuildResult existingResults, string[]
             _nodeRequestId = request.NodeRequestId;
             _circularDependency = false;
             _baseOverallResult = true;
+            _buildRequestDataFlags = request.BuildRequestDataFlags;
 
             if (existingResults == null)
             {
@@ -380,6 +386,12 @@ public ProjectInstance ProjectStateAfterBuild
             set => _projectStateAfterBuild = value;
         }
 
+        /// <summary>
+        /// Gets the flags that were used in the build request to which these results are associated.
+        /// See <see cref="Execution.BuildRequestDataFlags"/> for examples of the available flags.
+        /// </summary>
+        public BuildRequestDataFlags BuildRequestDataFlags => _buildRequestDataFlags;
+
         /// <summary>
         /// Returns the node packet type.
         /// </summary>
@@ -581,6 +593,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _savedCurrentDirectory);
             translator.Translate(ref _schedulerInducedError);
             translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);
+            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);
         }
 
         /// <summary>
diff --git a/src/Build/Collections/IConstrainableDictionary.cs b/src/Build/Collections/IConstrainableDictionary.cs
new file mode 100644
index 00000000000..2c4b34eef5d
--- /dev/null
+++ b/src/Build/Collections/IConstrainableDictionary.cs
@@ -0,0 +1,31 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// Represents an <see cref="IDictionary{String, TValue}"/> that supports use of an
+    /// <see cref="IConstrainedEqualityComparer{T}"/>.
+    /// </summary>
+    /// <typeparam name="TValue">The type of the values in the dictionary. The key is assumed
+    /// to always be <see cref="String"/>.</typeparam>
+    internal interface IConstrainableDictionary<TValue> : IDictionary<string, TValue>
+    {
+        /// <summary>
+        /// Get the value with the specified key or null if it is not present.
+        /// The key used for lookup is the substring of <paramref name="keyString"/>
+        /// starting at <paramref name="startIndex"/> and ending at <paramref name="endIndex"/>
+        /// (e.g. if the key is just the first character in <paramref name="keyString"/>, then
+        /// the value for <paramref name="startIndex"/> should be 0 and the value for
+        /// <paramref name="endIndex"/> should also be 0.)
+        /// </summary>
+        /// <param name="keyString">A string that contains the key of the item to retrieve.</param>
+        /// <param name="startIndex">The start index of the substring of <paramref name="keyString"/> that contains the key.</param>
+        /// <param name="endIndex">The end index of the substring of <paramref name="keyString"/> that contains the key.</param>
+        /// <returns>If it's found, the item whose key matches the calculated substring. Null otherwise.</returns>
+        TValue? Get(string keyString, int startIndex, int endIndex);
+    }
+}
diff --git a/src/Build/Collections/IItemDictionary.cs b/src/Build/Collections/IItemDictionary.cs
new file mode 100644
index 00000000000..1555c1de814
--- /dev/null
+++ b/src/Build/Collections/IItemDictionary.cs
@@ -0,0 +1,134 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Collections
+{
+    internal interface IItemDictionary<T> : IEnumerable<T>, IItemProvider<T>
+        where T : class, IKeyed, IItem
+    {
+        /// <summary>
+        /// Number of items in total, for debugging purposes.
+        /// </summary>
+        int Count { get; }
+
+        /// <summary>
+        /// Get the item types that have at least one item in this collection.
+        /// </summary>
+        /// <remarks>
+        /// KeyCollection&lt;K&gt; is already a read only collection, so no protection
+        /// is necessary.
+        /// </remarks>
+        ICollection<string> ItemTypes { get; }
+
+        /// <summary>
+        /// Returns the item list for a particular item type,
+        /// creating and adding a new item list if necessary.
+        /// Does not throw if there are no items of this type.
+        /// This is a read-only list.
+        /// If the result is not empty it is a live list.
+        /// Use AddItem or RemoveItem to modify items in this project.
+        /// Using the return value from this in a multithreaded situation is unsafe.
+        /// </summary>
+        ICollection<T> this[string itemType] { get; }
+
+        /// <summary>
+        /// Empty the collection.
+        /// </summary>
+        void Clear();
+
+        /// <summary>
+        /// Returns an enumerable which copies the underlying data on read.
+        /// </summary>
+        IEnumerable<TResult> GetCopyOnReadEnumerable<TResult>(Func<T, TResult> selector);
+
+        /// <summary>
+        /// Enumerates item lists per each item type under the lock.
+        /// </summary>
+        /// <param name="itemTypeCallback">
+        /// A delegate that accepts the item type string and a list of items of that type.
+        /// Will be called for each item type in the list.
+        /// </param>
+        void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback);
+
+        /// <summary>
+        /// Whether the provided item is in this table or not.
+        /// </summary>
+        bool Contains(T projectItem);
+
+        /// <summary>
+        /// Add a new item to the collection, at the
+        /// end of the list of other items with its key.
+        /// </summary>
+        void Add(T projectItem);
+
+        /// <summary>
+        /// Adds each new item to the collection, at the
+        /// end of the list of other items with the same key.
+        /// </summary>
+        void AddRange(IEnumerable<T> projectItems);
+
+        /// <summary>
+        /// Removes an item, if it is in the collection.
+        /// Returns true if it was found, otherwise false.
+        /// </summary>
+        /// <remarks>
+        /// If a list is emptied, removes the list from the enclosing collection
+        /// so it can be garbage collected.
+        /// </remarks>        
+        bool Remove(T projectItem);
+
+        /// <summary>
+        /// Replaces an existing item with a new item.  This is necessary to preserve the original ordering semantics of Lookup.GetItems
+        /// when items with metadata modifications are being returned.  See Dev10 bug 480737.
+        /// If the item is not found, does nothing.
+        /// </summary>
+        /// <param name="existingItem">The item to be replaced.</param>
+        /// <param name="newItem">The replacement item.</param>
+        void Replace(T existingItem, T newItem);
+
+        /// <summary>
+        /// Add the set of items specified to this dictionary.
+        /// </summary>
+        /// <param name="other">An enumerator over the items to remove.</param>
+        void ImportItems(IEnumerable<T> other);
+
+        /// <summary>
+        /// Add the set of items specified, all sharing an item type, to this dictionary.
+        /// </summary>
+        /// <comment>
+        /// This is a little faster than ImportItems where all the items have the same item type.
+        /// </comment>
+        void ImportItemsOfType(string itemType, IEnumerable<T> items);
+
+        /// <summary>
+        /// Remove the set of items specified from this dictionary
+        /// </summary>
+        /// <param name="other">An enumerator over the items to remove.</param>
+        void RemoveItems(IEnumerable<T> other);
+
+        /// <summary>
+        /// Special method used for batching buckets.
+        /// Adds an explicit marker indicating there are no items for the specified item type.
+        /// In the general case, this is redundant, but batching buckets use this to indicate that they are
+        /// batching over the item type, but their bucket does not contain items of that type.
+        /// See <see cref="HasEmptyMarker">HasEmptyMarker</see>.
+        /// </summary>
+        void AddEmptyMarker(string itemType);
+
+        /// <summary>
+        /// Special method used for batching buckets.
+        /// Lookup can call this to see whether there was an explicit marker placed indicating that
+        /// there are no items of this type. See comment on <see cref="AddEmptyMarker">AddEmptyMarker</see>.
+        /// </summary>
+        bool HasEmptyMarker(string itemType);
+    }
+}
diff --git a/src/Build/Collections/ItemDictionary.cs b/src/Build/Collections/ItemDictionary.cs
index ee57e45788c..128ef852825 100644
--- a/src/Build/Collections/ItemDictionary.cs
+++ b/src/Build/Collections/ItemDictionary.cs
@@ -29,7 +29,7 @@ namespace Microsoft.Build.Collections
     /// </remarks>
     /// <typeparam name="T">Item class type to store</typeparam>
     [DebuggerDisplay("#Item types={ItemTypes.Count} #Items={Count}")]
-    internal sealed class ItemDictionary<T> : IEnumerable<T>, IItemProvider<T>
+    internal sealed class ItemDictionary<T> : IItemDictionary<T>
         where T : class, IKeyed, IItem
     {
         /// <summary>
@@ -50,7 +50,7 @@ internal sealed class ItemDictionary<T> : IEnumerable<T>, IItemProvider<T>
         /// <summary>
         /// Constructor for an empty collection.
         /// </summary>
-        internal ItemDictionary()
+        public ItemDictionary()
         {
             // Tracing.Record("new item dictionary");
             _itemLists = new Dictionary<string, LinkedList<T>>(MSBuildNameIgnoreCaseComparer.Default);
@@ -61,7 +61,7 @@ internal ItemDictionary()
         /// Constructor for an empty collection taking an initial capacity
         /// for the number of distinct item types
         /// </summary>
-        internal ItemDictionary(int initialItemTypesCapacity, int initialItemsCapacity = 0)
+        public ItemDictionary(int initialItemTypesCapacity, int initialItemsCapacity = 0)
         {
             // Tracing.Record("new item dictionary");
             _itemLists = new Dictionary<string, LinkedList<T>>(initialItemTypesCapacity, MSBuildNameIgnoreCaseComparer.Default);
@@ -71,7 +71,7 @@ internal ItemDictionary(int initialItemTypesCapacity, int initialItemsCapacity =
         /// <summary>
         /// Constructor for an collection holding items from a specified enumerable.
         /// </summary>
-        internal ItemDictionary(IEnumerable<T> items)
+        public ItemDictionary(IEnumerable<T> items)
         {
             // Tracing.Record("new item dictionary");
             _itemLists = new Dictionary<string, LinkedList<T>>(MSBuildNameIgnoreCaseComparer.Default);
@@ -82,7 +82,7 @@ internal ItemDictionary(IEnumerable<T> items)
         /// <summary>
         /// Number of items in total, for debugging purposes.
         /// </summary>
-        internal int Count => _nodes.Count;
+        public int Count => _nodes.Count;
 
         /// <summary>
         /// Get the item types that have at least one item in this collection
@@ -91,7 +91,7 @@ internal ItemDictionary(IEnumerable<T> items)
         /// KeyCollection&lt;K&gt; is already a read only collection, so no protection
         /// is necessary.
         /// </remarks>
-        internal ICollection<string> ItemTypes
+        public ICollection<string> ItemTypes
         {
             get
             {
@@ -111,7 +111,7 @@ internal ICollection<string> ItemTypes
         /// Use AddItem or RemoveItem to modify items in this project.
         /// Using the return value from this in a multithreaded situation is unsafe.
         /// </summary>
-        internal ICollection<T> this[string itemtype]
+        public ICollection<T> this[string itemtype]
         {
             get
             {
@@ -176,7 +176,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// A delegate that accepts the item type string and a list of items of that type.
         /// Will be called for each item type in the list.
         /// </param>
-        internal void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)
+        public void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)
         {
             lock (_itemLists)
             {
@@ -214,7 +214,7 @@ public ICollection<T> GetItems(string itemType)
         /// <summary>
         /// Whether the provided item is in this table or not.
         /// </summary>
-        internal bool Contains(T projectItem)
+        public bool Contains(T projectItem)
         {
             lock (_itemLists)
             {
@@ -226,18 +226,22 @@ internal bool Contains(T projectItem)
         /// Add a new item to the collection, at the
         /// end of the list of other items with its key.
         /// </summary>
-        internal void Add(T projectItem)
+        public void Add(T projectItem)
         {
             lock (_itemLists)
             {
-                if (!_itemLists.TryGetValue(projectItem.Key, out LinkedList<T> list))
+                AddProjectItem(projectItem);
+            }
+        }
+
+        public void AddRange(IEnumerable<T> projectItems)
+        {
+            lock (_itemLists)
+            {
+                foreach (var projectItem in projectItems)
                 {
-                    list = new LinkedList<T>();
-                    _itemLists[projectItem.Key] = list;
+                    AddProjectItem(projectItem);
                 }
-
-                LinkedListNode<T> node = list.AddLast(projectItem);
-                _nodes.Add(projectItem, node);
             }
         }
 
@@ -249,7 +253,7 @@ internal void Add(T projectItem)
         /// If a list is emptied, removes the list from the enclosing collection
         /// so it can be garbage collected.
         /// </remarks>
-        internal bool Remove(T projectItem)
+        public bool Remove(T projectItem)
         {
             lock (_itemLists)
             {
@@ -279,7 +283,7 @@ internal bool Remove(T projectItem)
         /// </summary>
         /// <param name="existingItem">The item to be replaced.</param>
         /// <param name="newItem">The replacement item.</param>
-        internal void Replace(T existingItem, T newItem)
+        public void Replace(T existingItem, T newItem)
         {
             ErrorUtilities.VerifyThrow(existingItem.Key == newItem.Key, "Cannot replace an item {0} with an item {1} with a different name.", existingItem.Key, newItem.Key);
             lock (_itemLists)
@@ -297,12 +301,9 @@ internal void Replace(T existingItem, T newItem)
         /// Add the set of items specified to this dictionary
         /// </summary>
         /// <param name="other">An enumerator over the items to remove.</param>
-        internal void ImportItems(IEnumerable<T> other)
+        public void ImportItems(IEnumerable<T> other)
         {
-            foreach (T item in other)
-            {
-                Add(item);
-            }
+            AddRange(other);
         }
 
         /// <summary>
@@ -311,7 +312,7 @@ internal void ImportItems(IEnumerable<T> other)
         /// <comment>
         /// This is a little faster than ImportItems where all the items have the same item type.
         /// </comment>
-        internal void ImportItemsOfType(string itemType, IEnumerable<T> items)
+        public void ImportItemsOfType(string itemType, IEnumerable<T> items)
         {
             lock (_itemLists)
             {
@@ -337,7 +338,7 @@ internal void ImportItemsOfType(string itemType, IEnumerable<T> items)
         /// Remove the set of items specified from this dictionary
         /// </summary>
         /// <param name="other">An enumerator over the items to remove.</param>
-        internal void RemoveItems(IEnumerable<T> other)
+        public void RemoveItems(IEnumerable<T> other)
         {
             foreach (T item in other)
             {
@@ -352,7 +353,7 @@ internal void RemoveItems(IEnumerable<T> other)
         /// batching over the item type, but their bucket does not contain items of that type.
         /// See <see cref="HasEmptyMarker">HasEmptyMarker</see>.
         /// </summary>
-        internal void AddEmptyMarker(string itemType)
+        public void AddEmptyMarker(string itemType)
         {
             lock (_itemLists)
             {
@@ -366,7 +367,7 @@ internal void AddEmptyMarker(string itemType)
         /// Lookup can call this to see whether there was an explicit marker placed indicating that
         /// there are no items of this type. See comment on <see cref="AddEmptyMarker">AddEmptyMarker</see>.
         /// </summary>
-        internal bool HasEmptyMarker(string itemType)
+        public bool HasEmptyMarker(string itemType)
         {
             lock (_itemLists)
             {
@@ -379,6 +380,18 @@ internal bool HasEmptyMarker(string itemType)
             }
         }
 
+        private void AddProjectItem(T projectItem)
+        {
+            if (!_itemLists.TryGetValue(projectItem.Key, out LinkedList<T> list))
+            {
+                list = new LinkedList<T>();
+                _itemLists[projectItem.Key] = list;
+            }
+
+            LinkedListNode<T> node = list.AddLast(projectItem);
+            _nodes.Add(projectItem, node);
+        }
+
         /// <summary>
         /// Custom enumerator that allows enumeration over all the items in the collection
         /// as though they were in a single list.
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index 7672333cd2b..96884a1914d 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -35,14 +35,14 @@ namespace Microsoft.Build.Collections
     /// </remarks>
     /// <typeparam name="T">Property or Metadata class type to store</typeparam>
     [DebuggerDisplay("#Entries={Count}")]
-    internal sealed class PropertyDictionary<T> : IEnumerable<T>, IEquatable<PropertyDictionary<T>>, IPropertyProvider<T>, IDictionary<string, T>
+    internal sealed class PropertyDictionary<T> : IEnumerable<T>, IEquatable<PropertyDictionary<T>>, IPropertyProvider<T>, IDictionary<string, T>, IConstrainableDictionary<T>
         where T : class, IKeyed, IValued, IEquatable<T>
     {
         /// <summary>
         /// Backing dictionary
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
-        private readonly RetrievableEntryHashSet<T> _properties;
+        private readonly IRetrievableEntryHashSet<T> _properties;
 
         /// <summary>
         /// Creates empty dictionary
@@ -92,6 +92,15 @@ internal PropertyDictionary(int capacity, IEnumerable<T> elements)
             }
         }
 
+        /// <summary>
+        /// Initializes a new instance of the <see cref="PropertyDictionary{T}"/> class.
+        /// </summary>
+        /// <param name="propertiesHashSet">The collection of properties to use.</param>
+        internal PropertyDictionary(IRetrievableEntryHashSet<T> propertiesHashSet)
+        {
+            _properties = propertiesHashSet;
+        }
+
         /// <summary>
         /// Accessor for the list of property names
         /// </summary>
@@ -132,7 +141,7 @@ int ICollection<KeyValuePair<string, T>>.Count
             {
                 lock (_properties)
                 {
-                    return _properties.Count;
+                    return ((ICollection<T>)_properties).Count;
                 }
             }
         }
@@ -152,7 +161,7 @@ internal int Count
             {
                 lock (_properties)
                 {
-                    return _properties.Count;
+                    return ((ICollection<T>)_properties).Count;
                 }
             }
         }
@@ -228,7 +237,7 @@ public void Clear()
         {
             lock (_properties)
             {
-                _properties.Clear();
+                ((ICollection<T>)_properties).Clear();
             }
         }
 
@@ -318,6 +327,12 @@ public T GetProperty(string name, int startIndex, int endIndex)
             }
         }
 
+        /// <inheritdoc />
+        public T Get(string keyString, int startIndex, int endIndex)
+        {
+            return GetProperty(keyString, startIndex, endIndex);
+        }
+
         #region IDictionary<string,T> Members
 
         /// <summary>
@@ -424,13 +439,7 @@ bool ICollection<KeyValuePair<string, T>>.Remove(KeyValuePair<string, T> item)
         /// </summary>
         IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnumerator()
         {
-            lock (_properties)
-            {
-                foreach (var entry in _properties)
-                {
-                    yield return new KeyValuePair<string, T>(entry.Key, entry);
-                }
-            }
+            return ((IEnumerable<KeyValuePair<string, T>>)_properties).GetEnumerator();
         }
 
         #endregion
@@ -500,7 +509,7 @@ internal Dictionary<string, string> ToDictionary()
         {
             lock (_properties)
             {
-                var dictionary = new Dictionary<string, string>(_properties.Count, MSBuildNameIgnoreCaseComparer.Default);
+                var dictionary = new Dictionary<string, string>(((ICollection<T>)_properties).Count, MSBuildNameIgnoreCaseComparer.Default);
 
                 foreach (T property in this)
                 {
@@ -515,7 +524,7 @@ internal void Enumerate(Action<string, string> keyValueCallback)
         {
             lock (_properties)
             {
-                foreach (var kvp in _properties)
+                foreach (var kvp in (ICollection<T>)_properties)
                 {
                     keyValueCallback(kvp.Key, EscapingUtilities.UnescapeAll(kvp.EscapedValue));
                 }
@@ -527,7 +536,7 @@ internal IEnumerable<TResult> Filter<TResult>(Func<T, bool> filter, Func<T, TRes
             List<TResult> result = new();
             lock (_properties)
             {
-                foreach (T property in _properties)
+                foreach (T property in (ICollection<T>)_properties)
                 {
                     if (filter(property))
                     {
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index 8824d26e051..e6160cec90f 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -82,9 +82,7 @@ namespace Microsoft.Build.Collections
 #if FEATURE_SECURITY_PERMISSIONS
     [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
 #endif
-    internal class RetrievableEntryHashSet<T> : ICollection<T>,
-        ISerializable, IDeserializationCallback,
-        IDictionary<string, T>
+    internal class RetrievableEntryHashSet<T> : IRetrievableEntryHashSet<T>
         where T : class, IKeyed
     {
         // store lower 31 bits of hash code
diff --git a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
new file mode 100644
index 00000000000..3100e7914a8
--- /dev/null
+++ b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
@@ -0,0 +1,73 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using System.Runtime.Serialization;
+
+#nullable disable
+
+namespace Microsoft.Build.Collections
+{
+    internal interface IRetrievableEntryHashSet<T> :
+        ICollection<T>,
+        ISerializable,
+        IDeserializationCallback,
+        IDictionary<string, T>
+        where T : class, IKeyed
+    {
+        /// <summary>
+        /// Gets the item with the given name.
+        /// </summary>
+        /// <param name="key">key to check for containment.</param>
+        /// <returns>The item (if contained).</returns>
+        /// <exception cref="KeyNotFoundException">Thrown if no item with the given name is present in the collection.</exception>
+        T Get(string key);
+
+        /// <summary>
+        /// Gets the item if any with the given name.
+        /// </summary>
+        /// <param name="key">key to check for containment.</param>
+        /// <param name="index">The position of the substring within <paramref name="key"/>.</param>
+        /// <param name="length">The maximum number of characters in the <paramref name="key"/> to lookup.</param>
+        /// <returns>The item (if contained).</returns>
+        /// <exception cref="KeyNotFoundException">Thrown if no item with the given name is present in the collection.</exception>
+        T Get(string key, int index, int length);
+
+        /// <summary>
+        /// Copies the contents of this HashSet into the provided array.
+        /// </summary>
+        /// <param name="array">The array into which the contents of this HashSet will be copied.</param>
+        void CopyTo(T[] array);
+
+        /// <summary>
+        /// Copies the contents of this HashSet into the provided array.
+        /// </summary>
+        /// <param name="array">The array into which the contents of this HashSet will be copied.</param>
+        /// <param name="arrayIndex">The index within <paramref name="array"/> where the first item will be placed.</param>
+        /// <param name="count">The number of items from HashSet to copy into <paramref name="array"/>.</param>
+        void CopyTo(T[] array, int arrayIndex, int count);
+
+        /// <summary>
+        /// Take the union of this HashSet with other. Modifies this set.
+        /// 
+        /// Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding 
+        /// multiple resizes ended up not being useful in practice; quickly gets to the 
+        /// point where it's a wasteful check.
+        /// </summary>
+        /// <param name="other">enumerable with items to add</param>
+        void UnionWith(IEnumerable<T> other);
+
+        /// <summary>
+        /// Sets the capacity of this list to the size of the list (rounded up to nearest prime),
+        /// unless count is 0, in which case we release references.
+        /// 
+        /// This method can be used to minimize a list's memory overhead once it is known that no
+        /// new elements will be added to the list. To completely clear a list and release all 
+        /// memory referenced by the list, execute the following statements:
+        /// 
+        /// list.Clear();
+        /// list.TrimExcess();
+        /// </summary>
+        void TrimExcess();
+    }
+}
diff --git a/src/Build/CompatibilitySuppressions.xml b/src/Build/CompatibilitySuppressions.xml
new file mode 100644
index 00000000000..8497df99fb3
--- /dev/null
+++ b/src/Build/CompatibilitySuppressions.xml
@@ -0,0 +1,263 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
+<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Logging.IBuildEventStringsReader</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Logging.IBuildEventStringsReader</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Logging.IBuildEventStringsReader</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Logging.IBuildEventStringsReader</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.add_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.remove_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.add_StringEncountered(System.Action)</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.remove_StringEncountered(System.Action)</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.add_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.remove_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.add_StringEncountered(System.Action)</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.remove_StringEncountered(System.Action)</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.add_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.remove_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.add_StringEncountered(System.Action)</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.remove_StringEncountered(System.Action)</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.add_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.remove_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.add_StringEncountered(System.Action)</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.remove_StringEncountered(System.Action)</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.ArchiveFileEncountered</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.RecoverableReadError</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.StringReadDone</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.ArchiveFileEncountered</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.RecoverableReadError</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.StringReadDone</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.ArchiveFileEncountered</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.RecoverableReadError</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.StringReadDone</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0008</DiagnosticId>
+    <Target>T:Microsoft.Build.Logging.BuildEventArgsReader</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0008</DiagnosticId>
+    <Target>T:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0008</DiagnosticId>
+    <Target>T:Microsoft.Build.Logging.BuildEventArgsReader</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0008</DiagnosticId>
+    <Target>T:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0008</DiagnosticId>
+    <Target>T:Microsoft.Build.Logging.BuildEventArgsReader</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0008</DiagnosticId>
+    <Target>T:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0008</DiagnosticId>
+    <Target>T:Microsoft.Build.Logging.BuildEventArgsReader</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0008</DiagnosticId>
+    <Target>T:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+</Suppressions>
\ No newline at end of file
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index d785f9f8c50..cd5b9de17d9 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -4118,7 +4118,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// Items in this project, ordered within groups of item types.
             /// Protected by an upcast to IEnumerable.
             /// </summary>
-            public ItemDictionary<ProjectItem> Items { get; private set; }
+            public IItemDictionary<ProjectItem> Items { get; private set; }
 
             public List<ProjectItemElement> EvaluatedItemElements { get; private set; }
 
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 924b3e25db7..11dd0a1143d 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -11,6 +11,7 @@
 using System.Threading;
 using System.Xml;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
@@ -1732,6 +1733,7 @@ private void ShutDownLoggingService()
             {
                 try
                 {
+                    (LoggingService as LoggingService)?.WaitForLoggingToProcessEvents();
                     ((IBuildComponent)LoggingService).ShutdownComponent();
                 }
                 catch (LoggerException)
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index d6074d17f46..4d5b2ea8e98 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -190,7 +190,7 @@ IEnumerable<D> ItemDefinitionsEnumerable
         /// covariance problems. (A dictionary of Key, Value cannot be upcast
         /// to a Dictionary of Key, IValue).
         /// </summary>
-        ItemDictionary<I> Items
+        IItemDictionary<I> Items
         {
             get;
         }
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 3fff5c28e65..0f721647326 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -35,7 +35,7 @@ internal static class IntrinsicFunctions
 
         private static readonly Lazy<Regex> RegistrySdkRegex = new Lazy<Regex>(() => new Regex(@"^HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Microsoft SDKs\\Windows\\v(\d+\.\d+)$", RegexOptions.IgnoreCase));
 
-        private static readonly Lazy<NuGetFrameworkWrapper> NuGetFramework = new Lazy<NuGetFrameworkWrapper>(() => new NuGetFrameworkWrapper());
+        private static readonly Lazy<NuGetFrameworkWrapper> NuGetFramework = new Lazy<NuGetFrameworkWrapper>(() => NuGetFrameworkWrapper.CreateInstance());
 
         /// <summary>
         /// Add two doubles
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 74e43ce6c93..79cd844c167 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -30,7 +30,7 @@ public EvaluatorData(IEvaluatorData<P, I, M, D> wrappedData, IReadOnlyDictionary
                 _itemsByType = itemsByType;
             }
 
-            public ItemDictionary<I> Items
+            public IItemDictionary<I> Items
             {
                 get
                 {
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 7a4d6da9521..51117c2d7c1 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -134,7 +134,7 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
         public bool CanEvaluateElementsWithFalseConditions => _wrapped.CanEvaluateElementsWithFalseConditions;
         public PropertyDictionary<P> Properties => _wrapped.Properties;
         public IEnumerable<D> ItemDefinitionsEnumerable => _wrapped.ItemDefinitionsEnumerable;
-        public ItemDictionary<I> Items => _wrapped.Items;
+        public IItemDictionary<I> Items => _wrapped.Items;
         public List<ProjectItemElement> EvaluatedItemElements => _wrapped.EvaluatedItemElements;
         public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => _wrapped.EnvironmentVariablePropertiesDictionary;
         public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext) => _wrapped.InitializeForEvaluation(toolsetProvider, evaluationContext);
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index b4450000e4b..e343a98c4cc 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -306,7 +306,8 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
             Dictionary<string, ImmutableDictionary<string, string>> globalPropertiesForProjectConfiguration = new(StringComparer.OrdinalIgnoreCase);
 
             IReadOnlyList<ProjectInSolution> projectsInSolution = solution.ProjectsInOrder;
-            var newEntryPoints = new List<ProjectGraphEntryPoint>(projectsInSolution.Count);
+            List<ProjectGraphEntryPoint> newEntryPoints = new(projectsInSolution.Count);
+            Dictionary<string, IReadOnlyCollection<string>> solutionDependencies = new();
 
             foreach (ProjectInSolution project in projectsInSolution)
             {
@@ -332,11 +333,43 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
                 }
 
                 newEntryPoints.Add(new ProjectGraphEntryPoint(project.AbsolutePath, projectGlobalProperties));
+
+                if (project.Dependencies.Count > 0)
+                {
+                    // code snippet cloned from SolutionProjectGenerator.GetSolutionConfiguration
+
+                    List<string> solutionDependenciesForProject = new(project.Dependencies.Count);
+                    foreach (string dependencyProjectGuid in project.Dependencies)
+                    {
+                        if (!solution.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out ProjectInSolution dependencyProject))
+                        {
+                            ProjectFileErrorUtilities.ThrowInvalidProjectFile(
+                                "SubCategoryForSolutionParsingErrors",
+                                new BuildEventFileInfo(solution.FullPath),
+                                "SolutionParseProjectDepNotFoundError",
+                                project.ProjectGuid,
+                                dependencyProjectGuid);
+                        }
+
+                        // Add it to the list of dependencies, but only if it should build in this solution configuration
+                        // (If a project is not selected for build in the solution configuration, it won't build even if it's depended on by something that IS selected for build)
+                        // .. and only if it's known to be MSBuild format, as projects can't use the information otherwise
+                        if (dependencyProject.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat)
+                        {
+                            solutionDependenciesForProject.Add(dependencyProject.AbsolutePath);
+                        }
+                    }
+
+                    if (solutionDependenciesForProject.Count > 0)
+                    {
+                        solutionDependencies.Add(project.AbsolutePath, solutionDependenciesForProject);
+                    }
+                }
             }
 
             newEntryPoints.TrimExcess();
 
-            return (newEntryPoints, GetSolutionDependencies(solution));
+            return (newEntryPoints, solutionDependencies);
 
             SolutionConfigurationInSolution SelectSolutionConfiguration(SolutionFile solutionFile, IDictionary<string, string> globalProperties)
             {
@@ -367,43 +400,6 @@ ProjectConfigurationInSolution SelectProjectConfiguration(
                 var partiallyMarchedConfig = projectConfigs.FirstOrDefault(pc => pc.Value.ConfigurationName.Equals(solutionConfig.ConfigurationName, StringComparison.OrdinalIgnoreCase)).Value;
                 return partiallyMarchedConfig ?? projectConfigs.First().Value;
             }
-
-            IReadOnlyDictionary<string, IReadOnlyCollection<string>> GetSolutionDependencies(SolutionFile solutionFile)
-            {
-                var solutionDependencies = new Dictionary<string, IReadOnlyCollection<string>>();
-
-                foreach (var projectWithDependencies in solutionFile.ProjectsInOrder.Where(p => p.Dependencies.Count != 0))
-                {
-                    solutionDependencies[projectWithDependencies.AbsolutePath] = projectWithDependencies.Dependencies.Select(
-                        dependencyGuid =>
-                        {
-                            // code snippet cloned from SolutionProjectGenerator.AddPropertyGroupForSolutionConfiguration
-
-                            if (!solutionFile.ProjectsByGuid.TryGetValue(dependencyGuid, out var dependencyProject))
-                            {
-                                // If it's not itself part of the solution, that's an invalid solution
-                                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
-                                    dependencyProject != null,
-                                    "SubCategoryForSolutionParsingErrors",
-                                    new BuildEventFileInfo(solutionFile.FullPath),
-                                    "SolutionParseProjectDepNotFoundError",
-                                    projectWithDependencies.ProjectGuid,
-                                    dependencyGuid);
-                            }
-
-                            // Add it to the list of dependencies, but only if it should build in this solution configuration
-                            // (If a project is not selected for build in the solution configuration, it won't build even if it's depended on by something that IS selected for build)
-                            // .. and only if it's known to be MSBuild format, as projects can't use the information otherwise
-                            return dependencyProject?.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat
-                                ? dependencyProject.AbsolutePath
-                                : null;
-                        })
-                        .Where(p => p != null)
-                        .ToArray();
-                }
-
-                return solutionDependencies;
-            }
         }
 
         private static List<ConfigurationMetadata> AddGraphBuildPropertyToEntryPoints(IEnumerable<ProjectGraphEntryPoint> entryPoints)
diff --git a/src/Build/Instance/IImmutableInstanceProvider.cs b/src/Build/Instance/IImmutableInstanceProvider.cs
new file mode 100644
index 00000000000..a862a12cf13
--- /dev/null
+++ b/src/Build/Instance/IImmutableInstanceProvider.cs
@@ -0,0 +1,14 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Execution
+{
+    /// <summary>
+    /// Represents an object that is immutable and has an Instance, e.g. a <see cref="ProjectPropertyInstance"/>.
+    /// </summary>
+    /// <typeparam name="T">The Instance type.</typeparam>
+    internal interface IImmutableInstanceProvider<T>
+    {
+        T ImmutableInstance { get; set; }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
new file mode 100644
index 00000000000..ae164108704
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
@@ -0,0 +1,250 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Data;
+using System.Runtime.Serialization;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Instance
+{
+    /// <summary>
+    /// A specialized collection used when element data originates in an immutable Project.
+    /// </summary>
+    internal sealed class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>
+        where T : class, IKeyed
+    {
+        private readonly IDictionary<string, TCached> _projectElements;
+        private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;
+        private readonly ValuesCollection _values;
+
+        public ImmutableElementCollectionConverter(
+            IDictionary<string, TCached> projectElements,
+            IDictionary<(string, int, int), TCached> constrainedProjectElements)
+        {
+            _projectElements = projectElements;
+            _constrainedProjectElements = constrainedProjectElements;
+            _values = new ValuesCollection(_projectElements, _constrainedProjectElements);
+        }
+
+        public T this[string key]
+        {
+            get => Get(key);
+            set => throw new NotSupportedException();
+        }
+
+        public int Count => _values.Count;
+
+        public bool IsReadOnly => true;
+
+        public ICollection<string> Keys => _projectElements.Keys;
+
+        public ICollection<T> Values => _values;
+
+        public void Add(T item) => throw new NotSupportedException();
+
+        public void Add(string key, T value) => throw new NotSupportedException();
+
+        public void Add(KeyValuePair<string, T> item) => throw new NotSupportedException();
+
+        public void Clear() => throw new NotSupportedException();
+
+        public bool Contains(T item) => _projectElements.ContainsKey(item.Key);
+
+        // Note: This implementation of Contains(KeyValuePair<string, T> only checks whether the collection contains
+        // an item with the same key. This doesn't match the general behavior of collection comparison, where the
+        // KeyValuePair's key *and* value are compared. This is done intentionally in order to match the behavior of
+        // RetrievableEntryHashSet, which only checks for the existence of an item with the same key (ignoring
+        // whether the values match).
+        public bool Contains(KeyValuePair<string, T> item) => _projectElements.ContainsKey(item.Key);
+
+        public bool ContainsKey(string key) => _projectElements.ContainsKey(key);
+
+        public void CopyTo(T[] array) => _values.CopyTo(array, arrayIndex: 0);
+
+        public void CopyTo(T[] array, int arrayIndex, int count) => _values.CopyTo(array, arrayIndex, count);
+
+        public void CopyTo(T[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);
+
+        public void CopyTo(KeyValuePair<string, T>[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);
+
+        public T Get(string key) => _values.Get(key);
+
+        public T Get(string key, int index, int length) => _values.Get(key, index, length);
+
+        public IEnumerator<T> GetEnumerator() => _values.GetEnumerator();
+
+        public void GetObjectData(SerializationInfo info, StreamingContext context) => throw new NotSupportedException();
+
+        public void OnDeserialization(object sender) => throw new NotSupportedException();
+
+        public bool Remove(T item) => throw new NotSupportedException();
+
+        public bool Remove(string key) => throw new NotSupportedException();
+
+        public bool Remove(KeyValuePair<string, T> item) => throw new NotSupportedException();
+
+        public void TrimExcess()
+        {
+        }
+
+        public bool TryGetValue(string key, out T value) => _values.TryGetValue(key, out value);
+
+        public void UnionWith(IEnumerable<T> other) => throw new NotSupportedException();
+
+        IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnumerator() => _values.GetKvpEnumerator();
+
+        IEnumerator IEnumerable.GetEnumerator() => _values.GetEnumerator();
+
+        /// <summary>
+        /// Wraps the Project's values.
+        /// </summary>
+        private sealed class ValuesCollection : ICollection<T>
+        {
+            private readonly IDictionary<string, TCached> _projectElements;
+            private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;
+
+            public ValuesCollection(
+                IDictionary<string, TCached> projectElements,
+                IDictionary<(string, int, int), TCached> constrainedProjectElements)
+            {
+                _projectElements = projectElements;
+                _constrainedProjectElements = constrainedProjectElements;
+            }
+
+            public int Count => _projectElements.Count;
+
+            public bool IsReadOnly => true;
+
+            public void Add(T item) => throw new NotSupportedException();
+
+            public void Clear() => throw new NotSupportedException();
+
+            public bool Contains(T item)
+            {
+                if (item == null)
+                {
+                    throw new ArgumentNullException(nameof(item));
+                }
+
+                return _projectElements.ContainsKey(item.Key);
+            }
+
+            public void CopyTo(T[] array, int arrayIndex)
+            {
+                CopyTo(array, arrayIndex, _projectElements.Count);
+            }
+
+            public void CopyTo(T[] array, int arrayIndex, int count)
+            {
+                if (count < 0)
+                {
+                    throw new ArgumentOutOfRangeException(nameof(count));
+                }
+
+                ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), count);
+
+                int index = arrayIndex;
+                int endIndex = arrayIndex + count;
+                foreach (var item in _projectElements.Values)
+                {
+                    array[index] = GetElementInstance(item);
+                    ++index;
+                    if (index >= endIndex)
+                    {
+                        break;
+                    }
+                }
+            }
+
+            public void CopyTo(KeyValuePair<string, T>[] array, int arrayIndex)
+            {
+                ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _projectElements.Count);
+
+                int index = arrayIndex;
+                foreach (var item in _projectElements.Values)
+                {
+                    var itemInstance = GetElementInstance(item);
+                    array[index] = new KeyValuePair<string, T>(itemInstance.Key, itemInstance);
+                    ++index;
+                }
+            }
+
+            public IEnumerator<T> GetEnumerator()
+            {
+                foreach (var item in _projectElements.Values)
+                {
+                    yield return GetElementInstance(item);
+                }
+            }
+
+            public IEnumerator<KeyValuePair<string, T>> GetKvpEnumerator()
+            {
+                foreach (var kvp in _projectElements)
+                {
+                    T instance = GetElementInstance(kvp.Value);
+                    yield return new KeyValuePair<string, T>(kvp.Key, instance);
+                }
+            }
+
+            public bool Remove(T item) => throw new NotSupportedException();
+
+            IEnumerator IEnumerable.GetEnumerator()
+            {
+                foreach (var item in _projectElements.Values)
+                {
+                    yield return GetElementInstance(item);
+                }
+            }
+
+            public T Get(string key)
+            {
+                if (_projectElements.TryGetValue(key, out TCached element))
+                {
+                    return GetElementInstance(element);
+                }
+
+                return null;
+            }
+
+            public T Get(string keyString, int startIndex, int length)
+            {
+                if (_constrainedProjectElements.TryGetValue((keyString, startIndex, length), out TCached element))
+                {
+                    return GetElementInstance(element);
+                }
+
+                return null;
+            }
+
+            public bool TryGetValue(string key, out T value)
+            {
+                value = null;
+                if (!_projectElements.TryGetValue(key, out TCached element))
+                {
+                    return false;
+                }
+
+                value = GetElementInstance(element);
+                return value != null;
+            }
+
+            private T GetElementInstance(TCached element)
+            {
+                if (element is IImmutableInstanceProvider<T> instanceProvider)
+                {
+                    return instanceProvider.ImmutableInstance;
+                }
+
+                return null;
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
new file mode 100644
index 00000000000..74919a57b97
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
@@ -0,0 +1,221 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Instance
+{
+    /// <summary>
+    /// A specialized collection used when item data originates in an immutable Project.
+    /// </summary>
+    internal sealed class ImmutableItemDictionary<TCached, T> : IItemDictionary<T>
+        where T : class, IKeyed, IItem
+    {
+        private readonly IDictionary<string, ICollection<TCached>> _itemsByType;
+        private readonly ICollection<T> _allItems;
+
+        public ImmutableItemDictionary(IDictionary<string, ICollection<TCached>> itemsByType, ICollection<TCached> allItems)
+        {
+            _itemsByType = itemsByType ?? throw new ArgumentNullException(nameof(itemsByType));
+
+            if (allItems == null)
+            {
+                throw new ArgumentNullException(nameof(allItems));
+            }
+
+            var convertedItems = new HashSet<T>(allItems.Count);
+            foreach (var item in allItems)
+            {
+                T? instance = GetInstance(item);
+                if (instance != null)
+                {
+                    convertedItems.Add(instance);
+                }
+            }
+            _allItems = new ReadOnlyCollection<T>(convertedItems);
+        }
+
+        /// <inheritdoc />
+        public ICollection<T> this[string itemType]
+        {
+            get
+            {
+                if (!_itemsByType.TryGetValue(itemType, out ICollection<TCached>? list))
+                {
+                    return Array.Empty<T>();
+                }
+
+                return new ListConverter(itemType, _allItems, list);
+            }
+        }
+
+        /// <inheritdoc />
+        public int Count => _allItems.Count;
+
+        /// <inheritdoc />
+        public ICollection<string> ItemTypes => _itemsByType.Keys;
+
+        /// <inheritdoc />
+        public void Add(T projectItem) => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public void AddEmptyMarker(string itemType) => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public void AddRange(IEnumerable<T> projectItems) => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public void Clear() => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public bool Contains(T projectItem) => _allItems.Contains(projectItem);
+
+        /// <inheritdoc />
+        public void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)
+        {
+            foreach (var kvp in _itemsByType)
+            {
+                if (kvp.Value == null || kvp.Value.Count == 0)
+                {
+                    // skip empty markers
+                    continue;
+                }
+
+                itemTypeCallback(kvp.Key, new ListConverter(kvp.Key, _allItems, kvp.Value));
+            }
+        }
+
+        /// <inheritdoc />
+        public IEnumerable<TResult> GetCopyOnReadEnumerable<TResult>(Func<T, TResult> selector)
+        {
+            foreach (var item in _allItems)
+            {
+                yield return selector(item);
+            }
+        }
+
+        /// <inheritdoc />
+        public IEnumerator<T> GetEnumerator() => _allItems.GetEnumerator();
+
+        /// <inheritdoc />
+        IEnumerator IEnumerable.GetEnumerator() => _allItems.GetEnumerator();
+
+        /// <inheritdoc />
+        public ICollection<T> GetItems(string itemType)
+        {
+            if (_itemsByType.TryGetValue(itemType, out ICollection<TCached>? items))
+            {
+                return new ListConverter(itemType, _allItems, items);
+            }
+
+            return Array.Empty<T>();
+        }
+
+        /// <inheritdoc />
+        public bool HasEmptyMarker(string itemType) => _itemsByType.Values.Any(list => list.Count == 0);
+
+        /// <inheritdoc />
+        public void ImportItems(IEnumerable<T> other) => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public void ImportItemsOfType(string itemType, IEnumerable<T> items) => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public bool Remove(T projectItem) => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public void RemoveItems(IEnumerable<T> other) => throw new NotSupportedException();
+
+        /// <inheritdoc />
+        public void Replace(T existingItem, T newItem) => throw new NotSupportedException();
+
+        private static T? GetInstance(TCached item)
+        {
+            if (item is IImmutableInstanceProvider<T> instanceProvider)
+            {
+                return instanceProvider.ImmutableInstance;
+            }
+
+            return null;
+        }
+
+        private sealed class ListConverter : ICollection<T>
+        {
+            private readonly string _itemType;
+            private readonly ICollection<T> _allItems;
+            private readonly ICollection<TCached> _list;
+
+            public ListConverter(string itemType, ICollection<T> allItems, ICollection<TCached> list)
+            {
+                _itemType = itemType;
+                _allItems = allItems;
+                _list = list;
+            }
+
+            public int Count => _list.Count;
+
+            public bool IsReadOnly => true;
+
+            public void Add(T item) => throw new NotSupportedException();
+
+            public void Clear() => throw new NotSupportedException();
+
+            public bool Remove(T item) => throw new NotSupportedException();
+
+            public bool Contains(T item)
+            {
+                return MSBuildNameIgnoreCaseComparer.Default.Equals(item.Key, _itemType) &&
+                       _allItems.Contains(item);
+            }
+
+            public void CopyTo(T[] array, int arrayIndex)
+            {
+                ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _list.Count);
+
+                int currentIndex = arrayIndex;
+                foreach (var item in _list)
+                {
+                    T? instance = GetInstance(item);
+                    if (instance != null)
+                    {
+                        array[currentIndex] = instance;
+                        ++currentIndex;
+                    }
+                }
+            }
+
+            public IEnumerator<T> GetEnumerator()
+            {
+                foreach (var item in _list)
+                {
+                    T? instance = GetInstance(item);
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+
+            IEnumerator IEnumerable.GetEnumerator()
+            {
+                foreach (var item in _list)
+                {
+                    T? instance = GetInstance(item);
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 92b2cf72307..fe63676c1d2 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -21,6 +21,7 @@
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Instance;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -34,6 +35,7 @@
 namespace Microsoft.Build.Execution
 {
     using Utilities = Microsoft.Build.Internal.Utilities;
+
     /// <summary>
     /// Enum for controlling project instance creation
     /// </summary>
@@ -124,7 +126,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         /// <summary>
         /// Items in the project. This is a dictionary of ordered lists of a single type of items keyed by item type.
         /// </summary>
-        private ItemDictionary<ProjectItemInstance> _items;
+        private IItemDictionary<ProjectItemInstance> _items;
 
         /// <summary>
         /// Items organized by evaluatedInclude value
@@ -151,7 +153,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         /// <summary>
         /// The item definitions from the parent Project.
         /// </summary>
-        private RetrievableEntryHashSet<ProjectItemDefinitionInstance> _itemDefinitions;
+        private IRetrievableEntryHashSet<ProjectItemDefinitionInstance> _itemDefinitions;
 
         /// <summary>
         /// The HostServices to use during a build.
@@ -388,6 +390,82 @@ public ProjectInstance(Project project, ProjectInstanceSettings settings)
             _isImmutable = immutable;
         }
 
+        /// <summary>
+        /// Creates a ProjectInstance from an immutable <see cref="Project"/>.
+        /// The resulting <see cref="ProjectInstance"/> object wraps the <see cref="Project"/>
+        /// object. Unlike the ProjectInstance(Project project, ProjectInstanceSettings settings)
+        /// constructor, the properties and items are not cloned.
+        /// </summary>
+        /// <param name="linkedProject">The immutable <see cref="Project"/>.</param>
+        /// <param name="fastItemLookupNeeded">Whether the fast item lookup cache is required.</param>
+        private ProjectInstance(Project linkedProject, bool fastItemLookupNeeded)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(linkedProject, nameof(linkedProject));
+
+            var projectPath = linkedProject.FullPath;
+            _directory = Path.GetDirectoryName(projectPath);
+            _projectFileLocation = ElementLocation.Create(projectPath);
+            _hostServices = linkedProject.ProjectCollection.HostServices;
+            _isImmutable = true;
+
+            EvaluationId = linkedProject.EvaluationCounter;
+
+            // ProjectProperties
+            InitializeImmutableProjectPropertyInstances(linkedProject.Properties);
+            var projectPropertiesConverter = GetImmutableElementCollectionConverter<ProjectProperty, ProjectPropertyInstance>(linkedProject.Properties);
+            _properties = new PropertyDictionary<ProjectPropertyInstance>(projectPropertiesConverter);
+
+            // ProjectItemDefinitions
+            InitializeImmutableProjectItemDefinitionInstances(linkedProject.ItemDefinitions);
+            _itemDefinitions = GetImmutableElementCollectionConverter<ProjectItemDefinition, ProjectItemDefinitionInstance>(linkedProject.ItemDefinitions);
+
+            // ProjectItems
+            InitializeImmutableProjectItemInstances(linkedProject.Items);
+            var itemsByType = linkedProject.Items as IDictionary<string, ICollection<ProjectItem>>;
+            _items = new ImmutableItemDictionary<ProjectItem, ProjectItemInstance>(itemsByType, linkedProject.Items);
+
+            // ItemsByEvaluatedInclude
+            if (fastItemLookupNeeded)
+            {
+                _itemsByEvaluatedInclude = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
+                foreach (var item in linkedProject.Items)
+                {
+                    if (item is IImmutableInstanceProvider<ProjectItemInstance> immutableInstanceProvider)
+                    {
+                        _itemsByEvaluatedInclude.Add(item.EvaluatedInclude, immutableInstanceProvider.ImmutableInstance);
+                    }
+                }
+            }
+
+            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(linkedProject.GlobalPropertiesCount);
+            foreach (var property in linkedProject.GlobalPropertiesEnumerable)
+            {
+                _globalProperties.Set(ProjectPropertyInstance.Create(property.Key, property.Value));
+            }
+
+            CreateEnvironmentVariablePropertiesSnapshot(linkedProject.ProjectCollection.EnvironmentProperties);
+            CreateTargetsSnapshot(linkedProject.Targets, null, null, null, null);
+            CreateImportsSnapshot(linkedProject.Imports, linkedProject.ImportsIncludingDuplicates);
+
+            Toolset = linkedProject.ProjectCollection.GetToolset(linkedProject.ToolsVersion);
+            SubToolsetVersion = linkedProject.SubToolsetVersion;
+            TaskRegistry = new TaskRegistry(Toolset, linkedProject.ProjectCollection.ProjectRootElementCache);
+
+            ProjectRootElementCache = linkedProject.ProjectCollection.ProjectRootElementCache;
+
+            EvaluatedItemElements = new List<ProjectItemElement>(linkedProject.Items.Count);
+            foreach (var item in linkedProject.Items)
+            {
+                EvaluatedItemElements.Add(item.Xml);
+            }
+
+            _usingDifferentToolsVersionFromProjectFile = false;
+            _originalProjectToolsVersion = linkedProject.ToolsVersion;
+            _explicitToolsVersionSpecified = linkedProject.SubToolsetVersion != null;
+
+            _isImmutable = true;
+        }
+
         /// <summary>
         /// Creates a ProjectInstance directly.
         /// No intermediate Project object is created.
@@ -498,7 +576,7 @@ internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> glo
         /// </summary>
         internal ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, ILoggingService loggingService, int visualStudioVersionFromSolution, ProjectCollection projectCollection, ISdkResolverService sdkResolverService, int submissionId)
         {
-            BuildEventContext buildEventContext = new BuildEventContext(0, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
+            BuildEventContext buildEventContext = new BuildEventContext(submissionId, 0, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
             Initialize(xml, globalProperties, toolsVersion, null, visualStudioVersionFromSolution, new BuildParameters(projectCollection), loggingService, buildEventContext, sdkResolverService, submissionId);
         }
 
@@ -785,6 +863,51 @@ public static ProjectInstance FromProjectRootElement(ProjectRootElement rootElem
                 options.Interactive);
         }
 
+        /// <summary>
+        /// Create a ProjectInstance from an immutable project source.
+        /// </summary>
+        /// <param name="project">The immutable <see cref="Project"/> on which the ProjectInstance is based.</param>
+        /// <param name="settings">The <see cref="ProjectInstanceSettings"/> to use.</param>
+        public static ProjectInstance FromImmutableProjectSource(Project project, ProjectInstanceSettings settings)
+        {
+            bool fastItemLookupNeeded = settings.HasFlag(ProjectInstanceSettings.ImmutableWithFastItemLookup);
+            return new ProjectInstance(project, fastItemLookupNeeded);
+        }
+
+        private static ImmutableElementCollectionConverter<TCached, T> GetImmutableElementCollectionConverter<TCached, T>(
+            ICollection<TCached> elementsCollection)
+            where T : class, IKeyed
+        {
+            // The elementsCollection we receive here is implemented in CPS as a special collection
+            // that is both IDictionary<string, TCached> and also IDictionary<(string, int, int), TCached>.
+            // This allows it to represent the fundamental operations of an IRetrievableEntryHashSet.
+            // The IDictionary<(string, int, int), TCached> interface is used to handle the
+            // IRetrievableEntryHashSet's Get(string key, int index, int length) method. Here we take
+            // elementsCollection and put it into an ImmutableElementCollectionConverter, which
+            // represents the elementsCollection as an IRetrievableEntryHashSet<T>.
+            // That IRetrievableEntryHashSet is then used either directly or as a backing source for
+            // another collection wrapper (e.g. PropertyDictionary).
+            if (elementsCollection is not IDictionary<string, TCached> elementsDictionary ||
+                elementsCollection is not IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
+            {
+                throw new ArgumentException(nameof(elementsCollection));
+            }
+
+            return new ImmutableElementCollectionConverter<TCached, T>(elementsDictionary, constrainedElementsDictionary);
+        }
+
+        private static ImmutableElementCollectionConverter<TCached, T> GetImmutableElementCollectionConverter<TCached, T>(
+            IDictionary<string, TCached> elementsDictionary)
+            where T : class, IKeyed
+        {
+            if (elementsDictionary is not IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
+            {
+                throw new ArgumentException(nameof(elementsDictionary));
+            }
+
+            return new ImmutableElementCollectionConverter<TCached, T>(elementsDictionary, constrainedElementsDictionary);
+        }
+
         /// <summary>
         /// Global properties this project was evaluated with, if any.
         /// Read only collection.
@@ -1101,7 +1224,7 @@ IEnumerable<ProjectItemDefinitionInstance> IEvaluatorData<ProjectPropertyInstanc
         /// <summary>
         /// Gets the items
         /// </summary>
-        ItemDictionary<ProjectItemInstance> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.Items
+        IItemDictionary<ProjectItemInstance> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.Items
         {
             [DebuggerStepThrough]
             get
@@ -1283,7 +1406,7 @@ internal PropertyDictionary<ProjectPropertyInstance> PropertiesToBuildWith
         /// Actual collection of items in this project,
         /// for the build to start with.
         /// </summary>
-        internal ItemDictionary<ProjectItemInstance> ItemsToBuildWith
+        internal IItemDictionary<ProjectItemInstance> ItemsToBuildWith
         {
             [DebuggerStepThrough]
             get
@@ -2360,7 +2483,7 @@ internal bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<
 
             if (loggers != null)
             {
-                parameters.Loggers = (loggers is ICollection<ILogger>) ? ((ICollection<ILogger>)loggers) : new List<ILogger>(loggers);
+                parameters.Loggers = (loggers is ICollection<ILogger> loggersCollection) ? loggersCollection : new List<ILogger>(loggers);
 
                 // Enables task parameter logging based on whether any of the loggers attached
                 // to the Project have their verbosity set to Diagnostic. If no logger has
@@ -2693,6 +2816,41 @@ private static IDictionary<string, TValue> CreateCloneDictionary<TValue>(IDictio
             }
         }
 
+        private static void InitializeImmutableProjectItemDefinitionInstances(IDictionary<string, ProjectItemDefinition> projectItemDefinitions)
+        {
+            foreach (var projectItemDefinition in projectItemDefinitions.Values)
+            {
+                if (projectItemDefinition is IImmutableInstanceProvider<ProjectItemDefinitionInstance> immutableInstanceProvider)
+                {
+                    immutableInstanceProvider.ImmutableInstance = new ProjectItemDefinitionInstance(projectItemDefinition);
+                }
+            }
+        }
+
+        private static void InitializeImmutableProjectPropertyInstances(ICollection<ProjectProperty> projectProperties)
+        {
+            foreach (var projectProperty in projectProperties)
+            {
+                if (projectProperty is IImmutableInstanceProvider<ProjectPropertyInstance> immutableInstanceProvider)
+                {
+                    immutableInstanceProvider.ImmutableInstance = InstantiateProjectPropertyInstance(projectProperty, isImmutable: true);
+                }
+            }
+        }
+
+        private static ProjectPropertyInstance InstantiateProjectPropertyInstance(ProjectProperty property, bool isImmutable)
+        {
+            // Allow reserved property names, since this is how they are added to the project instance.
+            // The caller has prevented users setting them themselves.
+            var instance = ProjectPropertyInstance.Create(
+                                property.Name,
+                                ((IProperty)property).EvaluatedValueEscaped,
+                                true /* MAY be reserved name */,
+                                isImmutable,
+                                property.IsEnvironmentProperty);
+            return instance;
+        }
+
         /// <summary>
         /// Common code for the constructors that evaluate directly.
         /// Global properties may be null.
@@ -2934,44 +3092,60 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(ICollec
 
             foreach (ProjectItem item in items)
             {
-                List<ProjectItemDefinitionInstance> inheritedItemDefinitions = null;
+                ProjectItemInstance instance = InstantiateProjectItemInstance(item);
+                _items.Add(instance);
+                projectItemToInstanceMap?.Add(item, instance);
+            }
 
-                if (item.InheritedItemDefinitions != null)
-                {
-                    inheritedItemDefinitions = new List<ProjectItemDefinitionInstance>(item.InheritedItemDefinitions.Count);
+            return projectItemToInstanceMap;
+        }
 
-                    foreach (ProjectItemDefinition inheritedItemDefinition in item.InheritedItemDefinitions)
-                    {
-                        // All item definitions in this list should be present in the collection of item definitions
-                        // on the project we are cloning.
-                        inheritedItemDefinitions.Add(_itemDefinitions[inheritedItemDefinition.ItemType]);
-                    }
+        private void InitializeImmutableProjectItemInstances(ICollection<ProjectItem> projectItems)
+        {
+            foreach (var projectItem in projectItems)
+            {
+                if (projectItem is IImmutableInstanceProvider<ProjectItemInstance> immutableInstanceProvider)
+                {
+                    ProjectItemInstance instance = InstantiateProjectItemInstance(projectItem);
+                    immutableInstanceProvider.ImmutableInstance = instance;
                 }
+            }
+        }
 
-                CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = null;
+        private ProjectItemInstance InstantiateProjectItemInstance(ProjectItem item)
+        {
+            List<ProjectItemDefinitionInstance> inheritedItemDefinitions = null;
 
-                if (item.DirectMetadata != null)
-                {
-                    directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+            if (item.InheritedItemDefinitions != null)
+            {
+                inheritedItemDefinitions = new List<ProjectItemDefinitionInstance>(item.InheritedItemDefinitions.Count);
 
-                    IEnumerable<ProjectMetadataInstance> projectMetadataInstances = item.DirectMetadata.Select(directMetadatum => new ProjectMetadataInstance(directMetadatum));
-                    directMetadata.ImportProperties(projectMetadataInstances);
+                foreach (ProjectItemDefinition inheritedItemDefinition in item.InheritedItemDefinitions)
+                {
+                    // All item definitions in this list should be present in the collection of item definitions
+                    // on the project we are cloning.
+                    inheritedItemDefinitions.Add(_itemDefinitions[inheritedItemDefinition.ItemType]);
                 }
+            }
 
-                // For externally constructed ProjectItem, fall back to the publicly available EvaluateInclude
-                var evaluatedIncludeEscaped = ((IItem)item).EvaluatedIncludeEscaped;
-                evaluatedIncludeEscaped ??= item.EvaluatedInclude;
-                var evaluatedIncludeBeforeWildcardExpansionEscaped = item.EvaluatedIncludeBeforeWildcardExpansionEscaped;
-                evaluatedIncludeBeforeWildcardExpansionEscaped ??= item.EvaluatedInclude;
-
-                ProjectItemInstance instance = new ProjectItemInstance(this, item.ItemType, evaluatedIncludeEscaped, evaluatedIncludeBeforeWildcardExpansionEscaped, directMetadata, inheritedItemDefinitions, item.Xml.ContainingProject.EscapedFullPath);
+            CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = null;
 
-                _items.Add(instance);
+            if (item.DirectMetadata != null)
+            {
+                directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
 
-                projectItemToInstanceMap?.Add(item, instance);
+                IEnumerable<ProjectMetadataInstance> projectMetadataInstances = item.DirectMetadata.Select(directMetadatum => new ProjectMetadataInstance(directMetadatum));
+                directMetadata.ImportProperties(projectMetadataInstances);
             }
 
-            return projectItemToInstanceMap;
+            // For externally constructed ProjectItem, fall back to the publicly available EvaluateInclude
+            var evaluatedIncludeEscaped = ((IItem)item).EvaluatedIncludeEscaped;
+            evaluatedIncludeEscaped ??= item.EvaluatedInclude;
+            var evaluatedIncludeBeforeWildcardExpansionEscaped = item.EvaluatedIncludeBeforeWildcardExpansionEscaped;
+            evaluatedIncludeBeforeWildcardExpansionEscaped ??= item.EvaluatedInclude;
+
+            ProjectItemInstance instance = new ProjectItemInstance(this, item.ItemType, evaluatedIncludeEscaped, evaluatedIncludeBeforeWildcardExpansionEscaped, directMetadata, inheritedItemDefinitions, item.Xml.ContainingProject.EscapedFullPath);
+            return instance;
         }
 
         /// <summary>
@@ -2979,7 +3153,7 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(ICollec
         /// </summary>
         private void CreateItemDefinitionsSnapshot(IDictionary<string, ProjectItemDefinition> itemDefinitions)
         {
-            _itemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(MSBuildNameIgnoreCaseComparer.Default);
+            _itemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(itemDefinitions.Count, MSBuildNameIgnoreCaseComparer.Default);
 
             foreach (ProjectItemDefinition definition in itemDefinitions.Values)
             {
@@ -2996,9 +3170,7 @@ private void CreatePropertiesSnapshot(ICollection<ProjectProperty> properties, b
 
             foreach (ProjectProperty property in properties)
             {
-                // Allow reserved property names, since this is how they are added to the project instance.
-                // The caller has prevented users setting them themselves.
-                ProjectPropertyInstance instance = ProjectPropertyInstance.Create(property.Name, ((IProperty)property).EvaluatedValueEscaped, true /* MAY be reserved name */, isImmutable, property.IsEnvironmentProperty);
+                ProjectPropertyInstance instance = InstantiateProjectPropertyInstance(property, isImmutable);
                 _properties.Set(instance);
             }
         }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index 9fe1638fd3a..22921695dea 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -5,7 +5,12 @@
 
 namespace Microsoft.Build.Logging
 {
-    internal enum BinaryLogRecordKind
+    /// <summary>
+    /// Indicates the type of record stored in the binary log.
+    /// There is a record type for each type of build event and there
+    /// are also few meta-data record types (e.g. string data, lookup data, EOF).
+    /// </summary>
+    public enum BinaryLogRecordKind
     {
         EndOfFile = 0,
         BuildStarted,
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
index a19a06c2d37..abf9e4e80c9 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
@@ -11,13 +11,63 @@
 
 namespace Microsoft.Build.Logging
 {
+    /// <summary>
+    /// Interface for replaying a binary log file (*.binlog)
+    /// </summary>
+    internal interface IBinaryLogReplaySource :
+        IEventSource,
+        IBuildEventArgsReaderNotifications
+    {
+        /// <summary>
+        /// Event raised when non-textual log record is read.
+        /// This means all event args and key-value pairs.
+        /// Strings and Embedded files are not included.
+        /// </summary>
+        event Action<BinaryLogRecordKind, Stream>? RawLogRecordReceived;
+
+        /// <summary>
+        /// Enables initialization (e.g. subscription to events) - that is deferred until Replay is triggered.
+        /// At this point all other possible subscribers should be already subscribed -
+        ///  so it can be determined if raw events or structured events should be replayed.
+        /// </summary>
+        /// <param name="onRawReadingPossible"></param>
+        /// <param name="onStructuredReadingOnly"></param>
+        void DeferredInitialize(
+            Action onRawReadingPossible,
+            Action onStructuredReadingOnly);
+
+        /// <summary>
+        /// File format version of the binary log file.
+        /// </summary>
+        int FileFormatVersion { get; }
+
+        /// <summary>
+        /// The minimum reader version for the binary log file.
+        /// </summary>
+        int MinimumReaderVersion { get; }
+
+        /// <summary>
+        /// Raised when the log reader encounters a project import archive (embedded content) in the stream.
+        /// The subscriber must read the exactly given length of binary data from the stream - otherwise exception is raised.
+        /// If no subscriber is attached, the data is skipped.
+        /// </summary>
+        event Action<EmbeddedContentEventArgs> EmbeddedContentRead;
+    }
+
     /// <summary>
     /// Provides a method to read a binary log file (*.binlog) and replay all stored BuildEventArgs
     /// by implementing IEventSource and raising corresponding events.
     /// </summary>
     /// <remarks>The class is public so that we can call it from MSBuild.exe when replaying a log file.</remarks>
-    public sealed class BinaryLogReplayEventSource : EventArgsDispatcher
+    public sealed class BinaryLogReplayEventSource : EventArgsDispatcher,
+        IBinaryLogReplaySource
     {
+        private int? _fileFormatVersion;
+        private int? _minimumReaderVersion;
+
+        public int FileFormatVersion => _fileFormatVersion ?? throw new InvalidOperationException(ResourceUtilities.GetResourceString("Binlog_Source_VersionUninitialized"));
+        public int MinimumReaderVersion => _minimumReaderVersion ?? throw new InvalidOperationException(ResourceUtilities.GetResourceString("Binlog_Source_VersionUninitialized"));
+
         /// Touches the <see cref="ItemGroupLoggingHelper"/> static constructor
         /// to ensure it initializes <see cref="TaskParameterEventArgs.MessageGetter"/>
         /// and <see cref="TaskParameterEventArgs.DictionaryFactory"/>
@@ -27,9 +77,12 @@ static BinaryLogReplayEventSource()
         }
 
         /// <summary>
-        /// Raised once <see cref="BuildEventArgsReader"/> is created during replaying
+        /// Unknown build events or unknown parts of known build events will be ignored if this is set to true.
         /// </summary>
-        public event Action<IBuildEventArgsReaderNotifications>? NotificationsSourceCreated;
+        public bool AllowForwardCompatibility { private get; init; }
+
+        /// <inheritdoc cref="IBuildEventArgsReaderNotifications.RecoverableReadError"/>
+        public event Action<BinaryLogReaderErrorEventArgs>? RecoverableReadError;
 
         /// <summary>
         /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
@@ -40,6 +93,17 @@ public void Replay(string sourceFilePath)
             Replay(sourceFilePath, CancellationToken.None);
         }
 
+        /// <summary>
+        /// Read the provided binary log file opened as a stream and raise corresponding events for each BuildEventArgs
+        /// </summary>
+        /// <param name="sourceFileStream">Stream over the binlog content.</param>
+        /// <param name="cancellationToken"></param>
+        public void Replay(Stream sourceFileStream, CancellationToken cancellationToken)
+        {
+            using var binaryReader = OpenReader(sourceFileStream);
+            Replay(binaryReader, cancellationToken);
+        }
+
         /// <summary>
         /// Creates a <see cref="BinaryReader"/> for the provided binary log file.
         /// Performs decompression and buffering in the optimal way.
@@ -53,21 +117,78 @@ public static BinaryReader OpenReader(string sourceFilePath)
             try
             {
                 stream = new FileStream(sourceFilePath, FileMode.Open, FileAccess.Read, FileShare.Read);
-                var gzipStream = new GZipStream(stream, CompressionMode.Decompress, leaveOpen: false);
-
-                // wrapping the GZipStream in a buffered stream significantly improves performance
-                // and the max throughput is reached with a 32K buffer. See details here:
-                // https://github.com/dotnet/runtime/issues/39233#issuecomment-745598847
-                var bufferedStream = new BufferedStream(gzipStream, 32768);
-                return new BinaryReader(bufferedStream);
+                return OpenReader(stream);
             }
-            catch(Exception)
+            catch (Exception)
             {
                 stream?.Dispose();
                 throw;
             }
         }
 
+        /// <summary>
+        /// Creates a <see cref="BinaryReader"/> for the provided binary log file.
+        /// Performs decompression and buffering in the optimal way.
+        /// Caller is responsible for disposing the returned reader.
+        /// </summary>
+        /// <param name="sourceFileStream">Stream over the binlog file</param>
+        /// <returns>BinaryReader of the given binlog file.</returns>
+        public static BinaryReader OpenReader(Stream sourceFileStream)
+        {
+            var gzipStream = new GZipStream(sourceFileStream, CompressionMode.Decompress, leaveOpen: false);
+
+            // wrapping the GZipStream in a buffered stream significantly improves performance
+            // and the max throughput is reached with a 32K buffer. See details here:
+            // https://github.com/dotnet/runtime/issues/39233#issuecomment-745598847
+            var bufferedStream = new BufferedStream(gzipStream, 32768);
+            return new BinaryReader(bufferedStream);
+        }
+
+        /// <summary>
+        /// Creates a <see cref="BuildEventArgsReader"/> for the provided binary reader over binary log file.
+        /// Caller is responsible for disposing the returned reader.
+        /// </summary>
+        /// <param name="binaryReader"></param>
+        /// <param name="closeInput">Indicates whether the passed BinaryReader should be closed on disposing.</param>
+        /// <param name="allowForwardCompatibility">Unknown build events or unknown parts of known build events will be ignored if this is set to true.</param>
+        /// <returns>BuildEventArgsReader over the given binlog file binary reader.</returns>
+        public static BuildEventArgsReader OpenBuildEventsReader(
+            BinaryReader binaryReader,
+            bool closeInput,
+            bool allowForwardCompatibility = false)
+        {
+            int fileFormatVersion = binaryReader.ReadInt32();
+            // Is this the new log format that contains the minimum reader version?
+            int minimumReaderVersion = fileFormatVersion >= BinaryLogger.ForwardCompatibilityMinimalVersion
+                ? binaryReader.ReadInt32()
+                : fileFormatVersion;
+
+            // the log file is written using a newer version of file format
+            // that we don't know how to read
+            if (fileFormatVersion > BinaryLogger.FileFormatVersion &&
+                (!allowForwardCompatibility || minimumReaderVersion > BinaryLogger.FileFormatVersion))
+            {
+                var text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnsupportedLogFileFormat", fileFormatVersion, minimumReaderVersion, BinaryLogger.FileFormatVersion);
+                throw new NotSupportedException(text);
+            }
+
+            return new BuildEventArgsReader(binaryReader, fileFormatVersion)
+            {
+                CloseInput = closeInput,
+                MinimumReaderVersion = minimumReaderVersion
+            };
+        }
+
+        /// <summary>
+        /// Creates a <see cref="BinaryReader"/> for the provided binary log file.
+        /// Performs decompression and buffering in the optimal way.
+        /// Caller is responsible for disposing the returned reader.
+        /// </summary>
+        /// <param name="sourceFilePath"></param>
+        /// <returns>BinaryReader of the given binlog file.</returns>
+        public static BuildEventArgsReader OpenBuildEventsReader(string sourceFilePath)
+            => OpenBuildEventsReader(OpenReader(sourceFilePath), true);
+
         /// <summary>
         /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
         /// </summary>
@@ -75,8 +196,8 @@ public static BinaryReader OpenReader(string sourceFilePath)
         /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
         public void Replay(string sourceFilePath, CancellationToken cancellationToken)
         {
-            using var binaryReader = OpenReader(sourceFilePath);
-            Replay(binaryReader, cancellationToken);
+            using var eventsReader = OpenBuildEventsReader(sourceFilePath);
+            Replay(eventsReader, cancellationToken);
         }
 
         /// <summary>
@@ -85,24 +206,137 @@ public void Replay(string sourceFilePath, CancellationToken cancellationToken)
         /// <param name="binaryReader">The binary log content binary reader - caller is responsible for disposing.</param>
         /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
         public void Replay(BinaryReader binaryReader, CancellationToken cancellationToken)
+            => Replay(binaryReader, false, cancellationToken);
+
+        /// <summary>
+        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
+        /// </summary>
+        /// <param name="binaryReader">The binary log content binary reader - caller is responsible for disposing, unless <paramref name="closeInput"/> is set to true.</param>
+        /// <param name="closeInput">Indicates whether the passed BinaryReader should be closed on disposing.</param>
+        /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
+        public void Replay(BinaryReader binaryReader, bool closeInput, CancellationToken cancellationToken)
         {
-            int fileFormatVersion = binaryReader.ReadInt32();
+            using var reader = OpenBuildEventsReader(binaryReader, closeInput, AllowForwardCompatibility);
+            Replay(reader, cancellationToken);
+        }
 
-            // the log file is written using a newer version of file format
-            // that we don't know how to read
-            if (fileFormatVersion > BinaryLogger.FileFormatVersion)
+        /// <summary>
+        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
+        /// </summary>
+        /// <param name="reader">The build events reader - caller is responsible for disposing.</param>
+        /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
+        public void Replay(BuildEventArgsReader reader, CancellationToken cancellationToken)
+        {
+            _fileFormatVersion = reader.FileFormatVersion;
+            _minimumReaderVersion = reader.MinimumReaderVersion;
+            bool supportsForwardCompatibility = reader.FileFormatVersion >= BinaryLogger.ForwardCompatibilityMinimalVersion;
+
+            // Allow any possible deferred subscriptions to be registered
+            if (HasStructuredEventsSubscribers || !supportsForwardCompatibility)
             {
-                var text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnsupportedLogFileFormat", fileFormatVersion, BinaryLogger.FileFormatVersion);
-                throw new NotSupportedException(text);
+                _onStructuredReadingOnly?.Invoke();
+            }
+            else
+            {
+                _onRawReadingPossible?.Invoke();
             }
 
-            using var reader = new BuildEventArgsReader(binaryReader, fileFormatVersion);
-            NotificationsSourceCreated?.Invoke(reader);
+            reader.EmbeddedContentRead += _embeddedContentRead;
+            reader.ArchiveFileEncountered += _archiveFileEncountered;
+            reader.StringReadDone += _stringReadDone;
 
-            while (!cancellationToken.IsCancellationRequested && reader.Read() is { } instance)
+            if (HasStructuredEventsSubscribers || !supportsForwardCompatibility)
             {
-                Dispatch(instance);
+                if (this._rawLogRecordReceived != null)
+                {
+                    throw new NotSupportedException(
+                        ResourceUtilities.GetResourceString("Binlog_Source_MultiSubscribeError"));
+                }
+
+                // Forward compatible reading makes sense only for structured events reading.
+                reader.SkipUnknownEvents = supportsForwardCompatibility && AllowForwardCompatibility;
+                reader.SkipUnknownEventParts = supportsForwardCompatibility && AllowForwardCompatibility;
+                reader.RecoverableReadError += RecoverableReadError;
+
+                while (!cancellationToken.IsCancellationRequested && reader.Read() is { } instance)
+                {
+                    Dispatch(instance);
+                }
             }
+            else
+            {
+                if (this._rawLogRecordReceived == null &&
+                    this._embeddedContentRead == null &&
+                    this._stringReadDone == null &&
+                    this._archiveFileEncountered == null)
+                {
+                    throw new NotSupportedException(
+                        ResourceUtilities.GetResourceString("Binlog_Source_MissingSubscribeError"));
+                }
+
+                while (!cancellationToken.IsCancellationRequested && reader.ReadRaw() is { } instance &&
+                       instance.RecordKind != BinaryLogRecordKind.EndOfFile)
+                {
+                    _rawLogRecordReceived?.Invoke(instance.RecordKind, instance.Stream);
+                }
+            }
+
+            // Unsubscribe from events for a case if the reader is reused (upon cancellation).
+            reader.EmbeddedContentRead -= _embeddedContentRead;
+            reader.ArchiveFileEncountered -= _archiveFileEncountered;
+            reader.StringReadDone -= _stringReadDone;
+            reader.RecoverableReadError -= RecoverableReadError;
+        }
+
+        // Following members are explicit implementations of the IBinaryLogReplaySource interface
+        //  to avoid exposing them publicly.
+        // We want an interface so that BinaryLogger can fine tune its initialization logic
+        //  in case the given event source is the replay source. On the other hand we don't want
+        //  to expose these members publicly because they are not intended to be used by the consumers.
+
+        private Action? _onRawReadingPossible;
+        private Action? _onStructuredReadingOnly;
+        /// <inheritdoc cref="IBinaryLogReplaySource.DeferredInitialize"/>
+        void IBinaryLogReplaySource.DeferredInitialize(
+            Action onRawReadingPossible,
+            Action onStructuredReadingOnly)
+        {
+            this._onRawReadingPossible += onRawReadingPossible;
+            this._onStructuredReadingOnly += onStructuredReadingOnly;
+        }
+
+        private Action<EmbeddedContentEventArgs>? _embeddedContentRead;
+        /// <inheritdoc cref="IBinaryLogReplaySource.EmbeddedContentRead"/>
+        event Action<EmbeddedContentEventArgs>? IBinaryLogReplaySource.EmbeddedContentRead
+        {
+            // Explicitly implemented event has to declare explicit add/remove accessors
+            //  https://stackoverflow.com/a/2268472/2308106
+            add => _embeddedContentRead += value;
+            remove => _embeddedContentRead -= value;
+        }
+
+        private Action<StringReadEventArgs>? _stringReadDone;
+        /// <inheritdoc cref="IBuildEventArgsReaderNotifications.StringReadDone"/>
+        event Action<StringReadEventArgs>? IBuildEventArgsReaderNotifications.StringReadDone
+        {
+            add => _stringReadDone += value;
+            remove => _stringReadDone -= value;
+        }
+
+        private Action<ArchiveFileEventArgs>? _archiveFileEncountered;
+        /// <inheritdoc cref="IBuildEventArgsReaderNotifications.ArchiveFileEncountered"/>
+        event Action<ArchiveFileEventArgs>? IBuildEventArgsReaderNotifications.ArchiveFileEncountered
+        {
+            add => _archiveFileEncountered += value;
+            remove => _archiveFileEncountered -= value;
+        }
+
+        private Action<BinaryLogRecordKind, Stream>? _rawLogRecordReceived;
+        /// <inheritdoc cref="IBinaryLogReplaySource.RawLogRecordReceived"/>
+        event Action<BinaryLogRecordKind, Stream>? IBinaryLogReplaySource.RawLogRecordReceived
+        {
+            add => _rawLogRecordReceived += value;
+            remove => _rawLogRecordReceived -= value;
         }
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index a935708e681..a9e6f75705f 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -63,7 +63,24 @@ public sealed class BinaryLogger : ILogger
         //   - AssemblyLoadBuildEventArgs
         // version 17:
         //   - Added extended data for types implementing IExtendedBuildEventArgs
-        internal const int FileFormatVersion = 17;
+        // version 18:
+        //   - Making ProjectStartedEventArgs, ProjectEvaluationFinishedEventArgs, AssemblyLoadBuildEventArgs equal
+        //     between de/serialization roundtrips.
+        //   - Adding serialized events lengths - to support forward compatible reading
+
+        // This should be never changed.
+        // The minimum version of the binary log reader that can read log of above version.
+        internal const int ForwardCompatibilityMinimalVersion = 18;
+
+        // The current version of the binary log representation.
+        // Changes with each update of the binary log format.
+        internal const int FileFormatVersion = 18;
+
+        // The minimum version of the binary log reader that can read log of above version.
+        // This should be changed only when the binary log format is changed in a way that would prevent it from being
+        // read by older readers. (changing of the individual BuildEventArgs or adding new is fine - as reader can
+        // skip them if they are not known to it. Example of change requiring the increment would be the introduction of strings deduplication)
+        internal const int MinimumReaderVersion = 18;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
@@ -92,7 +109,7 @@ public enum ProjectImportsCollectionMode
             /// <summary>
             /// Create an external .ProjectImports.zip archive for the project files.
             /// </summary>
-            ZipFile
+            ZipFile,
         }
 
         /// <summary>
@@ -115,7 +132,7 @@ public enum ProjectImportsCollectionMode
         public string Parameters { get; set; }
 
         /// <summary>
-        /// Initializes the logger by subscribing to events of the specified event source.
+        /// Initializes the logger by subscribing to events of the specified event source and embedded content source.
         /// </summary>
         public void Initialize(IEventSource eventSource)
         {
@@ -130,7 +147,8 @@ public void Initialize(IEventSource eventSource)
             Traits.Instance.EscapeHatches.LogProjectImports = true;
             bool logPropertiesAndItemsAfterEvaluation = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation ?? true;
 
-            ProcessParameters();
+            ProcessParameters(out bool omitInitialInfo);
+            var replayEventSource = eventSource as IBinaryLogReplaySource;
 
             try
             {
@@ -152,7 +170,7 @@ public void Initialize(IEventSource eventSource)
 
                 stream = new FileStream(FilePath, FileMode.Create);
 
-                if (CollectProjectImports != ProjectImportsCollectionMode.None)
+                if (CollectProjectImports != ProjectImportsCollectionMode.None && replayEventSource == null)
                 {
                     projectImportsCollector = new ProjectImportsCollector(FilePath, CollectProjectImports == ProjectImportsCollectionMode.ZipFile);
                 }
@@ -189,13 +207,57 @@ public void Initialize(IEventSource eventSource)
                 eventArgsWriter.EmbedFile += EventArgsWriter_EmbedFile;
             }
 
-            binaryWriter.Write(FileFormatVersion);
-
-            LogInitialInfo();
+            if (replayEventSource != null)
+            {
+                if (CollectProjectImports == ProjectImportsCollectionMode.Embed)
+                {
+                    replayEventSource.EmbeddedContentRead += args =>
+                        eventArgsWriter.WriteBlob(args.ContentKind, args.ContentStream);
+                }
+                else if (CollectProjectImports == ProjectImportsCollectionMode.ZipFile)
+                {
+                    replayEventSource.EmbeddedContentRead += args =>
+                        ProjectImportsCollector.FlushBlobToFile(FilePath, args.ContentStream);
+                }
 
-            eventSource.AnyEventRaised += EventSource_AnyEventRaised;
+                // If raw events are provided - let's try to use the advantage.
+                // But other subscribers can later on subscribe to structured events -
+                //  for this reason we do only subscribe delayed.
+                replayEventSource.DeferredInitialize(
+                    // For raw events we cannot write the initial info - as we cannot write
+                    //  at the same time as raw events are being written - this would break the deduplicated strings store.
+                    // But we need to write the version info - but since we read/write raw - let's not change the version info.
+                    () =>
+                    {
+                        binaryWriter.Write(replayEventSource.FileFormatVersion);
+                        binaryWriter.Write(replayEventSource.MinimumReaderVersion);
+                        replayEventSource.RawLogRecordReceived += RawEvents_LogDataSliceReceived;
+                        // Replay separated strings here as well (and do not deduplicate! It would skew string indexes)
+                        replayEventSource.StringReadDone += strArg => eventArgsWriter.WriteStringRecord(strArg.StringToBeUsed);
+                    },
+                    SubscribeToStructuredEvents);
+            }
+            else
+            {
+                SubscribeToStructuredEvents();
+            }
 
             KnownTelemetry.LoggingConfigurationTelemetry.BinaryLogger = true;
+
+            void SubscribeToStructuredEvents()
+            {
+                // Write the version info - the latest version is written only for structured events replaying
+                //  as raw events do not change structure - hence the version is the same as the one they were written with.
+                binaryWriter.Write(FileFormatVersion);
+                binaryWriter.Write(MinimumReaderVersion);
+
+                if (!omitInitialInfo)
+                {
+                    LogInitialInfo();
+                }
+
+                eventSource.AnyEventRaised += EventSource_AnyEventRaised;
+            }
         }
 
         private void EventArgsWriter_EmbedFile(string filePath)
@@ -236,26 +298,11 @@ public void Shutdown()
 
                 if (CollectProjectImports == ProjectImportsCollectionMode.Embed)
                 {
-                    var archiveFilePath = projectImportsCollector.ArchiveFilePath;
+                    projectImportsCollector.ProcessResult(
+                        streamToEmbed => eventArgsWriter.WriteBlob(BinaryLogRecordKind.ProjectImportArchive, streamToEmbed),
+                        LogMessage);
 
-                    // It is possible that the archive couldn't be created for some reason.
-                    // Only embed it if it actually exists.
-                    if (FileSystems.Default.FileExists(archiveFilePath))
-                    {
-                        using (FileStream fileStream = File.OpenRead(archiveFilePath))
-                        {
-                            if (fileStream.Length > int.MaxValue)
-                            {
-                                LogMessage("Imported files archive exceeded 2GB limit and it's not embedded.");
-                            }
-                            else
-                            {
-                                eventArgsWriter.WriteBlob(BinaryLogRecordKind.ProjectImportArchive, fileStream);
-                            }
-                        }
-
-                        File.Delete(archiveFilePath);
-                    }
+                    projectImportsCollector.DeleteArchive();
                 }
 
                 projectImportsCollector = null;
@@ -272,6 +319,11 @@ public void Shutdown()
             }
         }
 
+        private void RawEvents_LogDataSliceReceived(BinaryLogRecordKind recordKind, Stream stream)
+        {
+            eventArgsWriter.WriteBlob(recordKind, stream);
+        }
+
         private void EventSource_AnyEventRaised(object sender, BuildEventArgs e)
         {
             Write(e);
@@ -304,7 +356,7 @@ private void CollectImports(BuildEventArgs e)
             {
                 projectImportsCollector.AddFile(projectArgs.ProjectFile);
             }
-            else if (e is MetaprojectGeneratedEventArgs metaprojectArgs)
+            else if (e is MetaprojectGeneratedEventArgs { metaprojectXml: { } } metaprojectArgs)
             {
                 projectImportsCollector.AddFileFromMemory(metaprojectArgs.ProjectFile, metaprojectArgs.metaprojectXml);
             }
@@ -319,13 +371,14 @@ private void CollectImports(BuildEventArgs e)
         /// </summary>
         /// <exception cref="LoggerException">
         /// </exception>
-        private void ProcessParameters()
+        private void ProcessParameters(out bool omitInitialInfo)
         {
             if (Parameters == null)
             {
                 throw new LoggerException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("InvalidBinaryLoggerParameters", ""));
             }
 
+            omitInitialInfo = false;
             var parameters = Parameters.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries);
             foreach (var parameter in parameters)
             {
@@ -341,6 +394,10 @@ private void ProcessParameters()
                 {
                     CollectProjectImports = ProjectImportsCollectionMode.ZipFile;
                 }
+                else if (string.Equals(parameter, "OmitInitialInfo", StringComparison.OrdinalIgnoreCase))
+                {
+                    omitInitialInfo = true;
+                }
                 else if (parameter.EndsWith(".binlog", StringComparison.OrdinalIgnoreCase))
                 {
                     FilePath = parameter;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsDispatcher.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsDispatcher.cs
index 4a50a3d8e8b..db24d791ed2 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsDispatcher.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsDispatcher.cs
@@ -85,6 +85,22 @@ public class EventArgsDispatcher : IEventSource
         /// </summary>
         public event BuildMessageEventHandler MessageRaised;
 
+        internal bool HasStructuredEventsSubscribers =>
+            AnyEventRaised != null ||
+            StatusEventRaised != null ||
+            CustomEventRaised != null ||
+            BuildStarted != null ||
+            BuildFinished != null ||
+            ProjectStarted != null ||
+            ProjectFinished != null ||
+            TargetStarted != null ||
+            TargetFinished != null ||
+            TaskStarted != null ||
+            TaskFinished != null ||
+            ErrorRaised != null ||
+            WarningRaised != null ||
+            MessageRaised != null;
+
         /// <summary>
         /// Raise one of the events that is appropriate for the type of the BuildEventArgs
         /// </summary>
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 3c3e2a2faee..2c49c17c8a7 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -2,10 +2,14 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Buffers;
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
+using System.IO.Compression;
+using System.Linq;
 using System.Reflection;
+using System.Runtime.CompilerServices;
 using System.Text;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
@@ -20,9 +24,13 @@ namespace Microsoft.Build.Logging
     /// </summary>
     public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposable
     {
-        private readonly BinaryReader binaryReader;
-        private readonly int fileFormatVersion;
-        private long recordNumber = 0;
+        private readonly BinaryReader _binaryReader;
+        // This is used to verify that events deserialization is not overreading expected size.
+        private readonly TransparentReadStream _readStream;
+        private readonly int _fileFormatVersion;
+        private long _recordNumber = 0;
+        private bool _skipUnknownEvents;
+        private bool _skipUnknownEventParts;
 
         /// <summary>
         /// A list of string records we've encountered so far. If it's a small string, it will be the string directly.
@@ -59,33 +67,140 @@ public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposa
         /// <param name="fileFormatVersion">The file format version of the log file being read.</param>
         public BuildEventArgsReader(BinaryReader binaryReader, int fileFormatVersion)
         {
-            this.binaryReader = binaryReader;
-            this.fileFormatVersion = fileFormatVersion;
+            this._readStream = TransparentReadStream.EnsureTransparentReadStream(binaryReader.BaseStream);
+            // make sure the reader we're going to use wraps the transparent stream wrapper
+            this._binaryReader = binaryReader.BaseStream == _readStream
+                ? binaryReader
+                : new BinaryReader(_readStream);
+            this._fileFormatVersion = fileFormatVersion;
         }
 
-        public void Dispose()
+        /// <summary>
+        /// Directs whether the passed <see cref="BinaryReader"/> should be closed when this instance is disposed.
+        /// Defaults to "false".
+        /// </summary>
+        public bool CloseInput { private get; set; } = false;
+
+        /// <summary>
+        /// Indicates whether unknown BuildEvents should be silently skipped. Read returns null otherwise.
+        /// Parameter is supported only if the file format supports forward compatible reading (version is 18 or higher).
+        /// </summary>
+        public bool SkipUnknownEvents
         {
-            stringStorage.Dispose();
+            set
+            {
+                if (value)
+                {
+                    EnsureForwardCompatibleReadingSupported();
+                }
+
+                _skipUnknownEvents = value;
+            }
         }
 
         /// <summary>
-        /// An event that allows the subscriber to be notified when a string is read from the binary log.
-        /// Subscriber may adjust the string by setting <see cref="StringReadEventArgs.StringToBeUsed"/> property.
-        /// The passed event arg can be reused and should not be stored.
+        /// Indicates whether unread parts of BuildEvents (probably added in newer format of particular BuildEvent)should be silently skipped. Exception thrown otherwise.
+        /// Parameter is supported only if the file format supports forward compatible reading (version is 18 or higher).
         /// </summary>
-        public event Action<StringReadEventArgs>? StringReadDone;
+        public bool SkipUnknownEventParts
+        {
+            set
+            {
+                if (value)
+                {
+                    EnsureForwardCompatibleReadingSupported();
+                }
+                _skipUnknownEventParts = value;
+            }
+        }
+
+        private void EnsureForwardCompatibleReadingSupported()
+        {
+            if (_fileFormatVersion < BinaryLogger.ForwardCompatibilityMinimalVersion)
+            {
+                throw new InvalidOperationException(
+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Binlog_FwdCompatUnsupported",
+                        _fileFormatVersion));
+            }
+        }
 
         /// <summary>
-        /// An event that allows the caller to be notified when a string is encountered in the binary log.
-        /// BinaryReader passed in ctor is at the beginning of the string at this point.
+        /// Receives recoverable errors during reading. See <see cref="IBuildEventArgsReaderNotifications.RecoverableReadError"/> for documentation on arguments.
+        /// Applicable mainly when <see cref="SkipUnknownEvents"/> or <see cref="SkipUnknownEventParts"/> is set to true."/>
         /// </summary>
-        public event Action? StringEncountered;
+        public event Action<BinaryLogReaderErrorEventArgs>? RecoverableReadError;
+
+        public void Dispose()
+        {
+            stringStorage.Dispose();
+            if (CloseInput)
+            {
+                _binaryReader.Dispose();
+            }
+        }
+
+        /// <inheritdoc cref="IBuildEventArgsReaderNotifications.StringReadDone"/>
+        public event Action<StringReadEventArgs>? StringReadDone;
+
+        internal int FileFormatVersion => _fileFormatVersion;
+        internal int MinimumReaderVersion { get; set; } = BinaryLogger.ForwardCompatibilityMinimalVersion;
+
+        /// <inheritdoc cref="IBinaryLogReplaySource.EmbeddedContentRead"/>
+        internal event Action<EmbeddedContentEventArgs>? EmbeddedContentRead;
+
+        /// <inheritdoc cref="IBuildEventArgsReaderNotifications.ArchiveFileEncountered"/>
+        public event Action<ArchiveFileEventArgs>? ArchiveFileEncountered;
+
+        private SubStream? _lastSubStream;
+
+        internal readonly record struct RawRecord(BinaryLogRecordKind RecordKind, Stream Stream);
 
         /// <summary>
-        /// Raised when the log reader encounters a binary blob embedded in the stream.
-        /// The arguments include the blob kind and the byte buffer with the contents.
+        /// Reads the next serialized log record from the <see cref="BinaryReader"/>.
         /// </summary>
-        internal event Action<BinaryLogRecordKind, byte[]>? OnBlobRead;
+        /// <returns>ArraySegment containing serialized BuildEventArgs record</returns>
+        internal RawRecord ReadRaw()
+        {
+            // This method is internal and condition is checked once before calling in loop,
+            //  so avoiding it here on each call.
+            // But keeping it for documentation purposes - in case someone will try to call it and debug issues.
+            ////if (fileFormatVersion < 18)
+            ////{
+            ////    throw new InvalidOperationException(
+            ////                           $"Raw data reading is not supported for file format version {fileFormatVersion} (needs >=18).");
+            ////}
+
+            if (_lastSubStream?.IsAtEnd == false)
+            {
+                _lastSubStream.ReadToEnd();
+            }
+
+            BinaryLogRecordKind recordKind = PreprocessRecordsTillNextEvent(IsTextualDataRecord);
+
+            if (recordKind == BinaryLogRecordKind.EndOfFile)
+            {
+                return new(recordKind, Stream.Null);
+            }
+
+            int serializedEventLength = ReadInt32();
+            Stream stream = _binaryReader.BaseStream.Slice(serializedEventLength);
+
+            _lastSubStream = stream as SubStream;
+
+            _recordNumber += 1;
+
+            return new(recordKind, stream);
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        private void CheckErrorsSubscribed()
+        {
+            if ((_skipUnknownEvents || _skipUnknownEventParts) && RecoverableReadError == null)
+            {
+                throw new InvalidOperationException(
+                    ResourceUtilities.GetResourceString("Binlog_MissingRecoverableErrorSubscribeError"));
+            }
+        }
 
         /// <summary>
         /// Reads the next log record from the <see cref="BinaryReader"/>.
@@ -96,11 +211,131 @@ public void Dispose()
         /// </returns>
         public BuildEventArgs? Read()
         {
+            CheckErrorsSubscribed();
+            BuildEventArgs? result = null;
+            while (result == null)
+            {
+                BinaryLogRecordKind recordKind = PreprocessRecordsTillNextEvent(IsAuxiliaryRecord);
+
+                if (recordKind == BinaryLogRecordKind.EndOfFile)
+                {
+                    return null;
+                }
+
+                int serializedEventLength = 0;
+                if (_fileFormatVersion >= BinaryLogger.ForwardCompatibilityMinimalVersion)
+                {
+                    serializedEventLength = ReadInt32(); // record length
+                    _readStream.BytesCountAllowedToRead = serializedEventLength;
+                }
+
+                bool hasError = false;
+                try
+                {
+                    result = ReadBuildEventArgs(recordKind);
+                }
+                catch (Exception e) when (
+                    // We throw this on mismatches in metadata (name-value list, strings index).
+                    e is InvalidDataException ||
+                    // Thrown when BinaryReader is unable to deserialize binary data into expected type.
+                    e is FormatException ||
+                    // Thrown when we attempt to read more bytes than what is in the next event chunk.
+                    (e is EndOfStreamException && _readStream.BytesCountAllowedToReadRemaining <= 0))
+                {
+                    hasError = true;
+
+                    string ErrorFactory() =>
+                        ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Binlog_ReaderMismatchedRead",
+                            _recordNumber, serializedEventLength, e.GetType(), e.Message) + (_skipUnknownEvents
+                            ? " " + ResourceUtilities.GetResourceString("Binlog_ReaderSkippingRecord")
+                            : string.Empty);
+
+                    HandleError(ErrorFactory, _skipUnknownEvents, ReaderErrorType.UnknownFormatOfEventData, recordKind, e);
+                }
+
+                if (result == null && !hasError)
+                {
+                    string ErrorFactory() =>
+                        ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Binlog_ReaderUnknownType",
+                            _recordNumber, serializedEventLength, recordKind) + (_skipUnknownEvents
+                            ? " " + ResourceUtilities.GetResourceString("Binlog_ReaderSkippingRecord")
+                            : string.Empty);
+
+                    HandleError(ErrorFactory, _skipUnknownEvents, ReaderErrorType.UnknownEventType, recordKind);
+                }
+
+                if (_readStream.BytesCountAllowedToReadRemaining > 0)
+                {
+                    string ErrorFactory() => ResourceUtilities.FormatResourceStringStripCodeAndKeyword(
+                        "Binlog_ReaderUnderRead", _recordNumber, serializedEventLength,
+                        serializedEventLength - _readStream.BytesCountAllowedToReadRemaining);
+
+                    HandleError(ErrorFactory, _skipUnknownEventParts, ReaderErrorType.UnknownEventData, recordKind);
+                }
+
+                _recordNumber += 1;
+            }
+
+            return result;
+
+            void HandleError(FormatErrorMessage msgFactory, bool noThrow, ReaderErrorType readerErrorType, BinaryLogRecordKind recordKind, Exception? innerException = null)
+            {
+                if (noThrow)
+                {
+                    RecoverableReadError?.Invoke(new BinaryLogReaderErrorEventArgs(readerErrorType, recordKind, msgFactory));
+                    SkipBytes(_readStream.BytesCountAllowedToReadRemaining);
+                }
+                else
+                {
+                    throw new InvalidDataException(msgFactory(), innerException);
+                }
+            }
+        }
+
+        private BuildEventArgs? ReadBuildEventArgs(BinaryLogRecordKind recordKind)
+            => recordKind switch
+            {
+                BinaryLogRecordKind.BuildStarted => ReadBuildStartedEventArgs(),
+                BinaryLogRecordKind.BuildFinished => ReadBuildFinishedEventArgs(),
+                BinaryLogRecordKind.ProjectStarted => ReadProjectStartedEventArgs(),
+                BinaryLogRecordKind.ProjectFinished => ReadProjectFinishedEventArgs(),
+                BinaryLogRecordKind.TargetStarted => ReadTargetStartedEventArgs(),
+                BinaryLogRecordKind.TargetFinished => ReadTargetFinishedEventArgs(),
+                BinaryLogRecordKind.TaskStarted => ReadTaskStartedEventArgs(),
+                BinaryLogRecordKind.TaskFinished => ReadTaskFinishedEventArgs(),
+                BinaryLogRecordKind.Error => ReadBuildErrorEventArgs(),
+                BinaryLogRecordKind.Warning => ReadBuildWarningEventArgs(),
+                BinaryLogRecordKind.Message => ReadBuildMessageEventArgs(),
+                BinaryLogRecordKind.CriticalBuildMessage => ReadCriticalBuildMessageEventArgs(),
+                BinaryLogRecordKind.TaskCommandLine => ReadTaskCommandLineEventArgs(),
+                BinaryLogRecordKind.TaskParameter => ReadTaskParameterEventArgs(),
+                BinaryLogRecordKind.ProjectEvaluationStarted => ReadProjectEvaluationStartedEventArgs(),
+                BinaryLogRecordKind.ProjectEvaluationFinished => ReadProjectEvaluationFinishedEventArgs(),
+                BinaryLogRecordKind.ProjectImported => ReadProjectImportedEventArgs(),
+                BinaryLogRecordKind.TargetSkipped => ReadTargetSkippedEventArgs(),
+                BinaryLogRecordKind.EnvironmentVariableRead => ReadEnvironmentVariableReadEventArgs(),
+                BinaryLogRecordKind.ResponseFileUsed => ReadResponseFileUsedEventArgs(),
+                BinaryLogRecordKind.PropertyReassignment => ReadPropertyReassignmentEventArgs(),
+                BinaryLogRecordKind.UninitializedPropertyRead => ReadUninitializedPropertyReadEventArgs(),
+                BinaryLogRecordKind.PropertyInitialValueSet => ReadPropertyInitialValueSetEventArgs(),
+                BinaryLogRecordKind.AssemblyLoad => ReadAssemblyLoadEventArgs(),
+                _ => null
+            };
+
+        private void SkipBytes(int count)
+        {
+            _binaryReader.BaseStream.Seek(count, SeekOrigin.Current);
+        }
+
+        private BinaryLogRecordKind PreprocessRecordsTillNextEvent(Func<BinaryLogRecordKind, bool> isPreprocessRecord)
+        {
+            _readStream.BytesCountAllowedToRead = null;
+
             BinaryLogRecordKind recordKind = (BinaryLogRecordKind)ReadInt32();
 
             // Skip over data storage records since they don't result in a BuildEventArgs.
             // just ingest their data and continue.
-            while (IsAuxiliaryRecord(recordKind))
+            while (isPreprocessRecord(recordKind))
             {
                 // these are ordered by commonality
                 if (recordKind == BinaryLogRecordKind.String)
@@ -110,99 +345,19 @@ public void Dispose()
                 else if (recordKind == BinaryLogRecordKind.NameValueList)
                 {
                     ReadNameValueList();
+                    _readStream.BytesCountAllowedToRead = null;
                 }
                 else if (recordKind == BinaryLogRecordKind.ProjectImportArchive)
                 {
-                    ReadBlob(recordKind);
+                    ReadEmbeddedContent(recordKind);
                 }
 
-                recordNumber += 1;
+                _recordNumber += 1;
 
                 recordKind = (BinaryLogRecordKind)ReadInt32();
             }
 
-            BuildEventArgs? result = null;
-            switch (recordKind)
-            {
-                case BinaryLogRecordKind.EndOfFile:
-                    break;
-                case BinaryLogRecordKind.BuildStarted:
-                    result = ReadBuildStartedEventArgs();
-                    break;
-                case BinaryLogRecordKind.BuildFinished:
-                    result = ReadBuildFinishedEventArgs();
-                    break;
-                case BinaryLogRecordKind.ProjectStarted:
-                    result = ReadProjectStartedEventArgs();
-                    break;
-                case BinaryLogRecordKind.ProjectFinished:
-                    result = ReadProjectFinishedEventArgs();
-                    break;
-                case BinaryLogRecordKind.TargetStarted:
-                    result = ReadTargetStartedEventArgs();
-                    break;
-                case BinaryLogRecordKind.TargetFinished:
-                    result = ReadTargetFinishedEventArgs();
-                    break;
-                case BinaryLogRecordKind.TaskStarted:
-                    result = ReadTaskStartedEventArgs();
-                    break;
-                case BinaryLogRecordKind.TaskFinished:
-                    result = ReadTaskFinishedEventArgs();
-                    break;
-                case BinaryLogRecordKind.Error:
-                    result = ReadBuildErrorEventArgs();
-                    break;
-                case BinaryLogRecordKind.Warning:
-                    result = ReadBuildWarningEventArgs();
-                    break;
-                case BinaryLogRecordKind.Message:
-                    result = ReadBuildMessageEventArgs();
-                    break;
-                case BinaryLogRecordKind.CriticalBuildMessage:
-                    result = ReadCriticalBuildMessageEventArgs();
-                    break;
-                case BinaryLogRecordKind.TaskCommandLine:
-                    result = ReadTaskCommandLineEventArgs();
-                    break;
-                case BinaryLogRecordKind.TaskParameter:
-                    result = ReadTaskParameterEventArgs();
-                    break;
-                case BinaryLogRecordKind.ProjectEvaluationStarted:
-                    result = ReadProjectEvaluationStartedEventArgs();
-                    break;
-                case BinaryLogRecordKind.ProjectEvaluationFinished:
-                    result = ReadProjectEvaluationFinishedEventArgs();
-                    break;
-                case BinaryLogRecordKind.ProjectImported:
-                    result = ReadProjectImportedEventArgs();
-                    break;
-                case BinaryLogRecordKind.TargetSkipped:
-                    result = ReadTargetSkippedEventArgs();
-                    break;
-                case BinaryLogRecordKind.EnvironmentVariableRead:
-                    result = ReadEnvironmentVariableReadEventArgs();
-                    break;
-                case BinaryLogRecordKind.ResponseFileUsed:
-                    result = ReadResponseFileUsedEventArgs();
-                    break;
-                case BinaryLogRecordKind.PropertyReassignment:
-                    result = ReadPropertyReassignmentEventArgs();
-                    break;
-                case BinaryLogRecordKind.UninitializedPropertyRead:
-                    result = ReadUninitializedPropertyReadEventArgs();
-                    break;
-                case BinaryLogRecordKind.PropertyInitialValueSet:
-                    result = ReadPropertyInitialValueSetEventArgs();
-                    break;
-                case BinaryLogRecordKind.AssemblyLoad:
-                    result = ReadAssemblyLoadEventArgs();
-                    break;
-            }
-
-            recordNumber += 1;
-
-            return result;
+            return recordKind;
         }
 
         private static bool IsAuxiliaryRecord(BinaryLogRecordKind recordKind)
@@ -212,15 +367,94 @@ private static bool IsAuxiliaryRecord(BinaryLogRecordKind recordKind)
                 || recordKind == BinaryLogRecordKind.ProjectImportArchive;
         }
 
-        private void ReadBlob(BinaryLogRecordKind kind)
+        private static bool IsTextualDataRecord(BinaryLogRecordKind recordKind)
+        {
+            return recordKind == BinaryLogRecordKind.String
+                   || recordKind == BinaryLogRecordKind.ProjectImportArchive;
+        }
+
+        private void ReadEmbeddedContent(BinaryLogRecordKind recordKind)
         {
             int length = ReadInt32();
-            byte[] bytes = binaryReader.ReadBytes(length);
-            OnBlobRead?.Invoke(kind, bytes);
+
+            if (ArchiveFileEncountered != null)
+            {
+                // We could create ZipArchive over the target stream, and write to that directly,
+                //  however, binlog format needs to know stream size upfront - which is unknown,
+                //  so we would need to write the size after - and that would require the target stream to be seekable (which it's not)
+                ProjectImportsCollector? projectImportsCollector = null;
+
+                if (EmbeddedContentRead != null)
+                {
+                    projectImportsCollector =
+                        new ProjectImportsCollector(Path.GetRandomFileName(), false, runOnBackground: false);
+                }
+
+                Stream embeddedStream = _binaryReader.BaseStream.Slice(length);
+
+                // We are intentionally not grace handling corrupt embedded stream
+
+                using var zipArchive = new ZipArchive(embeddedStream, ZipArchiveMode.Read);
+
+                foreach (var entry in zipArchive.Entries/*.OrderBy(e => e.LastWriteTime)*/)
+                {
+                    var file = ArchiveStream.From(entry);
+                    ArchiveFileEventArgs archiveFileEventArgs = new(file);
+                    // ArchiveFileEventArgs is not IDisposable as we do not want to clutter exposed API
+                    using var cleanupScope = new CleanupScope(archiveFileEventArgs.Dispose);
+                    ArchiveFileEncountered(archiveFileEventArgs);
+
+                    if (projectImportsCollector != null)
+                    {
+                        var resultFile = archiveFileEventArgs.ArchiveData;
+
+                        if (resultFile is ArchiveStream archiveStream)
+                        {
+                            projectImportsCollector.AddFileFromMemory(
+                                archiveStream.FullPath,
+                                archiveStream.ContentReader.BaseStream,
+                                makePathAbsolute: false,
+                                entryCreationStamp: entry.LastWriteTime);
+                        }
+                        else
+                        {
+                            projectImportsCollector.AddFileFromMemory(
+                                resultFile.FullPath,
+                                resultFile.ToArchiveFile().Content,
+                                makePathAbsolute: false,
+                                entryCreationStamp: entry.LastWriteTime);
+                        }
+                    }
+                }
+
+                // Once embedded files are replayed one by one - we can send the resulting stream to subscriber
+                if (EmbeddedContentRead != null)
+                {
+                    projectImportsCollector!.ProcessResult(
+                        streamToEmbed => EmbeddedContentRead(new EmbeddedContentEventArgs(recordKind, streamToEmbed)),
+                        error => throw new InvalidDataException(error));
+                    projectImportsCollector.DeleteArchive();
+                }
+            }
+            else if (EmbeddedContentRead != null)
+            {
+                EmbeddedContentRead(new EmbeddedContentEventArgs(
+                    recordKind,
+                    _binaryReader.BaseStream.Slice(length)));
+            }
+            else
+            {
+                SkipBytes(length);
+            }
         }
 
         private void ReadNameValueList()
         {
+            if (_fileFormatVersion >= BinaryLogger.ForwardCompatibilityMinimalVersion)
+            {
+                _readStream.BytesCountAllowedToRead = ReadInt32();
+            }
+
             int count = ReadInt32();
 
             var list = new (int, int)[count];
@@ -262,7 +496,7 @@ private IDictionary<string, string> GetNameValueList(int id)
 
             // this should never happen for valid binlogs
             throw new InvalidDataException(
-                $"NameValueList record number {recordNumber} is invalid: index {id} is not within {stringRecords.Count}.");
+                $"NameValueList record number {_recordNumber} is invalid: index {id} is not within {nameValueListRecords.Count}.");
         }
 
         private readonly StringReadEventArgs stringReadEventArgs = new StringReadEventArgs(string.Empty);
@@ -280,7 +514,7 @@ private BuildEventArgs ReadProjectImportedEventArgs()
             bool importIgnored = false;
 
             // the ImportIgnored field was introduced in file format version 3
-            if (fileFormatVersion > 2)
+            if (_fileFormatVersion > 2)
             {
                 importIgnored = ReadBoolean();
             }
@@ -317,7 +551,7 @@ private BuildEventArgs ReadTargetSkippedEventArgs()
             bool originallySucceeded = false;
             TargetSkipReason skipReason = TargetSkipReason.None;
             BuildEventContext? originalBuildEventContext = null;
-            if (fileFormatVersion >= 13)
+            if (_fileFormatVersion >= 13)
             {
                 condition = ReadOptionalString();
                 evaluatedCondition = ReadOptionalString();
@@ -333,10 +567,10 @@ private BuildEventArgs ReadTargetSkippedEventArgs()
 
             var buildReason = (TargetBuiltReason)ReadInt32();
 
-            if (fileFormatVersion >= 14)
+            if (_fileFormatVersion >= 14)
             {
                 skipReason = (TargetSkipReason)ReadInt32();
-                originalBuildEventContext = binaryReader.ReadOptionalBuildEventContext();
+                originalBuildEventContext = _binaryReader.ReadOptionalBuildEventContext();
             }
 
             var e = new TargetSkippedEventArgs(
@@ -417,10 +651,15 @@ private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
             };
             SetCommonFields(e, fields);
 
-            if (fileFormatVersion >= 12)
+            if (_fileFormatVersion >= 12)
             {
                 IEnumerable? globalProperties = null;
-                if (ReadBoolean())
+                // In newer versions, we store the global properties always, as it handles
+                //  null and empty within WriteProperties already.
+                // This saves a single boolean, but mainly doesn't hide the difference between null and empty
+                //  during write->read roundtrip.
+                if (_fileFormatVersion >= BinaryLogger.ForwardCompatibilityMinimalVersion ||
+                    ReadBoolean())
                 {
                     globalProperties = ReadStringDictionary();
                 }
@@ -434,7 +673,7 @@ private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
             }
 
             // ProfilerResult was introduced in version 5
-            if (fileFormatVersion > 4)
+            if (_fileFormatVersion > 4)
             {
                 var hasProfileData = ReadBoolean();
                 if (hasProfileData)
@@ -472,9 +711,11 @@ private BuildEventArgs ReadProjectStartedEventArgs()
 
             IDictionary<string, string>? globalProperties = null;
 
-            if (fileFormatVersion > 6)
+            if (_fileFormatVersion > 6)
             {
-                if (ReadBoolean())
+                // See ReadProjectEvaluationFinishedEventArgs for details on why we always store global properties in newer version.
+                if (_fileFormatVersion >= BinaryLogger.ForwardCompatibilityMinimalVersion ||
+                    ReadBoolean())
                 {
                     globalProperties = ReadStringDictionary();
                 }
@@ -522,7 +763,7 @@ private BuildEventArgs ReadTargetStartedEventArgs()
             var targetFile = ReadOptionalString();
             var parentTarget = ReadOptionalString();
             // BuildReason was introduced in version 4
-            var buildReason = fileFormatVersion > 3 ? (TargetBuiltReason)ReadInt32() : TargetBuiltReason.None;
+            var buildReason = _fileFormatVersion > 3 ? (TargetBuiltReason)ReadInt32() : TargetBuiltReason.None;
 
             var e = new TargetStartedEventArgs(
                 fields.Message,
@@ -642,7 +883,7 @@ private BuildEventArgs ReadBuildErrorEventArgs()
                     fields.Arguments)
                 {
                     ProjectFile = fields.ProjectFile,
-                    ExtendedMetadata = fields.Extended.ExtendedMetadata,
+                    ExtendedMetadata = fields.Extended.ExtendedMetadataAsDictionary,
                     ExtendedData = fields.Extended.ExtendedData,
                 };
             }
@@ -694,7 +935,7 @@ private BuildEventArgs ReadBuildWarningEventArgs()
                     fields.Arguments)
                 {
                     ProjectFile = fields.ProjectFile,
-                    ExtendedMetadata = fields.Extended.ExtendedMetadata,
+                    ExtendedMetadata = fields.Extended.ExtendedMetadataAsDictionary,
                     ExtendedData = fields.Extended.ExtendedData,
                 };
             }
@@ -747,7 +988,7 @@ private BuildEventArgs ReadBuildMessageEventArgs()
                     fields.Arguments)
                 {
                     ProjectFile = fields.ProjectFile,
-                    ExtendedMetadata = fields.Extended?.ExtendedMetadata,
+                    ExtendedMetadata = fields.Extended?.ExtendedMetadataAsDictionary,
                     ExtendedData = fields.Extended?.ExtendedData,
                 };
             }
@@ -836,7 +1077,7 @@ private BuildEventArgs ReadCriticalBuildMessageEventArgs()
                     fields.Arguments)
                 {
                     ProjectFile = fields.ProjectFile,
-                    ExtendedMetadata = fields.Extended?.ExtendedMetadata,
+                    ExtendedMetadata = fields.Extended?.ExtendedMetadataAsDictionary,
                     ExtendedData = fields.Extended?.ExtendedData,
                 };
             }
@@ -950,6 +1191,7 @@ private AssemblyLoadBuildEventArgs ReadAssemblyLoadEventArgs()
                 mvid,
                 appDomainName);
             SetCommonFields(e, fields);
+            e.ProjectFile = fields.ProjectFile;
 
             return e;
         }
@@ -1078,7 +1320,7 @@ private BuildEventArgsFields ReadBuildEventArgsFields(bool readImportance = fals
                 result.Arguments = arguments;
             }
 
-            if ((fileFormatVersion < 13 && readImportance) || (fileFormatVersion >= 13 && (flags & BuildEventArgsFieldFlags.Importance) != 0))
+            if ((_fileFormatVersion < 13 && readImportance) || (_fileFormatVersion >= 13 && (flags & BuildEventArgsFieldFlags.Importance) != 0))
             {
                 result.Importance = (MessageImportance)ReadInt32();
             }
@@ -1137,7 +1379,7 @@ private BuildEventContext ReadBuildEventContext()
 
             // evaluationId was introduced in format version 2
             int evaluationId = BuildEventContext.InvalidEvaluationId;
-            if (fileFormatVersion > 1)
+            if (_fileFormatVersion > 1)
             {
                 evaluationId = ReadInt32();
             }
@@ -1155,7 +1397,7 @@ private BuildEventContext ReadBuildEventContext()
 
         private IDictionary<string, string>? ReadStringDictionary()
         {
-            if (fileFormatVersion < 10)
+            if (_fileFormatVersion < 10)
             {
                 return ReadLegacyStringDictionary();
             }
@@ -1207,7 +1449,7 @@ private ITaskItem ReadTaskItem()
             // so we only have to write the name once, and then the count of items
             // with that name. When reading a legacy binlog we need to read the
             // old style flat list where the name is duplicated for each item.
-            if (fileFormatVersion < 10)
+            if (_fileFormatVersion < 10)
             {
                 int count = ReadInt32();
                 if (count == 0)
@@ -1223,7 +1465,7 @@ private ITaskItem ReadTaskItem()
                     list[i] = new DictionaryEntry(itemName, item);
                 }
             }
-            else if (fileFormatVersion < 12)
+            else if (_fileFormatVersion < 12)
             {
                 int count = ReadInt32();
                 if (count == 0)
@@ -1302,8 +1544,7 @@ private ITaskItem ReadTaskItem()
 
         private string ReadString()
         {
-            this.StringEncountered?.Invoke();
-            string text = binaryReader.ReadString();
+            string text = _binaryReader.ReadString();
             if (this.StringReadDone != null)
             {
                 stringReadEventArgs.Reuse(text);
@@ -1315,7 +1556,7 @@ private string ReadString()
 
         private string? ReadOptionalString()
         {
-            if (fileFormatVersion < 10)
+            if (_fileFormatVersion < 10)
             {
                 if (ReadBoolean())
                 {
@@ -1332,7 +1573,7 @@ private string ReadString()
 
         private string? ReadDeduplicatedString()
         {
-            if (fileFormatVersion < 10)
+            if (_fileFormatVersion < 10)
             {
                 return ReadString();
             }
@@ -1364,7 +1605,7 @@ private string ReadString()
 
             // this should never happen for valid binlogs
             throw new InvalidDataException(
-                $"String record number {recordNumber} is invalid: string index {index} is not within {stringRecords.Count}.");
+                $"String record number {_recordNumber} is invalid: string index {index} is not within {stringRecords.Count}.");
         }
 
         private int ReadInt32()
@@ -1372,32 +1613,32 @@ private int ReadInt32()
             // on some platforms (net5) this method was added to BinaryReader
             // but it's not available on others. Call our own extension method
             // explicitly to avoid ambiguity.
-            return BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
+            return BinaryReaderExtensions.Read7BitEncodedInt(_binaryReader);
         }
 
         private long ReadInt64()
         {
-            return binaryReader.ReadInt64();
+            return _binaryReader.ReadInt64();
         }
 
         private bool ReadBoolean()
         {
-            return binaryReader.ReadBoolean();
+            return _binaryReader.ReadBoolean();
         }
 
         private Guid ReadGuid()
         {
-            return new Guid(binaryReader.ReadBytes(16 /*sizeof(Guid) - to avoid unsafe context, Guid will never change in size */));
+            return new Guid(_binaryReader.ReadBytes(16 /*sizeof(Guid) - to avoid unsafe context, Guid will never change in size */));
         }
 
         private DateTime ReadDateTime()
         {
-            return new DateTime(binaryReader.ReadInt64(), (DateTimeKind)ReadInt32());
+            return new DateTime(_binaryReader.ReadInt64(), (DateTimeKind)ReadInt32());
         }
 
         private TimeSpan ReadTimeSpan()
         {
-            return new TimeSpan(binaryReader.ReadInt64());
+            return new TimeSpan(_binaryReader.ReadInt64());
         }
 
         private ProfiledLocation ReadProfiledLocation()
@@ -1426,7 +1667,7 @@ private EvaluationLocation ReadEvaluationLocation()
             }
 
             // Id and parent Id were introduced in version 6
-            if (fileFormatVersion > 5)
+            if (_fileFormatVersion > 5)
             {
                 var id = ReadInt64();
                 long? parentId = null;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 0a21182e83c..8a8311e1fd6 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Buffers;
 using System.Collections;
 using System.Collections.Generic;
 using System.Globalization;
@@ -35,6 +36,13 @@ internal class BuildEventArgsWriter
         /// </summary>
         private readonly MemoryStream currentRecordStream;
 
+        /// <summary>
+        /// For NameValueList we need to prefix the storage size
+        ///  (distinct from values count due to variable int encoding)
+        /// So using same technique as with 'currentRecordStream'.
+        /// </summary>
+        private readonly MemoryStream nameValueListStream;
+
         /// <summary>
         /// The binary writer around the originalStream.
         /// </summary>
@@ -121,6 +129,8 @@ public BuildEventArgsWriter(BinaryWriter binaryWriter)
             // starting point to avoid reallocations in the common case
             this.currentRecordStream = new MemoryStream(65536);
 
+            this.nameValueListStream = new MemoryStream(256);
+
             this.originalBinaryWriter = binaryWriter;
             this.currentRecordWriter = new BinaryWriter(currentRecordStream);
 
@@ -132,11 +142,20 @@ public BuildEventArgsWriter(BinaryWriter binaryWriter)
         /// </summary>
         public void Write(BuildEventArgs e)
         {
-            WriteCore(e);
+            // reset the temp stream (in case last usage forgot to do so).
+            this.currentRecordStream.SetLength(0);
+            BinaryLogRecordKind eventKind = WriteCore(e);
 
-            // flush the current record and clear the MemoryStream to prepare for next use
-            currentRecordStream.WriteTo(originalStream);
-            currentRecordStream.SetLength(0);
+            FlushRecordToFinalStream(eventKind, currentRecordStream);
+        }
+
+        private void FlushRecordToFinalStream(BinaryLogRecordKind recordKind, MemoryStream recordStream)
+        {
+            using var redirectionScope = RedirectWritesToOriginalWriter();
+            Write(recordKind);
+            Write((int)recordStream.Length);
+            recordStream.WriteTo(originalStream);
+            recordStream.SetLength(0);
         }
 
         /*
@@ -178,23 +197,23 @@ Base types and inheritance ("EventArgs" suffix omitted):
                     ExtendedCustomBuild
         */
 
-        private void WriteCore(BuildEventArgs e)
+        private BinaryLogRecordKind WriteCore(BuildEventArgs e)
         {
             switch (e)
             {
-                case BuildMessageEventArgs buildMessage: Write(buildMessage); break;
-                case TaskStartedEventArgs taskStarted: Write(taskStarted); break;
-                case TaskFinishedEventArgs taskFinished: Write(taskFinished); break;
-                case TargetStartedEventArgs targetStarted: Write(targetStarted); break;
-                case TargetFinishedEventArgs targetFinished: Write(targetFinished); break;
-                case BuildErrorEventArgs buildError: Write(buildError); break;
-                case BuildWarningEventArgs buildWarning: Write(buildWarning); break;
-                case ProjectStartedEventArgs projectStarted: Write(projectStarted); break;
-                case ProjectFinishedEventArgs projectFinished: Write(projectFinished); break;
-                case BuildStartedEventArgs buildStarted: Write(buildStarted); break;
-                case BuildFinishedEventArgs buildFinished: Write(buildFinished); break;
-                case ProjectEvaluationStartedEventArgs projectEvaluationStarted: Write(projectEvaluationStarted); break;
-                case ProjectEvaluationFinishedEventArgs projectEvaluationFinished: Write(projectEvaluationFinished); break;
+                case BuildMessageEventArgs buildMessage: return Write(buildMessage);
+                case TaskStartedEventArgs taskStarted: return Write(taskStarted);
+                case TaskFinishedEventArgs taskFinished: return Write(taskFinished);
+                case TargetStartedEventArgs targetStarted: return Write(targetStarted);
+                case TargetFinishedEventArgs targetFinished: return Write(targetFinished);
+                case BuildErrorEventArgs buildError: return Write(buildError);
+                case BuildWarningEventArgs buildWarning: return Write(buildWarning);
+                case ProjectStartedEventArgs projectStarted: return Write(projectStarted);
+                case ProjectFinishedEventArgs projectFinished: return Write(projectFinished);
+                case BuildStartedEventArgs buildStarted: return Write(buildStarted);
+                case BuildFinishedEventArgs buildFinished: return Write(buildFinished);
+                case ProjectEvaluationStartedEventArgs projectEvaluationStarted: return Write(projectEvaluationStarted);
+                case ProjectEvaluationFinishedEventArgs projectEvaluationFinished: return Write(projectEvaluationFinished);
                 default:
                     // convert all unrecognized objects to message
                     // and just preserve the message
@@ -224,25 +243,13 @@ private void WriteCore(BuildEventArgs e)
                             e.Timestamp);
                     }
                     buildMessageEventArgs.BuildEventContext = e.BuildEventContext ?? BuildEventContext.Invalid;
-                    Write(buildMessageEventArgs);
-                    break;
+                    return Write(buildMessageEventArgs);
             }
         }
 
-        public void WriteBlob(BinaryLogRecordKind kind, byte[] bytes)
-        {
-            // write the blob directly to the underlying writer,
-            // bypassing the memory stream
-            using var redirection = RedirectWritesToOriginalWriter();
-
-            Write(kind);
-            Write(bytes.Length);
-            Write(bytes);
-        }
-
         public void WriteBlob(BinaryLogRecordKind kind, Stream stream)
         {
-            if (stream.Length > int.MaxValue)
+            if (stream.CanSeek && stream.Length > int.MaxValue)
             {
                 throw new ArgumentOutOfRangeException(nameof(stream));
             }
@@ -253,7 +260,7 @@ public void WriteBlob(BinaryLogRecordKind kind, Stream stream)
 
             Write(kind);
             Write((int)stream.Length);
-            Write(stream);
+            WriteToOriginalStream(stream);
         }
 
         /// <summary>
@@ -263,28 +270,17 @@ public void WriteBlob(BinaryLogRecordKind kind, Stream stream)
         /// </summary>
         private IDisposable RedirectWritesToOriginalWriter()
         {
-            binaryWriter = originalBinaryWriter;
-            return new RedirectionScope(this);
+            return RedirectWritesToDifferentWriter(originalBinaryWriter, currentRecordWriter);
         }
 
-        private struct RedirectionScope : IDisposable
+        private IDisposable RedirectWritesToDifferentWriter(BinaryWriter inScopeWriter, BinaryWriter afterScopeWriter)
         {
-            private readonly BuildEventArgsWriter _writer;
-
-            public RedirectionScope(BuildEventArgsWriter buildEventArgsWriter)
-            {
-                _writer = buildEventArgsWriter;
-            }
-
-            public void Dispose()
-            {
-                _writer.binaryWriter = _writer.currentRecordWriter;
-            }
+            binaryWriter = inScopeWriter;
+            return new CleanupScope(() => binaryWriter = afterScopeWriter);
         }
 
-        private void Write(BuildStartedEventArgs e)
+        private BinaryLogRecordKind Write(BuildStartedEventArgs e)
         {
-            Write(BinaryLogRecordKind.BuildStarted);
             WriteBuildEventArgsFields(e);
             if (Traits.LogAllEnvironmentVariables)
             {
@@ -294,38 +290,31 @@ private void Write(BuildStartedEventArgs e)
             {
                 Write(e.BuildEnvironment?.Where(kvp => EnvironmentUtilities.IsWellKnownEnvironmentDerivedProperty(kvp.Key)));
             }
+
+            return BinaryLogRecordKind.BuildStarted;
         }
 
-        private void Write(BuildFinishedEventArgs e)
+        private BinaryLogRecordKind Write(BuildFinishedEventArgs e)
         {
-            Write(BinaryLogRecordKind.BuildFinished);
             WriteBuildEventArgsFields(e);
             Write(e.Succeeded);
+
+            return BinaryLogRecordKind.BuildFinished;
         }
 
-        private void Write(ProjectEvaluationStartedEventArgs e)
+        private BinaryLogRecordKind Write(ProjectEvaluationStartedEventArgs e)
         {
-            Write(BinaryLogRecordKind.ProjectEvaluationStarted);
             WriteBuildEventArgsFields(e, writeMessage: false);
             WriteDeduplicatedString(e.ProjectFile);
+            return BinaryLogRecordKind.ProjectEvaluationStarted;
         }
 
-        private void Write(ProjectEvaluationFinishedEventArgs e)
+        private BinaryLogRecordKind Write(ProjectEvaluationFinishedEventArgs e)
         {
-            Write(BinaryLogRecordKind.ProjectEvaluationFinished);
-
             WriteBuildEventArgsFields(e, writeMessage: false);
             WriteDeduplicatedString(e.ProjectFile);
 
-            if (e.GlobalProperties == null)
-            {
-                Write(false);
-            }
-            else
-            {
-                Write(true);
-                WriteProperties(e.GlobalProperties);
-            }
+            WriteProperties(e.GlobalProperties);
 
             WriteProperties(e.Properties);
 
@@ -343,11 +332,12 @@ private void Write(ProjectEvaluationFinishedEventArgs e)
                     Write(item.Value);
                 }
             }
+
+            return BinaryLogRecordKind.ProjectEvaluationFinished;
         }
 
-        private void Write(ProjectStartedEventArgs e)
+        private BinaryLogRecordKind Write(ProjectStartedEventArgs e)
         {
-            Write(BinaryLogRecordKind.ProjectStarted);
             WriteBuildEventArgsFields(e, writeMessage: false);
 
             if (e.ParentProjectBuildEventContext == null)
@@ -366,75 +356,73 @@ private void Write(ProjectStartedEventArgs e)
             WriteDeduplicatedString(e.TargetNames);
             WriteDeduplicatedString(e.ToolsVersion);
 
-            if (e.GlobalProperties == null)
-            {
-                Write(false);
-            }
-            else
-            {
-                Write(true);
-                Write(e.GlobalProperties);
-            }
+            Write(e.GlobalProperties);
 
             WriteProperties(e.Properties);
 
             WriteProjectItems(e.Items);
+
+            return BinaryLogRecordKind.ProjectStarted;
         }
 
-        private void Write(ProjectFinishedEventArgs e)
+        private BinaryLogRecordKind Write(ProjectFinishedEventArgs e)
         {
-            Write(BinaryLogRecordKind.ProjectFinished);
             WriteBuildEventArgsFields(e, writeMessage: false);
             WriteDeduplicatedString(e.ProjectFile);
             Write(e.Succeeded);
+
+            return BinaryLogRecordKind.ProjectFinished;
         }
 
-        private void Write(TargetStartedEventArgs e)
+        private BinaryLogRecordKind Write(TargetStartedEventArgs e)
         {
-            Write(BinaryLogRecordKind.TargetStarted);
             WriteBuildEventArgsFields(e, writeMessage: false);
             WriteDeduplicatedString(e.TargetName);
             WriteDeduplicatedString(e.ProjectFile);
             WriteDeduplicatedString(e.TargetFile);
             WriteDeduplicatedString(e.ParentTarget);
             Write((int)e.BuildReason);
+
+            return BinaryLogRecordKind.TargetStarted;
         }
 
-        private void Write(TargetFinishedEventArgs e)
+        private BinaryLogRecordKind Write(TargetFinishedEventArgs e)
         {
-            Write(BinaryLogRecordKind.TargetFinished);
             WriteBuildEventArgsFields(e, writeMessage: false);
             Write(e.Succeeded);
             WriteDeduplicatedString(e.ProjectFile);
             WriteDeduplicatedString(e.TargetFile);
             WriteDeduplicatedString(e.TargetName);
             WriteTaskItemList(e.TargetOutputs);
+
+            return BinaryLogRecordKind.TargetFinished;
         }
 
-        private void Write(TaskStartedEventArgs e)
+        private BinaryLogRecordKind Write(TaskStartedEventArgs e)
         {
-            Write(BinaryLogRecordKind.TaskStarted);
             WriteBuildEventArgsFields(e, writeMessage: false, writeLineAndColumn: true);
             Write(e.LineNumber);
             Write(e.ColumnNumber);
             WriteDeduplicatedString(e.TaskName);
             WriteDeduplicatedString(e.ProjectFile);
             WriteDeduplicatedString(e.TaskFile);
+
+            return BinaryLogRecordKind.TaskStarted;
         }
 
-        private void Write(TaskFinishedEventArgs e)
+        private BinaryLogRecordKind Write(TaskFinishedEventArgs e)
         {
-            Write(BinaryLogRecordKind.TaskFinished);
             WriteBuildEventArgsFields(e, writeMessage: false);
             Write(e.Succeeded);
             WriteDeduplicatedString(e.TaskName);
             WriteDeduplicatedString(e.ProjectFile);
             WriteDeduplicatedString(e.TaskFile);
+
+            return BinaryLogRecordKind.TaskFinished;
         }
 
-        private void Write(BuildErrorEventArgs e)
+        private BinaryLogRecordKind Write(BuildErrorEventArgs e)
         {
-            Write(BinaryLogRecordKind.Error);
             WriteBuildEventArgsFields(e);
             WriteArguments(e.RawArguments);
             WriteDeduplicatedString(e.Subcategory);
@@ -445,11 +433,12 @@ private void Write(BuildErrorEventArgs e)
             Write(e.ColumnNumber);
             Write(e.EndLineNumber);
             Write(e.EndColumnNumber);
+
+            return BinaryLogRecordKind.Error;
         }
 
-        private void Write(BuildWarningEventArgs e)
+        private BinaryLogRecordKind Write(BuildWarningEventArgs e)
         {
-            Write(BinaryLogRecordKind.Warning);
             WriteBuildEventArgsFields(e);
             WriteArguments(e.RawArguments);
             WriteDeduplicatedString(e.Subcategory);
@@ -460,42 +449,42 @@ private void Write(BuildWarningEventArgs e)
             Write(e.ColumnNumber);
             Write(e.EndLineNumber);
             Write(e.EndColumnNumber);
+
+            return BinaryLogRecordKind.Warning;
         }
 
-        private void Write(BuildMessageEventArgs e)
+        private BinaryLogRecordKind Write(BuildMessageEventArgs e)
         {
             switch (e)
             {
-                case ResponseFileUsedEventArgs responseFileUsed: Write(responseFileUsed); break;
-                case TaskParameterEventArgs taskParameter: Write(taskParameter); break;
-                case ProjectImportedEventArgs projectImported: Write(projectImported); break;
-                case TargetSkippedEventArgs targetSkipped: Write(targetSkipped); break;
-                case PropertyReassignmentEventArgs propertyReassignment: Write(propertyReassignment); break;
-                case TaskCommandLineEventArgs taskCommandLine: Write(taskCommandLine); break;
-                case UninitializedPropertyReadEventArgs uninitializedPropertyRead: Write(uninitializedPropertyRead); break;
-                case EnvironmentVariableReadEventArgs environmentVariableRead: Write(environmentVariableRead); break;
-                case PropertyInitialValueSetEventArgs propertyInitialValueSet: Write(propertyInitialValueSet); break;
-                case CriticalBuildMessageEventArgs criticalBuildMessage: Write(criticalBuildMessage); break;
-                case AssemblyLoadBuildEventArgs assemblyLoad: Write(assemblyLoad); break;
+                case ResponseFileUsedEventArgs responseFileUsed: return Write(responseFileUsed);
+                case TaskParameterEventArgs taskParameter: return Write(taskParameter);
+                case ProjectImportedEventArgs projectImported: return Write(projectImported);
+                case TargetSkippedEventArgs targetSkipped: return Write(targetSkipped);
+                case PropertyReassignmentEventArgs propertyReassignment: return Write(propertyReassignment);
+                case TaskCommandLineEventArgs taskCommandLine: return Write(taskCommandLine);
+                case UninitializedPropertyReadEventArgs uninitializedPropertyRead: return Write(uninitializedPropertyRead);
+                case EnvironmentVariableReadEventArgs environmentVariableRead: return Write(environmentVariableRead);
+                case PropertyInitialValueSetEventArgs propertyInitialValueSet: return Write(propertyInitialValueSet);
+                case CriticalBuildMessageEventArgs criticalBuildMessage: return Write(criticalBuildMessage);
+                case AssemblyLoadBuildEventArgs assemblyLoad: return Write(assemblyLoad);
                 default: // actual BuildMessageEventArgs
-                    Write(BinaryLogRecordKind.Message);
                     WriteMessageFields(e, writeImportance: true);
-                    break;
+                    return BinaryLogRecordKind.Message;
             }
         }
 
-        private void Write(ProjectImportedEventArgs e)
+        private BinaryLogRecordKind Write(ProjectImportedEventArgs e)
         {
-            Write(BinaryLogRecordKind.ProjectImported);
             WriteMessageFields(e);
             Write(e.ImportIgnored);
             WriteDeduplicatedString(e.ImportedProjectFile);
             WriteDeduplicatedString(e.UnexpandedProject);
+            return BinaryLogRecordKind.ProjectImported;
         }
 
-        private void Write(TargetSkippedEventArgs e)
+        private BinaryLogRecordKind Write(TargetSkippedEventArgs e)
         {
-            Write(BinaryLogRecordKind.TargetSkipped);
             WriteMessageFields(e, writeMessage: false);
             WriteDeduplicatedString(e.TargetFile);
             WriteDeduplicatedString(e.TargetName);
@@ -506,11 +495,11 @@ private void Write(TargetSkippedEventArgs e)
             Write((int)e.BuildReason);
             Write((int)e.SkipReason);
             binaryWriter.WriteOptionalBuildEventContext(e.OriginalBuildEventContext);
+            return BinaryLogRecordKind.TargetSkipped;
         }
 
-        private void Write(AssemblyLoadBuildEventArgs e)
+        private BinaryLogRecordKind Write(AssemblyLoadBuildEventArgs e)
         {
-            Write(BinaryLogRecordKind.AssemblyLoad);
             WriteMessageFields(e, writeMessage: false, writeImportance: false);
             Write((int)e.LoadingContext);
             WriteDeduplicatedString(e.LoadingInitiator);
@@ -518,63 +507,63 @@ private void Write(AssemblyLoadBuildEventArgs e)
             WriteDeduplicatedString(e.AssemblyPath);
             Write(e.MVID);
             WriteDeduplicatedString(e.AppDomainDescriptor);
+            return BinaryLogRecordKind.AssemblyLoad;
         }
 
-        private void Write(CriticalBuildMessageEventArgs e)
+        private BinaryLogRecordKind Write(CriticalBuildMessageEventArgs e)
         {
-            Write(BinaryLogRecordKind.CriticalBuildMessage);
             WriteMessageFields(e);
+            return BinaryLogRecordKind.CriticalBuildMessage;
         }
 
-        private void Write(PropertyReassignmentEventArgs e)
+        private BinaryLogRecordKind Write(PropertyReassignmentEventArgs e)
         {
-            Write(BinaryLogRecordKind.PropertyReassignment);
             WriteMessageFields(e, writeMessage: false, writeImportance: true);
             WriteDeduplicatedString(e.PropertyName);
             WriteDeduplicatedString(e.PreviousValue);
             WriteDeduplicatedString(e.NewValue);
             WriteDeduplicatedString(e.Location);
+            return BinaryLogRecordKind.PropertyReassignment;
         }
 
-        private void Write(UninitializedPropertyReadEventArgs e)
+        private BinaryLogRecordKind Write(UninitializedPropertyReadEventArgs e)
         {
-            Write(BinaryLogRecordKind.UninitializedPropertyRead);
             WriteMessageFields(e, writeImportance: true);
             WriteDeduplicatedString(e.PropertyName);
+            return BinaryLogRecordKind.UninitializedPropertyRead;
         }
 
-        private void Write(PropertyInitialValueSetEventArgs e)
+        private BinaryLogRecordKind Write(PropertyInitialValueSetEventArgs e)
         {
-            Write(BinaryLogRecordKind.PropertyInitialValueSet);
             WriteMessageFields(e, writeImportance: true);
             WriteDeduplicatedString(e.PropertyName);
             WriteDeduplicatedString(e.PropertyValue);
             WriteDeduplicatedString(e.PropertySource);
+            return BinaryLogRecordKind.PropertyInitialValueSet;
         }
 
-        private void Write(EnvironmentVariableReadEventArgs e)
+        private BinaryLogRecordKind Write(EnvironmentVariableReadEventArgs e)
         {
-            Write(BinaryLogRecordKind.EnvironmentVariableRead);
             WriteMessageFields(e, writeImportance: true);
             WriteDeduplicatedString(e.EnvironmentVariableName);
+            return BinaryLogRecordKind.EnvironmentVariableRead;
         }
-        private void Write(ResponseFileUsedEventArgs e)
+        private BinaryLogRecordKind Write(ResponseFileUsedEventArgs e)
         {
-            Write(BinaryLogRecordKind.ResponseFileUsed);
             WriteMessageFields(e);
             WriteDeduplicatedString(e.ResponseFilePath);
+            return BinaryLogRecordKind.ResponseFileUsed;
         }
-        private void Write(TaskCommandLineEventArgs e)
+        private BinaryLogRecordKind Write(TaskCommandLineEventArgs e)
         {
-            Write(BinaryLogRecordKind.TaskCommandLine);
             WriteMessageFields(e, writeMessage: false, writeImportance: true);
             WriteDeduplicatedString(e.CommandLine);
             WriteDeduplicatedString(e.TaskName);
+            return BinaryLogRecordKind.TaskCommandLine;
         }
 
-        private void Write(TaskParameterEventArgs e)
+        private BinaryLogRecordKind Write(TaskParameterEventArgs e)
         {
-            Write(BinaryLogRecordKind.TaskParameter);
             WriteMessageFields(e, writeMessage: false);
             Write((int)e.Kind);
             WriteDeduplicatedString(e.ItemType);
@@ -584,6 +573,7 @@ private void Write(TaskParameterEventArgs e)
             {
                 CheckForFilesToEmbed(e.ItemType, e.Items);
             }
+            return BinaryLogRecordKind.TaskParameter;
         }
 
         private void WriteBuildEventArgsFields(BuildEventArgs e, bool writeMessage = true, bool writeLineAndColumn = false)
@@ -1078,19 +1068,27 @@ private void WriteNameValueList()
         /// </summary>
         private void WriteNameValueListRecord()
         {
-            // Switch the binaryWriter used by the Write* methods to the direct underlying stream writer.
             // We want this record to precede the record we're currently writing to currentRecordWriter
-            // which is backed by a MemoryStream buffer
-            using var redirectionScope = RedirectWritesToOriginalWriter();
+            // We as well want to know the storage size (differs from nameValueIndexListBuffer.Count as
+            //  we use variable integer encoding).
+            // So we redirect the writes to a MemoryStream and then flush the record to the final stream.
+            // All that is redirected away from the 'currentRecordStream' - that will be flushed last
+
+            nameValueListStream.SetLength(0);
+            var nameValueListBw = new BinaryWriter(nameValueListStream);
 
-            Write(BinaryLogRecordKind.NameValueList);
-            Write(nameValueIndexListBuffer.Count);
-            for (int i = 0; i < nameValueListBuffer.Count; i++)
+            using (var _ = RedirectWritesToDifferentWriter(nameValueListBw, binaryWriter))
             {
-                var kvp = nameValueIndexListBuffer[i];
-                Write(kvp.Key);
-                Write(kvp.Value);
+                Write(nameValueIndexListBuffer.Count);
+                for (int i = 0; i < nameValueListBuffer.Count; i++)
+                {
+                    var kvp = nameValueIndexListBuffer[i];
+                    Write(kvp.Key);
+                    Write(kvp.Value);
+                }
             }
+
+            FlushRecordToFinalStream(BinaryLogRecordKind.NameValueList, nameValueListStream);
         }
 
         /// <summary>
@@ -1124,7 +1122,7 @@ private void Write(BinaryLogRecordKind kind)
             Write((int)kind);
         }
 
-        private void Write(int value)
+        internal void Write(int value)
         {
             BinaryWriterExtensions.Write7BitEncodedInt(binaryWriter, value);
         }
@@ -1139,9 +1137,12 @@ private void Write(byte[] bytes)
             binaryWriter.Write(bytes);
         }
 
-        private void Write(Stream stream)
+        private void WriteToOriginalStream(Stream stream)
         {
-            stream.CopyTo(binaryWriter.BaseStream);
+            // WARNING: avoid calling binaryWriter.BaseStream here
+            // as it will flush the underlying stream - since that is a
+            // BufferedStream it will make buffering nearly useless
+            stream.CopyTo(originalStream);
         }
 
         private void Write(byte b)
@@ -1198,7 +1199,7 @@ private void WriteDeduplicatedString(string text)
             return (recordId, hash);
         }
 
-        private void WriteStringRecord(string text)
+        internal void WriteStringRecord(string text)
         {
             using var redirectionScope = RedirectWritesToOriginalWriter();
 
diff --git a/src/Build/Logging/BinaryLogger/ExtendedDataFields.cs b/src/Build/Logging/BinaryLogger/ExtendedDataFields.cs
index 2a227e9d69c..12912cc3e70 100644
--- a/src/Build/Logging/BinaryLogger/ExtendedDataFields.cs
+++ b/src/Build/Logging/BinaryLogger/ExtendedDataFields.cs
@@ -17,4 +17,14 @@ public ExtendedDataFields(string extendedType, IDictionary<string, string?>? ext
     public string ExtendedType { get; }
     public IDictionary<string, string?>? ExtendedMetadata { get; }
     public string? ExtendedData { get; }
+
+    /// <summary>
+    /// We need to this for Extended event args have Dictionary as ExtendedMetadata.
+    /// </summary>
+    public Dictionary<string, string?>? ExtendedMetadataAsDictionary =>
+        ExtendedMetadata == null ?
+            null :
+            ExtendedMetadata is Dictionary<string, string?> asDictionary ?
+                asDictionary :
+                new Dictionary<string, string?>(ExtendedMetadata);
 }
diff --git a/src/Build/Logging/BinaryLogger/IBuildEventArgsReaderNotifications.cs b/src/Build/Logging/BinaryLogger/IBuildEventArgsReaderNotifications.cs
deleted file mode 100644
index 415bd7c71fd..00000000000
--- a/src/Build/Logging/BinaryLogger/IBuildEventArgsReaderNotifications.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-namespace Microsoft.Build.Logging
-{
-    /// <summary>
-    /// An interface for notifications from BuildEventArgsReader
-    /// </summary>
-    public interface IBuildEventArgsReaderNotifications : IBuildEventStringsReader
-    {
-        /* For future use */
-    }
-}
diff --git a/src/Build/Logging/BinaryLogger/IBuildEventStringsReader.cs b/src/Build/Logging/BinaryLogger/IBuildEventStringsReader.cs
deleted file mode 100644
index e9e7651ee78..00000000000
--- a/src/Build/Logging/BinaryLogger/IBuildEventStringsReader.cs
+++ /dev/null
@@ -1,26 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-
-namespace Microsoft.Build.Logging
-{
-    /// <summary>
-    /// An interface for notifications about reading strings from the binary log.
-    /// </summary>
-    public interface IBuildEventStringsReader
-    {
-        /// <summary>
-        /// An event that allows the subscriber to be notified when a string is read from the binary log.
-        /// Subscriber may adjust the string by setting <see cref="StringReadEventArgs.StringToBeUsed"/> property.
-        /// The passed event arg can be reused and should not be stored.
-        /// </summary>
-        public event Action<StringReadEventArgs>? StringReadDone;
-
-        /// <summary>
-        /// An event that allows the caller to be notified when a string is encountered in the binary log.
-        /// BinaryReader passed in ctor is at the beginning of the string at this point.
-        /// </summary>
-        public event Action? StringEncountered;
-    }
-}
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs b/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs
new file mode 100644
index 00000000000..ec8ba12c8b1
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs
@@ -0,0 +1,91 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.IO.Compression;
+using System.Text;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// An object model for binlog embedded files.
+    /// Used in <see cref="IBuildEventArgsReaderNotifications.ArchiveFileEncountered"/> event.
+    /// </summary>
+    public abstract class ArchiveData : IDisposable
+    {
+        private protected ArchiveData(string fullPath) => FullPath = fullPath;
+
+        /// <summary>
+        /// Full path of the original file before it was put in the embedded archive.
+        /// </summary>
+        public string FullPath { get; }
+
+        /// <summary>
+        /// Materializes the whole content of the embedded file in memory as a string.
+        /// </summary>
+        /// <returns></returns>
+        public abstract ArchiveFile ToArchiveFile();
+
+        public virtual void Dispose()
+        { }
+    }
+
+    /// <summary>
+    /// Fully materialized (in-memory) embedded file.
+    /// Easier to work with (the content is expressed in a single string), but more memory greedy.
+    /// </summary>
+    public sealed class ArchiveFile : ArchiveData
+    {
+        public ArchiveFile(string fullPath, string content)
+            : base(fullPath)
+            => Content = content;
+
+        /// <summary>
+        /// The content of the original file.
+        /// </summary>
+        public string Content { get; }
+
+        /// <inheritdoc cref="ArchiveData.ToArchiveFile" />
+        public override ArchiveFile ToArchiveFile()
+            => this;
+    }
+
+    /// <summary>
+    /// Lazy (streaming) embedded file.
+    /// Might be favorable for large files, as it doesn't materialize the whole content in memory.
+    /// </summary>
+    public sealed class ArchiveStream : ArchiveData
+    {
+        public ArchiveStream(string fullPath, StreamReader contentReader)
+            : base(fullPath)
+            => ContentReader = contentReader;
+
+        /// <summary>
+        /// Stream over the content of the archived file.
+        /// </summary>
+        public StreamReader ContentReader { get; }
+
+        /// <summary>
+        /// Creates an externally exposable embedded file representation from a <see cref="ZipArchiveEntry"/> (which is an implementation detail currently).
+        /// </summary>
+        /// <param name="entry"></param>
+        /// <returns></returns>
+        internal static ArchiveStream From(ZipArchiveEntry entry)
+        {
+            return new ArchiveStream(entry.FullName, new StreamReader(entry.Open()));
+        }
+
+        /// <inheritdoc cref="ArchiveData.ToArchiveFile" />
+        public override ArchiveFile ToArchiveFile()
+        {
+            var content = ContentReader.ReadToEnd();
+            ContentReader.Dispose();
+            return new ArchiveFile(FullPath, content);
+        }
+
+        public override void Dispose()
+            => ContentReader.Dispose();
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgs.cs b/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgs.cs
new file mode 100644
index 00000000000..9dc2b2e42a1
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgs.cs
@@ -0,0 +1,20 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Logging;
+
+/// <summary>
+/// Event arguments for <see cref="IBuildEventArgsReaderNotifications.ArchiveFileEncountered"/> event.
+/// </summary>
+public sealed class ArchiveFileEventArgs : EventArgs
+{
+    public ArchiveData ArchiveData { get; set; }
+
+    public ArchiveFileEventArgs(ArchiveData archiveData) => ArchiveData = archiveData;
+
+    // Intentionally not exposing this publicly (e.g. as IDisposable implementation)
+    // as we don't want to user to be bothered with ownership and disposing concerns.
+    internal void Dispose() => ArchiveData.Dispose();
+}
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgsExtensions.cs b/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgsExtensions.cs
new file mode 100644
index 00000000000..985e761411a
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgsExtensions.cs
@@ -0,0 +1,52 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Logging;
+
+public static class ArchiveFileEventArgsExtensions
+{
+    /// <summary>
+    /// Helper method that allows to subscribe to <see cref="IBuildEventArgsReaderNotifications.ArchiveFileEncountered"/> event via <see cref="IBuildEventArgsReaderNotifications.StringReadDone"/> event handler.
+    ///
+    /// This applies only when subscriber is OK with greedy reading entire content of the file and is interested only in the individual strings (e.g. for sensitive data redaction purposes),
+    ///  without distinction what each individual string means (e.g. they do not care about distinction between path and content or between individual files - they just need all textual data).
+    ///
+    /// <example>
+    /// <code>
+    /// private void OnStringReadDone(StringReadEventArgs e)
+    /// {
+    ///     e.StringToBeUsed = e.StringToBeUsed.Replace("foo", "bar");
+    /// }
+    ///
+    /// private void SubscribeToEvents()
+    /// {
+    ///     reader.StringReadDone += OnStringReadDone;
+    ///     reader.ArchiveFileEncountered += ((Action&lt;StringReadEventArgs&gt;)OnStringReadDone).ToArchiveFileHandler();
+    /// }
+    /// </code>
+    /// </example>
+    /// </summary>
+    public static Action<ArchiveFileEventArgs> ToArchiveFileHandler(this Action<StringReadEventArgs> stringHandler)
+    {
+        return args =>
+        {
+            var archiveFile = args.ArchiveData.ToArchiveFile();
+            var pathArgs = new StringReadEventArgs(archiveFile.FullPath);
+            stringHandler(pathArgs);
+            var contentArgs = new StringReadEventArgs(archiveFile.Content);
+            stringHandler(contentArgs);
+
+            if(pathArgs.StringToBeUsed != pathArgs.OriginalString ||
+               contentArgs.StringToBeUsed != contentArgs.OriginalString)
+            {
+                args.ArchiveData = new ArchiveFile(pathArgs.StringToBeUsed, contentArgs.StringToBeUsed);
+            }
+            else
+            {
+                args.ArchiveData = archiveFile;
+            }
+        };
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/BinaryLogReaderErrorEventArgs.cs b/src/Build/Logging/BinaryLogger/Postprocessing/BinaryLogReaderErrorEventArgs.cs
new file mode 100644
index 00000000000..adad3e7d363
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/BinaryLogReaderErrorEventArgs.cs
@@ -0,0 +1,49 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// Materializes the error message.
+    /// Until it's called the error message is not materialized and no string allocations are made.
+    /// </summary>
+    /// <returns>The error message.</returns>
+    internal delegate string FormatErrorMessage();
+
+    /// <summary>
+    /// An event args for <see cref="IBuildEventArgsReaderNotifications.RecoverableReadError"/> event.
+    /// </summary>
+    public sealed class BinaryLogReaderErrorEventArgs : EventArgs
+    {
+        private readonly FormatErrorMessage _formatErrorMessage;
+
+        internal BinaryLogReaderErrorEventArgs(
+            ReaderErrorType errorType,
+            BinaryLogRecordKind recordKind,
+            FormatErrorMessage formatErrorMessage)
+        {
+            ErrorType = errorType;
+            RecordKind = recordKind;
+            _formatErrorMessage = formatErrorMessage;
+        }
+
+        /// <summary>
+        /// Type of the error that occurred during reading.
+        /// </summary>
+        public ReaderErrorType ErrorType { get; }
+
+        /// <summary>
+        /// Kind of the record that encountered the error.
+        /// </summary>
+        public BinaryLogRecordKind RecordKind { get; }
+
+        /// <summary>
+        /// Materializes the error message.
+        /// Until it's called the error message is not materialized and no string allocations are made.
+        /// </summary>
+        /// <returns>The error message.</returns>
+        public string GetFormattedMessage() => _formatErrorMessage();
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/CleanupScope.cs b/src/Build/Logging/BinaryLogger/Postprocessing/CleanupScope.cs
new file mode 100644
index 00000000000..3045f914fe7
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/CleanupScope.cs
@@ -0,0 +1,15 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Logging;
+
+internal readonly struct CleanupScope : IDisposable
+{
+    private readonly Action _disposeAction;
+
+    public CleanupScope(Action disposeAction) => _disposeAction = disposeAction;
+
+    public void Dispose() => _disposeAction();
+}
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/EmbeddedContentEventArgs.cs b/src/Build/Logging/BinaryLogger/Postprocessing/EmbeddedContentEventArgs.cs
new file mode 100644
index 00000000000..123d927dd12
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/EmbeddedContentEventArgs.cs
@@ -0,0 +1,20 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+
+namespace Microsoft.Build.Logging
+{
+    internal sealed class EmbeddedContentEventArgs : EventArgs
+    {
+        public EmbeddedContentEventArgs(BinaryLogRecordKind contentKind, Stream contentStream)
+        {
+            ContentKind = contentKind;
+            ContentStream = contentStream;
+        }
+
+        public BinaryLogRecordKind ContentKind { get; }
+        public Stream ContentStream { get; }
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/IBuildEventArgsReaderNotifications.cs b/src/Build/Logging/BinaryLogger/Postprocessing/IBuildEventArgsReaderNotifications.cs
new file mode 100644
index 00000000000..aee71562898
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/IBuildEventArgsReaderNotifications.cs
@@ -0,0 +1,50 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// An interface for notifications from BuildEventArgsReader
+    /// </summary>
+    public interface IBuildEventArgsReaderNotifications
+    {
+        /// <summary>
+        /// An event that allows the subscriber to be notified when a string is read from the binary log.
+        /// Subscriber may adjust the string by setting <see cref="StringReadEventArgs.StringToBeUsed"/> property.
+        /// The passed event arg can be reused and should not be stored.
+        /// </summary>
+        event Action<StringReadEventArgs>? StringReadDone;
+
+        /// <summary>
+        /// An event that allows the caller to be notified when an embedded file is encountered in the binary log.
+        /// When subscriber is OK with greedy reading entire content of the file and is interested only in the individual strings (e.g. for sensitive data redaction purposes),
+        ///  it can simplify subscribing to this event, by using handler with same signature as handler for <see cref="IBuildEventArgsReaderNotifications.StringReadDone"/> and wrapping it via
+        /// <see cref="ArchiveFileEventArgsExtensions.ToArchiveFileHandler"/> extension.
+        /// </summary>
+        /// <example>
+        /// <code>
+        /// private void OnStringReadDone(StringReadEventArgs e)
+        /// {
+        ///     e.StringToBeUsed = e.StringToBeUsed.Replace("foo", "bar");
+        /// }
+        ///
+        /// private void SubscribeToEvents()
+        /// {
+        ///     reader.StringReadDone += OnStringReadDone;
+        ///     reader.ArchiveFileEncountered += ((Action&lt;StringReadEventArgs&gt;)OnStringReadDone).ToArchiveFileHandler();
+        /// }
+        /// </code>
+        /// </example>
+        event Action<ArchiveFileEventArgs>? ArchiveFileEncountered;
+
+        /// <summary>
+        /// Receives recoverable errors during reading.
+        /// Communicates type of the error, kind of the record that encountered the error and the message detailing the error.
+        /// In case of <see cref="ReaderErrorType.UnknownEventData"/> this is raised before returning the structured representation of a build event
+        /// that has some extra unknown data in the binlog. In case of other error types this event is raised and the offending build event is skipped and not returned.
+        /// </summary>
+        event Action<BinaryLogReaderErrorEventArgs>? RecoverableReadError;
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/ReaderErrorType.cs b/src/Build/Logging/BinaryLogger/Postprocessing/ReaderErrorType.cs
new file mode 100644
index 00000000000..5bce4a50935
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/ReaderErrorType.cs
@@ -0,0 +1,29 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging;
+
+/// <summary>
+/// Type of the error that occurred during reading.
+/// </summary>
+public enum ReaderErrorType
+{
+    /// <summary>
+    /// The encountered event is completely unknown to the reader. It cannot interpret any part of it.
+    /// </summary>
+    UnknownEventType,
+
+    /// <summary>
+    /// The encountered event is known to the reader and reader is able to read the event as it knows it.
+    /// However there are some extra data (append only extension to the event in future version), that reader cannot interpret,
+    ///  it can only skip it.
+    /// </summary>
+    UnknownEventData,
+
+    /// <summary>
+    /// The encountered event type is known to the reader, but the reader cannot interpret the data of the event.
+    /// This is probably caused by an event definition changing more than just adding fields.
+    /// The reader can only skip the event in full.
+    /// </summary>
+    UnknownFormatOfEventData,
+}
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
new file mode 100644
index 00000000000..2993b3953c1
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
@@ -0,0 +1,102 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Buffers;
+using System.Diagnostics;
+using System.IO;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Logging
+{
+    internal static class StreamExtensions
+    {
+        private static bool CheckIsSkipNeeded(long bytesCount)
+        {
+            if (bytesCount is < 0 or > int.MaxValue)
+            {
+                throw new ArgumentOutOfRangeException(nameof(bytesCount), ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Binlog_StreamUtils_UnsupportedSkipOffset",
+                    bytesCount));
+            }
+
+            return bytesCount > 0;
+        }
+
+        public static long SkipBytes(this Stream stream, long bytesCount)
+        {
+            if (!CheckIsSkipNeeded(bytesCount))
+            {
+                return 0;
+            }
+
+            byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);
+            using var _ = new CleanupScope(() => ArrayPool<byte>.Shared.Return(buffer));
+            return SkipBytes(stream, bytesCount, buffer);
+        }
+
+        public static long SkipBytes(this Stream stream, long bytesCount, byte[] buffer)
+        {
+            if (!CheckIsSkipNeeded(bytesCount))
+            {
+                return 0;
+            }
+
+            long totalRead = 0;
+            while (totalRead < bytesCount)
+            {
+                int read = stream.Read(buffer, 0, (int)Math.Min(bytesCount - totalRead, buffer.Length));
+                if (read == 0)
+                {
+                    throw new InvalidDataException("Unexpected end of stream.");
+                }
+
+                totalRead += read;
+            }
+
+            return totalRead;
+        }
+
+        public static byte[] ReadToEnd(this Stream stream)
+        {
+            if (stream.TryGetLength(out long length))
+            {
+                BinaryReader reader = new(stream);
+                return reader.ReadBytes((int)length);
+            }
+
+            using var ms = new MemoryStream();
+            stream.CopyTo(ms);
+            return ms.ToArray();
+        }
+
+        public static bool TryGetLength(this Stream stream, out long length)
+        {
+            try
+            {
+                length = stream.Length;
+                return true;
+            }
+            catch (NotSupportedException)
+            {
+                length = 0;
+                return false;
+            }
+        }
+
+        public static Stream ToReadableSeekableStream(this Stream stream)
+        {
+            return TransparentReadStream.EnsureSeekableStream(stream);
+        }
+
+        /// <summary>
+        /// Creates bounded read-only, forward-only view over an underlying stream.
+        /// </summary>
+        /// <param name="stream"></param>
+        /// <param name="length"></param>
+        /// <returns></returns>
+        public static Stream Slice(this Stream stream, long length)
+        {
+            return new SubStream(stream, length);
+        }
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/StringReadEventArgs.cs b/src/Build/Logging/BinaryLogger/Postprocessing/StringReadEventArgs.cs
similarity index 90%
rename from src/Build/Logging/BinaryLogger/StringReadEventArgs.cs
rename to src/Build/Logging/BinaryLogger/Postprocessing/StringReadEventArgs.cs
index e2a4c83d3cb..909cec443eb 100644
--- a/src/Build/Logging/BinaryLogger/StringReadEventArgs.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/StringReadEventArgs.cs
@@ -6,7 +6,7 @@
 namespace Microsoft.Build.Logging
 {
     /// <summary>
-    /// An event args for <see cref="IBuildEventStringsReader.StringReadDone"/> callback.
+    /// An event args for <see cref="IBuildEventArgsReaderNotifications.StringReadDone"/> callback.
     /// </summary>
     public sealed class StringReadEventArgs : EventArgs
     {
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs b/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
new file mode 100644
index 00000000000..ff5caf9bfdf
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
@@ -0,0 +1,55 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// Bounded read-only, forward-only view over an underlying stream.
+    /// </summary>
+    internal sealed class SubStream : Stream
+    {
+        // Do not Dispose/Close on Dispose/Close !!
+        private readonly Stream _stream;
+        private readonly long _length;
+        private long _position;
+
+        public SubStream(Stream stream, long length)
+        {
+            _stream = stream;
+            _length = length;
+
+            if (!stream.CanRead)
+            {
+                throw new NotSupportedException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_MustBeReadable"));
+            }
+        }
+
+        public bool IsAtEnd => _position >= _length;
+
+        public override bool CanRead => true;
+
+        public override bool CanSeek => false;
+
+        public override bool CanWrite => false;
+
+        public override long Length => _length;
+
+        public override long Position { get => _position; set => throw new NotImplementedException(); }
+
+        public override void Flush() { }
+        public override int Read(byte[] buffer, int offset, int count)
+        {
+            count = Math.Min((int)Math.Max(Length - _position, 0), count);
+            int read = _stream.Read(buffer, offset, count);
+            _position += read;
+            return read;
+        }
+        public override long Seek(long offset, SeekOrigin origin) => throw new NotImplementedException();
+        public override void SetLength(long value) => throw new NotImplementedException();
+        public override void Write(byte[] buffer, int offset, int count) => throw new NotImplementedException();
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs b/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
new file mode 100644
index 00000000000..4dd9afa0300
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
@@ -0,0 +1,114 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// A wrapper stream that allows position tracking and forward seeking.
+    /// </summary>
+    internal sealed class TransparentReadStream : Stream
+    {
+        private readonly Stream _stream;
+        private long _position;
+        private long _maxAllowedPosition = long.MaxValue;
+
+        public static Stream EnsureSeekableStream(Stream stream)
+        {
+            if (stream.CanSeek)
+            {
+                return stream;
+            }
+
+            if (!stream.CanRead)
+            {
+                throw new InvalidOperationException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_MustBeReadable"));
+            }
+
+            return new TransparentReadStream(stream);
+        }
+
+        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)
+        {
+            if (stream is TransparentReadStream transparentReadStream)
+            {
+                return transparentReadStream;
+            }
+
+            if (!stream.CanRead)
+            {
+                throw new InvalidOperationException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_MustBeReadable"));
+            }
+
+            return new TransparentReadStream(stream);
+        }
+
+        private TransparentReadStream(Stream stream)
+        {
+            _stream = stream;
+        }
+
+        public int? BytesCountAllowedToRead
+        {
+            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }
+        }
+
+        // if we haven't constrained the allowed read size - do not report it being unfinished either.
+        public int BytesCountAllowedToReadRemaining =>
+            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);
+
+        public override bool CanRead => _stream.CanRead;
+        public override bool CanSeek => true;
+        public override bool CanWrite => false;
+        public override long Length => _stream.Length;
+        public override long Position
+        {
+            get => _position;
+            set => this.SkipBytes(value - _position);
+        }
+
+        public override void Flush()
+        {
+            _stream.Flush();
+        }
+
+        public override int Read(byte[] buffer, int offset, int count)
+        {
+            if (_position + count > _maxAllowedPosition)
+            {
+                count = (int)(_maxAllowedPosition - _position);
+            }
+
+            int cnt = _stream.Read(buffer, offset, count);
+            _position += cnt;
+            return cnt;
+        }
+
+        public override long Seek(long offset, SeekOrigin origin)
+        {
+            if (origin != SeekOrigin.Current)
+            {
+                throw new NotSupportedException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_SeekNonOrigin"));
+            }
+
+            this.SkipBytes(offset);
+
+            return _position;
+        }
+
+        public override void SetLength(long value)
+        {
+            throw new NotSupportedException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_SetLengthUnsupported"));
+        }
+
+        public override void Write(byte[] buffer, int offset, int count)
+        {
+            throw new NotSupportedException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_WriteUnsupported"));
+        }
+
+        public override void Close() => _stream.Close();
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
index 27ededae8cc..536d7f9ed48 100644
--- a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
+++ b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
@@ -8,8 +8,7 @@
 using System.Text;
 using System.Threading.Tasks;
 using Microsoft.Build.Shared;
-
-#nullable disable
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Logging
 {
@@ -21,10 +20,11 @@ namespace Microsoft.Build.Logging
     /// </summary>
     internal class ProjectImportsCollector
     {
-        private Stream _fileStream;
-        private ZipArchive _zipArchive;
-
-        public string ArchiveFilePath { get; }
+        private Stream? _fileStream;
+        private ZipArchive? _zipArchive;
+        private readonly string _archiveFilePath;
+        private readonly bool _runOnBackground;
+        private const string DefaultSourcesArchiveExtension = ".ProjectImports.zip";
 
         /// <summary>
         /// Avoid visiting each file more than once.
@@ -34,12 +34,29 @@ internal class ProjectImportsCollector
         // this will form a chain of file write tasks, running sequentially on a background thread
         private Task _currentTask = Task.CompletedTask;
 
-        public ProjectImportsCollector(string logFilePath, bool createFile, string sourcesArchiveExtension = ".ProjectImports.zip")
+        internal static void FlushBlobToFile(
+            string logFilePath,
+            Stream contentStream)
+        {
+            string archiveFilePath = GetArchiveFilePath(logFilePath, DefaultSourcesArchiveExtension);
+
+            using var fileStream = new FileStream(archiveFilePath, FileMode.Create, FileAccess.ReadWrite, FileShare.Delete);
+            contentStream.CopyTo(fileStream);
+        }
+
+        // Archive file will be stored alongside the binlog
+        private static string GetArchiveFilePath(string logFilePath, string sourcesArchiveExtension)
+            => Path.ChangeExtension(logFilePath, sourcesArchiveExtension);
+
+        public ProjectImportsCollector(
+            string logFilePath,
+            bool createFile,
+            string sourcesArchiveExtension = DefaultSourcesArchiveExtension,
+            bool runOnBackground = true)
         {
             if (createFile)
             {
-                // Archive file will be stored alongside the binlog
-                ArchiveFilePath = Path.ChangeExtension(logFilePath, sourcesArchiveExtension);
+                _archiveFilePath = GetArchiveFilePath(logFilePath, sourcesArchiveExtension);
             }
             else
             {
@@ -50,16 +67,16 @@ public ProjectImportsCollector(string logFilePath, bool createFile, string sourc
                 }
 
                 // Archive file will be temporarily stored in MSBuild cache folder and deleted when no longer needed
-                ArchiveFilePath = Path.Combine(
+                _archiveFilePath = Path.Combine(
                     cacheDirectory,
-                    Path.ChangeExtension(
+                    GetArchiveFilePath(
                         Path.GetFileName(logFilePath),
                         sourcesArchiveExtension));
             }
 
             try
             {
-                _fileStream = new FileStream(ArchiveFilePath, FileMode.Create, FileAccess.ReadWrite, FileShare.Delete);
+                _fileStream = new FileStream(_archiveFilePath, FileMode.Create, FileAccess.ReadWrite, FileShare.Delete);
                 _zipArchive = new ZipArchive(_fileStream, ZipArchiveMode.Create);
             }
             catch
@@ -69,49 +86,67 @@ public ProjectImportsCollector(string logFilePath, bool createFile, string sourc
                 _fileStream = null;
                 _zipArchive = null;
             }
+            _runOnBackground = runOnBackground;
+        }
+
+        public void AddFile(string? filePath)
+        {
+            AddFileHelper(filePath, AddFileCore);
         }
 
-        public void AddFile(string filePath)
+        public void AddFileFromMemory(
+            string? filePath,
+            string data,
+            DateTimeOffset? entryCreationStamp = null,
+            bool makePathAbsolute = true)
+        {
+            AddFileHelper(filePath, path =>
+                AddFileFromMemoryCore(path, data, makePathAbsolute, entryCreationStamp));
+        }
+
+        public void AddFileFromMemory(
+            string? filePath,
+            Stream data,
+            DateTimeOffset? entryCreationStamp = null,
+            bool makePathAbsolute = true)
+        {
+            AddFileHelper(filePath, path => AddFileFromMemoryCore(path, data, makePathAbsolute, entryCreationStamp));
+        }
+
+        private void AddFileHelper(
+            string? filePath,
+            Action<string> addFileWorker)
         {
             if (filePath != null && _fileStream != null)
             {
                 lock (_fileStream)
                 {
-                    // enqueue the task to add a file and return quickly
-                    // to avoid holding up the current thread
-                    _currentTask = _currentTask.ContinueWith(t =>
+                    if (_runOnBackground)
                     {
-                        try
-                        {
-                            AddFileCore(filePath);
-                        }
-                        catch
-                        {
-                        }
-                    }, TaskScheduler.Default);
+                        // enqueue the task to add a file and return quickly
+                        // to avoid holding up the current thread
+                        _currentTask = _currentTask.ContinueWith(
+                            t => { TryAddFile(); },
+                            TaskScheduler.Default);
+                    }
+                    else
+                    {
+                        TryAddFile();
+                    }
                 }
             }
-        }
 
-        public void AddFileFromMemory(string filePath, string data)
-        {
-            if (filePath != null && data != null && _fileStream != null)
+            bool TryAddFile()
             {
-                lock (_fileStream)
+                try
                 {
-                    // enqueue the task to add a file and return quickly
-                    // to avoid holding up the current thread
-                    _currentTask = _currentTask.ContinueWith(t =>
-                    {
-                        try
-                        {
-                            AddFileFromMemoryCore(filePath, data);
-                        }
-                        catch
-                        {
-                        }
-                    }, TaskScheduler.Default);
+                    addFileWorker(filePath);
+                    return true;
                 }
+                catch
+                { }
+
+                return false;
             }
         }
 
@@ -122,61 +157,82 @@ public void AddFileFromMemory(string filePath, string data)
         private void AddFileCore(string filePath)
         {
             // quick check to avoid repeated disk access for Exists etc.
-            if (_processedFiles.Contains(filePath))
+            if (!ShouldAddFile(ref filePath, true, true))
             {
                 return;
             }
 
-            if (!File.Exists(filePath))
+            using FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);
+            AddFileData(filePath, content, null);
+        }
+
+        /// <remarks>
+        /// This method doesn't need locking/synchronization because it's only called
+        /// from a task that is chained linearly
+        /// </remarks>
+        private void AddFileFromMemoryCore(string filePath, string data, bool makePathAbsolute, DateTimeOffset? entryCreationStamp)
+        {
+            // quick check to avoid repeated disk access for Exists etc.
+            if (!ShouldAddFile(ref filePath, false, makePathAbsolute))
             {
-                _processedFiles.Add(filePath);
                 return;
             }
 
-            filePath = Path.GetFullPath(filePath);
+            using var content = new MemoryStream(Encoding.UTF8.GetBytes(data));
+            AddFileData(filePath, content, entryCreationStamp);
+        }
 
-            // if the file is already included, don't include it again
-            if (!_processedFiles.Add(filePath))
+        private void AddFileFromMemoryCore(string filePath, Stream data, bool makePathAbsolute, DateTimeOffset? entryCreationStamp)
+        {
+            // quick check to avoid repeated disk access for Exists etc.
+            if (!ShouldAddFile(ref filePath, false, makePathAbsolute))
             {
                 return;
             }
 
-            using FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);
-            using Stream entryStream = OpenArchiveEntry(filePath);
-            content.CopyTo(entryStream);
+            AddFileData(filePath, data, entryCreationStamp);
         }
 
-        /// <remarks>
-        /// This method doesn't need locking/synchronization because it's only called
-        /// from a task that is chained linearly
-        /// </remarks>
-        private void AddFileFromMemoryCore(string filePath, string data)
+        private void AddFileData(string filePath, Stream data, DateTimeOffset? entryCreationStamp)
+        {
+            using Stream entryStream = OpenArchiveEntry(filePath, entryCreationStamp);
+            data.CopyTo(entryStream);
+        }
+
+        private bool ShouldAddFile(ref string filePath, bool checkFileExistence, bool makeAbsolute)
         {
             // quick check to avoid repeated disk access for Exists etc.
             if (_processedFiles.Contains(filePath))
             {
-                return;
+                return false;
             }
 
-            filePath = Path.GetFullPath(filePath);
-
-            // if the file is already included, don't include it again
-            if (!_processedFiles.Add(filePath))
+            if (checkFileExistence && !File.Exists(filePath))
             {
-                return;
+                _processedFiles.Add(filePath);
+                return false;
             }
 
-            using (Stream entryStream = OpenArchiveEntry(filePath))
-            using (var content = new MemoryStream(Encoding.UTF8.GetBytes(data)))
+            // Only make the path absolute if it's request. In the replay scenario, the file entries
+            // are read from zip archive - where ':' is stripped and path can then seem relative.
+            if (makeAbsolute)
             {
-                content.CopyTo(entryStream);
+                filePath = Path.GetFullPath(filePath);
             }
+
+            // if the file is already included, don't include it again
+            return _processedFiles.Add(filePath);
         }
 
-        private Stream OpenArchiveEntry(string filePath)
+        private Stream OpenArchiveEntry(string filePath, DateTimeOffset? entryCreationStamp)
         {
             string archivePath = CalculateArchivePath(filePath);
-            var archiveEntry = _zipArchive.CreateEntry(archivePath);
+            var archiveEntry = _zipArchive!.CreateEntry(archivePath);
+            if (entryCreationStamp.HasValue)
+            {
+                archiveEntry.LastWriteTime = entryCreationStamp.Value;
+            }
+
             return archiveEntry.Open();
         }
 
@@ -191,6 +247,27 @@ private static string CalculateArchivePath(string filePath)
             return archivePath;
         }
 
+        public void ProcessResult(Action<Stream> consumeStream, Action<string> onError)
+        {
+            Close();
+
+            // It is possible that the archive couldn't be created for some reason.
+            // Only embed it if it actually exists.
+            if (FileSystems.Default.FileExists(_archiveFilePath))
+            {
+                using FileStream fileStream = File.OpenRead(_archiveFilePath);
+
+                if (fileStream.Length > int.MaxValue)
+                {
+                    onError(ResourceUtilities.GetResourceString("Binlog_ImportFileSizeError"));
+                }
+                else
+                {
+                    consumeStream(fileStream);
+                }
+            }
+        }
+
         public void Close()
         {
             // wait for all pending file writes to complete
@@ -208,5 +285,11 @@ public void Close()
                 _fileStream = null;
             }
         }
+
+        public void DeleteArchive()
+        {
+            Close();
+            File.Delete(_archiveFilePath);
+        }
     }
 }
diff --git a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index 277352b56a0..fc69e41d38d 100644
--- a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -1,14 +1,9 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Collections.Generic;
-
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Logging
 {
     /// <summary>
@@ -22,9 +17,7 @@ public class ConfigurableForwardingLogger : IForwardingLogger
         /// Default constructor.
         /// </summary>
         public ConfigurableForwardingLogger()
-        {
-            InitializeForwardingTable();
-        }
+        { }
         #endregion
 
         #region Properties
@@ -44,7 +37,7 @@ public LoggerVerbosity Verbosity
         /// and warnings summary at the end of a build.
         /// </summary>
         /// <value>null</value>
-        public string Parameters
+        public string? Parameters
         {
             get { return _loggerParameters; }
             set { _loggerParameters = value; }
@@ -54,7 +47,7 @@ public string Parameters
         /// This property is set by the build engine to allow a node loggers to forward messages to the
         /// central logger
         /// </summary>
-        public IEventRedirector BuildEventRedirector
+        public IEventRedirector? BuildEventRedirector
         {
             get { return _buildEventRedirector; }
             set { _buildEventRedirector = value; }
@@ -72,35 +65,10 @@ public int NodeId
 
         #region Methods
 
-        /// <summary>
-        /// Initialize the Forwarding Table with the default values
-        /// </summary>
-        private void InitializeForwardingTable()
-        {
-            _forwardingTable = new Dictionary<string, int>(16, StringComparer.OrdinalIgnoreCase);
-            _forwardingTable[BuildStartedEventDescription] = 0;
-            _forwardingTable[BuildFinishedEventDescription] = 0;
-            _forwardingTable[ProjectStartedEventDescription] = 0;
-            _forwardingTable[ProjectFinishedEventDescription] = 0;
-            _forwardingTable[ProjectEvaluationEventDescription] = 0;
-            _forwardingTable[TargetStartedEventDescription] = 0;
-            _forwardingTable[TargetFinishedEventDescription] = 0;
-            _forwardingTable[TaskStartedEventDescription] = 0;
-            _forwardingTable[TaskFinishedEventDescription] = 0;
-            _forwardingTable[ErrorEventDescription] = 0;
-            _forwardingTable[WarningEventDescription] = 0;
-            _forwardingTable[HighMessageEventDescription] = 0;
-            _forwardingTable[NormalMessageEventDescription] = 0;
-            _forwardingTable[LowMessageEventDescription] = 0;
-            _forwardingTable[CustomEventDescription] = 0;
-            _forwardingTable[CommandLineDescription] = 0;
-            _forwardingSetFromParameters = false;
-        }
-
         /// <summary>
         /// Parses out the logger parameters from the Parameters string.
         /// </summary>
-        private void ParseParameters()
+        private void ParseParameters(IEventSource eventSource)
         {
             if (_loggerParameters != null)
             {
@@ -109,7 +77,7 @@ private void ParseParameters()
                 {
                     if (parameterComponents[param].Length > 0)
                     {
-                        ApplyParameter(parameterComponents[param]);
+                        ApplyParameter(eventSource, parameterComponents[param]);
                     }
                 }
                 // Setting events to forward on the commandline will override the verbosity and other switches such as
@@ -125,8 +93,8 @@ private void ParseParameters()
                     // We can't know whether the project items needed to find ForwardProjectContextDescription
                     // will be set on ProjectStarted or ProjectEvaluationFinished because we don't know
                     // all of the other loggers that will be attached. So turn both on.
-                    _forwardingTable[ProjectStartedEventDescription] = 1;
-                    _forwardingTable[ProjectEvaluationEventDescription] = 1;
+                    eventSource.HandleStatusEventRaised(BuildStatusHandler);
+                    eventSource.HandleProjectStarted(ForwardEvent);
                 }
             }
         }
@@ -135,39 +103,93 @@ private void ParseParameters()
         /// Logger parameters can be used to enable and disable specific event types.
         /// Otherwise, the verbosity is used to choose which events to forward.
         /// </summary>
-        private void ApplyParameter(string parameterName)
+        private void ApplyParameter(IEventSource eventSource, string parameterName)
         {
             ErrorUtilities.VerifyThrowArgumentNull(parameterName, nameof(parameterName));
 
-            if (_forwardingTable.ContainsKey(parameterName))
-            {
-                _forwardingSetFromParameters = true;
-                _forwardingTable[parameterName] = 1;
-            }
-            else if (String.Equals(parameterName, ProjectEvaluationStartedEventDescription, StringComparison.OrdinalIgnoreCase) ||
-                String.Equals(parameterName, ProjectEvaluationFinishedEventDescription, StringComparison.OrdinalIgnoreCase))
+            bool isEventForwardingParameter = true;
+
+            // Careful - we need to brace before double specified parameters - hence the unsubscriptions before subscriptions
+            switch (parameterName.ToUpperInvariant())
+            {
+                case BuildStartedEventDescription:
+                    eventSource.HandleBuildStarted(ForwardEvent);
+                    break;
+                case BuildFinishedEventDescription:
+                    eventSource.HandleBuildFinished(ForwardEvent);
+                    break;
+                case ProjectStartedEventDescription:
+                    eventSource.HandleProjectStarted(ForwardEvent);
+                    break;
+                case ProjectFinishedEventDescription:
+                    eventSource.HandleProjectFinished(ForwardEvent);
+                    break;
+                case TargetStartedEventDescription:
+                    eventSource.HandleTargetStarted(ForwardEvent);
+                    break;
+                case TargetFinishedEventDescription:
+                    eventSource.HandleTargetFinished(ForwardEvent);
+                    break;
+                case TaskStartedEventDescription:
+                    eventSource.HandleTaskStarted(ForwardEvent);
+                    break;
+                case TaskFinishedEventDescription:
+                    eventSource.HandleTaskFinished(ForwardEvent);
+                    break;
+                case ErrorEventDescription:
+                    eventSource.HandleErrorRaised(ForwardEvent);
+                    break;
+                case WarningEventDescription:
+                    eventSource.HandleWarningRaised(ForwardEvent);
+                    break;
+                case CustomEventDescription:
+                    eventSource.HandleCustomEventRaised(ForwardEvent);
+                    break;
+                case HighMessageEventDescription:
+                    eventSource.HandleMessageRaised(MessageHandler);
+                    _forwardHighImportanceMessages = true;
+                    break;
+                case NormalMessageEventDescription:
+                    eventSource.HandleMessageRaised(MessageHandler);
+                    _forwardNormalImportanceMessages = true;
+                    break;
+                case LowMessageEventDescription:
+                    eventSource.HandleMessageRaised(MessageHandler);
+                    _forwardLowImportanceMessages = true;
+                    break;
+                case CommandLineDescription:
+                    eventSource.HandleMessageRaised(MessageHandler);
+                    _forwardTaskCommandLine = true;
+                    break;
+                case ProjectEvaluationStartedEventDescription:
+                case ProjectEvaluationFinishedEventDescription:
+                case ProjectEvaluationEventDescription:
+                    eventSource.HandleStatusEventRaised(BuildStatusHandler);
+                    break;
+                case PerformanceSummaryDescription:
+                    _showPerfSummary = true;
+                    isEventForwardingParameter = false;
+                    break;
+                case NoSummaryDescription:
+                    _showSummary = false;
+                    isEventForwardingParameter = false;
+                    break;
+                case ShowCommandLineDescription:
+                    _showCommandLine = true;
+                    isEventForwardingParameter = false;
+                    break;
+                case ForwardProjectContextDescription:
+                    _forwardProjectContext = true;
+                    isEventForwardingParameter = false;
+                    break;
+                default:
+                    isEventForwardingParameter = false;
+                    break;
+            }
+
+            if (isEventForwardingParameter)
             {
                 _forwardingSetFromParameters = true;
-                _forwardingTable[ProjectEvaluationEventDescription] = 1;
-            }
-
-            // If any of the following parameters are set, we will make sure we forward the events
-            // necessary for the central logger to emit the requested information
-            if (String.Equals(parameterName, PerformanceSummaryDescription, StringComparison.OrdinalIgnoreCase))
-            {
-                _showPerfSummary = true;
-            }
-            else if (String.Equals(parameterName, NoSummaryDescription, StringComparison.OrdinalIgnoreCase))
-            {
-                _showSummary = false;
-            }
-            else if (String.Equals(parameterName, ShowCommandLineDescription, StringComparison.OrdinalIgnoreCase))
-            {
-                _showCommandLine = true;
-            }
-            else if (string.Equals(parameterName, ForwardProjectContextDescription, StringComparison.OrdinalIgnoreCase))
-            {
-                _forwardProjectContext = true;
             }
         }
 
@@ -178,28 +200,14 @@ public virtual void Initialize(IEventSource eventSource)
         {
             ErrorUtilities.VerifyThrowArgumentNull(eventSource, nameof(eventSource));
 
-            ParseParameters();
+            ParseParameters(eventSource);
 
             ResetLoggerState();
 
             if (!_forwardingSetFromParameters)
             {
-                SetForwardingBasedOnVerbosity();
+                SetForwardingBasedOnVerbosity(eventSource);
             }
-
-            eventSource.BuildStarted += BuildStartedHandler;
-            eventSource.BuildFinished += BuildFinishedHandler;
-            eventSource.ProjectStarted += ProjectStartedHandler;
-            eventSource.ProjectFinished += ProjectFinishedHandler;
-            eventSource.TargetStarted += TargetStartedHandler;
-            eventSource.TargetFinished += TargetFinishedHandler;
-            eventSource.TaskStarted += TaskStartedHandler;
-            eventSource.TaskFinished += TaskFinishedHandler;
-            eventSource.ErrorRaised += ErrorHandler;
-            eventSource.WarningRaised += WarningHandler;
-            eventSource.MessageRaised += MessageHandler;
-            eventSource.CustomEventRaised += CustomEventHandler;
-            eventSource.StatusEventRaised += BuildStatusHandler;
         }
 
         /// <summary>
@@ -210,69 +218,74 @@ public void Initialize(IEventSource eventSource, int nodeCount)
             Initialize(eventSource);
         }
 
-        private void SetForwardingBasedOnVerbosity()
+        private void SetForwardingBasedOnVerbosity(IEventSource eventSource)
         {
-            _forwardingTable[BuildStartedEventDescription] = 1;
-            _forwardingTable[BuildFinishedEventDescription] = 1;
+            eventSource.HandleBuildStarted(ForwardEvent);
+            eventSource.HandleBuildFinished(ForwardEvent);
 
             if (IsVerbosityAtLeast(LoggerVerbosity.Quiet))
             {
-                _forwardingTable[ErrorEventDescription] = 1;
-                _forwardingTable[WarningEventDescription] = 1;
+                eventSource.HandleErrorRaised(ForwardEvent);
+                eventSource.HandleWarningRaised(ForwardEvent);
             }
 
             if (IsVerbosityAtLeast(LoggerVerbosity.Minimal))
             {
-                _forwardingTable[HighMessageEventDescription] = 1;
+                eventSource.HandleMessageRaised(MessageHandler);
+                _forwardHighImportanceMessages = true;
             }
 
             if (IsVerbosityAtLeast(LoggerVerbosity.Normal))
             {
-                _forwardingTable[NormalMessageEventDescription] = 1;
-                _forwardingTable[ProjectStartedEventDescription] = 1;
-                _forwardingTable[ProjectFinishedEventDescription] = 1;
-                _forwardingTable[TargetStartedEventDescription] = 1;
-                _forwardingTable[TargetFinishedEventDescription] = 1;
-                _forwardingTable[CommandLineDescription] = 1;
+                // MessageHandler already subscribed
+                _forwardNormalImportanceMessages = true;
+                _forwardTaskCommandLine = true;
+
+                eventSource.HandleProjectStarted(ForwardEvent);
+                eventSource.HandleProjectFinished(ForwardEvent);
+                eventSource.HandleTargetStarted(ForwardEvent);
+                eventSource.HandleTargetFinished(ForwardEvent);
             }
 
             if (IsVerbosityAtLeast(LoggerVerbosity.Detailed))
             {
-                _forwardingTable[TargetStartedEventDescription] = 1;
-                _forwardingTable[TargetFinishedEventDescription] = 1;
-                _forwardingTable[TaskStartedEventDescription] = 1;
-                _forwardingTable[TaskFinishedEventDescription] = 1;
-                _forwardingTable[LowMessageEventDescription] = 1;
+                eventSource.HandleTaskStarted(ForwardEvent);
+                eventSource.HandleTaskFinished(ForwardEvent);
+
+                // MessageHandler already subscribed
+                _forwardLowImportanceMessages = true;
             }
 
             if (IsVerbosityAtLeast(LoggerVerbosity.Diagnostic))
             {
-                _forwardingTable[CustomEventDescription] = 1;
-                _forwardingTable[ProjectEvaluationEventDescription] = 1;
+                eventSource.HandleCustomEventRaised(ForwardEvent);
+                eventSource.HandleStatusEventRaised(BuildStatusHandler);
             }
 
             if (_showSummary)
             {
-                _forwardingTable[ErrorEventDescription] = 1;
-                _forwardingTable[WarningEventDescription] = 1;
+                eventSource.HandleErrorRaised(ForwardEvent);
+                eventSource.HandleWarningRaised(ForwardEvent);
             }
 
             if (_showPerfSummary)
             {
-                _forwardingTable[TargetStartedEventDescription] = 1;
-                _forwardingTable[TargetFinishedEventDescription] = 1;
-                _forwardingTable[TaskStartedEventDescription] = 1;
-                _forwardingTable[TaskFinishedEventDescription] = 1;
-                _forwardingTable[TargetStartedEventDescription] = 1;
-                _forwardingTable[TargetFinishedEventDescription] = 1;
-                _forwardingTable[ProjectStartedEventDescription] = 1;
-                _forwardingTable[ProjectFinishedEventDescription] = 1;
-                _forwardingTable[ProjectEvaluationEventDescription] = 1;
+                eventSource.HandleTaskStarted(ForwardEvent);
+                eventSource.HandleTaskFinished(ForwardEvent);
+                eventSource.HandleTargetStarted(ForwardEvent);
+                eventSource.HandleTargetFinished(ForwardEvent);
+                eventSource.HandleProjectStarted(ForwardEvent);
+                eventSource.HandleProjectFinished(ForwardEvent);
+                eventSource.HandleStatusEventRaised(BuildStatusHandler);
             }
 
             if (_showCommandLine)
             {
-                _forwardingTable[CommandLineDescription] = 1;
+                // Prevent double subscribe
+                eventSource.MessageRaised -= MessageHandler;
+                eventSource.MessageRaised += MessageHandler;
+
+                _forwardTaskCommandLine = true;
             }
         }
 
@@ -285,20 +298,17 @@ private void SetForwardingBasedOnVerbosity()
         /// </returns>
         internal MessageImportance GetMinimumMessageImportance()
         {
-            if (_forwardingTable[LowMessageEventDescription] == 1)
+            return _verbosity switch
             {
-                return MessageImportance.Low;
-            }
-            if (_forwardingTable[NormalMessageEventDescription] == 1)
-            {
-                return MessageImportance.Normal;
-            }
-            if (_forwardingTable[HighMessageEventDescription] == 1)
-            {
-                return MessageImportance.High;
-            }
-            // The logger does not log messages of any importance.
-            return MessageImportance.High - 1;
+                LoggerVerbosity.Minimal => MessageImportance.High,
+                LoggerVerbosity.Normal => MessageImportance.Normal,
+                LoggerVerbosity.Detailed => MessageImportance.Low,
+                LoggerVerbosity.Diagnostic => MessageImportance.Low,
+
+                // The logger does not log messages of any importance.
+                LoggerVerbosity.Quiet => MessageImportance.High - 1,
+                _ => MessageImportance.High - 1,
+            };
         }
 
         /// <summary>
@@ -319,157 +329,35 @@ public virtual void Shutdown()
         }
 
         /// <summary>
-        /// Handler for build started events
+        /// Handler for build events
         /// </summary>
         /// <param name="sender">sender (should be null)</param>
         /// <param name="e">event arguments</param>
-        private void BuildStartedHandler(object sender, BuildStartedEventArgs e)
+        private void ForwardEvent(object sender, BuildEventArgs e)
         {
-            // This is false by default
-            if (_forwardingTable[BuildStartedEventDescription] == 1)
-            {
-                ForwardToCentralLogger(e);
-            }
+            ForwardToCentralLogger(e);
         }
 
-        /// <summary>
-        /// Handler for build finished events
-        /// </summary>
-        /// <param name="sender">sender (should be null)</param>
-        /// <param name="e">event arguments</param>
-        private void BuildFinishedHandler(object sender, BuildFinishedEventArgs e)
-        {
-            // This is false by default
-            if (_forwardingTable[BuildFinishedEventDescription] == 1)
-            {
-                ForwardToCentralLogger(e);
-            }
-            ResetLoggerState();
-        }
-
-        /// <summary>
-        /// Handler for project started events
-        /// </summary>
-        /// <param name="sender">sender (should be null)</param>
-        /// <param name="e">event arguments</param>
-        private void ProjectStartedHandler(object sender, ProjectStartedEventArgs e)
-        {
-            if (_forwardingTable[ProjectStartedEventDescription] == 1)
-            {
-                ForwardToCentralLogger(e);
-            }
-        }
-
-        /// <summary>
-        /// Handler for project finished events
-        /// </summary>
-        /// <param name="sender">sender (should be null)</param>
-        /// <param name="e">event arguments</param>
-        private void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e)
-        {
-            if (_forwardingTable[ProjectFinishedEventDescription] == 1)
-            {
-                ForwardToCentralLogger(e);
-            }
-        }
-
-        /// <summary>
-        /// Handler for target started events
-        /// </summary>
-        /// <param name="sender">sender (should be null)</param>
-        /// <param name="e">event arguments</param>
-        private void TargetStartedHandler(object sender, TargetStartedEventArgs e)
-        {
-            if (_forwardingTable[TargetStartedEventDescription] == 1)
-            {
-                ForwardToCentralLogger(e);
-            }
-        }
-
-        /// <summary>
-        /// Handler for target finished events
-        /// </summary>
-        /// <param name="sender">sender (should be null)</param>
-        /// <param name="e">event arguments</param>
-        private void TargetFinishedHandler(object sender, TargetFinishedEventArgs e)
-        {
-            if (_forwardingTable[TargetFinishedEventDescription] == 1)
-            {
-                ForwardToCentralLogger(e);
-            }
-        }
-
-        /// <summary>
-        /// Handler for task started events
-        /// </summary>
-        /// <param name="sender">sender (should be null)</param>
-        /// <param name="e">event arguments</param>
-        private void TaskStartedHandler(object sender, TaskStartedEventArgs e)
+        private void BuildStatusHandler(object sender, BuildStatusEventArgs e)
         {
-            if (_forwardingTable[TaskStartedEventDescription] == 1)
+            if (e is ProjectEvaluationStartedEventArgs || e is ProjectEvaluationFinishedEventArgs)
             {
                 ForwardToCentralLogger(e);
             }
         }
 
         /// <summary>
-        /// Handler for task finished events
+        /// Tailored handler for BuildMessageEventArgs - fine tunes forwarding of messages.
         /// </summary>
         /// <param name="sender">sender (should be null)</param>
         /// <param name="e">event arguments</param>
-        private void TaskFinishedHandler(object sender, TaskFinishedEventArgs e)
-        {
-            if (_forwardingTable[TaskFinishedEventDescription] == 1)
-            {
-                ForwardToCentralLogger(e);
-            }
-        }
-
-        /// <summary>
-        /// Prints an error event
-        /// </summary>
-        private void ErrorHandler(object sender, BuildErrorEventArgs e)
-        {
-            if (_forwardingTable[ErrorEventDescription] == 1)
-            {
-                ForwardToCentralLogger(e);
-            }
-        }
-
-        /// <summary>
-        /// Prints a warning event
-        /// </summary>
-        private void WarningHandler(object sender, BuildWarningEventArgs e)
-        {
-            if (_forwardingTable[WarningEventDescription] == 1)
-            {
-                ForwardToCentralLogger(e);
-            }
-        }
-
-        /// <summary>
-        /// Prints a message event
-        /// </summary>
         private void MessageHandler(object sender, BuildMessageEventArgs e)
         {
-            bool forwardEvent = false;
-
-            if (_forwardingTable[LowMessageEventDescription] == 1 && e.Importance == MessageImportance.Low)
-            {
-                forwardEvent = true;
-            }
-            else if (_forwardingTable[NormalMessageEventDescription] == 1 && e.Importance == MessageImportance.Normal)
-            {
-                forwardEvent = true;
-            }
-            else if (_forwardingTable[HighMessageEventDescription] == 1 && e.Importance == MessageImportance.High)
-            {
-                forwardEvent = true;
-            }
-            else if (_forwardingTable[CommandLineDescription] == 1 && e is TaskCommandLineEventArgs)
-            {
-                forwardEvent = true;
-            }
+            bool forwardEvent =
+                (_forwardLowImportanceMessages && e.Importance == MessageImportance.Low) ||
+                (_forwardNormalImportanceMessages && e.Importance == MessageImportance.Normal) ||
+                (_forwardHighImportanceMessages && e.Importance == MessageImportance.High) ||
+                (_forwardTaskCommandLine && e is TaskCommandLineEventArgs);
 
             if (forwardEvent)
             {
@@ -477,32 +365,13 @@ private void MessageHandler(object sender, BuildMessageEventArgs e)
             }
         }
 
-        /// <summary>
-        /// Prints a custom event
-        /// </summary>
-        private void CustomEventHandler(object sender, CustomBuildEventArgs e)
-        {
-            if (_forwardingTable[CustomEventDescription] == 1)
-            {
-                ForwardToCentralLogger(e);
-            }
-        }
-
-        private void BuildStatusHandler(object sender, BuildStatusEventArgs e)
-        {
-            if (_forwardingTable[ProjectEvaluationEventDescription] == 1 && (e is ProjectEvaluationStartedEventArgs || e is ProjectEvaluationFinishedEventArgs))
-            {
-                ForwardToCentralLogger(e);
-            }
-        }
-
         /// <summary>
         /// Forwards the specified event.
         /// </summary>
         /// <param name="e">The <see cref="BuildEventArgs"/> to forward.</param>
         protected virtual void ForwardToCentralLogger(BuildEventArgs e)
         {
-            _buildEventRedirector.ForwardEvent(e);
+            _buildEventRedirector?.ForwardEvent(e);
         }
 
         /// <summary>
@@ -525,7 +394,7 @@ private bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity)
         /// <summary>
         /// Console logger parameters.
         /// </summary>
-        private string _loggerParameters = null;
+        private string? _loggerParameters = null;
 
         /// <summary>
         /// Console logger parameters delimiters.
@@ -561,17 +430,10 @@ private bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity)
 
         #region Per-build Members
 
-        /// <summary>
-        /// A table indicating if a particular event type should be forwarded
-        /// The value is type int rather than bool to avoid the problem of JITting generics.
-        /// <see cref="Dictionary{String, Int}" /> is already compiled into mscorlib.
-        /// </summary>
-        private Dictionary<string, int> _forwardingTable;
-
         /// <summary>
         /// A pointer to the central logger
         /// </summary>
-        private IEventRedirector _buildEventRedirector;
+        private IEventRedirector? _buildEventRedirector;
 
         /// <summary>
         /// Indicates if the events to forward are being set by the parameters sent to the logger
@@ -600,6 +462,26 @@ private bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity)
         /// </summary>
         private bool _showCommandLine = false;
 
+        /// <summary>
+        /// Fine-tuning of BuildMessageEventArgs forwarding
+        /// </summary>
+        private bool _forwardLowImportanceMessages;
+
+        /// <summary>
+        /// Fine-tuning of BuildMessageEventArgs forwarding
+        /// </summary>
+        private bool _forwardNormalImportanceMessages;
+
+        /// <summary>
+        /// Fine-tuning of BuildMessageEventArgs forwarding
+        /// </summary>
+        private bool _forwardHighImportanceMessages;
+
+        /// <summary>
+        /// Fine-tuning of BuildMessageEventArgs forwarding
+        /// </summary>
+        private bool _forwardTaskCommandLine;
+
         /// <summary>
         /// Id of the node the logger is attached to
         /// </summary>
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index 21271e12fb0..67b1d939f93 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -68,7 +68,7 @@ private void ParseFileLoggerParameters()
         /// </summary>
         private void ApplyFileLoggerParameter(string parameterName, string parameterValue)
         {
-            if (String.Equals("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase))
+            if (string.Equals("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase))
             {
                 if (string.IsNullOrEmpty(parameterValue))
                 {
@@ -104,7 +104,7 @@ public void Initialize(IEventSource eventSource)
                 _nodeFileLogger = new FileLogger();
                 string extension = Path.GetExtension(_logFile);
                 // If there is no extension add a default of .log to it
-                if (String.IsNullOrEmpty(extension))
+                if (string.IsNullOrEmpty(extension))
                 {
                     _logFile += ".log";
                     extension = ".log";
diff --git a/src/Build/Logging/LoggerDescription.cs b/src/Build/Logging/LoggerDescription.cs
index a66ac147253..ef3a68959ab 100644
--- a/src/Build/Logging/LoggerDescription.cs
+++ b/src/Build/Logging/LoggerDescription.cs
@@ -89,7 +89,7 @@ internal int LoggerId
         /// <summary>
         /// This property generates the logger name by appending together the class name and assembly name
         /// </summary>
-        internal string Name
+        public string Name
         {
             get
             {
@@ -104,7 +104,7 @@ internal string Name
                 }
                 else
                 {
-                    return _loggerAssembly.AssemblyFile;
+                    return _loggerAssembly.AssemblyFile ?? _loggerAssembly.AssemblyName;
                 }
             }
         }
diff --git a/src/Build/Logging/SimpleErrorLogger.cs b/src/Build/Logging/SimpleErrorLogger.cs
index 6414324064b..a1e387f69aa 100644
--- a/src/Build/Logging/SimpleErrorLogger.cs
+++ b/src/Build/Logging/SimpleErrorLogger.cs
@@ -70,11 +70,11 @@ private void LogWithColor(string message, TerminalColor color)
         {
             if (acceptAnsiColorCodes)
             {
-                Console.Error.Write(AnsiCodes.Colorize(message, color));
+                Console.Error.WriteLine(AnsiCodes.Colorize(message, color));
             }
             else
             {
-                Console.Error.Write(message);
+                Console.Error.WriteLine(message);
             }
         }
 
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 436bf030051..ebcff02886d 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -160,10 +160,6 @@
     <Compile Include="FileAccess\ProcessData.cs" />
     <Compile Include="FileAccess\ReportedFileOperation.cs" />
     <Compile Include="FileAccess\RequestedAccess.cs" />
-    <Compile Include="Logging\BinaryLogger\ExtendedDataFields.cs" />
-    <Compile Include="Logging\BinaryLogger\IBuildEventArgsReaderNotifications.cs" />
-    <Compile Include="Logging\BinaryLogger\IBuildEventStringsReader.cs" />
-    <Compile Include="Logging\BinaryLogger\StringReadEventArgs.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
@@ -251,6 +247,7 @@
     <Compile Include="Collections\RetrievableEntryHashSet\BitHelper.cs" />
     <Compile Include="Collections\RetrievableEntryHashSet\HashSetDebugView.cs" />
     <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\IRetrievableEntryHashSet.cs" />
     <Compile Include="Construction\ImplicitImportLocation.cs" />
     <Compile Include="Construction\ProjectSdkElement.cs" />
     <Compile Include="Definition\ProjectOptions.cs" />
@@ -369,6 +366,8 @@
     <Compile Include="Collections\CopyOnWritePropertyDictionary.cs" />
     <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
     <Compile Include="Collections\HashTableUtility.cs" />
+    <Compile Include="Collections\IConstrainableDictionary.cs" />
+    <Compile Include="Collections\IItemDictionary.cs" />
     <Compile Include="Collections\ItemDictionary.cs" />
     <Compile Include="Collections\IImmutable.cs" />
     <Compile Include="Collections\MultiDictionary.cs" />
@@ -491,6 +490,9 @@
     <Compile Include="Globbing\IMSBuildGlob.cs" />
     <Compile Include="Globbing\Visitor\ParsedGlobCollector.cs" />
     <!-- #### INSTANCE MODEL ### -->
+    <Compile Include="Instance\IImmutableInstanceProvider.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableElementCollectionConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableItemDictionary.cs" />
     <Compile Include="Instance\ReflectableTaskPropertyInfo.cs" />
     <Compile Include="Instance\HostServices.cs" />
     <Compile Include="Instance\ProjectTargetInstanceChild.cs" />
@@ -527,6 +529,8 @@
     <Compile Include="Logging\BinaryLogger\BuildEventArgsReader.cs" />
     <Compile Include="Logging\BinaryLogger\BuildEventArgsWriter.cs" />
     <Compile Include="Logging\BinaryLogger\ProjectImportsCollector.cs" />
+    <Compile Include="Logging\BinaryLogger\ExtendedDataFields.cs" />
+    <Compile Include="Logging\BinaryLogger\Postprocessing\*.cs" />
     <Compile Include="Logging\ConsoleLogger.cs" />
     <Compile Include="Logging\DistributedLoggers\DistributedFileLogger.cs" />
     <Compile Include="Logging\DistributedLoggers\ConfigurableForwardingLogger.cs" />
@@ -670,4 +674,54 @@
       <LogicalName>$(AssemblyName).Strings.shared.resources</LogicalName>
     </EmbeddedResource>
   </ItemGroup>
+
+  <PropertyGroup>
+    <NuGetFrameworkWrapperRedirects_FilePath>$(IntermediateOutputPath)NuGetFrameworkWrapper.redirects.cs</NuGetFrameworkWrapperRedirects_FilePath>
+  </PropertyGroup>
+
+  <!-- Extract binding redirects for Microsoft.Build from MSBuild.exe.config into a source file -->
+  <Target Name="GenerateAppDomainConfig"
+          Inputs="..\MSBuild\app.config;..\MSBuild\app.amd64.config"
+          Outputs="$(NuGetFrameworkWrapperRedirects_FilePath)"
+          BeforeTargets="CoreCompile"
+          Condition="'$(FeatureAppDomain)' == 'true'">
+    <PropertyGroup>
+      <BindingRedirectNamespace>&lt;Namespace Prefix='ns' Uri='urn:schemas-microsoft-com:asm.v1' /&gt;</BindingRedirectNamespace>
+      <BindingRedirectXPath>/configuration/runtime/ns:assemblyBinding/ns:dependentAssembly[ns:assemblyIdentity/@name='Microsoft.Build']</BindingRedirectXPath>
+    </PropertyGroup>
+
+    <XmlPeek XmlInputPath="..\MSBuild\app.config" Query="$(BindingRedirectXPath)" Namespaces="$(BindingRedirectNamespace)">
+      <Output TaskParameter="Result" ItemName="BindingRedirect32" />
+    </XmlPeek>
+    <XmlPeek XmlInputPath="..\MSBuild\app.amd64.config" Query="$(BindingRedirectXPath)" Namespaces="$(BindingRedirectNamespace)">
+      <Output TaskParameter="Result" ItemName="BindingRedirect64" />
+    </XmlPeek>
+
+    <PropertyGroup>
+      <NuGetFrameworkWrapperRedirects_Content><![CDATA[
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Evaluation%3B;
+
+[System.CodeDom.Compiler.GeneratedCode("GenerateAppDomainConfig", "1.0")]
+internal sealed partial class NuGetFrameworkWrapper
+{
+    private const string _bindingRedirect32 = """;@(BindingRedirect32);"""%3B;
+    private const string _bindingRedirect64 = """;@(BindingRedirect64);"""%3B;
+}
+]]>
+      </NuGetFrameworkWrapperRedirects_Content>
+    </PropertyGroup>
+
+    <WriteLinesToFile File="$(NuGetFrameworkWrapperRedirects_FilePath)" Overwrite="true" WriteOnlyWhenDifferent="true" Lines="$(NuGetFrameworkWrapperRedirects_Content)" />
+
+    <ItemGroup>
+      <Compile Remove="$(NuGetFrameworkWrapperRedirects_FilePath)" />
+      <Compile Include="$(NuGetFrameworkWrapperRedirects_FilePath)">
+        <Link>Utilities\NuGetFrameworkWrapper.redirects.cs</Link>
+      </Compile>
+      <FileWrites Include="$(NuGetFrameworkWrapperRedirects_FilePath)" />
+    </ItemGroup>
+  </Target>
 </Project>
diff --git a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
index 4baaa9ace7d..c0165f577a5 100644
--- a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
+++ b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
@@ -4,6 +4,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 
 #nullable disable
@@ -236,20 +237,22 @@ public UsingTaskParameterGroupElement Create(UsingTaskParameterGroupElementLink
         // memory storage of original items (with the Link field) while it is small, some of the MSbuild items can be created
         // in millions so it does adds up otherwise.
 
-        private class LinkedProjectItem : ProjectItem, ILinkableObject
+        private class LinkedProjectItem : ProjectItem, ILinkableObject, IImmutableInstanceProvider<ProjectItemInstance>
         {
             internal LinkedProjectItem(ProjectItemElement xml, Project project, ProjectItemLink link)
                 : base(xml, project)
             {
-                this.Link = link;
+                Link = link;
             }
 
+            public ProjectItemInstance ImmutableInstance { get; set; }
+
             internal override ProjectItemLink Link { get; }
 
             object ILinkableObject.Link => Link;
         }
 
-        private class LinkedProjectItemDefinition : ProjectItemDefinition, ILinkableObject
+        private class LinkedProjectItemDefinition : ProjectItemDefinition, ILinkableObject, IImmutableInstanceProvider<ProjectItemDefinitionInstance>
         {
             internal LinkedProjectItemDefinition(ProjectItemDefinitionLink link, Project project, string itemType)
                 : base(project, itemType)
@@ -257,6 +260,8 @@ internal LinkedProjectItemDefinition(ProjectItemDefinitionLink link, Project pro
                 Link = link;
             }
 
+            public ProjectItemDefinitionInstance ImmutableInstance { get; set; }
+
             internal override ProjectItemDefinitionLink Link { get; }
             object ILinkableObject.Link => Link;
         }
@@ -273,7 +278,7 @@ internal LinkedProjectMetadata(object parent, ProjectMetadataLink link)
             object ILinkableObject.Link => Link;
         }
 
-        private class LinkedProjectProperty : ProjectProperty, ILinkableObject
+        private class LinkedProjectProperty : ProjectProperty, ILinkableObject, IImmutableInstanceProvider<ProjectPropertyInstance>
         {
             internal ProjectPropertyLink Link { get; }
             object ILinkableObject.Link => Link;
@@ -290,6 +295,8 @@ internal LinkedProjectProperty(Project project, ProjectPropertyLink link)
                 Link = link;
             }
 
+            public ProjectPropertyInstance ImmutableInstance { get; set;  }
+
             public override string Name => Link.Name;
 
             public override string UnevaluatedValue
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 119cfeaf410..b10df4f55d0 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -469,6 +469,13 @@
     likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
     special exception to abort the build.</comment>
   </data>
+  <data name="FatalErrorWhileLoggingWithInnerException" xml:space="preserve">
+    <value>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</value>
+    <comment>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
+    likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
+    special exception to abort the build.</comment>
+  </data>
   <data name="General.TwoVectorsMustHaveSameLength">
     <value>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</value>
     <comment>{StrBegin="MSB3094: "}</comment>
@@ -1324,6 +1331,17 @@
     <value>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
   {1}</value>
   </data>
+  <data name="SucceededToResolveSDK" xml:space="preserve">
+    <value>The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</value>
+  </data>
+  <data name="SDKResolverAttempt" xml:space="preserve">
+    <value>The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</value>
+    <comment>
+      LOCALIZATION: Do not localize the word SDK. "{2}" is new line separated warnings or "null". "{3}" is new line separated errors or "null".
+    </comment>
+  </data>
   <data name="CouldNotRunNuGetSdkResolver" xml:space="preserve">
     <value>The NuGet-based SDK resolver failed to run because NuGet assemblies could not be located.  Check your installation of MSBuild or set the environment variable "{0}" to the folder that contains the required NuGet assemblies. {1}</value>
   </data>
@@ -1352,7 +1370,7 @@
     <comment>{StrBegin="MSB4068: "}</comment>
   </data>
   <data name="UnsupportedLogFileFormat" xml:space="preserve">
-    <value>MSB4235: The log file format version is {0}, whereas this version of MSBuild only supports versions up to {1}.</value>
+    <value>MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</value>
     <comment>{StrBegin="MSB4235: "}</comment>
   </data>
   <data name="UnsupportedTaskParameterTypeError" xml:space="preserve">
@@ -1769,12 +1787,6 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION:  Do not localize the word SDK.
     </comment>
   </data>
-  <data name="SdkResolving" xml:space="preserve">
-    <value>Resolving SDK '{0}'...</value>
-    <comment>
-      LOCALIZATION:  Do not localize the word SDK.
-    </comment>
-  </data>
   <data name="ProjectGraphDoesNotSupportProjectReferenceWithToolset" xml:space="preserve">
     <value>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</value>
     <comment>
@@ -1889,7 +1901,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>Property initial value: $({0})="{1}" Source: {2}</value>
   </data>
   <data name="NuGetAssemblyNotFound" xml:space="preserve">
-    <value>A required NuGet assembly was not found. Expected Path: {0}</value>
+    <value>A required NuGet assembly '{0}' could not be loaded.</value>
   </data>
   <data name="StaticGraphConstructionMetrics" xml:space="preserve">
     <value>Static graph loaded in {0} seconds: {1} nodes, {2} edges</value>
@@ -2010,6 +2022,75 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="ReportFileAccessesX64Only" xml:space="preserve">
     <value>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</value>
   </data>
+  <data name="Binlog_Source_MultiSubscribeError" xml:space="preserve">
+    <value>Structured events and raw events cannot be replayed at the same time.</value>
+  </data>
+  <data name="Binlog_Source_MissingSubscribeError" xml:space="preserve">
+    <value>No subscribers for any events.</value>
+  </data>
+  <data name="Binlog_Source_VersionUninitialized" xml:space="preserve">
+    <value>Version info not yet initialized. Replay must be called first.</value>
+  </data>
+  <data name="Binlog_MissingRecoverableErrorSubscribeError" xml:space="preserve">
+    <value>Subscription to RecoverableReadError is mandatory during forward compatible reading.</value>
+  </data>
+  <data name="Binlog_ImportFileSizeError" xml:space="preserve">
+    <value>Imported files archive exceeded 2GB limit and it's not embedded.</value>
+  </data>
+  <data name="Binlog_FwdCompatUnsupported" xml:space="preserve">
+    <value>Forward compatible reading is not supported for file format version {0} (needs >= 18).</value>
+    <comment>
+      LOCALIZATION: {0} is an integer number denoting version.
+    </comment>
+  </data>
+  <data name="Binlog_ReaderSkippingRecord" xml:space="preserve">
+    <value>Skipping the record.</value>
+  </data>
+  <data name="Binlog_ReaderMismatchedRead" xml:space="preserve">
+    <value>BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</value>
+    <comment>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an exception type and {3} the exception message string.
+    </comment>
+  </data>
+  <data name="Binlog_ReaderUnknownType" xml:space="preserve">
+    <value>BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</value>
+    <comment>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is a string or integer value indicating type.
+    </comment>
+  </data>
+  <data name="Binlog_ReaderUnderRead" xml:space="preserve">
+    <value>BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</value>
+    <comment>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an integer value indicating number of bytes.
+    </comment>
+  </data>
+  <data name="Binlog_ArchiveFile_AcquiredAsStream" xml:space="preserve">
+    <value>Content already acquired as StreamReader via GetContentReader.</value>
+  </data>
+  <data name="Binlog_ArchiveFile_AcquiredAsString" xml:space="preserve">
+    <value>Content already acquired as string via GetContent or initialized as string only.</value>
+  </data>
+  <data name="Binlog_ArchiveFile_NotSetAfterAcquire" xml:space="preserve">
+    <value>ArchiveFile was obtained, but the final edited version was not set.</value>
+  </data>
+  <data name="Binlog_StreamUtils_MustBeReadable" xml:space="preserve">
+    <value>Stream must be readable.</value>
+  </data>
+  <data name="Binlog_StreamUtils_SeekNonOrigin" xml:space="preserve">
+    <value>Only seeking from SeekOrigin.Current is supported.</value>
+  </data>
+  <data name="Binlog_StreamUtils_SetLengthUnsupported" xml:space="preserve">
+    <value>Changing the stream length is not supported.</value>
+  </data>
+  <data name="Binlog_StreamUtils_WriteUnsupported" xml:space="preserve">
+    <value>Writing is not supported.</value>
+  </data>
+  <data name="Binlog_StreamUtils_UnsupportedSkipOffset" xml:space="preserve">
+    <value>Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</value>
+    <comment>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </comment>
+  </data>
   <!--
         The Build message bucket is: MSB4000 - MSB4999
 
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index bb072a16a70..92472b6aa70 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -26,6 +26,106 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsStream">
+        <source>Content already acquired as StreamReader via GetContentReader.</source>
+        <target state="new">Content already acquired as StreamReader via GetContentReader.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsString">
+        <source>Content already acquired as string via GetContent or initialized as string only.</source>
+        <target state="new">Content already acquired as string via GetContent or initialized as string only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_NotSetAfterAcquire">
+        <source>ArchiveFile was obtained, but the final edited version was not set.</source>
+        <target state="new">ArchiveFile was obtained, but the final edited version was not set.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_FwdCompatUnsupported">
+        <source>Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</source>
+        <target state="new">Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting version.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ImportFileSizeError">
+        <source>Imported files archive exceeded 2GB limit and it's not embedded.</source>
+        <target state="new">Imported files archive exceeded 2GB limit and it's not embedded.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_MissingRecoverableErrorSubscribeError">
+        <source>Subscription to RecoverableReadError is mandatory during forward compatible reading.</source>
+        <target state="new">Subscription to RecoverableReadError is mandatory during forward compatible reading.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderMismatchedRead">
+        <source>BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an exception type and {3} the exception message string.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderSkippingRecord">
+        <source>Skipping the record.</source>
+        <target state="new">Skipping the record.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnderRead">
+        <source>BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</source>
+        <target state="new">BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an integer value indicating number of bytes.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnknownType">
+        <source>BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is a string or integer value indicating type.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MissingSubscribeError">
+        <source>No subscribers for any events.</source>
+        <target state="new">No subscribers for any events.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MultiSubscribeError">
+        <source>Structured events and raw events cannot be replayed at the same time.</source>
+        <target state="new">Structured events and raw events cannot be replayed at the same time.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_VersionUninitialized">
+        <source>Version info not yet initialized. Replay must be called first.</source>
+        <target state="new">Version info not yet initialized. Replay must be called first.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_MustBeReadable">
+        <source>Stream must be readable.</source>
+        <target state="new">Stream must be readable.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SeekNonOrigin">
+        <source>Only seeking from SeekOrigin.Current is supported.</source>
+        <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SetLengthUnsupported">
+        <source>Changing the stream length is not supported.</source>
+        <target state="new">Changing the stream length is not supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
+        <source>Writing is not supported.</source>
+        <target state="new">Writing is not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Vytvoen otzky SELHALO. Vytven bylo pedasn ukoneno, protoe se pi nm narazilo na cl nebo lohu, kter nebyly aktuln.</target>
@@ -149,6 +249,15 @@
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FatalErrorWhileLoggingWithInnerException">
+        <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</source>
+        <target state="new">MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</target>
+        <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
+    likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
+    special exception to abort the build.</note>
+      </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
         <target state="translated">MSB3094: Poloka {2} odkazuje na {0} poloek a poloka {3} odkazuje na {1} poloek. Mus mt stejn poet poloek.</target>
@@ -222,8 +331,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Poadovan sestaven NuGet se nenalo. Oekvan cesta: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">Nepovedlo se nast poadovan sestaven NuGet {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -390,6 +499,17 @@
         <target state="translated">Pstupy k souborm sestav se v souasn dob podporuj jenom pomoc varianty x64 nstroje MSBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverAttempt">
+        <source>The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</source>
+        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</target>
+        <note>
+      LOCALIZATION: Do not localize the word SDK. "{2}" is new line separated warnings or "null". "{3}" is new line separated errors or "null".
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Selhn pekladae sady SDK: {0}</target>
@@ -451,6 +571,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="SucceededToResolveSDK">
+        <source>The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</source>
+        <target state="new">The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
         <target state="translated">loha {0} poadovala tento poet jader: {1}. Zskala tento poet jader: {2}. Te pouv celkem tento poet jader: {3}</target>
@@ -2490,8 +2615,8 @@ Vyuit:          Prmrn vyuit {0}: {1:###.0}</target>
         <note>{StrBegin="MSB4238: "}</note>
       </trans-unit>
       <trans-unit id="UnsupportedLogFileFormat">
-        <source>MSB4235: The log file format version is {0}, whereas this version of MSBuild only supports versions up to {1}.</source>
-        <target state="translated">MSB4235: Verze formtu souboru protokolu je {0}, ale tato verze nstroje MSBuild podporuje jenom verze do {1}.</target>
+        <source>MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</source>
+        <target state="new">MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</target>
         <note>{StrBegin="MSB4235: "}</note>
       </trans-unit>
       <trans-unit id="ProjectEvaluationPerformanceSummary">
@@ -2581,13 +2706,6 @@ Vyuit:          Prmrn vyuit {0}: {1:###.0}</target>
         <target state="translated">MSB4241: Odkaz na sadu SDK {0} verze {1} byl msto toho peloen na verzi {2}. Pokud neaktualizujete odkazovanou verzi tak, aby se shodovala, me se pouvat jin verze, ne kterou oekvte.</target>
         <note>{StrBegin="MSB4241: "}
       LOCALIZATION:  Do not localize the word SDK.
-    </note>
-      </trans-unit>
-      <trans-unit id="SdkResolving">
-        <source>Resolving SDK '{0}'...</source>
-        <target state="translated">Pekld se sada SDK {0}...</target>
-        <note>
-      LOCALIZATION:  Do not localize the word SDK.
     </note>
       </trans-unit>
       <trans-unit id="SdkResolverManifestInvalid">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 0778e20da99..5f340191f4f 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -26,6 +26,106 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsStream">
+        <source>Content already acquired as StreamReader via GetContentReader.</source>
+        <target state="new">Content already acquired as StreamReader via GetContentReader.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsString">
+        <source>Content already acquired as string via GetContent or initialized as string only.</source>
+        <target state="new">Content already acquired as string via GetContent or initialized as string only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_NotSetAfterAcquire">
+        <source>ArchiveFile was obtained, but the final edited version was not set.</source>
+        <target state="new">ArchiveFile was obtained, but the final edited version was not set.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_FwdCompatUnsupported">
+        <source>Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</source>
+        <target state="new">Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting version.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ImportFileSizeError">
+        <source>Imported files archive exceeded 2GB limit and it's not embedded.</source>
+        <target state="new">Imported files archive exceeded 2GB limit and it's not embedded.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_MissingRecoverableErrorSubscribeError">
+        <source>Subscription to RecoverableReadError is mandatory during forward compatible reading.</source>
+        <target state="new">Subscription to RecoverableReadError is mandatory during forward compatible reading.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderMismatchedRead">
+        <source>BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an exception type and {3} the exception message string.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderSkippingRecord">
+        <source>Skipping the record.</source>
+        <target state="new">Skipping the record.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnderRead">
+        <source>BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</source>
+        <target state="new">BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an integer value indicating number of bytes.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnknownType">
+        <source>BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is a string or integer value indicating type.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MissingSubscribeError">
+        <source>No subscribers for any events.</source>
+        <target state="new">No subscribers for any events.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MultiSubscribeError">
+        <source>Structured events and raw events cannot be replayed at the same time.</source>
+        <target state="new">Structured events and raw events cannot be replayed at the same time.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_VersionUninitialized">
+        <source>Version info not yet initialized. Replay must be called first.</source>
+        <target state="new">Version info not yet initialized. Replay must be called first.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_MustBeReadable">
+        <source>Stream must be readable.</source>
+        <target state="new">Stream must be readable.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SeekNonOrigin">
+        <source>Only seeking from SeekOrigin.Current is supported.</source>
+        <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SetLengthUnsupported">
+        <source>Changing the stream length is not supported.</source>
+        <target state="new">Changing the stream length is not supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
+        <source>Writing is not supported.</source>
+        <target state="new">Writing is not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Fehler beim Erstellen der Frage. Der Build wurde frh beendet, da ein Ziel oder eine Aufgabe gefunden wurde, die nicht aktuell war.</target>
@@ -149,6 +249,15 @@
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FatalErrorWhileLoggingWithInnerException">
+        <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</source>
+        <target state="new">MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</target>
+        <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
+    likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
+    special exception to abort the build.</note>
+      </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
         <target state="translated">MSB3094: "{2}" verweist auf {0} Element(e), und "{3}" verweist auf {1} Element(e). Die Anzahl von Elementen muss identisch sein.</target>
@@ -222,8 +331,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Eine erforderliche NuGet-Assembly wurde nicht gefunden. Erwarteter Pfad: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">Eine erforderliche NuGet-Assembly "{0}" konnte nicht geladen werden.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -390,6 +499,17 @@
         <target state="translated">Das Melden von Dateizugriffen wird derzeit nur mit der x64-Variante von MSBuild untersttzt.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverAttempt">
+        <source>The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</source>
+        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</target>
+        <note>
+      LOCALIZATION: Do not localize the word SDK. "{2}" is new line separated warnings or "null". "{3}" is new line separated errors or "null".
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Fehler bei SDK-Resolver: "{0}"</target>
@@ -451,6 +571,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="SucceededToResolveSDK">
+        <source>The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</source>
+        <target state="new">The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
         <target state="translated">Die Aufgabe "{0}" hat {1} Kerne angefordert und {2} Kerne erhalten und belegt jetzt insgesamt {3} Kerne.</target>
@@ -2490,8 +2615,8 @@ Auslastung:          {0} Durchschnittliche Auslastung: {1:###.0}</target>
         <note>{StrBegin="MSB4238: "}</note>
       </trans-unit>
       <trans-unit id="UnsupportedLogFileFormat">
-        <source>MSB4235: The log file format version is {0}, whereas this version of MSBuild only supports versions up to {1}.</source>
-        <target state="translated">MSB4235: Die Protokolldatei hat die Formatversion {0}, diese Version von MSBuild untersttzt jedoch nur Versionen bis zu {1}.</target>
+        <source>MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</source>
+        <target state="new">MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</target>
         <note>{StrBegin="MSB4235: "}</note>
       </trans-unit>
       <trans-unit id="ProjectEvaluationPerformanceSummary">
@@ -2581,13 +2706,6 @@ Auslastung:          {0} Durchschnittliche Auslastung: {1:###.0}</target>
         <target state="translated">MSB4241: Der SDK-Verweis "{0}" auf Version "{1}" wurde stattdessen in Version "{2}" aufgelst. Sie knnten eine andere Version als die erwartete verwenden, wenn Sie die referenzierte Version nicht entsprechend aktualisieren.</target>
         <note>{StrBegin="MSB4241: "}
       LOCALIZATION:  Do not localize the word SDK.
-    </note>
-      </trans-unit>
-      <trans-unit id="SdkResolving">
-        <source>Resolving SDK '{0}'...</source>
-        <target state="translated">SDK "{0}" wird aufgelst...</target>
-        <note>
-      LOCALIZATION:  Do not localize the word SDK.
     </note>
       </trans-unit>
       <trans-unit id="SdkResolverManifestInvalid">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index ad0b6a876a3..569bd2020b9 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -26,6 +26,106 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsStream">
+        <source>Content already acquired as StreamReader via GetContentReader.</source>
+        <target state="new">Content already acquired as StreamReader via GetContentReader.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsString">
+        <source>Content already acquired as string via GetContent or initialized as string only.</source>
+        <target state="new">Content already acquired as string via GetContent or initialized as string only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_NotSetAfterAcquire">
+        <source>ArchiveFile was obtained, but the final edited version was not set.</source>
+        <target state="new">ArchiveFile was obtained, but the final edited version was not set.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_FwdCompatUnsupported">
+        <source>Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</source>
+        <target state="new">Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting version.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ImportFileSizeError">
+        <source>Imported files archive exceeded 2GB limit and it's not embedded.</source>
+        <target state="new">Imported files archive exceeded 2GB limit and it's not embedded.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_MissingRecoverableErrorSubscribeError">
+        <source>Subscription to RecoverableReadError is mandatory during forward compatible reading.</source>
+        <target state="new">Subscription to RecoverableReadError is mandatory during forward compatible reading.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderMismatchedRead">
+        <source>BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an exception type and {3} the exception message string.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderSkippingRecord">
+        <source>Skipping the record.</source>
+        <target state="new">Skipping the record.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnderRead">
+        <source>BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</source>
+        <target state="new">BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an integer value indicating number of bytes.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnknownType">
+        <source>BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is a string or integer value indicating type.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MissingSubscribeError">
+        <source>No subscribers for any events.</source>
+        <target state="new">No subscribers for any events.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MultiSubscribeError">
+        <source>Structured events and raw events cannot be replayed at the same time.</source>
+        <target state="new">Structured events and raw events cannot be replayed at the same time.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_VersionUninitialized">
+        <source>Version info not yet initialized. Replay must be called first.</source>
+        <target state="new">Version info not yet initialized. Replay must be called first.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_MustBeReadable">
+        <source>Stream must be readable.</source>
+        <target state="new">Stream must be readable.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SeekNonOrigin">
+        <source>Only seeking from SeekOrigin.Current is supported.</source>
+        <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SetLengthUnsupported">
+        <source>Changing the stream length is not supported.</source>
+        <target state="new">Changing the stream length is not supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
+        <source>Writing is not supported.</source>
+        <target state="new">Writing is not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">La creacin de la pregunta ha FALLADO. La creacin finaliz antes de tiempo al encontrar un objetivo o tarea que no estaba actualizado.</target>
@@ -149,6 +249,15 @@
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FatalErrorWhileLoggingWithInnerException">
+        <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</source>
+        <target state="new">MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</target>
+        <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
+    likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
+    special exception to abort the build.</note>
+      </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
         <target state="translated">MSB3094: "{2}" hace referencia a {0} elementos y "{3}" hace referencia a {1} elementos. Deben tener el mismo nmero de elementos.</target>
@@ -222,8 +331,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">No se encontr un ensamblado de NuGet necesario. Ruta de acceso esperada: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">No se pudo cargar un ensamblado NuGet necesario "{0}".</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -390,6 +499,17 @@
         <target state="translated">Los accesos a archivos de informes solo se admiten actualmente con el tipo x64 de MSBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverAttempt">
+        <source>The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</source>
+        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</target>
+        <note>
+      LOCALIZATION: Do not localize the word SDK. "{2}" is new line separated warnings or "null". "{3}" is new line separated errors or "null".
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Error del solucionador del SDK: "{0}"</target>
@@ -451,6 +571,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="SucceededToResolveSDK">
+        <source>The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</source>
+        <target state="new">The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
         <target state="translated">La tarea "{0}" solicit {1}ncleos, adquiri {2}ncleos y ahora retiene un total de {3}ncleos.</target>
@@ -2490,8 +2615,8 @@ Utilizacin:          Utilizacin media de {0}: {1:###.0}</target>
         <note>{StrBegin="MSB4238: "}</note>
       </trans-unit>
       <trans-unit id="UnsupportedLogFileFormat">
-        <source>MSB4235: The log file format version is {0}, whereas this version of MSBuild only supports versions up to {1}.</source>
-        <target state="translated">MSB4235: La versin del formato del archivo de registro es {0}, mientras que la versin de MSBuild solo admite versiones hasta {1}.</target>
+        <source>MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</source>
+        <target state="new">MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</target>
         <note>{StrBegin="MSB4235: "}</note>
       </trans-unit>
       <trans-unit id="ProjectEvaluationPerformanceSummary">
@@ -2581,13 +2706,6 @@ Utilizacin:          Utilizacin media de {0}: {1:###.0}</target>
         <target state="translated">MSB4241: La referencia del SKD "{0}", versin "{1}", se resolvi en la versin "{2}". Podra estar utilizando una versin diferente de la esperada si no actualiza la versin de referencia para que coincida.</target>
         <note>{StrBegin="MSB4241: "}
       LOCALIZATION:  Do not localize the word SDK.
-    </note>
-      </trans-unit>
-      <trans-unit id="SdkResolving">
-        <source>Resolving SDK '{0}'...</source>
-        <target state="translated">Resolviendo SDK "{0}"...</target>
-        <note>
-      LOCALIZATION:  Do not localize the word SDK.
     </note>
       </trans-unit>
       <trans-unit id="SdkResolverManifestInvalid">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 5ad4606c62a..9dadb914184 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -26,6 +26,106 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsStream">
+        <source>Content already acquired as StreamReader via GetContentReader.</source>
+        <target state="new">Content already acquired as StreamReader via GetContentReader.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsString">
+        <source>Content already acquired as string via GetContent or initialized as string only.</source>
+        <target state="new">Content already acquired as string via GetContent or initialized as string only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_NotSetAfterAcquire">
+        <source>ArchiveFile was obtained, but the final edited version was not set.</source>
+        <target state="new">ArchiveFile was obtained, but the final edited version was not set.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_FwdCompatUnsupported">
+        <source>Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</source>
+        <target state="new">Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting version.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ImportFileSizeError">
+        <source>Imported files archive exceeded 2GB limit and it's not embedded.</source>
+        <target state="new">Imported files archive exceeded 2GB limit and it's not embedded.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_MissingRecoverableErrorSubscribeError">
+        <source>Subscription to RecoverableReadError is mandatory during forward compatible reading.</source>
+        <target state="new">Subscription to RecoverableReadError is mandatory during forward compatible reading.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderMismatchedRead">
+        <source>BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an exception type and {3} the exception message string.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderSkippingRecord">
+        <source>Skipping the record.</source>
+        <target state="new">Skipping the record.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnderRead">
+        <source>BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</source>
+        <target state="new">BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an integer value indicating number of bytes.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnknownType">
+        <source>BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is a string or integer value indicating type.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MissingSubscribeError">
+        <source>No subscribers for any events.</source>
+        <target state="new">No subscribers for any events.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MultiSubscribeError">
+        <source>Structured events and raw events cannot be replayed at the same time.</source>
+        <target state="new">Structured events and raw events cannot be replayed at the same time.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_VersionUninitialized">
+        <source>Version info not yet initialized. Replay must be called first.</source>
+        <target state="new">Version info not yet initialized. Replay must be called first.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_MustBeReadable">
+        <source>Stream must be readable.</source>
+        <target state="new">Stream must be readable.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SeekNonOrigin">
+        <source>Only seeking from SeekOrigin.Current is supported.</source>
+        <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SetLengthUnsupported">
+        <source>Changing the stream length is not supported.</source>
+        <target state="new">Changing the stream length is not supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
+        <source>Writing is not supported.</source>
+        <target state="new">Writing is not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">CHEC de la gnration de la question. La gnration sest arrte tt, car elle a rencontr une cible ou une tche qui ntait pas  jour.</target>
@@ -149,6 +249,15 @@
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FatalErrorWhileLoggingWithInnerException">
+        <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</source>
+        <target state="new">MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</target>
+        <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
+    likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
+    special exception to abort the build.</note>
+      </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
         <target state="translated">MSB3094: "{2}" fait rfrence  {0} lment(s) et "{3}",  {1} lment(s). Ils doivent avoir le mme nombre d'lments.</target>
@@ -222,8 +331,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Un assembly NuGet obligatoire est introuvable. Chemin attendu: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">Impossible de charger une assemble NuGet {0} requise.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -390,6 +499,17 @@
         <target state="translated">Les accs aux fichiers de cration de rapports sont uniquement pris en charge  laide de la saveur x64 de MSBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverAttempt">
+        <source>The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</source>
+        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</target>
+        <note>
+      LOCALIZATION: Do not localize the word SDK. "{2}" is new line separated warnings or "null". "{3}" is new line separated errors or "null".
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: chec du Programme de Rsolution SDK : {0}</target>
@@ -451,6 +571,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="SucceededToResolveSDK">
+        <source>The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</source>
+        <target state="new">The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
         <target state="translated">La tche "{0}" a demand {1} curs et a obtenu {2} curs. Elle dtient dsormais {3} curs au total.</target>
@@ -2490,8 +2615,8 @@ Utilisation:          {0} Utilisation moyenne: {1:###.0}</target>
         <note>{StrBegin="MSB4238: "}</note>
       </trans-unit>
       <trans-unit id="UnsupportedLogFileFormat">
-        <source>MSB4235: The log file format version is {0}, whereas this version of MSBuild only supports versions up to {1}.</source>
-        <target state="translated">MSB4235: Le format du fichier journal correspond  la version {0}, alors que cette version de MSBuild ne prend en charge que les versions allant jusqu' {1}.</target>
+        <source>MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</source>
+        <target state="new">MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</target>
         <note>{StrBegin="MSB4235: "}</note>
       </trans-unit>
       <trans-unit id="ProjectEvaluationPerformanceSummary">
@@ -2581,13 +2706,6 @@ Utilisation:          {0} Utilisation moyenne: {1:###.0}</target>
         <target state="translated">MSB4241: La rfrence du SDK "{0}" version "{1}" a t rsolue avec la version "{2}"  la place. Vous risquez d'utiliser une version diffrente de celle attendue si vous ne mettez pas  jour la version rfrence correspondante.</target>
         <note>{StrBegin="MSB4241: "}
       LOCALIZATION:  Do not localize the word SDK.
-    </note>
-      </trans-unit>
-      <trans-unit id="SdkResolving">
-        <source>Resolving SDK '{0}'...</source>
-        <target state="translated">Rsolution du SDK '{0}'...</target>
-        <note>
-      LOCALIZATION:  Do not localize the word SDK.
     </note>
       </trans-unit>
       <trans-unit id="SdkResolverManifestInvalid">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index b8fe5cd168d..ece23442fc7 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -26,6 +26,106 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsStream">
+        <source>Content already acquired as StreamReader via GetContentReader.</source>
+        <target state="new">Content already acquired as StreamReader via GetContentReader.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsString">
+        <source>Content already acquired as string via GetContent or initialized as string only.</source>
+        <target state="new">Content already acquired as string via GetContent or initialized as string only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_NotSetAfterAcquire">
+        <source>ArchiveFile was obtained, but the final edited version was not set.</source>
+        <target state="new">ArchiveFile was obtained, but the final edited version was not set.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_FwdCompatUnsupported">
+        <source>Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</source>
+        <target state="new">Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting version.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ImportFileSizeError">
+        <source>Imported files archive exceeded 2GB limit and it's not embedded.</source>
+        <target state="new">Imported files archive exceeded 2GB limit and it's not embedded.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_MissingRecoverableErrorSubscribeError">
+        <source>Subscription to RecoverableReadError is mandatory during forward compatible reading.</source>
+        <target state="new">Subscription to RecoverableReadError is mandatory during forward compatible reading.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderMismatchedRead">
+        <source>BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an exception type and {3} the exception message string.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderSkippingRecord">
+        <source>Skipping the record.</source>
+        <target state="new">Skipping the record.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnderRead">
+        <source>BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</source>
+        <target state="new">BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an integer value indicating number of bytes.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnknownType">
+        <source>BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is a string or integer value indicating type.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MissingSubscribeError">
+        <source>No subscribers for any events.</source>
+        <target state="new">No subscribers for any events.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MultiSubscribeError">
+        <source>Structured events and raw events cannot be replayed at the same time.</source>
+        <target state="new">Structured events and raw events cannot be replayed at the same time.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_VersionUninitialized">
+        <source>Version info not yet initialized. Replay must be called first.</source>
+        <target state="new">Version info not yet initialized. Replay must be called first.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_MustBeReadable">
+        <source>Stream must be readable.</source>
+        <target state="new">Stream must be readable.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SeekNonOrigin">
+        <source>Only seeking from SeekOrigin.Current is supported.</source>
+        <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SetLengthUnsupported">
+        <source>Changing the stream length is not supported.</source>
+        <target state="new">Changing the stream length is not supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
+        <source>Writing is not supported.</source>
+        <target state="new">Writing is not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Compilazione della domanda NON RIUSCITA. La compilazione  terminata in anticipo perch  stata rilevata una destinazione o un'attivit non aggiornata.</target>
@@ -149,6 +249,15 @@
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FatalErrorWhileLoggingWithInnerException">
+        <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</source>
+        <target state="new">MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</target>
+        <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
+    likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
+    special exception to abort the build.</note>
+      </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
         <target state="translated">MSB3094: "{2}" fa riferimento a {0} elemento/i, mentre "{3}" fa riferimento a {1} elemento/i. Devono avere lo stesso numero di elementi.</target>
@@ -222,8 +331,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Un assembly NuGet obbligatorio non  stato trovato. Percorso previsto: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">Non  stato possibile caricare un assembly NuGet obbligatorio '{0}'.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -390,6 +499,17 @@
         <target state="translated">Gli accessi ai file di report sono attualmente supportati solo con la versione x64 di MSBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverAttempt">
+        <source>The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</source>
+        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</target>
+        <note>
+      LOCALIZATION: Do not localize the word SDK. "{2}" is new line separated warnings or "null". "{3}" is new line separated errors or "null".
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: errore sistema di risoluzione SDK: "{0}"</target>
@@ -451,6 +571,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="SucceededToResolveSDK">
+        <source>The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</source>
+        <target state="new">The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
         <target state="translated">L'attivit "{0}" ha richiesto {1} core, ha acquisito {2} core e ora contiene {3} core in totale.</target>
@@ -2490,8 +2615,8 @@ Utilizzo:          {0} Utilizzo medio: {1:###.0}</target>
         <note>{StrBegin="MSB4238: "}</note>
       </trans-unit>
       <trans-unit id="UnsupportedLogFileFormat">
-        <source>MSB4235: The log file format version is {0}, whereas this version of MSBuild only supports versions up to {1}.</source>
-        <target state="translated">MSB4235: la versione del formato del file di log  la {0}, ma questa versione di MSBuild supporta solo le versioni fino alla {1}.</target>
+        <source>MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</source>
+        <target state="new">MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</target>
         <note>{StrBegin="MSB4235: "}</note>
       </trans-unit>
       <trans-unit id="ProjectEvaluationPerformanceSummary">
@@ -2581,13 +2706,6 @@ Utilizzo:          {0} Utilizzo medio: {1:###.0}</target>
         <target state="translated">MSB4241: la versione "{1}" del riferimento "{0}" all'SDK  stata risolta nella versione "{2}". Se non si aggiorna la versione di riferimento in modo che corrisponda,  possibile che la versione in uso sia diversa da quella prevista.</target>
         <note>{StrBegin="MSB4241: "}
       LOCALIZATION:  Do not localize the word SDK.
-    </note>
-      </trans-unit>
-      <trans-unit id="SdkResolving">
-        <source>Resolving SDK '{0}'...</source>
-        <target state="translated">Risoluzione dell'SDK '{0}'...</target>
-        <note>
-      LOCALIZATION:  Do not localize the word SDK.
     </note>
       </trans-unit>
       <trans-unit id="SdkResolverManifestInvalid">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 59c1576e9c3..22a9783f495 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -26,6 +26,106 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsStream">
+        <source>Content already acquired as StreamReader via GetContentReader.</source>
+        <target state="new">Content already acquired as StreamReader via GetContentReader.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsString">
+        <source>Content already acquired as string via GetContent or initialized as string only.</source>
+        <target state="new">Content already acquired as string via GetContent or initialized as string only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_NotSetAfterAcquire">
+        <source>ArchiveFile was obtained, but the final edited version was not set.</source>
+        <target state="new">ArchiveFile was obtained, but the final edited version was not set.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_FwdCompatUnsupported">
+        <source>Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</source>
+        <target state="new">Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting version.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ImportFileSizeError">
+        <source>Imported files archive exceeded 2GB limit and it's not embedded.</source>
+        <target state="new">Imported files archive exceeded 2GB limit and it's not embedded.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_MissingRecoverableErrorSubscribeError">
+        <source>Subscription to RecoverableReadError is mandatory during forward compatible reading.</source>
+        <target state="new">Subscription to RecoverableReadError is mandatory during forward compatible reading.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderMismatchedRead">
+        <source>BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an exception type and {3} the exception message string.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderSkippingRecord">
+        <source>Skipping the record.</source>
+        <target state="new">Skipping the record.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnderRead">
+        <source>BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</source>
+        <target state="new">BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an integer value indicating number of bytes.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnknownType">
+        <source>BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is a string or integer value indicating type.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MissingSubscribeError">
+        <source>No subscribers for any events.</source>
+        <target state="new">No subscribers for any events.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MultiSubscribeError">
+        <source>Structured events and raw events cannot be replayed at the same time.</source>
+        <target state="new">Structured events and raw events cannot be replayed at the same time.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_VersionUninitialized">
+        <source>Version info not yet initialized. Replay must be called first.</source>
+        <target state="new">Version info not yet initialized. Replay must be called first.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_MustBeReadable">
+        <source>Stream must be readable.</source>
+        <target state="new">Stream must be readable.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SeekNonOrigin">
+        <source>Only seeking from SeekOrigin.Current is supported.</source>
+        <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SetLengthUnsupported">
+        <source>Changing the stream length is not supported.</source>
+        <target state="new">Changing the stream length is not supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
+        <source>Writing is not supported.</source>
+        <target state="new">Writing is not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated"></target>
@@ -149,6 +249,15 @@
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FatalErrorWhileLoggingWithInnerException">
+        <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</source>
+        <target state="new">MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</target>
+        <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
+    likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
+    special exception to abort the build.</note>
+      </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
         <target state="translated">MSB3094: "{2}"  {0} "{3}"  {1} </target>
@@ -222,8 +331,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated"> NuGet : {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated"> NuGet  '{0}' </target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -390,6 +499,17 @@
         <target state="translated"> MSBuild  x64 </target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverAttempt">
+        <source>The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</source>
+        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</target>
+        <note>
+      LOCALIZATION: Do not localize the word SDK. "{2}" is new line separated warnings or "null". "{3}" is new line separated errors or "null".
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK  : "{0}"</target>
@@ -451,6 +571,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="SucceededToResolveSDK">
+        <source>The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</source>
+        <target state="new">The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
         <target state="translated"> "{0}" {1} {2}  {3} </target>
@@ -2490,8 +2615,8 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
         <note>{StrBegin="MSB4238: "}</note>
       </trans-unit>
       <trans-unit id="UnsupportedLogFileFormat">
-        <source>MSB4235: The log file format version is {0}, whereas this version of MSBuild only supports versions up to {1}.</source>
-        <target state="translated">MSB4235:   {0}  MSBuild  {1} </target>
+        <source>MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</source>
+        <target state="new">MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</target>
         <note>{StrBegin="MSB4235: "}</note>
       </trans-unit>
       <trans-unit id="ProjectEvaluationPerformanceSummary">
@@ -2581,13 +2706,6 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
         <target state="translated">MSB4241: SDK  "{0}"  "{1}"  "{2}"   </target>
         <note>{StrBegin="MSB4241: "}
       LOCALIZATION:  Do not localize the word SDK.
-    </note>
-      </trans-unit>
-      <trans-unit id="SdkResolving">
-        <source>Resolving SDK '{0}'...</source>
-        <target state="translated">SDK '{0}' ...</target>
-        <note>
-      LOCALIZATION:  Do not localize the word SDK.
     </note>
       </trans-unit>
       <trans-unit id="SdkResolverManifestInvalid">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index f971f5ac61e..e89dcc3d2ed 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -26,6 +26,106 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsStream">
+        <source>Content already acquired as StreamReader via GetContentReader.</source>
+        <target state="new">Content already acquired as StreamReader via GetContentReader.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsString">
+        <source>Content already acquired as string via GetContent or initialized as string only.</source>
+        <target state="new">Content already acquired as string via GetContent or initialized as string only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_NotSetAfterAcquire">
+        <source>ArchiveFile was obtained, but the final edited version was not set.</source>
+        <target state="new">ArchiveFile was obtained, but the final edited version was not set.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_FwdCompatUnsupported">
+        <source>Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</source>
+        <target state="new">Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting version.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ImportFileSizeError">
+        <source>Imported files archive exceeded 2GB limit and it's not embedded.</source>
+        <target state="new">Imported files archive exceeded 2GB limit and it's not embedded.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_MissingRecoverableErrorSubscribeError">
+        <source>Subscription to RecoverableReadError is mandatory during forward compatible reading.</source>
+        <target state="new">Subscription to RecoverableReadError is mandatory during forward compatible reading.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderMismatchedRead">
+        <source>BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an exception type and {3} the exception message string.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderSkippingRecord">
+        <source>Skipping the record.</source>
+        <target state="new">Skipping the record.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnderRead">
+        <source>BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</source>
+        <target state="new">BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an integer value indicating number of bytes.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnknownType">
+        <source>BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is a string or integer value indicating type.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MissingSubscribeError">
+        <source>No subscribers for any events.</source>
+        <target state="new">No subscribers for any events.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MultiSubscribeError">
+        <source>Structured events and raw events cannot be replayed at the same time.</source>
+        <target state="new">Structured events and raw events cannot be replayed at the same time.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_VersionUninitialized">
+        <source>Version info not yet initialized. Replay must be called first.</source>
+        <target state="new">Version info not yet initialized. Replay must be called first.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_MustBeReadable">
+        <source>Stream must be readable.</source>
+        <target state="new">Stream must be readable.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SeekNonOrigin">
+        <source>Only seeking from SeekOrigin.Current is supported.</source>
+        <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SetLengthUnsupported">
+        <source>Changing the stream length is not supported.</source>
+        <target state="new">Changing the stream length is not supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
+        <source>Writing is not supported.</source>
+        <target state="new">Writing is not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">  .         .</target>
@@ -149,6 +249,15 @@
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FatalErrorWhileLoggingWithInnerException">
+        <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</source>
+        <target state="new">MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</target>
+        <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
+    likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
+    special exception to abort the build.</note>
+      </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
         <target state="translated">MSB3094: "{2}"()  {0}  "{3}"()  {1} .     .</target>
@@ -222,8 +331,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated"> NuGet    .  : {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated"> NuGet  '{0}'()   .</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -390,6 +499,17 @@
         <target state="translated">    x64  MSBuild   .</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverAttempt">
+        <source>The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</source>
+        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</target>
+        <note>
+      LOCALIZATION: Do not localize the word SDK. "{2}" is new line separated warnings or "null". "{3}" is new line separated errors or "null".
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK   : "{0}"</target>
@@ -451,6 +571,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="SucceededToResolveSDK">
+        <source>The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</source>
+        <target state="new">The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
         <target state="translated">"{0}"   {1}   {2}    {3}   .</target>
@@ -2490,8 +2615,8 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
         <note>{StrBegin="MSB4238: "}</note>
       </trans-unit>
       <trans-unit id="UnsupportedLogFileFormat">
-        <source>MSB4235: The log file format version is {0}, whereas this version of MSBuild only supports versions up to {1}.</source>
-        <target state="translated">MSB4235:     {0}, MSBuild   {1}  .</target>
+        <source>MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</source>
+        <target state="new">MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</target>
         <note>{StrBegin="MSB4235: "}</note>
       </trans-unit>
       <trans-unit id="ProjectEvaluationPerformanceSummary">
@@ -2581,13 +2706,6 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
         <target state="translated">MSB4241: SDK  "{0}"  "{1}"()  "{2}"  .            .</target>
         <note>{StrBegin="MSB4241: "}
       LOCALIZATION:  Do not localize the word SDK.
-    </note>
-      </trans-unit>
-      <trans-unit id="SdkResolving">
-        <source>Resolving SDK '{0}'...</source>
-        <target state="translated">SDK '{0}'()  ...</target>
-        <note>
-      LOCALIZATION:  Do not localize the word SDK.
     </note>
       </trans-unit>
       <trans-unit id="SdkResolverManifestInvalid">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 6b5cb6a8fcb..2a93178133d 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -26,6 +26,106 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsStream">
+        <source>Content already acquired as StreamReader via GetContentReader.</source>
+        <target state="new">Content already acquired as StreamReader via GetContentReader.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsString">
+        <source>Content already acquired as string via GetContent or initialized as string only.</source>
+        <target state="new">Content already acquired as string via GetContent or initialized as string only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_NotSetAfterAcquire">
+        <source>ArchiveFile was obtained, but the final edited version was not set.</source>
+        <target state="new">ArchiveFile was obtained, but the final edited version was not set.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_FwdCompatUnsupported">
+        <source>Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</source>
+        <target state="new">Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting version.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ImportFileSizeError">
+        <source>Imported files archive exceeded 2GB limit and it's not embedded.</source>
+        <target state="new">Imported files archive exceeded 2GB limit and it's not embedded.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_MissingRecoverableErrorSubscribeError">
+        <source>Subscription to RecoverableReadError is mandatory during forward compatible reading.</source>
+        <target state="new">Subscription to RecoverableReadError is mandatory during forward compatible reading.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderMismatchedRead">
+        <source>BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an exception type and {3} the exception message string.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderSkippingRecord">
+        <source>Skipping the record.</source>
+        <target state="new">Skipping the record.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnderRead">
+        <source>BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</source>
+        <target state="new">BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an integer value indicating number of bytes.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnknownType">
+        <source>BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is a string or integer value indicating type.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MissingSubscribeError">
+        <source>No subscribers for any events.</source>
+        <target state="new">No subscribers for any events.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MultiSubscribeError">
+        <source>Structured events and raw events cannot be replayed at the same time.</source>
+        <target state="new">Structured events and raw events cannot be replayed at the same time.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_VersionUninitialized">
+        <source>Version info not yet initialized. Replay must be called first.</source>
+        <target state="new">Version info not yet initialized. Replay must be called first.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_MustBeReadable">
+        <source>Stream must be readable.</source>
+        <target state="new">Stream must be readable.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SeekNonOrigin">
+        <source>Only seeking from SeekOrigin.Current is supported.</source>
+        <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SetLengthUnsupported">
+        <source>Changing the stream length is not supported.</source>
+        <target state="new">Changing the stream length is not supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
+        <source>Writing is not supported.</source>
+        <target state="new">Writing is not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">NIEPOWODZENIE kompilacji pytania. Kompilacja zostaa zakoczona wczeniej, poniewa napotkaa element docelowy lub zadanie, ktre nie byo aktualne.</target>
@@ -149,6 +249,15 @@
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FatalErrorWhileLoggingWithInnerException">
+        <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</source>
+        <target state="new">MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</target>
+        <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
+    likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
+    special exception to abort the build.</note>
+      </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
         <target state="translated">MSB3094: {2} odwouje si do nastpujcej liczby elementw: {0}, a {3} odwouje si do nastpujcej liczby elementw: {1}. Liczba tych elementw musi by taka sama.</target>
@@ -222,8 +331,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Nie znaleziono wymaganego zestawu NuGet. Oczekiwano cieki {0}.</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">Nie mona zaadowa wymaganego zestawu NuGet {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -390,6 +499,17 @@
         <target state="translated">Raportowanie dostpu do plikw jest obecnie obsugiwane tylko przy uyciu wersji x64 programu MSBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverAttempt">
+        <source>The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</source>
+        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</target>
+        <note>
+      LOCALIZATION: Do not localize the word SDK. "{2}" is new line separated warnings or "null". "{3}" is new line separated errors or "null".
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: niepowodzenia programu do rozpoznawania zestawu SDK: {0}</target>
@@ -451,6 +571,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="SucceededToResolveSDK">
+        <source>The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</source>
+        <target state="new">The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
         <target state="translated">Zadanie {0} dao {1} rdzeni, uzyskao {2} i teraz jego czna liczba rdzeni to {3}.</target>
@@ -2490,8 +2615,8 @@ Wykorzystanie:          rednie wykorzystanie {0}: {1:###.0}</target>
         <note>{StrBegin="MSB4238: "}</note>
       </trans-unit>
       <trans-unit id="UnsupportedLogFileFormat">
-        <source>MSB4235: The log file format version is {0}, whereas this version of MSBuild only supports versions up to {1}.</source>
-        <target state="translated">MSB4235: Wersja formatu pliku dziennika to {0}, podczas gdy ta wersja programu MSBuild obsuguje wycznie wersje do {1}.</target>
+        <source>MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</source>
+        <target state="new">MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</target>
         <note>{StrBegin="MSB4235: "}</note>
       </trans-unit>
       <trans-unit id="ProjectEvaluationPerformanceSummary">
@@ -2581,13 +2706,6 @@ Wykorzystanie:          rednie wykorzystanie {0}: {1:###.0}</target>
         <target state="translated">MSB4241: Odwoanie do zestawu SDK {0} w wersji {1} zostao rozpoznane jako wersja {2}. Moe zosta uyta inna wersja ni oczekiwana, jeli nie zaktualizujesz wersji okrelonej w odwoaniu, tak aby bya zgodna.</target>
         <note>{StrBegin="MSB4241: "}
       LOCALIZATION:  Do not localize the word SDK.
-    </note>
-      </trans-unit>
-      <trans-unit id="SdkResolving">
-        <source>Resolving SDK '{0}'...</source>
-        <target state="translated">Trwa rozpoznawanie zestawu SDK {0}...</target>
-        <note>
-      LOCALIZATION:  Do not localize the word SDK.
     </note>
       </trans-unit>
       <trans-unit id="SdkResolverManifestInvalid">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 091ee565cc9..66ce62f4f2f 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -26,6 +26,106 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsStream">
+        <source>Content already acquired as StreamReader via GetContentReader.</source>
+        <target state="new">Content already acquired as StreamReader via GetContentReader.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsString">
+        <source>Content already acquired as string via GetContent or initialized as string only.</source>
+        <target state="new">Content already acquired as string via GetContent or initialized as string only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_NotSetAfterAcquire">
+        <source>ArchiveFile was obtained, but the final edited version was not set.</source>
+        <target state="new">ArchiveFile was obtained, but the final edited version was not set.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_FwdCompatUnsupported">
+        <source>Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</source>
+        <target state="new">Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting version.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ImportFileSizeError">
+        <source>Imported files archive exceeded 2GB limit and it's not embedded.</source>
+        <target state="new">Imported files archive exceeded 2GB limit and it's not embedded.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_MissingRecoverableErrorSubscribeError">
+        <source>Subscription to RecoverableReadError is mandatory during forward compatible reading.</source>
+        <target state="new">Subscription to RecoverableReadError is mandatory during forward compatible reading.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderMismatchedRead">
+        <source>BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an exception type and {3} the exception message string.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderSkippingRecord">
+        <source>Skipping the record.</source>
+        <target state="new">Skipping the record.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnderRead">
+        <source>BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</source>
+        <target state="new">BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an integer value indicating number of bytes.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnknownType">
+        <source>BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is a string or integer value indicating type.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MissingSubscribeError">
+        <source>No subscribers for any events.</source>
+        <target state="new">No subscribers for any events.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MultiSubscribeError">
+        <source>Structured events and raw events cannot be replayed at the same time.</source>
+        <target state="new">Structured events and raw events cannot be replayed at the same time.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_VersionUninitialized">
+        <source>Version info not yet initialized. Replay must be called first.</source>
+        <target state="new">Version info not yet initialized. Replay must be called first.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_MustBeReadable">
+        <source>Stream must be readable.</source>
+        <target state="new">Stream must be readable.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SeekNonOrigin">
+        <source>Only seeking from SeekOrigin.Current is supported.</source>
+        <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SetLengthUnsupported">
+        <source>Changing the stream length is not supported.</source>
+        <target state="new">Changing the stream length is not supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
+        <source>Writing is not supported.</source>
+        <target state="new">Writing is not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">FALHA na compilao da pergunta. A compilao foi encerrada antecipadamente ao se deparar com um alvo ou tarefa que no estava atualizado.</target>
@@ -149,6 +249,15 @@
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FatalErrorWhileLoggingWithInnerException">
+        <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</source>
+        <target state="new">MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</target>
+        <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
+    likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
+    special exception to abort the build.</note>
+      </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
         <target state="translated">MSB3094: "{2}" refere-se ao(s) item(ns) {0} e "{3}" refere-se ao(s) item(ns) {1}. Eles devem ter o mesmo nmero de itens.</target>
@@ -222,8 +331,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Um assembly NuGet necessrio no foi encontrado. Caminho Esperado: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">No foi possvel carregar um assembly NuGet "{0}" obrigatrio.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -390,6 +499,17 @@
         <target state="translated">Atualmente, o relatrio de acessos a arquivos s tem suporte usando o tipo x64 do MSBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverAttempt">
+        <source>The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</source>
+        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</target>
+        <note>
+      LOCALIZATION: Do not localize the word SDK. "{2}" is new line separated warnings or "null". "{3}" is new line separated errors or "null".
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Falha no Resolvedor do SDK: "{0}"</target>
@@ -451,6 +571,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="SucceededToResolveSDK">
+        <source>The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</source>
+        <target state="new">The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
         <target state="translated">A tarefa "{0}" solicitou {1} ncleos, adquiriu {2} ncleos e agora contm {3} ncleos no total.</target>
@@ -2490,8 +2615,8 @@ Utilizao:          {0} Utilizao Mdia: {1:###.0}</target>
         <note>{StrBegin="MSB4238: "}</note>
       </trans-unit>
       <trans-unit id="UnsupportedLogFileFormat">
-        <source>MSB4235: The log file format version is {0}, whereas this version of MSBuild only supports versions up to {1}.</source>
-        <target state="translated">MSB4235: a verso de formato do arquivo de log  {0}, enquanto esta verso do MSBuild d suporte apenas para verses at {1}.</target>
+        <source>MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</source>
+        <target state="new">MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</target>
         <note>{StrBegin="MSB4235: "}</note>
       </trans-unit>
       <trans-unit id="ProjectEvaluationPerformanceSummary">
@@ -2581,13 +2706,6 @@ Utilizao:          {0} Utilizao Mdia: {1:###.0}</target>
         <target state="translated">MSB4241: a referncia do SDK "{0}" verso "{1}" foi resolvida para a verso "{2}". Talvez voc estava usando um verso diferente que a esperada caso no tenha atualizado a verso referenciada de maneira correspondente.</target>
         <note>{StrBegin="MSB4241: "}
       LOCALIZATION:  Do not localize the word SDK.
-    </note>
-      </trans-unit>
-      <trans-unit id="SdkResolving">
-        <source>Resolving SDK '{0}'...</source>
-        <target state="translated">Resolvendo o SDK '{0}'...</target>
-        <note>
-      LOCALIZATION:  Do not localize the word SDK.
     </note>
       </trans-unit>
       <trans-unit id="SdkResolverManifestInvalid">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 9e28c12ef8e..848b07b5292 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -26,6 +26,106 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsStream">
+        <source>Content already acquired as StreamReader via GetContentReader.</source>
+        <target state="new">Content already acquired as StreamReader via GetContentReader.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsString">
+        <source>Content already acquired as string via GetContent or initialized as string only.</source>
+        <target state="new">Content already acquired as string via GetContent or initialized as string only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_NotSetAfterAcquire">
+        <source>ArchiveFile was obtained, but the final edited version was not set.</source>
+        <target state="new">ArchiveFile was obtained, but the final edited version was not set.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_FwdCompatUnsupported">
+        <source>Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</source>
+        <target state="new">Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting version.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ImportFileSizeError">
+        <source>Imported files archive exceeded 2GB limit and it's not embedded.</source>
+        <target state="new">Imported files archive exceeded 2GB limit and it's not embedded.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_MissingRecoverableErrorSubscribeError">
+        <source>Subscription to RecoverableReadError is mandatory during forward compatible reading.</source>
+        <target state="new">Subscription to RecoverableReadError is mandatory during forward compatible reading.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderMismatchedRead">
+        <source>BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an exception type and {3} the exception message string.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderSkippingRecord">
+        <source>Skipping the record.</source>
+        <target state="new">Skipping the record.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnderRead">
+        <source>BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</source>
+        <target state="new">BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an integer value indicating number of bytes.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnknownType">
+        <source>BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is a string or integer value indicating type.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MissingSubscribeError">
+        <source>No subscribers for any events.</source>
+        <target state="new">No subscribers for any events.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MultiSubscribeError">
+        <source>Structured events and raw events cannot be replayed at the same time.</source>
+        <target state="new">Structured events and raw events cannot be replayed at the same time.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_VersionUninitialized">
+        <source>Version info not yet initialized. Replay must be called first.</source>
+        <target state="new">Version info not yet initialized. Replay must be called first.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_MustBeReadable">
+        <source>Stream must be readable.</source>
+        <target state="new">Stream must be readable.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SeekNonOrigin">
+        <source>Only seeking from SeekOrigin.Current is supported.</source>
+        <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SetLengthUnsupported">
+        <source>Changing the stream length is not supported.</source>
+        <target state="new">Changing the stream length is not supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
+        <source>Writing is not supported.</source>
+        <target state="new">Writing is not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">  .     ,         .</target>
@@ -149,6 +249,15 @@
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FatalErrorWhileLoggingWithInnerException">
+        <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</source>
+        <target state="new">MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</target>
+        <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
+    likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
+    special exception to abort the build.</note>
+      </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
         <target state="translated">MSB3094: "{2}"     : {0},  "{3}"   {1}.     .</target>
@@ -222,8 +331,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">    NuGet.  : {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">     NuGet "{0}".</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -390,6 +499,17 @@
         <target state="translated">         64-   MSBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverAttempt">
+        <source>The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</source>
+        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</target>
+        <note>
+      LOCALIZATION: Do not localize the word SDK. "{2}" is new line separated warnings or "null". "{3}" is new line separated errors or "null".
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242:   SDK: "{0}"</target>
@@ -451,6 +571,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="SucceededToResolveSDK">
+        <source>The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</source>
+        <target state="new">The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
         <target state="translated"> "{0}"     ({1})      ({2}).    ,   ,  {3}.</target>
@@ -2490,8 +2615,8 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
         <note>{StrBegin="MSB4238: "}</note>
       </trans-unit>
       <trans-unit id="UnsupportedLogFileFormat">
-        <source>MSB4235: The log file format version is {0}, whereas this version of MSBuild only supports versions up to {1}.</source>
-        <target state="translated">MSB4235:    : {0},     MSBuild     {1}.</target>
+        <source>MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</source>
+        <target state="new">MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</target>
         <note>{StrBegin="MSB4235: "}</note>
       </trans-unit>
       <trans-unit id="ProjectEvaluationPerformanceSummary">
@@ -2581,13 +2706,6 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
         <target state="translated">MSB4241:    SDK "{0}"  "{1}"    "{2}". ,   ,   ,       .</target>
         <note>{StrBegin="MSB4241: "}
       LOCALIZATION:  Do not localize the word SDK.
-    </note>
-      </trans-unit>
-      <trans-unit id="SdkResolving">
-        <source>Resolving SDK '{0}'...</source>
-        <target state="translated"> SDK "{0}"</target>
-        <note>
-      LOCALIZATION:  Do not localize the word SDK.
     </note>
       </trans-unit>
       <trans-unit id="SdkResolverManifestInvalid">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index ebd5bc1b6ba..304761defa1 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -26,6 +26,106 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsStream">
+        <source>Content already acquired as StreamReader via GetContentReader.</source>
+        <target state="new">Content already acquired as StreamReader via GetContentReader.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsString">
+        <source>Content already acquired as string via GetContent or initialized as string only.</source>
+        <target state="new">Content already acquired as string via GetContent or initialized as string only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_NotSetAfterAcquire">
+        <source>ArchiveFile was obtained, but the final edited version was not set.</source>
+        <target state="new">ArchiveFile was obtained, but the final edited version was not set.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_FwdCompatUnsupported">
+        <source>Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</source>
+        <target state="new">Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting version.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ImportFileSizeError">
+        <source>Imported files archive exceeded 2GB limit and it's not embedded.</source>
+        <target state="new">Imported files archive exceeded 2GB limit and it's not embedded.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_MissingRecoverableErrorSubscribeError">
+        <source>Subscription to RecoverableReadError is mandatory during forward compatible reading.</source>
+        <target state="new">Subscription to RecoverableReadError is mandatory during forward compatible reading.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderMismatchedRead">
+        <source>BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an exception type and {3} the exception message string.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderSkippingRecord">
+        <source>Skipping the record.</source>
+        <target state="new">Skipping the record.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnderRead">
+        <source>BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</source>
+        <target state="new">BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an integer value indicating number of bytes.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnknownType">
+        <source>BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is a string or integer value indicating type.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MissingSubscribeError">
+        <source>No subscribers for any events.</source>
+        <target state="new">No subscribers for any events.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MultiSubscribeError">
+        <source>Structured events and raw events cannot be replayed at the same time.</source>
+        <target state="new">Structured events and raw events cannot be replayed at the same time.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_VersionUninitialized">
+        <source>Version info not yet initialized. Replay must be called first.</source>
+        <target state="new">Version info not yet initialized. Replay must be called first.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_MustBeReadable">
+        <source>Stream must be readable.</source>
+        <target state="new">Stream must be readable.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SeekNonOrigin">
+        <source>Only seeking from SeekOrigin.Current is supported.</source>
+        <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SetLengthUnsupported">
+        <source>Changing the stream length is not supported.</source>
+        <target state="new">Changing the stream length is not supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
+        <source>Writing is not supported.</source>
+        <target state="new">Writing is not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Soru derleme BAARISIZ oldu. Gncel olmayan bir hedef veya grev ile karlatndan derleme ileminden erken kld.</target>
@@ -149,6 +249,15 @@
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FatalErrorWhileLoggingWithInnerException">
+        <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</source>
+        <target state="new">MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</target>
+        <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
+    likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
+    special exception to abort the build.</note>
+      </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
         <target state="translated">MSB3094: "{2}", {0} eye; "{3}", {1} eye bavuruyor. Ayn sayda eye sahip olmalar gerekir.</target>
@@ -222,8 +331,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated">Gereken NuGet derlemesi bulunamad. Beklenen Yol: {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated">Gerekli bir NuGet '{0}' derlemesi yklenemedi.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -390,6 +499,17 @@
         <target state="translated">Raporlama dosyas eriimleri u anda yalnzca MSBuild x64 varyant kullanldnda destekleniyor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverAttempt">
+        <source>The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</source>
+        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</target>
+        <note>
+      LOCALIZATION: Do not localize the word SDK. "{2}" is new line separated warnings or "null". "{3}" is new line separated errors or "null".
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK zmleyici Hatas: "{0}"</target>
@@ -451,6 +571,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="SucceededToResolveSDK">
+        <source>The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</source>
+        <target state="new">The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
         <target state="translated">"{0}" grevi {1} ekirdek istedi, {2} ekirdek ald ve u anda toplam {3} ekirdek tutuyor.</target>
@@ -2490,8 +2615,8 @@ Kullanm:             {0} Ortalama Kullanm: {1:###.0}</target>
         <note>{StrBegin="MSB4238: "}</note>
       </trans-unit>
       <trans-unit id="UnsupportedLogFileFormat">
-        <source>MSB4235: The log file format version is {0}, whereas this version of MSBuild only supports versions up to {1}.</source>
-        <target state="translated">MSB4235: Gnlk dosyasnn biim srm {0} ancak bu MSBuild srmnn destekledii en yksek srm {1}.</target>
+        <source>MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</source>
+        <target state="new">MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</target>
         <note>{StrBegin="MSB4235: "}</note>
       </trans-unit>
       <trans-unit id="ProjectEvaluationPerformanceSummary">
@@ -2581,13 +2706,6 @@ Kullanm:             {0} Ortalama Kullanm: {1:###.0}</target>
         <target state="translated">MSB4241: "{0}" SDK bavurusunun "{1}" srm, bunun yerine srm "{2}" olarak zmlendi. Bavurulan srm eleecek ekilde gncelletirmezseniz beklenen srmden farkl bir srm kullanyor olabilirsiniz.</target>
         <note>{StrBegin="MSB4241: "}
       LOCALIZATION:  Do not localize the word SDK.
-    </note>
-      </trans-unit>
-      <trans-unit id="SdkResolving">
-        <source>Resolving SDK '{0}'...</source>
-        <target state="translated">'{0}' SDKs zmleniyor...</target>
-        <note>
-      LOCALIZATION:  Do not localize the word SDK.
     </note>
       </trans-unit>
       <trans-unit id="SdkResolverManifestInvalid">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index f5f0b5ec933..7bb32f30ae6 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -26,6 +26,106 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsStream">
+        <source>Content already acquired as StreamReader via GetContentReader.</source>
+        <target state="new">Content already acquired as StreamReader via GetContentReader.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsString">
+        <source>Content already acquired as string via GetContent or initialized as string only.</source>
+        <target state="new">Content already acquired as string via GetContent or initialized as string only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_NotSetAfterAcquire">
+        <source>ArchiveFile was obtained, but the final edited version was not set.</source>
+        <target state="new">ArchiveFile was obtained, but the final edited version was not set.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_FwdCompatUnsupported">
+        <source>Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</source>
+        <target state="new">Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting version.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ImportFileSizeError">
+        <source>Imported files archive exceeded 2GB limit and it's not embedded.</source>
+        <target state="new">Imported files archive exceeded 2GB limit and it's not embedded.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_MissingRecoverableErrorSubscribeError">
+        <source>Subscription to RecoverableReadError is mandatory during forward compatible reading.</source>
+        <target state="new">Subscription to RecoverableReadError is mandatory during forward compatible reading.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderMismatchedRead">
+        <source>BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an exception type and {3} the exception message string.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderSkippingRecord">
+        <source>Skipping the record.</source>
+        <target state="new">Skipping the record.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnderRead">
+        <source>BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</source>
+        <target state="new">BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an integer value indicating number of bytes.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnknownType">
+        <source>BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is a string or integer value indicating type.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MissingSubscribeError">
+        <source>No subscribers for any events.</source>
+        <target state="new">No subscribers for any events.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MultiSubscribeError">
+        <source>Structured events and raw events cannot be replayed at the same time.</source>
+        <target state="new">Structured events and raw events cannot be replayed at the same time.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_VersionUninitialized">
+        <source>Version info not yet initialized. Replay must be called first.</source>
+        <target state="new">Version info not yet initialized. Replay must be called first.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_MustBeReadable">
+        <source>Stream must be readable.</source>
+        <target state="new">Stream must be readable.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SeekNonOrigin">
+        <source>Only seeking from SeekOrigin.Current is supported.</source>
+        <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SetLengthUnsupported">
+        <source>Changing the stream length is not supported.</source>
+        <target state="new">Changing the stream length is not supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
+        <source>Writing is not supported.</source>
+        <target state="new">Writing is not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated"></target>
@@ -149,6 +249,15 @@
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FatalErrorWhileLoggingWithInnerException">
+        <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</source>
+        <target state="new">MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</target>
+        <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
+    likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
+    special exception to abort the build.</note>
+      </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
         <target state="translated">MSB3094: {2} {0} {3} {1} </target>
@@ -222,8 +331,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated"> NuGet : {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated"> NuGet {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -390,6 +499,17 @@
         <target state="translated"> x64  MSBuild </target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverAttempt">
+        <source>The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</source>
+        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</target>
+        <note>
+      LOCALIZATION: Do not localize the word SDK. "{2}" is new line separated warnings or "null". "{3}" is new line separated errors or "null".
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK : "{0}"</target>
@@ -451,6 +571,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="SucceededToResolveSDK">
+        <source>The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</source>
+        <target state="new">The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
         <target state="translated">{0} {1}  {2}  {3} </target>
@@ -2490,8 +2615,8 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
         <note>{StrBegin="MSB4238: "}</note>
       </trans-unit>
       <trans-unit id="UnsupportedLogFileFormat">
-        <source>MSB4235: The log file format version is {0}, whereas this version of MSBuild only supports versions up to {1}.</source>
-        <target state="translated">MSB4235:  {0} MSBuild  {1} </target>
+        <source>MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</source>
+        <target state="new">MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</target>
         <note>{StrBegin="MSB4235: "}</note>
       </trans-unit>
       <trans-unit id="ProjectEvaluationPerformanceSummary">
@@ -2581,13 +2706,6 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
         <target state="translated">MSB4241: SDK {0}{1}{2}</target>
         <note>{StrBegin="MSB4241: "}
       LOCALIZATION:  Do not localize the word SDK.
-    </note>
-      </trans-unit>
-      <trans-unit id="SdkResolving">
-        <source>Resolving SDK '{0}'...</source>
-        <target state="translated"> SDK{0}...</target>
-        <note>
-      LOCALIZATION:  Do not localize the word SDK.
     </note>
       </trans-unit>
       <trans-unit id="SdkResolverManifestInvalid">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 69a33fe9a21..b18cc573b92 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -26,6 +26,106 @@
         <note>{StrBegin="MSB4003: "}UE: Tasks are not allowed to use incorrect case for reserved attributes on the task nodes e.g. "continueonerror"
     instead of the "ContinueOnError".</note>
       </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsStream">
+        <source>Content already acquired as StreamReader via GetContentReader.</source>
+        <target state="new">Content already acquired as StreamReader via GetContentReader.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_AcquiredAsString">
+        <source>Content already acquired as string via GetContent or initialized as string only.</source>
+        <target state="new">Content already acquired as string via GetContent or initialized as string only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ArchiveFile_NotSetAfterAcquire">
+        <source>ArchiveFile was obtained, but the final edited version was not set.</source>
+        <target state="new">ArchiveFile was obtained, but the final edited version was not set.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_FwdCompatUnsupported">
+        <source>Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</source>
+        <target state="new">Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting version.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ImportFileSizeError">
+        <source>Imported files archive exceeded 2GB limit and it's not embedded.</source>
+        <target state="new">Imported files archive exceeded 2GB limit and it's not embedded.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_MissingRecoverableErrorSubscribeError">
+        <source>Subscription to RecoverableReadError is mandatory during forward compatible reading.</source>
+        <target state="new">Subscription to RecoverableReadError is mandatory during forward compatible reading.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderMismatchedRead">
+        <source>BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) attempted to perform disallowed reads (details: {2}: {3}).</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an exception type and {3} the exception message string.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderSkippingRecord">
+        <source>Skipping the record.</source>
+        <target state="new">Skipping the record.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnderRead">
+        <source>BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</source>
+        <target state="new">BuildEvent record number {0} was expected to read exactly {1} bytes from the stream, but read {2} instead.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is an integer value indicating number of bytes.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_ReaderUnknownType">
+        <source>BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</source>
+        <target state="new">BuildEvent record number {0} (serialized size: {1}) is of unsupported type: {2}.</target>
+        <note>
+      LOCALIZATION: {0} is an integer number denoting order. {1} is an integer denoting size. {2} is a string or integer value indicating type.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MissingSubscribeError">
+        <source>No subscribers for any events.</source>
+        <target state="new">No subscribers for any events.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_MultiSubscribeError">
+        <source>Structured events and raw events cannot be replayed at the same time.</source>
+        <target state="new">Structured events and raw events cannot be replayed at the same time.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_Source_VersionUninitialized">
+        <source>Version info not yet initialized. Replay must be called first.</source>
+        <target state="new">Version info not yet initialized. Replay must be called first.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_MustBeReadable">
+        <source>Stream must be readable.</source>
+        <target state="new">Stream must be readable.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SeekNonOrigin">
+        <source>Only seeking from SeekOrigin.Current is supported.</source>
+        <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_SetLengthUnsupported">
+        <source>Changing the stream length is not supported.</source>
+        <target state="new">Changing the stream length is not supported.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
+        <source>Writing is not supported.</source>
+        <target state="new">Writing is not supported.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated"></target>
@@ -149,6 +249,15 @@
   {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FatalErrorWhileLoggingWithInnerException">
+        <source>MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</source>
+        <target state="new">MSB4017: The build stopped unexpectedly because of an unexpected logger failure.
+    {0}</target>
+        <note>{StrBegin="MSB4017: "}UE: This message is used for a special exception that is thrown when a logger fails while logging an event (most
+    likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
+    special exception to abort the build.</note>
+      </trans-unit>
       <trans-unit id="General.TwoVectorsMustHaveSameLength">
         <source>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</source>
         <target state="translated">MSB3094: "{2}"  {0} "{3}"  {1} </target>
@@ -222,8 +331,8 @@
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
-        <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="translated"> NuGet : {0}</target>
+        <source>A required NuGet assembly '{0}' could not be loaded.</source>
+        <target state="translated"> NuGet  '{0}'</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -390,6 +499,17 @@
         <target state="translated"> MSBuild  x64 </target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverAttempt">
+        <source>The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</source>
+        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}".
+Warnings: {2}
+Errors: {3}</target>
+        <note>
+      LOCALIZATION: Do not localize the word SDK. "{2}" is new line separated warnings or "null". "{3}" is new line separated errors or "null".
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK : "{0}"</target>
@@ -451,6 +571,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="SucceededToResolveSDK">
+        <source>The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</source>
+        <target state="new">The SDK "{0}" was successfully resolved by the "{1}" resolver to location "{2}" and version "{3}".</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskAcquiredCores">
         <source>Task "{0}" requested {1} cores, acquired {2} cores, and now holds {3} cores total.</source>
         <target state="translated"> "{0}"  {1}  {2}  {3} </target>
@@ -2490,8 +2615,8 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
         <note>{StrBegin="MSB4238: "}</note>
       </trans-unit>
       <trans-unit id="UnsupportedLogFileFormat">
-        <source>MSB4235: The log file format version is {0}, whereas this version of MSBuild only supports versions up to {1}.</source>
-        <target state="translated">MSB4235:  {0} MSBuild  {1} () </target>
+        <source>MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</source>
+        <target state="new">MSB4235: The log file format version is {0} with minimum required reader version {1}, whereas this version of MSBuild only supports versions up to {2}.</target>
         <note>{StrBegin="MSB4235: "}</note>
       </trans-unit>
       <trans-unit id="ProjectEvaluationPerformanceSummary">
@@ -2581,13 +2706,6 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
         <target state="translated">MSB4241: SDK  "{0}"  "{1}"  "{2}"</target>
         <note>{StrBegin="MSB4241: "}
       LOCALIZATION:  Do not localize the word SDK.
-    </note>
-      </trans-unit>
-      <trans-unit id="SdkResolving">
-        <source>Resolving SDK '{0}'...</source>
-        <target state="translated"> SDK '{0}'...</target>
-        <note>
-      LOCALIZATION:  Do not localize the word SDK.
     </note>
       </trans-unit>
       <trans-unit id="SdkResolverManifestInvalid">
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 367ef9ddf2b..0f5736349a8 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using System.IO;
 using System.Linq;
 using System.Reflection;
@@ -16,47 +17,63 @@
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
-    /// Wraps the NuGet.Frameworks assembly, which is referenced by reflection.
+    /// Wraps the NuGet.Frameworks assembly, which is referenced by reflection and optionally loaded into a separate AppDomain for performance.
     /// </summary>
-    internal class NuGetFrameworkWrapper
+    internal sealed partial class NuGetFrameworkWrapper
+#if FEATURE_APPDOMAIN
+        : MarshalByRefObject
+#endif
     {
+        private const string NuGetFrameworksAssemblyName = "NuGet.Frameworks";
+        private const string NuGetFrameworksFileName = NuGetFrameworksAssemblyName + ".dll";
+
         /// <summary>
-        /// NuGet Types
+        /// Methods, properties, and objects used from the NuGet.Frameworks assembly.
         /// </summary>
-        private static MethodInfo ParseMethod;
-        private static MethodInfo IsCompatibleMethod;
-        private static object DefaultCompatibilityProvider;
-        private static PropertyInfo FrameworkProperty;
-        private static PropertyInfo VersionProperty;
-        private static PropertyInfo PlatformProperty;
-        private static PropertyInfo PlatformVersionProperty;
-        private static PropertyInfo AllFrameworkVersionsProperty;
+        private MethodInfo ParseMethod;
+        private MethodInfo IsCompatibleMethod;
+        private object DefaultCompatibilityProvider;
+        private PropertyInfo FrameworkProperty;
+        private PropertyInfo VersionProperty;
+        private PropertyInfo PlatformProperty;
+        private PropertyInfo PlatformVersionProperty;
+        private PropertyInfo AllFrameworkVersionsProperty;
 
+        /// <summary>
+        /// Public constructor for cross-domain activation only. Use <see cref="CreateInstance"/> to instantiate.
+        /// </summary>
         public NuGetFrameworkWrapper()
+        { }
+
+        /// <summary>
+        /// Initialized this instance. May run in a separate AppDomain.
+        /// </summary>
+        /// <param name="assemblyName">The NuGet.Frameworks to be loaded or null to load by path.</param>
+        /// <param name="assemblyFilePath">The file path from which NuGet.Frameworks should be loaded of <paramref name="assemblyName"/> is null.</param>
+        public void Initialize(AssemblyName assemblyName, string assemblyFilePath)
         {
-            // Resolve the location of the NuGet.Frameworks assembly
-            var assemblyDirectory = BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio ?
-                Path.Combine(BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory, "Common7", "IDE", "CommonExtensions", "Microsoft", "NuGet") :
-                BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
-            try
+            Assembly NuGetAssembly;
+            if (assemblyName != null)
             {
-                var NuGetAssembly = Assembly.LoadFile(Path.Combine(assemblyDirectory, "NuGet.Frameworks.dll"));
-                var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
-                var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
-                var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
-                ParseMethod = NuGetFramework.GetMethod("Parse", new Type[] { typeof(string) });
-                IsCompatibleMethod = NuGetFrameworkCompatibilityProvider.GetMethod("IsCompatible");
-                DefaultCompatibilityProvider = NuGetFrameworkDefaultCompatibilityProvider.GetMethod("get_Instance").Invoke(null, Array.Empty<object>());
-                FrameworkProperty = NuGetFramework.GetProperty("Framework");
-                VersionProperty = NuGetFramework.GetProperty("Version");
-                PlatformProperty = NuGetFramework.GetProperty("Platform");
-                PlatformVersionProperty = NuGetFramework.GetProperty("PlatformVersion");
-                AllFrameworkVersionsProperty = NuGetFramework.GetProperty("AllFrameworkVersions");
+                // This will load the assembly into the default load context if possible, and fall back to LoadFrom context.
+                NuGetAssembly = Assembly.Load(assemblyName);
             }
-            catch
+            else
             {
-                throw new InternalErrorException(string.Format(AssemblyResources.GetString("NuGetAssemblyNotFound"), assemblyDirectory));
+                NuGetAssembly = Assembly.LoadFile(assemblyFilePath);
             }
+
+            var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
+            var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
+            var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
+            ParseMethod = NuGetFramework.GetMethod("Parse", new Type[] { typeof(string) });
+            IsCompatibleMethod = NuGetFrameworkCompatibilityProvider.GetMethod("IsCompatible");
+            DefaultCompatibilityProvider = NuGetFrameworkDefaultCompatibilityProvider.GetMethod("get_Instance").Invoke(null, Array.Empty<object>());
+            FrameworkProperty = NuGetFramework.GetProperty("Framework");
+            VersionProperty = NuGetFramework.GetProperty("Version");
+            PlatformProperty = NuGetFramework.GetProperty("Platform");
+            PlatformVersionProperty = NuGetFramework.GetProperty("PlatformVersion");
+            AllFrameworkVersionsProperty = NuGetFramework.GetProperty("AllFrameworkVersions");
         }
 
         private object Parse(string tfm)
@@ -133,5 +150,99 @@ public string FilterTargetFrameworks(string incoming, string filter)
                 });
             }
         }
+
+#if FEATURE_APPDOMAIN
+        /// <summary>
+        /// A null-returning InitializeLifetimeService to give the proxy an infinite lease time.
+        /// </summary>
+        public override object InitializeLifetimeService() => null;
+
+        private static AppDomainSetup CreateAppDomainSetup(AssemblyName assemblyName, string assemblyPath)
+        {
+            byte[] publicKeyToken = assemblyName.GetPublicKeyToken();
+            StringBuilder publicKeyTokenString = new(publicKeyToken.Length * 2);
+            for (int i = 0; i < publicKeyToken.Length; i++)
+            {
+                publicKeyTokenString.Append(publicKeyToken[i].ToString("x2", CultureInfo.InvariantCulture));
+            }
+
+            // Create an app.config for the AppDomain. We expect the AD to host the currently executing assembly Microsoft.Build,
+            // NuGet.Frameworks, and Framework assemblies. It is important to use the same binding redirects that were used when
+            // NGENing MSBuild for the native images to be used.
+            string configuration = $"""
+<?xml version="1.0" encoding="utf-8"?>
+  <configuration>
+    <runtime>
+      <DisableFXClosureWalk enabled="true" />
+      <DeferFXClosureWalk enabled="true" />
+      <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
+        {(Environment.Is64BitProcess ? _bindingRedirect64 : _bindingRedirect32)}
+        <dependentAssembly>
+          <assemblyIdentity name="{NuGetFrameworksAssemblyName}" publicKeyToken="{publicKeyTokenString}" culture="{assemblyName.CultureName}" />
+          <codeBase version="{assemblyName.Version}" href="{assemblyPath}" />
+        </dependentAssembly>
+      </assemblyBinding>
+    </runtime>
+  </configuration>
+""";
+
+            AppDomainSetup appDomainSetup = AppDomain.CurrentDomain.SetupInformation;
+            appDomainSetup.SetConfigurationBytes(Encoding.UTF8.GetBytes(configuration));
+            return appDomainSetup;
+        }
+#endif
+
+        public static NuGetFrameworkWrapper CreateInstance()
+        {
+            // Resolve the location of the NuGet.Frameworks assembly
+            string assemblyDirectory = BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio ?
+                Path.Combine(BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory, "Common7", "IDE", "CommonExtensions", "Microsoft", "NuGet") :
+                BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
+
+            string assemblyPath = Path.Combine(assemblyDirectory, NuGetFrameworksFileName);
+
+            NuGetFrameworkWrapper instance = null;
+            AssemblyName assemblyName = null;
+#if FEATURE_APPDOMAIN
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) &&
+                (BuildEnvironmentHelper.Instance.RunningInMSBuildExe || BuildEnvironmentHelper.Instance.RunningInVisualStudio))
+            {
+                // If we are running in MSBuild.exe or VS, we can load the assembly with Assembly.Load, which enables
+                // the runtime to bind to the native image, eliminating some non-trivial JITting cost. Devenv.exe knows how to
+                // load the assembly by name. In MSBuild.exe, however, we don't know the version of the assembly statically so
+                // we create a separate AppDomain with the right binding redirects.
+                try
+                {
+                    assemblyName = AssemblyName.GetAssemblyName(assemblyPath);
+                    if (assemblyName != null && BuildEnvironmentHelper.Instance.RunningInMSBuildExe)
+                    {
+                        AppDomainSetup appDomainSetup = CreateAppDomainSetup(assemblyName, assemblyPath);
+                        if (appDomainSetup != null)
+                        {
+                            AppDomain appDomain = AppDomain.CreateDomain(nameof(NuGetFrameworkWrapper), null, appDomainSetup);
+                            instance = (NuGetFrameworkWrapper)appDomain.CreateInstanceAndUnwrap(Assembly.GetExecutingAssembly().FullName, typeof(NuGetFrameworkWrapper).FullName);
+                        }
+                    }
+                }
+                catch
+                {
+                    // If anything goes wrong just fall back to loading into current AD by path.
+                    instance = null;
+                    assemblyName = null;
+                }
+            }
+#endif
+            try
+            {
+                instance ??= new NuGetFrameworkWrapper();
+                instance.Initialize(assemblyName, assemblyPath);
+
+                return instance;
+            }
+            catch (Exception ex)
+            {
+                throw new InternalErrorException(string.Format(AssemblyResources.GetString("NuGetAssemblyNotFound"), assemblyDirectory), ex);
+            }
+        }
     }
 }
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index fd9dc2a5974..554aa2b2533 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -24,8 +24,8 @@
 
     <ProduceReferenceAssembly Condition="'$(IsTestProject)' != 'true'">true</ProduceReferenceAssembly>
 
-    <!-- Set up BeforeCommon.targets -->
-    <CustomBeforeMicrosoftCommonTargets>$(MSBuildThisFileDirectory)Directory.BeforeCommon.targets</CustomBeforeMicrosoftCommonTargets>
+    <!-- Set up BeforeCommon.targets. Arcade uses this property as well, so don't overwrite it. -->
+    <CustomBeforeMicrosoftCommonTargets>$(CustomBeforeMicrosoftCommonTargets);$(MSBuildThisFileDirectory)Directory.BeforeCommon.targets</CustomBeforeMicrosoftCommonTargets>
 
     <Platforms>AnyCPU;x64;arm64</Platforms>
 
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 1f925324acf..b6479c3698e 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Diagnostics;
 using System.Linq;
 
 #nullable disable
@@ -22,7 +23,7 @@ internal enum ChangeWaveConversionState
     /// </summary>
     /// See docs here: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves.md
     /// For dev docs: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves-Dev.md
-    internal class ChangeWaves
+    internal static class ChangeWaves
     {
         internal static readonly Version Wave17_4 = new Version(17, 4);
         internal static readonly Version Wave17_6 = new Version(17, 6);
@@ -35,6 +36,13 @@ internal class ChangeWaves
         /// </summary>
         internal static readonly Version EnableAllFeatures = new Version(999, 999);
 
+#if DEBUG
+        /// <summary>
+        /// True if <see cref="ResetStateForTests"/> has been called.
+        /// </summary>
+        private static bool _runningTests = false;
+#endif
+
         /// <summary>
         /// The lowest wave in the current rotation of Change Waves.
         /// </summary>
@@ -162,6 +170,10 @@ internal static bool AreFeaturesEnabled(Version wave)
         {
             ApplyChangeWave();
 
+#if DEBUG
+            Debug.Assert(_runningTests || AllWaves.Contains(wave), $"Change wave version {wave} is invalid");
+#endif
+
             return wave < _cachedWave;
         }
 
@@ -171,6 +183,9 @@ internal static bool AreFeaturesEnabled(Version wave)
         /// </summary>
         internal static void ResetStateForTests()
         {
+#if DEBUG
+            _runningTests = true;
+#endif
             _cachedWave = null;
             _state = ChangeWaveConversionState.NotConvertedYet;
         }
diff --git a/src/Framework/ExtendedBuildErrorEventArgs.cs b/src/Framework/ExtendedBuildErrorEventArgs.cs
index e5830592b6c..85d10939236 100644
--- a/src/Framework/ExtendedBuildErrorEventArgs.cs
+++ b/src/Framework/ExtendedBuildErrorEventArgs.cs
@@ -18,7 +18,7 @@ public sealed class ExtendedBuildErrorEventArgs : BuildErrorEventArgs, IExtended
     public string ExtendedType { get; set; }
 
     /// <inheritdoc />
-    public IDictionary<string, string?>? ExtendedMetadata { get; set; }
+    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <inheritdoc />
     public string? ExtendedData { get; set; }
diff --git a/src/Framework/ExtendedBuildMessageEventArgs.cs b/src/Framework/ExtendedBuildMessageEventArgs.cs
index 6330a502050..53ec510c8da 100644
--- a/src/Framework/ExtendedBuildMessageEventArgs.cs
+++ b/src/Framework/ExtendedBuildMessageEventArgs.cs
@@ -18,7 +18,7 @@ public sealed class ExtendedBuildMessageEventArgs : BuildMessageEventArgs, IExte
     public string ExtendedType { get; set; }
 
     /// <inheritdoc />
-    public IDictionary<string, string?>? ExtendedMetadata { get; set; }
+    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <inheritdoc />
     public string? ExtendedData { get; set; }
diff --git a/src/Framework/ExtendedBuildWarningEventArgs.cs b/src/Framework/ExtendedBuildWarningEventArgs.cs
index 88eaf08af0d..9481d2bfbdc 100644
--- a/src/Framework/ExtendedBuildWarningEventArgs.cs
+++ b/src/Framework/ExtendedBuildWarningEventArgs.cs
@@ -18,7 +18,7 @@ public sealed class ExtendedBuildWarningEventArgs : BuildWarningEventArgs, IExte
     public string ExtendedType { get; set; }
 
     /// <inheritdoc />
-    public IDictionary<string, string?>? ExtendedMetadata { get; set; }
+    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <inheritdoc />
     public string? ExtendedData { get; set; }
diff --git a/src/Framework/ExtendedCriticalBuildMessageEventArgs.cs b/src/Framework/ExtendedCriticalBuildMessageEventArgs.cs
index 8b16acdb3be..3897a1de6e6 100644
--- a/src/Framework/ExtendedCriticalBuildMessageEventArgs.cs
+++ b/src/Framework/ExtendedCriticalBuildMessageEventArgs.cs
@@ -18,7 +18,7 @@ public sealed class ExtendedCriticalBuildMessageEventArgs : CriticalBuildMessage
     public string ExtendedType { get; set; }
 
     /// <inheritdoc />
-    public IDictionary<string, string?>? ExtendedMetadata { get; set; }
+    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <inheritdoc />
     public string? ExtendedData { get; set; }
diff --git a/src/Framework/ExtendedCustomBuildEventArgs.cs b/src/Framework/ExtendedCustomBuildEventArgs.cs
index 8a20c512923..0669c025843 100644
--- a/src/Framework/ExtendedCustomBuildEventArgs.cs
+++ b/src/Framework/ExtendedCustomBuildEventArgs.cs
@@ -18,7 +18,7 @@ public sealed class ExtendedCustomBuildEventArgs : CustomBuildEventArgs, IExtend
     public string ExtendedType { get; set; }
 
     /// <inheritdoc />
-    public IDictionary<string, string?>? ExtendedMetadata { get; set; }
+    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <inheritdoc />
     public string? ExtendedData { get; set; }
diff --git a/src/Framework/IEventSource.cs b/src/Framework/IEventSource.cs
index 4ba9c258238..187c105d386 100644
--- a/src/Framework/IEventSource.cs
+++ b/src/Framework/IEventSource.cs
@@ -152,4 +152,165 @@ public interface IEventSource
         /// </summary>
         event AnyEventHandler AnyEventRaised;
     }
+
+    /// <summary>
+    /// Helper methods for <see cref="IEventSource"/> interface.
+    /// </summary>
+    public static class EventSourceExtensions
+    {
+        /// <summary>
+        /// Helper method ensuring single deduplicated subscription to the <see cref="IEventSource.MessageRaised"/> event.
+        /// </summary>
+        /// <param name="eventSource"></param>
+        /// <param name="handler">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>
+        public static void HandleMessageRaised(this IEventSource eventSource, BuildMessageEventHandler handler)
+        {
+            eventSource.MessageRaised -= handler;
+            eventSource.MessageRaised += handler;
+        }
+
+        /// <summary>
+        /// Helper method ensuring single deduplicated subscription to the <see cref="IEventSource.ErrorRaised"/> event.
+        /// </summary>
+        /// <param name="eventSource"></param>
+        /// <param name="handler">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>
+        public static void HandleErrorRaised(this IEventSource eventSource, BuildErrorEventHandler handler)
+        {
+            eventSource.ErrorRaised -= handler;
+            eventSource.ErrorRaised += handler;
+        }
+
+        /// <summary>
+        /// Helper method ensuring single deduplicated subscription to the <see cref="IEventSource.WarningRaised"/> event.
+        /// </summary>
+        /// <param name="eventSource"></param>
+        /// <param name="handler">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>
+        public static void HandleWarningRaised(this IEventSource eventSource, BuildWarningEventHandler handler)
+        {
+            eventSource.WarningRaised -= handler;
+            eventSource.WarningRaised += handler;
+        }
+
+        /// <summary>
+        /// Helper method ensuring single deduplicated subscription to the <see cref="IEventSource.BuildStarted"/> event.
+        /// </summary>
+        /// <param name="eventSource"></param>
+        /// <param name="handler">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>
+        public static void HandleBuildStarted(this IEventSource eventSource, BuildStartedEventHandler handler)
+        {
+            eventSource.BuildStarted -= handler;
+            eventSource.BuildStarted += handler;
+        }
+
+        /// <summary>
+        /// Helper method ensuring single deduplicated subscription to the <see cref="IEventSource.BuildFinished"/> event.
+        /// </summary>
+        /// <param name="eventSource"></param>
+        /// <param name="handler">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>
+        public static void HandleBuildFinished(this IEventSource eventSource, BuildFinishedEventHandler handler)
+        {
+            eventSource.BuildFinished -= handler;
+            eventSource.BuildFinished += handler;
+        }
+
+        /// <summary>
+        /// Helper method ensuring single deduplicated subscription to the <see cref="IEventSource.ProjectStarted"/> event.
+        /// </summary>
+        /// <param name="eventSource"></param>
+        /// <param name="handler">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>
+        public static void HandleProjectStarted(this IEventSource eventSource, ProjectStartedEventHandler handler)
+        {
+            eventSource.ProjectStarted -= handler;
+            eventSource.ProjectStarted += handler;
+        }
+
+        /// <summary>
+        /// Helper method ensuring single deduplicated subscription to the <see cref="IEventSource.ProjectFinished"/> event.
+        /// </summary>
+        /// <param name="eventSource"></param>
+        /// <param name="handler">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>
+        public static void HandleProjectFinished(this IEventSource eventSource, ProjectFinishedEventHandler handler)
+        {
+            eventSource.ProjectFinished -= handler;
+            eventSource.ProjectFinished += handler;
+        }
+
+
+        /// <summary>
+        /// Helper method ensuring single deduplicated subscription to the <see cref="IEventSource.TargetStarted"/> event.
+        /// </summary>
+        /// <param name="eventSource"></param>
+        /// <param name="handler">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>
+        public static void HandleTargetStarted(this IEventSource eventSource, TargetStartedEventHandler handler)
+        {
+            eventSource.TargetStarted -= handler;
+            eventSource.TargetStarted += handler;
+        }
+
+        /// <summary>
+        /// Helper method ensuring single deduplicated subscription to the <see cref="IEventSource.TargetFinished"/> event.
+        /// </summary>
+        /// <param name="eventSource"></param>
+        /// <param name="handler">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>
+        public static void HandleTargetFinished(this IEventSource eventSource, TargetFinishedEventHandler handler)
+        {
+            eventSource.TargetFinished -= handler;
+            eventSource.TargetFinished += handler;
+        }
+
+        /// <summary>
+        /// Helper method ensuring single deduplicated subscription to the <see cref="IEventSource.TaskStarted"/> event.
+        /// </summary>
+        /// <param name="eventSource"></param>
+        /// <param name="handler">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>
+        public static void HandleTaskStarted(this IEventSource eventSource, TaskStartedEventHandler handler)
+        {
+            eventSource.TaskStarted -= handler;
+            eventSource.TaskStarted += handler;
+        }
+
+        /// <summary>
+        /// Helper method ensuring single deduplicated subscription to the <see cref="IEventSource.TaskFinished"/> event.
+        /// </summary>
+        /// <param name="eventSource"></param>
+        /// <param name="handler">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>
+        public static void HandleTaskFinished(this IEventSource eventSource, TaskFinishedEventHandler handler)
+        {
+            eventSource.TaskFinished -= handler;
+            eventSource.TaskFinished += handler;
+        }
+
+        /// <summary>
+        /// Helper method ensuring single deduplicated subscription to the <see cref="IEventSource.CustomEventRaised"/> event.
+        /// </summary>
+        /// <param name="eventSource"></param>
+        /// <param name="handler">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>
+        public static void HandleCustomEventRaised(this IEventSource eventSource, CustomBuildEventHandler handler)
+        {
+            eventSource.CustomEventRaised -= handler;
+            eventSource.CustomEventRaised += handler;
+        }
+
+        /// <summary>
+        /// Helper method ensuring single deduplicated subscription to the <see cref="IEventSource.StatusEventRaised"/> event.
+        /// </summary>
+        /// <param name="eventSource"></param>
+        /// <param name="handler">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>
+        public static void HandleStatusEventRaised(this IEventSource eventSource, BuildStatusEventHandler handler)
+        {
+            eventSource.StatusEventRaised -= handler;
+            eventSource.StatusEventRaised += handler;
+        }
+
+        /// <summary>
+        /// Helper method ensuring single deduplicated subscription to the <see cref="IEventSource.AnyEventRaised"/> event.
+        /// </summary>
+        /// <param name="eventSource"></param>
+        /// <param name="handler">Handler to the event. If this handler is already subscribed, single subscription will be ensured.</param>
+        public static void HandleAnyEventRaised(this IEventSource eventSource, AnyEventHandler handler)
+        {
+            eventSource.AnyEventRaised -= handler;
+            eventSource.AnyEventRaised += handler;
+        }
+    }
 }
diff --git a/src/Framework/IExtendedBuildEventArgs.cs b/src/Framework/IExtendedBuildEventArgs.cs
index 83b4c3ba555..0c73ddb914f 100644
--- a/src/Framework/IExtendedBuildEventArgs.cs
+++ b/src/Framework/IExtendedBuildEventArgs.cs
@@ -22,7 +22,7 @@ public interface IExtendedBuildEventArgs
     ///   - data which needed in custom code to properly routing this message without interpreting/deserializing <see cref="ExtendedData"/>.
     ///   - simple extended data can be transferred in form of dictionary key-value per one extended property.
     /// </summary>
-    IDictionary<string, string?>? ExtendedMetadata { get; set; }
+    Dictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <summary>
     /// Transparent data as string.
diff --git a/src/Framework/Telemetry/BuildTelemetry.cs b/src/Framework/Telemetry/BuildTelemetry.cs
index 9515a2e185e..7e2e0c6b514 100644
--- a/src/Framework/Telemetry/BuildTelemetry.cs
+++ b/src/Framework/Telemetry/BuildTelemetry.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.Globalization;
 
 namespace Microsoft.Build.Framework.Telemetry
@@ -84,62 +85,67 @@ internal class BuildTelemetry : TelemetryBase
         /// </summary>
         public string? FrameworkName { get; set; }
 
-        public override void UpdateEventProperties()
+        public override IDictionary<string, string> GetProperties()
         {
+            var properties = new Dictionary<string, string>();
+
+            // populate property values
             if (DisplayVersion != null)
             {
-                Properties["BuildEngineDisplayVersion"] = DisplayVersion;
+                properties["BuildEngineDisplayVersion"] = DisplayVersion;
             }
 
             if (StartAt.HasValue && FinishedAt.HasValue)
             {
-                Properties["BuildDurationInMilliseconds"] = (FinishedAt.Value - StartAt.Value).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+                properties["BuildDurationInMilliseconds"] = (FinishedAt.Value - StartAt.Value).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
             }
 
             if (InnerStartAt.HasValue && FinishedAt.HasValue)
             {
-                Properties["InnerBuildDurationInMilliseconds"] = (FinishedAt.Value - InnerStartAt.Value).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+                properties["InnerBuildDurationInMilliseconds"] = (FinishedAt.Value - InnerStartAt.Value).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
             }
 
             if (FrameworkName != null)
             {
-                Properties["BuildEngineFrameworkName"] = FrameworkName;
+                properties["BuildEngineFrameworkName"] = FrameworkName;
             }
 
             if (Host != null)
             {
-                Properties["BuildEngineHost"] = Host;
+                properties["BuildEngineHost"] = Host;
             }
 
             if (InitialServerState != null)
             {
-                Properties["InitialMSBuildServerState"] = InitialServerState;
+                properties["InitialMSBuildServerState"] = InitialServerState;
             }
 
             if (Project != null)
             {
-                Properties["ProjectPath"] = Project;
+                properties["ProjectPath"] = Project;
             }
 
             if (ServerFallbackReason != null)
             {
-                Properties["ServerFallbackReason"] = ServerFallbackReason;
+                properties["ServerFallbackReason"] = ServerFallbackReason;
             }
 
             if (Success.HasValue)
             {
-                Properties["BuildSuccess"] = Success.HasValue.ToString(CultureInfo.InvariantCulture);
+                properties["BuildSuccess"] = Success.HasValue.ToString(CultureInfo.InvariantCulture);
             }
 
             if (Target != null)
             {
-                Properties["BuildTarget"] = Target;
+                properties["BuildTarget"] = Target;
             }
 
             if (Version != null)
             {
-                Properties["BuildEngineVersion"] = Version.ToString();
+                properties["BuildEngineVersion"] = Version.ToString();
             }
+
+            return properties;
         }
     }
 }
diff --git a/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs b/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs
index 5281c43b9d2..493a945a526 100644
--- a/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs
+++ b/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.Globalization;
 
 namespace Microsoft.Build.Framework.Telemetry;
@@ -97,54 +98,59 @@ internal class LoggingConfigurationTelemetry : TelemetryBase
     /// </summary>
     public bool BinaryLoggerUsedDefaultName { get; set; }
 
-    public override void UpdateEventProperties()
+    public override IDictionary<string, string> GetProperties()
     {
-        Properties["TerminalLogger"] = TerminalLogger.ToString(CultureInfo.InvariantCulture);
+        var properties = new Dictionary<string, string>();
+
+        // populate property values
+        properties["TerminalLogger"] = TerminalLogger.ToString(CultureInfo.InvariantCulture);
 
         if (TerminalLoggerUserIntent != null)
         {
-            Properties["TerminalLoggerUserIntent"] = TerminalLoggerUserIntent;
+            properties["TerminalLoggerUserIntent"] = TerminalLoggerUserIntent;
         }
 
         if (TerminalLoggerUserIntentSource != null)
         {
-            Properties["TerminalLoggerUserIntentSource"] = TerminalLoggerUserIntentSource;
+            properties["TerminalLoggerUserIntentSource"] = TerminalLoggerUserIntentSource;
         }
 
         if (TerminalLoggerDefault != null)
         {
-            Properties["TerminalLoggerDefault"] = TerminalLoggerDefault;
+            properties["TerminalLoggerDefault"] = TerminalLoggerDefault;
         }
 
         if (TerminalLoggerDefaultSource != null)
         {
-            Properties["TerminalLoggerDefaultSource"] = TerminalLoggerDefaultSource;
+            properties["TerminalLoggerDefaultSource"] = TerminalLoggerDefaultSource;
         }
 
-        Properties["ConsoleLogger"] = ConsoleLogger.ToString(CultureInfo.InvariantCulture);
+        properties["ConsoleLogger"] = ConsoleLogger.ToString(CultureInfo.InvariantCulture);
         if (ConsoleLoggerType != null)
         {
-            Properties["ConsoleLoggerType"] = ConsoleLoggerType;
+            properties["ConsoleLoggerType"] = ConsoleLoggerType;
         }
 
         if (ConsoleLoggerVerbosity != null)
         {
-            Properties["ConsoleLoggerVerbosity"] = ConsoleLoggerVerbosity;
+            properties["ConsoleLoggerVerbosity"] = ConsoleLoggerVerbosity;
         }
 
-        Properties["FileLogger"] = FileLogger.ToString(CultureInfo.InvariantCulture);
+        properties["FileLogger"] = FileLogger.ToString(CultureInfo.InvariantCulture);
         if (FileLoggerType != null)
         {
-            Properties["FileLoggerType"] = FileLoggerType;
-            Properties["FileLoggersCount"] = FileLoggersCount.ToString(CultureInfo.InvariantCulture);
+            properties["FileLoggerType"] = FileLoggerType;
+            properties["FileLoggersCount"] = FileLoggersCount.ToString(CultureInfo.InvariantCulture);
         }
 
         if (FileLoggerVerbosity != null)
         {
-            Properties["FileLoggerVerbosity"] = FileLoggerVerbosity;
+            properties["FileLoggerVerbosity"] = FileLoggerVerbosity;
         }
 
-        Properties["BinaryLogger"] = BinaryLogger.ToString(CultureInfo.InvariantCulture);
-        Properties["BinaryLoggerUsedDefaultName"] = BinaryLoggerUsedDefaultName.ToString(CultureInfo.InvariantCulture);
+        properties["BinaryLogger"] = BinaryLogger.ToString(CultureInfo.InvariantCulture);
+        properties["BinaryLoggerUsedDefaultName"] = BinaryLoggerUsedDefaultName.ToString(CultureInfo.InvariantCulture);
+
+        return properties;
     }
 }
diff --git a/src/Framework/Telemetry/TelemetryBase.cs b/src/Framework/Telemetry/TelemetryBase.cs
index d2475146c5b..9084c330488 100644
--- a/src/Framework/Telemetry/TelemetryBase.cs
+++ b/src/Framework/Telemetry/TelemetryBase.cs
@@ -13,12 +13,7 @@ internal abstract class TelemetryBase
     public abstract string EventName { get; }
 
     /// <summary>
-    /// Gets or sets a list of properties associated with the event.
+    /// Fetches all derived type members wrapped in Dictionary which will be used to build <see cref="TelemetryEventArgs"/>.
     /// </summary>
-    public IDictionary<string, string> Properties { get; set; } = new Dictionary<string, string>();
-
-    /// <summary>
-    /// Translate all derived type members into properties which will be used to build <see cref="TelemetryEventArgs"/>.
-    /// </summary>
-    public abstract void UpdateEventProperties();
+    public abstract IDictionary<string, string> GetProperties();
 }
diff --git a/src/MSBuild.UnitTests/MockStopwatch.cs b/src/MSBuild.UnitTests/MockStopwatch.cs
new file mode 100644
index 00000000000..8c65821140f
--- /dev/null
+++ b/src/MSBuild.UnitTests/MockStopwatch.cs
@@ -0,0 +1,34 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Logging.TerminalLogger;
+
+namespace Microsoft.Build.CommandLine.UnitTests;
+
+internal sealed class MockStopwatch : StopwatchAbstraction
+{
+    public override double ElapsedSeconds
+    {
+        get
+        {
+            return _elapsed;
+        }
+    }
+
+    public override void Start()
+    {
+        IsStarted = true;
+        Tick();
+    }
+
+    public override void Stop() => IsStarted = false;
+
+    public bool IsStarted { get; private set; }
+
+    private double _elapsed = 0d;
+
+    public void Tick(double seconds = 0.1)
+    {
+        _elapsed += seconds;
+    }
+}
diff --git a/src/MSBuild.UnitTests/NodeStatus_Tests.cs b/src/MSBuild.UnitTests/NodeStatus_Tests.cs
index 50ae7b38a51..42e821c4ae6 100644
--- a/src/MSBuild.UnitTests/NodeStatus_Tests.cs
+++ b/src/MSBuild.UnitTests/NodeStatus_Tests.cs
@@ -1,4 +1,4 @@
-// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -21,7 +21,7 @@ namespace Microsoft.Build.CommandLine.UnitTests;
 [UsesVerify]
 public class NodeStatus_Tests
 {
-    private readonly NodeStatus _status = new("Namespace.Project", "TargetFramework", "Target", new());
+    private readonly NodeStatus _status = new("Namespace.Project", "TargetFramework", "Target", new MockStopwatch());
 
     public NodeStatus_Tests()
     {
@@ -31,32 +31,32 @@ public NodeStatus_Tests()
     [Fact]
     public async Task EverythingFits()
     {
-        NodesFrame frame = new(new[] { _status }, width: 80, height: 5);
+        NodesFrame frame = new([_status], width: 80, height: 5);
 
-        await Verify(frame.RenderNodeStatus(_status).ToString());
+        await Verify(frame.RenderNodeStatus(0).ToString());
     }
 
     [Fact]
     public async Task TargetIsTruncatedFirst()
     {
-        NodesFrame frame = new(new[] { _status }, width: 45, height: 5);
+        NodesFrame frame = new([_status], width: 45, height: 5);
 
-        await Verify(frame.RenderNodeStatus(_status).ToString());
+        await Verify(frame.RenderNodeStatus(0).ToString());
     }
 
     [Fact]
     public async Task NamespaceIsTruncatedNext()
     {
-        NodesFrame frame = new(new[] { _status }, width: 40, height: 5);
+        NodesFrame frame = new([_status], width: 40, height: 5);
 
-        await Verify(frame.RenderNodeStatus(_status).ToString());
+        await Verify(frame.RenderNodeStatus(0).ToString());
     }
 
     [Fact]
     public async Task GoesToProject()
     {
-        NodesFrame frame = new(new[] { _status }, width: 10, height: 5);
+        NodesFrame frame = new([_status], width: 10, height: 5);
 
-        await Verify(frame.RenderNodeStatus(_status).ToString());
+        await Verify(frame.RenderNodeStatus(0).ToString());
     }
 }
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Linux.verified.txt
new file mode 100644
index 00000000000..2e9f63be66c
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Linux.verified.txt
@@ -0,0 +1,3 @@
+]9;4;3;\[?25l[1F
+  project [120G[14DBuild (111.2s)
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.OSX.verified.txt
new file mode 100644
index 00000000000..dc43e217d65
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.OSX.verified.txt
@@ -0,0 +1,3 @@
+[?25l[1F
+  project [120G[14DBuild (111.2s)
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Windows.verified.txt
new file mode 100644
index 00000000000..2e9f63be66c
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Windows.verified.txt
@@ -0,0 +1,3 @@
+]9;4;3;\[?25l[1F
+  project [120G[14DBuild (111.2s)
+[?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt
index fe12f4e9dec..7e605333ed6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt
@@ -1,5 +1,5 @@
 ]9;4;3;\[?25l[1F
-  project [36;1mtfName[m [120G[12DBuild (0.0s)
+  project [36;1mtfName[m [120G[12DBuild (0.2s)
 [?25h[?25l[2F
-[K  project [36;1mtf2[m [120G[12DBuild (0.0s)
+[K  project [36;1mtf2[m [120G[12DBuild (0.2s)
 [?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt
index 8d078e61f5c..5018115c62a 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt
@@ -1,5 +1,5 @@
 [?25l[1F
-  project [36;1mtfName[m [120G[12DBuild (0.0s)
+  project [36;1mtfName[m [120G[12DBuild (0.2s)
 [?25h[?25l[2F
-[K  project [36;1mtf2[m [120G[12DBuild (0.0s)
+[K  project [36;1mtf2[m [120G[12DBuild (0.2s)
 [?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt
index fe12f4e9dec..7e605333ed6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt
@@ -1,5 +1,5 @@
 ]9;4;3;\[?25l[1F
-  project [36;1mtfName[m [120G[12DBuild (0.0s)
+  project [36;1mtfName[m [120G[12DBuild (0.2s)
 [?25h[?25l[2F
-[K  project [36;1mtf2[m [120G[12DBuild (0.0s)
+[K  project [36;1mtf2[m [120G[12DBuild (0.2s)
 [?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt
index 1f7b782f2ef..ccfb1bac3a5 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt
@@ -1,3 +1,3 @@
 ]9;4;3;\[?25l[1F
-  project [120G[12DBuild (0.0s)
+  project [120G[12DBuild (0.2s)
 [?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt
index 143745dea40..c671e994c3e 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt
@@ -1,3 +1,3 @@
 [?25l[1F
-  project [120G[12DBuild (0.0s)
+  project [120G[12DBuild (0.2s)
 [?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt
index 1f7b782f2ef..ccfb1bac3a5 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt
@@ -1,3 +1,3 @@
 ]9;4;3;\[?25l[1F
-  project [120G[12DBuild (0.0s)
+  project [120G[12DBuild (0.2s)
 [?25h
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt
index e397b179c6b..b863cb67194 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt
@@ -1,4 +1,4 @@
 ]9;4;3;\[?25l[1F
 [?25h
-Build [31;1mfailed[m in 0.0s
+Build [31;1mfailed[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt
index 5dac0df45b6..c36142ab71a 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt
@@ -1,3 +1,3 @@
 [?25l[1F
 [?25h
-Build [31;1mfailed[m in 0.0s
+Build [31;1mfailed[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt
index e397b179c6b..b863cb67194 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt
@@ -1,4 +1,4 @@
 ]9;4;3;\[?25l[1F
 [?25h
-Build [31;1mfailed[m in 0.0s
+Build [31;1mfailed[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt
index 0041a7257fe..11e72f94fbf 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt
@@ -1,6 +1,6 @@
-]9;4;3;\  project [31;1mfailed with errors[m (0.0s)
+]9;4;3;\  project [31;1mfailed with errors[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with errors[m in 0.0s
+Build [31;1mfailed with errors[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt
index cf0d8f1d6c9..bc476784fbb 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt
@@ -1,5 +1,5 @@
-  project [31;1mfailed with errors[m (0.0s)
+  project [31;1mfailed with errors[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with errors[m in 0.0s
+Build [31;1mfailed with errors[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt
index 0041a7257fe..11e72f94fbf 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt
@@ -1,6 +1,6 @@
-]9;4;3;\  project [31;1mfailed with errors[m (0.0s)
+]9;4;3;\  project [31;1mfailed with errors[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with errors[m in 0.0s
+Build [31;1mfailed with errors[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
index 86c02fdb8df..aeec26abf26 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
@@ -1,6 +1,6 @@
-]9;4;3;\  project [33;1msucceeded with warnings[m (0.0s)
+]9;4;3;\  project [33;1msucceeded with warnings[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
 [?25l[1F
 [?25h
-Build [33;1msucceeded with warnings[m in 0.0s
+Build [33;1msucceeded with warnings[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
index 43510237153..3b6fcaf238d 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
@@ -1,5 +1,5 @@
-  project [33;1msucceeded with warnings[m (0.0s)
+  project [33;1msucceeded with warnings[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
 [?25l[1F
 [?25h
-Build [33;1msucceeded with warnings[m in 0.0s
+Build [33;1msucceeded with warnings[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
index 86c02fdb8df..aeec26abf26 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
@@ -1,6 +1,6 @@
-]9;4;3;\  project [33;1msucceeded with warnings[m (0.0s)
+]9;4;3;\  project [33;1msucceeded with warnings[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
 [?25l[1F
 [?25h
-Build [33;1msucceeded with warnings[m in 0.0s
+Build [33;1msucceeded with warnings[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Linux.verified.txt
index e6169b4e163..d5e6b72e894 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Linux.verified.txt
@@ -1,4 +1,4 @@
 ]9;4;3;\[?25l[1F
 [?25h
-Build [32;1msucceeded[m in 0.0s
+Build [32;1msucceeded[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.OSX.verified.txt
index de2ebf4c55e..4d414bf90bf 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.OSX.verified.txt
@@ -1,3 +1,3 @@
 [?25l[1F
 [?25h
-Build [32;1msucceeded[m in 0.0s
+Build [32;1msucceeded[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Windows.verified.txt
index e6169b4e163..d5e6b72e894 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Windows.verified.txt
@@ -1,4 +1,4 @@
 ]9;4;3;\[?25l[1F
 [?25h
-Build [32;1msucceeded[m in 0.0s
+Build [32;1msucceeded[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Linux.verified.txt
index 86eed92792e..75842281bfb 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Linux.verified.txt
@@ -1,5 +1,5 @@
 ]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
 [?25l[1F
 [?25h
-Build [32;1msucceeded[m in 0.0s
+Build [32;1msucceeded[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.OSX.verified.txt
index acf188a70ce..1e10e7fc988 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.OSX.verified.txt
@@ -1,4 +1,4 @@
 The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
 [?25l[1F
 [?25h
-Build [32;1msucceeded[m in 0.0s
+Build [32;1msucceeded[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Windows.verified.txt
index 86eed92792e..75842281bfb 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Windows.verified.txt
@@ -1,5 +1,5 @@
 ]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
 [?25l[1F
 [?25h
-Build [32;1msucceeded[m in 0.0s
+Build [32;1msucceeded[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Linux.verified.txt
index d3967bfd576..512b5b78d7e 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Linux.verified.txt
@@ -1,9 +1,9 @@
 ]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]DeviceFlow: https://testfeed/index.json
 directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]ATTENTION: User interaction required.**********************************************************************To sign in, use a web browser to open the page https://devicelogin and enter the code XXXXXX to authenticate.**********************************************************************
-  project [33;1msucceeded with warnings[m (0.0s)
+  project [33;1msucceeded with warnings[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]DeviceFlow: https://testfeed/index.json
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]ATTENTION: User interaction required.**********************************************************************To sign in, use a web browser to open the page https://devicelogin and enter the code XXXXXX to authenticate.**********************************************************************
 [?25l[1F
 [?25h
-Build [33;1msucceeded with warnings[m in 0.0s
+Build [33;1msucceeded with warnings[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.OSX.verified.txt
index 42c777b8c11..0b5a2d831c1 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.OSX.verified.txt
@@ -1,8 +1,8 @@
 directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]DeviceFlow: https://testfeed/index.json
 directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]ATTENTION: User interaction required.**********************************************************************To sign in, use a web browser to open the page https://devicelogin and enter the code XXXXXX to authenticate.**********************************************************************
-  project [33;1msucceeded with warnings[m (0.0s)
+  project [33;1msucceeded with warnings[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]DeviceFlow: https://testfeed/index.json
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]ATTENTION: User interaction required.**********************************************************************To sign in, use a web browser to open the page https://devicelogin and enter the code XXXXXX to authenticate.**********************************************************************
 [?25l[1F
 [?25h
-Build [33;1msucceeded with warnings[m in 0.0s
+Build [33;1msucceeded with warnings[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Windows.verified.txt
index d3967bfd576..512b5b78d7e 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Windows.verified.txt
@@ -1,9 +1,9 @@
 ]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]DeviceFlow: https://testfeed/index.json
 directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]ATTENTION: User interaction required.**********************************************************************To sign in, use a web browser to open the page https://devicelogin and enter the code XXXXXX to authenticate.**********************************************************************
-  project [33;1msucceeded with warnings[m (0.0s)
+  project [33;1msucceeded with warnings[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]DeviceFlow: https://testfeed/index.json
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: [CredentialProvider]ATTENTION: User interaction required.**********************************************************************To sign in, use a web browser to open the page https://devicelogin and enter the code XXXXXX to authenticate.**********************************************************************
 [?25l[1F
 [?25h
-Build [33;1msucceeded with warnings[m in 0.0s
+Build [33;1msucceeded with warnings[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Linux.verified.txt
index 1df7926cf3f..fde469843b0 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Linux.verified.txt
@@ -1,4 +1,4 @@
-directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Restore Failed
+]9;4;3;\directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Restore Failed
 
-Build [31;1mfailed with errors[m in 0.0s
+Build [31;1mfailed with errors[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.OSX.verified.txt
index c4d47333679..f912378dc48 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.OSX.verified.txt
@@ -1,3 +1,3 @@
 directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Restore Failed
 
-Build [31;1mfailed with errors[m in 0.0s
+Build [31;1mfailed with errors[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Windows.verified.txt
index 1df7926cf3f..fde469843b0 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Windows.verified.txt
@@ -1,4 +1,4 @@
-directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Restore Failed
+]9;4;3;\directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Restore Failed
 
-Build [31;1mfailed with errors[m in 0.0s
+Build [31;1mfailed with errors[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Linux.verified.txt
index bc7006945a4..927084af0f3 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Linux.verified.txt
@@ -1,4 +1,4 @@
-directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Restore with Warning
+]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Restore with Warning
 
-Build [33;1msucceeded with warnings[m in 0.0s
+Build [33;1msucceeded with warnings[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.OSX.verified.txt
index 8756e2b3be2..430fce9be26 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.OSX.verified.txt
@@ -1,3 +1,3 @@
 directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Restore with Warning
 
-Build [33;1msucceeded with warnings[m in 0.0s
+Build [33;1msucceeded with warnings[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Windows.verified.txt
index bc7006945a4..927084af0f3 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Windows.verified.txt
@@ -1,4 +1,4 @@
-directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Restore with Warning
+]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Restore with Warning
 
-Build [33;1msucceeded with warnings[m in 0.0s
+Build [33;1msucceeded with warnings[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt
index e6169b4e163..d5e6b72e894 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt
@@ -1,4 +1,4 @@
 ]9;4;3;\[?25l[1F
 [?25h
-Build [32;1msucceeded[m in 0.0s
+Build [32;1msucceeded[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt
index de2ebf4c55e..4d414bf90bf 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt
@@ -1,3 +1,3 @@
 [?25l[1F
 [?25h
-Build [32;1msucceeded[m in 0.0s
+Build [32;1msucceeded[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt
index e6169b4e163..d5e6b72e894 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt
@@ -1,4 +1,4 @@
 ]9;4;3;\[?25l[1F
 [?25h
-Build [32;1msucceeded[m in 0.0s
+Build [32;1msucceeded[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
index 9d764455e9a..75749517b55 100644
--- a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
+++ b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
@@ -11,6 +11,7 @@
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.CommandLine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
@@ -41,8 +42,6 @@ public class TerminalLogger_Tests : IEventSource, IDisposable
 
         private VerifySettings _settings = new();
 
-        private static Regex s_elapsedTime = new($@"\d+{Regex.Escape(CultureInfo.CurrentCulture.NumberFormat.NumberDecimalSeparator)}\ds", RegexOptions.Compiled);
-
         public TerminalLogger_Tests()
         {
             _mockTerminal = new Terminal(_outputWriter);
@@ -50,17 +49,9 @@ public TerminalLogger_Tests()
 
             _terminallogger.Initialize(this, _nodeCount);
 
-            UseProjectRelativeDirectory("Snapshots");
+            _terminallogger.CreateStopwatch = () => new MockStopwatch();
 
-            // Scrub timestamps on intermediate execution lines,
-            // which are subject to the vagaries of the test machine
-            // and OS scheduler.
-            _settings.AddScrubber(static lineBuilder =>
-            {
-                string line = lineBuilder.ToString();
-                lineBuilder.Clear();
-                lineBuilder.Append(s_elapsedTime.Replace(line, "0.0s"));
-            });
+            UseProjectRelativeDirectory("Snapshots");
         }
 
         #region IEventSource implementation
@@ -209,8 +200,6 @@ private void InvokeLoggerCallbacksForSimpleProject(bool succeeded, Action additi
 
             additionalCallbacks();
 
-            Thread.Sleep(1_000);
-
             TaskFinished?.Invoke(_eventSender, MakeTaskFinishedEventArgs(_projectFile, "Task", succeeded));
             TargetFinished?.Invoke(_eventSender, MakeTargetFinishedEventArgs(_projectFile, "Build", succeeded));
 
@@ -281,6 +270,8 @@ public Task PrintImmediateMessage_Skipped()
         [Fact]
         public Task PrintRestore_Failed()
         {
+            BuildStarted?.Invoke(_eventSender, MakeBuildStartedEventArgs());
+
             bool succeeded = false;
             ErrorRaised?.Invoke(_eventSender, MakeErrorEventArgs("Restore Failed"));
 
@@ -293,6 +284,8 @@ public Task PrintRestore_Failed()
         [Fact]
         public Task PrintRestore_SuccessWithWarnings()
         {
+            BuildStarted?.Invoke(_eventSender, MakeBuildStartedEventArgs());
+
             bool succeeded = true;
             WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("Restore with Warning"));
 
@@ -333,6 +326,43 @@ public void DisplayNodesShowsCurrent()
             });
         }
 
+        [Fact]
+        public void DisplayNodesOverwritesTime()
+        {
+            List<MockStopwatch> stopwatches = new();
+
+            Func<StopwatchAbstraction>? createStopwatch = _terminallogger.CreateStopwatch;
+
+            try
+            {
+                _terminallogger.CreateStopwatch = () =>
+                {
+                    MockStopwatch stopwatch = new();
+                    stopwatches.Add(stopwatch);
+                    return stopwatch;
+                };
+
+                InvokeLoggerCallbacksForSimpleProject(succeeded: false, async () =>
+                {
+                    foreach (var stopwatch in stopwatches)
+                    {
+                        // Tick time forward by at least 10 seconds,
+                        // as a regression test for https://github.com/dotnet/msbuild/issues/9562
+                        stopwatch.Tick(111.0);
+                    }
+
+                    _terminallogger.DisplayNodes();
+
+                    await Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+                });
+            }
+            finally
+            {
+                _terminallogger.CreateStopwatch = createStopwatch;
+            }
+        }
+
+
         [Fact]
         public async Task DisplayNodesOverwritesWithNewTargetFramework()
         {
@@ -383,13 +413,8 @@ public void TestTerminalLoggerTogetherWithOtherLoggers()
                 TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
                 TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
 
-                BinaryLogger loggerWithTL = new();
                 string logFileWithTL = env.ExpectFile(".binlog").Path;
-                loggerWithTL.Parameters = logFileWithTL;
-
-                BinaryLogger loggerWithoutTL = new();
                 string logFileWithoutTL = env.ExpectFile(".binlog").Path;
-                loggerWithoutTL.Parameters = logFileWithoutTL;
 
                 // Execute MSBuild with binary, file and terminal loggers
                 RunnerUtilities.ExecMSBuild($"{projectFile.Path} /m /bl:{logFileWithTL} -flp:logfile={Path.Combine(logFolder.Path, "logFileWithTL.log")};verbosity=diagnostic -tl:on", out bool success);
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 1fafe1f5bef..d92d9cdf5e2 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -523,6 +523,91 @@ public void Help(string indicator)
             .ShouldBe(MSBuildApp.ExitType.Success);
         }
 
+        [Fact]
+        public void VersionSwitch()
+        {
+            using TestEnvironment env = UnitTests.TestEnvironment.Create();
+
+            // Ensure Change Wave 17.10 is enabled.
+            ChangeWaves.ResetStateForTests();
+            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", "");
+            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+            List<string> cmdLine = new()
+            {
+#if !FEATURE_RUN_EXE_IN_TESTS
+                EnvironmentProvider.GetDotnetExePath(),
+#endif
+                FileUtilities.EnsureDoubleQuotes(RunnerUtilities.PathToCurrentlyRunningMsBuildExe),
+                "-nologo",
+                "-version"
+            };
+
+            using Process process = new()
+            {
+                StartInfo =
+                {
+                    FileName = cmdLine[0],
+                    Arguments = string.Join(" ", cmdLine.Skip(1)),
+                    UseShellExecute = false,
+                    RedirectStandardOutput = true,
+                },
+            };
+
+            process.Start();
+            process.WaitForExit();
+            process.ExitCode.ShouldBe(0);
+
+            string output = process.StandardOutput.ReadToEnd();
+            output.EndsWith(Environment.NewLine).ShouldBeTrue();
+
+            process.Close();
+        }
+
+        /// <summary>
+        /// PR: Change Version switch output to finish with a newline https://github.com/dotnet/msbuild/pull/9485
+        /// </summary>
+        [Fact]
+        public void VersionSwitchDisableChangeWave()
+        {
+            using TestEnvironment env = UnitTests.TestEnvironment.Create();
+
+            // Disable Change Wave 17.10
+            ChangeWaves.ResetStateForTests();
+            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_10.ToString());
+            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+            List<string> cmdLine = new()
+            {
+#if !FEATURE_RUN_EXE_IN_TESTS
+                EnvironmentProvider.GetDotnetExePath(),
+#endif
+                FileUtilities.EnsureDoubleQuotes(RunnerUtilities.PathToCurrentlyRunningMsBuildExe),
+                "-nologo",
+                "-version"
+            };
+
+            using Process process = new()
+            {
+                StartInfo =
+                {
+                    FileName = cmdLine[0],
+                    Arguments = string.Join(" ", cmdLine.Skip(1)),
+                    UseShellExecute = false,
+                    RedirectStandardOutput = true,
+                },
+            };
+
+            process.Start();
+            process.WaitForExit();
+            process.ExitCode.ShouldBe(0);
+
+            string output = process.StandardOutput.ReadToEnd();
+            output.EndsWith(Environment.NewLine).ShouldBeFalse();
+
+            process.Close();
+        }
+
         [Fact]
         public void ErrorCommandLine()
         {
@@ -618,6 +703,17 @@ public void InvalidMaxCPUCountSwitch4()
             });
         }
 
+        [Fact]
+        public void GetPropertyWithInvalidProjectThrowsInvalidProjectFileExceptionNotInternalError()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            TransientTestFile project = env.CreateFile("testProject.csproj", "Project");
+            string result = RunnerUtilities.ExecMSBuild($" {project.Path} -getProperty:Foo", out bool success);
+            success.ShouldBeFalse();
+            result.ShouldContain("MSB4025");
+            result.ShouldNotContain("MSB1025");
+        }
+
         [Theory]
         [InlineData("-getProperty:Foo;Bar", true, "EvalValue", false, false, false, true, false)]
         [InlineData("-getProperty:Foo;Bar -t:Build", true, "TargetValue", false, false, false, true, false)]
@@ -697,6 +793,22 @@ public void ExecuteAppWithGetPropertyItemAndTargetResult(
             results.ShouldNotContain(ResourceUtilities.GetResourceString("BuildFailedWithPropertiesItemsOrTargetResultsRequested"));
         }
 
+        [Fact]
+        public void BuildFailsWithBadPropertyName()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            TransientTestFile project = env.CreateFile("testProject.csproj", @"
+<Project>
+  <Target Name=""Build"">
+  </Target>
+</Project>
+");
+            string results = RunnerUtilities.ExecMSBuild($" {project.Path} /p:someProperty:fdalse= ", out bool success);
+            success.ShouldBeFalse(results);
+
+            results.ShouldContain("error MSB4177");
+        }
+
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
@@ -2372,13 +2484,13 @@ public void MultipleTargetsDoesNotCrash()
         }
 
         [Theory]
-        [InlineData("-logger:,\"nonExistentlogger.dll\",IsOptional;Foo")]
-        [InlineData("-logger:ClassA,\"nonExistentlogger.dll\",IsOptional;Foo")]
-        [InlineData("-logger:,\"nonExistentlogger.dll\",IsOptional,OptionB,OptionC")]
-        [InlineData("-distributedlogger:,\"nonExistentlogger.dll\",IsOptional;Foo")]
-        [InlineData("-distributedlogger:ClassA,\"nonExistentlogger.dll\",IsOptional;Foo")]
-        [InlineData("-distributedlogger:,\"nonExistentlogger.dll\",IsOptional,OptionB,OptionC")]
-        public void MissingOptionalLoggersAreIgnored(string logger)
+        [InlineData("-logger:,\"nonExistentlogger.dll\",IsOptional;Foo", "nonExistentLogger.dll")]
+        [InlineData("-logger:ClassA,\"nonExistentlogger.dll\",IsOptional;Foo", "ClassA")]
+        [InlineData("-logger:,\"nonExistentlogger.dll\",IsOptional,OptionB,OptionC", "nonExistentLogger.dll")]
+        [InlineData("-distributedlogger:,\"nonExistentlogger.dll\",IsOptional;Foo", "nonExistentLogger.dll")]
+        [InlineData("-distributedlogger:ClassA,\"nonExistentlogger.dll\",IsOptional;Foo", "ClassA")]
+        [InlineData("-distributedlogger:,\"nonExistentlogger.dll\",IsOptional,OptionB,OptionC", "nonExistentLogger.dll")]
+        public void MissingOptionalLoggersAreIgnored(string logger, string expectedLoggerName)
         {
             string projectString =
                 "<Project>" +
@@ -2392,7 +2504,7 @@ public void MissingOptionalLoggersAreIgnored(string logger)
             var output = RunnerUtilities.ExecMSBuild(parametersLoggerOptional, out bool successfulExit, _output);
             successfulExit.ShouldBe(true);
             output.ShouldContain("Hello", customMessage: output);
-            output.ShouldContain("The specified logger could not be created and will not be used.", customMessage: output);
+            output.ShouldContain($"The specified logger \"{expectedLoggerName}\" could not be created and will not be used.", customMessage: output);
         }
 
         [Theory]
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 6ac15c07dec..3ae01e17f17 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -278,8 +278,8 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "question", "q" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "detailedsummary", "ds" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "getProperty" },                       ParameterizedSwitch.GetProperty,                null,                           true,           "MissingGetPropertyError",             true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "getItem" },                           ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",             true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "getTargetResult" },                   ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",             true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "getItem" },                           ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",                 true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "getTargetResult" },                   ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",         true,   false),
         };
 
         /// <summary>
@@ -301,7 +301,7 @@ internal static bool IsParameterlessSwitch(
             {
                 foreach (string parameterlessSwitchName in switchInfo.switchNames)
                 {
-                    if (String.Equals(switchName, parameterlessSwitchName, StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(switchName, parameterlessSwitchName, StringComparison.OrdinalIgnoreCase))
                     {
                         parameterlessSwitch = switchInfo.parameterlessSwitch;
                         duplicateSwitchErrorMessage = switchInfo.duplicateSwitchErrorMessage;
@@ -313,17 +313,6 @@ internal static bool IsParameterlessSwitch(
             return false;
         }
 
-        /// <summary>
-        /// Identifies/detects a switch that takes no parameters.
-        /// </summary>
-        internal static bool IsParameterlessSwitch(
-            string switchName)
-        {
-            ParameterlessSwitch parameterlessSwitch;
-            string duplicateSwitchErrorMessage;
-            return CommandLineSwitches.IsParameterlessSwitch(switchName, out parameterlessSwitch, out duplicateSwitchErrorMessage);
-        }
-
         /// <summary>
         /// Identifies/detects a switch that takes parameters.
         /// </summary>
@@ -354,7 +343,7 @@ internal static bool IsParameterizedSwitch(
             {
                 foreach (string parameterizedSwitchName in switchInfo.switchNames)
                 {
-                    if (String.Equals(switchName, parameterizedSwitchName, StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(switchName, parameterizedSwitchName, StringComparison.OrdinalIgnoreCase))
                     {
                         parameterizedSwitch = switchInfo.parameterizedSwitch;
                         duplicateSwitchErrorMessage = switchInfo.duplicateSwitchErrorMessage;
@@ -480,7 +469,7 @@ internal bool SetParameterizedSwitch(
             // check if the switch has multiple parameters
             if (multipleParametersAllowed)
             {
-                if (String.Empty.Equals(switchParameters) && emptyParametersAllowed)
+                if (string.Empty.Equals(switchParameters) && emptyParametersAllowed)
                 {
                     // Store a null parameter if its allowed
                     _parameterizedSwitches[(int)parameterizedSwitch].parameters.Add(null);
@@ -551,7 +540,7 @@ internal string GetEquivalentCommandLineExceptProjectFile()
             commandLineA.Sort(StringComparer.OrdinalIgnoreCase);
             commandLineB.Sort(StringComparer.OrdinalIgnoreCase);
 
-            return (String.Join(" ", commandLineA).Trim() + " " + String.Join(" ", commandLineB).Trim()).Trim();
+            return (string.Join(" ", commandLineA).Trim() + " " + string.Join(" ", commandLineB).Trim()).Trim();
         }
 
         /// <summary>
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 72b71371e3b..4f7383fa154 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -256,6 +256,7 @@
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Common.props" TargetFramework="%(_TargetFrameworks.Identity)" Subdirectory="Current\" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Common.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Common.tasks" TargetFramework="%(_TargetFrameworks.Identity)" />
+      <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Common.Test.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Managed.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Managed.Before.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Managed.After.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 98c41c4823c..0daf54d6adf 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -1398,10 +1398,11 @@
     <comment>{StrBegin="MSBUILD : error MSB1058: "}</comment>
   </data>
   <data name="OptionalLoggerCreationMessage" UESanitized="true" Visibility="Public">
-    <value>The specified logger could not be created and will not be used. {0}</value>
+    <value>The specified logger "{0}" could not be created and will not be used. {1}</value>
     <comment>
       UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: {0} contains the exception message explaining why the
+      LOCALIZATION: {0} contains the logger description passed on the command line or in a
+      response file. {1} contains the exception message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </comment>
   </data>
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 55929f8714c..2ed7d5da6bb 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -79,7 +79,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="new">({0:F1}s)</target>
+        <target state="translated">({0:F1} s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -1473,11 +1473,12 @@ Kdy se nastav na MessageUponIsolationViolation (nebo jeho krtk
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
-        <source>The specified logger could not be created and will not be used. {0}</source>
-        <target state="translated">Zadan protokolovac nstroj nebylo mon vytvoit a nebude se pouvat. {0}</target>
+        <source>The specified logger "{0}" could not be created and will not be used. {1}</source>
+        <target state="translated">Zadan protokolovac nstroj {0} nebylo mon vytvoit a nebude se pouvat. {1}</target>
         <note>
       UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: {0} contains the exception message explaining why the
+      LOCALIZATION: {0} contains the logger description passed on the command line or in a
+      response file. {1} contains the exception message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 226e0960175..d95a1823546 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -79,7 +79,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="new">({0:F1}s)</target>
+        <target state="translated">({0:F1}s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -1461,11 +1461,12 @@ Dieses Protokollierungsformat ist standardmig aktiviert.
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
-        <source>The specified logger could not be created and will not be used. {0}</source>
-        <target state="translated">Die angegebene Protokollierung konnte nicht erstellt werden und wird nicht verwendet. {0}</target>
+        <source>The specified logger "{0}" could not be created and will not be used. {1}</source>
+        <target state="translated">Die angegebene Protokollierung {0} konnte nicht erstellt werden und wird nicht verwendet. {1}</target>
         <note>
       UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: {0} contains the exception message explaining why the
+      LOCALIZATION: {0} contains the logger description passed on the command line or in a
+      response file. {1} contains the exception message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 1846d8646a1..7cd424ea80f 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -79,7 +79,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="new">({0:F1}s)</target>
+        <target state="translated">({0:F1}s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -1467,11 +1467,12 @@ Esta marca es experimental y puede que no funcione segn lo previsto.
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
-        <source>The specified logger could not be created and will not be used. {0}</source>
-        <target state="translated">No se pudo crear el registrador especificado y no se usar. {0}</target>
+        <source>The specified logger "{0}" could not be created and will not be used. {1}</source>
+        <target state="translated">No se pudo crear el registrador especificado por "{0}" y no se usar. {1}</target>
         <note>
       UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: {0} contains the exception message explaining why the
+      LOCALIZATION: {0} contains the logger description passed on the command line or in a
+      response file. {1} contains the exception message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index f4d88741a76..4439fa3e05a 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -79,7 +79,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="new">({0:F1}s)</target>
+        <target state="translated">({0:F1}s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -1460,11 +1460,12 @@ Remarque : verbosit des enregistreurs dvnements de fichiers
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
-        <source>The specified logger could not be created and will not be used. {0}</source>
-        <target state="translated">Le journaliseur spcifi n'a pas pu tre cr et ne sera pas utilis. {0}</target>
+        <source>The specified logger "{0}" could not be created and will not be used. {1}</source>
+        <target state="translated">Lenregistreur dvnements {0} spcifi na pas pu tre cr et ne sera pas utilis. {1}</target>
         <note>
       UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: {0} contains the exception message explaining why the
+      LOCALIZATION: {0} contains the logger description passed on the command line or in a
+      response file. {1} contains the exception message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 12e7aa2ac94..d549fbef333 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -79,7 +79,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="new">({0:F1}s)</target>
+        <target state="translated">({0:F1}s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -1471,11 +1471,12 @@ Nota: livello di dettaglio dei logger di file
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
-        <source>The specified logger could not be created and will not be used. {0}</source>
-        <target state="translated">Non  stato possibile creare il logger specificato, che quindi non verr usato. {0}</target>
+        <source>The specified logger "{0}" could not be created and will not be used. {1}</source>
+        <target state="translated">Non  stato possibile creare il logger specificato "{0}", che quindi non verr usato. {1}</target>
         <note>
       UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: {0} contains the exception message explaining why the
+      LOCALIZATION: {0} contains the logger description passed on the command line or in a
+      response file. {1} contains the exception message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index cd05368111a..bde74466fc0 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -79,7 +79,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="new">({0:F1}s)</target>
+        <target state="translated">({0:F1}s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -1460,11 +1460,12 @@
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
-        <source>The specified logger could not be created and will not be used. {0}</source>
-        <target state="translated">{0}</target>
+        <source>The specified logger "{0}" could not be created and will not be used. {1}</source>
+        <target state="translated"> "{0}" {1}</target>
         <note>
       UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: {0} contains the exception message explaining why the
+      LOCALIZATION: {0} contains the logger description passed on the command line or in a
+      response file. {1} contains the exception message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index dfa81b71e90..6b2e1b97d3c 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -79,7 +79,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="new">({0:F1}s)</target>
+        <target state="translated">({0:F1}s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -1460,11 +1460,12 @@
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
-        <source>The specified logger could not be created and will not be used. {0}</source>
-        <target state="translated">        . {0}</target>
+        <source>The specified logger "{0}" could not be created and will not be used. {1}</source>
+        <target state="translated">  "{0}"()      . {1}</target>
         <note>
       UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: {0} contains the exception message explaining why the
+      LOCALIZATION: {0} contains the logger description passed on the command line or in a
+      response file. {1} contains the exception message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 133760011df..38eafd9dbc1 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -79,7 +79,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="new">({0:F1}s)</target>
+        <target state="translated">({0:F1}s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -1471,11 +1471,12 @@ Ta flaga jest eksperymentalna i moe nie dziaa zgodnie z oczekiwaniami.
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
-        <source>The specified logger could not be created and will not be used. {0}</source>
-        <target state="translated">Nie mona utworzy okrelonego rejestratora i nie zostanie on uyty. {0}</target>
+        <source>The specified logger "{0}" could not be created and will not be used. {1}</source>
+        <target state="translated">Nie mona utworzy okrelonego rejestratora {0} i nie zostanie on uyty. {1}</target>
         <note>
       UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: {0} contains the exception message explaining why the
+      LOCALIZATION: {0} contains the logger description passed on the command line or in a
+      response file. {1} contains the exception message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 247e14490ef..9399e73a222 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -79,7 +79,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="new">({0:F1}s)</target>
+        <target state="translated">({0:F1}s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -1461,11 +1461,12 @@ arquivo de resposta.
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
-        <source>The specified logger could not be created and will not be used. {0}</source>
-        <target state="translated">No foi possvel criar o agente especificado e ele no ser usado. {0}</target>
+        <source>The specified logger "{0}" could not be created and will not be used. {1}</source>
+        <target state="translated">O agente especificado "{0}" no pde ser criado e no ser usado. {1}</target>
         <note>
       UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: {0} contains the exception message explaining why the
+      LOCALIZATION: {0} contains the logger description passed on the command line or in a
+      response file. {1} contains the exception message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 1d89ce20f45..09b513f67b4 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -79,7 +79,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="new">({0:F1}s)</target>
+        <target state="translated">({0:F1}s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -1459,11 +1459,12 @@
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
-        <source>The specified logger could not be created and will not be used. {0}</source>
-        <target state="translated">           . {0}</target>
+        <source>The specified logger "{0}" could not be created and will not be used. {1}</source>
+        <target state="translated">    "{0}"      . {1}</target>
         <note>
       UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: {0} contains the exception message explaining why the
+      LOCALIZATION: {0} contains the logger description passed on the command line or in a
+      response file. {1} contains the exception message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index d3fc5c7e9ed..37bd0d98a4f 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -79,7 +79,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="new">({0:F1}s)</target>
+        <target state="translated">({0:F1}s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -1464,11 +1464,12 @@
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
-        <source>The specified logger could not be created and will not be used. {0}</source>
-        <target state="translated">Belirtilen gnlk oluturulamadndan kullanlamyor. {0}</target>
+        <source>The specified logger "{0}" could not be created and will not be used. {1}</source>
+        <target state="translated">Belirtilen "{0}" gnlks oluturulamad ve kullanlmayacak. {1}</target>
         <note>
       UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: {0} contains the exception message explaining why the
+      LOCALIZATION: {0} contains the logger description passed on the command line or in a
+      response file. {1} contains the exception message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 12f6f98c04d..bb43d7a64f0 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -17,7 +17,7 @@
       </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
-        <target state="translated"> {1}  {0}</target>
+        <target state="translated"> {1}  {0}</target>
         <note>
       Overall build summary
       {0}: BuildResult_X (below)
@@ -79,7 +79,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="new">({0:F1}s)</target>
+        <target state="translated">({0:F1}s)</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -1460,11 +1460,12 @@
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
-        <source>The specified logger could not be created and will not be used. {0}</source>
-        <target state="translated">{0}</target>
+        <source>The specified logger "{0}" could not be created and will not be used. {1}</source>
+        <target state="translated">{0}{1}</target>
         <note>
       UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: {0} contains the exception message explaining why the
+      LOCALIZATION: {0} contains the logger description passed on the command line or in a
+      response file. {1} contains the exception message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </note>
       </trans-unit>
@@ -1562,14 +1563,14 @@
       </trans-unit>
       <trans-unit id="RestoreComplete">
         <source>Restore complete ({0}s)</source>
-        <target state="translated">({0})</target>
+        <target state="translated">({0} )</target>
         <note>
       {0}: duration in seconds with 1 decimal point
     </note>
       </trans-unit>
       <trans-unit id="RestoreCompleteWithMessage">
         <source>Restore {0} in {1}s</source>
-        <target state="translated"> {1}  {0}</target>
+        <target state="translated"> {1}  {0}</target>
         <note>
       Restore summary when finished with warning or error
       {0}: BuildResult_X (below)
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index b603ad790a6..64eb661fc18 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -79,7 +79,7 @@
       </trans-unit>
       <trans-unit id="DurationDisplay">
         <source>({0:F1}s)</source>
-        <target state="new">({0:F1}s)</target>
+        <target state="translated">({0:F1} )</target>
         <note>
         {0}: duration in seconds with 1 decimal point
       </note>
@@ -1460,11 +1460,12 @@
         <note>{StrBegin="MSBUILD : error MSB1062: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-warnnotaserror" and "-warnaserror" should not be localized.</note>
       </trans-unit>
       <trans-unit id="OptionalLoggerCreationMessage">
-        <source>The specified logger could not be created and will not be used. {0}</source>
-        <target state="translated">{0}</target>
+        <source>The specified logger "{0}" could not be created and will not be used. {1}</source>
+        <target state="translated"> "{0}"{1}</target>
         <note>
       UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: {0} contains the exception message explaining why the
+      LOCALIZATION: {0} contains the logger description passed on the command line or in a
+      response file. {1} contains the exception message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </note>
       </trans-unit>
diff --git a/src/MSBuild/TerminalLogger/NodeStatus.cs b/src/MSBuild/TerminalLogger/NodeStatus.cs
index c82a3d106d7..d199edc461c 100644
--- a/src/MSBuild/TerminalLogger/NodeStatus.cs
+++ b/src/MSBuild/TerminalLogger/NodeStatus.cs
@@ -14,9 +14,9 @@ internal class NodeStatus
     public string Project { get; }
     public string? TargetFramework { get; }
     public string Target { get; }
-    public Stopwatch Stopwatch { get; }
+    public StopwatchAbstraction Stopwatch { get; }
 
-    public NodeStatus(string project, string? targetFramework, string target, Stopwatch stopwatch)
+    public NodeStatus(string project, string? targetFramework, string target, StopwatchAbstraction stopwatch)
     {
         Project = project;
         TargetFramework = targetFramework;
@@ -35,7 +35,7 @@ obj is NodeStatus status &&
 
     public override string ToString()
     {
-        string duration = Stopwatch.Elapsed.TotalSeconds.ToString("F1");
+        string duration = Stopwatch.ElapsedSeconds.ToString("F1");
 
         return string.IsNullOrEmpty(TargetFramework)
             ? string.Format("{0}{1} {2} ({3}s)",
diff --git a/src/MSBuild/TerminalLogger/NodesFrame.cs b/src/MSBuild/TerminalLogger/NodesFrame.cs
index 144288950fa..33fbf2c8d42 100644
--- a/src/MSBuild/TerminalLogger/NodesFrame.cs
+++ b/src/MSBuild/TerminalLogger/NodesFrame.cs
@@ -16,7 +16,7 @@ internal sealed class NodesFrame
 {
     private const int MaxColumn = 120;
 
-    private readonly NodeStatus[] _nodes;
+    private readonly (NodeStatus nodeStatus, int durationLength)[] _nodes;
 
     private readonly StringBuilder _renderBuilder = new();
 
@@ -29,22 +29,26 @@ public NodesFrame(NodeStatus?[] nodes, int width, int height)
         Width = Math.Min(width, MaxColumn);
         Height = height;
 
-        _nodes = new NodeStatus[nodes.Length];
+        _nodes = new (NodeStatus, int)[nodes.Length];
 
         foreach (NodeStatus? status in nodes)
         {
             if (status is not null)
             {
-                _nodes[NodesCount++] = status;
+                _nodes[NodesCount++].nodeStatus = status;
             }
         }
     }
 
-    internal ReadOnlySpan<char> RenderNodeStatus(NodeStatus status)
+    internal ReadOnlySpan<char> RenderNodeStatus(int i)
     {
+        NodeStatus status = _nodes[i].nodeStatus;
+
         string durationString = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
             "DurationDisplay",
-            status.Stopwatch.Elapsed.TotalSeconds);
+            status.Stopwatch.ElapsedSeconds);
+
+        _nodes[i].durationLength = durationString.Length;
 
         string project = status.Project;
         string? targetFramework = status.TargetFramework;
@@ -91,15 +95,15 @@ public string Render(NodesFrame previousFrame)
         int i = 0;
         for (; i < NodesCount; i++)
         {
-            ReadOnlySpan<char> needed = RenderNodeStatus(_nodes[i]);
+            ReadOnlySpan<char> needed = RenderNodeStatus(i);
 
             // Do we have previous node string to compare with?
             if (previousFrame.NodesCount > i)
             {
                 if (previousFrame._nodes[i] == _nodes[i])
                 {
-                    // Same everything except time
-                    string durationString = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("DurationDisplay", _nodes[i].Stopwatch.Elapsed.TotalSeconds);
+                    // Same everything except time, AND same number of digits in time
+                    string durationString = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("DurationDisplay", _nodes[i].nodeStatus.Stopwatch.ElapsedSeconds);
                     sb.Append($"{AnsiCodes.SetCursorHorizontal(MaxColumn)}{AnsiCodes.MoveCursorBackward(durationString.Length)}{durationString}");
                 }
                 else
diff --git a/src/MSBuild/TerminalLogger/Project.cs b/src/MSBuild/TerminalLogger/Project.cs
index 5ed03039bcc..3f027249782 100644
--- a/src/MSBuild/TerminalLogger/Project.cs
+++ b/src/MSBuild/TerminalLogger/Project.cs
@@ -16,15 +16,25 @@ internal sealed class Project
     /// Initialized a new <see cref="Project"/> with the given <paramref name="targetFramework"/>.
     /// </summary>
     /// <param name="targetFramework">The target framework of the project or null if not multi-targeting.</param>
-    public Project(string? targetFramework)
+    public Project(string? targetFramework, StopwatchAbstraction? stopwatch)
     {
         TargetFramework = targetFramework;
+
+        if (stopwatch is not null)
+        {
+            stopwatch.Start();
+            Stopwatch = stopwatch;
+        }
+        else
+        {
+            Stopwatch = SystemStopwatch.StartNew();
+        }
     }
 
     /// <summary>
     /// A stopwatch to time the build of the project.
     /// </summary>
-    public Stopwatch Stopwatch { get; } = Stopwatch.StartNew();
+    public StopwatchAbstraction Stopwatch { get; }
 
     /// <summary>
     /// Full path to the primary output of the project, if known.
diff --git a/src/MSBuild/TerminalLogger/StopwatchAbstraction.cs b/src/MSBuild/TerminalLogger/StopwatchAbstraction.cs
new file mode 100644
index 00000000000..8b365517a6a
--- /dev/null
+++ b/src/MSBuild/TerminalLogger/StopwatchAbstraction.cs
@@ -0,0 +1,12 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging.TerminalLogger;
+
+internal abstract class StopwatchAbstraction
+{
+    public abstract void Start();
+    public abstract void Stop();
+
+    public abstract double ElapsedSeconds { get; }
+}
diff --git a/src/MSBuild/TerminalLogger/SystemStopwatch.cs b/src/MSBuild/TerminalLogger/SystemStopwatch.cs
new file mode 100644
index 00000000000..2f03092971c
--- /dev/null
+++ b/src/MSBuild/TerminalLogger/SystemStopwatch.cs
@@ -0,0 +1,24 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Diagnostics;
+
+namespace Microsoft.Build.Logging.TerminalLogger;
+
+internal sealed class SystemStopwatch : StopwatchAbstraction
+{
+    private Stopwatch _stopwatch = new ();
+
+    public override double ElapsedSeconds => _stopwatch.Elapsed.TotalSeconds;
+
+    public override void Start() => _stopwatch.Start();
+    public override void Stop() => _stopwatch.Stop();
+
+    public static StopwatchAbstraction StartNew()
+    {
+        SystemStopwatch wallClockStopwatch = new();
+        wallClockStopwatch.Start();
+
+        return wallClockStopwatch;
+    }
+}
diff --git a/src/MSBuild/TerminalLogger/TerminalLogger.cs b/src/MSBuild/TerminalLogger/TerminalLogger.cs
index 221d6e4e4fa..10048c7ac19 100644
--- a/src/MSBuild/TerminalLogger/TerminalLogger.cs
+++ b/src/MSBuild/TerminalLogger/TerminalLogger.cs
@@ -57,6 +57,8 @@ public ProjectContext(BuildEventContext context)
 
     internal const TerminalColor TargetFrameworkColor = TerminalColor.Cyan;
 
+    internal Func<StopwatchAbstraction>? CreateStopwatch = null;
+
     /// <summary>
     /// Protects access to state shared between the logger callbacks and the rendering thread.
     /// </summary>
@@ -136,6 +138,11 @@ public ProjectContext(BuildEventContext context)
     /// </summary>
     private bool _manualRefresh;
 
+    /// <summary>
+    /// True if we've logged the ".NET SDK is preview" message.
+    /// </summary>
+    private bool _loggedPreviewMessage;
+
     /// <summary>
     /// List of events the logger needs as parameters to the <see cref="ConfigurableForwardingLogger"/>.
     /// </summary>
@@ -318,7 +325,7 @@ private void ProjectStarted(object sender, ProjectStartedEventArgs e)
             {
                 targetFramework = null;
             }
-            _projects[c] = new(targetFramework);
+            _projects[c] = new(targetFramework, CreateStopwatch?.Invoke());
 
             // First ever restore in the build is starting.
             if (e.TargetNames == "Restore" && !_restoreFinished)
@@ -358,7 +365,7 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
                 {
                     EraseNodes();
 
-                    string duration = project.Stopwatch.Elapsed.TotalSeconds.ToString("F1");
+                    string duration = project.Stopwatch.ElapsedSeconds.ToString("F1");
                     ReadOnlyMemory<char>? outputPath = project.OutputPath;
 
                     string projectFile = e.ProjectFile is not null ?
@@ -568,6 +575,15 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)
             {
                 RenderImmediateMessage(message);
             }
+            else if (e.Code == "NETSDK1057" && !_loggedPreviewMessage)
+            {
+                // The SDK will log the high-pri "not-a-warning" message NETSDK1057
+                // when it's a preview version up to MaxCPUCount times, but that's
+                // an implementation detail--the user cares about at most one.
+
+                RenderImmediateMessage(message);
+                _loggedPreviewMessage = true;
+            }
         }
     }
 
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index d5b98d4906b..45332aa219e 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -211,9 +211,15 @@ private static void HandleConfigurationException(Exception ex)
         /// MSBuild no longer runs any arbitrary code (tasks or loggers) on the main thread, so it never needs the
         /// main thread to be in an STA. Accordingly, to avoid ambiguity, we explicitly use the [MTAThread] attribute.
         /// This doesn't actually do any work unless COM interop occurs for some reason.
+        /// We use the MultiDomainHost loader policy because we may create secondary AppDomains and need NGEN images
+        /// for Framework / GACed assemblies to be loaded domain neutral so their native images can be used.
+        /// See <see cref="NuGetFrameworkWrapper"/>.
         /// </remarks>
         /// <returns>0 on success, 1 on failure</returns>
         [MTAThread]
+#if FEATURE_APPDOMAIN
+        [LoaderOptimization(LoaderOptimization.MultiDomainHost)]
+#endif
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
         public static int Main(
 #if !FEATURE_GET_COMMANDLINE
@@ -809,11 +815,18 @@ public static ExitType Execute(
                     }
                     else if ((getProperty.Length > 0 || getItem.Length > 0) && (targets is null || targets.Length == 0))
                     {
-                        using (ProjectCollection collection = new(globalProperties, loggers, ToolsetDefinitionLocations.Default))
+                        try
+                        {
+                            using (ProjectCollection collection = new(globalProperties, loggers, ToolsetDefinitionLocations.Default))
+                            {
+                                Project project = collection.LoadProject(projectFile, globalProperties, toolsVersion);
+                                exitType = OutputPropertiesAfterEvaluation(getProperty, getItem, project);
+                                collection.LogBuildFinishedEvent(exitType == ExitType.Success);
+                            }
+                        }
+                        catch (InvalidProjectFileException)
                         {
-                            Project project = collection.LoadProject(projectFile, globalProperties, toolsVersion);
-                            exitType = OutputPropertiesAfterEvaluation(getProperty, getItem, project);
-                            collection.LogBuildFinishedEvent(exitType == ExitType.Success);
+                            exitType = ExitType.BuildError;
                         }
                     }
                     else // regular build
@@ -1031,28 +1044,20 @@ public static ExitType Execute(
 
         private static ExitType OutputPropertiesAfterEvaluation(string[] getProperty, string[] getItem, Project project)
         {
-            try
+            // Special case if the user requests exactly one property: skip json formatting
+            if (getProperty.Length == 1 && getItem.Length == 0)
             {
-                // Special case if the user requests exactly one property: skip json formatting
-                if (getProperty.Length == 1 && getItem.Length == 0)
-                {
-                    Console.WriteLine(project.GetPropertyValue(getProperty[0]));
-                }
-                else
-                {
-                    JsonOutputFormatter jsonOutputFormatter = new();
-                    jsonOutputFormatter.AddPropertiesInJsonFormat(getProperty, property => project.GetPropertyValue(property));
-                    jsonOutputFormatter.AddItemsInJsonFormat(getItem, project);
-                    Console.WriteLine(jsonOutputFormatter.ToString());
-                }
-
-                return ExitType.Success;
+                Console.WriteLine(project.GetPropertyValue(getProperty[0]));
             }
-            catch (InvalidProjectFileException e)
+            else
             {
-                Console.Error.WriteLine(e.Message);
-                return ExitType.BuildError;
+                JsonOutputFormatter jsonOutputFormatter = new();
+                jsonOutputFormatter.AddPropertiesInJsonFormat(getProperty, property => project.GetPropertyValue(property));
+                jsonOutputFormatter.AddItemsInJsonFormat(getItem, project);
+                Console.WriteLine(jsonOutputFormatter.ToString());
             }
+
+            return ExitType.Success;
         }
 
         private static ExitType OutputBuildInformationInJson(BuildResult result, string[] getProperty, string[] getItem, string[] getTargetResult, ILogger[] loggers, ExitType exitType)
@@ -4275,7 +4280,7 @@ private static bool CreateAndConfigureLogger(
             }
             catch (Exception e) when (loggerDescription.IsOptional)
             {
-                Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OptionalLoggerCreationMessage", e.Message));
+                Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OptionalLoggerCreationMessage", loggerDescription.Name, e.Message));
                 return false;
             }
 
@@ -4487,7 +4492,15 @@ private static void ShowHelpPrompt()
         /// </summary>
         private static void ShowVersion()
         {
-            Console.Write(ProjectCollection.Version.ToString());
+            // Change Version switch output to finish with a newline https://github.com/dotnet/msbuild/pull/9485
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))
+            {
+                Console.WriteLine(ProjectCollection.Version.ToString());
+            }
+            else
+            {
+                Console.Write(ProjectCollection.Version.ToString());
+            }
         }
     }
 }
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 1feab29307d..d21ec8b5294 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -68,8 +68,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\Microsoft.Bcl.AsyncInterfaces.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\Microsoft.Bcl.AsyncInterfaces.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -94,8 +94,8 @@
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\System.Collections.Immutable.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Collections.Immutable.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -109,18 +109,18 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\System.Reflection.Metadata.dll" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Reflection.Metadata.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.MetadataLoadContext" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\System.Reflection.MetadataLoadContext.dll" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Reflection.MetadataLoadContext.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\System.Resources.Extensions.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Resources.Extensions.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -129,23 +129,23 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\System.Text.Encodings.Web.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Text.Encodings.Web.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.3" newVersion="7.0.0.3" />
-          <codeBase version="7.0.0.3" href="..\System.Text.Json.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Text.Json.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Channels" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\System.Threading.Channels.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Threading.Channels.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
-          <codeBase version="7.0.0.0" href="..\System.Threading.Tasks.Dataflow.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <codeBase version="8.0.0.0" href="..\System.Threading.Tasks.Dataflow.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -184,6 +184,21 @@
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis.Sdk" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
           <codeBase version="17.0.0.0" href="..\..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
         </dependentAssembly>
+
+        <!-- Redirects for SDK resolver components -->
+        <qualifyAssembly partialName="Microsoft.DotNet.MSBuildSdkResolver" fullName="Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60" />
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.DotNet.MSBuildSdkResolver" culture="neutral" publicKeyToken="adb9793829ddae60" />
+          <codeBase version="8.0.100.0" href="..\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Microsoft.DotNet.MSBuildSdkResolver.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Deployment.DotNet.Releases" culture="neutral" publicKeyToken="31bf3856ad364e35" />
+          <codeBase version="2.0.0.0" href="..\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Microsoft.Deployment.DotNet.Releases.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Newtonsoft.Json" culture="neutral" publicKeyToken="30ad4fe6b2a6aeed" />
+          <codeBase version="13.0.0.0" href="..\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Newtonsoft.Json.dll" />
+        </dependentAssembly>
       </assemblyBinding>
     </runtime>
     <!-- To define one or more new toolsets, add an 'msbuildToolsets' element in this file. -->
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 51d2a26861e..a372f0c4760 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -41,7 +41,7 @@
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -58,7 +58,7 @@
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -70,15 +70,15 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.MetadataLoadContext" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -86,15 +86,15 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.3" newVersion="7.0.0.3" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -133,6 +133,21 @@
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis.Sdk" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
           <codeBase version="17.0.0.0" href="..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
         </dependentAssembly>
+
+        <!-- Redirects for SDK resolver components -->
+        <qualifyAssembly partialName="Microsoft.DotNet.MSBuildSdkResolver" fullName="Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60" />
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.DotNet.MSBuildSdkResolver" culture="neutral" publicKeyToken="adb9793829ddae60" />
+          <codeBase version="8.0.100.0" href=".\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Microsoft.DotNet.MSBuildSdkResolver.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Deployment.DotNet.Releases" culture="neutral" publicKeyToken="31bf3856ad364e35" />
+          <codeBase version="2.0.0.0" href=".\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Microsoft.Deployment.DotNet.Releases.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Newtonsoft.Json" culture="neutral" publicKeyToken="30ad4fe6b2a6aeed" />
+          <codeBase version="13.0.0.0" href=".\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Newtonsoft.Json.dll" />
+        </dependentAssembly>
       </assemblyBinding>
     </runtime>
     <!-- To define one or more new toolsets, add an 'msbuildToolsets' element in this file. -->
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 06d5e138401..211d1307c6f 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -64,6 +64,7 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.Common.overridetasks
   file source=$(X86BinPath)Microsoft.Common.targets
   file source=$(X86BinPath)Microsoft.Common.tasks
+  file source=$(X86BinPath)Microsoft.Common.Test.targets
   file source=$(X86BinPath)Microsoft.Managed.targets
   file source=$(X86BinPath)Microsoft.Managed.Before.targets
   file source=$(X86BinPath)Microsoft.Managed.After.targets
@@ -212,6 +213,7 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)Microsoft.Common.overridetasks
   file source=$(X86BinPath)Microsoft.Common.targets
   file source=$(X86BinPath)Microsoft.Common.tasks
+  file source=$(X86BinPath)Microsoft.Common.Test.targets
   file source=$(X86BinPath)Microsoft.Managed.targets
   file source=$(X86BinPath)Microsoft.Managed.Before.targets
   file source=$(X86BinPath)Microsoft.Managed.After.targets
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index b2f5106d38d..2f3dce9f66b 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -120,6 +120,7 @@ private static BuildEnvironment Initialize()
                 BuildEnvironmentMode.None,
                 msbuildExePath,
                 runningTests: s_runningTests(),
+                runningInMSBuildExe: false,
                 runningInVisualStudio: false,
                 visualStudioPath: null);
         }
@@ -153,6 +154,7 @@ private static BuildEnvironment TryFromVisualStudioProcess()
                 BuildEnvironmentMode.VisualStudio,
                 msBuildExe,
                 runningTests: false,
+                runningInMSBuildExe: false,
                 runningInVisualStudio: true,
                 visualStudioPath: vsRoot);
         }
@@ -173,6 +175,7 @@ private static BuildEnvironment TryFromMSBuildProcess()
                     BuildEnvironmentMode.VisualStudio,
                     msBuildExe,
                     runningTests: false,
+                    runningInMSBuildExe: true,
                     runningInVisualStudio: false,
                     visualStudioPath: GetVsRootFromMSBuildAssembly(msBuildExe));
             }
@@ -182,6 +185,7 @@ private static BuildEnvironment TryFromMSBuildProcess()
                 BuildEnvironmentMode.Standalone,
                 msBuildExe,
                 runningTests: false,
+                runningInMSBuildExe: true,
                 runningInVisualStudio: false,
                 visualStudioPath: null);
         }
@@ -223,6 +227,7 @@ private static BuildEnvironment TryFromMSBuildAssembly()
                     BuildEnvironmentMode.Standalone,
                     msBuildPath,
                     runningTests: s_runningTests(),
+                    runningInMSBuildExe: false,
                     runningInVisualStudio: false,
                     visualStudioPath: null);
             }
@@ -244,6 +249,7 @@ private static BuildEnvironment TryFromMSBuildExeUnderVisualStudio(string msbuil
                         BuildEnvironmentMode.VisualStudio,
                         GetMSBuildExeFromVsRoot(visualStudioRoot),
                         runningTests: s_runningTests(),
+                        runningInMSBuildExe: false,
                         runningInVisualStudio: false,
                         visualStudioPath: visualStudioRoot);
             }
@@ -274,6 +280,7 @@ private static BuildEnvironment TryFromDevConsole()
                 BuildEnvironmentMode.VisualStudio,
                 GetMSBuildExeFromVsRoot(vsInstallDir),
                 runningTests: false,
+                runningInMSBuildExe: false,
                 runningInVisualStudio: false,
                 visualStudioPath: vsInstallDir);
         }
@@ -306,6 +313,7 @@ private static BuildEnvironment TryFromSetupApi()
                 BuildEnvironmentMode.VisualStudio,
                 GetMSBuildExeFromVsRoot(instances[0].Path),
                 runningTests: false,
+                runningInMSBuildExe: false,
                 runningInVisualStudio: false,
                 visualStudioPath: instances[0].Path);
         }
@@ -338,6 +346,7 @@ private static BuildEnvironment TryFromStandaloneMSBuildExe(string msBuildExePat
                     BuildEnvironmentMode.Standalone,
                     msBuildExePath,
                     runningTests: s_runningTests(),
+                    runningInMSBuildExe: false,
                     runningInVisualStudio: false,
                     visualStudioPath: null);
             }
@@ -527,13 +536,15 @@ internal enum BuildEnvironmentMode
     /// </summary>
     internal sealed class BuildEnvironment
     {
-        public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath, bool runningTests, bool runningInVisualStudio, string visualStudioPath)
+        public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath, bool runningTests, bool runningInMSBuildExe, bool runningInVisualStudio,
+                string visualStudioPath)
         {
             FileInfo currentMSBuildExeFile = null;
             DirectoryInfo currentToolsDirectory = null;
 
             Mode = mode;
             RunningTests = runningTests;
+            RunningInMSBuildExe = runningInMSBuildExe;
             RunningInVisualStudio = runningInVisualStudio;
             CurrentMSBuildExePath = currentMSBuildExePath;
             VisualStudioInstallRootDirectory = visualStudioPath;
@@ -620,6 +631,11 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA
         /// </summary>
         internal bool RunningTests { get; }
 
+        /// <summary>
+        /// Returns true when the entry point application is MSBuild.exe.
+        /// </summary>
+        internal bool RunningInMSBuildExe { get; }
+
         /// <summary>
         /// Returns true when the entry point application is Visual Studio.
         /// </summary>
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 58a982de12e..9bbd30e09c8 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -601,6 +601,32 @@ internal static void ThrowObjectDisposed(string objectName)
         {
             throw new ObjectDisposedException(objectName);
         }
+
+        /// <summary>
+        /// A utility that verifies the parameters provided to a standard ICollection<typeparamref name="T"/>.CopyTo call.
+        /// </summary>
+        /// <exception cref="ArgumentNullException">If <paramref name="array"/> is null.</exception>
+        /// <exception cref="ArgumentOutOfRangeException">If <paramref name="arrayIndex"/> falls outside of the bounds <paramref name="array"/>.</exception>
+        /// <exception cref="ArgumentException">If there is insufficient capacity to copy the collection contents into <paramref name="array"/>
+        /// when starting at <paramref name="arrayIndex"/>.</exception>
+        internal static void VerifyCollectionCopyToArguments<T>(
+            T[] array,
+            string arrayParameterName,
+            int arrayIndex,
+            string arrayIndexParameterName,
+            int requiredCapacity)
+        {
+            VerifyThrowArgumentNull(array, arrayParameterName);
+            VerifyThrowArgumentOutOfRange(arrayIndex >= 0 && arrayIndex < array.Length, arrayIndexParameterName);
+
+            int arrayCapacity = array.Length - arrayIndex;
+            if (requiredCapacity > arrayCapacity)
+            {
+                throw new ArgumentException(
+                    ResourceUtilities.GetResourceString("Shared.CollectionCopyToFailureProvidedArrayIsTooSmall"),
+                    arrayParameterName);
+            }
+        }
 #endif
     }
 }
diff --git a/src/Shared/Resources/Strings.shared.resx b/src/Shared/Resources/Strings.shared.resx
index 9fb94751e2f..fc738f26816 100644
--- a/src/Shared/Resources/Strings.shared.resx
+++ b/src/Shared/Resources/Strings.shared.resx
@@ -1,20 +1,96 @@
 <?xml version="1.0" encoding="utf-8"?>
 <root>
+  <!-- 
+    Microsoft ResX Schema 
+    
+    Version 2.0
+    
+    The primary goals of this format is to allow a simple XML format 
+    that is mostly human readable. The generation and parsing of the 
+    various data types are done through the TypeConverter classes 
+    associated with the data types.
+    
+    Example:
+    
+    ... ado.net/XML headers & schema ...
+    <resheader name="resmimetype">text/microsoft-resx</resheader>
+    <resheader name="version">2.0</resheader>
+    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
+    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
+    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
+    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
+    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
+        <value>[base64 mime encoded serialized .NET Framework object]</value>
+    </data>
+    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
+        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
+        <comment>This is a comment</comment>
+    </data>
+                
+    There are any number of "resheader" rows that contain simple 
+    name/value pairs.
+    
+    Each data row contains a name, and value. The row also contains a 
+    type or mimetype. Type corresponds to a .NET class that support 
+    text/value conversion through the TypeConverter architecture. 
+    Classes that don't support this are serialized and stored with the 
+    mimetype set.
+    
+    The mimetype is used for serialized objects, and tells the 
+    ResXResourceReader how to depersist the object. This is currently not 
+    extensible. For a given mimetype the value must be set accordingly:
+    
+    Note - application/x-microsoft.net.object.binary.base64 is the format 
+    that the ResXResourceWriter will generate, however the reader can 
+    read any of the formats listed below.
+    
+    mimetype: application/x-microsoft.net.object.binary.base64
+    value   : The object must be serialized with 
+            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
+            : and then encoded with base64 encoding.
+    
+    mimetype: application/x-microsoft.net.object.soap.base64
+    value   : The object must be serialized with 
+            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
+            : and then encoded with base64 encoding.
+
+    mimetype: application/x-microsoft.net.object.bytearray.base64
+    value   : The object must be serialized into a byte array 
+            : using a System.ComponentModel.TypeConverter
+            : and then encoded with base64 encoding.
+    -->
   <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
+    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
     <xsd:element name="root" msdata:IsDataSet="true">
       <xsd:complexType>
         <xsd:choice maxOccurs="unbounded">
+          <xsd:element name="metadata">
+            <xsd:complexType>
+              <xsd:sequence>
+                <xsd:element name="value" type="xsd:string" minOccurs="0" />
+              </xsd:sequence>
+              <xsd:attribute name="name" use="required" type="xsd:string" />
+              <xsd:attribute name="type" type="xsd:string" />
+              <xsd:attribute name="mimetype" type="xsd:string" />
+              <xsd:attribute ref="xml:space" />
+            </xsd:complexType>
+          </xsd:element>
+          <xsd:element name="assembly">
+            <xsd:complexType>
+              <xsd:attribute name="alias" type="xsd:string" />
+              <xsd:attribute name="name" type="xsd:string" />
+            </xsd:complexType>
+          </xsd:element>
           <xsd:element name="data">
             <xsd:complexType>
               <xsd:sequence>
                 <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                 <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
               </xsd:sequence>
-              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
-              <xsd:attribute name="UESanitized" type="xsd:boolean" msdata:Ordinal="3" />
-              <xsd:attribute name="Visibility" type="Visibility_Type" msdata:Ordinal="4" />
-              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="5" />
-              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="6" />
+              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
+              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
+              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
+              <xsd:attribute ref="xml:space" />
             </xsd:complexType>
           </xsd:element>
           <xsd:element name="resheader">
@@ -28,130 +104,123 @@
         </xsd:choice>
       </xsd:complexType>
     </xsd:element>
-    <xsd:simpleType name="Visibility_Type">
-      <xsd:restriction base="xsd:string">
-        <xsd:enumeration value="Public" />
-        <xsd:enumeration value="Obsolete" />
-        <xsd:enumeration value="Private_OM" />
-      </xsd:restriction>
-    </xsd:simpleType>
   </xsd:schema>
   <resheader name="resmimetype">
     <value>text/microsoft-resx</value>
   </resheader>
   <resheader name="version">
-    <value>1.3</value>
+    <value>2.0</value>
   </resheader>
   <resheader name="reader">
-    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.3500.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
   </resheader>
   <resheader name="writer">
-    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.3500.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
+    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
   </resheader>
-  <data name="BuildAborted" Visibility="Public">
+  <data name="BuildAborted" xml:space="preserve">
     <value>MSB4188: Build was canceled.</value>
     <comment>{StrBegin="MSB4188: "} Error when the build stops suddenly for some reason. For example, because a child node died.</comment>
   </data>
-  <data name="BuildEngineCallbacksInTaskHostUnsupported" Visibility="Public">
+  <data name="BuildEngineCallbacksInTaskHostUnsupported" xml:space="preserve">
     <value>MSB5022: The MSBuild task host does not support running tasks that perform IBuildEngine callbacks. If you wish to perform these operations, please run your task in the core MSBuild process instead.  A task will automatically execute in the task host if the UsingTask has been attributed with a "Runtime" or "Architecture" value, or the task invocation has been attributed with an "MSBuildRuntime" or "MSBuildArchitecture" value, that does not match the current runtime or architecture of MSBuild.</value>
     <comment>{StrBegin="MSB5022: "} "Runtime", "Architecture", "MSBuildRuntime", and "MSBuildArchitecture" are all attributes in the project file, and thus should not be localized.</comment>
   </data>
-  <data name="BuildStarted" UESanitized="false" Visibility="Public">
+  <data name="BuildStarted" xml:space="preserve">
     <value>Build started.</value>
   </data>
-  <data name="ConflictingTaskAssembly" Visibility="Public">
+  <data name="ConflictingTaskAssembly" xml:space="preserve">
     <value>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</value>
     <comment>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</comment>
   </data>
-  <data name="ExpectedEventToBeSerializable" Visibility="Public">
+  <data name="ExpectedEventToBeSerializable" xml:space="preserve">
     <value>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</value>
   </data>
-  <data name="DeprecatedEventSerialization" Visibility="Public">
+  <data name="DeprecatedEventSerialization" xml:space="preserve">
     <value>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</value>
   </data>
-  <data name="FileLocation" Visibility="Public">
+  <data name="FileLocation" xml:space="preserve">
     <value>{0} ({1},{2})</value>
     <comment>A file location to be embedded in a string.</comment>
   </data>
-  <data name="ModifyingTaskHostEnvironmentHeader" Visibility="Public">
+  <data name="ModifyingTaskHostEnvironmentHeader" xml:space="preserve">
     <value>Making the following modifications to the environment received from the parent node before applying it to the task host:</value>
     <comment>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</comment>
   </data>
-  <data name="ModifyingTaskHostEnvironmentVariable" Visibility="Public">
+  <data name="ModifyingTaskHostEnvironmentVariable" xml:space="preserve">
     <value>  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</value>
     <comment>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</comment>
   </data>
-  <data name="InvalidProjectFile" Visibility="Public">
+  <data name="InvalidProjectFile" xml:space="preserve">
     <value>MSB4025: The project file could not be loaded. {0}</value>
     <comment>{StrBegin="MSB4025: "}UE: This message is shown when the project file given to the engine cannot be loaded because the filename/path is
     invalid, or due to lack of permissions, or incorrect XML. The project filename is not part of the message because it is
     provided separately to loggers.
     LOCALIZATION: {0} is a localized message from the CLR/FX explaining why the project is invalid.</comment>
   </data>
-  <data name="InvalidVerbosity" Visibility="Public">
+  <data name="InvalidVerbosity" xml:space="preserve">
     <value>MSB4103: "{0}" is not a valid logger verbosity level.</value>
     <comment>{StrBegin="MSB4103: "}</comment>
   </data>
-  <data name="InvalidLogFileFormat" Visibility="Public">
+  <data name="InvalidLogFileFormat" xml:space="preserve">
     <value>MSB4233: There was an exception while reading the log file: {0}</value>
     <comment>{StrBegin="MSB4233: "}This is shown when the Binary Logger can't read the log file.</comment>
   </data>
-  <data name="MissingProject" Visibility="Private_OM">
+  <data name="MissingProject" xml:space="preserve">
     <value>MSBuild is expecting a valid "{0}" object.</value>
   </data>
-  <data name="UnrecognizedToolsVersion" Visibility="Public">
+  <data name="UnrecognizedToolsVersion" xml:space="preserve">
     <value>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</value>
     <comment>{StrBegin="MSB4132: "}LOCALIZATION: {1} contains a comma separated list.</comment>
   </data>
-  <data name="NameInvalid" Visibility="Public">
+  <data name="NameInvalid" xml:space="preserve">
     <value>MSB5016: The name "{0}" contains an invalid character "{1}".</value>
     <comment>{StrBegin="MSB5016: "}</comment>
   </data>
-  <data name="Shared.CannotChangeItemSpecModifiers" Visibility="Private_OM">
+  <data name="Shared.CannotChangeItemSpecModifiers" xml:space="preserve">
     <value>"{0}" is a reserved item metadata, and cannot be modified or deleted.</value>
     <comment>UE: Tasks and OM users are not allowed to remove or change the value of the built-in metadata on items e.g. the meta-data "FullPath", "RelativeDir", etc. are reserved.</comment>
   </data>
-  <data name="Shared.CannotConvertStringToBool" Visibility="Public">
+  <data name="Shared.CannotConvertStringToBool" xml:space="preserve">
     <value>The string "{0}" cannot be converted to a boolean (true/false) value.</value>
   </data>
-  <data name="Shared.FailedCreatingTempFile" Visibility="Public">
+  <data name="Shared.FailedCreatingTempFile" xml:space="preserve">
     <value>MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0}</value>
     <comment>{StrBegin="MSB5003: "}</comment>
   </data>
-  <data name="Shared.FailedDeletingTempFile" Visibility="Public">
+  <data name="Shared.FailedDeletingTempFile" xml:space="preserve">
     <value>MSB5018: Failed to delete the temporary file "{0}". {1}</value>
     <comment>{StrBegin="MSB5018: "}</comment>
   </data>
-  <data name="Shared.InvalidFilespecForTransform" Visibility="Public">
+  <data name="Shared.InvalidFilespecForTransform" xml:space="preserve">
     <value>The item metadata "%({0})" cannot be applied to the path "{1}". {2}</value>
     <comment>UE: This message is shown when the user tries to perform path manipulations using one of the built-in item metadata e.g. %(RootDir), on an item-spec that's not a valid path. LOCALIZATION: "{2}" is a localized message from a CLR/FX exception.</comment>
   </data>
-  <data name="TaskNotMarshalByRef" Visibility="Public">
+  <data name="TaskNotMarshalByRef" xml:space="preserve">
     <value>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</value>
     <comment>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</comment>
   </data>
-  <data name="FrameworkLocationHelper.UnsupportedFrameworkVersion" Visibility="Private_OM">
+  <data name="FrameworkLocationHelper.UnsupportedFrameworkVersion" xml:space="preserve">
     <value>.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</value>
   </data>
-  <data name="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk" Visibility="Private_OM">
+  <data name="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk" xml:space="preserve">
     <value>.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</value>
   </data>
-  <data name="FrameworkLocationHelper.UnsupportedVisualStudioVersion" Visibility="Private_OM">
+  <data name="FrameworkLocationHelper.UnsupportedVisualStudioVersion" xml:space="preserve">
     <value>Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</value>
   </data>
-  <data name="FrameworkLocationHelper.CouldNotGenerateReferenceAssemblyDirectory">
+  <data name="FrameworkLocationHelper.CouldNotGenerateReferenceAssemblyDirectory" xml:space="preserve">
     <value>When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</value>
     <comment>No Error code because this resource will be used in an exception. The error code is discarded if it is included</comment>
   </data>
-  <data name="DirectoryNotFound" Visibility="Public">
+  <data name="DirectoryNotFound" xml:space="preserve">
     <value>Could not find directory path: {0}</value>
     <comment>Directory must exist</comment>
   </data>
-  <data name="UnauthorizedAccess" Visibility="Public">
+  <data name="UnauthorizedAccess" xml:space="preserve">
     <value>You do not have access to: {0}</value>
     <comment>Directory must have access</comment>
   </data>
-  <data name="SubCategoryForSchemaValidationErrors" Visibility="Public">
+  <data name="SubCategoryForSchemaValidationErrors" xml:space="preserve">
     <value>Schema validation</value>
     <comment>
       UE: this fragment is used to describe errors that are caused by schema validation. For example, if a normal error is
@@ -160,124 +229,123 @@
       LOCALIZATION: This fragment needs to be localized.
     </comment>
   </data>
-  <data name="Shared.KillingProcess">
+  <data name="Shared.KillingProcess" xml:space="preserve">
     <value>MSB5002: Terminating the task executable "{0}" because it did not finish within the specified limit of {1} milliseconds.</value>
     <comment>{StrBegin="MSB5002: "}</comment>
   </data>
-  <data name="Shared.ParameterCannotBeNull" Visibility="Public">
+  <data name="Shared.ParameterCannotBeNull" xml:space="preserve">
     <value>Parameter "{0}" cannot be null.</value>
   </data>
-  <data name="Shared.ParameterCannotHaveInvalidPathChars" Visibility="Public">
+  <data name="Shared.ParameterCannotHaveInvalidPathChars" xml:space="preserve">
     <value>Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</value>
   </data>
-  <data name="Shared.ParameterCannotHaveZeroLength" Visibility="Public">
+  <data name="Shared.ParameterCannotHaveZeroLength" xml:space="preserve">
     <value>Parameter "{0}" cannot have zero length.</value>
   </data>
-  <data name="Shared.ParametersMustHaveTheSameLength" Visibility="Public">
+  <data name="Shared.ParametersMustHaveTheSameLength" xml:space="preserve">
     <value>Parameters "{0}" and "{1}" must have the same number of elements.</value>
   </data>
-  <data name="Shared.TaskResourceNotFound" Visibility="Private_OM">
+  <data name="Shared.TaskResourceNotFound" xml:space="preserve">
     <value>The resource string "{0}" for the "{1}" task cannot be found. Confirm that the resource name "{0}" is correctly spelled, and the resource exists in the task's assembly.</value>
   </data>
-  <data name="Shared.TaskResourcesNotRegistered" Visibility="Private_OM">
+  <data name="Shared.TaskResourcesNotRegistered" xml:space="preserve">
     <value>The "{0}" task has not registered its resources. In order to use the "TaskLoggingHelper.FormatResourceString()" method this task needs to register its resources either during construction, or via the "TaskResources" property.</value>
     <comment>LOCALIZATION: "TaskLoggingHelper.FormatResourceString()" and "TaskResources" should not be localized.</comment>
   </data>
-  <data name="SolutionParseDuplicateProject" Visibility="Public">
+  <data name="SolutionParseDuplicateProject" xml:space="preserve">
     <value>MSB5004: The solution file has two projects named "{0}".</value>
     <comment>{StrBegin="MSB5004: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseInvalidProjectFileNameCharacters" Visibility="Public">
+  <data name="SolutionParseInvalidProjectFileNameCharacters" xml:space="preserve">
     <value>MSB5005: Error parsing project section for project "{0}". The project file name "{1}" contains invalid characters.</value>
     <comment>{StrBegin="MSB5005: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseInvalidProjectFileNameEmpty" Visibility="Public">
+  <data name="SolutionParseInvalidProjectFileNameEmpty" xml:space="preserve">
     <value>MSB5006: Error parsing project section for project "{0}". The project file name is empty.</value>
     <comment>{StrBegin="MSB5006: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseInvalidProjectSolutionConfigurationEntry" Visibility="Public">
+  <data name="SolutionParseInvalidProjectSolutionConfigurationEntry" xml:space="preserve">
     <value>MSB5007: Error parsing the project configuration section in solution file. The entry "{0}" is invalid.</value>
     <comment>{StrBegin="MSB5007: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseInvalidSolutionConfigurationEntry" Visibility="Public">
+  <data name="SolutionParseInvalidSolutionConfigurationEntry" xml:space="preserve">
     <value>MSB5008: Error parsing the solution configuration section in solution file. The entry "{0}" is invalid.</value>
     <comment>{StrBegin="MSB5008: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseNestedProjectErrorWithNameAndGuid" Visibility="Public">
+  <data name="SolutionParseNestedProjectErrorWithNameAndGuid" xml:space="preserve">
     <value>MSB5009: Error parsing the project "{0}" section with GUID: "{1}". It is nested under "{2}" but that project is not found in the solution.</value>
     <comment>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseNestedProjectError" Visibility="Public">
+  <data name="SolutionParseNestedProjectError" xml:space="preserve">
     <value>MSB5009: Error parsing the nested project section in solution file.</value>
     <comment>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseNestedProjectUndefinedError" Visibility="Public">
+  <data name="SolutionParseNestedProjectUndefinedError" xml:space="preserve">
     <value>MSB5023: Error parsing the nested project section in solution file. A project with the GUID "{0}" is listed as being nested under project "{1}", but does not exist in the solution.</value>
     <comment>{StrBegin="MSB5023: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseNoHeaderError" Visibility="Public">
+  <data name="SolutionParseNoHeaderError" xml:space="preserve">
     <value>MSB5010: No file format header found.</value>
     <comment>{StrBegin="MSB5010: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseProjectDepGuidError" Visibility="Public">
+  <data name="SolutionParseProjectDepGuidError" xml:space="preserve">
     <value>MSB5011: Parent project GUID not found in "{0}" project dependency section.</value>
     <comment>{StrBegin="MSB5011: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseProjectEofError" Visibility="Public">
+  <data name="SolutionParseProjectEofError" xml:space="preserve">
     <value>MSB5012: Unexpected end-of-file reached inside "{0}" project section.</value>
     <comment>{StrBegin="MSB5012: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseProjectError" Visibility="Public">
+  <data name="SolutionParseProjectError" xml:space="preserve">
     <value>MSB5013: Error parsing a project section.</value>
     <comment>{StrBegin="MSB5013: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseVersionMismatchError" Visibility="Public">
+  <data name="SolutionParseVersionMismatchError" xml:space="preserve">
     <value>MSB5014: File format version is not recognized.  MSBuild can only read solution files between versions {0}.0 and {1}.0, inclusive.</value>
     <comment>{StrBegin="MSB5014: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseWebProjectPropertiesError" Visibility="Public">
+  <data name="SolutionParseWebProjectPropertiesError" xml:space="preserve">
     <value>MSB5015: The properties could not be read from the WebsiteProperties section of the "{0}" project.</value>
     <comment>{StrBegin="MSB5015: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="UnrecognizedSolutionComment" Visibility="Public">
+  <data name="UnrecognizedSolutionComment" xml:space="preserve">
     <value>Unrecognized solution version "{0}", attempting to continue.</value>
   </data>
-  <data name="SubCategoryForSolutionParsingErrors" Visibility="Public">
+  <data name="SubCategoryForSolutionParsingErrors" xml:space="preserve">
     <value>Solution file</value>
     <comment>UE: this fragment is used to describe errors found while parsing solution files. For example, if a normal error is
       displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from solution parsing would look like this:
       "MSBUILD : Solution file error MSB0000: This is an error."
       LOCALIZATION: This fragment needs to be localized.</comment>
   </data>
-  <data name="Shared.InvalidProjectFile" Visibility="Public">
+  <data name="Shared.InvalidProjectFile" xml:space="preserve">
     <value>MSB5019: The project file is malformed: "{0}". {1}</value>
     <comment>{StrBegin="MSB5019: "}</comment>
   </data>
-  <data name="Shared.ProjectFileCouldNotBeLoaded" Visibility="Public">
+  <data name="Shared.ProjectFileCouldNotBeLoaded" xml:space="preserve">
     <value>MSB5020: Could not load the project file: "{0}". {1}</value>
     <comment>{StrBegin="MSB5020: "}</comment>
   </data>
-  <data name="Shared.KillingProcessByCancellation">
+  <data name="Shared.KillingProcessByCancellation" xml:space="preserve">
     <value>MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</value>
     <comment>{StrBegin="MSB5021: "}</comment>
   </data>
-  <data name="Shared.CanNotFindValidMSBuildLocation">
+  <data name="Shared.CanNotFindValidMSBuildLocation" xml:space="preserve">
     <value>MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</value>
     <comment>{StrBegin="MSB5024: "}</comment>
   </data>
-  <data name="Shared.PathTooLong">
+  <data name="Shared.PathTooLong" xml:space="preserve">
     <value>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</value>
-    <comment></comment>
   </data>
-  <data name="SolutionFilterJsonParsingError" Visibility="Public">
+  <data name="SolutionFilterJsonParsingError" xml:space="preserve">
     <value>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</value>
     <comment>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionFilterMissingSolutionError" Visibility="Public">
+  <data name="SolutionFilterMissingSolutionError" xml:space="preserve">
     <value>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</value>
     <comment>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionFilterFilterContainsProjectNotInSolution" Visibility="Public">
+  <data name="SolutionFilterFilterContainsProjectNotInSolution" xml:space="preserve">
     <value>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</value>
     <comment>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</comment>
   </data>
@@ -286,29 +354,14 @@
     <comment>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
       attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</comment>
   </data>
-  <data name="LoggingBeforeTaskInitialization" UESanitized="false" Visibility="Public">
+  <data name="LoggingBeforeTaskInitialization" xml:space="preserve">
     <value>MSB6005: Task attempted to log before it was initialized. Message was: {0}</value>
     <comment>{StrBegin="MSB6005: "}UE: This occurs if the task attempts to log something in its own constructor.</comment>
   </data>
-  <!--
-        The shared message bucket is: MSB5001 - MSB5999
-
-        Next message code should be MSB5030
-
-        Some unused codes which can also be reused (because their messages were deleted, and UE hasn't indexed the codes yet):
-            <none>
-
-        Retired codes which have shipped so cannot be reused
-            MSB5017
-
-        Don't forget to update this comment after using a new code.
-  -->
-  <!-- #################################################################################################-->
-  <!-- ############################## Collection-related strings #######################################-->
-  <!-- #################################################################################################-->
-  <!-- The OM_ prefix indicates at the point of use that there is no error code in the message;
-       these should not be used in an InvalidProjectFileException -->
-  <data name="OM_NotSupportedReadOnlyCollection">
+  <data name="OM_NotSupportedReadOnlyCollection" xml:space="preserve">
     <value>This collection is read-only.</value>
   </data>
-</root>
+  <data name="CollectionCopyToFailureProvidedArrayIsTooSmall" xml:space="preserve">
+    <value>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</value>
+  </data>
+</root>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index cdffb07fb6f..1edd7bcb179 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -17,6 +17,11 @@
         <target state="translated">Vytven sestaven bylo zahjeno.</target>
         <note />
       </trans-unit>
+      <trans-unit id="CollectionCopyToFailureProvidedArrayIsTooSmall">
+        <source>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</source>
+        <target state="translated">Poet element v kolekci je vt ne dostupn msto v clovm poli (pi sputn na zadanm indexu).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
         <target state="translated">MSB4008: Bylo nalezeno konfliktn sestaven pro sestaven lohy {0} v umstn {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index 9faa13d7602..ee1ab288105 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -17,6 +17,11 @@
         <target state="translated">Der Buildvorgang wurde gestartet.</target>
         <note />
       </trans-unit>
+      <trans-unit id="CollectionCopyToFailureProvidedArrayIsTooSmall">
+        <source>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</source>
+        <target state="translated">Die Anzahl der Elemente in der Auflistung ist grer als der verfgbare Speicherplatz im Zielarray (wenn am angegebenen Index begonnen wird).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
         <target state="translated">MSB4008: Eine mit der Aufgabenassembly "{0}" in Konflikt stehende Assembly wurde in "{1}" gefunden.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index dc91f2bd810..95cf2fbc390 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -17,6 +17,11 @@
         <target state="translated">Compilacin iniciada.</target>
         <note />
       </trans-unit>
+      <trans-unit id="CollectionCopyToFailureProvidedArrayIsTooSmall">
+        <source>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</source>
+        <target state="translated">El nmero de elementos de la coleccin es mayor que el espacio disponible en la matriz de destino (a partir del ndice especificado).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
         <target state="translated">MSB4008: Se detect un ensamblado conflictivo para el ensamblado de tarea "{0}" en "{1}".</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index c812aa833db..c498cd0cd39 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -17,6 +17,11 @@
         <target state="translated">La gnration a dmarr.</target>
         <note />
       </trans-unit>
+      <trans-unit id="CollectionCopyToFailureProvidedArrayIsTooSmall">
+        <source>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</source>
+        <target state="translated">Le nombre dlments de la collection est suprieur  lespace disponible dans le tableau de destination (lors du dmarrage  lindex spcifi).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
         <target state="translated">MSB4008: un assembly en conflit avec l'assembly de tche "{0}" a t trouv sur "{1}".</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index 2ed5a530e64..a3c710638c9 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -17,6 +17,11 @@
         <target state="translated">Compilazione avviata.</target>
         <note />
       </trans-unit>
+      <trans-unit id="CollectionCopyToFailureProvidedArrayIsTooSmall">
+        <source>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</source>
+        <target state="translated">Il numero di elementi nella raccolta  maggiore dello spazio disponibile nella matrice di destinazione (a partire dall'indice specificato).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
         <target state="translated">MSB4008: rilevato un assembly in conflitto per l'assembly dell'attivit "{0}" in "{1}".</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index 0d17c4c2a44..5689a1f9504 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -17,6 +17,11 @@
         <target state="translated"></target>
         <note />
       </trans-unit>
+      <trans-unit id="CollectionCopyToFailureProvidedArrayIsTooSmall">
+        <source>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</source>
+        <target state="translated"> ()</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
         <target state="translated">MSB4008:   "{0}"  "{1}" </target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index e8bbabfd3e9..d3da7922151 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -17,6 +17,11 @@
         <target state="translated"> .</target>
         <note />
       </trans-unit>
+      <trans-unit id="CollectionCopyToFailureProvidedArrayIsTooSmall">
+        <source>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</source>
+        <target state="translated">        (   ).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
         <target state="translated">MSB4008:   "{0}"()   "{1}" .</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index 272e8877783..32da5c6782c 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -17,6 +17,11 @@
         <target state="translated">Kompilacja rozpocza si.</target>
         <note />
       </trans-unit>
+      <trans-unit id="CollectionCopyToFailureProvidedArrayIsTooSmall">
+        <source>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</source>
+        <target state="translated">Liczba elementw w kolekcji jest wiksza ni dostpne miejsce w tablicy docelowej (zaczynajc od okrelonego indeksu).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
         <target state="translated">MSB4008: Zestaw, ktry wywouje konflikt z zestawem zadania {0}, zosta znaleziony w {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index 3b4308d3b6d..6be67780d46 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -17,6 +17,11 @@
         <target state="translated">Compilao iniciada.</target>
         <note />
       </trans-unit>
+      <trans-unit id="CollectionCopyToFailureProvidedArrayIsTooSmall">
+        <source>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</source>
+        <target state="translated">O nmero de elementos na coleo  maior que o espao disponvel na matriz de destino (ao iniciar no ndice especificado).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
         <target state="translated">MSB4008: Foi encontrado um assembly conflitante no assembly da tarefa "{0}" em "{1}".</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index eebaa4e6caa..92b45a030e4 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -17,6 +17,11 @@
         <target state="translated"> .</target>
         <note />
       </trans-unit>
+      <trans-unit id="CollectionCopyToFailureProvidedArrayIsTooSmall">
+        <source>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</source>
+        <target state="translated">          (    ).</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
         <target state="translated">MSB4008:  "{1}"  ,     "{0}".</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index 775a8cc8718..e5631033254 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -17,6 +17,11 @@
         <target state="translated">Oluturma balatld.</target>
         <note />
       </trans-unit>
+      <trans-unit id="CollectionCopyToFailureProvidedArrayIsTooSmall">
+        <source>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</source>
+        <target state="translated">Koleksiyondaki e says hedef dizideki kullanlabilir boluun boyutundan (belirtilen dizinden balayarak) daha byk.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
         <target state="translated">MSB4008: "{0}" grev derlemesi iin "{1}" konumunda akan derleme bulundu.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index 7e9f0b6897d..c40f0476018 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -17,6 +17,11 @@
         <target state="translated"></target>
         <note />
       </trans-unit>
+      <trans-unit id="CollectionCopyToFailureProvidedArrayIsTooSmall">
+        <source>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</source>
+        <target state="translated"> ()</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
         <target state="translated">MSB4008: {1}{0}</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index 94fd6cd9fcc..4b995564ab6 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -17,6 +17,11 @@
         <target state="translated"></target>
         <note />
       </trans-unit>
+      <trans-unit id="CollectionCopyToFailureProvidedArrayIsTooSmall">
+        <source>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</source>
+        <target state="translated"> ()</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
         <target state="translated">MSB4008:  "{1}"  "{0}" </target>
diff --git a/src/Shared/UnitTests/TestAssemblyInfo.cs b/src/Shared/UnitTests/TestAssemblyInfo.cs
index 368eb99d6c6..08353749def 100644
--- a/src/Shared/UnitTests/TestAssemblyInfo.cs
+++ b/src/Shared/UnitTests/TestAssemblyInfo.cs
@@ -5,6 +5,7 @@
 using System.IO;
 using System.Linq;
 using System.Runtime.InteropServices;
+using System.Xml;
 using System.Xml.Linq;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -103,7 +104,13 @@ private static void SetDotnetHostPath(TestEnvironment testEnvironment)
                 string potentialVersionsPropsPath = Path.Combine(currentFolder, "build", "Versions.props");
                 if (FileSystems.Default.FileExists(potentialVersionsPropsPath))
                 {
-                    var doc = XDocument.Load(potentialVersionsPropsPath);
+                    XDocument doc = null;
+                    var xrs = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true, IgnoreWhitespace = true };
+                    using (XmlReader xr = XmlReader.Create(File.OpenRead(potentialVersionsPropsPath), xrs))
+                    {
+                        doc = XDocument.Load(xr);
+                    }
+
                     var ns = doc.Root.Name.Namespace;
                     var cliVersionElement = doc.Root.Elements(ns + "PropertyGroup").Elements(ns + "DotNetCliVersion").FirstOrDefault();
                     if (cliVersionElement != null)
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 1792dad790f..3c15516a43f 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -16,10 +16,11 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
+
 using Shouldly;
+
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -27,6 +28,20 @@ namespace Microsoft.Build.UnitTests
 {
     public class Copy_Tests : IDisposable
     {
+        public static IEnumerable<object[]> GetDestinationExists() =>
+            new List<object[]>
+            {
+                new object[] { true },
+                new object[] { false },
+            };
+
+        public static IEnumerable<object[]> GetNullAndEmptyArrays() =>
+            new List<object[]>
+            {
+                new object[] { null },
+                new object[] { Array.Empty<ITaskItem>() },
+            };
+
         /// <summary>
         /// Gets data for testing with combinations of isUseHardLinks and isUseSymbolicLinks.
         /// Index 0 is the value for isUseHardLinks.
@@ -112,6 +127,356 @@ public void Dispose()
             Copy.RefreshInternalEnvironmentValues();
         }
 
+        [Fact]
+        public void CopyWithNoInput()
+        {
+            var task = new Copy { BuildEngine = new MockEngine(true), };
+            task.Execute().ShouldBeTrue();
+            (task.CopiedFiles == null || task.CopiedFiles.Length == 0).ShouldBeTrue();
+            (task.DestinationFiles == null || task.DestinationFiles.Length == 0).ShouldBeTrue();
+            task.WroteAtLeastOneFile.ShouldBeFalse();
+        }
+
+        [Fact]
+        public void CopyWithMatchingSourceFilesToDestinationFiles()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var sourceFile = env.CreateFile("source.txt");
+
+                var task = new Copy
+                {
+                    BuildEngine = new MockEngine(true),
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination.txt") },
+                    RetryDelayMilliseconds = 1,
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(1);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(1);
+                task.WroteAtLeastOneFile.ShouldBeTrue();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetDestinationExists))]
+        public void CopyWithSourceFilesToDestinationFolder(bool isDestinationExists)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var sourceFile = env.CreateFile("source.txt");
+                var destinationFolder = env.CreateFolder(isDestinationExists);
+
+                var task = new Copy
+                {
+                    BuildEngine = new MockEngine(true),
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                    RetryDelayMilliseconds = 1,
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(1);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(1);
+                task.WroteAtLeastOneFile.ShouldBeTrue();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetDestinationExists))]
+        public void CopyWithSourceFoldersToDestinationFolder(bool isDestinationExists)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var s0Folder = env.DefaultTestDirectory.CreateDirectory("source0");
+                s0Folder.CreateFile("00.txt");
+                s0Folder.CreateFile("01.txt");
+                var s0AFolder = s0Folder.CreateDirectory("a");
+                s0AFolder.CreateFile("a0.txt");
+                s0AFolder.CreateFile("a1.txt");
+                _ = s0Folder.CreateDirectory("b");
+                var s0CFolder = s0Folder.CreateDirectory("c");
+                s0CFolder.CreateFile("c0.txt");
+
+                var s1Folder = env.DefaultTestDirectory.CreateDirectory("source1");
+                s1Folder.CreateFile("10.txt");
+                s1Folder.CreateFile("11.txt");
+                var s1AFolder = s1Folder.CreateDirectory("a");
+                s1AFolder.CreateFile("a0.txt");
+                s1AFolder.CreateFile("a1.txt");
+                var s1BFolder = s1Folder.CreateDirectory("b");
+                s1BFolder.CreateFile("b0.txt");
+
+                var destinationFolder = env.CreateFolder(isDestinationExists);
+
+                var task = new Copy
+                {
+                    BuildEngine = new MockEngine(true),
+                    SourceFolders = new ITaskItem[] { new TaskItem(s0Folder.Path), new TaskItem(s1Folder.Path) },
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                    RetryDelayMilliseconds = 1,
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(10);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(10);
+                task.WroteAtLeastOneFile.ShouldBeTrue();
+                Directory.Exists(Path.Combine(destinationFolder.Path, "source0")).ShouldBeTrue();
+                Directory.Exists(Path.Combine(destinationFolder.Path, "source1")).ShouldBeTrue();
+            }
+        }
+
+        [Fact]
+        public void CopyWithNoSource()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var destinationFolder = env.CreateFolder(true);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(0);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(0);
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetDestinationExists))]
+        public void CopyWithMultipleSourceTypes(bool isDestinationExists)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+                var sourceFolder = env.DefaultTestDirectory.CreateDirectory("source");
+                sourceFolder.CreateFile("source.txt");
+                var aDirectory = sourceFolder.CreateDirectory("a");
+                aDirectory.CreateFile("a.txt");
+                sourceFolder.CreateDirectory("b");
+                var destinationFolder = env.CreateFolder(isDestinationExists);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    SourceFolders = new ITaskItem[] { new TaskItem(sourceFolder.Path) },
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(3);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(3);
+                task.WroteAtLeastOneFile.ShouldBeTrue();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetNullAndEmptyArrays))]
+        public void CopyWithEmptySourceFiles(ITaskItem[] sourceFiles)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var destinationFolder = env.CreateFolder(true);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = sourceFiles,
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(0);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(0);
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetNullAndEmptyArrays))]
+        public void CopyWithEmptySourceFolders(ITaskItem[] sourceFolders)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var destinationFolder = env.CreateFolder(true);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFolders = sourceFolders,
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                };
+                task.Execute().ShouldBeTrue();
+                task.CopiedFiles.ShouldNotBeNull();
+                task.CopiedFiles.Length.ShouldBe(0);
+                task.DestinationFiles.ShouldNotBeNull();
+                task.DestinationFiles.Length.ShouldBe(0);
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(GetNullAndEmptyArrays))]
+        public void CopyWithNoDestination(ITaskItem[] destinationFiles)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = destinationFiles,
+                };
+                task.Execute().ShouldBeFalse();
+                // Copy.NeedsDestination (MSB3023) or General.TwoVectorsMustHaveSameLength (MSB3094)
+                engine.AssertLogContains(destinationFiles == null ? "MSB3023" : "MSB3094");
+                task.CopiedFiles.ShouldBeNull();
+                (task.DestinationFiles == null || task.DestinationFiles.Length == 0).ShouldBeTrue();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Fact]
+        public void CopyWithMultipleDestinationTypes()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+                var destinationFolder = env.CreateFolder(true);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination.txt") },
+                    DestinationFolder = new TaskItem(destinationFolder.Path),
+                };
+                task.Execute().ShouldBeFalse();
+                engine.AssertLogContains("MSB3022"); // Copy.ExactlyOneTypeOfDestination
+                task.CopiedFiles.ShouldBeNull();
+                task.DestinationFiles.ShouldNotBeNull();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Fact]
+        public void CopyWithSourceFoldersAndDestinationFiles()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+                var sourceFolder = env.CreateFolder(true);
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    SourceFolders = new ITaskItem[] { new TaskItem(sourceFolder.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination0.txt"), new TaskItem("destination1.txt") },
+                };
+                task.Execute().ShouldBeFalse();
+                engine.AssertLogContains("MSB3896"); // Copy.IncompatibleParameters
+                task.CopiedFiles.ShouldBeNull();
+                task.DestinationFiles.ShouldNotBeNull();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        [Fact]
+        public void CopyWithDifferentLengthSourceFilesToDestinationFiles()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination0.txt"), new TaskItem("destination1.txt") },
+                };
+                task.Execute().ShouldBeFalse();
+                engine.AssertLogContains("MSB3094"); // General.TwoVectorsMustHaveSameLength
+                task.CopiedFiles.ShouldBeNull();
+                task.DestinationFiles.ShouldNotBeNull();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        /// <summary>
+        /// Verifies that we error for retries less than 0
+        /// </summary>
+        [Fact]
+        public void CopyWithInvalidRetryCount()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination.txt") },
+                    Retries = -1,
+                };
+                task.Execute().ShouldBeFalse();
+                engine.AssertLogContains("MSB3028"); // Copy.InvalidRetryCount
+                task.CopiedFiles.ShouldBeNull();
+                task.DestinationFiles.ShouldNotBeNull();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
+        /// <summary>
+        /// Verifies that we error for retry delay less than 0
+        /// </summary>
+        [Fact]
+        public void CopyWithInvalidRetryDelay()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var engine = new MockEngine(true);
+                var sourceFile = env.CreateFile("source.txt");
+
+                var task = new Copy
+                {
+                    BuildEngine = engine,
+                    SourceFiles = new ITaskItem[] { new TaskItem(sourceFile.Path) },
+                    DestinationFiles = new ITaskItem[] { new TaskItem("destination.txt") },
+                    RetryDelayMilliseconds = -1,
+                };
+                task.Execute().ShouldBeFalse();
+                engine.AssertLogContains("MSB3029"); // Copy.InvalidRetryDelay
+                task.CopiedFiles.ShouldBeNull();
+                task.DestinationFiles.ShouldNotBeNull();
+                task.WroteAtLeastOneFile.ShouldBeFalse();
+            }
+        }
+
         /// <summary>
         /// If OnlyCopyIfDifferent is set to "true" then we shouldn't copy over files that
         /// have the same date and time.
@@ -1898,6 +2263,30 @@ public void ExitGracefullyOnInvalidPathCharacters(bool isUseHardLinks, bool isUs
             ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
         }
 
+        /// <summary>
+        /// If the DestinationFolder parameter is given invalid path characters, make sure the task exits gracefully.
+        /// </summary>
+        [Theory]
+        [MemberData(nameof(GetHardLinksSymLinks))]
+        public void ExitGracefullyOnInvalidPathCharactersInDestinationFolder(bool isUseHardLinks, bool isUseSymbolicLinks)
+        {
+            var t = new Copy
+            {
+                RetryDelayMilliseconds = 1,  // speed up tests!
+                BuildEngine = new MockEngine(_testOutputHelper),
+                SourceFiles = new ITaskItem[] { new TaskItem("foo") },
+                DestinationFolder = new TaskItem("here | there"),
+                UseHardlinksIfPossible = isUseHardLinks,
+                UseSymboliclinksIfPossible = isUseSymbolicLinks,
+            };
+
+            bool result = t.Execute();
+
+            // Expect for there to have been no copies.
+            Assert.False(result);
+            ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3026"); // Didn't do retries
+        }
+
         /// <summary>
         /// Verifies that we error for retries less than 0
         /// </summary>
diff --git a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
index a417cabd783..07b1ce57a0f 100644
--- a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
+++ b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
@@ -259,6 +259,22 @@ public void AppConfigInvalidIfDependentAssemblyNodeIsEmpty()
             redirectResults.Engine.AssertLogContains("MSB3835");
         }
 
+        [Fact]
+        public void AppConfigWhenFilePlacedInLocationWithGB18030Characters()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFolder rootTestFolder = env.CreateFolder(); 
+                TransientTestFolder testFolder = env.CreateFolder(Path.Combine(rootTestFolder.Path, "\uD873\uDD02\u9FA8\u82D8\u722B\u9EA4\u03C5\u33D1\uE038\u486B\u0033"));
+                string appConfigContents = WriteAppConfigRuntimeSection(string.Empty, testFolder);
+                string outputAppConfigFile = env.ExpectFile(".config").Path;
+
+                TaskItemMock redirect = new TaskItemMock("System, Version=10.0.0.0, Culture=Neutral, PublicKeyToken='b77a5c561934e089'", "40.0.0.0");
+
+                _ = Should.NotThrow(() => GenerateBindingRedirects(appConfigContents, outputAppConfigFile, redirect));
+            }
+        }
+
         [Fact]
         public void AppConfigFileNotSavedWhenIdentical()
         {
@@ -306,12 +322,11 @@ private BindingRedirectsExecutionResult GenerateBindingRedirects(string appConfi
             GenerateBindingRedirects bindingRedirects = new GenerateBindingRedirects
             {
                 BuildEngine = engine,
-                SuggestedRedirects = suggestedRedirects ?? System.Array.Empty<ITaskItem>(),
+                SuggestedRedirects = suggestedRedirects ?? Array.Empty<ITaskItem>(),
                 AppConfigFile = new TaskItem(appConfigFile),
                 OutputAppConfigFile = new TaskItem(outputAppConfig)
             };
 
-
             bool executionResult = bindingRedirects.Execute();
 
             return new BindingRedirectsExecutionResult
@@ -324,7 +339,9 @@ private BindingRedirectsExecutionResult GenerateBindingRedirects(string appConfi
             };
         }
 
-        private string WriteAppConfigRuntimeSection(string runtimeSection)
+        private string WriteAppConfigRuntimeSection(
+            string runtimeSection,
+            TransientTestFolder transientTestFolder = null)
         {
             string formatString =
 @"<configuration>
@@ -334,7 +351,7 @@ private string WriteAppConfigRuntimeSection(string runtimeSection)
 </configuration>";
             string appConfigContents = string.Format(formatString, runtimeSection);
 
-            string appConfigFile = _env.CreateFile(".config").Path;
+            string appConfigFile = _env.CreateFile(transientTestFolder ?? new TransientTestFolder(), ".config").Path;
             File.WriteAllText(appConfigFile, appConfigContents);
             return appConfigFile;
         }
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index c108bb142f0..99307761f8f 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using System.IO;
+using System.Xml;
 
 #nullable disable
 
@@ -335,7 +336,12 @@ private XDocument LoadAppConfig(ITaskItem appConfigItem)
             }
             else
             {
-                document = XDocument.Load(appConfigItem.ItemSpec);
+                var xrs = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true, IgnoreWhitespace = true };
+                using (XmlReader xr = XmlReader.Create(File.OpenRead(appConfigItem.ItemSpec), xrs))
+                {
+                    document = XDocument.Load(xr);
+                }
+
                 if (document.Root == null || document.Root.Name != "configuration")
                 {
                     Log.LogErrorWithCodeFromResources("GenerateBindingRedirects.MissingConfigurationNode");
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 381fa520766..2c3e3779d45 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -2066,12 +2066,6 @@ internal void WriteStateFile()
             {
                 // Either the cache is dirty (we added or updated an item) or the number of items actually used is less than what
                 // we got by reading the state file prior to execution. Serialize the cache into the state file.
-                if (FailIfNotIncremental)
-                {
-                    Log.LogErrorFromResources("ResolveAssemblyReference.WritingCacheFile", _stateFile);
-                    return;
-                }
-
                 _cache.SerializeCache(_stateFile, Log);
             }
         }
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index cdb28ee4dc9..c51b3db6e91 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -8,6 +8,7 @@
 using System.Runtime.InteropServices;
 using System.Threading;
 using System.Threading.Tasks.Dataflow;
+
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -99,9 +100,10 @@ public Copy()
         /// </summary>
         private const int RetryDelayMillisecondsDefault = 1000;
 
-        [Required]
         public ITaskItem[] SourceFiles { get; set; }
 
+        public ITaskItem[] SourceFolders { get; set; }
+
         public ITaskItem DestinationFolder { get; set; }
 
         /// <summary>
@@ -402,7 +404,7 @@ internal bool Execute(
             int parallelism)
         {
             // If there are no source files then just return success.
-            if (SourceFiles == null || SourceFiles.Length == 0)
+            if (IsSourceSetEmpty())
             {
                 DestinationFiles = Array.Empty<ITaskItem>();
                 CopiedFiles = Array.Empty<ITaskItem>();
@@ -643,6 +645,11 @@ private bool CopyParallel(
             return success;
         }
 
+        private bool IsSourceSetEmpty()
+        {
+            return (SourceFiles == null || SourceFiles.Length == 0) && (SourceFolders == null || SourceFolders.Length == 0);
+        }
+
         /// <summary>
         /// Verify that the inputs are correct.
         /// </summary>
@@ -661,7 +668,7 @@ private bool ValidateInputs()
                 return false;
             }
 
-            // There must be a destinationFolder (either files or directory).
+            // There must be a destination (either files or directory).
             if (DestinationFiles == null && DestinationFolder == null)
             {
                 Log.LogErrorWithCodeFromResources("Copy.NeedsDestination", "DestinationFiles", "DestinationFolder");
@@ -675,6 +682,13 @@ private bool ValidateInputs()
                 return false;
             }
 
+            // SourceFolders and DestinationFiles can't be used together.
+            if (SourceFolders != null && DestinationFiles != null)
+            {
+                Log.LogErrorWithCodeFromResources("Copy.IncompatibleParameters", "SourceFolders", "DestinationFiles");
+                return false;
+            }
+
             // If the caller passed in DestinationFiles, then its length must match SourceFiles.
             if (DestinationFiles != null && DestinationFiles.Length != SourceFiles.Length)
             {
@@ -682,7 +696,6 @@ private bool ValidateInputs()
                 return false;
             }
 
-
             if (ErrorIfLinkFails && !UseHardlinksIfPossible && !UseSymboliclinksIfPossible)
             {
                 Log.LogErrorWithCodeFromResources("Copy.ErrorIfLinkFailsSetWithoutLinkOption");
@@ -694,40 +707,126 @@ private bool ValidateInputs()
 
         /// <summary>
         /// Set up our list of destination files.
+        /// For SourceFiles: Apply DestinationFolder to each SourceFiles item to create a DestinationFiles item.
+        /// For SourceFolders: With each SourceFolders item, get the files in the represented directory. Create both SourceFiles and DestinationFiles items.
         /// </summary>
         /// <returns>False if an error occurred, implying aborting the overall copy operation.</returns>
         private bool InitializeDestinationFiles()
         {
-            if (DestinationFiles == null)
+            bool isSuccess = true;
+
+            try
             {
                 // If the caller passed in DestinationFolder, convert it to DestinationFiles
-                DestinationFiles = new ITaskItem[SourceFiles.Length];
-
-                for (int i = 0; i < SourceFiles.Length; ++i)
+                if (DestinationFiles == null && SourceFiles != null)
                 {
-                    // Build the correct path.
-                    string destinationFile;
-                    try
+                    DestinationFiles = new ITaskItem[SourceFiles.Length];
+
+                    for (int i = 0; i < SourceFiles.Length; ++i)
                     {
-                        destinationFile = Path.Combine(DestinationFolder.ItemSpec, Path.GetFileName(SourceFiles[i].ItemSpec));
+                        // Build the correct path.
+                        if (!TryPathOperation(
+                                () => Path.Combine(DestinationFolder.ItemSpec, Path.GetFileName(SourceFiles[i].ItemSpec)),
+                                SourceFiles[i].ItemSpec,
+                                DestinationFolder.ItemSpec,
+                                out string destinationFile))
+                        {
+                            isSuccess = false;
+                            break;
+                        }
+
+                        // Initialize the destinationFolder item.
+                        // ItemSpec is unescaped, and the TaskItem constructor expects an escaped input, so we need to
+                        // make sure to re-escape it here.
+                        DestinationFiles[i] = new TaskItem(EscapingUtilities.Escape(destinationFile));
+
+                        // Copy meta-data from source to destinationFolder.
+                        SourceFiles[i].CopyMetadataTo(DestinationFiles[i]);
                     }
-                    catch (ArgumentException e)
+                }
+
+                if (isSuccess && SourceFolders != null && SourceFolders.Length > 0)
+                {
+                    var sourceFiles = SourceFiles != null ? new List<ITaskItem>(SourceFiles) : new List<ITaskItem>();
+                    var destinationFiles = DestinationFiles != null ? new List<ITaskItem>(DestinationFiles) : new List<ITaskItem>();
+
+                    foreach (ITaskItem sourceFolder in SourceFolders)
                     {
-                        Log.LogErrorWithCodeFromResources("Copy.Error", SourceFiles[i].ItemSpec, DestinationFolder.ItemSpec, e.Message);
-                        // Clear the outputs.
-                        DestinationFiles = Array.Empty<ITaskItem>();
-                        return false;
-                    }
+                        string src = FileUtilities.NormalizePath(sourceFolder.ItemSpec);
+                        string srcName = Path.GetFileName(src);
 
-                    // Initialize the destinationFolder item.
-                    // ItemSpec is unescaped, and the TaskItem constructor expects an escaped input, so we need to
-                    // make sure to re-escape it here.
-                    DestinationFiles[i] = new TaskItem(EscapingUtilities.Escape(destinationFile));
+                        (string[] filesInFolder, _, _) = FileMatcher.Default.GetFiles(src, "**");
 
-                    // Copy meta-data from source to destinationFolder.
-                    SourceFiles[i].CopyMetadataTo(DestinationFiles[i]);
+                        foreach (string file in filesInFolder)
+                        {
+                            if (!TryPathOperation(
+                                    () => Path.Combine(src, file),
+                                    sourceFolder.ItemSpec,
+                                    DestinationFolder.ItemSpec,
+                                    out string sourceFile))
+                            {
+                                isSuccess = false;
+                                break;
+                            }
+
+                            if (!TryPathOperation(
+                                    () => Path.Combine(DestinationFolder.ItemSpec, srcName, file),
+                                    sourceFolder.ItemSpec,
+                                    DestinationFolder.ItemSpec,
+                                    out string destinationFile))
+                            {
+                                isSuccess = false;
+                                break;
+                            }
+
+
+                            var item = new TaskItem(EscapingUtilities.Escape(sourceFile));
+                            sourceFolder.CopyMetadataTo(item);
+                            sourceFiles.Add(item);
+
+                            item = new TaskItem(EscapingUtilities.Escape(destinationFile));
+                            sourceFolder.CopyMetadataTo(item);
+                            destinationFiles.Add(item);
+                        }
+                    }
+
+                    SourceFiles = sourceFiles.ToArray();
+                    DestinationFiles = destinationFiles.ToArray();
                 }
             }
+            finally
+            {
+                if (!isSuccess)
+                {
+                    // Clear the outputs.
+                    DestinationFiles = Array.Empty<ITaskItem>();
+                }
+            }
+
+            return isSuccess;
+        }
+
+        /// <summary>
+        /// Tries the path operation. Logs a 'Copy.Error' if an exception is thrown.
+        /// </summary>
+        /// <param name="operation">The operation.</param>
+        /// <param name="src">The source to use for the log message.</param>
+        /// <param name="dest">The destination to use for the log message.</param>
+        /// <param name="resultPathOperation">The result of the path operation.</param>
+        /// <returns></returns>
+        private bool TryPathOperation(Func<string> operation, string src, string dest, out string resultPathOperation)
+        {
+            resultPathOperation = string.Empty;
+
+            try
+            {
+                resultPathOperation = operation();
+            }
+            catch (ArgumentException e)
+            {
+                Log.LogErrorWithCodeFromResources("Copy.Error", src, dest, e.Message);
+                return false;
+            }
 
             return true;
         }
@@ -926,20 +1025,9 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
         private static string GetLockedFileMessage(string file)
         {
             string message = string.Empty;
-
-            try
-            {
-                if (NativeMethodsShared.IsWindows && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-                {
-                    var processes = LockCheck.GetProcessesLockingFile(file);
-                    message = !string.IsNullOrEmpty(processes)
-                        ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("Copy.FileLocked", processes)
-                        : String.Empty;
-                }
-            }
-            catch (Exception)
+            if (NativeMethodsShared.IsWindows)
             {
-                // Never throw if we can't get the processes locking the file.
+                message = LockCheck.GetLockedFileMessage(file);
             }
 
             return message;
diff --git a/src/Tasks/GenerateManifestBase.cs b/src/Tasks/GenerateManifestBase.cs
index 7fdafde410b..fe77d0e5f63 100644
--- a/src/Tasks/GenerateManifestBase.cs
+++ b/src/Tasks/GenerateManifestBase.cs
@@ -619,7 +619,13 @@ private bool WriteManifest()
             }
             catch (Exception ex)
             {
-                Log.LogErrorWithCodeFromResources("GenerateManifest.WriteOutputManifestFailed", OutputManifest.ItemSpec, ex.Message);
+                string lockedFileMessage = string.Empty;
+                if (NativeMethodsShared.IsWindows)
+                {
+                    lockedFileMessage = LockCheck.GetLockedFileMessage(OutputManifest.ItemSpec);
+                }
+                Log.LogErrorWithCodeFromResources("GenerateManifest.WriteOutputManifestFailed", OutputManifest.ItemSpec, ex.Message, lockedFileMessage);
+
                 return false;
             }
 
diff --git a/src/Tasks/LockCheck.cs b/src/Tasks/LockCheck.cs
index 3def6381e12..c2d068d33b1 100644
--- a/src/Tasks/LockCheck.cs
+++ b/src/Tasks/LockCheck.cs
@@ -7,6 +7,8 @@
 using System.Linq;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -244,6 +246,31 @@ internal static string GetProcessesLockingFile(string filePath)
             return string.Join(", ", GetLockingProcessInfos(filePath).Select(p => $"{p.ApplicationName} ({p.ProcessId})"));
         }
 
+        /// <summary>
+        /// Try to get a message to inform the user which processes have a lock on a given file.
+        /// </summary>
+        internal static string GetLockedFileMessage(string file)
+        {
+            string message = string.Empty;
+
+            try
+            {
+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                {
+                    var processes = GetProcessesLockingFile(file);
+                    message = !string.IsNullOrEmpty(processes)
+                        ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("Task.FileLocked", processes)
+                        : String.Empty;
+                }
+            }
+            catch (Exception)
+            {
+                // Never throw if we can't get the processes locking the file.
+            }
+
+            return message;
+        }
+
         internal static IEnumerable<ProcessInfo> GetLockingProcessInfos(params string[] paths)
         {
             if (paths == null)
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index 938c839fd47..d8e5b2a8fdd 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -487,7 +487,7 @@ private void UpdateAssemblyReference(AssemblyReference a, string targetFramework
 
         private void UpdateFileReference(BaseReference f, string targetFrameworkVersion)
         {
-            if (String.IsNullOrEmpty(f.ResolvedPath))
+            if (string.IsNullOrEmpty(f.ResolvedPath))
             {
                 throw new FileNotFoundException(null, f.SourcePath);
             }
@@ -506,22 +506,33 @@ private void UpdateFileReference(BaseReference f, string targetFrameworkVersion)
             f.Size = size;
 
             //
-            // .NETCore Launcher.exe based Deployment: If the filereference is for apphost.exe, we need to change
-            // the ResolvedPath and TargetPath to {assemblyname}.exe before we write the manifest, so that the
-            // manifest does not have a file reference to apphost.exe
+            // .NET >= 5 ClickOnce: If the file reference is for apphost.exe, we need to change the filename
+            // in ResolvedPath to TargetPath so we don't end up publishing the file as apphost.exe.
+            // If the TargetPath is not present, we will fallback to AssemblyName.
             //
             string fileName = Path.GetFileName(f.ResolvedPath);
             if (LauncherBasedDeployment &&
-                fileName.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase) &&
-                !String.IsNullOrEmpty(AssemblyName))
+                fileName.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase))
             {
-                f.ResolvedPath = Path.Combine(Path.GetDirectoryName(f.ResolvedPath), AssemblyName);
-                f.TargetPath = BaseReference.GetDefaultTargetPath(f.ResolvedPath);
+                if (!string.IsNullOrEmpty(f.TargetPath))
+                {
+                    f.ResolvedPath = Path.Combine(Path.GetDirectoryName(f.ResolvedPath), f.TargetPath);
+                }
+                else if (!string.IsNullOrEmpty(AssemblyName))
+                {
+                    f.ResolvedPath = Path.Combine(Path.GetDirectoryName(f.ResolvedPath), AssemblyName);
+                    f.TargetPath = BaseReference.GetDefaultTargetPath(f.ResolvedPath);
+                }
+                else
+                {
+                    Debug.Assert(false, "AssemblyName cannot be empty");
+                    OutputMessages.AddWarningMessage("GenerateManifest.InvalidValue", "AssemblyName");
+                }
             }
 
-            if (String.IsNullOrEmpty(f.TargetPath))
+            if (string.IsNullOrEmpty(f.TargetPath))
             {
-                if (!String.IsNullOrEmpty(f.SourcePath))
+                if (!string.IsNullOrEmpty(f.SourcePath))
                 {
                     f.TargetPath = BaseReference.GetDefaultTargetPath(f.SourcePath);
                 }
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index da2308866d1..dfc7d8e46c2 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -814,13 +814,28 @@ private static string ObtainRFC3161Timestamp(string timeStampUrl, string signatu
 
                 try
                 {
-                    byte[] nonce = new byte[24];
+                    byte[] nonce = new byte[32];
 
                     using (RandomNumberGenerator rng = RandomNumberGenerator.Create())
                     {
                         rng.GetBytes(nonce);
                     }
 
+                    // Eventually, CryptEncodeObjectEx(...) is called on a CRYPT_TIMESTAMP_REQUEST with this nonce,
+                    // and CryptEncodeObjectEx(...) interprets the nonce as a little endian, DER-encoded integer value
+                    // (without tag and length), and may even strip leading bytes from the big endian representation
+                    // of the byte sequence to achieve proper integer DER encoding.
+                    //
+                    // If the nonce is changed after the client generates it, the timestamp server would receive
+                    // and return a nonce that does not agree with the client's original nonce.
+                    //
+                    // To ensure this does not happen, ensure that the most significant byte in the little
+                    // endian byte sequence is in the 0x01-0x7F range; clear that byte's most significant bit
+                    // and set that byte's least significant bit.
+ 
+                    nonce[nonce.Length - 1] &= 0x7f;
+                    nonce[nonce.Length - 1] |= 0x01;
+
                     Win32.CRYPT_TIMESTAMP_PARA para = new Win32.CRYPT_TIMESTAMP_PARA()
                     {
                         fRequestCerts = true,
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index b320fd94dd6..d51513a7139 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -438,6 +438,9 @@
     <Content Include="Microsoft.Common.tasks">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
+    <Content Include="Microsoft.Common.Test.targets">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
     <Content Include="Microsoft.NET.props">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index 44bed1b25ba..8d079e3f057 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -19,6 +19,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.CrossTargeting.targets\ImportBefore\*.targets"
           Condition="'$(ImportByWildcardBeforeMicrosoftCommonCrossTargetingTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.CrossTargeting.targets\ImportBefore')"/>
 
+  <Import Project="$(MSBuildProjectFullPath).user" Condition="Exists('$(MSBuildProjectFullPath).user')"/>
+
   <Import Project="$(CustomBeforeMicrosoftCommonCrossTargetingTargets)" Condition="'$(CustomBeforeMicrosoftCommonCrossTargetingTargets)' != '' and Exists('$(CustomBeforeMicrosoftCommonCrossTargetingTargets)')"/>
 
   <Target Name="GetTargetFrameworks"
@@ -246,4 +248,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(DirectoryBuildTargetsPath)" Condition="'$(ImportDirectoryBuildTargets)' == 'true' and exists('$(DirectoryBuildTargetsPath)')"/>
 
+  <PropertyGroup>
+    <UseMSBuildTestInfrastructure Condition="'$(UseMSBuildTestInfrastructure)' == ''">false</UseMSBuildTestInfrastructure>
+  </PropertyGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.Common.Test.targets" Condition="'$(UseMSBuildTestInfrastructure)' == 'true'"/>
+
 </Project>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 483575bc1a2..7ea4d4d06fb 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -323,7 +323,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <!-- Example, C:\MyProjects\MyProject\bin\Debug\MyAssembly.dll -->
     <TargetPath Condition=" '$(TargetPath)' == '' ">$(TargetDir)$(TargetFileName)</TargetPath>
 
-    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' and ('$(ProduceReferenceAssemblyInOutDir)' == 'true' or '$([MSBuild]::AreFeaturesEnabled(17.0))' != 'true' ) ">$([MSBuild]::NormalizePath($(TargetDir), 'ref', $(TargetFileName)))</TargetRefPath>
+    <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' and '$(ProduceReferenceAssemblyInOutDir)' == 'true' ">$([MSBuild]::NormalizePath($(TargetDir), 'ref', $(TargetFileName)))</TargetRefPath>
     <TargetRefPath Condition=" '$(TargetRefPath)' == '' and '$(ProduceReferenceAssembly)' == 'true' ">$([MSBuild]::NormalizePath($(MSBuildProjectDirectory), $(IntermediateOutputPath), 'ref', $(TargetFileName)))</TargetRefPath>
 
     <!-- Example, C:\MyProjects\MyProject\ -->
@@ -388,9 +388,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   
   <PropertyGroup Condition="'$(MSBuildCopyMarkerName)' == ''">
     <MSBuildCopyMarkerName>$(MSBuildProjectFile)</MSBuildCopyMarkerName>
-    <!-- For a long MSBuildProjectFile let's shorten this to 17 chars - using the first 8 chars of the filename and either the ProjectGuid if it exists -->
-    <MSBuildCopyMarkerName Condition="'$(MSBuildCopyMarkerName.Length)' &gt; '17' and '$(ProjectGuid)' != ''">$(MSBuildProjectFile.Substring(0,8)).$(ProjectGuid.Substring(1,8))</MSBuildCopyMarkerName>
-    <!-- or a filename hash if the guid is not present (in such case the filename was not shortened and is still over 17 chars long). -->
+    <!-- For a long MSBuildProjectFile let's shorten this to 17 chars - using the first 8 chars of the filename and a filename hash. -->
     <MSBuildCopyMarkerName Condition="'$(MSBuildCopyMarkerName.Length)' &gt; '17'">$(MSBuildProjectFile.Substring(0,8)).$([MSBuild]::StableStringHash($(MSBuildProjectFile)).ToString("X8"))</MSBuildCopyMarkerName>
     <MSBuildCopyMarkerName>$(MSBuildCopyMarkerName).Up2Date</MSBuildCopyMarkerName>
   </PropertyGroup>
@@ -5026,7 +5024,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       This target enforces the dependency.
     -->
 
-    <MSBuildCopyContentTransitively Condition=" '$(MSBuildCopyContentTransitively)' == '' and $([MSBuild]::AreFeaturesEnabled('17.0'))">true</MSBuildCopyContentTransitively>
+    <MSBuildCopyContentTransitively Condition=" '$(MSBuildCopyContentTransitively)' == ''">true</MSBuildCopyContentTransitively>
 
     <_TargetsThatPrepareProjectReferences Condition=" '$(MSBuildCopyContentTransitively)' == 'true' ">
       AssignProjectConfiguration;
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 9b98bcf97a8..9a78f010f16 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -285,14 +285,17 @@ private ITaskItem CreateFileItem(ITaskItem item, string group, string targetPath
             {
                 targetPath = Path.GetFileName(item.ItemSpec);
                 //
-                // .NETCore Launcher.exe based deployment: If the file is apphost.exe, we need to set 'TargetPath' metadata
-                // to {assemblyname}.exe so that the file gets published as {assemblyname}.exe and not apphost.exe.
+                // .NET >= 5 ClickOnce: If TargetPath metadata is not present in apphost.exe's metadata, we'll fallback to using AssemblyName
                 //
                 if (LauncherBasedDeployment &&
                     targetPath.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase) &&
                     !String.IsNullOrEmpty(AssemblyName))
                 {
-                    targetPath = AssemblyName;
+                    targetPath = item.GetMetadata(ItemMetadataNames.targetPath);
+                    if (String.IsNullOrEmpty(targetPath))
+                    {
+                        targetPath = AssemblyName;
+                    }
                 }
                 else
                 {
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 3ba788b9c76..7cc9051fe8a 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -293,7 +293,7 @@
     <value>MSB3030: Could not copy the file "{0}" because it was not found.</value>
     <comment>{StrBegin="MSB3030: "} LOCALIZATION: {0} is a number.</comment>
   </data>
-  <data name="Copy.FileLocked">
+  <data name="Task.FileLocked">
     <value>The file is locked by: "{0}"</value>
   </data>
 
@@ -915,7 +915,7 @@
     <comment>{StrBegin="MSB3183: "}</comment>
   </data>
   <data name="GenerateManifest.WriteOutputManifestFailed">
-    <value>MSB3173: Unable to write manifest '{0}'. {1}</value>
+    <value>MSB3173: Unable to write manifest '{0}'. {1} {2}</value>
     <comment>{StrBegin="MSB3173: "}</comment>
   </data>
   <data name="GenerateManifest.InvalidRequestedExecutionLevel">
@@ -1776,10 +1776,6 @@
     <value>Assembly file '{0}' could not be opened -- PE image doesn't contain managed metadata.</value>
     <comment></comment>
   </data>
-  <data name="ResolveAssemblyReference.WritingCacheFile">
-    <value>Updating assembly cache file "{0}".</value>
-    <comment></comment>
-  </data>
   <!--
         The ResolveComReference message bucket is: MSB3281 - MSB3320
 
@@ -2793,6 +2789,10 @@
     <value>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</value>
     <comment>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</comment>
   </data>
+  <data name="Copy.IncompatibleParameters">
+    <value>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</value>
+    <comment>{StrBegin="MSB3896: "}</comment>
+  </data>
 
   <!--
         MSB3901 - MSB3910   Task: Telemetry
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 162dd1ea684..edfeadba856 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: Pi koprovn {1} do {2} dolo k vjimce {0} a HR je {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: V souboru projektu byl zadn jak parametr {0}, tak parametr {1}. Nelze je vak pout oba najednou. Zvolte prosm jenom jeden z nich.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Ned se pout odkaz pro koprovn {0} do {1}.</target>
@@ -1055,8 +1060,8 @@
         <note>{StrBegin="MSB3183: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.WriteOutputManifestFailed">
-        <source>MSB3173: Unable to write manifest '{0}'. {1}</source>
-        <target state="translated">MSB3173: Nelze zapsat manifest {0}. {1}</target>
+        <source>MSB3173: Unable to write manifest '{0}'. {1} {2}</source>
+        <target state="translated">MSB3173: Nepovedlo se zapsat manifest {0}. {1} {2}</target>
         <note>{StrBegin="MSB3173: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.InvalidRequestedExecutionLevel">
@@ -2175,11 +2180,6 @@
         <target state="translated">Nzev redistribunho balku v elementu FileList v souboru seznamu redistribunho balku {0} je null nebo przdn. Nzev redistribunho balku nesm bt null ani przdn.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Aktualizuje se soubor mezipamti sestaven {0}.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">Odkaz modelu COM {0} je definin sestaven ovldacho prvku ActiveX {1}, ale kompiltor ho oznail pznakem /link. S tmto odkazem modelu COM se bude zachzet jako s odkazem a nebude propojen.</target>
@@ -2514,6 +2514,11 @@
         <target state="translated">MSB3353: Nebyl zadn veejn kl nezbytn ke zpodnmu podepsn.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
+      <trans-unit id="Task.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">Soubor uzamkl(a): {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: loha {0} se nepodporuje ve verzi MSBuildu pro .NET Core. Pouijte prosm verzi MSBuildu pro .NET Framework. Dal podrobnosti najdete na strnce https://aka.ms/msbuild/MSB4803.</target>
@@ -3399,11 +3404,6 @@
         <target state="translated">MSB4801: Objekt pro vytven loh {0} se ve verzi .NET Core nstroje MSBuild nepodporuje.</target>
         <note>{StrBegin="MSB4801: "}</note>
       </trans-unit>
-      <trans-unit id="Copy.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">Soubor uzamkl(a): {0}.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CodeTaskFactory.InvalidCodeType">
         <source>MSB3759: The specified code type "{0}" is invalid.  The supported code types are "{1}".</source>
         <target state="translated">MSB3759: Uren typ kdu {0} nen platn. Podporovan jsou tyto typy kdu: {1}.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 58d7ba7e5dc..cd93a9e81c7 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: Erhalt von {0} Kopieren von "{1}" zu "{2}" und HR ist {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: Sowohl "{0}" als auch "{1}" wurden als Parameter in der Projektdatei angegeben, knnen aber nicht zusammen verwendet werden. Whlen Sie eins oder das andere aus.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Es konnte kein Link verwendet werden, um "{0}" in "{1}" zu kopieren.</target>
@@ -1055,8 +1060,8 @@
         <note>{StrBegin="MSB3183: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.WriteOutputManifestFailed">
-        <source>MSB3173: Unable to write manifest '{0}'. {1}</source>
-        <target state="translated">MSB3173: Das Manifest "{0}" kann nicht geschrieben werden. {1}</target>
+        <source>MSB3173: Unable to write manifest '{0}'. {1} {2}</source>
+        <target state="translated">MSB3173: Das Manifest {0} kann nicht geschrieben werden. {1} {2}</target>
         <note>{StrBegin="MSB3173: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.InvalidRequestedExecutionLevel">
@@ -2175,11 +2180,6 @@
         <target state="translated">Der Redist-Name im FileList-Element der Redistributable-Listendatei "{0}" ist NULL oder leer. Vergewissern Sie sich, dass der Redist-Name nicht NULL oder leer ist.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Aktualisiert Assemblycachedatei "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">Der COM-Verweis "{0}" ist die Interopassembly fr das ActiveX-Steuerelement "{1}". Entsprechend der Markierung ist der Verweis jedoch durch den Compiler mit dem /link-Flag verknpft. Der COM-Verweis wird als Verweis behandelt und nicht verknpft.</target>
@@ -2514,6 +2514,11 @@
         <target state="translated">MSB3353: Der fr die verzgerte Signierung erforderliche ffentliche Schlssel wurde nicht angegeben.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
+      <trans-unit id="Task.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">Die Datei wird durch "{0}" gesperrt.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: Die Aufgabe "{0}" wird fr die .NET Core-Version von MSBuild nicht untersttzt. Verwenden Sie die .NET Framework-Version von MSBuild. Weitere Informationen finden Sie unter https://aka.ms/msbuild/MSB4803.</target>
@@ -3399,11 +3404,6 @@
         <target state="translated">MSB4801: Die Aufgabenfactory "{0}" wird fr die .NET Core-Version von MSBuild nicht untersttzt.</target>
         <note>{StrBegin="MSB4801: "}</note>
       </trans-unit>
-      <trans-unit id="Copy.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">Die Datei wird durch "{0}" gesperrt.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CodeTaskFactory.InvalidCodeType">
         <source>MSB3759: The specified code type "{0}" is invalid.  The supported code types are "{1}".</source>
         <target state="translated">MSB3759: Der angegebene Codetyp "{0}" ist ungltig. Untersttzte Codetypen: {1}.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index a3c16e3c798..1969f32a5a8 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: Se obtuvo {0} al copiar "{1}" en "{2}" y HR es {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: "{0}" y "{1}" se especificaron como parmetros en el archivo de proyecto, pero no se pueden usar juntos. Elija una u otra.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: No se puede usar un vnculo para copiar "{0}" en "{1}".</target>
@@ -1055,8 +1060,8 @@
         <note>{StrBegin="MSB3183: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.WriteOutputManifestFailed">
-        <source>MSB3173: Unable to write manifest '{0}'. {1}</source>
-        <target state="translated">MSB3173: No se puede escribir en el manifiesto '{0}'. {1}</target>
+        <source>MSB3173: Unable to write manifest '{0}'. {1} {2}</source>
+        <target state="translated">MSB3173: No se puede escribir el manifiesto '{0}'. {1} {2}</target>
         <note>{StrBegin="MSB3173: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.InvalidRequestedExecutionLevel">
@@ -2175,11 +2180,6 @@
         <target state="translated">El archivo de lista de paquetes redistribuibles "{0}" tiene un nombre Redist NULL o vaco en el elemento FileList. Asegrese de que el nombre Redist no sea NULL ni est vaco.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Actualizando el archivo de cach de ensamblado "{0}".</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">La referencia COM '{0}' es el ensamblado de interoperabilidad del control ActiveX '{1}' pero estaba marcada para su vinculacin por el compilador con la marca /link. Esta referencia COM se tratar como una referencia y no se vincular.</target>
@@ -2514,6 +2514,11 @@
         <target state="translated">MSB3353: No se especific la clave pblica necesaria para la firma retardada.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
+      <trans-unit id="Task.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">El archivo se ha bloqueado por: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: No se admite la tarea "{0}" en la versin de MSBuild de .NET Core. Use la versin de MSBuild de .NET Framework. Vea https://aka.ms/msbuild/MSB4803 para obtener ms informacin.</target>
@@ -3399,11 +3404,6 @@
         <target state="translated">MSB4801: El generador de tareas "{0}" no se admite en la versin de .NET Core de MSBuild.</target>
         <note>{StrBegin="MSB4801: "}</note>
       </trans-unit>
-      <trans-unit id="Copy.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">El archivo se ha bloqueado por: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CodeTaskFactory.InvalidCodeType">
         <source>MSB3759: The specified code type "{0}" is invalid.  The supported code types are "{1}".</source>
         <target state="translated">MSB3759: El tipo de cdigo especificado "{0}" no es vlido. Los tipos de cdigo admitidos son "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index d309c31905c..8d57e22e80a 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: Nous avons copi {0} {1} vers {2} et les ressources humaines sont {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: {0} et {1} ont t spcifies comme paramtres dans le Fichier projet, mais ne peuvent pas tre utiliss ensemble. Choisissez lune ou lautre.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: impossible d'utiliser un lien pour copier "{0}" vers "{1}".</target>
@@ -1055,8 +1060,8 @@
         <note>{StrBegin="MSB3183: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.WriteOutputManifestFailed">
-        <source>MSB3173: Unable to write manifest '{0}'. {1}</source>
-        <target state="translated">MSB3173: Impossible d'crire le manifeste '{0}'. {1}</target>
+        <source>MSB3173: Unable to write manifest '{0}'. {1} {2}</source>
+        <target state="translated">MSB3173: impossible dcrire le manifeste {0}. {1} {2}</target>
         <note>{StrBegin="MSB3173: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.InvalidRequestedExecutionLevel">
@@ -2175,11 +2180,6 @@
         <target state="translated">Le fichier de liste de packages redistribuables "{0}" a un nom Redist vide ou ayant une valeur null dans l'lment FileList. Vrifiez que le nom Redist n'est pas vide ou qu'il n'a pas une valeur null.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Mise  jour du fichier de cache dassembly {0}.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">La rfrence COM '{0}' est l'assembly d'interoprabilit pour le contrle ActiveX '{1}', mais elle a t marque comme tant lie au compilateur avec l'indicateur /link. Cette rfrence COM sera traite comme une rfrence, mais ne sera pas lie.</target>
@@ -2514,6 +2514,11 @@
         <target state="translated">MSB3353: La cl publique ncessaire  la signature diffre n'a pas t spcifie.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
+      <trans-unit id="Task.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">Le fichier est verrouill par: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: La tche "{0}" n'est pas prise en charge dans la version .NET Core de MSBuild. Utilisez la version du .NET Framework de MSBuild. Pour plus d'informations, consultez https://aka.ms/msbuild/MSB4803.</target>
@@ -3399,11 +3404,6 @@
         <target state="translated">MSB4801: La fabrique de tches "{0}" n'est pas prise en charge dans la version .NET Core de MSBuild.</target>
         <note>{StrBegin="MSB4801: "}</note>
       </trans-unit>
-      <trans-unit id="Copy.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">Le fichier est verrouill par: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CodeTaskFactory.InvalidCodeType">
         <source>MSB3759: The specified code type "{0}" is invalid.  The supported code types are "{1}".</source>
         <target state="translated">MSB3759: Le type de code spcifi ("{0}") n'est pas valide. Les types de code pris en charge sont "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 65f4471d1dc..20f8704e804 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: Ottenuto {0} copiando "{1}" in "{2}" e HR  {3}"</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: i parametri "{0}" e "{1}" sono stati specificati come parametri nel file di progetto, ma non possono essere usati insieme. Scegliere uno o l'altro.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: non  stato possibile usare un collegamento per copiare "{0}" in "{1}".</target>
@@ -1055,8 +1060,8 @@
         <note>{StrBegin="MSB3183: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.WriteOutputManifestFailed">
-        <source>MSB3173: Unable to write manifest '{0}'. {1}</source>
-        <target state="translated">MSB3173: non  possibile scrivere il manifesto '{0}'. {1}</target>
+        <source>MSB3173: Unable to write manifest '{0}'. {1} {2}</source>
+        <target state="translated">MSB3173: non  possibile scrivere il manifesto '{0}'. {1} {2}</target>
         <note>{StrBegin="MSB3173: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.InvalidRequestedExecutionLevel">
@@ -2175,11 +2180,6 @@
         <target state="translated">Il file di elenco di pacchetti ridistribuibili "{0}" include un nome di Redist Null o vuoto nell'elemento FileList. Verificare che il nome di Redist non sia Null o vuoto.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Aggiornamento del file della cache di assembly "{0}".</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">Il riferimento COM '{0}'  l'assembly di interoperabilit per il controllo ActiveX '{1}', tuttavia  stato contrassegnato dal compilatore con il flag /link per il collegamento. Il riferimento COM verr trattato come riferimento e non verr collegato.</target>
@@ -2514,6 +2514,11 @@
         <target state="translated">MSB3353: chiave pubblica necessaria per la firma ritardata non specificata.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
+      <trans-unit id="Task.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">Il file  bloccato da: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: l'attivit "{0}" non  supportata nella versione .NET Core di MSBuild. Usare la versione .NET Framework di MSBuild. Per altri dettagli, vedere https://aka.ms/msbuild/MSB4803.</target>
@@ -3399,11 +3404,6 @@
         <target state="translated">MSB4801: la factory delle attivit "{0}" non  supportata nella versione .NET Core di MSBuild.</target>
         <note>{StrBegin="MSB4801: "}</note>
       </trans-unit>
-      <trans-unit id="Copy.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">Il file  bloccato da: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CodeTaskFactory.InvalidCodeType">
         <source>MSB3759: The specified code type "{0}" is invalid.  The supported code types are "{1}".</source>
         <target state="translated">MSB3759: il tipo di codice specificato "{0}" non  valido. I tipi di codice supportati sono "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index c9cd6028fc9..a33712e3aaf 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: "{1}"  "{2}"  {0}HR  {3} </target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: "{0}"  "{1}"  </target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893:  "{0}"  "{1}" </target>
@@ -1055,8 +1060,8 @@
         <note>{StrBegin="MSB3183: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.WriteOutputManifestFailed">
-        <source>MSB3173: Unable to write manifest '{0}'. {1}</source>
-        <target state="translated">MSB3173:  '{0}' {1}</target>
+        <source>MSB3173: Unable to write manifest '{0}'. {1} {2}</source>
+        <target state="translated">MSB3173:  '{0}' {1}{2}</target>
         <note>{StrBegin="MSB3173: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.InvalidRequestedExecutionLevel">
@@ -2175,11 +2180,6 @@
         <target state="translated">   "{0}"  FileList  null  null </target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">   "{0}" </target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM  '{0}'  ActiveX  '{1}'  /link  COM </target>
@@ -2514,6 +2514,11 @@
         <target state="translated">MSB3353: </target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
+      <trans-unit id="Task.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated"> "{0}" </target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803:  "{0}"  .NET Core  MSBuild .NET Framework  MSBuild https://aka.ms/msbuild/MSB4803 </target>
@@ -3399,11 +3404,6 @@
         <target state="translated">MSB4801:   "{0}"  MSBuild  .NET Core </target>
         <note>{StrBegin="MSB4801: "}</note>
       </trans-unit>
-      <trans-unit id="Copy.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated"> "{0}" </target>
-        <note />
-      </trans-unit>
       <trans-unit id="CodeTaskFactory.InvalidCodeType">
         <source>MSB3759: The specified code type "{0}" is invalid.  The supported code types are "{1}".</source>
         <target state="translated">MSB3759:  "{0}"  "{1}" </target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 0ca9222197f..5c77412480c 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: {0}() {1}()  {2}()  HR {3}.</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: "{0}"  "{1}"          .     .</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893:   "{0}"() "{1}"   .</target>
@@ -1055,8 +1060,8 @@
         <note>{StrBegin="MSB3183: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.WriteOutputManifestFailed">
-        <source>MSB3173: Unable to write manifest '{0}'. {1}</source>
-        <target state="translated">MSB3173: '{0}'    . {1}</target>
+        <source>MSB3173: Unable to write manifest '{0}'. {1} {2}</source>
+        <target state="translated">MSB3173: '{0}'    . {1} {2}</target>
         <note>{StrBegin="MSB3173: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.InvalidRequestedExecutionLevel">
@@ -2175,11 +2180,6 @@
         <target state="translated">     "{0}" FileList  null       .     null    .</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">   "{0}"()  .</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM  '{0}'() ActiveX  '{1}'  interop  /link      .  COM     .</target>
@@ -2514,6 +2514,11 @@
         <target state="translated">MSB3353:       .</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
+      <trans-unit id="Task.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated"> "{0}"   .</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: "{0}"  MSBuild .NET Core   . MSBuild .NET Framework  .   https://aka.ms/msbuild/MSB4803 .</target>
@@ -3399,11 +3404,6 @@
         <target state="translated">MSB4801: MSBuild .NET Core  "{0}"    .</target>
         <note>{StrBegin="MSB4801: "}</note>
       </trans-unit>
-      <trans-unit id="Copy.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated"> "{0}"   .</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CodeTaskFactory.InvalidCodeType">
         <source>MSB3759: The specified code type "{0}" is invalid.  The supported code types are "{1}".</source>
         <target state="translated">MSB3759:    "{0}"() .    "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index a21fc7cd781..2f157a473aa 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: Mam {0} kopiowane z {1} do {2}, a HR to {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: parametry {0} i {1} zostay okrelone jako parametry w pliku projektu, ale nie mog by uywane razem. Wybierz jeden lub drugi.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Nie mona uy linku w celu skopiowania cieki {0} do cieki {1}.</target>
@@ -1055,8 +1060,8 @@
         <note>{StrBegin="MSB3183: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.WriteOutputManifestFailed">
-        <source>MSB3173: Unable to write manifest '{0}'. {1}</source>
-        <target state="translated">MSB3173: Nie mona zapisa manifestu '{0}'. {1}</target>
+        <source>MSB3173: Unable to write manifest '{0}'. {1} {2}</source>
+        <target state="translated">MSB3173: Nie mona zapisa manifestu {0}. {1} {2}</target>
         <note>{StrBegin="MSB3173: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.InvalidRequestedExecutionLevel">
@@ -2175,11 +2180,6 @@
         <target state="translated">Plik z list pakietw redystrybucyjnych {0} ma nazw Redist rwn null lub pust w elemencie FileList. Upewnij si, e nazwa Redist nie ma wartoci null ani nie jest pusta.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Aktualizowanie pliku pamici podrcznej zestawu {0}.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">Odwoanie COM {0} jest zestawem midzyoperacyjnym dla kontrolki ActiveX {1}, ale zostao wybrane do poczenia przez kompilator przy uyciu flagi /link. To odwoanie COM jest traktowane jako odwoanie i nie zostanie poczone.</target>
@@ -2514,6 +2514,11 @@
         <target state="translated">MSB3353: Klucz publiczny jest niezbdny, poniewa nie okrelono znaku opnienia.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
+      <trans-unit id="Task.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">Plik jest zablokowany przez: {0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: Zadanie {0} nie jest obsugiwane w wersji programu MSBuild dla platformy .NET Core. Uyj wersji programu MSBuild dla platformy .NET Framework. Zobacz https://aka.ms/msbuild/MSB4803, aby uzyska wicej szczegw.</target>
@@ -3399,11 +3404,6 @@
         <target state="translated">MSB4801: Fabryka zada {0} nie jest obsugiwana przez wersj programu MSBuild dla platformy .NET Core.</target>
         <note>{StrBegin="MSB4801: "}</note>
       </trans-unit>
-      <trans-unit id="Copy.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">Plik jest zablokowany przez: {0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CodeTaskFactory.InvalidCodeType">
         <source>MSB3759: The specified code type "{0}" is invalid.  The supported code types are "{1}".</source>
         <target state="translated">MSB3759: Okrelony typ kodu {0} jest nieprawidowy. Obsugiwane typy kodu: {1}.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 2cbac98a44a..8c515b96f45 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: Recebi {0} copiando "{1}" para {2} e o RH  {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: "{0}" e "{1}" foram especificados como parmetros no arquivo de projeto, mas no podem ser usados juntos. Escolha um ou outro.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: No foi possvel usar um link para copiar "{0}" para "{1}".</target>
@@ -1055,8 +1060,8 @@
         <note>{StrBegin="MSB3183: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.WriteOutputManifestFailed">
-        <source>MSB3173: Unable to write manifest '{0}'. {1}</source>
-        <target state="translated">MSB3173: No  possvel gravar o manifesto "{0}". {1}</target>
+        <source>MSB3173: Unable to write manifest '{0}'. {1} {2}</source>
+        <target state="new">MSB3173: Unable to write manifest '{0}'. {1} {2}</target>
         <note>{StrBegin="MSB3173: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.InvalidRequestedExecutionLevel">
@@ -2175,11 +2180,6 @@
         <target state="translated">O arquivo da lista de pacote redistribuvel "{0}" tem um nome de Pacote Redistribuvel nulo ou vazio no elemento FileList. Verifique se o Nome do Pacote Redistribuvel no  nulo nem est vazio.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Atualizando o arquivo de cache do assembly "{0}".</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">A Referncia COM "{0}"  o assembly de interoperabilidade para o controle ActiveX "{1}", mas foi marcada para ser vinculada pelo compilador com o sinalizador /link. Essa referncia COM ser tratada como uma referncia e no ser vinculada.</target>
@@ -2514,6 +2514,11 @@
         <target state="translated">MSB3353: Chave pblica necessria, pois a assinatura atrasada no foi especificada.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
+      <trans-unit id="Task.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">O arquivo  bloqueado por: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: a tarefa "{0}" no  compatvel com a verso do .NET Core do MSBuild. Use a verso do .NET Framework do MSBuild. Confira https://aka.ms/msbuild/MSB4803 para obter mais detalhes.</target>
@@ -3399,11 +3404,6 @@
         <target state="translated">MSB4801: no h suporte para a fbrica de tarefas "{0}" na verso .NET Core do MSBuild.</target>
         <note>{StrBegin="MSB4801: "}</note>
       </trans-unit>
-      <trans-unit id="Copy.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">O arquivo  bloqueado por: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CodeTaskFactory.InvalidCodeType">
         <source>MSB3759: The specified code type "{0}" is invalid.  The supported code types are "{1}".</source>
         <target state="translated">MSB3759: o tipo de cdigo especificado "{0}"  invlido. Os tipos de cdigo compatveis so "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 9f27ce3a87d..dde66c33b4a 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894:   {0} "{1}"  "{2}"  HR  {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: "{0}"  "{1}"       ,     .     .</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893:       "{0}"  "{1}".</target>
@@ -1055,8 +1060,8 @@
         <note>{StrBegin="MSB3183: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.WriteOutputManifestFailed">
-        <source>MSB3173: Unable to write manifest '{0}'. {1}</source>
-        <target state="translated">MSB3173:    "{0}". {1}</target>
+        <source>MSB3173: Unable to write manifest '{0}'. {1} {2}</source>
+        <target state="translated">MSB3173:    "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3173: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.InvalidRequestedExecutionLevel">
@@ -2175,11 +2180,6 @@
         <target state="translated">     "{0}"      FileList      NULL. ,     (Redist Name)      NULL.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">    "{0}".</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM- "{0}"      ActiveX "{1}",        /link.  COM-       .</target>
@@ -2514,6 +2514,11 @@
         <target state="translated">MSB3353:    ,    .</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
+      <trans-unit id="Task.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">"{0}"   </target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803:  "{0}"    MSBuild  .NET Core.  MSBuild  .NET Framework.  : https://aka.ms/msbuild/MSB4803.</target>
@@ -3399,11 +3404,6 @@
         <target state="translated">MSB4801:   "{0}"     .NETCore  MSBuild.</target>
         <note>{StrBegin="MSB4801: "}</note>
       </trans-unit>
-      <trans-unit id="Copy.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">"{0}"   </target>
-        <note />
-      </trans-unit>
       <trans-unit id="CodeTaskFactory.InvalidCodeType">
         <source>MSB3759: The specified code type "{0}" is invalid.  The supported code types are "{1}".</source>
         <target state="translated">MSB3759:    "{0}" .   : "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 0b59127f2b0..82e2c5c862c 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894: {0} iin {1} yolu {2} yoluna kopyaland ve HR: {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: "{0}" ve "{1}" proje dosyasnda parametre olarak belirtilmi ancak birlikte kullanlamaz. Ltfen birini veya dierini sein.</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: "{0}" dosyasn "{1}" yoluna kopyalama balants kullanlamad.</target>
@@ -1055,8 +1060,8 @@
         <note>{StrBegin="MSB3183: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.WriteOutputManifestFailed">
-        <source>MSB3173: Unable to write manifest '{0}'. {1}</source>
-        <target state="translated">MSB3173: '{0}' bildirimi yazlamyor. {1}</target>
+        <source>MSB3173: Unable to write manifest '{0}'. {1} {2}</source>
+        <target state="translated">MSB3173: '{0}' bildirimi yazlamyor. {1} {2}</target>
         <note>{StrBegin="MSB3173: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.InvalidRequestedExecutionLevel">
@@ -2175,11 +2180,6 @@
         <target state="translated">"{0}" yeniden datm liste dosyasnn FileList esindeki Redist ad null veya bo. Redist adnn null veya bo olmadndan emin olun.</target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">Derleme nbellei dosyas "{0}" gncelletiriliyor.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">'{0}' COM Bavurusu, '{1}' ActiveX denetiminin birlikte alma btnletirilmi kodu, ancak /link bayrayla derleyici tarafndan balanmak zere iaretlenmi. Bu COM bavurusu, bavuru olarak deerlendirilecek ve balanmayacak.</target>
@@ -2514,6 +2514,11 @@
         <target state="translated">MSB3353: Gecikmeli imzalama iin gerekli olan ortak anahtar belirtilmemi.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
+      <trans-unit id="Task.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">Dosya unun tarafndan kilitlendi: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: MSBuildin .NET Core srmnde "{0}" grevi desteklenmiyor. Ltfen MSBuildin .NET Framework srmn kullann. Daha ayrntl bilgi iin bkz. https://aka.ms/msbuild/MSB4803.</target>
@@ -3399,11 +3404,6 @@
         <target state="translated">MSB4801: "{0}" grev fabrikas, MSBuild .NET Core srmnde desteklenmiyor.</target>
         <note>{StrBegin="MSB4801: "}</note>
       </trans-unit>
-      <trans-unit id="Copy.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">Dosya unun tarafndan kilitlendi: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CodeTaskFactory.InvalidCodeType">
         <source>MSB3759: The specified code type "{0}" is invalid.  The supported code types are "{1}".</source>
         <target state="translated">MSB3759: Belirtilen "{0}" kod tr geersiz.  Desteklenen kod trleri unlardr: "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 8272b18a8a5..b32e3adb30b 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894:  "{1}"  "{2}"  {0}HR  {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: {0}{1}</target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: {0}{1}</target>
@@ -1055,8 +1060,8 @@
         <note>{StrBegin="MSB3183: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.WriteOutputManifestFailed">
-        <source>MSB3173: Unable to write manifest '{0}'. {1}</source>
-        <target state="translated">MSB3173: {0}{1}</target>
+        <source>MSB3173: Unable to write manifest '{0}'. {1} {2}</source>
+        <target state="translated">MSB3173: {0}{1} {2}</target>
         <note>{StrBegin="MSB3173: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.InvalidRequestedExecutionLevel">
@@ -2175,11 +2180,6 @@
         <target state="translated">{0} FileList  null  null </target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated">{0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM {0} ActiveX {1} /link  COM </target>
@@ -2514,6 +2514,11 @@
         <target state="translated">MSB3353: </target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
+      <trans-unit id="Task.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">{0}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: .NET Core  MSBuild {0} .NET Framework  MSBuild https://aka.ms/msbuild/MSB4803</target>
@@ -3399,11 +3404,6 @@
         <target state="translated">MSB4801: {0} MSBuild  .NET Core </target>
         <note>{StrBegin="MSB4801: "}</note>
       </trans-unit>
-      <trans-unit id="Copy.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">{0}</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CodeTaskFactory.InvalidCodeType">
         <source>MSB3759: The specified code type "{0}" is invalid.  The supported code types are "{1}".</source>
         <target state="translated">MSB3759: {0}{1}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index ef2d07887fa..00e0f257dd6 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -196,6 +196,11 @@
         <target state="translated">MSB3894:  {0}  "{1}"  "{2}" HR  {3}</target>
         <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
       </trans-unit>
+      <trans-unit id="Copy.IncompatibleParameters">
+        <source>MSB3896: Both "{0}" and "{1}" were specified as parameters in the project file but cannot be used together. Please choose one or the other.</source>
+        <target state="translated">MSB3896: "{0}"  "{1}" </target>
+        <note>{StrBegin="MSB3896: "}</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893:  "{0}"  "{1}"</target>
@@ -1055,8 +1060,8 @@
         <note>{StrBegin="MSB3183: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.WriteOutputManifestFailed">
-        <source>MSB3173: Unable to write manifest '{0}'. {1}</source>
-        <target state="translated">MSB3173:  '{0}'{1}</target>
+        <source>MSB3173: Unable to write manifest '{0}'. {1} {2}</source>
+        <target state="translated">MSB3173:  '{0}'{1} {2}</target>
         <note>{StrBegin="MSB3173: "}</note>
       </trans-unit>
       <trans-unit id="GenerateManifest.InvalidRequestedExecutionLevel">
@@ -2175,11 +2180,6 @@
         <target state="translated"> "{0}"  FileList  Redist  null  Redist  null </target>
         <note />
       </trans-unit>
-      <trans-unit id="ResolveAssemblyReference.WritingCacheFile">
-        <source>Updating assembly cache file "{0}".</source>
-        <target state="translated"> "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="ResolveComReference.TreatingTlbOfActiveXAsNonEmbedded">
         <source>COM Reference '{0}' is the interop assembly for ActiveX control '{1}' but was marked to be linked by the compiler with the /link flag. This COM reference will be treated as a reference and will not be linked.</source>
         <target state="translated">COM  '{0}'  ActiveX  '{1}'  Interop  /link  COM </target>
@@ -2514,6 +2514,11 @@
         <target state="translated">MSB3353: </target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
+      <trans-unit id="Task.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: MSBuild  .NET Core  "{0}" MSBuild  .NET Framework  https://aka.ms/msbuild/MSB4803</target>
@@ -3399,11 +3404,6 @@
         <target state="translated">MSB4801: MSBuild  .NET Core  "{0}"</target>
         <note>{StrBegin="MSB4801: "}</note>
       </trans-unit>
-      <trans-unit id="Copy.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="CodeTaskFactory.InvalidCodeType">
         <source>MSB3759: The specified code type "{0}" is invalid.  The supported code types are "{1}".</source>
         <target state="translated">MSB3759:  "{0}"    "{1}"</target>
diff --git a/src/Tasks/System.Resources.Extensions.pkgdef b/src/Tasks/System.Resources.Extensions.pkgdef
index 9315270511f..62579ad4643 100644
--- a/src/Tasks/System.Resources.Extensions.pkgdef
+++ b/src/Tasks/System.Resources.Extensions.pkgdef
@@ -4,4 +4,4 @@
 "publicKeyToken"="cc7b13ffcd2ddd51"
 "culture"="neutral"
 "oldVersion"="0.0.0.0-99.9.9.9"
-"newVersion"="7.0.0.0"
+"newVersion"="8.0.0.0"
