diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index df5f8f2bc6d..260f46914b1 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -209,6 +209,8 @@ jobs:
     condition: always()
 
 - job: MonoOnMac
+  # Mono CI disabled until it can parse C# 9 syntax: https://github.com/dotnet/msbuild/issues/6058
+  condition: eq(1,2)
   displayName: "macOS Mono"
   pool:
     vmImage: 'macOS-10.14'
diff --git a/NuGet.config b/NuGet.config
index 6a442ae4089..617e0f8a7ce 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -4,7 +4,7 @@
     <clear />
     <add key="dotnet-core" value="https://dotnetfeed.blob.core.windows.net/dotnet-core/index.json" />
     <add key="arcade" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json" />
-    <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
+    <add key="dotnet-public" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public/nuget/v3/index.json" />
     <add key="dotnet-tools" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json" />
   </packageSources>
   <disabledPackageSources />
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index f464ca17374..8f6a76fd036 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -61,6 +61,7 @@ If implementing a project with an “outer” (determine what properties to pass
   * The `GetReferenceNearestTargetFrameworkTask` (provided by NuGet) is responsible for selecting the best matching `TargetFramework` of the referenced project
   * This target is _optional_. If not present, the reference will be built with no additional properties.
   * **New** in MSBuild 15.5.  (`TargetFrameworkMonikers` and `TargetPlatformMonikers` metadata is new in MSBuild 16.8)
+  * It is possible to gather additional information from referenced projects.  See the below section on "Getting additional properties from referenced projects" for more information
 * `GetTargetFrameworkProperties` determines what properties should be passed to the “main” target for a given `ReferringTargetFramework`.
   * **Deprecated** in MSBuild 15.5.
   * New for MSBuild 15/Visual Studio 2017. Supports the cross-targeting feature allowing a project to have multiple `TargetFrameworks`.
@@ -91,3 +92,31 @@ As with all MSBuild logic, targets can be added to do other work with `ProjectRe
 In particular, NuGet depends on being able to identify referenced projects' package dependencies, and calls some targets that are imported through `Microsoft.Common.targets` to do so. At the time of writing this this is in [`NuGet.targets`](https://github.com/NuGet/NuGet.Client/blob/79264a74262354c1a8f899c2c9ddcaff58afaf62/src/NuGet.Core/NuGet.Build.Tasks/NuGet.targets).
 
 `Microsoft.AppxPackage.targets` adds a dependency on the target `GetPackagingOutputs`.
+
+## Getting additional properties from referenced projects
+
+As of MSBuild 16.10, it is possible to gather additional properties from referenced projects.  To do this, the referenced project should declare an `AdditionalTargetFrameworkInfoProperty` item for each property that should be gathered for referencing projects.  For example:
+
+```xml
+  <ItemGroup>
+    <AdditionalTargetFrameworkInfoProperty Include="SelfContained"/>
+    <AdditionalTargetFrameworkInfoProperty Include="_IsExecutable"/>
+  </ItemGroup>
+```
+
+These properties will then be gathered via the `GetTargetFrameworks` call.  They will be available to the referencing project via the `AdditionalPropertiesFromProject` metadata on the `_MSBuildProjectReferenceExistent` item.  The `AdditionalPropertiesFromProject` value will be an XML string which contains the values of the properties for each `TargetFramework` in the referenced project.  For example:
+
+```xml
+<AdditionalProjectProperties>
+  <net5.0>
+    <SelfContained>true</SelfContained>
+    <_IsExecutable>true</_IsExecutable>
+  </net5.0>
+  <net5.0-windows>
+    <SelfContained>false</SelfContained>
+    <_IsExecutable>true</_IsExecutable>
+  </net5.0-windows>
+</AdditionalProjectProperties>
+```
+
+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.
\ No newline at end of file
diff --git a/documentation/specs/static-graph-implementation-details.md b/documentation/specs/static-graph-implementation-details.md
new file mode 100644
index 00000000000..4845fff794d
--- /dev/null
+++ b/documentation/specs/static-graph-implementation-details.md
@@ -0,0 +1,59 @@
+- [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)
+  - [Input / Output cache implementation](#input--output-cache-implementation)
+  - [Isolation implementation](#isolation-implementation)
+    - [How isolation exemption complicates everything](#how-isolation-exemption-complicates-everything)
+
+# Single project isolated builds: implementation details
+
+<!-- workflow -->
+Single project isolated builds can be achieved by providing MSBuild with input and output cache files.
+
+The input cache files contain the cached results of all the targets that a project calls on its references. When a project builds without isolation, it builds its references via [MSBuild task](aka.ms/msbuild_tasks) calls. In isolated builds, the engine, instead of executing these tasks, serves their results from the provided input caches. In an isolated project build, only the top level project (built via the BuildManager APIs) should build targets. Any referenced projects by the top level project should be provided from the input caches.
+
+The output cache file tells MSBuild where to serialize the results of building the current project. This output cache becomes an input cache for all other projects that depend on the current project.
+The output cache file can be omitted in which case the build reuses prior results but does not write out any new results. This is useful when one wants to re-execute the build for a project without building its references.
+
+The presence of either input or output caches turns on [isolated build constraints](static-graph.md##single-project-isolated-builds).
+
+## Input / Output cache implementation
+<!-- cache structure -->
+The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which contain or more instances of [TargetResult](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22). 
+
+One can view the two caches as the following mapping: `(project path, global properties) -> results`. `(project path, global properties)` is represented by a `BuildRequestConfiguration`, and the results are represented by `BuildResult` and `TargetResult`.
+
+<!-- cache lifetime -->
+The input and output cache files have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On commandline builds, since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime. When other processes (e.g. Visual Studio's devenv.exe) perform msbuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.
+
+<!-- constraints -->
+
+When MSBuild is loading input cache files, it has to merge multiple incoming instances of `ConfigCache` and `ResultsCache` into one instance of each. The [CacheAggregator](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L13) is responsible for stitching together the pairs of deserialized `ConfigCache`/`ResultsCache` entries from each input cache file.
+The following constraints are enforced during cache aggregation:
+- For each input cache, `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
+- For each input cache, there is exactly one mapping from ConfigCache to ResultsCache (on `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`)
+- Colliding configurations (defined as tuples of `(project path, global properties)`) get their corresponding BuildResult entries merged at the level of TargetResult entries. TargetResult conflicts are handled via the "first one wins" strategy. This is in line with vanilla msbuild's behaviour where a target tuple of `(project path, global properties, target)` gets executed only once.
+
+The output cache file **only contains results for additional work performed in the current BeginBuild / EndBuild session**. Entries from input caches are not transferred to the output cache.
+
+<!-- How input / output cache entries are separated with the override caches -->
+Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache. The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.
+
+## Isolation implementation
+
+[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the Scheduler and the TaskBuilder. [TaskBuilder.ExecuteInstantiatedTask](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in `ProjectReference`. [Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.
+
+### How isolation exemption complicates everything
+<!-- Potential cache scenarios caused by exemption -->
+Project references [can be exempt](static-graph.md#exempting-references-from-isolation-constraints) from isolation constraints via the `GraphIsolationExemptReference` item.
+
+The `Scheduler` knows to skip isolation constraints on an exempt `BuildRequest` because the [ProjectBuilder compares](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs#L349) each new `BuildRequest` against the `GraphIsolationExemptReference` items defined in the calling project, and if exempt, sets `BuildRequest.SkipStaticGraphIsolationConstraints`. When a `BuildRequest` is marked as exempt, the `Scheduler` also marks its corresponding `BuildRequestConfiguration` as exempt as well, which aids in further identification of exempt projects outside the `Scheduler`.
+
+The build results for the exempt project are also included in the current cache (according to the above mentioned rule that newly built results are serialized in the output cache file). This complicates the way caches interact in several scenarios:
+1. the same project can be exempt via multiple references, thus potentially colliding when multiple output cache files containing the same exempt project get aggregated. For example, given the graph `{A->B, A->C}`, where both `B` and `C` build the exempt project `D`, `D` will appear in the output caches of both `B` and `C`. When `A` aggregates these two caches, it will encounter duplicate entries for `D`, and will need to merge the results.
+2. a project can be both exempt and present in the graph at the same time. For example, given the graph `{A->B}`, both `A` and `B` are in the graph, but `A` can also mark `B` as exempt (meaning that `A` contains both a `ProjectReference` item to `B`, and a `GraphIsolationExemptReference` item to `B`). The fact that `B` is in the graph means that `A` will receive an input cache containing B's build results. There are two subcases here:
+   1.  `A` builds targets from `B` that already exist in the input cache file from `B`. In this case, all the builds of `B` will be cache hits, and no target results from `B` will make it into `A`'s output cache, since nothing new was built.
+   2.  `A` builds targets from `B` that do not exist in the input cache file from `B`. If `B` weren't exempt from isolation constraints, this scenario would lead to a build break, as cache misses are illegal under isolation. With `B` being exempt, the new builds of `B` will get included in `A`'s output cache. The results from `B`'s cache file won't get included in `A`'s output cache file, as they weren't built by `A`.
+3. A project, which is not in the graph, can be exempt by two parent/child projects from the graph. For example, given the graph `{A->B}`, both `A` and `B` can exempt project `D` (meaning that neither `A` nor `B` have a `ProjectReference` to `D`, but both `A` and `B` have a `GraphIsolationExemptReference` to `D`). The fact that `B` is in the graph means that `A` will receive an input cache containing `B`'s build results. Since `B` builds targets from `D`, it means that `B`'s output cache file also contains target results from `D`. There are two subcases here:
+   1. `A` builds targets from `D` that already exist in the input cache file from `B`. This is handled in the same way as the above case `2.1.`
+   2. `A` builds targets from `D` that do not exist in the input cache file from `B`, meaning that `A` builds additional targets from `D` which `B` didn't build. This is handled in the same way as teh above case `2.2.`
+
+**Current issue:** if multiple nodes in the graph exempt the same project file, the build results of the exempt project will trickle up and conflict in the first parent that tries to merge them. Documented in issue [#4386](https://github.com/dotnet/msbuild/issues/4386).
diff --git a/documentation/specs/static-graph.md b/documentation/specs/static-graph.md
index 240db807df2..6e4527a7470 100644
--- a/documentation/specs/static-graph.md
+++ b/documentation/specs/static-graph.md
@@ -9,9 +9,12 @@
   - [Design documentation](#design-documentation)
     - [Design goals](#design-goals)
   - [Project Graph](#project-graph)
+    - [Constructing the project graph](#constructing-the-project-graph)
     - [Build dimensions](#build-dimensions)
       - [Multitargeting](#multitargeting)
-    - [Building a project graph](#building-a-project-graph)
+    - [Executing targets on a graph](#executing-targets-on-a-graph)
+      - [Command line](#command-line)
+      - [APIs](#apis)
     - [Inferring which targets to run for a project within the graph](#inferring-which-targets-to-run-for-a-project-within-the-graph)
       - [Multitargeting details](#multitargeting-details)
     - [Underspecified graphs](#underspecified-graphs)
@@ -19,9 +22,9 @@
   - [Isolated builds](#isolated-builds)
     - [Isolated graph builds](#isolated-graph-builds)
     - [Single project isolated builds](#single-project-isolated-builds)
-    - [Single project isolated builds: implementation details](#single-project-isolated-builds-implementation-details)
-      - [APIs](#apis)
-      - [Command line](#command-line)
+      - [APIs](#apis-1)
+      - [Command line](#command-line-1)
+      - [Exempting references from isolation constraints](#exempting-references-from-isolation-constraints)
   - [I/O Tracking](#io-tracking)
     - [Detours](#detours)
     - [Isolation requirement](#isolation-requirement)
@@ -112,11 +115,15 @@ Static graph functionality can be used in three ways:
 
 ## Project Graph
 
+### Constructing the project graph
 Calculating the project graph will be very similar to the MS internal build engine's existing Traversal logic. For a given evaluated project, all project references will be identified and recursively evaluated (with deduping).
 Project references are identified via the `ProjectReference` item.
 
 A node in the graph is a tuple of the project file and global properties. Each (project, global properties) combo can be evaluated in parallel.
 
+Transitive project references are opt-in per project. Once a project opts-in, transitivity is applied for all ProjectReference items.
+A project opt-ins by setting the property `AddTransitiveProjectReferencesInStaticGraph` to true.
+
 ### Build dimensions
 
 Build dimensions can be thought of as different ways to build a particular project. For example, a project can be built Debug or Retail, x86 or x64, for .NET Framework 4.7.1 or .NET Core 2.0.
@@ -179,7 +186,7 @@ To summarize, there are two main patterns for build dimensions which are handled
 1. The project multitargets, in which case the SDK needs to specify the multitargeting build dimensions.
 2. A different set of global properties are used to choose the dimension like with Configuration or Platform. The project graph supports this via multiple entry points.
 
-### Building a project graph
+### Executing targets on a graph
 When building a graph, project references should be built before the projects that reference them, as opposed to the existing msbuild scheduler which builds projects just in time.
 
 For example if project A depends on project B, then project B should build first, then project A. Existing msbuild scheduling would start building project A, reach an MSBuild task for project B, yield project A, build project B, then resume project A once unblocked.
@@ -188,6 +195,13 @@ Building in this way should make better use of parallelism as all CPU cores can
 
 Note that graph cycles are disallowed, even if they're using disconnected targets. This is a breaking change, as today you can have two projects where each project depends on a target from the other project, but that target doesn't depend on the default target or anything in its target graph.
 
+#### Command line
+`msbuild /graph` - msbuild will create a static graph from the entry point project and build it in topological order with the specified targets. Targets to call on each node are inferred via the rules in [this section](#inferring-which-targets-to-run-for-a-project-within-the-graph).
+
+#### APIs
+
+[BuildManager.PendBuildRequest(GraphBuildRequestData requestData)](https://github.com/microsoft/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/BuildManager.cs#L676)
+
 ### Inferring which targets to run for a project within the graph
 In the classic traversal, the referencing project chooses which targets to call on the referenced projects and may call into a project multiple times with different target lists and global properties (examples in [project reference protocol](../ProjectReference-Protocol.md)). When building a graph, where projects are built before the projects that reference them, we have to determine the target list to execute on each project statically.
 
@@ -375,56 +389,50 @@ Because referenced projects and their entry targets are guaranteed to be in the
 ### Isolated graph builds
 When building a graph in isolated mode, the graph is used to traverse and build the projects in the right order, but each individual project is built in isolation. The build result cache will just be in memory exactly as it is today, but on cache miss it will error. This enforces that both the graph and target mappings are complete and correct.
 
-Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.
+Furthermore, running in this mode enforces that each (project, global properties) pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.
 
 This discrete start and end time also allows for easy integration with [I/O Tracking](#io-tracking) to observe all inputs and outputs for a project. Note however that I/O during target execution, particular target execution which may not normally happen as part of a project's individual build execution, would be attributed to the project reference project rather the project with the project reference. This differs from today's behavior, but seems like a desirable difference anyway.
 
 ### Single project isolated builds
 When building a single project in isolation, all project references' build results must be provided to the project externally. Specifically, the results will need to be [deserialized](#deserialization) from files and loaded into the build result cache in memory.
 
-Because of this, single project isolated builds is quite restrictive and is not intended to be used directly by end-users. Instead the scenario is intended for higher-order build engines which support caching and [distribution](#distribution).
-
-There is also the possibility for these higher-order build engines and even Visual Studio to enable extremely fast incremental builds for a project. For example, when all project references' build results are provided (and validated as up to date by that higher-order build engine), there is no need to evaluate or execute any targets on any other project.
-
-These incremental builds can even be extended to multiple projects by keeping a project graph in memory as well as the last build result for each node and whether that build result is valid. The higher-order build engine can then itself traverse the graph and do single project isolated builds for projects which are not currently up to date.
+When MSBuild runs in isolation mode, it fails the build when it detects:
+1. `MSBuild` task calls which cannot be served from the cache. Cache misses are illegal.
+2. `MSBuild` task calls to project files which were not defined in the `ProjectReference` item.
 
-### Single project isolated builds: implementation details
-
-<!-- workflow -->
-Single project builds can be achieved by providing MSBuild with input and output cache files.
+Because of this, single project isolated builds is quite restrictive and is not intended to be used directly by end-users. Instead the scenario is intended for higher-order build engines which support caching and [distribution](#distribution).
 
-The input cache files contain the cached results of all of the current project's references. This way, when the current project executes, it will naturally build its references via [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) calls. The engine, instead of executing these tasks, will serve them from the provided input caches.
+There is also the possibility for these higher-order build engines and even Visual Studio to enable faster incremental builds for a project. For example, when a project's references' build results are provided via file caches (and validated as up to date by that higher-order build engine), there is no need to evaluate or execute any targets for any reference.
 
-The output cache file tells MSBuild where it should serialize the results of the current project. This output cache would become an input cache for all other projects that depend on the current project.
-The output cache file can be ommited in which case the build would just reuse prior results but not write out any new results. This could be useful when one wants to replay a build from previous caches.
+These incremental builds could be extended to the entire graph by keeping a project graph in memory as well as the last build result cache files for each node and whether a node's results are up to date. The higher-order build engine can then itself traverse the graph and do single project isolated builds only for projects which are not currently up to date.
 
-The presence of either input or output caches turns on the isolated build constraints. The engine will fail the build on:
-- `MSBuild` task calls to project files which were not defined in the `ProjectReference` item at evaluation time.
-- `MSBuild` task calls which cannot be served from the cache
+Details on how isolation and cache files are implemented in MSBuild can be found [here](./static-graph-implementation-details.md).
 
-<!-- cache structure -->
-These cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results.
+#### APIs
+Cache file information is provided via [BuildParameters](https://github.com/Microsoft/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). Input caches are applied in `BuildManager.BeginBuild`. Output cache files are written in `BuildManager.EndBuild`. Thus, the scope of the caches are one BuildManager BeginBuild/EndBuild session.
 
-Cache structure: `(project path, global properties) -> results`
+Isolation constraints are turned on via [BuildParameters.IsolateProjects](https://github.com/microsoft/msbuild/blob/b111470ae61eba02c6102374c2b7d62aebe45f5b/src/Build/BackEnd/BuildManager/BuildParameters.cs#L742). Isolation constraints are also automatically turned on if either input or output cache files are used.
 
-<!-- cache lifetime -->
-The caches are applicable for the entire duration of the MSBuild.exe process. The input and output caches have the same lifetime as the `ConfigCache` and the `ResultsCache`. The `ConfigCache` and the `ResultsCache` are owned by the [BuildManager](https://github.com/Microsoft/msbuild/blob/master/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. Since MSBuild.exe uses one BuildManager with one BeginBuild / EndBuild session, the cache lifetime is the same as the entire process lifetime.
+#### Command line
+Caches are provided to MSBuild.exe via the multi value `/inputResultsCaches` and the single value `/outputResultsCache`.
+Isolation constraints are turned on via `/isolate` (they are also implicitly activated when either input or output caches are used).
 
-<!-- constraints -->
-The following are cache file constraints enforced by the engine.
+#### Exempting references from isolation constraints
+In certain situations one may want to exempt a reference from isolation constraints. A few potential cases:
+- debugging / onboarding to isolation constraints
+- exempting references whose project files are generated at build times with random names (for example, each WPF project, before the Build target, generates and builds a helper .csproj with a random file name)
+- relaxing constraints for MSBuild task calling patterns that static graph cannot express (for exemple, if a project is calculating references, or the targets to call on references, at runtime via an arbitrary algorithm)
 
-Input cache files constraints:
-- A ConfigCache / ResultsCache mapping must be unique between all input caches (multiple input caches cannot provide information for the same cache entry)
-- For each input cache, `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
-- For each input cache, there is exactly one mapping from ConfigCache to ResultsCache
+A project is exempt from isolation constraints by adding its full path to the `GraphIsolationExemptReference` item. For example, if project A.csproj references project B.csproj, the following snippet exempts B.csproj from isolation constraints while A.csproj is built:
+```xml
+<ItemGroup>
+  <GraphIsolationExemptReference Include="/Full/Path/To/B.csproj" />
+</ItemGroup>
+```
 
-Output cache file constraints:
-- the output cache file contains results only for additional work performed in the current BeginBuild / EndBuild session. Entries from input caches are not transferred to the output cache.
+A reference is exempt only in projects that add the reference in `GraphIsolationExemptReference`. If multiple projects need to exempt the same reference, all of them need to add the reference to `GraphIsolationExemptReference`.
 
-#### APIs
-Caches are provided via [BuildParameters](https://github.com/Microsoft/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). They are applied in `BuildManager.BeginBuild`
-#### Command line
-Caches are provided to MSBuild.exe via the multi value `/inputResultsCaches` and the single value `/outputResultsCache`.
+For now, self-builds (a project building itself with different global properties) are also exempt from isolation constraints, but this behaviour is of dubious value and might be changed in the future.
 
 ## I/O Tracking
 To help facilitate caching of build outputs by a higher-order build engine, MSBuild needs to track all I/O that happens as part of a build.
diff --git a/documentation/specs/threading.md b/documentation/specs/threading.md
new file mode 100644
index 00000000000..935e96cf141
--- /dev/null
+++ b/documentation/specs/threading.md
@@ -0,0 +1,17 @@
+# Threading in MSBuild Worker Nodes
+
+MSBuild can build multiple projects in parallel with the `-m` switch. This launches many worker processes (**nodes**) and assigns work to them. Each is generally dedicated to building a single project at a time.
+
+Projects can have dependencies on other projects. This is often represented with `@(ProjectReference)` items, but can be more complex--a dependency is created when a task calls the `IBuildEngine.BuildProjectFile` method or an equivalent. When this happens, the project is _blocked_: it cannot progress until the request it generated is built.
+
+While a project is blocked, the node that was building it can do work on other projects. The build engine will save project-specific state like environment variables and current working directory and then do something else (if the scheduler has work to assign to it).
+
+This is logically single-threaded, via a continuation model: a node is building a single chain of things, which may be suspended and continued after building another project in the same thread. The thread used to do this work is named `RequestBuilder thread`. It is not the main thread of the process because some other work goes on in parallel, like inter-process communication.
+
+It is sometimes useful to be able to do computational work within one project while *also* freeing up the node to do work on another project. When this is desired, a task can call `IBuildEngine3.Yield()` to indicate that the node can do other work until it calls `IBuildEngine3.Reacquire()`.
+
+When a project is _yielded_, the node is also yielded. The scheduler may then decide to assign additional work to the node. If it does so, the node will start a new RequestBuilder thread to do the new work, because the original thread will still be running the task code between `Yield()` and `Reacquire()`.
+
+The scheduler limits the amount of total work being done, including both executing and yielded nodes, to attempt to avoid starting too much parallel work and bogging down the operating system. As a result, it's rare for a single node to have more than two or three RequestBuilder threads, though there is no hard bound on the number of threads in a single node.
+
+If multiple RequestBuilder threads have been started and are idle in a single worker node, any of them may be used when a request is assigned to that node (or unblocked).
diff --git a/eng/Packages.props b/eng/Packages.props
index 30ae007906c..71606f3f644 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -17,23 +17,11 @@
     <PackageReference Update="Shouldly" Version="3.0.0" />
     <PackageReference Update="SourceLink.Create.CommandLine" Version="2.1.2" />
     <PackageReference Update="System.CodeDom" Version="4.4.0" />
-    <PackageReference Update="System.Collections.Concurrent" Version="4.3.0" />
     <PackageReference Update="System.Collections.Immutable" Version="5.0.0" />
-    <PackageReference Update="System.Diagnostics.TraceSource" Version="4.0.0" />
-    <PackageReference Update="System.IO.Compression" Version="4.3.0" />
-    <PackageReference Update="System.IO.FileSystem.Primitives" Version="4.3.0" />
-    <PackageReference Update="System.Linq.Parallel" Version="4.0.1" />
     <PackageReference Update="System.Memory" Version="4.5.4" />
-    <PackageReference Update="System.Net.Http" Version="4.3.4" />
     <PackageReference Update="System.Reflection.Metadata" Version="1.6.0" />
-    <PackageReference Update="System.Reflection.TypeExtensions" Version="4.1.0" />
     <PackageReference Update="System.Resources.Extensions" Version="4.6.0" />
-    <PackageReference Update="System.Resources.Writer" Version="4.0.0" />
     <PackageReference Update="System.Runtime.CompilerServices.Unsafe" Version="5.0.0"/>
-    <PackageReference Update="System.Runtime.InteropServices" Version="4.3.0" />
-    <PackageReference Update="System.Runtime.InteropServices.RuntimeInformation" Version="4.3.0" />
-    <PackageReference Update="System.Runtime.Loader" Version="4.0.0" />
-    <PackageReference Update="System.Runtime.Serialization.Primitives" Version="4.1.1" />
     <PackageReference Update="System.Security.Cryptography.Pkcs" Version="4.7.0" />
     <PackageReference Update="System.Security.Cryptography.Xml" Version="4.7.0" />
     <PackageReference Update="System.Security.Permissions" Version="4.7.0" />
@@ -41,8 +29,6 @@
     <PackageReference Update="System.Text.Encoding.CodePages" Version="4.0.1" />
     <PackageReference Update="System.Text.Json" Version="4.7.0" />
     <PackageReference Update="System.Threading.Tasks.Dataflow" Version="4.9.0" />
-    <PackageReference Update="System.Threading.Thread" Version="4.0.0" />
-    <PackageReference Update="System.Xml.XPath" Version="4.3.0" />
     <PackageReference Update="xunit.assert" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.console" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.core" Version="$(XUnitVersion)" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 9b1550fa2f0..e4df6cc23fc 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -5,9 +5,9 @@
       <Uri>https://github.com/dotnet/arcade</Uri>
       <Sha>6813f5aa511a7a4498fa217a54219b5704a01f83</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="5.9.0-preview.3.7016">
-      <Uri>https://github.com/NuGet/NuGet.Client</Uri>
-      <Sha>719f110bf31709b7f8bdf1ab74024450936d866c</Sha>
+    <Dependency Name="NuGet.Build.Tasks" Version="5.9.0-rc.7097">
+      <Uri>https://dev.azure.com/devdiv/DevDiv/_git/NuGet-NuGet.Client-Trusted</Uri>
+      <Sha>ed9af679b4425c1ff4d41d2302d73f6e580a2839</Sha>
     </Dependency>
     <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="3.9.0-2.20574.26">
       <Uri>https://github.com/dotnet/roslyn</Uri>
diff --git a/eng/Versions.props b/eng/Versions.props
index 1d46a43d11b..3916d33cc6a 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -27,7 +27,7 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>5.0.102</DotNetCliVersion>
     <MicrosoftNetCompilersToolsetVersion>3.9.0-2.20574.26</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>5.9.0-preview.3.7016</NuGetBuildTasksVersion>
+    <NuGetBuildTasksVersion>5.9.0-rc.7097</NuGetBuildTasksVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/common/templates/post-build/post-build.yml b/eng/common/templates/post-build/post-build.yml
index 753c6d295b4..88044aebf1a 100644
--- a/eng/common/templates/post-build/post-build.yml
+++ b/eng/common/templates/post-build/post-build.yml
@@ -66,6 +66,7 @@ parameters:
   VS168ChannelId: 1154
   VSMasterChannelId: 1012
   VS169ChannelId: 1473
+  VS1610ChannelId: 1692
 
 stages:
 - stage: Validate
@@ -94,7 +95,7 @@ stages:
           inputs:
             filePath: $(Build.SourcesDirectory)/eng/common/post-build/check-channel-consistency.ps1
             arguments: -PromoteToChannels "$(TargetChannels)"
-              -AvailableChannelIds ${{parameters.NetEngLatestChannelId}},${{parameters.NetEngValidationChannelId}},${{parameters.NetDev5ChannelId}},${{parameters.NetDev6ChannelId}},${{parameters.GeneralTestingChannelId}},${{parameters.NETCoreToolingDevChannelId}},${{parameters.NETCoreToolingReleaseChannelId}},${{parameters.NETInternalToolingChannelId}},${{parameters.NETCoreExperimentalChannelId}},${{parameters.NetEngServicesIntChannelId}},${{parameters.NetEngServicesProdChannelId}},${{parameters.Net5Preview8ChannelId}},${{parameters.Net5RC1ChannelId}},${{parameters.Net5RC2ChannelId}},${{parameters.NetCoreSDK313xxChannelId}},${{parameters.NetCoreSDK313xxInternalChannelId}},${{parameters.NetCoreSDK314xxChannelId}},${{parameters.NetCoreSDK314xxInternalChannelId}},${{parameters.VS166ChannelId}},${{parameters.VS167ChannelId}},${{parameters.VS168ChannelId}},${{parameters.VSMasterChannelId}},${{parameters.VS169ChannelId}}
+              -AvailableChannelIds ${{parameters.NetEngLatestChannelId}},${{parameters.NetEngValidationChannelId}},${{parameters.NetDev5ChannelId}},${{parameters.NetDev6ChannelId}},${{parameters.GeneralTestingChannelId}},${{parameters.NETCoreToolingDevChannelId}},${{parameters.NETCoreToolingReleaseChannelId}},${{parameters.NETInternalToolingChannelId}},${{parameters.NETCoreExperimentalChannelId}},${{parameters.NetEngServicesIntChannelId}},${{parameters.NetEngServicesProdChannelId}},${{parameters.Net5Preview8ChannelId}},${{parameters.Net5RC1ChannelId}},${{parameters.Net5RC2ChannelId}},${{parameters.NetCoreSDK313xxChannelId}},${{parameters.NetCoreSDK313xxInternalChannelId}},${{parameters.NetCoreSDK314xxChannelId}},${{parameters.NetCoreSDK314xxInternalChannelId}},${{parameters.VS166ChannelId}},${{parameters.VS167ChannelId}},${{parameters.VS168ChannelId}},${{parameters.VSMasterChannelId}},${{parameters.VS169ChannelId}},${{parameters.VS1610ChannelId}}
 
   - job:
     displayName: NuGet Validation
@@ -620,3 +621,18 @@ stages:
       transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
       shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
       symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
+
+  - template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+    parameters:
+      BARBuildId: ${{ parameters.BARBuildId }}
+      PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
+      artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+      dependsOn: ${{ parameters.publishDependsOn }}
+      publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+      symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+      stageName: 'VS16_10_Publishing'
+      channelName: 'VS 16.10'
+      channelId: ${{ parameters.VS1610ChannelId }}
+      transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-transport/nuget/v3/index.json'
+      shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json'
+      symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools-symbols/nuget/v3/index.json'
diff --git a/eng/config/OptProf.json b/eng/config/OptProf.json
index 53061450ff8..9f2887b156e 100644
--- a/eng/config/OptProf.json
+++ b/eng/config/OptProf.json
@@ -14,13 +14,13 @@
           "container": "MSBuild",
           "testCases": [
             "MSBuild.Managed.vs_perf_designtime_commandline_msbuild_cs_mstv_fullbuild",
-            "MSBuild.Managed.vs_perf_designtime_commandline_msbuild_cs_mstv_fullbuild_4proc",
+            "MSBuild.Managed.vs_perf_designtime_commandline_msbuild_cs_mstv_fullbuild_4proc"
           ]
         },
         {
           "container": "ManagedLangs",
           "testCases": [
-            "ManagedLangs.OptProfTests.DDRIT_RPS_ManagedLangs"
+            "VSPE.OptProfTests.DDRIT_RPS_ManagedLangs_Debug"
           ]
         }  
       ]
diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index dc26ebeb9ba..719440bead7 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -157,6 +157,24 @@ public CombinePath() { }
         public Microsoft.Build.Framework.ITaskItem[] Paths { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public partial class CombineTargetFrameworkInfoProperties : Microsoft.Build.Tasks.TaskExtension
+    {
+        public CombineTargetFrameworkInfoProperties() { }
+        public Microsoft.Build.Framework.ITaskItem[] PropertiesAndValues { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public string Result { get { throw null; } set { } }
+        public string RootElementName { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
+    public partial class CombineXmlElements : Microsoft.Build.Tasks.TaskExtension
+    {
+        public CombineXmlElements() { }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public string Result { get { throw null; } set { } }
+        public string RootElementName { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] XmlElements { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public partial class CommandLineBuilderExtension : Microsoft.Build.Utilities.CommandLineBuilder
     {
         public CommandLineBuilderExtension() { }
@@ -1217,6 +1235,8 @@ public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microso
         public Unzip() { }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }
+        public string Exclude { get { throw null; } set { } }
+        public string Include { get { throw null; } set { } }
         public bool OverwriteReadOnlyFiles { get { throw null; } set { } }
         public bool SkipUnchangedFiles { get { throw null; } set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 0d85a2cc928..5bd884463da 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -87,6 +87,24 @@ public CombinePath() { }
         public Microsoft.Build.Framework.ITaskItem[] Paths { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public partial class CombineTargetFrameworkInfoProperties : Microsoft.Build.Tasks.TaskExtension
+    {
+        public CombineTargetFrameworkInfoProperties() { }
+        public Microsoft.Build.Framework.ITaskItem[] PropertiesAndValues { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public string Result { get { throw null; } set { } }
+        public string RootElementName { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
+    public partial class CombineXmlElements : Microsoft.Build.Tasks.TaskExtension
+    {
+        public CombineXmlElements() { }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public string Result { get { throw null; } set { } }
+        public string RootElementName { get { throw null; } set { } }
+        public Microsoft.Build.Framework.ITaskItem[] XmlElements { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public partial class CommandLineBuilderExtension : Microsoft.Build.Utilities.CommandLineBuilder
     {
         public CommandLineBuilderExtension() { }
@@ -894,6 +912,8 @@ public sealed partial class Unzip : Microsoft.Build.Tasks.TaskExtension, Microso
         public Unzip() { }
         [Microsoft.Build.Framework.RequiredAttribute]
         public Microsoft.Build.Framework.ITaskItem DestinationFolder { get { throw null; } set { } }
+        public string Exclude { get { throw null; } set { } }
+        public string Include { get { throw null; } set { } }
         public bool OverwriteReadOnlyFiles { get { throw null; } set { } }
         public bool SkipUnchangedFiles { get { throw null; } set { } }
         [Microsoft.Build.Framework.RequiredAttribute]
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 3b2268d29e2..3619a7a0852 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -1545,6 +1545,21 @@ public static partial class MSBuildGlobExtensions
 }
 namespace Microsoft.Build.Graph
 {
+    public partial class GraphBuildOptions : System.IEquatable<Microsoft.Build.Graph.GraphBuildOptions>
+    {
+        public GraphBuildOptions() { }
+        protected GraphBuildOptions(Microsoft.Build.Graph.GraphBuildOptions original) { }
+        public bool Build { get { throw null; } set { } }
+        protected virtual System.Type EqualityContract { get { throw null; } }
+        public virtual bool Equals(Microsoft.Build.Graph.GraphBuildOptions other) { throw null; }
+        public override bool Equals(object obj) { throw null; }
+        public override int GetHashCode() { throw null; }
+        public static bool operator ==(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
+        public static bool operator !=(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
+        protected virtual bool PrintMembers(System.Text.StringBuilder builder) { throw null; }
+        public override string ToString() { throw null; }
+        public virtual Microsoft.Build.Graph.GraphBuildOptions <Clone>$() { throw null; }
+    }
     public sealed partial class GraphBuildRequestData
     {
         public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild) { }
@@ -1556,9 +1571,11 @@ public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projec
         public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild) { }
         public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
+        public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Graph.GraphBuildOptions graphBuildOptions) { }
         public GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
         public Microsoft.Build.Execution.BuildRequestDataFlags Flags { get { throw null; } }
+        public Microsoft.Build.Graph.GraphBuildOptions GraphBuildOptions { get { throw null; } }
         public Microsoft.Build.Execution.HostServices HostServices { get { throw null; } }
         public Microsoft.Build.Graph.ProjectGraph ProjectGraph { get { throw null; } }
         public System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> ProjectGraphEntryPoints { get { throw null; } }
@@ -1659,9 +1676,10 @@ public BinaryLogReplayEventSource() { }
         public void Replay(string sourceFilePath) { }
         public void Replay(string sourceFilePath, System.Threading.CancellationToken cancellationToken) { }
     }
-    public partial class BuildEventArgsReader
+    public partial class BuildEventArgsReader : System.IDisposable
     {
         public BuildEventArgsReader(System.IO.BinaryReader binaryReader, int fileFormatVersion) { }
+        public void Dispose() { }
         public Microsoft.Build.Framework.BuildEventArgs Read() { throw null; }
     }
     public delegate void ColorResetter();
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index 2d8bde06715..2d5246af021 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -1539,6 +1539,21 @@ public static partial class MSBuildGlobExtensions
 }
 namespace Microsoft.Build.Graph
 {
+    public partial class GraphBuildOptions : System.IEquatable<Microsoft.Build.Graph.GraphBuildOptions>
+    {
+        public GraphBuildOptions() { }
+        protected GraphBuildOptions(Microsoft.Build.Graph.GraphBuildOptions original) { }
+        public bool Build { get { throw null; } set { } }
+        protected virtual System.Type EqualityContract { get { throw null; } }
+        public virtual bool Equals(Microsoft.Build.Graph.GraphBuildOptions other) { throw null; }
+        public override bool Equals(object obj) { throw null; }
+        public override int GetHashCode() { throw null; }
+        public static bool operator ==(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
+        public static bool operator !=(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
+        protected virtual bool PrintMembers(System.Text.StringBuilder builder) { throw null; }
+        public override string ToString() { throw null; }
+        public virtual Microsoft.Build.Graph.GraphBuildOptions <Clone>$() { throw null; }
+    }
     public sealed partial class GraphBuildRequestData
     {
         public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild) { }
@@ -1550,9 +1565,11 @@ public GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projec
         public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild) { }
         public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
+        public GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Graph.GraphBuildOptions graphBuildOptions) { }
         public GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
         public Microsoft.Build.Execution.BuildRequestDataFlags Flags { get { throw null; } }
+        public Microsoft.Build.Graph.GraphBuildOptions GraphBuildOptions { get { throw null; } }
         public Microsoft.Build.Execution.HostServices HostServices { get { throw null; } }
         public Microsoft.Build.Graph.ProjectGraph ProjectGraph { get { throw null; } }
         public System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> ProjectGraphEntryPoints { get { throw null; } }
@@ -1653,9 +1670,10 @@ public BinaryLogReplayEventSource() { }
         public void Replay(string sourceFilePath) { }
         public void Replay(string sourceFilePath, System.Threading.CancellationToken cancellationToken) { }
     }
-    public partial class BuildEventArgsReader
+    public partial class BuildEventArgsReader : System.IDisposable
     {
         public BuildEventArgsReader(System.IO.BinaryReader binaryReader, int fileFormatVersion) { }
+        public void Dispose() { }
         public Microsoft.Build.Framework.BuildEventArgs Read() { throw null; }
     }
     public delegate void ColorResetter();
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index 3135035b20b..b09519f9f71 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -212,6 +212,14 @@ private void SimpleP2PBuild(BuildParameters buildParameters)
                 .ShouldBe(3);
         }
 
+        [Fact]
+        public void GraphBuildOptionsDefaults()
+        {
+            var options = new GraphBuildOptions();
+
+            options.Build.ShouldBeTrue();
+        }
+
         /// <summary>
         /// A simple successful graph build.
         /// </summary>
@@ -4279,5 +4287,35 @@ public void GraphBuildCircular()
             result.OverallResult.ShouldBe(BuildResultCode.Failure);
             result.CircularDependency.ShouldBeTrue();
         }
+
+        [Fact]
+        public void GraphBuildShouldBeAbleToConstructGraphButSkipBuild()
+        {
+            var graph = Helpers.CreateProjectGraph(env: _env, dependencyEdges: new Dictionary<int, int[]> {{1, new[] {2, 3}}});
+
+            MockLogger logger = null;
+
+            using (var buildSession = new Helpers.BuildManagerSession(_env))
+            {
+                var graphResult = buildSession.BuildGraphSubmission(
+                    new GraphBuildRequestData(
+                        projectGraphEntryPoints: new[] {new ProjectGraphEntryPoint(graph.GraphRoots.First().ProjectInstance.FullPath)},
+                        targetsToBuild: new string[0],
+                        hostServices: null,
+                        flags: BuildRequestDataFlags.None,
+                        graphBuildOptions: new GraphBuildOptions {Build = false}));
+
+                graphResult.OverallResult.ShouldBe(BuildResultCode.Success);
+                logger = buildSession.Logger;
+            }
+
+            logger.EvaluationStartedEvents.Count.ShouldBe(3);
+            logger.ProjectStartedEvents.ShouldBeEmpty();
+            logger.TargetStartedEvents.ShouldBeEmpty();
+            logger.BuildStartedEvents.ShouldHaveSingleItem();
+            logger.BuildFinishedEvents.ShouldHaveSingleItem();
+            logger.FullLog.ShouldContain("Static graph loaded in");
+            logger.FullLog.ShouldContain("3 nodes, 2 edges");
+        }
     }
 }
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index ca2de8f8f3b..afd56aea915 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -513,7 +513,7 @@ public void ReadingCorruptedStreamThrows()
                 memoryStream.Position = 0;
 
                 var binaryReader = new BinaryReader(memoryStream);
-                var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion);
+                using var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion);
 
                 Assert.Throws<EndOfStreamException>(() => buildEventArgsReader.Read());
             }
@@ -570,7 +570,7 @@ private void Roundtrip<T>(T args, params Func<T, string>[] fieldsToCompare)
             memoryStream.Position = 0;
 
             var binaryReader = new BinaryReader(memoryStream);
-            var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion);
+            using var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion);
             var deserializedArgs = (T)buildEventArgsReader.Read();
 
             Assert.Equal(length, memoryStream.Position);
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index a52d2eace20..548a25b3858 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -7,7 +7,6 @@
 using System.IO;
 using System.Linq;
 using System.Text.RegularExpressions;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index dbb5365a805..756dffdbd0e 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -16,7 +16,6 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <PackageReference Include="System.Collections.Concurrent" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
     <PackageReference Include="NuGet.Frameworks" >
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 9e94c5bd41d..271454fb2a9 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1723,76 +1723,23 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                         projectGraph.ConstructionMetrics.NodeCount,
                         projectGraph.ConstructionMetrics.EdgeCount));
 
-                var targetListTask = Task.Run(() => projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames));
-                var cacheServiceTask = Task.Run(() => SearchAndInitializeProjectCachePluginFromGraph(projectGraph));
+                Dictionary<ProjectGraphNode, BuildResult> resultsPerNode = null;
 
-                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = targetListTask.Result;
-                using var cacheService = cacheServiceTask.Result;
-
-                var waitHandle = new AutoResetEvent(true);
-                var graphBuildStateLock = new object();
-
-                var blockedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes);
-                var finishedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes.Count);
-                var buildingNodes = new Dictionary<BuildSubmission, ProjectGraphNode>();
-                var resultsPerNode = new Dictionary<ProjectGraphNode, BuildResult>(projectGraph.ProjectNodes.Count);
-
-                while (blockedNodes.Count > 0 || buildingNodes.Count > 0)
+                if (submission.BuildRequestData.GraphBuildOptions.Build)
                 {
-                    waitHandle.WaitOne();
-
-                    lock (graphBuildStateLock)
-                    {
-                        var unblockedNodes = blockedNodes
-                            .Where(node => node.ProjectReferences.All(projectReference => finishedNodes.Contains(projectReference)))
-                            .ToList();
-                        foreach (var node in unblockedNodes)
-                        {
-                            var targetList = targetLists[node];
-                            if (targetList.Count == 0)
-                            {
-                                // An empty target list here means "no targets" instead of "default targets", so don't even build it.
-                                finishedNodes.Add(node);
-                                blockedNodes.Remove(node);
-
-                                waitHandle.Set();
+                    var cacheServiceTask = Task.Run(() => SearchAndInitializeProjectCachePluginFromGraph(projectGraph));
+                    var targetListTask = Task.Run(() => projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames));
 
-                                continue;
-                            }
+                    using var cacheService = cacheServiceTask.Result;
 
-                            var request = new BuildRequestData(
-                                node.ProjectInstance,
-                                targetList.ToArray(),
-                                submission.BuildRequestData.HostServices,
-                                submission.BuildRequestData.Flags);
-
-                            // TODO Tack onto the existing submission instead of pending a whole new submission for every node
-                            // Among other things, this makes BuildParameters.DetailedSummary produce a summary for each node, which is not desirable.
-                            // We basically want to submit all requests to the scheduler all at once and describe dependencies by requests being blocked by other requests.
-                            // However today the scheduler only keeps track of MSBuild nodes being blocked by other MSBuild nodes, and MSBuild nodes haven't been assigned to the graph nodes yet.
-                            var innerBuildSubmission = PendBuildRequest(request);
-                            buildingNodes.Add(innerBuildSubmission, node);
-                            blockedNodes.Remove(node);
-                            innerBuildSubmission.ExecuteAsync(finishedBuildSubmission =>
-                            {
-                                lock (graphBuildStateLock)
-                                {
-                                    ProjectGraphNode finishedNode = buildingNodes[finishedBuildSubmission];
-
-                                    finishedNodes.Add(finishedNode);
-                                    buildingNodes.Remove(finishedBuildSubmission);
-
-                                    resultsPerNode.Add(finishedNode, finishedBuildSubmission.BuildResult);
-                                }
-
-                                waitHandle.Set();
-                            }, null);
-                        }
-                    }
+                    resultsPerNode = BuildGraph(projectGraph, targetListTask.Result, submission.BuildRequestData);
                 }
 
                 // The overall submission is complete, so report it as complete
-                ReportResultsToSubmission(new GraphBuildResult(submission.SubmissionId, new ReadOnlyDictionary<ProjectGraphNode, BuildResult>(resultsPerNode)));
+                ReportResultsToSubmission(
+                    new GraphBuildResult(
+                        submission.SubmissionId,
+                        new ReadOnlyDictionary<ProjectGraphNode, BuildResult>(resultsPerNode ?? new Dictionary<ProjectGraphNode, BuildResult>())));
             }
             catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
             {
@@ -1839,10 +1786,81 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                 }
 
                 ReportResultsToSubmission(result);
+
                 _overallBuildSuccess = false;
             }
         }
 
+        private Dictionary<ProjectGraphNode, BuildResult> BuildGraph(
+            ProjectGraph projectGraph,
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetsPerNode,
+            GraphBuildRequestData graphBuildRequestData)
+        {
+            var waitHandle = new AutoResetEvent(true);
+            var graphBuildStateLock = new object();
+
+            var blockedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes);
+            var finishedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes.Count);
+            var buildingNodes = new Dictionary<BuildSubmission, ProjectGraphNode>();
+            var resultsPerNode = new Dictionary<ProjectGraphNode, BuildResult>(projectGraph.ProjectNodes.Count);
+
+            while (blockedNodes.Count > 0 || buildingNodes.Count > 0)
+            {
+                waitHandle.WaitOne();
+
+                lock (graphBuildStateLock)
+                {
+                    var unblockedNodes = blockedNodes
+                        .Where(node => node.ProjectReferences.All(projectReference => finishedNodes.Contains(projectReference)))
+                        .ToList();
+                    foreach (var node in unblockedNodes)
+                    {
+                        var targetList = targetsPerNode[node];
+                        if (targetList.Count == 0)
+                        {
+                            // An empty target list here means "no targets" instead of "default targets", so don't even build it.
+                            finishedNodes.Add(node);
+                            blockedNodes.Remove(node);
+
+                            waitHandle.Set();
+
+                            continue;
+                        }
+
+                        var request = new BuildRequestData(
+                            node.ProjectInstance,
+                            targetList.ToArray(),
+                            graphBuildRequestData.HostServices,
+                            graphBuildRequestData.Flags);
+
+                        // TODO Tack onto the existing submission instead of pending a whole new submission for every node
+                        // Among other things, this makes BuildParameters.DetailedSummary produce a summary for each node, which is not desirable.
+                        // We basically want to submit all requests to the scheduler all at once and describe dependencies by requests being blocked by other requests.
+                        // However today the scheduler only keeps track of MSBuild nodes being blocked by other MSBuild nodes, and MSBuild nodes haven't been assigned to the graph nodes yet.
+                        var innerBuildSubmission = PendBuildRequest(request);
+                        buildingNodes.Add(innerBuildSubmission, node);
+                        blockedNodes.Remove(node);
+                        innerBuildSubmission.ExecuteAsync(finishedBuildSubmission =>
+                        {
+                            lock (graphBuildStateLock)
+                            {
+                                ProjectGraphNode finishedNode = buildingNodes[finishedBuildSubmission];
+
+                                finishedNodes.Add(finishedNode);
+                                buildingNodes.Remove(finishedBuildSubmission);
+
+                                resultsPerNode.Add(finishedNode, finishedBuildSubmission.BuildResult);
+                            }
+
+                            waitHandle.Set();
+                        }, null);
+                    }
+                }
+            }
+
+            return resultsPerNode;
+        }
+
         private DisposePluginService SearchAndInitializeProjectCachePluginFromGraph(ProjectGraph projectGraph)
         {
             // TODO: Consider allowing parallel graph submissions, each with its own separate cache plugin. Right now the second graph submission with a cache will fail.
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 8db5fafe25b..21c371f67c2 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -3,14 +3,13 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.Concurrent;
 using System.Globalization;
 using System.IO;
 using System.IO.Pipes;
 using System.Diagnostics;
 using System.Threading;
-#if !FEATURE_APM
 using System.Threading.Tasks;
-#endif
 using System.Runtime.InteropServices;
 #if FEATURE_PIPE_SECURITY
 using System.Security.Principal;
@@ -639,8 +638,27 @@ internal class NodeContext
 
             /// <summary>
             /// A buffer typically big enough to handle a packet body.
+            /// We use this as a convenient way to manage and cache a byte[] that's resized
+            /// automatically to fit our payload.
+            /// </summary>
+            private MemoryStream _readBufferMemoryStream;
+
+            /// <summary>
+            /// A reusable buffer for writing packets.
+            /// </summary>
+            private MemoryStream _writeBufferMemoryStream;
+
+            /// <summary>
+            /// A queue used for enqueuing packets to write to the stream asynchronously.
+            /// </summary>
+            private BlockingCollection<INodePacket> _packetWriteQueue = new BlockingCollection<INodePacket>();
+
+            /// <summary>
+            /// A task representing the last packet write, so we can chain packet writes one after another.
+            /// We want to queue up writing packets on a separate thread asynchronously, but serially.
+            /// Each task drains the <see cref="_packetWriteQueue"/>
             /// </summary>
-            private byte[] _smallReadBuffer;
+            private Task _packetWriteDrainTask = Task.CompletedTask;
 
             /// <summary>
             /// Delegate called when the context terminates.
@@ -670,7 +688,8 @@ public NodeContext(int nodeId, Process process,
                 _serverToClientStream = nodePipe;
                 _packetFactory = factory;
                 _headerByte = new byte[5]; // 1 for the packet type, 4 for the body length
-                _smallReadBuffer = new byte[1000]; // 1000 was just an average seen on one profile run.
+                _readBufferMemoryStream = new MemoryStream();
+                _writeBufferMemoryStream = new MemoryStream();
                 _terminateDelegate = terminateDelegate;
                 _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
             }
@@ -714,16 +733,8 @@ public async Task RunPacketReadLoopAsync()
                     NodePacketType packetType = (NodePacketType)_headerByte[0];
                     int packetLength = BitConverter.ToInt32(_headerByte, 1);
 
-                    byte[] packetData;
-                    if (packetLength < _smallReadBuffer.Length)
-                    {
-                        packetData = _smallReadBuffer;
-                    }
-                    else
-                    {
-                        // Preallocated buffer is not large enough to hold the body. Allocate now, but don't hold it forever.
-                        packetData = new byte[packetLength];
-                    }
+                    _readBufferMemoryStream.SetLength(packetLength);
+                    byte[] packetData = _readBufferMemoryStream.GetBuffer();
 
                     try
                     {
@@ -757,54 +768,81 @@ public async Task RunPacketReadLoopAsync()
 #endif
 
             /// <summary>
-            /// Sends the specified packet to this node.
+            /// Sends the specified packet to this node asynchronously.
+            /// The method enqueues a task to write the packet and returns
+            /// immediately. This is because SendData() is on a hot path
+            /// under the primary lock (BuildManager's _syncLock)
+            /// and we want to minimize our time there.
             /// </summary>
             /// <param name="packet">The packet to send.</param>
             public void SendData(INodePacket packet)
             {
-                MemoryStream writeStream = new MemoryStream();
+                _packetWriteQueue.Add(packet);
+                DrainPacketQueue();
+            }
+
+            /// <summary>
+            /// Schedule a task to drain the packet write queue. We could have had a
+            /// dedicated thread that would pump the queue constantly, but
+            /// we don't want to allocate a dedicated thread per node (1MB stack)
+            /// </summary>
+            /// <remarks>Usually there'll be a single packet in the queue, but sometimes
+            /// a burst of SendData comes in, with 10-20 packets scheduled. In this case
+            /// the first scheduled task will drain all of them, and subsequent tasks
+            /// will run on an empty queue. I tried to write logic that avoids queueing
+            /// a new task if the queue is already being drained, but it didn't show any
+            /// improvement and made things more complicated.</remarks>
+            private void DrainPacketQueue()
+            {
+                // this lock is only necessary to protect a write to _packetWriteDrainTask field
+                lock (_packetWriteQueue)
+                {
+                    // average latency between the moment this runs and when the delegate starts
+                    // running is about 100-200 microseconds (unless there's thread pool saturation)
+                    _packetWriteDrainTask = _packetWriteDrainTask.ContinueWith(_ =>
+                    {
+                        while (_packetWriteQueue.TryTake(out var packet))
+                        {
+                            SendDataCore(packet);
+                        }
+                    }, TaskScheduler.Default);
+                }
+            }
+
+            /// <summary>
+            /// Actually writes and sends the packet. This can't be called in parallel
+            /// because it reuses the _writeBufferMemoryStream, and this is why we use
+            /// the _packetWriteDrainTask to serially chain invocations one after another.
+            /// </summary>
+            /// <param name="packet">The packet to send.</param>
+            private void SendDataCore(INodePacket packet)
+            {
+                MemoryStream writeStream = _writeBufferMemoryStream;
+
+                // clear the buffer but keep the underlying capacity to avoid reallocations
+                writeStream.SetLength(0);
+
                 ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(writeStream);
                 try
                 {
                     writeStream.WriteByte((byte)packet.Type);
 
                     // Pad for the packet length
-                    writeStream.Write(BitConverter.GetBytes((int)0), 0, 4);
+                    WriteInt32(writeStream, 0);
                     packet.Translate(writeTranslator);
 
+                    int writeStreamLength = (int)writeStream.Position;
+
                     // Now plug in the real packet length
                     writeStream.Position = 1;
-                    writeStream.Write(BitConverter.GetBytes((int)writeStream.Length - 5), 0, 4);
+                    WriteInt32(writeStream, writeStreamLength - 5);
 
                     byte[] writeStreamBuffer = writeStream.GetBuffer();
 
-                    for (int i = 0; i < writeStream.Length; i += MaxPacketWriteSize)
+                    for (int i = 0; i < writeStreamLength; i += MaxPacketWriteSize)
                     {
-                        int lengthToWrite = Math.Min((int)writeStream.Length - i, MaxPacketWriteSize);
-                        if ((int)writeStream.Length - i <= MaxPacketWriteSize)
-                        {
-                            // We are done, write the last bit asynchronously.  This is actually the general case for
-                            // most packets in the build, and the asynchronous behavior here is desirable.
-#if FEATURE_APM
-                            _serverToClientStream.BeginWrite(writeStreamBuffer, i, lengthToWrite, PacketWriteComplete, null);
-#else
-                            _serverToClientStream.WriteAsync(writeStreamBuffer, i, lengthToWrite);
-#endif
-                            break;
-                        }
-                        else
-                        {
-                            // If this packet is longer that we can write in one go, then we need to break it up.  We can't
-                            // return out of this function and let the rest of the system continue because another operation
-                            // might want to send data immediately afterward, and that could result in overlapping writes
-                            // to the pipe on different threads.
-#if FEATURE_APM
-                            IAsyncResult result = _serverToClientStream.BeginWrite(writeStream.GetBuffer(), i, lengthToWrite, null, null);
-                            _serverToClientStream.EndWrite(result);
-#else
-                            _serverToClientStream.Write(writeStreamBuffer, i, lengthToWrite);
-#endif
-                        }
+                        int lengthToWrite = Math.Min(writeStreamLength - i, MaxPacketWriteSize);
+                        _serverToClientStream.Write(writeStreamBuffer, i, lengthToWrite);
                     }
                     _isExiting = packet is NodeBuildComplete buildCompletePacket && !buildCompletePacket.PrepareForReuse;
                 }
@@ -819,6 +857,17 @@ public void SendData(INodePacket packet)
                 }
             }
 
+            /// <summary>
+            /// Avoid having a BinaryWriter just to write a 4-byte int
+            /// </summary>
+            private void WriteInt32(MemoryStream stream, int value)
+            {
+                stream.WriteByte((byte)value);
+                stream.WriteByte((byte)(value >> 8));
+                stream.WriteByte((byte)(value >> 16));
+                stream.WriteByte((byte)(value >> 24));
+            }
+
             /// <summary>
             /// Closes the node's context, disconnecting it from the node.
             /// </summary>
@@ -958,16 +1007,10 @@ private void HeaderReadComplete(IAsyncResult result)
                 int packetLength = BitConverter.ToInt32(_headerByte, 1);
                 MSBuildEventSource.Log.PacketReadSize(packetLength);
 
-                byte[] packetData;
-                if (packetLength < _smallReadBuffer.Length)
-                {
-                    packetData = _smallReadBuffer;
-                }
-                else
-                {
-                    // Preallocated buffer is not large enough to hold the body. Allocate now, but don't hold it forever.
-                    packetData = new byte[packetLength];
-                }
+                // Ensures the buffer is at least this length.
+                // It avoids reallocations if the buffer is already large enough.
+                _readBufferMemoryStream.SetLength(packetLength);
+                byte[] packetData = _readBufferMemoryStream.GetBuffer();
 
                 _clientToServerStream.BeginRead(packetData, 0, packetLength, BodyReadComplete, new Tuple<byte[], int>(packetData, packetLength));
             }
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 37a0bb91438..7bf9a69aebc 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -1099,13 +1099,30 @@ out parameterSet
                 else
                 {
                     // flag an error if we find a parameter that has no .NET property equivalent
-                    _taskLoggingContext.LogError
-                        (
-                        new BuildEventFileInfo(parameterLocation),
-                        "UnexpectedTaskAttribute",
-                        parameterName,
-                        _taskName
-                        );
+                    if (_taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssembly is null)
+                    {
+                        _taskLoggingContext.LogError
+                            (
+                            new BuildEventFileInfo( parameterLocation ),
+                            "UnexpectedTaskAttribute",
+                            parameterName,
+                            _taskName,
+                            _taskFactoryWrapper.TaskFactoryLoadedType.Type.Assembly.FullName,
+                            _taskFactoryWrapper.TaskFactoryLoadedType.Type.Assembly.Location
+                            );
+                    }
+                    else
+                    {
+                        _taskLoggingContext.LogError
+                            (
+                            new BuildEventFileInfo( parameterLocation ),
+                            "UnexpectedTaskAttribute",
+                            parameterName,
+                            _taskName,
+                            _taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssembly.FullName,
+                            _taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssembly.Location
+                            );
+                    }
                 }
             }
             catch (AmbiguousMatchException)
diff --git a/src/Build/Graph/GraphBuildRequestData.cs b/src/Build/Graph/GraphBuildRequestData.cs
index 86a2231551b..0a1e008820b 100644
--- a/src/Build/Graph/GraphBuildRequestData.cs
+++ b/src/Build/Graph/GraphBuildRequestData.cs
@@ -7,6 +7,14 @@
 
 namespace Microsoft.Build.Graph
 {
+    public record GraphBuildOptions
+    {
+        /// <summary>
+        /// If false, the graph is constructed but the nodes are not built.
+        /// </summary>
+        public bool Build { get; init; } = true;
+    }
+
     /// <summary>
     /// GraphBuildRequestData encapsulates all of the data needed to submit a graph build request.
     /// </summary>
@@ -142,10 +150,18 @@ public GraphBuildRequestData(IEnumerable<ProjectGraphEntryPoint> projectGraphEnt
             ProjectGraphEntryPoints = projectGraphEntryPoints;
         }
 
+        public GraphBuildRequestData(IEnumerable<ProjectGraphEntryPoint> projectGraphEntryPoints, ICollection<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, GraphBuildOptions graphBuildOptions)
+            : this(targetsToBuild, hostServices, flags, graphBuildOptions)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(projectGraphEntryPoints, nameof(projectGraphEntryPoints));
+
+            ProjectGraphEntryPoints = projectGraphEntryPoints;
+        }
+
         /// <summary>
         /// Common constructor.
         /// </summary>
-        private GraphBuildRequestData(ICollection<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags)
+        private GraphBuildRequestData(ICollection<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, GraphBuildOptions graphBuildOptions = null)
         {
             ErrorUtilities.VerifyThrowArgumentNull(targetsToBuild, nameof(targetsToBuild));
             foreach (string targetName in targetsToBuild)
@@ -156,6 +172,7 @@ private GraphBuildRequestData(ICollection<string> targetsToBuild, HostServices h
             HostServices = hostServices;
             TargetNames = new List<string>(targetsToBuild);
             Flags = flags;
+            GraphBuildOptions = graphBuildOptions ?? new GraphBuildOptions();
         }
 
         /// <summary>
@@ -183,6 +200,11 @@ private GraphBuildRequestData(ICollection<string> targetsToBuild, HostServices h
         /// </summary>
         public BuildRequestDataFlags Flags { get; }
 
+        /// <summary>
+        /// Options for how the graph should be built.
+        /// </summary>
+        public GraphBuildOptions GraphBuildOptions { get; }
+
         /// <summary>
         /// Gets the HostServices object for this request.
         /// </summary>
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index 61ad2576bb6..d8c90800210 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -25,5 +25,7 @@ internal enum BinaryLogRecordKind
         UninitializedPropertyRead,
         EnvironmentVariableRead,
         PropertyInitialValueSet,
+        NameValueList,
+        String,
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
index 264eba384ca..c6456c1a759 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
@@ -33,7 +33,12 @@ public void Replay(string sourceFilePath, CancellationToken cancellationToken)
             using (var stream = new FileStream(sourceFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
             {
                 var gzipStream = new GZipStream(stream, CompressionMode.Decompress, leaveOpen: true);
-                var binaryReader = new BinaryReader(gzipStream);
+
+                // wrapping the GZipStream in a buffered stream significantly improves performance
+                // and the max throughput is reached with a 32K buffer. See details here:
+                // https://github.com/dotnet/runtime/issues/39233#issuecomment-745598847
+                var bufferedStream = new BufferedStream(gzipStream, 32768);
+                var binaryReader = new BinaryReader(bufferedStream);
 
                 int fileFormatVersion = binaryReader.ReadInt32();
 
@@ -45,7 +50,7 @@ public void Replay(string sourceFilePath, CancellationToken cancellationToken)
                     throw new NotSupportedException(text);
                 }
 
-                var reader = new BuildEventArgsReader(binaryReader, fileFormatVersion);
+                using var reader = new BuildEventArgsReader(binaryReader, fileFormatVersion);
                 while (true)
                 {
                     if (cancellationToken.IsCancellationRequested)
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 8af5b386041..f9e9cb0b295 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -35,7 +35,13 @@ public sealed class BinaryLogger : ILogger
         //   - This was used in a now-reverted change but is the same as 9.
         // version 9:
         //   - new record kinds: EnvironmentVariableRead, PropertyReassignment, UninitializedPropertyRead
-        internal const int FileFormatVersion = 9;
+        // version 10:
+        //   - new record kinds:
+        //      * String - deduplicate strings by hashing and write a string record before it's used
+        //      * NameValueList - deduplicate arrays of name-value pairs such as properties, items and metadata
+        //                        in a separate record and refer to those records from regular records
+        //                        where a list used to be written in-place
+        internal const int FileFormatVersion = 10;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
@@ -137,6 +143,11 @@ public void Initialize(IEventSource eventSource)
             }
 
             stream = new GZipStream(stream, CompressionLevel.Optimal);
+
+            // wrapping the GZipStream in a buffered stream significantly improves performance
+            // and the max throughput is reached with a 32K buffer. See details here:
+            // https://github.com/dotnet/runtime/issues/39233#issuecomment-745598847
+            stream = new BufferedStream(stream, bufferSize: 32768);
             binaryWriter = new BinaryWriter(stream);
             eventArgsWriter = new BuildEventArgsWriter(binaryWriter);
 
@@ -175,8 +186,8 @@ public void Shutdown()
                 {
                     eventArgsWriter.WriteBlob(BinaryLogRecordKind.ProjectImportArchive, projectImportsCollector.GetAllBytes());
                 }
-                projectImportsCollector.Close();
 
+                projectImportsCollector.Close();
                 projectImportsCollector = null;
             }
 
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 5ee2af9780c..bd9ae6e9481 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -3,6 +3,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Reflection;
+using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 
@@ -11,10 +12,30 @@ namespace Microsoft.Build.Logging
     /// <summary>
     /// Deserializes and returns BuildEventArgs-derived objects from a BinaryReader
     /// </summary>
-    public class BuildEventArgsReader
+    public class BuildEventArgsReader : IDisposable
     {
         private readonly BinaryReader binaryReader;
         private readonly int fileFormatVersion;
+        private long recordNumber = 0;
+
+        /// <summary>
+        /// A list of string records we've encountered so far. If it's a small string, it will be the string directly.
+        /// If it's a large string, it will be a pointer into a temporary page file where the string content will be
+        /// written out to. This is necessary so we don't keep all the strings in memory when reading large binlogs.
+        /// We will OOM otherwise.
+        /// </summary>
+        private readonly List<object> stringRecords = new List<object>();
+
+        /// <summary>
+        /// A list of dictionaries we've encountered so far. Dictionaries are referred to by their order in this list.
+        /// </summary>
+        private readonly List<(int keyIndex, int valueIndex)[]> nameValueListRecords = new List<(int, int)[]>();
+
+        /// <summary>
+        /// A "page-file" for storing strings we've read so far. Keeping them in memory would OOM the 32-bit MSBuild
+        /// when reading large binlogs. This is a no-op in a 64-bit process.
+        /// </summary>
+        private StringStorage stringStorage = new StringStorage();
 
         // reflection is needed to set these three fields because public constructors don't provide
         // a way to set these from the outside
@@ -36,6 +57,15 @@ public BuildEventArgsReader(BinaryReader binaryReader, int fileFormatVersion)
             this.fileFormatVersion = fileFormatVersion;
         }
 
+        public void Dispose()
+        {
+            if (stringStorage != null)
+            {
+                stringStorage.Dispose();
+                stringStorage = null;
+            }
+        }
+
         /// <summary>
         /// Raised when the log reader encounters a binary blob embedded in the stream.
         /// The arguments include the blob kind and the byte buffer with the contents.
@@ -49,9 +79,25 @@ public BuildEventArgs Read()
         {
             BinaryLogRecordKind recordKind = (BinaryLogRecordKind)ReadInt32();
 
-            while (IsBlob(recordKind))
+            // Skip over data storage records since they don't result in a BuildEventArgs.
+            // just ingest their data and continue.
+            while (IsAuxiliaryRecord(recordKind))
             {
-                ReadBlob(recordKind);
+                // these are ordered by commonality
+                if (recordKind == BinaryLogRecordKind.String)
+                {
+                    ReadStringRecord();
+                }
+                else if (recordKind == BinaryLogRecordKind.NameValueList)
+                {
+                    ReadNameValueList();
+                }
+                else if (recordKind == BinaryLogRecordKind.ProjectImportArchive)
+                {
+                    ReadBlob(recordKind);
+                }
+
+                recordNumber += 1;
 
                 recordKind = (BinaryLogRecordKind)ReadInt32();
             }
@@ -128,15 +174,16 @@ public BuildEventArgs Read()
                     break;
             }
 
+            recordNumber += 1;
+
             return result;
         }
 
-        /// <summary>
-        /// For now it's just the ProjectImportArchive.
-        /// </summary>
-        private static bool IsBlob(BinaryLogRecordKind recordKind)
+        private static bool IsAuxiliaryRecord(BinaryLogRecordKind recordKind)
         {
-            return recordKind == BinaryLogRecordKind.ProjectImportArchive;
+            return recordKind == BinaryLogRecordKind.String
+                || recordKind == BinaryLogRecordKind.NameValueList
+                || recordKind == BinaryLogRecordKind.ProjectImportArchive;
         }
 
         private void ReadBlob(BinaryLogRecordKind kind)
@@ -146,6 +193,54 @@ private void ReadBlob(BinaryLogRecordKind kind)
             OnBlobRead?.Invoke(kind, bytes);
         }
 
+        private void ReadNameValueList()
+        {
+            int count = ReadInt32();
+
+            var list = new (int, int)[count];
+            for (int i = 0; i < count; i++)
+            {
+                int key = ReadInt32();
+                int value = ReadInt32();
+                list[i] = (key, value);
+            }
+
+            nameValueListRecords.Add(list);
+        }
+
+        private IDictionary<string, string> GetNameValueList(int id)
+        {
+            id -= BuildEventArgsWriter.NameValueRecordStartIndex;
+            if (id >= 0 && id < nameValueListRecords.Count)
+            {
+                var list = nameValueListRecords[id];
+
+                var dictionary = new Dictionary<string, string>(list.Length);
+                for (int i = 0; i < list.Length; i++)
+                {
+                    string key = GetStringFromRecord(list[i].keyIndex);
+                    string value = GetStringFromRecord(list[i].valueIndex);
+                    if (key != null)
+                    {
+                        dictionary[key] = value;
+                    }
+                }
+
+                return dictionary;
+            }
+
+            // this should never happen for valid binlogs
+            throw new InvalidDataException(
+                $"NameValueList record number {recordNumber} is invalid: index {id} is not within {stringRecords.Count}.");
+        }
+
+        private void ReadStringRecord()
+        {
+            string text = ReadString();
+            object storedString = stringStorage.Add(text);
+            stringRecords.Add(storedString);
+        }
+
         private BuildEventArgs ReadProjectImportedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
@@ -232,7 +327,7 @@ private BuildEventArgs ReadBuildFinishedEventArgs()
         private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
-            var projectFile = ReadString();
+            var projectFile = ReadDeduplicatedString();
 
             var e = new ProjectEvaluationStartedEventArgs(fields.Message)
             {
@@ -245,7 +340,7 @@ private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
         private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
-            var projectFile = ReadString();
+            var projectFile = ReadDeduplicatedString();
 
             var e = new ProjectEvaluationFinishedEventArgs(fields.Message)
             {
@@ -264,8 +359,11 @@ private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
                     var d = new Dictionary<EvaluationLocation, ProfiledLocation>(count);
                     for (int i = 0; i < count; i++)
                     {
-                        d.Add(ReadEvaluationLocation(), ReadProfiledLocation());
+                        var evaluationLocation = ReadEvaluationLocation();
+                        var profiledLocation = ReadProfiledLocation();
+                        d[evaluationLocation] = profiledLocation;
                     }
+
                     e.ProfilerResult = new ProfilerResult(d);
                 }
             }
@@ -284,10 +382,10 @@ private BuildEventArgs ReadProjectStartedEventArgs()
 
             var projectFile = ReadOptionalString();
             var projectId = ReadInt32();
-            var targetNames = ReadString();
+            var targetNames = ReadDeduplicatedString();
             var toolsVersion = ReadOptionalString();
 
-            Dictionary<string, string> globalProperties = null;
+            IDictionary<string, string> globalProperties = null;
 
             if (fileFormatVersion > 6)
             {
@@ -298,7 +396,7 @@ private BuildEventArgs ReadProjectStartedEventArgs()
             }
 
             var propertyList = ReadPropertyList();
-            var itemList = ReadItems();
+            var itemList = ReadProjectItems();
 
             var e = new ProjectStartedEventArgs(
                 projectId,
@@ -361,7 +459,7 @@ private BuildEventArgs ReadTargetFinishedEventArgs()
             var projectFile = ReadOptionalString();
             var targetFile = ReadOptionalString();
             var targetName = ReadOptionalString();
-            var targetOutputItemList = ReadItemList();
+            var targetOutputItemList = ReadTaskItemList();
 
             var e = new TargetFinishedEventArgs(
                 fields.Message,
@@ -525,7 +623,7 @@ private BuildEventArgs ReadEnvironmentVariableReadEventArgs()
             var fields = ReadBuildEventArgsFields();
             var importance = (MessageImportance)ReadInt32();
 
-            var environmentVariableName = ReadString();
+            var environmentVariableName = ReadDeduplicatedString();
 
             var e = new EnvironmentVariableReadEventArgs(
                 environmentVariableName,
@@ -542,10 +640,10 @@ private BuildEventArgs ReadPropertyReassignmentEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
             var importance = (MessageImportance)ReadInt32();
-            string propertyName = ReadString();
-            string previousValue = ReadString();
-            string newValue = ReadString();
-            string location = ReadString();
+            string propertyName = ReadDeduplicatedString();
+            string previousValue = ReadDeduplicatedString();
+            string newValue = ReadDeduplicatedString();
+            string location = ReadDeduplicatedString();
 
             var e = new PropertyReassignmentEventArgs(
                 propertyName,
@@ -565,7 +663,7 @@ private BuildEventArgs ReadUninitializedPropertyReadEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
             var importance = (MessageImportance)ReadInt32();
-            string propertyName = ReadString();
+            string propertyName = ReadDeduplicatedString();
 
             var e = new UninitializedPropertyReadEventArgs(
                 propertyName,
@@ -582,9 +680,9 @@ private BuildEventArgs ReadPropertyInitialValueSetEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
             var importance = (MessageImportance)ReadInt32();
-            string propertyName = ReadString();
-            string propertyValue = ReadString();
-            string propertySource = ReadString();
+            string propertyName = ReadDeduplicatedString();
+            string propertyValue = ReadDeduplicatedString();
+            string propertySource = ReadDeduplicatedString();
 
             var e = new PropertyInitialValueSetEventArgs(
                 propertyName,
@@ -625,7 +723,7 @@ private BuildEventArgsFields ReadBuildEventArgsFields()
 
             if ((flags & BuildEventArgsFieldFlags.Message) != 0)
             {
-                result.Message = ReadString();
+                result.Message = ReadDeduplicatedString();
             }
 
             if ((flags & BuildEventArgsFieldFlags.BuildEventContext) != 0)
@@ -640,12 +738,12 @@ private BuildEventArgsFields ReadBuildEventArgsFields()
 
             if ((flags & BuildEventArgsFieldFlags.HelpHeyword) != 0)
             {
-                result.HelpKeyword = ReadString();
+                result.HelpKeyword = ReadDeduplicatedString();
             }
 
             if ((flags & BuildEventArgsFieldFlags.SenderName) != 0)
             {
-                result.SenderName = ReadString();
+                result.SenderName = ReadDeduplicatedString();
             }
 
             if ((flags & BuildEventArgsFieldFlags.Timestamp) != 0)
@@ -655,22 +753,22 @@ private BuildEventArgsFields ReadBuildEventArgsFields()
 
             if ((flags & BuildEventArgsFieldFlags.Subcategory) != 0)
             {
-                result.Subcategory = ReadString();
+                result.Subcategory = ReadDeduplicatedString();
             }
 
             if ((flags & BuildEventArgsFieldFlags.Code) != 0)
             {
-                result.Code = ReadString();
+                result.Code = ReadDeduplicatedString();
             }
 
             if ((flags & BuildEventArgsFieldFlags.File) != 0)
             {
-                result.File = ReadString();
+                result.File = ReadDeduplicatedString();
             }
 
             if ((flags & BuildEventArgsFieldFlags.ProjectFile) != 0)
             {
-                result.ProjectFile = ReadString();
+                result.ProjectFile = ReadDeduplicatedString();
             }
 
             if ((flags & BuildEventArgsFieldFlags.LineNumber) != 0)
@@ -761,16 +859,33 @@ private BuildEventContext ReadBuildEventContext()
             return result;
         }
 
-        private Dictionary<string, string> ReadStringDictionary()
+        private IDictionary<string, string> ReadStringDictionary()
         {
-            int count = ReadInt32();
+            if (fileFormatVersion < 10)
+            {
+                return ReadLegacyStringDictionary();
+            }
+
+            int index = ReadInt32();
+            if (index == 0)
+            {
+                return null;
+            }
+
+            var record = GetNameValueList(index);
+            return record;
+        }
 
+        private IDictionary<string, string> ReadLegacyStringDictionary()
+        {
+            int count = ReadInt32();
             if (count == 0)
             {
                 return null;
             }
 
-            Dictionary<string, string> result = new Dictionary<string, string>(count);
+            var result = new Dictionary<string, string>(count);
+
             for (int i = 0; i < count; i++)
             {
                 string key = ReadString();
@@ -783,16 +898,29 @@ private Dictionary<string, string> ReadStringDictionary()
 
         private class TaskItem : ITaskItem
         {
+            private static readonly Dictionary<string, string> emptyMetadata = new Dictionary<string, string>();
+
             public string ItemSpec { get; set; }
-            public Dictionary<string, string> Metadata { get; } = new Dictionary<string, string>();
+            public IDictionary<string, string> Metadata { get; }
+
+            public TaskItem()
+            {
+                Metadata = new Dictionary<string, string>();
+            }
+
+            public TaskItem(string itemSpec, IDictionary<string, string> metadata)
+            {
+                ItemSpec = itemSpec;
+                Metadata = metadata ?? emptyMetadata;
+            }
 
             public int MetadataCount => Metadata.Count;
 
-            public ICollection MetadataNames => Metadata.Keys;
+            public ICollection MetadataNames => (ICollection)Metadata.Keys;
 
             public IDictionary CloneCustomMetadata()
             {
-                return Metadata;
+                return (IDictionary)Metadata;
             }
 
             public void CopyMetadataTo(ITaskItem destinationItem)
@@ -814,25 +942,23 @@ public void SetMetadata(string metadataName, string metadataValue)
             {
                 throw new NotImplementedException();
             }
-        }
-
-        private ITaskItem ReadItem()
-        {
-            var item = new TaskItem();
-            item.ItemSpec = ReadString();
 
-            int count = ReadInt32();
-            for (int i = 0; i < count; i++)
+            public override string ToString()
             {
-                string name = ReadString();
-                string value = ReadString();
-                item.Metadata[name] = value;
+                return $"{ItemSpec} Metadata: {MetadataCount}";
             }
+        }
 
-            return item;
+        private ITaskItem ReadTaskItem()
+        {
+            string itemSpec = ReadDeduplicatedString();
+            var metadata = ReadStringDictionary();
+
+            var taskItem = new TaskItem(itemSpec, metadata);
+            return taskItem;
         }
 
-        private IEnumerable ReadItems()
+        private IEnumerable ReadProjectItems()
         {
             int count = ReadInt32();
             if (count == 0)
@@ -840,19 +966,40 @@ private IEnumerable ReadItems()
                 return null;
             }
 
-            var list = new List<DictionaryEntry>(count);
+            List<DictionaryEntry> list;
 
-            for (int i = 0; i < count; i++)
+            // starting with format version 10 project items are grouped by name
+            // so we only have to write the name once, and then the count of items
+            // with that name. When reading a legacy binlog we need to read the
+            // old style flat list where the name is duplicated for each item.
+            if (fileFormatVersion < 10)
             {
-                string key = ReadString();
-                ITaskItem item = ReadItem();
-                list.Add(new DictionaryEntry(key, item));
+                list = new List<DictionaryEntry>(count);
+                for (int i = 0; i < count; i++)
+                {
+                    string itemName = ReadString();
+                    ITaskItem item = ReadTaskItem();
+                    list.Add(new DictionaryEntry(itemName, item));
+                }
+            }
+            else
+            {
+                list = new List<DictionaryEntry>();
+                for (int i = 0; i < count; i++)
+                {
+                    string itemName = ReadDeduplicatedString();
+                    var items = ReadTaskItemList();
+                    foreach (var item in items)
+                    {
+                        list.Add(new DictionaryEntry(itemName, item));
+                    }
+                }
             }
 
             return list;
         }
 
-        private IEnumerable ReadItemList()
+        private IEnumerable ReadTaskItemList()
         {
             int count = ReadInt32();
             if (count == 0)
@@ -864,28 +1011,70 @@ private IEnumerable ReadItemList()
 
             for (int i = 0; i < count; i++)
             {
-                ITaskItem item = ReadItem();
+                ITaskItem item = ReadTaskItem();
                 list.Add(item);
             }
 
             return list;
         }
 
+        private string ReadString()
+        {
+            return binaryReader.ReadString();
+        }
+
         private string ReadOptionalString()
         {
-            if (ReadBoolean())
+            if (fileFormatVersion < 10)
             {
-                return ReadString();
+                if (ReadBoolean())
+                {
+                    return ReadString();
+                }
+                else
+                {
+                    return null;
+                }
             }
-            else
+
+            return ReadDeduplicatedString();
+        }
+
+        private string ReadDeduplicatedString()
+        {
+            if (fileFormatVersion < 10)
             {
-                return null;
+                return ReadString();
             }
+
+            int index = ReadInt32();
+            return GetStringFromRecord(index);
         }
 
-        private string ReadString()
+        private string GetStringFromRecord(int index)
         {
-            return binaryReader.ReadString();
+            if (index == 0)
+            {
+                return null;
+            }
+            else if (index == 1)
+            {
+                return string.Empty;
+            }
+
+            // we reserve numbers 2-9 for future use.
+            // the writer assigns 10 as the index of the first string
+            index -= BuildEventArgsWriter.StringStartIndex;
+            if (index >= 0 && index < this.stringRecords.Count)
+            {
+                object storedString = stringRecords[index];
+                string result = stringStorage.Get(storedString);
+                return result;
+            }
+
+            // this should never happen for valid binlogs
+            throw new InvalidDataException(
+                $"String record number {recordNumber} is invalid: string index {index} is not within {stringRecords.Count}.");
         }
 
         private int ReadInt32()
@@ -972,10 +1161,150 @@ private EvaluationLocation ReadEvaluationLocation()
                 {
                     parentId = ReadInt64();
                 }
+
                 return new EvaluationLocation(id, parentId, evaluationPass, evaluationDescription, file, line, elementName, description, kind);
             }
 
             return new EvaluationLocation(0, null, evaluationPass, evaluationDescription, file, line, elementName, description, kind);
         }
+
+        /// <summary>
+        /// Locates the string in the page file.
+        /// </summary>
+        internal class StringPosition
+        {
+            /// <summary>
+            /// Offset in the file.
+            /// </summary>
+            public long FilePosition;
+
+            /// <summary>
+            /// The length of the string in chars (not bytes).
+            /// </summary>
+            public int StringLength;
+        }
+
+        /// <summary>
+        /// Stores large strings in a temp file on disk, to avoid keeping all strings in memory.
+        /// Only creates a file for 32-bit MSBuild.exe, just returns the string directly on 64-bit.
+        /// </summary>
+        internal class StringStorage : IDisposable
+        {
+            private readonly string filePath;
+            private FileStream stream;
+            private StreamWriter streamWriter;
+            private readonly StreamReader streamReader;
+            private readonly StringBuilder stringBuilder;
+
+            public const int StringSizeThreshold = 1024;
+
+            public StringStorage()
+            {
+                if (!Environment.Is64BitProcess)
+                {
+                    filePath = Path.GetTempFileName();
+                    var utf8noBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);
+                    stream = new FileStream(
+                        filePath,
+                        FileMode.OpenOrCreate,
+                        FileAccess.ReadWrite,
+                        FileShare.None,
+                        bufferSize: 4096, // 4096 seems to have the best performance on SSD
+                        FileOptions.RandomAccess | FileOptions.DeleteOnClose);
+
+                    // 65536 has no particular significance, and maybe could be tuned
+                    // but 65536 performs well enough and isn't a lot of memory for a singleton
+                    streamWriter = new StreamWriter(stream, utf8noBom, 65536);
+                    streamWriter.AutoFlush = true;
+                    streamReader = new StreamReader(stream, utf8noBom);
+                    stringBuilder = new StringBuilder();
+                }
+            }
+
+            private long totalAllocatedShortStrings = 0;
+
+            public object Add(string text)
+            {
+                if (filePath == null)
+                {
+                    // on 64-bit, we have as much memory as we want
+                    // so no need to write to the file at all
+                    return text;
+                }
+
+                // Tradeoff between not crashing with OOM on large binlogs and
+                // keeping the playback of smaller binlogs relatively fast.
+                // It is slow to store all small strings in the file and constantly
+                // seek to retrieve them. Instead we'll keep storing small strings
+                // in memory until we allocate 2 GB. After that, all strings go to
+                // the file.
+                // Win-win: small binlog playback is fast and large binlog playback
+                // doesn't OOM.
+                if (text.Length <= StringSizeThreshold && totalAllocatedShortStrings < 1_000_000_000)
+                {
+                    totalAllocatedShortStrings += text.Length;
+                    return text;
+                }
+
+                var stringPosition = new StringPosition();
+
+                stringPosition.FilePosition = stream.Position;
+
+                streamWriter.Write(text);
+
+                stringPosition.StringLength = text.Length;
+                return stringPosition;
+            }
+
+            public string Get(object storedString)
+            {
+                if (storedString is string text)
+                {
+                    return text;
+                }
+
+                var position = (StringPosition)storedString;
+
+                stream.Position = position.FilePosition;
+                stringBuilder.Length = position.StringLength;
+                for (int i = 0; i < position.StringLength; i++)
+                {
+                    char ch = (char)streamReader.Read();
+                    stringBuilder[i] = ch;
+                }
+
+                stream.Position = stream.Length;
+                streamReader.DiscardBufferedData();
+
+                string result = stringBuilder.ToString();
+                stringBuilder.Clear();
+                return result;
+            }
+
+            public void Dispose()
+            {
+                try
+                {
+                    if (streamWriter != null)
+                    {
+                        streamWriter.Dispose();
+                        streamWriter = null;
+                    }
+
+                    if (stream != null)
+                    {
+                        stream.Dispose();
+                        stream = null;
+                    }
+                }
+                catch
+                {
+                    // The StringStorage class is not crucial for other functionality and if 
+                    // there are exceptions when closing the temp file, it's too late to do anything about it.
+                    // Since we don't want to disrupt anything and the file is in the TEMP directory, it will
+                    // get cleaned up at some point anyway.
+                }
+            }
+        }
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index bc8f203903e..3b37d1404cf 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
+using Microsoft.Build.Internal;
 
 namespace Microsoft.Build.Logging
 {
@@ -15,7 +16,85 @@ namespace Microsoft.Build.Logging
     /// </summary>
     internal class BuildEventArgsWriter
     {
-        private readonly BinaryWriter binaryWriter;
+        private readonly Stream originalStream;
+
+        /// <summary>
+        /// When writing the current record, first write it to a memory stream,
+        /// then flush to the originalStream. This is needed so that if we discover
+        /// that we need to write a string record in the middle of writing the
+        /// current record, we will write the string record to the original stream
+        /// and the current record will end up after the string record.
+        /// </summary>
+        private readonly MemoryStream currentRecordStream;
+
+        /// <summary>
+        /// The binary writer around the originalStream.
+        /// </summary>
+        private readonly BinaryWriter originalBinaryWriter;
+
+        /// <summary>
+        /// The binary writer around the currentRecordStream.
+        /// </summary>
+        private readonly BinaryWriter currentRecordWriter;
+
+        /// <summary>
+        /// The binary writer we're currently using. Is pointing at the currentRecordWriter usually,
+        /// but sometimes we repoint it to the originalBinaryWriter temporarily, when writing string
+        /// and name-value records.
+        /// </summary>
+        private BinaryWriter binaryWriter;
+
+        /// <summary>
+        /// Hashtable used for deduplicating strings. When we need to write a string,
+        /// we check in this hashtable first, and if we've seen the string before,
+        /// just write out its index. Otherwise write out a string record, and then
+        /// write the string index. A string record is guaranteed to precede its first
+        /// usage.
+        /// The reader will read the string records first and then be able to retrieve
+        /// a string by its index. This allows us to keep the format streaming instead
+        /// of writing one giant string table at the end. If a binlog is interrupted
+        /// we'll be able to use all the information we've discovered thus far.
+        /// </summary>
+        private readonly Dictionary<HashKey, int> stringHashes = new Dictionary<HashKey, int>();
+
+        /// <summary>
+        /// Hashtable used for deduplicating name-value lists. Same as strings.
+        /// </summary>
+        private readonly Dictionary<HashKey, int> nameValueListHashes = new Dictionary<HashKey, int>();
+
+        /// <summary>
+        /// Index 0 is null, Index 1 is the empty string.
+        /// Reserve indices 2-9 for future use. Start indexing actual strings at 10.
+        /// </summary>
+        internal const int StringStartIndex = 10;
+
+        /// <summary>
+        /// Let's reserve a few indices for future use.
+        /// </summary>
+        internal const int NameValueRecordStartIndex = 10;
+
+        /// <summary>
+        /// 0 is null, 1 is empty string
+        /// 2-9 are reserved for future use.
+        /// Start indexing at 10.
+        /// </summary>
+        private int stringRecordId = StringStartIndex;
+
+        /// <summary>
+        /// The index of the next record to be written.
+        /// </summary>
+        private int nameValueRecordId = NameValueRecordStartIndex;
+
+        /// <summary>
+        /// A temporary buffer we use when writing a NameValueList record. Avoids allocating a list each time.
+        /// </summary>
+        private readonly List<KeyValuePair<string, string>> nameValueListBuffer = new List<KeyValuePair<string, string>>(1024);
+
+        /// <summary>
+        /// A temporary buffer we use when hashing a NameValueList record. Stores the indices of hashed strings
+        /// instead of the actual names and values.
+        /// </summary>
+        private readonly List<KeyValuePair<int, int>> nameValueIndexListBuffer = new List<KeyValuePair<int, int>>(1024);
 
         /// <summary>
         /// Initializes a new instance of BuildEventArgsWriter with a BinaryWriter
@@ -23,13 +102,31 @@ internal class BuildEventArgsWriter
         /// <param name="binaryWriter">A BinaryWriter to write the BuildEventArgs instances to</param>
         public BuildEventArgsWriter(BinaryWriter binaryWriter)
         {
-            this.binaryWriter = binaryWriter;
+            this.originalStream = binaryWriter.BaseStream;
+
+            // this doesn't exceed 30K for smaller binlogs so seems like a reasonable
+            // starting point to avoid reallocations in the common case
+            this.currentRecordStream = new MemoryStream(65536);
+
+            this.originalBinaryWriter = binaryWriter;
+            this.currentRecordWriter = new BinaryWriter(currentRecordStream);
+
+            this.binaryWriter = currentRecordWriter;
         }
 
         /// <summary>
         /// Write a provided instance of BuildEventArgs to the BinaryWriter
         /// </summary>
         public void Write(BuildEventArgs e)
+        {
+            WriteCore(e);
+
+            // flush the current record and clear the MemoryStream to prepare for next use
+            currentRecordStream.WriteTo(originalStream);
+            currentRecordStream.SetLength(0);
+        }
+
+        private void WriteCore(BuildEventArgs e)
         {
             // the cases are ordered by most used first for performance
             if (e is BuildMessageEventArgs)
@@ -101,11 +198,41 @@ public void Write(BuildEventArgs e)
 
         public void WriteBlob(BinaryLogRecordKind kind, byte[] bytes)
         {
+            // write the blob directly to the underlying writer,
+            // bypassing the memory stream
+            using var redirection = RedirectWritesToOriginalWriter();
+
             Write(kind);
             Write(bytes.Length);
             Write(bytes);
         }
 
+        /// <summary>
+        /// Switches the binaryWriter used by the Write* methods to the direct underlying stream writer
+        /// until the disposable is disposed. Useful to bypass the currentRecordWriter to write a string,
+        /// blob or NameValueRecord that should precede the record being currently written.
+        /// </summary>
+        private IDisposable RedirectWritesToOriginalWriter()
+        {
+            binaryWriter = originalBinaryWriter;
+            return new RedirectionScope(this);
+        }
+
+        private struct RedirectionScope : IDisposable
+        {
+            private readonly BuildEventArgsWriter _writer;
+
+            public RedirectionScope(BuildEventArgsWriter buildEventArgsWriter)
+            {
+                _writer = buildEventArgsWriter;
+            }
+
+            public void Dispose()
+            {
+                _writer.binaryWriter = _writer.currentRecordWriter;
+            }
+        }
+
         private void Write(BuildStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.BuildStarted);
@@ -124,15 +251,15 @@ private void Write(ProjectEvaluationStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.ProjectEvaluationStarted);
             WriteBuildEventArgsFields(e);
-            Write(e.ProjectFile);
+            WriteDeduplicatedString(e.ProjectFile);
         }
 
         private void Write(ProjectEvaluationFinishedEventArgs e)
         {
             Write(BinaryLogRecordKind.ProjectEvaluationFinished);
-            
+
             WriteBuildEventArgsFields(e);
-            Write(e.ProjectFile);
+            WriteDeduplicatedString(e.ProjectFile);
 
             Write(e.ProfilerResult.HasValue);
             if (e.ProfilerResult.HasValue)
@@ -162,11 +289,11 @@ private void Write(ProjectStartedEventArgs e)
                 Write(e.ParentProjectBuildEventContext);
             }
 
-            WriteOptionalString(e.ProjectFile);
+            WriteDeduplicatedString(e.ProjectFile);
 
             Write(e.ProjectId);
-            Write(e.TargetNames);
-            WriteOptionalString(e.ToolsVersion);
+            WriteDeduplicatedString(e.TargetNames);
+            WriteDeduplicatedString(e.ToolsVersion);
 
             if (e.GlobalProperties == null)
             {
@@ -180,14 +307,14 @@ private void Write(ProjectStartedEventArgs e)
 
             WriteProperties(e.Properties);
 
-            WriteItems(e.Items);
+            WriteProjectItems(e.Items);
         }
 
         private void Write(ProjectFinishedEventArgs e)
         {
             Write(BinaryLogRecordKind.ProjectFinished);
             WriteBuildEventArgsFields(e);
-            WriteOptionalString(e.ProjectFile);
+            WriteDeduplicatedString(e.ProjectFile);
             Write(e.Succeeded);
         }
 
@@ -195,11 +322,11 @@ private void Write(TargetStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.TargetStarted);
             WriteBuildEventArgsFields(e);
-            WriteOptionalString(e.TargetName);
-            WriteOptionalString(e.ProjectFile);
-            WriteOptionalString(e.TargetFile);
-            WriteOptionalString(e.ParentTarget);
-            Write((int) e.BuildReason);
+            WriteDeduplicatedString(e.TargetName);
+            WriteDeduplicatedString(e.ProjectFile);
+            WriteDeduplicatedString(e.TargetFile);
+            WriteDeduplicatedString(e.ParentTarget);
+            Write((int)e.BuildReason);
         }
 
         private void Write(TargetFinishedEventArgs e)
@@ -207,19 +334,19 @@ private void Write(TargetFinishedEventArgs e)
             Write(BinaryLogRecordKind.TargetFinished);
             WriteBuildEventArgsFields(e);
             Write(e.Succeeded);
-            WriteOptionalString(e.ProjectFile);
-            WriteOptionalString(e.TargetFile);
-            WriteOptionalString(e.TargetName);
-            WriteItemList(e.TargetOutputs);
+            WriteDeduplicatedString(e.ProjectFile);
+            WriteDeduplicatedString(e.TargetFile);
+            WriteDeduplicatedString(e.TargetName);
+            WriteTaskItemList(e.TargetOutputs);
         }
 
         private void Write(TaskStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.TaskStarted);
             WriteBuildEventArgsFields(e);
-            WriteOptionalString(e.TaskName);
-            WriteOptionalString(e.ProjectFile);
-            WriteOptionalString(e.TaskFile);
+            WriteDeduplicatedString(e.TaskName);
+            WriteDeduplicatedString(e.ProjectFile);
+            WriteDeduplicatedString(e.TaskFile);
         }
 
         private void Write(TaskFinishedEventArgs e)
@@ -227,19 +354,19 @@ private void Write(TaskFinishedEventArgs e)
             Write(BinaryLogRecordKind.TaskFinished);
             WriteBuildEventArgsFields(e);
             Write(e.Succeeded);
-            WriteOptionalString(e.TaskName);
-            WriteOptionalString(e.ProjectFile);
-            WriteOptionalString(e.TaskFile);
+            WriteDeduplicatedString(e.TaskName);
+            WriteDeduplicatedString(e.ProjectFile);
+            WriteDeduplicatedString(e.TaskFile);
         }
 
         private void Write(BuildErrorEventArgs e)
         {
             Write(BinaryLogRecordKind.Error);
             WriteBuildEventArgsFields(e);
-            WriteOptionalString(e.Subcategory);
-            WriteOptionalString(e.Code);
-            WriteOptionalString(e.File);
-            WriteOptionalString(e.ProjectFile);
+            WriteDeduplicatedString(e.Subcategory);
+            WriteDeduplicatedString(e.Code);
+            WriteDeduplicatedString(e.File);
+            WriteDeduplicatedString(e.ProjectFile);
             Write(e.LineNumber);
             Write(e.ColumnNumber);
             Write(e.EndLineNumber);
@@ -250,10 +377,10 @@ private void Write(BuildWarningEventArgs e)
         {
             Write(BinaryLogRecordKind.Warning);
             WriteBuildEventArgsFields(e);
-            WriteOptionalString(e.Subcategory);
-            WriteOptionalString(e.Code);
-            WriteOptionalString(e.File);
-            WriteOptionalString(e.ProjectFile);
+            WriteDeduplicatedString(e.Subcategory);
+            WriteDeduplicatedString(e.Code);
+            WriteDeduplicatedString(e.File);
+            WriteDeduplicatedString(e.ProjectFile);
             Write(e.LineNumber);
             Write(e.ColumnNumber);
             Write(e.EndLineNumber);
@@ -319,17 +446,17 @@ private void Write(ProjectImportedEventArgs e)
             Write(BinaryLogRecordKind.ProjectImported);
             WriteMessageFields(e);
             Write(e.ImportIgnored);
-            WriteOptionalString(e.ImportedProjectFile);
-            WriteOptionalString(e.UnexpandedProject);
+            WriteDeduplicatedString(e.ImportedProjectFile);
+            WriteDeduplicatedString(e.UnexpandedProject);
         }
 
         private void Write(TargetSkippedEventArgs e)
         {
             Write(BinaryLogRecordKind.TargetSkipped);
             WriteMessageFields(e);
-            WriteOptionalString(e.TargetFile);
-            WriteOptionalString(e.TargetName);
-            WriteOptionalString(e.ParentTarget);
+            WriteDeduplicatedString(e.TargetFile);
+            WriteDeduplicatedString(e.TargetName);
+            WriteDeduplicatedString(e.ParentTarget);
             Write((int)e.BuildReason);
         }
 
@@ -343,41 +470,41 @@ private void Write(PropertyReassignmentEventArgs e)
         {
             Write(BinaryLogRecordKind.PropertyReassignment);
             WriteMessageFields(e);
-            Write(e.PropertyName);
-            Write(e.PreviousValue);
-            Write(e.NewValue);
-            Write(e.Location);
+            WriteDeduplicatedString(e.PropertyName);
+            WriteDeduplicatedString(e.PreviousValue);
+            WriteDeduplicatedString(e.NewValue);
+            WriteDeduplicatedString(e.Location);
         }
 
         private void Write(UninitializedPropertyReadEventArgs e)
         {
             Write(BinaryLogRecordKind.UninitializedPropertyRead);
             WriteMessageFields(e);
-            Write(e.PropertyName);
+            WriteDeduplicatedString(e.PropertyName);
         }
 
         private void Write(PropertyInitialValueSetEventArgs e)
         {
             Write(BinaryLogRecordKind.PropertyInitialValueSet);
             WriteMessageFields(e);
-            Write(e.PropertyName);
-            Write(e.PropertyValue);
-            Write(e.PropertySource);
+            WriteDeduplicatedString(e.PropertyName);
+            WriteDeduplicatedString(e.PropertyValue);
+            WriteDeduplicatedString(e.PropertySource);
         }
 
         private void Write(EnvironmentVariableReadEventArgs e)
         {
             Write(BinaryLogRecordKind.EnvironmentVariableRead);
             WriteMessageFields(e);
-            Write(e.EnvironmentVariableName);
+            WriteDeduplicatedString(e.EnvironmentVariableName);
         }
 
         private void Write(TaskCommandLineEventArgs e)
         {
             Write(BinaryLogRecordKind.TaskCommandLine);
             WriteMessageFields(e);
-            WriteOptionalString(e.CommandLine);
-            WriteOptionalString(e.TaskName);
+            WriteDeduplicatedString(e.CommandLine);
+            WriteDeduplicatedString(e.TaskName);
         }
 
         private void WriteBuildEventArgsFields(BuildEventArgs e)
@@ -391,7 +518,7 @@ private void WriteBaseFields(BuildEventArgs e, BuildEventArgsFieldFlags flags)
         {
             if ((flags & BuildEventArgsFieldFlags.Message) != 0)
             {
-                Write(e.Message);
+                WriteDeduplicatedString(e.Message);
             }
 
             if ((flags & BuildEventArgsFieldFlags.BuildEventContext) != 0)
@@ -406,12 +533,12 @@ private void WriteBaseFields(BuildEventArgs e, BuildEventArgsFieldFlags flags)
 
             if ((flags & BuildEventArgsFieldFlags.HelpHeyword) != 0)
             {
-                Write(e.HelpKeyword);
+                WriteDeduplicatedString(e.HelpKeyword);
             }
 
             if ((flags & BuildEventArgsFieldFlags.SenderName) != 0)
             {
-                Write(e.SenderName);
+                WriteDeduplicatedString(e.SenderName);
             }
 
             if ((flags & BuildEventArgsFieldFlags.Timestamp) != 0)
@@ -431,22 +558,22 @@ private void WriteMessageFields(BuildMessageEventArgs e)
 
             if ((flags & BuildEventArgsFieldFlags.Subcategory) != 0)
             {
-                Write(e.Subcategory);
+                WriteDeduplicatedString(e.Subcategory);
             }
 
             if ((flags & BuildEventArgsFieldFlags.Code) != 0)
             {
-                Write(e.Code);
+                WriteDeduplicatedString(e.Code);
             }
 
             if ((flags & BuildEventArgsFieldFlags.File) != 0)
             {
-                Write(e.File);
+                WriteDeduplicatedString(e.File);
             }
 
             if ((flags & BuildEventArgsFieldFlags.ProjectFile) != 0)
             {
-                Write(e.ProjectFile);
+                WriteDeduplicatedString(e.ProjectFile);
             }
 
             if ((flags & BuildEventArgsFieldFlags.LineNumber) != 0)
@@ -554,25 +681,24 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr
             return flags;
         }
 
-        private void WriteItemList(IEnumerable items)
+        private void WriteTaskItemList(IEnumerable items)
         {
             var taskItems = items as IEnumerable<ITaskItem>;
-            if (taskItems != null)
+            if (taskItems == null)
             {
-                Write(taskItems.Count());
-
-                foreach (var item in taskItems)
-                {
-                    Write(item);
-                }
-
+                Write(false);
                 return;
             }
 
-            Write(0);
+            Write(taskItems.Count());
+
+            foreach (var item in taskItems)
+            {
+                Write(item);
+            }
         }
 
-        private void WriteItems(IEnumerable items)
+        private void WriteProjectItems(IEnumerable items)
         {
             if (items == null)
             {
@@ -580,29 +706,31 @@ private void WriteItems(IEnumerable items)
                 return;
             }
 
-            var entries = items.OfType<DictionaryEntry>()
-                .Where(e => e.Key is string && e.Value is ITaskItem)
+            var groups = items
+                .OfType<DictionaryEntry>()
+                .GroupBy(entry => entry.Key as string, entry => entry.Value as ITaskItem)
+                .Where(group => !string.IsNullOrEmpty(group.Key))
                 .ToArray();
-            Write(entries.Length);
 
-            foreach (DictionaryEntry entry in entries)
+            Write(groups.Length);
+
+            foreach (var group in groups)
             {
-                string key = entry.Key as string;
-                ITaskItem item = entry.Value as ITaskItem;
-                Write(key);
-                Write(item);
+                WriteDeduplicatedString(group.Key);
+                WriteTaskItemList(group);
             }
         }
 
         private void Write(ITaskItem item)
         {
-            Write(item.ItemSpec);
+            WriteDeduplicatedString(item.ItemSpec);
+
+            nameValueListBuffer.Clear();
+
             IDictionary customMetadata = item.CloneCustomMetadata();
-            Write(customMetadata.Count);
 
             foreach (string metadataName in customMetadata.Keys)
             {
-                Write(metadataName);
                 string valueOrError;
 
                 try
@@ -623,8 +751,10 @@ private void Write(ITaskItem item)
                     Debug.Fail(e.ToString());
                 }
 
-                Write(valueOrError);
+                nameValueListBuffer.Add(new KeyValuePair<string, string>(metadataName, valueOrError));
             }
+
+            WriteNameValueList();
         }
 
         private void WriteProperties(IEnumerable properties)
@@ -635,26 +765,26 @@ private void WriteProperties(IEnumerable properties)
                 return;
             }
 
+            nameValueListBuffer.Clear();
+
             // there are no guarantees that the properties iterator won't change, so 
             // take a snapshot and work with the readonly copy
             var propertiesArray = properties.OfType<DictionaryEntry>().ToArray();
 
-            Write(propertiesArray.Length);
-
-            foreach (DictionaryEntry entry in propertiesArray)
+            for (int i = 0; i < propertiesArray.Length; i++)
             {
-                if (entry.Key is string && entry.Value is string)
+                DictionaryEntry entry = propertiesArray[i];
+                if (entry.Key is string key && entry.Value is string value)
                 {
-                    Write((string)entry.Key);
-                    Write((string)entry.Value);
+                    nameValueListBuffer.Add(new KeyValuePair<string, string>(key, value));
                 }
                 else
                 {
-                    // to keep the count accurate
-                    Write("");
-                    Write("");
+                    nameValueListBuffer.Add(new KeyValuePair<string, string>(string.Empty, string.Empty));
                 }
             }
+
+            WriteNameValueList();
         }
 
         private void Write(BuildEventContext buildEventContext)
@@ -668,23 +798,94 @@ private void Write(BuildEventContext buildEventContext)
             Write(buildEventContext.EvaluationId);
         }
 
-        private void Write<TKey, TValue>(IEnumerable<KeyValuePair<TKey, TValue>> keyValuePairs)
+        private void Write(IEnumerable<KeyValuePair<string, string>> keyValuePairs)
         {
-            if (keyValuePairs?.Any() == true)
+            nameValueListBuffer.Clear();
+
+            if (keyValuePairs != null)
             {
-                Write(keyValuePairs.Count());
                 foreach (var kvp in keyValuePairs)
                 {
-                    Write(kvp.Key.ToString());
-                    Write(kvp.Value.ToString());
+                    nameValueListBuffer.Add(kvp);
                 }
             }
-            else
+
+            WriteNameValueList();
+        }
+
+        private void WriteNameValueList()
+        {
+            if (nameValueListBuffer.Count == 0)
             {
-                Write(false);
+                Write((byte)0);
+                return;
+            }
+
+            HashKey hash = HashAllStrings(nameValueListBuffer);
+            if (!nameValueListHashes.TryGetValue(hash, out var recordId))
+            {
+                recordId = nameValueRecordId;
+                nameValueListHashes[hash] = nameValueRecordId;
+
+                WriteNameValueListRecord();
+
+                nameValueRecordId += 1;
+            }
+
+            Write(recordId);
+        }
+
+        /// <summary>
+        /// In the middle of writing the current record we may discover that we want to write another record
+        /// preceding the current one, specifically the list of names and values we want to reuse in the
+        /// future. As we are writing the current record to a MemoryStream first, it's OK to temporarily
+        /// switch to the direct underlying stream and write the NameValueList record first.
+        /// When the current record is done writing, the MemoryStream will flush to the underlying stream
+        /// and the current record will end up after the NameValueList record, as desired.
+        /// </summary>
+        private void WriteNameValueListRecord()
+        {
+            // Switch the binaryWriter used by the Write* methods to the direct underlying stream writer.
+            // We want this record to precede the record we're currently writing to currentRecordWriter
+            // which is backed by a MemoryStream buffer
+            using var redirectionScope = RedirectWritesToOriginalWriter();
+
+            Write(BinaryLogRecordKind.NameValueList);
+            Write(nameValueIndexListBuffer.Count);
+            for (int i = 0; i < nameValueListBuffer.Count; i++)
+            {
+                var kvp = nameValueIndexListBuffer[i];
+                Write(kvp.Key);
+                Write(kvp.Value);
             }
         }
 
+        /// <summary>
+        /// Compute the total hash of all items in the nameValueList
+        /// while simultaneously filling the nameValueIndexListBuffer with the individual
+        /// hashes of the strings, mirroring the strings in the original nameValueList.
+        /// This helps us avoid hashing strings twice (once to hash the string individually
+        /// and the second time when hashing it as part of the nameValueList)
+        /// </summary>
+        private HashKey HashAllStrings(List<KeyValuePair<string, string>> nameValueList)
+        {
+            HashKey hash = new HashKey();
+
+            nameValueIndexListBuffer.Clear();
+
+            for (int i = 0; i < nameValueList.Count; i++)
+            {
+                var kvp = nameValueList[i];
+                var (keyIndex, keyHash) = HashString(kvp.Key);
+                var (valueIndex, valueHash) = HashString(kvp.Value);
+                hash = hash.Add(keyHash);
+                hash = hash.Add(valueHash);
+                nameValueIndexListBuffer.Add(new KeyValuePair<int, int>(keyIndex, valueIndex));
+            }
+
+            return hash;
+        }
+
         private void Write(BinaryLogRecordKind kind)
         {
             Write((int)kind);
@@ -718,34 +919,57 @@ private void Write(byte[] bytes)
             binaryWriter.Write(bytes);
         }
 
+        private void Write(byte b)
+        {
+            binaryWriter.Write(b);
+        }
+
         private void Write(bool boolean)
         {
             binaryWriter.Write(boolean);
         }
 
-        private void Write(string text)
+        private void WriteDeduplicatedString(string text)
         {
-            if (text != null)
-            {
-                binaryWriter.Write(text);
-            }
-            else
-            {
-                binaryWriter.Write(false);
-            }
+            var (recordId, _) = HashString(text);
+            Write(recordId);
         }
 
-        private void WriteOptionalString(string text)
+        /// <summary>
+        /// Hash the string and write a String record if not already hashed.
+        /// </summary>
+        /// <returns>Returns the string record index as well as the hash.</returns>
+        private (int index, HashKey hash) HashString(string text)
         {
             if (text == null)
             {
-                Write(false);
+                return (0, default);
             }
-            else
+            else if (text.Length == 0)
             {
-                Write(true);
-                Write(text);
+                return (1, default);
+            }
+
+            var hash = new HashKey(text);
+            if (!stringHashes.TryGetValue(hash, out var recordId))
+            {
+                recordId = stringRecordId;
+                stringHashes[hash] = stringRecordId;
+
+                WriteStringRecord(text);
+
+                stringRecordId += 1;
             }
+
+            return (recordId, hash);
+        }
+
+        private void WriteStringRecord(string text)
+        {
+            using var redirectionScope = RedirectWritesToOriginalWriter();
+
+            Write(BinaryLogRecordKind.String);
+            binaryWriter.Write(text);
         }
 
         private void Write(DateTime timestamp)
@@ -761,10 +985,10 @@ private void Write(TimeSpan timeSpan)
 
         private void Write(EvaluationLocation item)
         {
-            WriteOptionalString(item.ElementName);
-            WriteOptionalString(item.ElementDescription);
-            WriteOptionalString(item.EvaluationPassDescription);
-            WriteOptionalString(item.File);
+            WriteDeduplicatedString(item.ElementName);
+            WriteDeduplicatedString(item.ElementDescription);
+            WriteDeduplicatedString(item.EvaluationPassDescription);
+            WriteDeduplicatedString(item.File);
             Write((int)item.Kind);
             Write((int)item.EvaluationPass);
 
@@ -788,5 +1012,89 @@ private void Write(ProfiledLocation e)
             Write(e.ExclusiveTime);
             Write(e.InclusiveTime);
         }
+
+        internal readonly struct HashKey : IEquatable<HashKey>
+        {
+            private readonly ulong value;
+
+            private HashKey(ulong i)
+            {
+                value = i;
+            }
+
+            public HashKey(string text)
+            {
+                if (text == null)
+                {
+                    value = 0;
+                }
+                else
+                {
+                    value = FnvHash64.GetHashCode(text);
+                }
+            }
+
+            public static HashKey Combine(HashKey left, HashKey right)
+            {
+                return new HashKey(FnvHash64.Combine(left.value, right.value));
+            }
+
+            public HashKey Add(HashKey other) => Combine(this, other);
+
+            public bool Equals(HashKey other)
+            {
+                return value == other.value;
+            }
+
+            public override bool Equals(object obj)
+            {
+                if (obj is HashKey other)
+                {
+                    return Equals(other);
+                }
+
+                return false;
+            }
+
+            public override int GetHashCode()
+            {
+                return unchecked((int)value);
+            }
+
+            public override string ToString()
+            {
+                return value.ToString();
+            }
+        }
+
+        internal static class FnvHash64
+        {
+            public const ulong Offset = 14695981039346656037;
+            public const ulong Prime = 1099511628211;
+
+            public static ulong GetHashCode(string text)
+            {
+                ulong hash = Offset;
+
+                unchecked
+                {
+                    for (int i = 0; i < text.Length; i++)
+                    {
+                        char ch = text[i];
+                        hash = (hash ^ ch) * Prime;
+                    }
+                }
+
+                return hash;
+            }
+
+            public static ulong Combine(ulong left, ulong right)
+            {
+                unchecked
+                {
+                    return (left ^ right) * Prime;
+                }
+            }
+        }
     }
 }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 1a851c22044..d71f127c265 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -32,8 +32,6 @@
 
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
-    <PackageReference Include="System.Memory" />
-    <PackageReference Include="System.Runtime.CompilerServices.Unsafe"/>
     <PackageReference Include="System.Text.Json" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
@@ -43,6 +41,7 @@
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" />
     <Reference Include="System.Configuration" />
     <Reference Include="System.IO.Compression" />
+    <PackageReference Include="System.Memory" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 7d3fa3d7161..5b737e6d5f0 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1225,7 +1225,7 @@
     <comment>{StrBegin="MSB4091: "}</comment>
   </data>
   <data name="UnexpectedTaskAttribute" xml:space="preserve">
-    <value>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</value>
+    <value>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</value>
     <comment>{StrBegin="MSB4064: "}</comment>
   </data>
   <data name="UnexpectedTaskOutputAttribute" xml:space="preserve">
@@ -1846,10 +1846,10 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>A required NuGet assembly was not found. Expected Path: {0}</value>
   </data>
   <data name="StaticGraphConstructionMetrics" xml:space="preserve">
-    <value>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</value>
+    <value>Static graph loaded in {0} seconds: {1} nodes, {2} edges</value>
   </data>
   <data name="IsolatedContextDoesNotSupportFileSystem" xml:space="preserve">
-    <value>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</value>
+    <value>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</value>
   </data>
   <data name="LoadingProjectCachePlugin" xml:space="preserve">
     <value>"Loading the following project cache plugin:
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index e53798c778d..157443afc16 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -128,15 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">Objekty EvaluationContext vytvořené pomocí SharingPolicy.Isolated nepodporují předávání souborového systému MSBuildFileSystemBase.</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">Objekty EvaluationContext vytvořené pomocí SharingPolicy.Isolated nepodporují předávání souborového systému MSBuildFileSystemBase.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>"Loading the following project cache plugin:
     {0}"</source>
-        <target state="new">"Loading the following project cache plugin:
-    {0}"</target>
+        <target state="translated">Načítá se následující modul plug-in mezipaměti projektu:
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -163,12 +163,12 @@
       </trans-unit>
       <trans-unit id="NoProjectCachePluginFoundInAssembly">
         <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
-        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <target state="translated">MSB4270: V sestavení {0} se nenašly žádné moduly plug-in mezipaměti projektu. Modul plug-in se očekával.</target>
         <note />
       </trans-unit>
       <trans-unit id="NotAllNodesDefineACacheItem">
         <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <target state="translated">MSB4269: Pokud jakýkoli uzel statického grafu definuje mezipaměť projektu, musí všechny uzly definovat stejnou mezipaměť projektu. Následující projekty neobsahují deklaraci položky {0}: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -211,22 +211,22 @@
       </trans-unit>
       <trans-unit id="OnlyOneCachePluginMustBeSpecified">
         <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <target state="translated">MSB4265: Musí se zadat jeden modul plug-in mezipaměti projektu, ale našlo se jich více: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
-        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <target state="translated">MSB4266: Nepovedlo se inicializovat mezipaměť projektu.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheQueryFailed">
         <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
-        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <target state="translated">MSB4267: Při dotazování na následující projekt selhala jeho mezipaměť: {0}. Na mezipaměť se dotazy posílají paralelně pro několik projektů, takže tento konkrétní projekt nemusí být příčinou.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheShutdownFailed">
         <source>MSB4268: The project cache failed to shut down properly.</source>
-        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <target state="translated">MSB4268: Mezipaměť projektu se nepovedlo správně vypnout.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
@@ -251,7 +251,7 @@
       </trans-unit>
       <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
         <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
-        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <target state="translated">MSB4264: Neplatná vlastnost $(SolutionPath): {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
@@ -262,8 +262,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">Statický graf se načetl za {0} s: počet uzlů: {1}, počet hraničních uzlů: {2}</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">Statický graf se načetl za {0} s: počet uzlů: {1}, počet hraničních uzlů: {2}</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1670,8 +1670,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: Parametr {0} není podporován úlohou {1}. Zkontrolujte, zda parametr úlohy existuje a zda se jedná o nastavitelnou vlastnost veřejné instance.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index cedd498f70f..895d6839645 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -128,14 +128,14 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"Die Übergabe eines MSBuildFileSystemBase-Dateisystems wird von EvaluationContext-Objekten, die mit SharingPolicy.Isolated erstellt wurden, nicht unterstützt."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"Die Übergabe eines MSBuildFileSystemBase-Dateisystems wird von EvaluationContext-Objekten, die mit SharingPolicy.Isolated erstellt wurden, nicht unterstützt."</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>"Loading the following project cache plugin:
     {0}"</source>
-        <target state="new">"Loading the following project cache plugin:
+        <target state="translated">"Folgendes Projektcache-Plug-In wird geladen:
     {0}"</target>
         <note />
       </trans-unit>
@@ -163,12 +163,12 @@
       </trans-unit>
       <trans-unit id="NoProjectCachePluginFoundInAssembly">
         <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
-        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <target state="translated">MSB4270: In der Assembly "{0}" wurde ein Projektcache-Plug-In erwartet, aber keines gefunden.</target>
         <note />
       </trans-unit>
       <trans-unit id="NotAllNodesDefineACacheItem">
         <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <target state="translated">MSB4269: Wenn ein statischer Graphknoten einen Projektcache definiert, müssen alle Knoten denselben Projektcache definieren. Die folgenden Projekte enthalten keine Deklaration des Elements "{0}": {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -211,22 +211,22 @@
       </trans-unit>
       <trans-unit id="OnlyOneCachePluginMustBeSpecified">
         <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <target state="translated">MSB4265: Ein einzelnes Projektcache-Plug-In muss angegeben werden, es wurden jedoch mehrere gefunden: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
-        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <target state="translated">MSB4266: Fehler beim Initialisieren des Projektcache.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheQueryFailed">
         <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
-        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <target state="translated">MSB4267: Fehler beim Abfragen des Projektcache für das folgende Projekt: {0}. Der Cache wird für mehrere Projekte parallel abgefragt, sodass dieses spezifische Projekt möglicherweise nicht die Ursache darstellt.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheShutdownFailed">
         <source>MSB4268: The project cache failed to shut down properly.</source>
-        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <target state="translated">MSB4268: Der Projektcache konnte nicht ordnungsgemäß heruntergefahren werden.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
@@ -251,7 +251,7 @@
       </trans-unit>
       <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
         <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
-        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <target state="translated">"MSB4264: Ungültige $(SolutionPath)-Eigenschaft: {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
@@ -262,8 +262,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"Statisches Diagramm in {0} Sekunden geladen: {1} Knoten, {2} Edges"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"Statisches Diagramm in {0} Sekunden geladen: {1} Knoten, {2} Edges"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1670,8 +1670,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: Der "{0}"-Parameter wird von der "{1}"-Aufgabe nicht unterstützt. Vergewissern Sie sich, dass der Parameter in der Aufgabe vorhanden ist und es sich um eine festlegbare öffentliche Instanzeigenschaft handelt.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index d2f150f9752..444ca3a5542 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -128,8 +128,8 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="new">"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="new">EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
@@ -262,8 +262,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="new">Static graph loaded in {0} seconds: {1} nodes, {2} edges</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1715,8 +1715,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 67be95b5e38..36a2729aa8b 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -128,15 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"Los objetos EvaluationContext creados con SharingPolicy.Isolated no admiten que se les pase un sistema de archivos MSBuildFileSystemBase".</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"Los objetos EvaluationContext creados con SharingPolicy.Isolated no admiten que se les pase un sistema de archivos MSBuildFileSystemBase".</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>"Loading the following project cache plugin:
     {0}"</source>
-        <target state="new">"Loading the following project cache plugin:
-    {0}"</target>
+        <target state="translated">"Cargando el complemento de caché de proyectos siguiente:
+    {0} "</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -163,12 +163,12 @@
       </trans-unit>
       <trans-unit id="NoProjectCachePluginFoundInAssembly">
         <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
-        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <target state="translated">MSB4270: No se encontró ningún complemento de caché de proyectos en el ensamblado "{0}". Se esperaba uno.</target>
         <note />
       </trans-unit>
       <trans-unit id="NotAllNodesDefineACacheItem">
         <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <target state="translated">MSB4269: Cuando un nodo de gráfico estático define una memoria caché de proyectos, todos los nodos deben definir la misma caché de proyectos. Los proyectos siguientes no contienen ninguna declaración de elemento "{0}": {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -211,22 +211,22 @@
       </trans-unit>
       <trans-unit id="OnlyOneCachePluginMustBeSpecified">
         <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <target state="translated">MSB4265: Debe especificarse un solo complemento de caché de proyectos, pero se encontraron varios: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
-        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <target state="translated">MSB4266: No se pudo inicializar la caché de proyectos.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheQueryFailed">
         <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
-        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <target state="translated">MSB4267: Error de la memoria caché de proyectos al consultar el proyecto siguiente: {0}. La memoria caché se consulta en paralelo para varios proyectos, por lo que puede que este proyecto específico no sea la causa.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheShutdownFailed">
         <source>MSB4268: The project cache failed to shut down properly.</source>
-        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <target state="translated">MSB4268: La memoria caché de proyectos no se cerró correctamente.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
@@ -251,7 +251,7 @@
       </trans-unit>
       <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
         <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
-        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <target state="translated">"MSB4264: Propiedad $(SolutionPath) no válida: {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
@@ -262,8 +262,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"Grafo estático cargado en {0} segundos: {1} nodos, {2} bordes"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"Grafo estático cargado en {0} segundos: {1} nodos, {2} bordes"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1670,8 +1670,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: El parámetro "{0}" no es compatible con la tarea "{1}". Compruebe que el parámetro existe en la tarea y que es una propiedad de instancia Public que se puede establecer.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index fd377f2b9be..26c0b149b57 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -128,14 +128,14 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"Les objets EvaluationContext créés avec SharingPolicy.Isolated ne prennent pas en charge le passage d'un système de fichiers MSBuildFileSystemBase."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"Les objets EvaluationContext créés avec SharingPolicy.Isolated ne prennent pas en charge le passage d'un système de fichiers MSBuildFileSystemBase."</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>"Loading the following project cache plugin:
     {0}"</source>
-        <target state="new">"Loading the following project cache plugin:
+        <target state="translated">"Chargement du plug-in de cache de projet suivant :
     {0}"</target>
         <note />
       </trans-unit>
@@ -163,12 +163,12 @@
       </trans-unit>
       <trans-unit id="NoProjectCachePluginFoundInAssembly">
         <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
-        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <target state="translated">MSB4270: plug-ins de cache de projet introuvables dans l'assembly "{0}". Un plug-in est attendu.</target>
         <note />
       </trans-unit>
       <trans-unit id="NotAllNodesDefineACacheItem">
         <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <target state="translated">MSB4269: quand un nœud de graphe statique définit un cache de projet, tous les nœuds doivent définir le même cache de projet. Le ou les projets suivants ne contiennent pas de déclaration d'élément "{0}" : {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -211,22 +211,22 @@
       </trans-unit>
       <trans-unit id="OnlyOneCachePluginMustBeSpecified">
         <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <target state="translated">MSB4265: un seul plug-in de cache de projet doit être spécifié, mais plusieurs plug-ins ont été trouvés : {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
-        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <target state="translated">MSB4266: échec de l'initialisation du cache de projet.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheQueryFailed">
         <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
-        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <target state="translated">MSB4267: échec du cache de projet au moment où il a été interrogé pour le projet suivant : {0}. Dans la mesure où le cache est interrogé en parallèle pour plusieurs projets, ce projet spécifique n'est peut-être pas à l'origine du problème.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheShutdownFailed">
         <source>MSB4268: The project cache failed to shut down properly.</source>
-        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <target state="translated">MSB4268: le cache de projet ne s'est pas arrêté correctement.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
@@ -251,7 +251,7 @@
       </trans-unit>
       <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
         <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
-        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <target state="translated">"MSB4264: propriété $(SolutionPath) non valide : {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
@@ -262,8 +262,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"Graphe statique chargé en {0} secondes : {1} nœuds, {2} arêtes"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"Graphe statique chargé en {0} secondes : {1} nœuds, {2} arêtes"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1670,8 +1670,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: Le paramètre "{0}" n'est pas pris en charge par la tâche "{1}". Vérifiez que le paramètre existe pour la tâche et qu'il représente une propriété d'instance publique définissable.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 08e593ca38c..86a00974a5f 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -128,14 +128,14 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"Agli oggetti EvaluationContext creati con SharingPolicy.Isolated non è possibile passare un file system MSBuildFileSystemBase."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"Agli oggetti EvaluationContext creati con SharingPolicy.Isolated non è possibile passare un file system MSBuildFileSystemBase."</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>"Loading the following project cache plugin:
     {0}"</source>
-        <target state="new">"Loading the following project cache plugin:
+        <target state="translated">"Caricamento del plug-in seguente della cache del progetto:
     {0}"</target>
         <note />
       </trans-unit>
@@ -163,12 +163,12 @@
       </trans-unit>
       <trans-unit id="NoProjectCachePluginFoundInAssembly">
         <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
-        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <target state="translated">MSB4270: non sono stati trovati plug-in della cache del progetto nell'assembly "{0}". Ne è previsto uno.</target>
         <note />
       </trans-unit>
       <trans-unit id="NotAllNodesDefineACacheItem">
         <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <target state="translated">MSB4269: quando un nodo di grafo statico definisce una cache del progetto, tutti i nodi devono definire la stessa cache del progetto. Il progetto o i progetti seguenti non contengono una dichiarazione di elemento "{0}": {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -211,22 +211,22 @@
       </trans-unit>
       <trans-unit id="OnlyOneCachePluginMustBeSpecified">
         <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <target state="translated">MSB4265: è necessario specificare un singolo plug-in della cache del progetto, ma ne sono trovati più di uno: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
-        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <target state="translated">MSB4266: non è stato possibile inizializzare la cache del progetto.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheQueryFailed">
         <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
-        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <target state="translated">MSB4267: si è verificato un errore nella cache del progetto durante l'esecuzione della query relativa al progetto seguente: {0}. La query sulla cache viene eseguita in parallelo per più progetti, di conseguenza l'errore potrebbe non dipendere dal progetto specifico.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheShutdownFailed">
         <source>MSB4268: The project cache failed to shut down properly.</source>
-        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <target state="translated">MSB4268: non è stato possibile arrestare correttamente la cache del progetto.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
@@ -251,7 +251,7 @@
       </trans-unit>
       <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
         <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
-        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <target state="translated">"MSB4264: la proprietà $(SolutionPath) non è valida: {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
@@ -262,8 +262,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"Il grafo statico è stato caricato in {0} secondi: {1} nodi, {2} vertici"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"Il grafo statico è stato caricato in {0} secondi: {1} nodi, {2} vertici"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1670,8 +1670,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: il parametro "{0}" non è supportato dall'attività "{1}". Verificare che il parametro sia presente per l'attività e che si tratti di un'istanza pubblica e impostabile della proprietà.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 375becad3df..27c3d3f6130 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -128,14 +128,14 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"SharingPolicy.Isolated を指定して作成された EvaluationContext オブジェクトに MSBuildFileSystemBase ファイル システムを渡すことはサポートされていません。"</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"SharingPolicy.Isolated を指定して作成された EvaluationContext オブジェクトに MSBuildFileSystemBase ファイル システムを渡すことはサポートされていません。"</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>"Loading the following project cache plugin:
     {0}"</source>
-        <target state="new">"Loading the following project cache plugin:
+        <target state="translated">"次のプロジェクト キャッシュ プラグインを読み込んでいます。
     {0}"</target>
         <note />
       </trans-unit>
@@ -163,12 +163,12 @@
       </trans-unit>
       <trans-unit id="NoProjectCachePluginFoundInAssembly">
         <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
-        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <target state="translated">MSB4270: プロジェクト キャッシュのプラグインがアセンブリ "{0}" に見つかりませんでした。プラグインが 1 つ必要です。</target>
         <note />
       </trans-unit>
       <trans-unit id="NotAllNodesDefineACacheItem">
         <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <target state="translated">MSB4269: 静的グラフ ノードでプロジェクト キャッシュが定義されている場合、すべてのノードで同じプロジェクト キャッシュを定義する必要があります。プロジェクト {1} には、"{0}" 項目宣言が含まれていません</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -211,22 +211,22 @@
       </trans-unit>
       <trans-unit id="OnlyOneCachePluginMustBeSpecified">
         <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <target state="translated">MSB4265: 単一のプロジェクト キャッシュ プラグインを指定する必要がありますが、複数指定されています。{0}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
-        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <target state="translated">MSB4266: プロジェクト キャッシュを初期化できませんでした。</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheQueryFailed">
         <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
-        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <target state="translated">MSB4267: プロジェクト キャッシュは、プロジェクト {0} に対してクエリを実行しているときに失敗しました。このキャッシュでは複数のプロジェクトについて並列でクエリが実行されるため、この特定のプロジェクトが原因ではない可能性があります。</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheShutdownFailed">
         <source>MSB4268: The project cache failed to shut down properly.</source>
-        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <target state="translated">MSB4268: プロジェクト キャッシュは正常にシャットダウンできませんでした。</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
@@ -251,7 +251,7 @@
       </trans-unit>
       <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
         <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
-        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <target state="translated">"MSB4264: 無効な $(SolutionPath) プロパティ: {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
@@ -262,8 +262,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"{0} 秒で読み込まれた静的グラフ: {1} ノード、{2} エッジ"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"{0} 秒で読み込まれた静的グラフ: {1} ノード、{2} エッジ"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1670,8 +1670,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: "{0}" パラメーターは "{1}" タスクではサポートされていません。タスク上にパラメーターが存在し、設定可能なパブリック インスタンス プロパティであることを確認してください。</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 71515138175..367cf54895e 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -128,14 +128,14 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"SharingPolicy.Isolated로 만든 EvaluationContext 개체는 MSBuildFileSystemBase 파일 시스템 전달을 지원하지 않습니다."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"SharingPolicy.Isolated로 만든 EvaluationContext 개체는 MSBuildFileSystemBase 파일 시스템 전달을 지원하지 않습니다."</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>"Loading the following project cache plugin:
     {0}"</source>
-        <target state="new">"Loading the following project cache plugin:
+        <target state="translated">"다음 프로젝트 캐시 플러그 인을 로드하는 중:
     {0}"</target>
         <note />
       </trans-unit>
@@ -163,12 +163,12 @@
       </trans-unit>
       <trans-unit id="NoProjectCachePluginFoundInAssembly">
         <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
-        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <target state="translated">MSB4270: "{0}" 어셈블리에서 프로젝트 캐시 플러그 인을 찾을 수 없습니다. 1개가 필요합니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="NotAllNodesDefineACacheItem">
         <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <target state="translated">MSB4269: 정적 그래프 노드에서 프로젝트 캐시를 정의할 때 모든 노드는 같은 프로젝트 캐시를 정의해야 합니다. {1} 프로젝트에는 "{0}" 항목 선언이 포함되어 있지 않습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -211,22 +211,22 @@
       </trans-unit>
       <trans-unit id="OnlyOneCachePluginMustBeSpecified">
         <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <target state="translated">MSB4265: 단일 프로젝트 캐시 플러그 인이 지정되어야 하지만, {0}에서 여러 개를 찾았습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
-        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <target state="translated">MSB4266: 프로젝트 캐시를 초기화하지 못했습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheQueryFailed">
         <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
-        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <target state="translated">MSB4267: {0} 프로젝트에 대해 쿼리되는 동안 프로젝트 캐시가 실패했습니다. 캐시는 여러 프로젝트에 대해 병렬로 쿼리되므로 이 특정 프로젝트가 원인이 아닐 수 있습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheShutdownFailed">
         <source>MSB4268: The project cache failed to shut down properly.</source>
-        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <target state="translated">MSB4268: 프로젝트 캐시가 제대로 종료되지 않았습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
@@ -251,7 +251,7 @@
       </trans-unit>
       <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
         <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
-        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <target state="translated">"MSB4264: 잘못된 $(SolutionPath) 속성: {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
@@ -262,8 +262,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"정적 그래프가 {0}초 안에 로드됨: {1}개 노드, {2}개 에지"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"정적 그래프가 {0}초 안에 로드됨: {1}개 노드, {2}개 에지"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1670,8 +1670,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: "{1}" 작업에서 "{0}" 매개 변수를 지원하지 않습니다. 해당 매개 변수가 작업에 있는지 그리고 설정 가능한 public 인스턴스 속성인지 확인하세요.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
@@ -2306,7 +2306,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
       </trans-unit>
       <trans-unit id="ProjectImportSkippedFalseCondition">
         <source>Project "{0}" was not imported by "{1}" at ({2},{3}), due to false condition; ({4}) was evaluated as ({5}).</source>
-        <target state="translated">false 조건으로 인해 ({2},{3})의 "{1}”이(가) "{0}" 프로젝트를 가져오지 않았습니다. ({4})은(는) ({5})(으)로 확인되었습니다.</target>
+        <target state="translated">false 조건으로 인해 ({2},{3})의 "{1}"이(가) "{0}" 프로젝트를 가져오지 않았습니다. ({4})은(는) ({5})(으)로 확인되었습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectImportSkippedNoMatches">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 6e351a614d3..b13eb7e424f 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -128,15 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">„Obiekty EvaluationContext utworzone za pomocą elementu SharingPolicy.Isolated nie obsługują przekazywania za pomocą systemu plików MSBuildFileSystemBase.”</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">„Obiekty EvaluationContext utworzone za pomocą elementu SharingPolicy.Isolated nie obsługują przekazywania za pomocą systemu plików MSBuildFileSystemBase.”</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>"Loading the following project cache plugin:
     {0}"</source>
-        <target state="new">"Loading the following project cache plugin:
-    {0}"</target>
+        <target state="translated">„Ładowanie następującej wtyczki pamięci podręcznej projektu:
+    {0}”</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -163,12 +163,12 @@
       </trans-unit>
       <trans-unit id="NoProjectCachePluginFoundInAssembly">
         <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
-        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <target state="translated">MSB4270: nie znaleziono wtyczek pamięci podręcznej projektu w zestawie „{0}”. Oczekiwano jednej.</target>
         <note />
       </trans-unit>
       <trans-unit id="NotAllNodesDefineACacheItem">
         <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <target state="translated">MSB4269: gdy dowolny węzeł wykresu statycznego definiuje pamięć podręczną projektu, wszystkie węzły muszą definiować tę samą pamięć podręczną projektu. Następujące projekty nie zawierają deklaracji elementu „{0}”: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -211,22 +211,22 @@
       </trans-unit>
       <trans-unit id="OnlyOneCachePluginMustBeSpecified">
         <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <target state="translated">MSB4265: należy określić jedną wtyczkę pamięci podręcznej projektu, ale znaleziono ich wiele: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
-        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <target state="translated">MSB4266: nie można zainicjować pamięci podręcznej projektu.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheQueryFailed">
         <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
-        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <target state="translated">MSB4267: w pamięci podręcznej projektu wystąpił błąd podczas wykonywania zapytania dotyczącego następującego projektu: {0}. Względem pamięci podręcznej równolegle są wykonywane zapytania o wiele projektów, dlatego ten konkretny projekt może nie być przyczyną.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheShutdownFailed">
         <source>MSB4268: The project cache failed to shut down properly.</source>
-        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <target state="translated">MSB4268: nie można poprawnie zamknąć pamięci podręcznej projektu.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
@@ -251,7 +251,7 @@
       </trans-unit>
       <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
         <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
-        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <target state="translated">„MSB4264: nieprawidłowa właściwość $(SolutionPath): {0}”</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
@@ -262,8 +262,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">„Wykres statyczny załadowany w {0} s, węzły: {1}, krawędzie: {2}”</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">„Wykres statyczny załadowany w {0} s, węzły: {1}, krawędzie: {2}”</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1670,8 +1670,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: Parametr „{0}” nie jest obsługiwany przez zadanie „{1}”. Sprawdź, czy parametr istnieje w zadaniu i czy jest właściwością wystąpienia publicznego, którą można ustawić.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
@@ -2090,7 +2090,7 @@ Wykorzystanie:          Średnie wykorzystanie {0}: {1:###.0}</target>
       </trans-unit>
       <trans-unit id="OM_ProjectXmlCannotBeUnloadedDueToLoadedProjects">
         <source>The project XML file "{0}" cannot be unloaded because at least one project "{1}" is still loaded which references that project XML.</source>
-        <target state="translated">Nie można zwolnić pliku XML „{0}” projektu, ponieważ jest nadal załadowany co najmniej jeden projekt „{1}", który odwołuje się do kodu XML tego projektu.</target>
+        <target state="translated">Nie można zwolnić pliku XML „{0}” projektu, ponieważ jest nadal załadowany co najmniej jeden projekt „{1}”, który odwołuje się do kodu XML tego projektu.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_ProjectInstanceImmutable">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index f70c147770a..188df5f9cf3 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -128,14 +128,14 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"Os objetos EvaluationContext criados com SharingPolicy.Isolable não são compatíveis com o recebimento de um sistema de arquivos MSBuildFileSystemBase."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"Os objetos EvaluationContext criados com SharingPolicy.Isolable não são compatíveis com o recebimento de um sistema de arquivos MSBuildFileSystemBase."</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>"Loading the following project cache plugin:
     {0}"</source>
-        <target state="new">"Loading the following project cache plugin:
+        <target state="translated">"Carregando o seguinte plug-in de cache do projeto:
     {0}"</target>
         <note />
       </trans-unit>
@@ -163,12 +163,12 @@
       </trans-unit>
       <trans-unit id="NoProjectCachePluginFoundInAssembly">
         <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
-        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <target state="translated">MSB4270: não foi encontrado nenhum plug-in de cache do projeto no assembly "{0}". Era esperado um plug-in.</target>
         <note />
       </trans-unit>
       <trans-unit id="NotAllNodesDefineACacheItem">
         <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <target state="translated">MSB4269: quando algum nó de grafo estático define um cache do projeto, todos os nós precisam definir o mesmo cache do projeto. Os seguintes projetos não contêm uma declaração de item "{0}": {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -211,22 +211,22 @@
       </trans-unit>
       <trans-unit id="OnlyOneCachePluginMustBeSpecified">
         <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <target state="translated">MSB4265: é necessário especificar só um plug-in de cache do projeto, mas foram encontrados vários: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
-        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <target state="translated">MSB4266: falha ao inicializar o cache do projeto.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheQueryFailed">
         <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
-        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <target state="translated">MSB4267: falha no cache do projeto durante a consulta do seguinte projeto: {0}. O cache é consultado em paralelo quanto a vários projetos, portanto, esse projeto específico pode não ser a causa.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheShutdownFailed">
         <source>MSB4268: The project cache failed to shut down properly.</source>
-        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <target state="translated">MSB4268: falha ao desligar o cache do projeto corretamente.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
@@ -251,7 +251,7 @@
       </trans-unit>
       <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
         <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
-        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <target state="translated">"MSB4264: propriedade $(SolutionPath) inválida: {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
@@ -262,8 +262,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"Grafo estático carregado em {0} segundos: {1} nós, {2} bordas"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"Grafo estático carregado em {0} segundos: {1} nós, {2} bordas"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1670,8 +1670,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: O parâmetro "{0}" não tem suporte na tarefa "{1}". Verifique se o parâmetro existe na tarefa e se ele é uma propriedade de instância pública que pode ser definida.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index cd8b9a1caac..508d9a08b28 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -128,14 +128,14 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"Объекты EvaluationContext, созданные с помощью SharingPolicy.Isolated, не поддерживают передачу в файловую систему MSBuildFileSystemBase."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"Объекты EvaluationContext, созданные с помощью SharingPolicy.Isolated, не поддерживают передачу в файловую систему MSBuildFileSystemBase."</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>"Loading the following project cache plugin:
     {0}"</source>
-        <target state="new">"Loading the following project cache plugin:
+        <target state="translated">"Идет загрузка следующего подключаемого модуля кэша проектов:
     {0}"</target>
         <note />
       </trans-unit>
@@ -163,12 +163,12 @@
       </trans-unit>
       <trans-unit id="NoProjectCachePluginFoundInAssembly">
         <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
-        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <target state="translated">MSB4270: не найдены подключаемые модули кэша проектов в сборке "{0}". Должен быть указан один модуль.</target>
         <note />
       </trans-unit>
       <trans-unit id="NotAllNodesDefineACacheItem">
         <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <target state="translated">MSB4269: если для какого-либо узла статического графа определен кэш проектов, этот кэш должен быть указан для всех узлов. Следующие проекты не содержат объявление элемента "{0}": {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -211,22 +211,22 @@
       </trans-unit>
       <trans-unit id="OnlyOneCachePluginMustBeSpecified">
         <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <target state="translated">MSB4265: должен быть указан один подключаемый модуль кэша проектов, но найдено несколько: {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
-        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <target state="translated">MSB4266: не удалось инициализировать кэш проектов.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheQueryFailed">
         <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
-        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <target state="translated">MSB4267: произошел сбой кэша при выполнении запроса к следующему проекту: {0}. К кэшу выполнены параллельные запросы к нескольким проектам, поэтому, возможно, причина не в указанном проекте.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheShutdownFailed">
         <source>MSB4268: The project cache failed to shut down properly.</source>
-        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <target state="translated">MSB4268: не удалось правильно завершить работу кэша проектов.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
@@ -251,7 +251,7 @@
       </trans-unit>
       <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
         <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
-        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <target state="translated">"MSB4264: недопустимое свойство $(SolutionPath) — {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
@@ -262,8 +262,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"Статический граф загружен за {0} с: узлов — {1}, ребер — {2}."</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"Статический граф загружен за {0} с: узлов — {1}, ребер — {2}."</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -678,7 +678,7 @@
       </trans-unit>
       <trans-unit id="FatalTaskError">
         <source>MSB4018: The "{0}" task failed unexpectedly.</source>
-        <target state="translated">MSB4018: непредвиденная ошибка при выполнении задачи {0}".</target>
+        <target state="translated">MSB4018: непредвиденная ошибка при выполнении задачи "{0}".</target>
         <note>{StrBegin="MSB4018: "}UE: This message is shown when a task terminates because of an unhandled exception. The cause is most likely a
     programming error in the task; however, it is also possible that the unhandled exception originated in the engine, and was
     surfaced through the task when the task called into the engine.</note>
@@ -1670,8 +1670,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: параметр "{0}" не поддерживается задачей "{1}". Убедитесь, что параметр существует в задаче и является открытым задаваемым свойством экземпляра.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 825f2dcc90a..9bcd9bde59b 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -128,14 +128,14 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"SharingPolicy.Isolated ile oluşturulan EvaluationContext nesneleri bir MSBuildFileSystemBase dosya sisteminin geçirilmesini desteklemez."</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"SharingPolicy.Isolated ile oluşturulan EvaluationContext nesneleri bir MSBuildFileSystemBase dosya sisteminin geçirilmesini desteklemez."</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>"Loading the following project cache plugin:
     {0}"</source>
-        <target state="new">"Loading the following project cache plugin:
+        <target state="translated">"Şu proje önbelleği eklentisi yükleniyor:
     {0}"</target>
         <note />
       </trans-unit>
@@ -163,12 +163,12 @@
       </trans-unit>
       <trans-unit id="NoProjectCachePluginFoundInAssembly">
         <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
-        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <target state="translated">MSB4270: "{0}" bütünleştirilmiş kodunda proje önbelleği eklentisi bulunamadı. Bir eklenti bekleniyordu.</target>
         <note />
       </trans-unit>
       <trans-unit id="NotAllNodesDefineACacheItem">
         <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <target state="translated">MSB4269: Herhangi bir statik graf düğümünde proje önbelleği tanımlandığında tüm düğümler aynı proje önbelleğini tanımlamalıdır. Şu projeler "{0}" öğe bildirimini içermiyor: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -211,22 +211,22 @@
       </trans-unit>
       <trans-unit id="OnlyOneCachePluginMustBeSpecified">
         <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <target state="translated">MSB4265: Tek bir proje önbellek eklentisi belirtilmelidir ancak birden çok eklenti bulundu: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
-        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <target state="translated">MSB4266: Proje önbelleği başlatılamadı.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheQueryFailed">
         <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
-        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <target state="translated">MSB4267: Proje önbelleği, {0} projesi için sorgulanırken başarısız oldu. Önbellek birden çok proje için paralel olarak sorgulandığından sorunun nedeni bu proje olmayabilir.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheShutdownFailed">
         <source>MSB4268: The project cache failed to shut down properly.</source>
-        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <target state="translated">MSB4268: Proje önbelleği düzgün bir şekilde kapatılamadı.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
@@ -251,7 +251,7 @@
       </trans-unit>
       <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
         <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
-        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <target state="translated">"MSB4264: $(SolutionPath) özelliği geçersiz: {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
@@ -262,8 +262,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"Statik graf {0} saniye içinde yüklendi: {1} düğüm, {2} uç"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"Statik graf {0} saniye içinde yüklendi: {1} düğüm, {2} uç"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1670,8 +1670,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: "{0}" parametresi "{1}" görevi tarafından desteklenmiyor. Parametrenin görevde bulunduğunu ve ayarlanabilir bir genel örnek özelliği olduğunu doğrulayın.</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index cf4bce1a797..942ffe8d692 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -128,15 +128,15 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">“使用 SharingPolicy.Isolated 创建的 EvaluationContext 对象不支持通过 MSBuildFileSystemBase 文件系统传递。”</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">“使用 SharingPolicy.Isolated 创建的 EvaluationContext 对象不支持通过 MSBuildFileSystemBase 文件系统传递。”</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>"Loading the following project cache plugin:
     {0}"</source>
-        <target state="new">"Loading the following project cache plugin:
-    {0}"</target>
+        <target state="translated">“正在加载以下项目缓存插件:
+    {0}”</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -163,12 +163,12 @@
       </trans-unit>
       <trans-unit id="NoProjectCachePluginFoundInAssembly">
         <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
-        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <target state="translated">MSB4270: 在程序集 "{0}" 中未找到项目缓存插件。应有一个插件。</target>
         <note />
       </trans-unit>
       <trans-unit id="NotAllNodesDefineACacheItem">
         <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <target state="translated">MSB4269: 当任何静态关系图节点定义项目缓存时，所有节点必须定义相同的项目缓存。以下项目不包含 "{0}" 项声明: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -211,22 +211,22 @@
       </trans-unit>
       <trans-unit id="OnlyOneCachePluginMustBeSpecified">
         <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <target state="translated">MSB4265: 必须指定单个项目缓存插件，但找到多个位置: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
-        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <target state="translated">MSB4266: 未能初始化项目缓存。</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheQueryFailed">
         <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
-        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <target state="translated">MSB4267: 查询以下项目时，项目缓存失败: {0}。并行查询了多个项目的缓存，因此这一项目可能不是导致此问题的原因。</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheShutdownFailed">
         <source>MSB4268: The project cache failed to shut down properly.</source>
-        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <target state="translated">MSB4268: 项目缓存未能正确关闭。</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
@@ -251,7 +251,7 @@
       </trans-unit>
       <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
         <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
-        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <target state="translated">“MSB4264: $(SolutionPath) 属性无效: {0}”</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
@@ -262,8 +262,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">“静态图形已在 {0} 秒内加载: {1} 个节点、{2} 个边”</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">“静态图形已在 {0} 秒内加载: {1} 个节点、{2} 个边”</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1670,8 +1670,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: “{1}”任务不支持“{0}”参数。请确认该参数存在于此任务中，并且是可设置的公共实例属性。</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 64f91b3ebe5..eadd2f2e6cc 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -128,14 +128,14 @@
         <note />
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
-        <source>"EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system."</source>
-        <target state="translated">"使用 SharingPolicy.Isolated 建立的 EvaluationContext 物件不支援以 MSBuildFileSystemBase 檔案系統傳遞。"</target>
+        <source>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</source>
+        <target state="needs-review-translation">"使用 SharingPolicy.Isolated 建立的 EvaluationContext 物件不支援以 MSBuildFileSystemBase 檔案系統傳遞。"</target>
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>"Loading the following project cache plugin:
     {0}"</source>
-        <target state="new">"Loading the following project cache plugin:
+        <target state="translated">"正在載入下列專案快取外掛程式:
     {0}"</target>
         <note />
       </trans-unit>
@@ -163,12 +163,12 @@
       </trans-unit>
       <trans-unit id="NoProjectCachePluginFoundInAssembly">
         <source>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</source>
-        <target state="new">MSB4270: No project cache plugins found in assembly "{0}". Expected one.</target>
+        <target state="translated">MSB4270: 在組件 "{0}" 中找不到任何專案快取外掛程式，但應該要有一個外掛程式。</target>
         <note />
       </trans-unit>
       <trans-unit id="NotAllNodesDefineACacheItem">
         <source>MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</source>
-        <target state="new">MSB4269: When any static graph node defines a project cache, all nodes must define the same project cache. The following project(s) do not contain a "{0}" item declaration: {1}</target>
+        <target state="translated">MSB4269: 當任何靜態圖表節點定義了專案快取時，所有節點都必須定義相同的專案快取。下列專案不包含 "{0}" 項目宣告: {1}</target>
         <note />
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
@@ -211,22 +211,22 @@
       </trans-unit>
       <trans-unit id="OnlyOneCachePluginMustBeSpecified">
         <source>MSB4265: A single project cache plugin must be specified but multiple where found: {0}</source>
-        <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
+        <target state="translated">MSB4265: 只可指定單一專案快取外掛程式，但發現多個指定項目: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
-        <target state="new">MSB4266: Failed to initialize the project cache.</target>
+        <target state="translated">MSB4266: 無法將專案快取初始化。</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheQueryFailed">
         <source>MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</source>
-        <target state="new">MSB4267: The project cache failed while being queried for the following project: {0}. The cache is queried in parallel for multiple projects so this specific project might not be the cause.</target>
+        <target state="translated">MSB4267: 查詢下列專案時，專案快取失敗: {0}。查詢多個專案時，會平行查詢快取，因此這個特定專案可能不是失敗原因。</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheShutdownFailed">
         <source>MSB4268: The project cache failed to shut down properly.</source>
-        <target state="new">MSB4268: The project cache failed to shut down properly.</target>
+        <target state="translated">MSB4268: 無法正確關閉專案快取。</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
@@ -251,7 +251,7 @@
       </trans-unit>
       <trans-unit id="SolutionPathPropertyMustBeSetOnVSSubmissions">
         <source>"MSB4264: Invalid $(SolutionPath) property: {0}"</source>
-        <target state="new">"MSB4264: Invalid $(SolutionPath) property: {0}"</target>
+        <target state="translated">"MSB4264: $(SolutionPath) 屬性無效: {0}"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
@@ -262,8 +262,8 @@
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphConstructionMetrics">
-        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
-        <target state="translated">"在 {0} 秒內載入的靜態圖形: {1} 個節點、{2} 個邊緣"</target>
+        <source>Static graph loaded in {0} seconds: {1} nodes, {2} edges</source>
+        <target state="needs-review-translation">"在 {0} 秒內載入的靜態圖形: {1} 個節點、{2} 個邊緣"</target>
         <note />
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
@@ -1670,8 +1670,8 @@
         <note>{StrBegin="MSB4091: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskAttribute">
-        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task. Verify the parameter exists on the task, and it is a settable public instance property.</source>
-        <target state="translated">MSB4064: "{1}" 工作不支援 "{0}" 參數。請驗證參數位於工作上，且為可設定的公用執行個體屬性。</target>
+        <source>MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</source>
+        <target state="new">MSB4064: The "{0}" parameter is not supported by the "{1}" task loaded from assembly: {2} from the path: {3}. Verify that the parameter exists on the task, the &lt;UsingTask&gt; points to the correct assembly, and it is a settable public instance property.</target>
         <note>{StrBegin="MSB4064: "}</note>
       </trans-unit>
       <trans-unit id="UnexpectedTaskOutputAttribute">
@@ -2388,7 +2388,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
       </trans-unit>
       <trans-unit id="SdkResultVersionDifferentThanReference">
         <source>MSB4241: The SDK reference "{0}" version "{1}" was resolved to version "{2}" instead.  You could be using a different version than expected if you do not update the referenced version to match.</source>
-        <target state="translated">MSB4241: SDK 參考 "{0}" 版本 "{1}" 已改為解析成版本 {2}"。若您未將參考的版本更新為符合的版本，您可能使用了與預期不同的版本。</target>
+        <target state="translated">MSB4241: SDK 參考 "{0}" 版本 "{1}" 已改為解析成版本 "{2}"。若您未將參考的版本更新為符合的版本，您可能使用了與預期不同的版本。</target>
         <note>{StrBegin="MSB4241: "}
       LOCALIZATION:  Do not localize the word SDK.
     </note>
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 3bb52fd3d73..e60c3a07af2 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -32,7 +32,7 @@ public NuGetFrameworkWrapper()
                 BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
             try
             {
-                var NuGetAssembly = Assembly.LoadFile(Path.Combine(assemblyDirectory, "NuGet.Frameworks.dll"));
+                var NuGetAssembly = Assembly.LoadFrom(Path.Combine(assemblyDirectory, "NuGet.Frameworks.dll"));
                 var NuGetFramework = NuGetAssembly.GetType("NuGet.Frameworks.NuGetFramework");
                 var NuGetFrameworkCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.CompatibilityProvider");
                 var NuGetFrameworkDefaultCompatibilityProvider = NuGetAssembly.GetType("NuGet.Frameworks.DefaultCompatibilityProvider");
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index 297b1c7c17a..93836bc46aa 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -127,7 +127,6 @@
   <PropertyGroup Condition="'$(TargetFramework)' == 'netcoreapp2.1' or '$(TargetFramework)' == 'net5.0'">
     <DefineConstants>$(DefineConstants);FEATURE_PIPEOPTIONS_CURRENTUSERONLY</DefineConstants>
     <DefineConstants Condition="'$(MachineIndependentBuild)' != 'true'">$(DefineConstants);FEATURE_NODE_REUSE</DefineConstants>
-    <DefineConstants>$(DefineConstants);FEATURE_SPAN</DefineConstants>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(GenerateReferenceAssemblySources)' != 'true'">
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 37550a1c24a..7761c468d44 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -110,18 +110,20 @@ internal static ChangeWaveConversionState ConversionState
         internal static void ApplyChangeWave()
         {
             // Once set, change wave should not need to be set again.
-            string mSBuildDisableFeaturesFromVersion = Environment.GetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION");
             if (!ShouldApplyChangeWave)
             {
                 return;
             }
+
+            string msbuildDisableFeaturesFromVersion = Environment.GetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION");
+
             // Most common case, `MSBuildDisableFeaturesFromVersion` unset
-            else if (string.IsNullOrEmpty(mSBuildDisableFeaturesFromVersion))
+            if (string.IsNullOrEmpty(msbuildDisableFeaturesFromVersion))
             {
                 ConversionState = ChangeWaveConversionState.Valid;
                 _cachedWave = ChangeWaves.EnableAllFeatures;
             }
-            else if (_cachedWave == null && !Version.TryParse(mSBuildDisableFeaturesFromVersion, out _cachedWave))
+            else if (!Version.TryParse(msbuildDisableFeaturesFromVersion, out _cachedWave))
             {
                 ConversionState = ChangeWaveConversionState.InvalidFormat;
                 _cachedWave = ChangeWaves.EnableAllFeatures;
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 03f84f7fd47..c0d09628fe3 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.CommandLine;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Graph;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
@@ -503,7 +504,7 @@ public void GraphBuildSwitchIdentificationTests(string graph)
             CommandLineSwitches.IsParameterizedSwitch(graph, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
             parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.GraphBuild);
             duplicateSwitchErrorMessage.ShouldBeNull();
-            multipleParametersAllowed.ShouldBeFalse();
+            multipleParametersAllowed.ShouldBeTrue();
             missingParametersErrorMessage.ShouldBeNull();
             unquoteParameters.ShouldBeTrue();
             emptyParametersAllowed.ShouldBeFalse();
@@ -531,6 +532,29 @@ public void LowPrioritySwitchIdentificationTests(string lowpriority)
             emptyParametersAllowed.ShouldBeFalse();
         }
 
+        [Fact]
+        public void GraphBuildSwitchCanHaveParameters()
+        {
+            CommandLineSwitches switches = new CommandLineSwitches();
+
+            MSBuildApp.GatherCommandLineSwitches(new List<string>{ "/graph", "/graph:true;  NoBuild  ;;  ;", "/graph:foo"}, switches);
+
+            switches[CommandLineSwitches.ParameterizedSwitch.GraphBuild].ShouldBe(new[] {"true", "  NoBuild  ", "  ", "foo"});
+
+            switches.HaveErrors().ShouldBeFalse();
+        }
+
+        [Fact]
+        public void GraphBuildSwitchCanBeParameterless()
+        {
+            CommandLineSwitches switches = new CommandLineSwitches();
+
+            MSBuildApp.GatherCommandLineSwitches(new List<string>{ "/graph" }, switches);
+
+            switches[CommandLineSwitches.ParameterizedSwitch.GraphBuild].ShouldBe(new string[0]);
+
+            switches.HaveErrors().ShouldBeFalse();
+        }
 
         [Fact]
         public void InputResultsCachesSupportsMultipleOccurrence()
@@ -967,7 +991,7 @@ public void InvalidToolsVersionErrors()
                                         enableProfiler: false,
                                         interactive: false,
                                         isolateProjects: false,
-                                        graphBuild: false,
+                                        graphBuildOptions: null,
                                         lowPriority: false,
                                         inputResultsCaches: null,
                                         outputResultsCache: null
@@ -1201,6 +1225,67 @@ public void ProcessBooleanSwitchTest()
             Should.Throw<CommandLineSwitchException>(() => MSBuildApp.ProcessBooleanSwitch(new[] { "invalid" }, defaultValue: true, resourceName: "InvalidRestoreValue"));
         }
 
+        public static IEnumerable<object[]> ProcessGraphBuildSwitchData()
+        {
+            var emptyOptions = new GraphBuildOptions();
+            var noBuildOptions = new GraphBuildOptions {Build = false};
+
+            yield return new object[] {new string[0], emptyOptions, null};
+
+            yield return new object[] {new[] {"true"}, emptyOptions, null};
+
+            yield return new object[] {new[] {"false"}, null, null};
+
+            yield return new object[] {new[] {"  ", "  "}, emptyOptions, null};
+
+            yield return new object[] {new[] {"NoBuild"}, noBuildOptions, null};
+
+            yield return new object[] {new[] {"noBUILD"}, noBuildOptions, null};
+
+            yield return new object[] {new[] {"noBUILD     "}, noBuildOptions, null};
+
+            yield return new object[] {new[] {"false", "true"}, null, new[] {"false"}};
+
+            yield return new object[] {new[] {"nobuild", "true"}, noBuildOptions, new[] {"true"}};
+
+            yield return new object[] {new[] { "false", "nobuild" }, null, new[] {"false"}};
+
+            yield return new object[] {new[] {"nobuild", "invalid"}, null, new[] {"invalid"}};
+        }
+
+        [Theory]
+        [MemberData(nameof(ProcessGraphBuildSwitchData))]
+        public void ProcessGraphBuildSwitch(string[] parameters, GraphBuildOptions expectedOptions, string[] expectedWordsInException)
+        {
+            CommandLineSwitchException exception = null;
+
+            try
+            {
+                var graphBuildOptions = MSBuildApp.ProcessGraphBuildSwitch(parameters);
+                graphBuildOptions.ShouldBe(expectedOptions);
+            }
+            catch (CommandLineSwitchException e)
+            {
+                exception = e;
+            }
+
+            if (expectedWordsInException != null)
+            {
+                exception.ShouldNotBeNull();
+
+                exception.Message.ShouldContain("Graph build value is not valid");
+
+                foreach (var expectedWord in expectedWordsInException)
+                {
+                    exception.Message.ShouldContain(expectedWord);
+                }
+            }
+            else
+            {
+                exception.ShouldBeNull();
+            }
+        }
+
         /// <summary>
         /// Verifies that when the /profileevaluation switch is used with invalid filenames an error is shown.
         /// </summary>
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index c8b2ed78726..9e6eb9fd49c 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -269,7 +269,7 @@ bool emptyParametersAllowed
             new ParameterizedSwitchInfo(  new string[] { "restoreproperty", "rp" },             ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingRestorePropertyError",         true,   false  ),
             new ParameterizedSwitchInfo(  new string[] { "interactive" },                       ParameterizedSwitch.Interactive,                null,                           false,          null,                                  true,   false  ),
             new ParameterizedSwitchInfo(  new string[] { "isolateprojects", "isolate" },        ParameterizedSwitch.IsolateProjects,            null,                           false,          null,                                  true,   false  ),
-            new ParameterizedSwitchInfo(  new string[] { "graphbuild", "graph" },               ParameterizedSwitch.GraphBuild,                 null,                           false,          null,                                  true,   false  ),
+            new ParameterizedSwitchInfo(  new string[] { "graphbuild", "graph" },               ParameterizedSwitch.GraphBuild,                 null,                           true,          null,                                  true,   false  ),
             new ParameterizedSwitchInfo(  new string[] { "inputResultsCaches", "irc" },         ParameterizedSwitch.InputResultsCaches,         null,                           true,           null,                                  true,   true   ),
             new ParameterizedSwitchInfo(  new string[] { "outputResultsCache", "orc" },         ParameterizedSwitch.OutputResultsCache,         "DuplicateOutputResultsCache",  false,          null,                                  true,   true   ),
             new ParameterizedSwitchInfo(  new string[] { "lowpriority", "low" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false  ),
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 98f08298b0b..7d990720a96 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -197,7 +197,6 @@
     <Compile Include="XMake.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <None Include="project.json" />
     <!-- This is to enable CodeMarkers in MSBuild.exe -->
     <!-- Win32 RC Files -->
     <RCResourceFile Include="native.rc" />
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 3484f2cacaa..5f2b1ab2330 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -1172,7 +1172,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </comment>
   </data>
   <data name="InvalidGraphBuildValue" UESanitized="true" Visibility="Public">
-    <value>MSBUILD : error MSB1057: Graph build value is not valid. {0}</value>
+    <value>MSBUILD : error MSB1057: Graph build value is not valid.</value>
     <comment>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index d3242d73401..ea203edd619 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -963,8 +963,8 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: Hodnota sestavení grafu není platná. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index b12875ea503..dfbf6409b2d 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -955,8 +955,8 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: Der Wert für die Diagrammerstellung ist nicht gültig. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.en.xlf b/src/MSBuild/Resources/xlf/Strings.en.xlf
index a866ad64681..813d56eb252 100644
--- a/src/MSBuild/Resources/xlf/Strings.en.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.en.xlf
@@ -1144,8 +1144,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 84dfcc76473..be5821b7ddb 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -964,8 +964,8 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: El valor de compilación del grafo no es válido. {0}.</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index bc5d0cab144..1e9052ab0ec 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -956,8 +956,8 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: La valeur de build du graphe n'est pas valide. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 792c30f845e..3576dee6f26 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -976,8 +976,8 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: il valore di graphBuild non è valido. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index c4340920b51..d64a16c977d 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -955,8 +955,8 @@ Copyright (C) Microsoft Corporation.All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: Graph build 値が無効です。{0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 54603d31f2f..b627ff1eef4 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -955,8 +955,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: 그래프 빌드 값이 유효하지 않습니다. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index aff42990b9e..8f1ee8b37b8 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -968,8 +968,8 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: Wartość kompilacji grafu jest nieprawidłowa. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index e406782e4b3..5d4dd910080 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -956,8 +956,8 @@ isoladamente.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: O valor de build do gráfico não é válido. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index f735d35d2be..b04ff45fb56 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -955,8 +955,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: значение сборки графа является недопустимым. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index aac67729919..73a7f281be0 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -959,8 +959,8 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: Grafik derleme değeri geçerli değil. {0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index e44b94a0e59..dcc8024c787 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -955,8 +955,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: 关系图生成值无效。{0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 0d183976b13..0e54b0e7198 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -955,8 +955,8 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
     </note>
       </trans-unit>
       <trans-unit id="InvalidGraphBuildValue">
-        <source>MSBUILD : error MSB1057: Graph build value is not valid. {0}</source>
-        <target state="translated">MSBUILD : error MSB1057: 圖形組建值無效。{0}</target>
+        <source>MSBUILD : error MSB1057: Graph build value is not valid.</source>
+        <target state="new">MSBUILD : error MSB1057: Graph build value is not valid.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1057: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 89b5641c4c4..7891c7923dd 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -563,7 +563,7 @@ string [] commandLine
                 bool enableProfiler = false;
                 bool interactive = false;
                 bool isolateProjects = false;
-                bool graphBuild = false;
+                GraphBuildOptions graphBuildOptions = null;
                 bool lowPriority = false;
                 string[] inputResultsCaches = null;
                 string outputResultsCache = null;
@@ -597,7 +597,7 @@ string [] commandLine
                         ref enableProfiler,
                         ref restoreProperties,
                         ref isolateProjects,
-                        ref graphBuild,
+                        ref graphBuildOptions,
                         ref inputResultsCaches,
                         ref outputResultsCache,
                         ref lowPriority,
@@ -675,7 +675,7 @@ string [] commandLine
                                     enableProfiler,
                                     interactive,
                                     isolateProjects,
-                                    graphBuild,
+                                    graphBuildOptions,
                                     lowPriority,
                                     inputResultsCaches,
                                     outputResultsCache))
@@ -984,7 +984,7 @@ internal static bool BuildProject
             bool enableProfiler,
             bool interactive,
             bool isolateProjects,
-            bool graphBuild,
+            GraphBuildOptions graphBuildOptions,
             bool lowPriority,
             string[] inputResultsCaches,
             string outputResultsCache
@@ -1211,9 +1211,9 @@ string outputResultsCache
                             BuildRequestData buildRequest = null;
                             if (!restoreOnly)
                             {
-                                if (graphBuild)
+                                if (graphBuildOptions != null)
                                 {
-                                    graphBuildRequest = new GraphBuildRequestData(new ProjectGraphEntryPoint(projectFile, globalProperties), targets, null);
+                                    graphBuildRequest = new GraphBuildRequestData(new[]{ new ProjectGraphEntryPoint(projectFile, globalProperties) }, targets, null, BuildRequestDataFlags.None, graphBuildOptions);
                                 }
                                 else
                                 {
@@ -1233,7 +1233,7 @@ string outputResultsCache
 
                             if (!restoreOnly)
                             {
-                                if (graphBuild)
+                                if (graphBuildOptions != null)
                                 {
                                     (result, exception) = ExecuteGraphBuild(buildManager, graphBuildRequest);
                                 }
@@ -2094,7 +2094,7 @@ private static bool ProcessCommandLineSwitches
             ref bool enableProfiler,
             ref Dictionary<string, string> restoreProperties,
             ref bool isolateProjects,
-            ref bool graphBuild,
+            ref GraphBuildOptions graphBuild,
             ref string[] inputResultsCaches,
             ref string outputResultsCache,
             ref bool lowPriority,
@@ -2276,7 +2276,7 @@ bool recursing
 
                     if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.GraphBuild))
                     {
-                        graphBuild = ProcessBooleanSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GraphBuild], defaultValue: true, resourceName: "InvalidGraphBuildValue");
+                        graphBuild = ProcessGraphBuildSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GraphBuild]);
                     }
 
                     if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.LowPriority))
@@ -2340,6 +2340,37 @@ out enableProfiler
             return invokeBuild;
         }
 
+        internal static GraphBuildOptions ProcessGraphBuildSwitch(string[] parameters)
+        {
+            var options = new GraphBuildOptions();
+
+            // Before /graph had parameters, it was treated as a boolean switch.
+            // Preserve that in case anyone is using /graph:{false|true}
+            if (parameters.Length == 1 && bool.TryParse(parameters[0], out var boolValue))
+            {
+                return boolValue ? options : null;
+            }
+
+            foreach (var parameter in parameters)
+            {
+                if (string.IsNullOrWhiteSpace(parameter))
+                {
+                    continue;
+                }
+
+                if (parameter.Trim().Equals("NoBuild", StringComparison.OrdinalIgnoreCase))
+                {
+                    options = options with {Build = false};
+                }
+                else
+                {
+                    CommandLineSwitchException.Throw("InvalidGraphBuildValue", parameter);
+                }
+            }
+
+            return options;
+        }
+
         private static string ProcessOutputResultsCache(CommandLineSwitches commandLineSwitches)
         {
             return commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.OutputResultsCache)
diff --git a/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs b/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs
index c540a86288e..6ed1e6755d5 100644
--- a/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs
+++ b/src/MSBuildTaskHost/Immutable/ImmutableDictionary.cs
@@ -138,6 +138,17 @@ internal ImmutableDictionary<K, V> SetItem(K key, V value)
             return clone;
         }
 
+        internal ImmutableDictionary<K, V> SetItems(IEnumerable<KeyValuePair<K, V>> items)
+        {
+            var clone = new ImmutableDictionary<K, V>(_backing);
+            foreach (KeyValuePair<K, V> item in items)
+            {
+                clone._backing[item.Key] = item.Value;
+            }
+
+            return clone;
+        }
+
         internal ImmutableDictionary<K, V> Remove(K key)
         {
             if (!ContainsKey(key))
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 79d3960e612..9e82ee87cae 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -8,7 +8,6 @@ package name=Microsoft.Build
 vs.dependencies
   vs.dependency id=Microsoft.Build.UnGAC
   vs.dependency id=Microsoft.VisualStudio.PackageGroup.NuGet
-                version=[15.0,17.0)
 
 vs.relatedProcessFiles
   vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\Microsoft.Build.dll"
diff --git a/src/Shared/AssemblyUtilities.cs b/src/Shared/AssemblyUtilities.cs
index f4194346f88..46d679293c5 100644
--- a/src/Shared/AssemblyUtilities.cs
+++ b/src/Shared/AssemblyUtilities.cs
@@ -6,6 +6,12 @@
 using System.Linq;
 using System.Reflection;
 
+// Declare this to get init properties. See https://github.com/dotnet/roslyn/issues/45510#issuecomment-694977239
+namespace System.Runtime.CompilerServices
+{
+    internal static class IsExternalInit { }
+}
+
 namespace Microsoft.Build.Shared
 {
     /// <summary>
diff --git a/src/Shared/CopyOnWriteDictionary.cs b/src/Shared/CopyOnWriteDictionary.cs
index 31d376092ea..7059463de3b 100644
--- a/src/Shared/CopyOnWriteDictionary.cs
+++ b/src/Shared/CopyOnWriteDictionary.cs
@@ -227,6 +227,18 @@ public void Add(string key, V value)
             _backing = _backing.SetItem(key, value);
         }
 
+        /// <summary>
+        /// Adds several value to the dictionary.
+        /// </summary>
+        public void SetItems(IEnumerable<KeyValuePair<string, V>> items)
+        {
+            _backing = _backing.SetItems(items);
+        }
+
+        public IEnumerable<KeyValuePair<string, V>> Where(Func<KeyValuePair<string, V>, bool> predicate)
+        {
+            return _backing.Where(predicate);
+        }
         /// <summary>
         /// Returns true if the dictionary contains the specified key.
         /// </summary>
diff --git a/src/Shared/FileDelegates.cs b/src/Shared/FileDelegates.cs
index bbe0c8e39a4..f13f4e74772 100644
--- a/src/Shared/FileDelegates.cs
+++ b/src/Shared/FileDelegates.cs
@@ -6,13 +6,22 @@
 namespace Microsoft.Build.Shared
 {
     /// <summary>
-    /// delegate for System.IO.Directory.GetFiles, used for testing
+    /// delegate for System.IO.Directory.GetFiles
     /// </summary>
     /// <param name="path">Directory path to start search for files in</param>
     /// <param name="searchPattern">pattern of files to match</param>
     /// <returns>string array of files which match search pattern</returns>
     internal delegate string[] DirectoryGetFiles(string path, string searchPattern);
 
+    /// <summary>
+    /// Delegate for optimized looking up files in directory.
+    /// Designed to be used for testing and to verify file existence by cached directory listing.
+    /// </summary>
+    /// <param name="path">Directory path to search files in</param>
+    /// <param name="fileName">name of file</param>
+    /// <returns>true if file exists</returns>
+    internal delegate bool FileExistsInDirectory(string path, string fileName);
+
     /// <summary>
     /// delegate for Directory.GetDirectories.
     /// </summary>
@@ -53,4 +62,4 @@ namespace Microsoft.Build.Shared
     /// </summary>
     /// <param name="path">The path to create.</param>
     internal delegate FileStream FileCreate(string path);
-}
\ No newline at end of file
+}
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index fb276f722ef..ba1fbfd01d3 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -31,6 +31,8 @@ internal class FileMatcher
         private static readonly char[] s_wildcardCharacters = { '*', '?' };
         private static readonly char[] s_wildcardAndSemicolonCharacters = { '*', '?', ';' };
 
+        private static readonly string[] s_propertyAndItemReferences = { "$(", "@(" };
+
         // on OSX both System.IO.Path separators are '/', so we have to use the literals
         internal static readonly char[] directorySeparatorCharacters = { '/', '\\' };
         internal static readonly string[] directorySeparatorStrings = directorySeparatorCharacters.Select(c => c.ToString()).ToArray();
@@ -166,8 +168,6 @@ internal static void ClearFileEnumerationsCache()
         /// <summary>
         /// Determines whether the given path has any wild card characters.
         /// </summary>
-        /// <param name="filespec"></param>
-        /// <returns></returns>
         internal static bool HasWildcards(string filespec)
         {
             // Perf Note: Doing a [Last]IndexOfAny(...) is much faster than compiling a
@@ -180,18 +180,33 @@ internal static bool HasWildcards(string filespec)
         }
 
         /// <summary>
-        /// Determines whether the given path has any wild card characters or any semicolons.
+        /// Determines whether the given path has any wild card characters or semicolons.
+        /// </summary>
+        internal static bool HasWildcardsOrSemicolon(string filespec)
+        {
+            return -1 != filespec.LastIndexOfAny(s_wildcardAndSemicolonCharacters);
+        }
+
+        /// <summary>
+        /// Determines whether the given path has any wild card characters, any semicolons or any property references.
         /// </summary>
         internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec)
         {
             return
 
                 (-1 != filespec.IndexOfAny(s_wildcardAndSemicolonCharacters)) ||
-                filespec.Contains("$(") ||
-                filespec.Contains("@(")
+                HasPropertyOrItemReferences(filespec)
                 ;
         }
 
+        /// <summary>
+        /// Determines whether the given path has any property references.
+        /// </summary>
+        internal static bool HasPropertyOrItemReferences(string filespec)
+        {
+            return s_propertyAndItemReferences.Any(filespec.Contains);
+        }
+
         /// <summary>
         /// Get the files and\or folders specified by the given path and pattern.
         /// </summary>
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index f942b9da01b..15120f03b02 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -4,6 +4,8 @@
 using System;
 #if !CLR2COMPATIBILITY
 using System.Collections.Concurrent;
+#else
+using Microsoft.Build.Shared.Concurrent;
 #endif
 using System.Collections.Generic;
 using System.Diagnostics;
@@ -107,11 +109,8 @@ public static bool GetIsFileSystemCaseSensitive()
 
         internal static readonly string DirectorySeparatorString = Path.DirectorySeparatorChar.ToString();
 
-#if !CLR2COMPATIBILITY
         private static readonly ConcurrentDictionary<string, bool> FileExistenceCache = new ConcurrentDictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
-#else
-        private static readonly Microsoft.Build.Shared.Concurrent.ConcurrentDictionary<string, bool> FileExistenceCache = new Microsoft.Build.Shared.Concurrent.ConcurrentDictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
-#endif
+
         private static readonly IFileSystem DefaultFileSystem = FileSystems.Default;
 
         /// <summary>
@@ -451,6 +450,7 @@ internal static string FixFilePath(string path)
             return string.IsNullOrEmpty(path) || Path.DirectorySeparatorChar == '\\' ? path : path.Replace('\\', '/');//.Replace("//", "/");
         }
 
+#if !CLR2COMPATIBILITY
         /// <summary>
         /// If on Unix, convert backslashes to slashes for strings that resemble paths.
         /// The heuristic is if something resembles paths (contains slashes) check if the
@@ -474,60 +474,13 @@ internal static string MaybeAdjustFilePath(string value, string baseDirectory =
             }
 
             // For Unix-like systems, we may want to convert backslashes to slashes
-#if FEATURE_SPAN
             Span<char> newValue = ConvertToUnixSlashes(value.ToCharArray());
-#else
-            string newValue = ConvertToUnixSlashes(value);
-#endif
 
             // Find the part of the name we want to check, that is remove quotes, if present
             bool shouldAdjust = newValue.IndexOf('/') != -1 && LooksLikeUnixFilePath(RemoveQuotes(newValue), baseDirectory);
             return shouldAdjust ? newValue.ToString() : value;
         }
 
-#if !FEATURE_SPAN
-        private static string ConvertToUnixSlashes(string path)
-        {
-            if (path.IndexOf('\\') == -1)
-            {
-                return path;
-            }
-            StringBuilder unixPath = StringBuilderCache.Acquire(path.Length);
-            CopyAndCollapseSlashes(path, unixPath);
-            return StringBuilderCache.GetStringAndRelease(unixPath);
-        }
-
-#if !CLR2COMPATIBILITY && !FEATURE_SPAN
-        [MethodImpl(MethodImplOptions.AggressiveInlining)]
-#endif
-        private static void CopyAndCollapseSlashes(string str, StringBuilder copy)
-        {
-            // Performs Regex.Replace(str, @"[\\/]+", "/")
-            for (int i = 0; i < str.Length; i++)
-            {
-                bool isCurSlash = IsAnySlash(str[i]);
-                bool isPrevSlash = i > 0 && IsAnySlash(str[i - 1]);
-
-                if (!isCurSlash || !isPrevSlash)
-                {
-                    copy.Append(str[i] == '\\' ? '/' : str[i]);
-                }
-            }
-        }
-
-        private static string RemoveQuotes(string path)
-        {
-            int endId = path.Length - 1;
-            char singleQuote = '\'';
-            char doubleQuote = '\"';
-
-            bool hasQuotes = path.Length > 2
-                && ((path[0] == singleQuote && path[endId] == singleQuote)
-                || (path[0] == doubleQuote && path[endId] == doubleQuote));
-
-            return hasQuotes ? path.Substring(1, endId - 1) : path;
-        }
-#else
         private static Span<char> ConvertToUnixSlashes(Span<char> path)
         {
             return path.IndexOf('\\') == -1 ? path : CollapseSlashes(path);
@@ -573,6 +526,7 @@ private static Span<char> RemoveQuotes(Span<char> path)
 #endif
         internal static bool IsAnySlash(char c) => c == '/' || c == '\\';
 
+#if !CLR2COMPATIBILITY
         /// <summary>
         /// If on Unix, check if the string looks like a file path.
         /// The heuristic is if something resembles paths (contains slashes) check if the
@@ -582,24 +536,8 @@ private static Span<char> RemoveQuotes(Span<char> path)
         /// that
         /// </summary>
         internal static bool LooksLikeUnixFilePath(string value, string baseDirectory = "")
-        {
-            if (NativeMethodsShared.IsWindows)
-            {
-                return false;
-            }
-
-            // The first slash will either be at the beginning of the string or after the first directory name
-            int directoryLength = value.IndexOf('/', 1) + 1;
-            bool shouldCheckDirectory = directoryLength != 0;
+            => LooksLikeUnixFilePath(value.AsSpan(), baseDirectory);
 
-            // Check for actual files or directories under / that get missed by the above logic
-            bool shouldCheckFileOrDirectory = !shouldCheckDirectory && value.Length > 0 && value[0] == '/';
-
-            return (shouldCheckDirectory && DefaultFileSystem.DirectoryExists(Path.Combine(baseDirectory, value.Substring(0, directoryLength))))
-                || (shouldCheckFileOrDirectory && DefaultFileSystem.DirectoryEntryExists(value));
-        }
-
-#if FEATURE_SPAN
         internal static bool LooksLikeUnixFilePath(ReadOnlySpan<char> value, string baseDirectory = "")
         {
             if (NativeMethodsShared.IsWindows)
@@ -966,6 +904,20 @@ internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem =
             }
         }
 
+        /// <summary>
+        /// Get all files from directory matching pattern
+        /// </summary>
+        internal static string[] DirectoryGetFiles(string path, string pattern = "*", IFileSystem fileSystem = null)
+        {
+            if (path is null)
+                throw new ArgumentNullException(nameof(path));
+            if (path.Length == 0)
+                throw new ArgumentException("Unexpected empty string", nameof(path));
+
+            path = AttemptToShortenPath(path);
+            return (fileSystem ?? DefaultFileSystem).EnumerateFiles(path, pattern).ToArray();
+        }
+
         /// <summary>
         /// If there is a directory or file at the specified path, returns true.
         /// Otherwise, returns false.
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index f080c2e05a9..d44b57480d4 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -25,8 +25,20 @@ internal class MSBuildLoadContext : AssemblyLoadContext
                 "MSBuild",
                 "Microsoft.Build",
                 "Microsoft.Build.Framework",
+                "Microsoft.Build.NuGetSdkResolver",
                 "Microsoft.Build.Tasks.Core",
                 "Microsoft.Build.Utilities.Core",
+                "NuGet.Build.Tasks",
+                "NuGet.Common",
+                "NuGet.Configuration",
+                "NuGet.Credentials",
+                "NuGet.DependencyResolver.Core",
+                "NuGet.Frameworks",
+                "NuGet.LibraryModel",
+                "NuGet.Packaging",
+                "NuGet.Protocol",
+                "NuGet.ProjectModel",
+                "NuGet.Versioning",
             }.ToImmutableHashSet();
 
         internal static readonly string[] Extensions = new[] { "ni.dll", "ni.exe", "dll", "exe" };
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 7bb77dda88f..c58bc449a1c 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -99,6 +99,16 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         /// </summary>
         private SharedReadBuffer _sharedReadBuffer;
 
+        /// <summary>
+        /// A way to cache a byte array when writing out packets
+        /// </summary>
+        private MemoryStream _packetStream;
+
+        /// <summary>
+        /// A binary writer to help write into <see cref="_packetStream"/>
+        /// </summary>
+        private BinaryWriter _binaryWriter;
+
 #endregion
 
 #region INodeEndpoint Events
@@ -189,6 +199,9 @@ internal void InternalConstruct(string pipeName)
             _asyncDataMonitor = new object();
             _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
 
+            _packetStream = new MemoryStream();
+            _binaryWriter = new BinaryWriter(_packetStream);
+
 #if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
             if (!NativeMethodsShared.IsMono)
             {
@@ -590,22 +603,26 @@ private void RunReadLoop(Stream localReadPipe, Stream localWritePipe,
                             INodePacket packet;
                             while (localPacketQueue.TryDequeue(out packet))
                             {
-                                MemoryStream packetStream = new MemoryStream();
+                                var packetStream = _packetStream;
+                                packetStream.SetLength(0);
+
                                 ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(packetStream);
 
                                 packetStream.WriteByte((byte)packet.Type);
 
                                 // Pad for packet length
-                                packetStream.Write(BitConverter.GetBytes((int)0), 0, 4);
+                                _binaryWriter.Write(0);
 
                                 // Reset the position in the write buffer.
                                 packet.Translate(writeTranslator);
 
+                                int packetStreamLength = (int)packetStream.Position;
+
                                 // Now write in the actual packet length
                                 packetStream.Position = 1;
-                                packetStream.Write(BitConverter.GetBytes((int)packetStream.Length - 5), 0, 4);
+                                _binaryWriter.Write(packetStreamLength - 5);
 
-                                localWritePipe.Write(packetStream.GetBuffer(), 0, (int)packetStream.Length);
+                                localWritePipe.Write(packetStream.GetBuffer(), 0, packetStreamLength);
                             }
                         }
                         catch (Exception e)
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index 636c41df025..a893427c579 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -549,6 +549,7 @@ public void FileOrDirectoryExistsNoThrow()
 
             Assert.False(FileUtilities.FileOrDirectoryExistsNoThrow("||"));
             Assert.False(FileUtilities.FileOrDirectoryExistsNoThrow(isWindows ? @"c:\doesnot_exist" : "/doesnot_exist"));
+            Assert.False(FileUtilities.FileOrDirectoryExistsNoThrow(string.Empty));
             Assert.True(FileUtilities.FileOrDirectoryExistsNoThrow(isWindows ? @"c:\" : "/"));
             Assert.True(FileUtilities.FileOrDirectoryExistsNoThrow(Path.GetTempPath()));
 
@@ -666,6 +667,35 @@ public void DirectoryExistsNoThrowTooLongWithDotsRelative()
             }
         }
 
+        [Fact]
+        public void DirectoryGetFilesThrowsOnNull()
+        {
+            Assert.Throws<ArgumentNullException>(() => FileUtilities.DirectoryGetFiles(null));
+        }
+
+        [Fact]
+        public void DirectoryGetFilesThrowsOnEmpty()
+        {
+            Assert.Throws<ArgumentException>(() => FileUtilities.DirectoryGetFiles(string.Empty));
+        }
+
+        [ConditionalFact(nameof(RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241))]
+        public void DirectoryGetFilesTooLongWithDots()
+        {
+            Assert.Throws<ArgumentNullException>(() => FileUtilities.DirectoryGetFiles(null));
+
+            string systemDirectoryPath = Path.Combine(Environment.SystemDirectory) + Path.DirectorySeparatorChar;
+            string longPart = new string('x', NativeMethodsShared.MAX_PATH - systemDirectoryPath.Length); // We want the shortest that is > max path.
+
+            string inputPath = Path.Combine(new[] { Environment.SystemDirectory, longPart, "..", });
+
+            Console.WriteLine(inputPath.Length);
+
+            // "c:\windows\system32\<verylong>\.." > MAX_PATH
+            var files = FileUtilities.DirectoryGetFiles(inputPath);
+            Assert.NotEmpty(files);
+        }     
+
         public static bool RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241()
         {
             // Run these tests only when we're not on Windows
diff --git a/src/Shared/UnitTests/MockLogger.cs b/src/Shared/UnitTests/MockLogger.cs
index 07af5356dc7..f8a094bb442 100644
--- a/src/Shared/UnitTests/MockLogger.cs
+++ b/src/Shared/UnitTests/MockLogger.cs
@@ -81,6 +81,16 @@ internal sealed class MockLogger : ILogger
         /// </summary>
         internal List<ExternalProjectFinishedEventArgs> ExternalProjectFinishedEvents { get; } = new List<ExternalProjectFinishedEventArgs>();
 
+        /// <summary>
+        /// List of ProjectStarted events
+        /// </summary>
+        internal List<ProjectEvaluationStartedEventArgs> EvaluationStartedEvents { get; } = new List<ProjectEvaluationStartedEventArgs>();
+
+        /// <summary>
+        /// List of ProjectFinished events
+        /// </summary>
+        internal List<ProjectEvaluationFinishedEventArgs> EvaluationFinishedEvents { get; } = new List<ProjectEvaluationFinishedEventArgs>();
+
         /// <summary>
         /// List of ProjectStarted events
         /// </summary>
@@ -293,6 +303,16 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
                         ExternalProjectFinishedEvents.Add(finishedEventArgs);
                         break;
                     }
+                    case ProjectEvaluationStartedEventArgs evaluationStartedEventArgs:
+                    {
+                        EvaluationStartedEvents.Add(evaluationStartedEventArgs);
+                        break;
+                    }
+                    case ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs:
+                    {
+                        EvaluationFinishedEvents.Add(evaluationFinishedEventArgs);
+                        break;
+                    }
                     case ProjectStartedEventArgs startedEventArgs:
                     {
                         ProjectStartedEvents.Add(startedEventArgs);
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index c20d923b67c..5c721b50c7e 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1944,6 +1944,11 @@ public BuildResult BuildProjectFile(
 
                 return buildResult;
             }
+			
+			public GraphBuildResult BuildGraphSubmission(GraphBuildRequestData requestData)
+            {
+                return _buildManager.BuildRequest(requestData);
+            }
 
             public void Dispose()
             {
diff --git a/src/StringTools/StringTools.csproj b/src/StringTools/StringTools.csproj
index f3ac3633595..1bead8c7ed9 100644
--- a/src/StringTools/StringTools.csproj
+++ b/src/StringTools/StringTools.csproj
@@ -15,7 +15,12 @@
     <SemanticVersioningV1>true</SemanticVersioningV1>
 
     <AssemblyName>Microsoft.NET.StringTools</AssemblyName>
-    <AssemblyName Condition="'$(TargetFramework)' == 'net35'">Microsoft.NET.StringTools.net35</AssemblyName>
+  </PropertyGroup>
+
+  <PropertyGroup Condition="'$(TargetFramework)' == 'net35'">
+    <AssemblyName>Microsoft.NET.StringTools.net35</AssemblyName>
+    <!-- Disable Fx install checks as we're building against jnm2's 3.5 reference assemblies -->
+    <BypassFrameworkInstallChecks>true</BypassFrameworkInstallChecks>
   </PropertyGroup>
 
   <ItemGroup Condition="'$(TargetFramework)' != 'net35'">
diff --git a/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs b/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
index d4b92d40fed..c419e46bfb7 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
@@ -288,6 +288,7 @@ public void SystemRuntimeDepends_No_Build()
                     fileExists,
                     directoryExists,
                     getDirectories,
+                    getDirectoryFiles,
                     getAssemblyName,
                     getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -316,6 +317,7 @@ public void SystemRuntimeDepends_No_Build()
                     fileExists,
                     directoryExists,
                     getDirectories,
+                    getDirectoryFiles,
                     getAssemblyName,
                     getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -364,6 +366,7 @@ public void SystemRuntimeDepends_Yes()
                     fileExists,
                     directoryExists,
                     getDirectories,
+                    getDirectoryFiles,
                     getAssemblyName,
                     getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -391,6 +394,7 @@ public void SystemRuntimeDepends_Yes()
                     fileExists,
                     directoryExists,
                     getDirectories,
+                    getDirectoryFiles,
                     getAssemblyName,
                     getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -438,6 +442,7 @@ public void SystemRuntimeDepends_Yes_Indirect()
                     fileExists,
                     directoryExists,
                     getDirectories,
+                    getDirectoryFiles,
                     getAssemblyName,
                     getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -465,6 +470,7 @@ public void SystemRuntimeDepends_Yes_Indirect()
                     fileExists,
                     directoryExists,
                     getDirectories,
+                    getDirectoryFiles,
                     getAssemblyName,
                     getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -509,6 +515,7 @@ public void SystemRuntimeDepends_Yes_Indirect_ExternallyResolved()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -532,6 +539,7 @@ public void SystemRuntimeDepends_Yes_Indirect_ExternallyResolved()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -572,6 +580,7 @@ public void NETStandardDepends_Yes()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -595,6 +604,7 @@ public void NETStandardDepends_Yes()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -636,6 +646,7 @@ public void NETStandardDepends_Yes_Indirect()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -659,6 +670,7 @@ public void NETStandardDepends_Yes_Indirect()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -702,6 +714,7 @@ public void NETStandardDepends_Yes_Indirect_ExternallyResolved()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -725,6 +738,7 @@ public void NETStandardDepends_Yes_Indirect_ExternallyResolved()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -768,6 +782,7 @@ public void DependsOn_NETStandard_and_SystemRuntime()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -792,6 +807,7 @@ public void DependsOn_NETStandard_and_SystemRuntime()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -838,6 +854,7 @@ public void DependsOn_NETStandard_and_SystemRuntime_ExternallyResolved()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -862,6 +879,7 @@ public void DependsOn_NETStandard_and_SystemRuntime_ExternallyResolved()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 2d0aaec17b3..9a0b3b56078 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -3312,7 +3312,7 @@ public void ParentAssemblyResolvedFromAForGac()
         /// <returns></returns>
         private ReferenceTable GenerateTableWithAssemblyFromTheGlobalLocation(string location)
         {
-            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null, null,
+            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, fileExistsInDirectory, null, null, null, null,
 #if FEATURE_WIN32_REGISTRY
                 null, null, null,
 #endif
@@ -5467,31 +5467,22 @@ public void Regress46599_BogusInGACValueForAssemblyInRedistList()
             };
             t.TargetFrameworkDirectories = new string[] { @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx" };
 
-            FileExists cachedFileExists = fileExists;
-            GetAssemblyName cachedGetAssemblyName = getAssemblyName;
             string redistFile = CreateGenericRedistList();
-
+            List<string> preservedExistentFiles = s_existentFiles;
+            s_existentFiles = new List<string>(s_existentFiles);
             bool success = false;
             try
             {
-                fileExists = new FileExists(delegate (string path)
-                {
-                    if (String.Equals(path, @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\Microsoft.Build.Engine.dll", StringComparison.OrdinalIgnoreCase) ||
-                        String.Equals(path, @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\System.Xml.dll", StringComparison.OrdinalIgnoreCase) ||
-                        path.EndsWith("RarCache", StringComparison.OrdinalIgnoreCase))
-                    {
-                        return true;
-                    }
-                    return false;
-                });
+                s_existentFiles.Add(@"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\Microsoft.Build.Engine.dll");
+                s_existentFiles.Add(@"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\System.Xml.dll");
+
                 t.InstalledAssemblyTables = new ITaskItem[] { new TaskItem(redistFile) };
 
                 success = Execute(t);
             }
             finally
             {
-                fileExists = cachedFileExists;
-                getAssemblyName = cachedGetAssemblyName;
+                s_existentFiles = preservedExistentFiles;
                 File.Delete(redistFile);
             }
 
@@ -5528,7 +5519,6 @@ public void VerifyFrameworkFileMetadataFiles()
             };
             t.TargetFrameworkDirectories = new string[] { @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx" };
 
-            FileExists cachedFileExists = fileExists;
             GetAssemblyName cachedGetAssemblyName = getAssemblyName;
 
             // Create a redist list which will contains both of the assemblies to search for
@@ -5542,22 +5532,17 @@ public void VerifyFrameworkFileMetadataFiles()
             string redistFile = FileUtilities.GetTemporaryFile();
             File.WriteAllText(redistFile, redistListContents);
 
+            List<string> preservedExistentFiles = s_existentFiles;
+            s_existentFiles = new List<string>(s_existentFiles);
+
             bool success = false;
             try
             {
-                fileExists = new FileExists(delegate (string path)
-                {
-                    if (String.Equals(path, @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\Microsoft.Build.Engine.dll", StringComparison.OrdinalIgnoreCase) ||
-                        String.Equals(path, @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\System.Xml.dll", StringComparison.OrdinalIgnoreCase) ||
-                        String.Equals(path, @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\B.dll", StringComparison.OrdinalIgnoreCase) ||
-                        String.Equals(path, @"c:\somewhere\c.dll", StringComparison.OrdinalIgnoreCase) ||
-                        String.Equals(path, @"c:\somewhere\d.dll", StringComparison.OrdinalIgnoreCase) ||
-                        path.EndsWith("RarCache", StringComparison.OrdinalIgnoreCase))
-                    {
-                        return true;
-                    }
-                    return false;
-                });
+                s_existentFiles.Add(@"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\Microsoft.Build.Engine.dll");
+                s_existentFiles.Add(@"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\System.Xml.dll");
+                s_existentFiles.Add(@"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\B.dll");
+                s_existentFiles.Add(@"c:\somewhere\c.dll");
+                s_existentFiles.Add(@"c:\somewhere\d.dll");
 
                 getAssemblyName = new GetAssemblyName(delegate (string path)
                 {
@@ -5579,7 +5564,7 @@ public void VerifyFrameworkFileMetadataFiles()
             }
             finally
             {
-                fileExists = cachedFileExists;
+                s_existentFiles = preservedExistentFiles;
                 getAssemblyName = cachedGetAssemblyName;
                 File.Delete(redistFile);
             }
@@ -6342,19 +6327,12 @@ public void IgnoreDefaultInstalledAssemblyTables()
             // Only the explicitly specified redist list should be used
             t.IgnoreDefaultInstalledAssemblyTables = true;
 
-            FileExists cachedFileExists = fileExists;
             GetAssemblyName cachedGetAssemblyName = getAssemblyName;
+            List<string> preservedExistentFiles = s_existentFiles;
+            s_existentFiles = new List<string>(s_existentFiles);
 
-            fileExists = new FileExists(delegate (string path)
-            {
-                if (String.Equals(path, microsoftBuildEnginePath, StringComparison.OrdinalIgnoreCase) ||
-                    String.Equals(path, systemXmlPath, StringComparison.OrdinalIgnoreCase) ||
-                    path.EndsWith("RarCache", StringComparison.OrdinalIgnoreCase))
-                {
-                    return true;
-                }
-                return false;
-            });
+            s_existentFiles.Add(microsoftBuildEnginePath);
+            s_existentFiles.Add(systemXmlPath);
 
             getAssemblyName = new GetAssemblyName(delegate (string path)
             {
@@ -6377,7 +6355,7 @@ public void IgnoreDefaultInstalledAssemblyTables()
             }
             finally
             {
-                fileExists = cachedFileExists;
+                s_existentFiles = preservedExistentFiles;
                 getAssemblyName = cachedGetAssemblyName;
             }
 
@@ -6817,7 +6795,7 @@ public void ReferenceTableDependentItemsInBlackList3()
         [Fact]
         public void ReferenceTableDependentItemsInBlackList4()
         {
-            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null,
+            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, fileExistsInDirectory, null, null, null,
 #if FEATURE_WIN32_REGISTRY
                 null, null, null,
 #endif
@@ -6995,7 +6973,7 @@ public void ReferenceTableDependentItemsInBlackListPrimaryWithSpecificVersion()
 
         private static ReferenceTable MakeEmptyReferenceTable(TaskLoggingHelper log)
         {
-            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null, null,
+            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, fileExistsInDirectory, null, null, null, null,
 #if FEATURE_WIN32_REGISTRY
                 null, null, null,
 #endif
@@ -7258,18 +7236,12 @@ public void IgnoreDefaultInstalledSubsetTables()
         /// </summary>
         private bool GenerateHelperDelegatesAndExecuteTask(ResolveAssemblyReference t, string microsoftBuildEnginePath, string systemXmlPath)
         {
-            FileExists cachedFileExists = fileExists;
             GetAssemblyName cachedGetAssemblyName = getAssemblyName;
-            fileExists = new FileExists(delegate (string path)
-            {
-                if (String.Equals(path, microsoftBuildEnginePath, StringComparison.OrdinalIgnoreCase) ||
-                    String.Equals(path, systemXmlPath, StringComparison.OrdinalIgnoreCase) ||
-                    path.EndsWith("RarCache", StringComparison.OrdinalIgnoreCase))
-                {
-                    return true;
-                }
-                return false;
-            });
+            List<string> preservedExistentFiles = s_existentFiles;
+            s_existentFiles = new List<string>(s_existentFiles);
+
+            s_existentFiles.Add(microsoftBuildEnginePath);
+            s_existentFiles.Add(systemXmlPath);
 
             getAssemblyName = new GetAssemblyName(delegate (string path)
             {
@@ -7292,7 +7264,7 @@ private bool GenerateHelperDelegatesAndExecuteTask(ResolveAssemblyReference t, s
             }
             finally
             {
-                fileExists = cachedFileExists;
+                s_existentFiles = preservedExistentFiles;
                 getAssemblyName = cachedGetAssemblyName;
             }
             return success;
@@ -7609,33 +7581,26 @@ public void DoNotAssumeFilesDescribedByRedistListExistOnDisk()
                 t.BuildEngine = new MockEngine(_output);
 
                 t.Assemblies = new ITaskItem[]
-            {
-                new TaskItem("Microsoft.Build.Engine"),
-                new TaskItem("System.Xml")
-            };
+                {
+                    new TaskItem("Microsoft.Build.Engine"),
+                    new TaskItem("System.Xml")
+                };
 
-                t.SearchPaths = new string[]
-            {
-                @"{TargetFrameworkDirectory}"
-            };
+                    t.SearchPaths = new string[]
+                {
+                    @"{TargetFrameworkDirectory}"
+                };
                 t.TargetFrameworkDirectories = new string[] { Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5") };
                 string microsoftBuildEnginePath = Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5\\Microsoft.Build.Engine");
                 string systemXmlPath = Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5\\System.Xml.dll");
 
                 t.InstalledAssemblyTables = new ITaskItem[] { new TaskItem(redistListPath) };
 
-                FileExists cachedFileExists = fileExists;
                 GetAssemblyName cachedGetAssemblyName = getAssemblyName;
+                List<string> preservedExistentFiles = s_existentFiles;
+                s_existentFiles = new List<string>(s_existentFiles);
 
-                // Note that Microsoft.Build.Engine.dll does not exist
-                fileExists = new FileExists(delegate (string path)
-                {
-                    if (String.Equals(path, systemXmlPath, StringComparison.OrdinalIgnoreCase) || path.EndsWith("RarCache", StringComparison.OrdinalIgnoreCase))
-                    {
-                        return true;
-                    }
-                    return false;
-                });
+                s_existentFiles.Add(systemXmlPath);
 
                 getAssemblyName = new GetAssemblyName(delegate (string path)
                 {
@@ -7658,7 +7623,74 @@ public void DoNotAssumeFilesDescribedByRedistListExistOnDisk()
                 }
                 finally
                 {
-                    fileExists = cachedFileExists;
+                    s_existentFiles = preservedExistentFiles;
+                    getAssemblyName = cachedGetAssemblyName;
+                }
+
+                Assert.True(success); // "Expected no errors."
+                Assert.Single(t.ResolvedFiles); // "Expected one resolved assembly."
+                Assert.Contains("System.Xml", t.ResolvedFiles[0].ItemSpec); // "Expected System.Xml to resolve."
+            }
+            finally
+            {
+                File.Delete(redistListPath);
+            }
+        }
+
+        [Fact]
+        [Trait("Category", "mono-osx-failing")]
+        public void HandleFilesInSearchPathsWhichDiffersOnlyInCasing()
+        {
+            string redistListPath = CreateGenericRedistList();
+            try
+            {
+                ResolveAssemblyReference t = new ResolveAssemblyReference();
+
+                t.BuildEngine = new MockEngine(_output);
+
+                t.Assemblies = new ITaskItem[]
+                {
+                    new TaskItem("System.Xml")
+                };
+
+                t.SearchPaths = new string[]
+                {
+                    @"{TargetFrameworkDirectory}"
+                };
+
+                t.TargetFrameworkDirectories = new string[] { Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5") };
+                string systemXmlPath = Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5\\System.Xml.dll");
+                string aFile = Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5\\A.File.dll");
+                string aFileLowercase = Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5\\a.file.dll");
+
+                t.InstalledAssemblyTables = new ITaskItem[] { new TaskItem(redistListPath) };
+
+                GetAssemblyName cachedGetAssemblyName = getAssemblyName;
+                List<string> preservedExistentFiles = s_existentFiles;
+                s_existentFiles = new List<string>(s_existentFiles);
+
+                s_existentFiles.Add(systemXmlPath);
+                s_existentFiles.Add(aFile);
+                s_existentFiles.Add(aFileLowercase);
+
+                getAssemblyName = new GetAssemblyName(delegate (string path)
+                {
+                    if (String.Equals(path, systemXmlPath, StringComparison.OrdinalIgnoreCase))
+                    {
+                        return new AssemblyNameExtension("System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
+                    }
+
+                    return null;
+                });
+
+                bool success;
+                try
+                {
+                    success = Execute(t);
+                }
+                finally
+                {
+                    s_existentFiles = preservedExistentFiles;
                     getAssemblyName = cachedGetAssemblyName;
                 }
 
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
index eef70e698bf..ffc610d2b90 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
@@ -76,9 +76,7 @@ public void DependeeDirectoryIsProbedForDependency()
 
                 Assert.True(succeeded);
                 
-                uniqueFileExists[s_dependsOnNuGet_NWinMdPath].ShouldBe(1);
-                uniqueFileExists[s_dependsOnNuGet_NDllPath].ShouldBe(1);
-                uniqueFileExists[s_dependsOnNuGet_NExePath].ShouldBe(1);
+                uniqueGetDirectoryFiles[s_dependsOnNuGet_Path].ShouldBe(1);
             }
             finally
             {
@@ -121,9 +119,7 @@ public void DependeeDirectoryShouldNotBeProbedForDependencyWhenDependencyResolve
 
                 Assert.True(succeeded);
 
-                uniqueFileExists.ShouldNotContainKey(@"C:\DependsOnNuget\N.winmd");
-                uniqueFileExists.ShouldNotContainKey(@"C:\DependsOnNuget\N.dll");
-                uniqueFileExists.ShouldNotContainKey(@"C:\DependsOnNuget\N.exe");
+                uniqueGetDirectoryFiles.ShouldNotContainKey(s_dependsOnNuGet_Path);
             }
             finally
             {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 373805aa30f..839e5b70c6e 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -13,6 +13,7 @@
 using SystemProcessorArchitecture = System.Reflection.ProcessorArchitecture;
 using Xunit;
 using Xunit.Abstractions;
+using System.Linq;
 
 namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests
 {
@@ -20,7 +21,9 @@ public class ResolveAssemblyReferenceTestFixture : IDisposable
     {
         // Create the mocks.
         internal static Microsoft.Build.Shared.FileExists fileExists = new Microsoft.Build.Shared.FileExists(FileExists);
+        internal static Microsoft.Build.Shared.FileExistsInDirectory fileExistsInDirectory = new Microsoft.Build.Shared.FileExistsInDirectory(FileExistsInDirectory);
         internal static Microsoft.Build.Shared.DirectoryExists directoryExists = new Microsoft.Build.Shared.DirectoryExists(DirectoryExists);
+        internal static Microsoft.Build.Shared.DirectoryGetFiles getDirectoryFiles = new Microsoft.Build.Shared.DirectoryGetFiles(GetDirectoryFiles);
         internal static Microsoft.Build.Tasks.GetDirectories getDirectories = new Microsoft.Build.Tasks.GetDirectories(GetDirectories);
         internal static Microsoft.Build.Tasks.GetAssemblyName getAssemblyName = new Microsoft.Build.Tasks.GetAssemblyName(GetAssemblyName);
         internal static Microsoft.Build.Tasks.GetAssemblyMetadata getAssemblyMetadata = new Microsoft.Build.Tasks.GetAssemblyMetadata(GetAssemblyMetadata);
@@ -41,6 +44,7 @@ public class ResolveAssemblyReferenceTestFixture : IDisposable
         // Performance checks.
         internal static Dictionary<string, int> uniqueFileExists = null;
         internal static Dictionary<string, int> uniqueGetAssemblyName = null;
+        internal static Dictionary<string, int> uniqueGetDirectoryFiles = null;
 
         internal static bool useFrameworkFileExists = false;
         internal const string REDISTLIST = @"<FileList  Redist=""Microsoft-Windows-CLRCoreComp.4.0"" Name="".NET Framework 4"" RuntimeVersion=""4.0"" ToolsVersion=""12.0"">
@@ -256,6 +260,7 @@ public void Dispose()
         protected static readonly string s_portableDllPath = Path.Combine(s_rootPathPrefix, "SystemRuntime", "Portable.dll");
         protected static readonly string s_systemRuntimeDllPath = Path.Combine(s_rootPathPrefix, "SystemRuntime", "System.Runtime.dll");
 
+        protected static readonly string s_dependsOnNuGet_Path = Path.Combine(s_rootPathPrefix, "DependsOnNuget");
         protected static readonly string s_dependsOnNuGet_ADllPath = Path.Combine(s_rootPathPrefix, "DependsOnNuget", "A.dll");
         protected static readonly string s_dependsOnNuGet_NDllPath = Path.Combine(s_rootPathPrefix, "DependsOnNuget", "N.dll");
         protected static readonly string s_dependsOnNuGet_NExePath = Path.Combine(s_rootPathPrefix, "DependsOnNuget", "N.exe");
@@ -300,6 +305,7 @@ internal void StartIOMonitoring()
             // If tables are present then the corresponding IO function will do some monitoring.
             uniqueFileExists = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
             uniqueGetAssemblyName = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
+            uniqueGetDirectoryFiles = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -861,6 +867,47 @@ internal static bool FileExists(string path)
             return false;
         }
 
+        /// <summary>
+        /// Mock the Directory.GetFiles method.
+        /// </summary>
+        /// <param name="path">The path to directory.</param>
+        /// <returns>'true' if the file is supposed to exist</returns>
+        internal static string[] GetDirectoryFiles(string path, string pattern)
+        {
+            if (!Path.IsPathRooted(path))
+            {
+                path = Path.GetFullPath(path);
+            }
+
+            // remove trailing path separator
+            path = Path.GetDirectoryName(Path.Combine(path, "a.txt"));
+
+            if (pattern != "*")
+            {
+                throw new InvalidOperationException("In this context, directory listing with pattern is neither supported not expected to be used.");
+            }
+
+            // Do IO monitoring if needed.
+            if (uniqueGetDirectoryFiles != null)
+            {
+                uniqueGetDirectoryFiles.TryGetValue(path, out int count);
+                uniqueGetDirectoryFiles[path] = count + 1;
+            }
+
+            return s_existentFiles
+                .Where(fn => Path.GetDirectoryName(fn).Equals(path, StringComparison.OrdinalIgnoreCase))
+                .Select(fn => Path.Combine(path, Path.GetFileName(fn)))
+                .Distinct()
+                .ToArray();
+        }
+
+        internal static bool FileExistsInDirectory(string path, string fileName)
+        {
+            string fullName = Path.Combine(path, fileName);
+
+            return FileExists(fullName);
+        }
+
         /// <summary>
         /// Mock the Directory.Exists method.
         /// </summary>
@@ -3001,26 +3048,27 @@ protected static bool Execute(ResolveAssemblyReference t, bool buildConsistencyC
                     t.FindSerializationAssemblies = false;
                     t.FindRelatedFiles = false;
                     t.StateFile = null;
-	                t.Execute
-	                (
-	                    fileExists,
-	                    directoryExists,
-	                    getDirectories,
-	                    getAssemblyName,
-	                    getAssemblyMetadata,
-	#if FEATURE_WIN32_REGISTRY
-	                    getRegistrySubKeyNames,
-	                    getRegistrySubKeyDefaultValue,
-	#endif
-	                    getLastWriteTime,
-	                    getRuntimeVersion,
-	#if FEATURE_WIN32_REGISTRY
-	                    openBaseKey,
-	#endif
-	                    checkIfAssemblyIsInGac,
-	                    isWinMDFile,
-	                    readMachineTypeFromPEHeader
-	                );
+                    t.Execute
+                    (
+                        fileExists,
+                        directoryExists,
+                        getDirectories,
+                        getDirectoryFiles,
+                        getAssemblyName,
+                        getAssemblyMetadata,
+    #if FEATURE_WIN32_REGISTRY
+                        getRegistrySubKeyNames,
+                        getRegistrySubKeyDefaultValue,
+    #endif
+                        getLastWriteTime,
+                        getRuntimeVersion,
+    #if FEATURE_WIN32_REGISTRY
+                        openBaseKey,
+    #endif
+                        checkIfAssemblyIsInGac,
+                        isWinMDFile,
+                        readMachineTypeFromPEHeader
+                );
 
                     // A few checks. These should always be true or it may be a perf issue for project load.
                     ITaskItem[] loadModeResolvedFiles = new TaskItem[0];
@@ -3062,27 +3110,28 @@ protected static bool Execute(ResolveAssemblyReference t, bool buildConsistencyC
                     string cache = rarCacheFile;
                     t.StateFile = cache;
                     File.Delete(t.StateFile);
-	                succeeded =
-	                    t.Execute
-	                    (
-	                        fileExists,
-	                        directoryExists,
-	                        getDirectories,
-	                        getAssemblyName,
-	                        getAssemblyMetadata,
-	#if FEATURE_WIN32_REGISTRY
-	                        getRegistrySubKeyNames,
-	                        getRegistrySubKeyDefaultValue,
-	#endif
-	                        getLastWriteTime,
-	                        getRuntimeVersion,
-	#if FEATURE_WIN32_REGISTRY
-	                        openBaseKey,
-	#endif
-	                        checkIfAssemblyIsInGac,
-	                        isWinMDFile,
-	                        readMachineTypeFromPEHeader
-	                    );
+                    succeeded =
+                        t.Execute
+                        (
+                            fileExists,
+                            directoryExists,
+                            getDirectories,
+                            getDirectoryFiles,
+                            getAssemblyName,
+                            getAssemblyMetadata,
+    #if FEATURE_WIN32_REGISTRY
+                            getRegistrySubKeyNames,
+                            getRegistrySubKeyDefaultValue,
+    #endif
+                            getLastWriteTime,
+                            getRuntimeVersion,
+    #if FEATURE_WIN32_REGISTRY
+                            openBaseKey,
+    #endif
+                            checkIfAssemblyIsInGac,
+                            isWinMDFile,
+                            readMachineTypeFromPEHeader
+                        );
                     if (FileUtilities.FileExistsNoThrow(t.StateFile))
                     {
                         Assert.Single(t.FilesWritten);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs
index a97a93c7a50..6baa714ce5f 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs
@@ -372,6 +372,7 @@ public void HigherVersionDirectDependenciesFalse()
                     fileExists,
                     directoryExists,
                     getDirectories,
+                    getDirectoryFiles,
                     getAssemblyName,
                     getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
diff --git a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
index b764f4d7869..22e3eb6a34c 100644
--- a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
+++ b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
@@ -13,7 +13,7 @@
 using Xunit;
 using Xunit.Abstractions;
 
-namespace Microsoft.Build.Tasks.Unittest
+namespace Microsoft.Build.Tasks.UnitTests
 {
     public class GenerateBindingRedirectsTests : IDisposable
     {
diff --git a/src/Tasks.UnitTests/HintPathResolver_Tests.cs b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
index 37f8f89445c..3b6daa56dc6 100644
--- a/src/Tasks.UnitTests/HintPathResolver_Tests.cs
+++ b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
@@ -66,6 +66,7 @@ private bool ResolveHintPath(string hintPath)
                 searchPathElement: "{HintPathFromItem}",
                 getAssemblyName: (path) => throw new NotImplementedException(), // not called in this code path
                 fileExists: p => FileUtilities.FileExistsNoThrow(p),
+                fileExistsInDirectory: null, // not used
                 getRuntimeVersion: (path) => throw new NotImplementedException(), // not called in this code path
                 targetedRuntimeVesion: Version.Parse("4.0.30319"));
 
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index eab4bd23cd8..cd00af8329e 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
@@ -13,7 +13,6 @@
 
   <ItemGroup>
     <PackageReference Include="System.Security.Principal.Windows" />
-    <PackageReference Include="System.Xml.XPath" />
     <PackageReference Include="Shouldly" />
 
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
diff --git a/src/Tasks.UnitTests/Unzip_Tests.cs b/src/Tasks.UnitTests/Unzip_Tests.cs
index 4ccb35c6a2d..8b48e6ccaf8 100644
--- a/src/Tasks.UnitTests/Unzip_Tests.cs
+++ b/src/Tasks.UnitTests/Unzip_Tests.cs
@@ -214,5 +214,212 @@ public void LogsErrorIfSourceFileDoesNotExist()
                 _mockEngine.Log.ShouldContain("MSB3932", () => _mockEngine.Log);
             }
         }
+
+        [Fact]
+        public void CanUnzip_WithIncludeFilter()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);
+                testEnvironment.CreateFile(source, "BE78A17D30144B549D21F71D5C633F7D.txt", "file1");
+                testEnvironment.CreateFile(source, "A04FF4B88DF14860B7C73A8E75A4FB76.txt", "file2");
+
+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
+
+                Unzip unzip = new Unzip
+                                  {
+                                      BuildEngine = _mockEngine,
+                                      DestinationFolder = new TaskItem(destination.Path),
+                                      OverwriteReadOnlyFiles = true,
+                                      SkipUnchangedFiles = false,
+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                                      Include = "BE78A17D30144B549D21F71D5C633F7D.txt"
+                                  };
+
+                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
+
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "BE78A17D30144B549D21F71D5C633F7D.txt"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "A04FF4B88DF14860B7C73A8E75A4FB76.txt"), () => _mockEngine.Log);
+            }
+        }
+
+        [Fact]
+        public void CanUnzip_WithExcludeFilter()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);
+                testEnvironment.CreateFile(source, "BE78A17D30144B549D21F71D5C633F7D.txt", "file1");
+                testEnvironment.CreateFile(source, "A04FF4B88DF14860B7C73A8E75A4FB76.txt", "file2");
+
+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
+
+                Unzip unzip = new Unzip
+                                  {
+                                      BuildEngine = _mockEngine,
+                                      DestinationFolder = new TaskItem(destination.Path),
+                                      OverwriteReadOnlyFiles = true,
+                                      SkipUnchangedFiles = false,
+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                                      Exclude = "BE78A17D30144B549D21F71D5C633F7D.txt"
+                                  };
+
+                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
+
+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "BE78A17D30144B549D21F71D5C633F7D.txt"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "A04FF4B88DF14860B7C73A8E75A4FB76.txt"), () => _mockEngine.Log);
+            }
+        }
+
+        [Fact]
+        public void CanUnzip_WithIncludeAndExcludeFilter()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);
+                TransientTestFolder sub = source.CreateDirectory("sub");
+                testEnvironment.CreateFile(source, "file1.js", "file1");
+                testEnvironment.CreateFile(source, "file1.js.map", "file2");
+                testEnvironment.CreateFile(source, "file2.js", "file3");
+                testEnvironment.CreateFile(source, "readme.txt", "file4");
+                testEnvironment.CreateFile(sub, "subfile.js", "File5");
+
+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
+
+                Unzip unzip = new Unzip
+                                  {
+                                      BuildEngine = _mockEngine,
+                                      DestinationFolder = new TaskItem(destination.Path),
+                                      OverwriteReadOnlyFiles = true,
+                                      SkipUnchangedFiles = false,
+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                                      Include = "*.js",
+                                      Exclude = "*.js.map;sub\\*.js"
+                                  };
+
+                unzip.Execute().ShouldBeTrue(() => _mockEngine.Log);
+
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "file1.js"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "file1.js.map"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldContain(Path.Combine(destination.Path, "file2.js"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "readme.txt"), () => _mockEngine.Log);
+                _mockEngine.Log.ShouldNotContain(Path.Combine(destination.Path, "sub", "subfile.js"), () => _mockEngine.Log);
+            }
+        }
+
+        [Fact]
+        public void LogsErrorIfIncludeContainsInvalidPathCharacters()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);
+                testEnvironment.CreateFile(source, "BE78A17D30144B549D21F71D5C633F7D.txt", "file1");
+                testEnvironment.CreateFile(source, "A04FF4B88DF14860B7C73A8E75A4FB76.txt", "file2");
+
+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
+
+                Unzip unzip = new Unzip
+                                  {
+                                      BuildEngine = _mockEngine,
+                                      DestinationFolder = new TaskItem(destination.Path),
+                                      OverwriteReadOnlyFiles = true,
+                                      SkipUnchangedFiles = false,
+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                                      Include = "<BE78A17D30144B|549D21F71D5C633F7D/.txt"
+                                  };
+
+                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+
+                _mockEngine.Log.ShouldContain("MSB3937", () => _mockEngine.Log);
+            }
+        }
+
+        [Fact]
+        public void LogsErrorIfIncludeContainsPropertyReferences()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);
+                testEnvironment.CreateFile(source, "BE78A17D30144B549D21F71D5C633F7D.txt", "file1");
+                testEnvironment.CreateFile(source, "A04FF4B88DF14860B7C73A8E75A4FB76.txt", "file2");
+
+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
+
+                Unzip unzip = new Unzip
+                                  {
+                                      BuildEngine = _mockEngine,
+                                      DestinationFolder = new TaskItem(destination.Path),
+                                      OverwriteReadOnlyFiles = true,
+                                      SkipUnchangedFiles = false,
+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                                      Include = "$(Include)"
+                                  };
+
+                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+
+                _mockEngine.Log.ShouldContain("MSB3938", () => _mockEngine.Log);
+            }
+        }
+
+        [Fact]
+        public void LogsErrorIfExcludeContainsInvalidPathCharacters()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);
+                testEnvironment.CreateFile(source, "BE78A17D30144B549D21F71D5C633F7D.txt", "file1");
+                testEnvironment.CreateFile(source, "A04FF4B88DF14860B7C73A8E75A4FB76.txt", "file2");
+
+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
+
+                Unzip unzip = new Unzip
+                                  {
+                                      BuildEngine = _mockEngine,
+                                      DestinationFolder = new TaskItem(destination.Path),
+                                      OverwriteReadOnlyFiles = true,
+                                      SkipUnchangedFiles = false,
+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                                      Exclude = "<BE78A17D30144B|549D21F71D5C633F7D/.txt"
+                                  };
+
+                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+
+                _mockEngine.Log.ShouldContain("MSB3937", () => _mockEngine.Log);
+            }
+        }
+
+        [Fact]
+        public void LogsErrorIfExcludeContainsPropertyReferences()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder source = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder destination = testEnvironment.CreateFolder(createFolder: false);
+                testEnvironment.CreateFile(source, "BE78A17D30144B549D21F71D5C633F7D.txt", "file1");
+                testEnvironment.CreateFile(source, "A04FF4B88DF14860B7C73A8E75A4FB76.txt", "file2");
+
+                TransientZipArchive zipArchive = TransientZipArchive.Create(source, testEnvironment.CreateFolder(createFolder: true));
+
+                Unzip unzip = new Unzip
+                                  {
+                                      BuildEngine = _mockEngine,
+                                      DestinationFolder = new TaskItem(destination.Path),
+                                      OverwriteReadOnlyFiles = true,
+                                      SkipUnchangedFiles = false,
+                                      SourceFiles = new ITaskItem[] { new TaskItem(zipArchive.Path) },
+                                      Exclude = "$(Include)"
+                                  };
+
+                unzip.Execute().ShouldBeFalse(() => _mockEngine.Log);
+
+                _mockEngine.Log.ShouldContain("MSB3938", () => _mockEngine.Log);
+            }
+        }
     }
 }
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
index ab6b685ba91..8a40638f1d8 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
@@ -99,8 +99,8 @@ internal class AssemblyFoldersExResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public AssemblyFoldersExResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, GetAssemblyRuntimeVersion getRuntimeVersion, OpenBaseKey openBaseKey, Version targetedRuntimeVesion, ProcessorArchitecture targetProcessorArchitecture, bool compareProcessorArchitecture, IBuildEngine buildEngine)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, targetProcessorArchitecture, compareProcessorArchitecture)
+        public AssemblyFoldersExResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, GetAssemblyRuntimeVersion getRuntimeVersion, OpenBaseKey openBaseKey, Version targetedRuntimeVesion, ProcessorArchitecture targetProcessorArchitecture, bool compareProcessorArchitecture, IBuildEngine buildEngine)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, targetProcessorArchitecture, compareProcessorArchitecture)
         {
             _buildEngine = buildEngine as IBuildEngine4;
             _getRegistrySubKeyNames = getRegistrySubKeyNames;
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
index e6e2a2bcb80..bcbe5b2fc99 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
@@ -74,11 +74,11 @@ internal class AssemblyFoldersFromConfigResolver : Resolver
         /// Construct.
         /// </summary>
         public AssemblyFoldersFromConfigResolver(string searchPathElement, GetAssemblyName getAssemblyName,
-            FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion,
+            FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion,
             ProcessorArchitecture targetProcessorArchitecture, bool compareProcessorArchitecture,
             IBuildEngine buildEngine, TaskLoggingHelper log)
             : base(
-                searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion,
+                searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion,
                 targetProcessorArchitecture, compareProcessorArchitecture)
         {
             _buildEngine = buildEngine as IBuildEngine4;
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
index 82fbcc95204..04355c6803b 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
@@ -18,10 +18,11 @@ internal class AssemblyFoldersResolver : Resolver
         /// <param name="searchPathElement">The corresponding element from the search path.</param>
         /// <param name="getAssemblyName">Delegate that gets the assembly name.</param>
         /// <param name="fileExists">Delegate that returns if the file exists.</param>
+        /// <param name="fileExistsInDirectory">Delegate to test if file exists in directory.</param>
         /// <param name="getRuntimeVersion">Delegate that returns the clr runtime version for the file.</param>
         /// <param name="targetedRuntimeVesion">The targeted runtime version.</param>
-        public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
+        public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
         {
         }
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyResolution.cs b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
index f2fe396824f..1f604001d55 100644
--- a/src/Tasks/AssemblyDependency/AssemblyResolution.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
@@ -109,6 +109,7 @@ out userRequestedSpecificFile
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
         /// <param name="frameworkPaths">Paths to FX folders.</param>
         /// <param name="fileExists"></param>
+        /// <param name="fileExistsInDirectory"></param>
         /// <param name="getAssemblyName"></param>
         /// <param name="getRegistrySubKeyNames"></param>
         /// <param name="getRegistrySubKeyDefaultValue"></param>
@@ -129,6 +130,7 @@ out userRequestedSpecificFile
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
         /// <param name="frameworkPaths">Paths to FX folders.</param>
         /// <param name="fileExists"></param>
+        /// <param name="fileExistsInDirectory"></param>
         /// <param name="getAssemblyName"></param>
         /// <param name="installedAssemblies"></param>
         /// <param name="getRuntimeVersion"></param>
@@ -145,6 +147,7 @@ public static Resolver[] CompileSearchPaths
             System.Reflection.ProcessorArchitecture targetProcessorArchitecture,
             string[] frameworkPaths,
             FileExists fileExists,
+            FileExistsInDirectory fileExistsInDirectory,
             GetAssemblyName getAssemblyName,
 #if FEATURE_WIN32_REGISTRY
             GetRegistrySubKeyNames getRegistrySubKeyNames,
@@ -168,44 +171,44 @@ TaskLoggingHelper log
                 // HintPath property.
                 if (String.Equals(basePath, AssemblyResolutionConstants.hintPathSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new HintPathResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new HintPathResolver(searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion);
                 }
                 else if (String.Equals(basePath, AssemblyResolutionConstants.frameworkPathSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new FrameworkPathResolver(frameworkPaths, installedAssemblies, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new FrameworkPathResolver(frameworkPaths, installedAssemblies, searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion);
                 }
                 else if (String.Equals(basePath, AssemblyResolutionConstants.rawFileNameSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new RawFilenameResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new RawFilenameResolver(searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion);
                 }
                 else if (String.Equals(basePath, AssemblyResolutionConstants.candidateAssemblyFilesSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new CandidateAssemblyFilesResolver(candidateAssemblyFiles, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new CandidateAssemblyFilesResolver(candidateAssemblyFiles, searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion);
                 }
 #if FEATURE_GAC
                 else if (String.Equals(basePath, AssemblyResolutionConstants.gacSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new GacResolver(targetProcessorArchitecture, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, getAssemblyPathInGac);
+                    resolvers[p] = new GacResolver(targetProcessorArchitecture, searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion, getAssemblyPathInGac);
                 }
 #endif
                 else if (String.Equals(basePath, AssemblyResolutionConstants.assemblyFoldersSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new AssemblyFoldersResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new AssemblyFoldersResolver(searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion);
                 }
 #if FEATURE_WIN32_REGISTRY
                 // Check for AssemblyFoldersEx sentinel.
                 else if (0 == String.Compare(basePath, 0, AssemblyResolutionConstants.assemblyFoldersExSentinel, 0, AssemblyResolutionConstants.assemblyFoldersExSentinel.Length, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new AssemblyFoldersExResolver(searchPaths[p], getAssemblyName, fileExists, getRegistrySubKeyNames, getRegistrySubKeyDefaultValue, getRuntimeVersion, openBaseKey, targetedRuntimeVersion, targetProcessorArchitecture, true, buildEngine);
+                    resolvers[p] = new AssemblyFoldersExResolver(searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRegistrySubKeyNames, getRegistrySubKeyDefaultValue, getRuntimeVersion, openBaseKey, targetedRuntimeVersion, targetProcessorArchitecture, true, buildEngine);
                 }
 #endif
                 else if (0 == String.Compare(basePath, 0, AssemblyResolutionConstants.assemblyFoldersFromConfigSentinel, 0, AssemblyResolutionConstants.assemblyFoldersFromConfigSentinel.Length, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new AssemblyFoldersFromConfigResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, targetProcessorArchitecture, true, buildEngine, log);
+                    resolvers[p] = new AssemblyFoldersFromConfigResolver(searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion, targetProcessorArchitecture, true, buildEngine, log);
                 }
                 else
                 {
-                    resolvers[p] = new DirectoryResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new DirectoryResolver(searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion);
                 }
             }
             return resolvers;
@@ -218,6 +221,7 @@ internal static Resolver[] CompileDirectories
         (
             List<string> directories,
             FileExists fileExists,
+            FileExistsInDirectory fileExistsInDirectory,
             GetAssemblyName getAssemblyName,
             GetAssemblyRuntimeVersion getRuntimeVersion,
             Version targetedRuntimeVersion
@@ -226,7 +230,7 @@ Version targetedRuntimeVersion
             var resolvers = new Resolver[directories.Count];
             for (int i = 0; i < directories.Count; i++)
             {
-                resolvers[i] = new DirectoryResolver(directories[i], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                resolvers[i] = new DirectoryResolver(directories[i], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion);
             }
 
             return resolvers;
diff --git a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
index 23ccac23cb2..cbb0d614185 100644
--- a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
+++ b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
@@ -26,10 +26,11 @@ internal class CandidateAssemblyFilesResolver : Resolver
         /// <param name="searchPathElement">The corresponding element from the search path.</param>
         /// <param name="getAssemblyName">Delegate that gets the assembly name.</param>
         /// <param name="fileExists">Delegate that returns if the file exists.</param>
+        /// <param name="fileExistsInDirectory">Delegate to test if file exists in directory and return full file name</param>
         /// <param name="getRuntimeVersion">Delegate that returns the clr runtime version for the file.</param>
         /// <param name="targetedRuntimeVesion">The targeted runtime version.</param>
-        public CandidateAssemblyFilesResolver(string[] candidateAssemblyFiles, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
+        public CandidateAssemblyFilesResolver(string[] candidateAssemblyFiles, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
         {
             _candidateAssemblyFiles = candidateAssemblyFiles;
         }
diff --git a/src/Tasks/AssemblyDependency/DirectoryResolver.cs b/src/Tasks/AssemblyDependency/DirectoryResolver.cs
index 8f7be0e76ac..3ec833c0201 100644
--- a/src/Tasks/AssemblyDependency/DirectoryResolver.cs
+++ b/src/Tasks/AssemblyDependency/DirectoryResolver.cs
@@ -15,8 +15,8 @@ internal class DirectoryResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public DirectoryResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
+        public DirectoryResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
         {
         }
 
diff --git a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
index bfee4b6dc71..e64f95aac69 100644
--- a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
@@ -21,8 +21,8 @@ internal class FrameworkPathResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public FrameworkPathResolver(string[] frameworkPaths, InstalledAssemblies installedAssemblies, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
+        public FrameworkPathResolver(string[] frameworkPaths, InstalledAssemblies installedAssemblies, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
         {
             _frameworkPaths = frameworkPaths;
             _installedAssemblies = installedAssemblies;
diff --git a/src/Tasks/AssemblyDependency/GacResolver.cs b/src/Tasks/AssemblyDependency/GacResolver.cs
index 16342d58a31..23e73349d61 100644
--- a/src/Tasks/AssemblyDependency/GacResolver.cs
+++ b/src/Tasks/AssemblyDependency/GacResolver.cs
@@ -24,11 +24,12 @@ internal class GacResolver : Resolver
         /// <param name="searchPathElement">The search path element.</param>
         /// <param name="getAssemblyName">Delegate to get the assembly name object.</param>
         /// <param name="fileExists">Delegate to check if the file exists.</param>
+        /// <param name="fileExistsInDirectory">Delegate to check if the file exists by cached list of files of directory.</param>
         /// <param name="getRuntimeVersion">Delegate to get the runtime version.</param>
         /// <param name="targetedRuntimeVesion">The targeted runtime version.</param>
         /// <param name="getAssemblyPathInGac">Delegate to get assembly path in the GAC.</param>
-        public GacResolver(System.Reflection.ProcessorArchitecture targetProcessorArchitecture, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, GetAssemblyPathInGac getAssemblyPathInGac)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, targetProcessorArchitecture, true)
+        public GacResolver(System.Reflection.ProcessorArchitecture targetProcessorArchitecture, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, GetAssemblyPathInGac getAssemblyPathInGac)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, targetProcessorArchitecture, true)
         {
             _getAssemblyPathInGac = getAssemblyPathInGac;
         }
diff --git a/src/Tasks/AssemblyDependency/HintPathResolver.cs b/src/Tasks/AssemblyDependency/HintPathResolver.cs
index d4a90c0e2b4..cf2787c9d92 100644
--- a/src/Tasks/AssemblyDependency/HintPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/HintPathResolver.cs
@@ -16,8 +16,8 @@ internal class HintPathResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public HintPathResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
+        public HintPathResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
         {
         }
 
diff --git a/src/Tasks/AssemblyDependency/RawFilenameResolver.cs b/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
index b75ef96a73b..7f287fb65ca 100644
--- a/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
+++ b/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
@@ -16,8 +16,8 @@ internal class RawFilenameResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public RawFilenameResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
+        public RawFilenameResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
         {
         }
 
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 405f8662611..68b70aa8fb7 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -79,6 +79,8 @@ internal sealed class ReferenceTable
         private readonly DirectoryExists _directoryExists;
         /// <summary>Delegate used for getting directories.</summary>
         private readonly GetDirectories _getDirectories;
+        /// <summary>Delegate used for checking for the existence of a file in a directory.</summary>
+        private readonly FileExistsInDirectory _fileExistsInDirectory;
         /// <summary>Delegate used for getting assembly names.</summary>
         private readonly GetAssemblyName _getAssemblyName;
         /// <summary>Delegate used for finding dependencies of a file.</summary>
@@ -175,6 +177,7 @@ internal sealed class ReferenceTable
         /// <param name="installedAssemblies">Installed assembly XML tables.</param>
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
         /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
+        /// <param name="fileExistsInDirectory">Delegate used for checking for the existence of a file in a directory.</param>
         /// <param name="directoryExists">Delegate used for files.</param>
         /// <param name="getDirectories">Delegate used for getting directories.</param>
         /// <param name="getAssemblyName">Delegate used for getting assembly names.</param>
@@ -216,6 +219,7 @@ internal sealed class ReferenceTable
         /// <param name="installedAssemblies">Installed assembly XML tables.</param>
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
         /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
+        /// <param name="fileExistsInDirectory">Delegate used for checking for the existence of a file in a directory.</param>
         /// <param name="directoryExists">Delegate used for files.</param>
         /// <param name="getDirectories">Delegate used for getting directories.</param>
         /// <param name="getAssemblyName">Delegate used for getting assembly names.</param>
@@ -254,6 +258,7 @@ internal ReferenceTable
             InstalledAssemblies installedAssemblies,
             System.Reflection.ProcessorArchitecture targetProcessorArchitecture,
             FileExists fileExists,
+            FileExistsInDirectory fileExistsInDirectory,
             DirectoryExists directoryExists,
             GetDirectories getDirectories,
             GetAssemblyName getAssemblyName,
@@ -293,6 +298,7 @@ internal ReferenceTable
             _fileExists = fileExists;
             _directoryExists = directoryExists;
             _getDirectories = getDirectories;
+            _fileExistsInDirectory = fileExistsInDirectory;
             _getAssemblyName = getAssemblyName;
             _getAssemblyMetadata = getAssemblyMetadata;
             _getRuntimeVersion = getRuntimeVersion;
@@ -348,6 +354,7 @@ internal ReferenceTable
                     targetProcessorArchitecture,
                     frameworkPaths,
                     fileExists,
+                    fileExistsInDirectory,
                     getAssemblyName,
 #if FEATURE_WIN32_REGISTRY
                     getRegistrySubKeyNames,
@@ -1302,14 +1309,14 @@ Reference reference
             // If a reference has the SDKName metadata on it then we will only search using a single resolver, that is the InstalledSDKResolver.
             if (reference.SDKName.Length > 0)
             {
-                jaggedResolvers.Add(new Resolver[] { new InstalledSDKResolver(_resolvedSDKReferences, "SDKResolver", _getAssemblyName, _fileExists, _getRuntimeVersion, _targetedRuntimeVersion) });
+                jaggedResolvers.Add(new Resolver[] { new InstalledSDKResolver(_resolvedSDKReferences, "SDKResolver", _getAssemblyName, _fileExists, _fileExistsInDirectory, _getRuntimeVersion, _targetedRuntimeVersion) });
             }
             else
             {
                 // Do not probe near dependees if the reference is primary and resolved externally. If resolved externally, the search paths should have been specified in such a way to point to the assembly file.
                 if (assemblyName == null || !_externallyResolvedPrimaryReferences.Contains(assemblyName.Name))
                 {
-                    jaggedResolvers.Add(AssemblyResolution.CompileDirectories(parentReferenceFolders, _fileExists, _getAssemblyName, _getRuntimeVersion, _targetedRuntimeVersion));
+                    jaggedResolvers.Add(AssemblyResolution.CompileDirectories(parentReferenceFolders, _fileExists, _fileExistsInDirectory, _getAssemblyName, _getRuntimeVersion, _targetedRuntimeVersion));
                 }
 
                 jaggedResolvers.Add(Resolvers);
@@ -2616,14 +2623,6 @@ internal void GetReferenceItems
             out ITaskItem[] copyLocalFiles
         )
         {
-            primaryFiles = Array.Empty<ITaskItem>();
-            dependencyFiles = Array.Empty<ITaskItem>();
-            relatedFiles = Array.Empty<ITaskItem>();
-            satelliteFiles = Array.Empty<ITaskItem>();
-            serializationAssemblyFiles = Array.Empty<ITaskItem>();
-            scatterFiles = Array.Empty<ITaskItem>();
-            copyLocalFiles = Array.Empty<ITaskItem>();
-
             var primaryItems = new List<ITaskItem>();
             var dependencyItems = new List<ITaskItem>();
             var relatedItems = new List<ITaskItem>();
@@ -2632,10 +2631,10 @@ out ITaskItem[] copyLocalFiles
             var scatterItems = new List<ITaskItem>();
             var copyLocalItems = new List<ITaskItem>();
 
-            foreach (AssemblyNameExtension assemblyName in References.Keys)
+            foreach (KeyValuePair<AssemblyNameExtension, Reference> kvp in References)
             {
-                string fusionName = assemblyName.FullName;
-                Reference reference = GetReference(assemblyName);
+                AssemblyNameExtension assemblyName = kvp.Key;
+                Reference reference = kvp.Value;
 
                 // Conflict victims and badimages are filtered out.
                 if (!reference.IsBadImage)
@@ -2664,7 +2663,7 @@ out ITaskItem[] copyLocalFiles
 
                     if (reference.IsResolved)
                     {
-                        ITaskItem referenceItem = SetItemMetadata(relatedItems, satelliteItems, serializationAssemblyItems, scatterItems, fusionName, reference, assemblyName);
+                        ITaskItem referenceItem = SetItemMetadata(relatedItems, satelliteItems, serializationAssemblyItems, scatterItems, assemblyName.FullName, reference, assemblyName);
 
                         if (reference.IsPrimary)
                         {
@@ -2683,9 +2682,7 @@ out ITaskItem[] copyLocalFiles
                 }
             }
 
-            primaryFiles = new ITaskItem[primaryItems.Count];
-            primaryItems.CopyTo(primaryFiles, 0);
-
+            primaryFiles = primaryItems.ToArray();
             dependencyFiles = dependencyItems.ToArray();
             relatedFiles = relatedItems.ToArray();
             satelliteFiles = satelliteItems.ToArray();
@@ -2711,22 +2708,12 @@ out ITaskItem[] copyLocalFiles
         private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem> satelliteItems, List<ITaskItem> serializationAssemblyItems, List<ITaskItem> scatterItems, string fusionName, Reference reference, AssemblyNameExtension assemblyName)
         {
             // Set up the main item.
-            ITaskItem referenceItem = new TaskItem();
+            TaskItem referenceItem = new TaskItem();
             referenceItem.ItemSpec = reference.FullPath;
             referenceItem.SetMetadata(ItemMetadataNames.resolvedFrom, reference.ResolvedSearchPath);
 
             // Set the CopyLocal metadata.
-            if (reference.IsCopyLocal)
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.copyLocal, "true");
-            }
-            else
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.copyLocal, "false");
-            }
-
-            // Set the FusionName metadata.
-            referenceItem.SetMetadata(ItemMetadataNames.fusionName, fusionName);
+            referenceItem.SetMetadata(ItemMetadataNames.copyLocal, reference.IsCopyLocal ? "true" : "false");
 
             // Set the Redist name metadata.
             if (!String.IsNullOrEmpty(reference.RedistName))
@@ -2747,57 +2734,11 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
                 referenceItem.SetMetadata(ItemMetadataNames.imageRuntime, reference.ImageRuntime);
             }
 
-            if (reference.IsWinMDFile)
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.winMDFile, "true");
-
-                // The ImplementationAssembly is only set if the implementation file exits on disk
-                if (reference.ImplementationAssembly != null)
-                {
-                    if (VerifyArchitectureOfImplementationDll(reference.ImplementationAssembly, reference.FullPath))
-                    {
-                        if (string.IsNullOrEmpty(referenceItem.GetMetadata(ItemMetadataNames.winmdImplmentationFile)))
-                        {
-                            referenceItem.SetMetadata(ItemMetadataNames.winmdImplmentationFile, Path.GetFileName(reference.ImplementationAssembly));
-                        }
-
-                        // Add the implementation item as a related file
-                        ITaskItem item = new TaskItem(reference.ImplementationAssembly);
-                        // Clone metadata.
-                        referenceItem.CopyMetadataTo(item);
-                        // Related files don't have a fusion name.
-                        item.SetMetadata(ItemMetadataNames.fusionName, "");
-                        RemoveNonForwardableMetadata(item);
-
-                        // Add the related item.
-                        relatedItems.Add(item);
-                    }
-                }
-
-                if (reference.IsManagedWinMDFile)
-                {
-                    referenceItem.SetMetadata(ItemMetadataNames.winMDFileType, "Managed");
-                }
-                else
-                {
-                    referenceItem.SetMetadata(ItemMetadataNames.winMDFileType, "Native");
-                }
-            }
-
-            // Set the IsRedistRoot metadata
-            if (reference.IsRedistRoot == true)
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.isRedistRoot, "true");
-            }
-            else if (reference.IsRedistRoot == false)
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.isRedistRoot, "false");
-            }
-            else
+            // The redist root is "null" when there was no IsRedistRoot flag in the Redist XML
+            // (or there was no redist XML at all for this item).
+            if (reference.IsRedistRoot != null)
             {
-                // This happens when the redist root is "null". This means there
-                // was no IsRedistRoot flag in the Redist XML (or there was no 
-                // redist XML at all for this item).
+                referenceItem.SetMetadata(ItemMetadataNames.isRedistRoot, (bool)reference.IsRedistRoot ? "true" : "false");
             }
 
             // If there was a primary source item, then forward metadata from it.
@@ -2826,14 +2767,14 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
                 }
 
                 // If the item originally did not have the implementation file metadata then we do not want to get it from the set of primary source items
-                // since the implementation file is something specific to the source item and not supposed to be propigated.
+                // since the implementation file is something specific to the source item and not supposed to be propagated.
                 if (!hasImplementationFile)
                 {
                     referenceItem.RemoveMetadata(ItemMetadataNames.winmdImplmentationFile);
                 }
 
                 // If the item originally did not have the ImageRuntime metadata then we do not want to get it from the set of primary source items
-                // since the ImageRuntime is something specific to the source item and not supposed to be propigated.
+                // since the ImageRuntime is something specific to the source item and not supposed to be propagated.
                 if (!hasImageRuntime)
                 {
                     referenceItem.RemoveMetadata(ItemMetadataNames.imageRuntime);
@@ -2847,68 +2788,63 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
                 }
             }
 
-            if (reference.ReferenceVersion != null)
-            {
-                referenceItem.SetMetadata(ItemMetadataNames.version, reference.ReferenceVersion.ToString());
-            }
-            else
+            referenceItem.SetMetadata(ItemMetadataNames.version, reference.ReferenceVersion == null ? string.Empty : reference.ReferenceVersion.ToString());
+
+            // Unset fusionName so we don't have to unset it later.
+            referenceItem.RemoveMetadata(ItemMetadataNames.fusionName);
+
+            List<string> relatedFileExtensions = reference.GetRelatedFileExtensions();
+            List<string> satellites = reference.GetSatelliteFiles();
+            List<string> serializationAssemblyFiles = reference.GetSerializationAssemblyFiles();
+            string[] scatterFiles = reference.GetScatterFiles();
+            Dictionary<string, string> nonForwardableMetadata = null;
+            if (relatedFileExtensions.Count > 0 || satellites.Count > 0 || serializationAssemblyFiles.Count > 0 || scatterFiles.Length > 0)
             {
-                referenceItem.SetMetadata(ItemMetadataNames.version, String.Empty);
+                // Unset non-forwardable metadata now so we don't have to do it for individual items.
+                nonForwardableMetadata = RemoveNonForwardableMetadata(referenceItem);
             }
 
             // Now clone all properties onto the related files.
-            foreach (string relatedFileExtension in reference.GetRelatedFileExtensions())
+            foreach (string relatedFileExtension in relatedFileExtensions)
             {
                 ITaskItem item = new TaskItem(reference.FullPathWithoutExtension + relatedFileExtension);
                 // Clone metadata.
                 referenceItem.CopyMetadataTo(item);
-                // Related files don't have a fusion name.
-                item.SetMetadata(ItemMetadataNames.fusionName, "");
-                RemoveNonForwardableMetadata(item);
 
                 // Add the related item.
                 relatedItems.Add(item);
             }
 
             // Set up the satellites.
-            foreach (string satelliteFile in reference.GetSatelliteFiles())
+            foreach (string satelliteFile in satellites)
             {
                 ITaskItem item = new TaskItem(Path.Combine(reference.DirectoryName, satelliteFile));
                 // Clone metadata.
                 referenceItem.CopyMetadataTo(item);
                 // Set the destination directory.
                 item.SetMetadata(ItemMetadataNames.destinationSubDirectory, FileUtilities.EnsureTrailingSlash(Path.GetDirectoryName(satelliteFile)));
-                // Satellite files don't have a fusion name.
-                item.SetMetadata(ItemMetadataNames.fusionName, "");
-                RemoveNonForwardableMetadata(item);
 
                 // Add the satellite item.
                 satelliteItems.Add(item);
             }
 
             // Set up the serialization assemblies
-            foreach (string serializationAssemblyFile in reference.GetSerializationAssemblyFiles())
+            foreach (string serializationAssemblyFile in serializationAssemblyFiles)
             {
                 ITaskItem item = new TaskItem(Path.Combine(reference.DirectoryName, serializationAssemblyFile));
                 // Clone metadata.
                 referenceItem.CopyMetadataTo(item);
-                // serialization assemblies files don't have a fusion name.
-                item.SetMetadata(ItemMetadataNames.fusionName, "");
-                RemoveNonForwardableMetadata(item);
 
                 // Add the serialization assembly item.
                 serializationAssemblyItems.Add(item);
             }
 
             // Set up the scatter files.
-            foreach (string scatterFile in reference.GetScatterFiles())
+            foreach (string scatterFile in scatterFiles)
             {
                 ITaskItem item = new TaskItem(Path.Combine(reference.DirectoryName, scatterFile));
                 // Clone metadata.
                 referenceItem.CopyMetadataTo(item);
-                // We don't have a fusion name for scatter files.
-                item.SetMetadata(ItemMetadataNames.fusionName, "");
-                RemoveNonForwardableMetadata(item);
 
                 // Add the satellite item.
                 scatterItems.Add(item);
@@ -2928,6 +2864,61 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
                 }
             }
 
+            if (reference.IsWinMDFile)
+            {
+                // The ImplementationAssembly is only set if the implementation file exits on disk
+                if (reference.ImplementationAssembly != null)
+                {
+                    if (VerifyArchitectureOfImplementationDll(reference.ImplementationAssembly, reference.FullPath))
+                    {
+                        // Add the implementation item as a related file
+                        ITaskItem item = new TaskItem(reference.ImplementationAssembly);
+                        // Clone metadata.
+                        referenceItem.CopyMetadataTo(item);
+
+                        // Add the related item.
+                        relatedItems.Add(item);
+
+                        referenceItem.SetMetadata(ItemMetadataNames.winmdImplmentationFile, Path.GetFileName(reference.ImplementationAssembly));
+                        // This may have been set previously (before it was removed so we could more efficiently set metadata on the various related files).
+                        // This version should take priority, so we remove it from nonForwardableMetadata if it's there to prevent the correct value from
+                        // being overwritten.
+                        nonForwardableMetadata?.Remove(ItemMetadataNames.winmdImplmentationFile);
+                    }
+                }
+
+                // This may have been set previously (before it was removed so we could more efficiently set metadata on the various related files).
+                // This version should take priority, so we remove it from nonForwardableMetadata if it's there to prevent the correct value from
+                // being overwritten.
+                nonForwardableMetadata?.Remove(ItemMetadataNames.winMDFileType);
+                if (reference.IsManagedWinMDFile)
+                {
+                    referenceItem.SetMetadata(ItemMetadataNames.winMDFileType, "Managed");
+                }
+                else
+                {
+                    referenceItem.SetMetadata(ItemMetadataNames.winMDFileType, "Native");
+                }
+
+                // This may have been set previously (before it was removed so we could more efficiently set metadata on the various related files).
+                // This version should take priority, so we remove it from nonForwardableMetadata if it's there to prevent the correct value from
+                // being overwritten.
+                nonForwardableMetadata?.Remove(ItemMetadataNames.winMDFile);
+                referenceItem.SetMetadata(ItemMetadataNames.winMDFile, "true");
+            }
+
+            // Set the FusionName late, so we don't copy it to the derived items, but it's still available on referenceItem.
+            referenceItem.SetMetadata(ItemMetadataNames.fusionName, fusionName);
+
+            // nonForwardableMetadata should be null here if relatedFileExtensions, satellites, serializationAssemblyFiles, and scatterFiles were all empty.
+            if (nonForwardableMetadata != null)
+            {
+                foreach (KeyValuePair<string, string> kvp in nonForwardableMetadata)
+                {
+                    referenceItem.SetMetadata(kvp.Key, kvp.Value);
+                }
+            }
+
             return referenceItem;
         }
 
@@ -3061,15 +3052,28 @@ IMAGE_FILE_MACHINE_IA64	0x200	Intel Itanium processor family
         /// <summary>
         /// Some metadata should not be forwarded between the parent and child items.
         /// </summary>
-        private static void RemoveNonForwardableMetadata(ITaskItem item)
+        /// <returns>The metadata that were removed.</returns>
+        private static Dictionary<string, string> RemoveNonForwardableMetadata(ITaskItem item)
         {
-            item.RemoveMetadata(ItemMetadataNames.winmdImplmentationFile);
-            item.RemoveMetadata(ItemMetadataNames.imageRuntime);
-            item.RemoveMetadata(ItemMetadataNames.winMDFile);
+            Dictionary<string, string> removedMetadata = new Dictionary<string, string>();
+            RemoveMetadatum(ItemMetadataNames.winmdImplmentationFile, item, removedMetadata);
+            RemoveMetadatum(ItemMetadataNames.imageRuntime, item, removedMetadata);
+            RemoveMetadatum(ItemMetadataNames.winMDFile, item, removedMetadata);
             if (!Traits.Instance.EscapeHatches.TargetPathForRelatedFiles)
             {
-                item.RemoveMetadata(ItemMetadataNames.targetPath);
+                RemoveMetadatum(ItemMetadataNames.targetPath, item, removedMetadata);
+            }
+            return removedMetadata;
+        }
+
+        private static void RemoveMetadatum(string key, ITaskItem item, Dictionary<string, string> removedMetadata)
+        {
+            string meta = item.GetMetadata(key);
+            if (!String.IsNullOrEmpty(meta))
+            {
+                removedMetadata.Add(key, meta);
             }
+            item.RemoveMetadata(key);
         }
 
         /// <summary>
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index b7e72734291..e3834148241 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -1024,8 +1024,8 @@ quiet at the engine level.
                                 {
                                     { "logMessage", output },
                                     { "logMessageDetails", details },
-                                    { "victorVersionNumber", victor.ReferenceVersion.ToString() },
-                                    { "victimVersionNumber", conflictCandidate.ReferenceVersion.ToString() }
+                                    { "victorVersionNumber", victor.ReferenceVersion?.ToString() },
+                                    { "victimVersionNumber", conflictCandidate.ReferenceVersion?.ToString() }
                                 }));
                             }
                         }
@@ -1934,6 +1934,7 @@ private List<DependentAssembly> GetAssemblyRemappingsFromAppConfig()
         /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
         /// <param name="directoryExists">Delegate used for checking for the existence of a directory.</param>
         /// <param name="getDirectories">Delegate used for finding directories.</param>
+        /// <param name="getDirectoryFiles">Delegate used to get files from directories.</param>
         /// <param name="getAssemblyName">Delegate used for finding fusion names of assemblyFiles.</param>
         /// <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
         /// <param name="getRegistrySubKeyNames">Used to get registry subkey names.</param>
@@ -1952,6 +1953,7 @@ private List<DependentAssembly> GetAssemblyRemappingsFromAppConfig()
         /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
         /// <param name="directoryExists">Delegate used for checking for the existence of a directory.</param>
         /// <param name="getDirectories">Delegate used for finding directories.</param>
+        /// <param name="getDirectoryFiles">Delegate used to get files from directories.</param>
         /// <param name="getAssemblyName">Delegate used for finding fusion names of assemblyFiles.</param>
         /// <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
         /// <param name="getLastWriteTime">Delegate used to get the last write time.</param>
@@ -1966,6 +1968,7 @@ internal bool Execute
             FileExists fileExists,
             DirectoryExists directoryExists,
             GetDirectories getDirectories,
+            DirectoryGetFiles getDirectoryFiles,
             GetAssemblyName getAssemblyName,
             GetAssemblyMetadata getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -2141,6 +2144,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     getAssemblyMetadata = _cache.CacheDelegate(getAssemblyMetadata);
                     fileExists = _cache.CacheDelegate(fileExists);
                     directoryExists = _cache.CacheDelegate(directoryExists);
+                    FileExistsInDirectory fileExistsInDirectory = _cache.CacheDelegate(getDirectoryFiles);
                     getDirectories = _cache.CacheDelegate(getDirectories);
                     getRuntimeVersion = _cache.CacheDelegate(getRuntimeVersion);
 
@@ -2188,6 +2192,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                         installedAssemblies,
                         processorArchitecture,
                         fileExists,
+                        fileExistsInDirectory,
                         directoryExists,
                         getDirectories,
                         getAssemblyName,
@@ -3023,6 +3028,7 @@ public override bool Execute()
                 new FileExists(p => FileUtilities.FileExistsNoThrow(p)),
                 new DirectoryExists(p => FileUtilities.DirectoryExistsNoThrow(p)),
                 new GetDirectories(Directory.GetDirectories),
+                new DirectoryGetFiles((d, p) => FileUtilities.DirectoryGetFiles(d, p)),
                 new GetAssemblyName(AssemblyNameExtension.GetAssemblyNameEx),
                 new GetAssemblyMetadata(AssemblyInformation.GetAssemblyMetadata),
 #if FEATURE_WIN32_REGISTRY
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index be72b128729..72dd8c4a4c7 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -29,6 +29,11 @@ internal abstract class Resolver
         /// </summary>
         protected FileExists fileExists;
 
+        /// <summary>
+        /// Delegate.
+        /// </summary>
+        private readonly FileExistsInDirectory fileExistsInDirectory;
+
         /// <summary>
         /// Delegate
         /// </summary>
@@ -52,11 +57,12 @@ internal abstract class Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture)
+        protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture)
         {
             this.searchPathElement = searchPathElement;
             this.getAssemblyName = getAssemblyName;
             this.fileExists = fileExists;
+            this.fileExistsInDirectory = fileExistsInDirectory;
             this.getRuntimeVersion = getRuntimeVersion;
             this.targetedRuntimeVersion = targetedRuntimeVesion;
             this.targetProcessorArchitecture = targetedProcessorArchitecture;
@@ -109,7 +115,10 @@ protected bool ResolveAsFile
             bool isPrimaryProjectReference,
             bool wantSpecificVersion,
             bool allowMismatchBetweenFusionNameAndFileName,
-            List<ResolutionSearchLocation> assembliesConsideredAndRejected
+            List<ResolutionSearchLocation> assembliesConsideredAndRejected,
+            bool useDirectoryCache = false,
+            string directory = null,
+            string fileName = null
         )
         {
             ResolutionSearchLocation considered = null;
@@ -122,7 +131,7 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
                 };
             }
 
-            if (FileMatchesAssemblyName(assemblyName, isPrimaryProjectReference, wantSpecificVersion, allowMismatchBetweenFusionNameAndFileName, fullPath, considered))
+            if (FileMatchesAssemblyName(assemblyName, isPrimaryProjectReference, wantSpecificVersion, allowMismatchBetweenFusionNameAndFileName, fullPath, considered, useDirectoryCache, directory, fileName))
             {
                 return true;
             }
@@ -142,6 +151,9 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
         /// <param name="allowMismatchBetweenFusionNameAndFileName">Whether to allow naming mismatch.</param>
         /// <param name="pathToCandidateAssembly">Path to a possible file.</param>
         /// <param name="searchLocation">Information about why the candidate file didn't match</param>
+        /// <param name="useDirectoryCache">Set it to true if file existence is verified by cached list of files in directory.</param>
+        /// <param name="directory">Directory of directory cache. Required if useDirectoryCache.</param>
+        /// <param name="fileName">Name of file in directory cache. Required if useDirectoryCache.</param>
         protected bool FileMatchesAssemblyName
         (
             AssemblyNameExtension assemblyName,
@@ -149,7 +161,10 @@ protected bool FileMatchesAssemblyName
             bool wantSpecificVersion,
             bool allowMismatchBetweenFusionNameAndFileName,
             string pathToCandidateAssembly,
-            ResolutionSearchLocation searchLocation
+            ResolutionSearchLocation searchLocation,
+            bool useDirectoryCache = false,
+            string directory = null,
+            string fileName = null
         )
         {
             if (searchLocation != null)
@@ -181,7 +196,27 @@ ResolutionSearchLocation searchLocation
 
             bool isSimpleAssemblyName = assemblyName?.IsSimpleName == true;
 
-            if (fileExists(pathToCandidateAssembly))
+            bool fileFound;
+            if (useDirectoryCache && Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave16_10))
+            {
+                // this verifies file existence using fileExistsInDirectory delegate which internally used cached set of all files in a particular directory
+                // if some cases it render better performance than one by one FileExists
+                try
+                {
+                    fileFound = fileExistsInDirectory(directory, fileName);
+                }
+                catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
+                {
+                    // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.
+                    throw new InvalidParameterValueException("SearchPaths", $"{directory.TrimEnd(Path.DirectorySeparatorChar)}{Path.DirectorySeparatorChar}{fileName}", e.Message);
+                }
+            }
+            else
+            {
+                fileFound = fileExists(pathToCandidateAssembly);
+            }
+
+            if (fileFound)
             {
                 // If the resolver we are using is targeting a given processor architecture then we must crack open the assembly and make sure the architecture is compatible
                 // We cannot do these simple name matches.
@@ -312,23 +347,25 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
             if (directory != null)
             {
                 string weakNameBase = assemblyName.Name;
+
                 foreach (string executableExtension in executableExtensions)
                 {
-                    string baseName = weakNameBase + executableExtension;
+                    string fileName = weakNameBase + executableExtension;
                     string fullPath;
 
                     try
                     {
-                        fullPath = Path.Combine(directory, baseName);
+                        fullPath = Path.Combine(directory, fileName);
                     }
                     catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                     {
                         // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.
-                        throw new InvalidParameterValueException("SearchPaths", directory + (directory.EndsWith("\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : "\\") + baseName, e.Message);
+                        throw new InvalidParameterValueException("SearchPaths", $"{directory.TrimEnd(Path.DirectorySeparatorChar)}{Path.DirectorySeparatorChar}{fileName}", e.Message);
                     }
 
-                    // We have a full path returned 
-                    if (ResolveAsFile(fullPath, assemblyName, isPrimaryProjectReference, wantSpecificVersion, false, assembliesConsideredAndRejected))
+                    // We have a full path returned
+                    if (ResolveAsFile(fullPath, assemblyName, isPrimaryProjectReference, wantSpecificVersion, false, assembliesConsideredAndRejected,
+                        useDirectoryCache: true, directory: directory, fileName: fileName))
                     {
                         if (candidateFullPath == null)
                         {
@@ -341,7 +378,7 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
                          * If targeting AMD64 / X86 / IA64 / ARM /NONE we will return the first assembly which has a matching processor architecture OR is an assembly with a processor architecture of MSIL or NONE
                          * 
                          * If targeting MSIL we will first look through all of the assemblies, if an MSIL assembly is found we will return that. If no MSIL assembly is found we will return 
-                         * the first assembly which matches reguardless of its processor architecture.
+                         * the first assembly which matches regardless of its processor architecture.
                          */
 
                         if (targetProcessorArchitecture == ProcessorArchitecture.MSIL)
@@ -378,7 +415,8 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
                                 string fullPath = Path.Combine(directory, weakNameBase);
                                 var extensionlessAssemblyName = new AssemblyNameExtension(weakNameBaseFileName);
 
-                                if (ResolveAsFile(fullPath, extensionlessAssemblyName, isPrimaryProjectReference, wantSpecificVersion, false, assembliesConsideredAndRejected))
+                                if (ResolveAsFile(fullPath, extensionlessAssemblyName, isPrimaryProjectReference, wantSpecificVersion, false, assembliesConsideredAndRejected,
+                                    useDirectoryCache: true, directory: directory, fileName: weakNameBase))
                                 {
                                     return fullPath;
                                 }
diff --git a/src/Tasks/CombineTargetFrameworkInfoProperties.cs b/src/Tasks/CombineTargetFrameworkInfoProperties.cs
new file mode 100644
index 00000000000..612f27d3b88
--- /dev/null
+++ b/src/Tasks/CombineTargetFrameworkInfoProperties.cs
@@ -0,0 +1,51 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Framework;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Xml.Linq;
+
+namespace Microsoft.Build.Tasks
+{
+    /// <summary>
+    /// Combines items that represent properties and values into an XML representation.
+    /// </summary>
+    public class CombineTargetFrameworkInfoProperties : TaskExtension
+    {
+        /// <summary>
+        /// The root element name to use for the generated XML string
+        /// </summary>
+        public string RootElementName { get; set; }
+
+        /// <summary>
+        /// Items to include in the XML.  The ItemSpec should be the property name, and it should have Value metadata for its value.
+        /// </summary>
+        public ITaskItem[] PropertiesAndValues { get; set; }
+
+        /// <summary>
+        /// The generated XML representation of the properties and values.
+        /// </summary>
+        [Output]
+        public string Result { get; set; }
+
+        public override bool Execute()
+        {
+            if (PropertiesAndValues != null)
+            {
+                XElement root = new XElement(RootElementName);
+
+                foreach (var item in PropertiesAndValues)
+                {
+                    root.Add(new XElement(item.ItemSpec, item.GetMetadata("Value")));
+                }
+
+                Result = root.ToString();
+            }
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
diff --git a/src/Tasks/CombineXmlElements.cs b/src/Tasks/CombineXmlElements.cs
new file mode 100644
index 00000000000..c42aed7f1bd
--- /dev/null
+++ b/src/Tasks/CombineXmlElements.cs
@@ -0,0 +1,52 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Framework;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Xml.Linq;
+
+namespace Microsoft.Build.Tasks
+{
+    /// <summary>
+    /// Combines multiple XML elements
+    /// </summary>
+    public class CombineXmlElements : TaskExtension
+    {
+        /// <summary>
+        /// The root element name to use for the generated XML string
+        /// </summary>
+        public string RootElementName { get; set; }
+
+        /// <summary>
+        /// The XML elements to include as children of the root element
+        /// </summary>
+        public ITaskItem [] XmlElements { get; set; }
+
+        /// <summary>
+        /// The generated XML
+        /// </summary>
+        [Output]
+        public string Result { get; set; }
+
+        public override bool Execute()
+        {
+            if (XmlElements != null)
+            {
+                XElement root = new XElement(RootElementName);
+
+                foreach (var item in XmlElements)
+                {
+                    root.Add(XElement.Parse(item.ItemSpec));
+                }
+
+                Result = root.ToString();
+            }
+
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
diff --git a/src/Tasks/InstalledSDKResolver.cs b/src/Tasks/InstalledSDKResolver.cs
index 427cc8c86eb..eb091a657f8 100644
--- a/src/Tasks/InstalledSDKResolver.cs
+++ b/src/Tasks/InstalledSDKResolver.cs
@@ -22,8 +22,8 @@ internal class InstalledSDKResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public InstalledSDKResolver(Dictionary<string, ITaskItem> resolvedSDKs, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
+        public InstalledSDKResolver(Dictionary<string, ITaskItem> resolvedSDKs, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
         {
             _resolvedSDKs = resolvedSDKs;
         }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 97daccd3aae..988843a2973 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -61,6 +61,8 @@
       <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="AssemblyDependency\AssemblyMetadata.cs" />
+    <Compile Include="CombineTargetFrameworkInfoProperties.cs" />
+    <Compile Include="CombineXmlElements.cs" />
     <Compile Include="ConvertToAbsolutePath.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -994,8 +996,6 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
     <PackageReference Include="System.CodeDom" />
     <PackageReference Include="System.Reflection.Metadata" />
-    <PackageReference Include="System.Reflection.TypeExtensions" />
-    <PackageReference Include="System.Runtime.InteropServices" />
     <PackageReference Include="System.Security.Cryptography.Pkcs" />
     <PackageReference Include="System.Security.Cryptography.Xml" />
     <PackageReference Include="System.Security.Permissions" />
diff --git a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
index f48855ce32f..a14d5b42df4 100644
--- a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
@@ -237,9 +237,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
           <AdditionalFiles Include="@(%(AdditionalFileItems.Identity))" />
         </ItemGroup>
         
-       <!-- Don't run analyzers for Csc task on XamlPrecompile pass, we only want to run them on core compile. -->
-       <!-- Analyzers="@(Analyzer)" -->
-
        <PropertyGroup Condition="'$(UseSharedCompilation)' == ''">
          <UseSharedCompilation>true</UseSharedCompilation>
        </PropertyGroup>
@@ -250,6 +247,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               AddModules="@(AddModules)"
               AdditionalFiles="@(AdditionalFiles)"
               AllowUnsafeBlocks="$(AllowUnsafeBlocks)"
+              Analyzers="@(Analyzer)"
               ApplicationConfiguration="$(AppConfigForCompiler)"
               BaseAddress="$(BaseAddress)"
               CheckForOverflowUnderflow="$(CheckForOverflowUnderflow)"
@@ -278,6 +276,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               NoLogo="$(NoLogo)"
               NoStandardLib="$(NoCompilerStandardLib)"
               NoWin32Manifest="$(NoWin32Manifest)"
+              Nullable="$(Nullable)"
               Optimize="$(Optimize)"
               OutputAssembly="@(XamlIntermediateAssembly)"
               PdbFile="$(PdbFile)" 
@@ -288,6 +287,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
               ReportAnalyzer="$(ReportAnalyzer)"
               Resources="@(_CoreCompileResourceInputs);@(CompiledLicenseFile)"
               ResponseFiles="$(CompilerResponseFile)"
+              SkipAnalyzers="$(_SkipAnalyzers)"
               Sources="@(Compile)"
               SubsystemVersion="$(SubsystemVersion)"
               TargetType="$(OutputType)"
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index c7023d3cca6..c5ce7a2d79e 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -26,12 +26,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <Error Condition="'$(IsCrossTargetingBuild)' != 'true'"
            Text="Internal MSBuild error: CrossTargeting GetTargetFrameworks target should only be used in cross targeting (outer) build" />
+
+    <CombineXmlElements
+      RootElementName="AdditionalProjectProperties"
+      XmlElements="@(_TargetFrameworkInfo->'%(AdditionalPropertiesFromProject)')">
+      <Output TaskParameter="Result"
+        PropertyName="_AdditionalPropertiesFromProject"/>
+    </CombineXmlElements>
     
     <ItemGroup>
       <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
         <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
         <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
         <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
+        <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>
 
         <HasSingleTargetFramework>false</HasSingleTargetFramework>
 
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 9e82022491e..18d7712ad5c 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1778,11 +1778,19 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <Error Condition="'$(IsCrossTargetingBuild)' == 'true'"
            Text="Internal MSBuild error: Non-CrossTargeting GetTargetFrameworks target should not be used in cross targeting (outer) build" />
 
+    <CombineXmlElements
+      RootElementName="AdditionalProjectProperties"
+      XmlElements="@(_TargetFrameworkInfo->'%(AdditionalPropertiesFromProject)')">
+      <Output TaskParameter="Result"
+        PropertyName="_AdditionalPropertiesFromProject"/>
+    </CombineXmlElements>
+    
     <ItemGroup>
       <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
         <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
         <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
         <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
+        <AdditionalPropertiesFromProject>$(_AdditionalPropertiesFromProject)</AdditionalPropertiesFromProject>
 
         <HasSingleTargetFramework>true</HasSingleTargetFramework>
 
@@ -1796,12 +1804,26 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Target Name="GetTargetFrameworksWithPlatformForSingleTargetFramework"
         Returns="@(_TargetFrameworkInfo)">
 
+    <ItemGroup>
+      <_AdditionalTargetFrameworkInfoPropertyWithValue Include="@(AdditionalTargetFrameworkInfoProperty)">
+        <Value>$(%(AdditionalTargetFrameworkInfoProperty.Identity))</Value>
+      </_AdditionalTargetFrameworkInfoPropertyWithValue>
+    </ItemGroup>
+
+    <CombineTargetFrameworkInfoProperties
+        RootElementName="$(TargetFramework)"
+        PropertiesAndValues="@(_AdditionalTargetFrameworkInfoPropertyWithValue)">
+      <Output TaskParameter="Result"
+              PropertyName="_AdditionalTargetFrameworkInfoProperties"/>
+    </CombineTargetFrameworkInfoProperties>
+
     <ItemGroup>
       <_TargetFrameworkInfo Include="$(TargetFramework)">
         <TargetFrameworks>$(TargetFramework)</TargetFrameworks>
         <TargetFrameworkMonikers>$(TargetFrameworkMoniker)</TargetFrameworkMonikers>
         <TargetPlatformMonikers>$(TargetPlatformMoniker)</TargetPlatformMonikers>
         <TargetPlatformMonikers Condition="'$(TargetPlatformMoniker)' == ''">None</TargetPlatformMonikers>
+        <AdditionalPropertiesFromProject>$(_AdditionalTargetFrameworkInfoProperties)</AdditionalPropertiesFromProject>
       </_TargetFrameworkInfo>
     </ItemGroup>
 
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index 9f7f4620cd2..a1eb793d5ee 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -95,6 +95,8 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.CallTarget"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.CombinePath"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.ConvertToAbsolutePath"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties"  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.CombineXmlElements"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.Copy"                                  AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.CreateCSharpManifestResourceName"      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.CreateItem"                            AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index fcf321c1beb..ee59ffb9b5e 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -732,7 +732,7 @@ private bool IsFiltered(ITaskItem item)
             {
                 if (identity?.IsInFramework(Constants.DotNetCoreIdentifier, null) == true)
                 {
-                    return true;
+                    return !GetItemCopyLocal(item);
                 }
             }
             else if (identity?.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion) == true)
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index b465dd10789..a054ea6c65a 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -2789,9 +2789,20 @@
     <value>MSB3936: Failed to open unzip file "{0}" to "{1}".  {2}</value>
     <comment>{StrBegin="MSB3936: "}</comment>
   </data>
+  <data name="Unzip.ErrorParsingPatternInvalidPath">
+    <value>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</value>
+    <comment>{StrBegin="MSB3937: "}</comment>
+  </data>
+  <data name="Unzip.ErrorParsingPatternPropertyReferences">
+    <value>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</value>
+    <comment>{StrBegin="MSB3938: "}</comment>
+  </data>
   <data name="Unzip.DidNotUnzipBecauseOfFileMatch">
     <value>Did not unzip from file "{0}" to file "{1}" because the "{2}" parameter was set to "{3}" in the project and the files' sizes and timestamps match.</value>
   </data>
+  <data name="Unzip.DidNotUnzipBecauseOfFilter">
+    <value>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</value>
+  </data>
   <data name="Unzip.FileComment">
     <value>Unzipping file "{0}" to "{1}".</value>
   </data>
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index d63041a77a8..c6ebbc2bf98 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Rozzipování ze souboru {0} do souboru {1} neproběhlo, protože parametr {2} byl v projektu nastaven na hodnotu {3} a velikosti souborů a časová razítka se shodují.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: Rozzipování do adresáře {0} se nepodařilo, protože ho nebylo možné vytvořit. {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: Soubor {0} se nepodařilo rozzipovat, protože neexistuje nebo není přístupný.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Soubor {0} se rozzipovává do {1}.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 6f55e8ffb7d..9d261b2b46f 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Die Datei "{0}" wurde nicht in die Datei "{1}" entzippt, weil der Parameter "{2}" im Projekt auf "{3}" festgelegt war und die Größen und Zeitstempel der Dateien übereinstimmen.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: Fehler beim Entzippen in das Verzeichnis "{0}", weil dieses nicht erstellt werden konnte.  {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: Die Datei "{0}" konnte nicht entzippt werden, weil sie nicht vorhanden ist oder nicht darauf zugegriffen werden kann.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Die Datei "{0}" wird in "{1}" entzippt.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.en.xlf b/src/Tasks/Resources/xlf/Strings.en.xlf
index 0c447b05ab3..df627557c4a 100644
--- a/src/Tasks/Resources/xlf/Strings.en.xlf
+++ b/src/Tasks/Resources/xlf/Strings.en.xlf
@@ -2530,6 +2530,11 @@
         <target state="new">Did not unzip from file "{0}" to file "{1}" because the "{2}" parameter was set to "{3}" in the project and the files' sizes and timestamps match.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="new">MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</target>
@@ -2560,6 +2565,16 @@
         <target state="new">MSB3932: Failed to unzip file "{0}" because the file does not exist or is inaccessible.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="new">Unzipping file "{0}" to "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 620929ddfe8..8a28657818f 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">No se descomprimió del archivo "{0}" en el archivo "{1}" porque el parámetro "{2}" se estableció como "{3}" en el proyecto y los tamaños y las marcas de tiempo de los archivos coinciden.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: No se pudo descomprimir en el directorio "{0}" porque no se pudo crear.  {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: No se pudo descomprimir el archivo "{0}" porque no existe o no se puede tener acceso a él.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Descomprimiendo el archivo "{0}" en "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 11359a59620..3854fcf0c19 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Impossible de décompresser le fichier "{0}" vers le fichier "{1}", car le paramètre "{2}" a la valeur "{3}" dans le projet, et les tailles et horodatages des fichiers correspondent.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: Échec de la décompression dans le répertoire "{0}", car il n'a pas pu être créé. {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: Échec de la décompression du fichier "{0}", car le fichier n'existe pas ou est inaccessible.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Décompression du fichier "{0}" dans "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 39b30cfbacb..14bdb0e8baf 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Non è stato possibile decomprimere il file "{0}" nel file "{1}". Il parametro "{2}" è stato impostato su "{3}" nel progetto e le dimensioni e il timestamp dei file corrispondono.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: non è stato possibile decomprimere nella directory "{0}" perché non è stato possibile crearla. {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: non è stato possibile decomprimere il file "{0}" perché non esiste oppure è inaccessibile.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Decompressione del file "{0}" in "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 8166fd4d2dd..a4b07fadb16 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">"{2}" パラメーターがプロジェクトで "{3}" に設定されているため、またファイルのサイズとタイムスタンプが一致するため、ファイル "{0}" からファイル "{1}" に解凍しませんでした。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: ディレクトリ "{0}" への解凍は、そのディレクトリを作成できなかったため、失敗しました。{1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: ファイルが存在しないか、アクセスできないため、ファイル "{0}" を解凍できませんでした。</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">ファイル "{0}" を "{1}" に解凍しています。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index dd566fd77b2..e801bdd91a6 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">"{2}" 매개 변수가 프로젝트에 "{3}"(으)로 설정되었고 파일 크기와 타임스탬프가 일치하기 때문에 "{0}" 파일에서 "{1}" 파일로 압축을 풀 수 없습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: "{0}" 디렉터리를 생성할 수 없기 때문에 이 디렉터리에 압축을 풀지 못했습니다.  {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: 파일이 존재하지 않거나 액세스할 수 없기 때문에 파일 "{0}"의 압축을 풀지 못했습니다.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">파일 "{0}"의 압축을 "{1}"에 푸는 중입니다.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index bf99b39d5ea..4251be9ff36 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Nie wykonano rozpakowywania z pliku „{0}” do pliku „{1}”, ponieważ parametr „{2}” w projekcie został ustawiony na wartość „{3}”, a rozmiary plików i sygnatury czasowe pasują do siebie.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: Nie można rozpakować do katalogu „{0}”, ponieważ nie można go utworzyć. {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: Nie można rozpakować pliku „{0}”, ponieważ plik nie istnieje lub jest niedostępny.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Rozpakowywanie pliku „{0}” do pliku „{1}”.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index dc823788e5c..1dfff7329b4 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Não foi possível descompactar o arquivo "{0}" para o arquivo "{1}", pois o parâmetro "{2}" foi definido como "{3}" no projeto, e os tamanhos de arquivos e os carimbos de data/hora não correspondem.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: Falha ao descompactar no diretório "{0}" porque ele não pôde ser criado. {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: Falha ao descompactar o arquivo "{0}" porque ele não existe ou está inacessível.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Descompactando o arquivo "{0}" em "{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 9e7588f33eb..9e883f29af7 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Не удалось выполнить распаковку из файла "{0}" в файл "{1}", так как для параметра "{2}" в проекте было задано значение "{3}", а размеры файлов и отметки времени совпадают.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: не удалось выполнить распаковку в каталог "{0}", так как создать его не удалось. {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: не удалось распаковать файл "{0}", так как он не существует или недоступен.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">Распаковка файла "{0}" в"{1}".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index f4e09678061..194e8b3f3e1 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">Projede "{2}" parametresi "{3}" olarak ayarlandığından ve dosya boyutlarıyla zaman damgaları eşleştiğinden "{0}" dosyasını "{1}" dosyasına çıkarma işlemi gerçekleştirilmedi.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: "{0}" dizini oluşturulamadığından bu dizine çıkarılamadı. {1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: Dosya mevcut olmadığından veya erişilebilir olmadığından "{0}" dosyasının sıkıştırması açılamadı.</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">"{0}" dosyasının sıkıştırması "{1}" hedefine açılıyor.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 37aa968f49b..44e2fce72d4 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">未从文件“{0}”解压缩到文件“{1}”，因为“{2}”参数在项目中设置为“{3}”，而两个文件的大小及时间戳一致。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: 未能解压缩到目录“{0}”，因为无法创建它。{1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: 未能解压缩文件“{0}”，因为该文件不存在或无法访问。</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">将文件“{0}”解压缩到“{1}”。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 2fa9517589f..a70ec8fb257 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -2480,6 +2480,11 @@
         <target state="translated">並未從檔案 "{0}" 解壓縮到檔案 "{1}"，因為在專案中的 "{2}" 參數原先設定為 "{3}"，且檔案的大小與時間戳記相符。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.DidNotUnzipBecauseOfFilter">
+        <source>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</source>
+        <target state="new">Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotCreateDestinationDirectory">
         <source>MSB3931: Failed to unzip to directory "{0}" because it could not be created.  {1}</source>
         <target state="translated">MSB3931: 因為無法建立目錄 "{0}"，所以無法解壓縮至該目錄。{1}</target>
@@ -2510,6 +2515,16 @@
         <target state="translated">MSB3932: 因為檔案不存在或無法存取，所以無法解壓縮檔案 "{0}"。</target>
         <note>{StrBegin="MSB3932: "}</note>
       </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternInvalidPath">
+        <source>MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</source>
+        <target state="new">MSB3937: Failed to parse pattern "{0}" because it contains an invalid path character.</target>
+        <note>{StrBegin="MSB3937: "}</note>
+      </trans-unit>
+      <trans-unit id="Unzip.ErrorParsingPatternPropertyReferences">
+        <source>MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</source>
+        <target state="new">MSB3938: Failed to parse pattern "{0}" because it contains a property reference which isn't supported.</target>
+        <note>{StrBegin="MSB3938: "}</note>
+      </trans-unit>
       <trans-unit id="Unzip.FileComment">
         <source>Unzipping file "{0}" to "{1}".</source>
         <target state="translated">正在將檔案 "{0}" 解壓縮到 "{1}"。</target>
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 1dd51c92c86..84c11a0b70e 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -8,6 +8,7 @@
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.IO;
+using System.Linq;
 using System.Runtime.Serialization;
 using System.Runtime.Versioning;
 using System.Security.Permissions;
@@ -54,6 +55,13 @@ internal sealed class SystemState : StateFileBase, ISerializable
         /// </summary>
         private Dictionary<string, string[]> instanceLocalDirectories = new Dictionary<string, string[]>(StringComparer.OrdinalIgnoreCase);
 
+        /// <summary>
+        /// List of all files in directory is also purely instance-local. This information
+        /// is only considered good for the lifetime of the task (or whatever) that owns 
+        /// this instance.
+        /// </summary>
+        private Dictionary<string, HashSet<string>> instanceLocalDirectoryFiles = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);
+
         /// <summary>
         /// Additional level of caching kept at the process level.
         /// </summary>
@@ -94,6 +102,11 @@ internal sealed class SystemState : StateFileBase, ISerializable
         /// </summary>
         private DirectoryExists directoryExists;
 
+        /// <summary>
+        /// Cached delegate.
+        /// </summary>
+        private DirectoryGetFiles getFiles;
+
         /// <summary>
         /// Cached delegate.
         /// </summary>
@@ -332,6 +345,12 @@ public DirectoryExists CacheDelegate(DirectoryExists directoryExistsValue)
             return DirectoryExists;
         }
 
+        public FileExistsInDirectory CacheDelegate(DirectoryGetFiles getFilesValue)
+        {
+            getFiles = getFilesValue;
+            return FileExistsInDirectory;
+        }
+
         /// <summary>
         /// Cache the results of a GetDirectories delegate. 
         /// </summary>
@@ -573,6 +592,42 @@ private string[] GetDirectories(string path, string pattern)
             return getDirectories(path, pattern);
         }
 
+        /// <summary>
+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.
+        /// It does not throw if directory does not exists.
+        /// </summary>
+        /// <param name="path"></param>
+        /// <param name="fileName"></param>
+        /// <returns>true if file exists</returns>
+        private bool FileExistsInDirectory(string path, string fileName)
+        {
+            // to behave same as File.Exists(Path.Combine("","file.cs") we have to map empty string to current directory
+            if (path.Length == 0)
+            {
+                path = ".";
+            }
+
+            instanceLocalDirectoryFiles.TryGetValue(path, out HashSet<string> cached);
+            if (cached == null)
+            {
+                string[] files;
+                try
+                {
+                    files = getFiles(path, "*");
+                }
+                catch (DirectoryNotFoundException)
+                {
+                    files = Array.Empty<string>();
+                }
+
+                cached = new HashSet<string>(files.Select(Path.GetFileName), StringComparer.OrdinalIgnoreCase);
+
+                instanceLocalDirectoryFiles[path] = cached;
+            }
+
+            return cached.Contains(fileName);
+        }
+
         /// <summary>
         /// Cached implementation of FileExists.
         /// </summary>
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index 401829e2f65..4e00a677831 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -1,14 +1,16 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using System;
 using System.IO;
 using System.IO.Compression;
 using System.Linq;
 using System.Threading;
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -27,6 +29,16 @@ public sealed class Unzip : TaskExtension, ICancelableTask
         /// </summary>
         private readonly CancellationTokenSource _cancellationToken = new CancellationTokenSource();
 
+        /// <summary>
+        /// Stores the include patterns after parsing.
+        /// </summary>
+        private string[] _includePatterns;
+
+        /// <summary>
+        /// Stores the exclude patterns after parsing.
+        /// </summary>
+        private string[] _excludePatterns;
+
         /// <summary>
         /// Gets or sets a <see cref="ITaskItem"/> with a destination folder path to unzip the files to.
         /// </summary>
@@ -49,6 +61,16 @@ public sealed class Unzip : TaskExtension, ICancelableTask
         [Required]
         public ITaskItem[] SourceFiles { get; set; }
 
+        /// <summary>
+        /// Gets or sets an MSBuild glob expression that will be used to determine which files to include being unzipped from the archive.
+        /// </summary>
+        public string Include { get; set; }
+
+        /// <summary>
+        /// Gets or sets an MSBuild glob expression that will be used to determine which files to exclude from being unzipped from the archive.
+        /// </summary>
+        public string Exclude { get; set; }
+
         /// <inheritdoc cref="ICancelableTask.Cancel"/>
         public void Cancel()
         {
@@ -74,41 +96,46 @@ public override bool Execute()
 
             try
             {
-                foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))
+                ParseIncludeExclude();
+
+                if (!Log.HasLoggedErrors)
                 {
-                    if (!FileSystems.Default.FileExists(sourceFile.ItemSpec))
+                    foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))
                     {
-                        Log.LogErrorWithCodeFromResources("Unzip.ErrorFileDoesNotExist", sourceFile.ItemSpec);
-                        continue;
-                    }
+                        if (!FileSystems.Default.FileExists(sourceFile.ItemSpec))
+                        {
+                            Log.LogErrorWithCodeFromResources("Unzip.ErrorFileDoesNotExist", sourceFile.ItemSpec);
+                            continue;
+                        }
 
-                    try
-                    {
-                        using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))
+                        try
                         {
-                            using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))
+                            using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))
                             {
-                                try
-                                {
-                                    Extract(zipArchive, destinationDirectory);
-                                }
-                                catch (Exception e)
+                                using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))
                                 {
-                                    // Unhandled exception in Extract() is a bug!
-                                    Log.LogErrorFromException(e, showStackTrace: true);
-                                    return false;
+                                    try
+                                    {
+                                        Extract(zipArchive, destinationDirectory);
+                                    }
+                                    catch (Exception e)
+                                    {
+                                        // Unhandled exception in Extract() is a bug!
+                                        Log.LogErrorFromException(e, showStackTrace: true);
+                                        return false;
+                                    }
                                 }
                             }
                         }
-                    }
-                    catch (OperationCanceledException)
-                    {
-                        break;
-                    }
-                    catch (Exception e)
-                    {
-                        // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)
-                        Log.LogErrorWithCodeFromResources("Unzip.ErrorCouldNotOpenFile", sourceFile.ItemSpec, e.Message);
+                        catch (OperationCanceledException)
+                        {
+                            break;
+                        }
+                        catch (Exception e)
+                        {
+                            // Should only be thrown if the archive could not be opened (Access denied, corrupt file, etc)
+                            Log.LogErrorWithCodeFromResources("Unzip.ErrorCouldNotOpenFile", sourceFile.ItemSpec, e.Message);
+                        }
                     }
                 }
             }
@@ -129,6 +156,12 @@ private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirector
         {
             foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_cancellationToken.IsCancellationRequested))
             {
+                if (ShouldSkipEntry(zipArchiveEntry))
+                {
+                    Log.LogMessageFromResources(MessageImportance.Low, "Unzip.DidNotUnzipBecauseOfFilter", zipArchiveEntry.FullName);
+                    continue;
+                }
+
                 FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));
 
                 // Zip archives can have directory entries listed explicitly.
@@ -199,6 +232,28 @@ private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirector
             }
         }
 
+        /// <summary>
+        /// Determines whether or not a file should be skipped when unzipping by filtering.
+        /// </summary>
+        /// <param name="zipArchiveEntry">The <see cref="ZipArchiveEntry"/> object containing information about the file in the zip archive.</param>
+        /// <returns><code>true</code> if the file should be skipped, otherwise <code>false</code>.</returns>
+        private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry)
+        {
+            bool result = false;
+
+            if (_includePatterns.Length > 0)
+            {
+                result = _includePatterns.All(pattern => !FileMatcher.IsMatch(FileMatcher.Normalize(zipArchiveEntry.FullName), pattern, true));
+            }
+
+            if (_excludePatterns.Length > 0)
+            {
+                result |= _excludePatterns.Any(pattern => FileMatcher.IsMatch(FileMatcher.Normalize(zipArchiveEntry.FullName), pattern, true));
+            }
+
+            return result;
+        }
+
         /// <summary>
         /// Determines whether or not a file should be skipped when unzipping.
         /// </summary>
@@ -212,5 +267,34 @@ private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry, FileInfo fileInfo)
                    && zipArchiveEntry.LastWriteTime == fileInfo.LastWriteTimeUtc
                    && zipArchiveEntry.Length == fileInfo.Length;
         }
+
+        private void ParseIncludeExclude()
+        {
+            ParsePattern(Include, out _includePatterns);
+            ParsePattern(Exclude, out _excludePatterns);
+        }
+
+        private void ParsePattern(string pattern, out string[] patterns)
+        {
+            patterns = Array.Empty<string>();
+            if (!string.IsNullOrWhiteSpace(pattern))
+            {
+                if (FileMatcher.HasPropertyOrItemReferences(pattern))
+                {
+                    // Supporting property references would require access to Expander which is unavailable in Microsoft.Build.Tasks
+                    Log.LogErrorWithCodeFromResources("Unzip.ErrorParsingPatternPropertyReferences", pattern);
+                }
+                else if (pattern.IndexOfAny(FileUtilities.InvalidPathChars) != -1)
+                {
+                    Log.LogErrorWithCodeFromResources("Unzip.ErrorParsingPatternInvalidPath", pattern);
+                }
+                else
+                {
+                    patterns = pattern.Contains(';')
+                                   ? pattern.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries).Select(FileMatcher.Normalize).ToArray()
+                                   : new[] { pattern };
+                }
+            }
+        }
     }
 }
diff --git a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
index b560f1b1455..2f3dd9cba5a 100644
--- a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
+++ b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
@@ -11,7 +11,6 @@
 
   <ItemGroup>
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.IO.FileSystem.Primitives" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
 
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index d8c69b18f9e..f683c61ca7d 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -679,22 +679,22 @@ public void ToolPathIsFoundWhenDirectoryExistsWithNameOfTool()
         [Fact]
         public void FindOnPathSucceeds()
         {
-            string expectedCmdPath;
+            string[] expectedCmdPath;
             string shellName;
             if (NativeMethodsShared.IsWindows)
             {
-                expectedCmdPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "cmd.exe");
+                expectedCmdPath = new[] { Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "cmd.exe") };
                 shellName = "cmd.exe";
             }
             else
             {
-                expectedCmdPath = "/bin/sh";
+                expectedCmdPath = new[] { "/bin/sh", "/usr/bin/sh" };
                 shellName = "sh";
             }
 
             string cmdPath = ToolTask.FindOnPath(shellName);
 
-            cmdPath.ShouldBe(expectedCmdPath, StringCompareShould.IgnoreCase);
+            cmdPath.ShouldBeOneOf(expectedCmdPath);
         }
 
         /// <summary>
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index 0a361a8cd7a..a2bb6693c41 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -30,7 +30,7 @@ public sealed class TaskItem :
 #if FEATURE_APPDOMAIN
         MarshalByRefObject,
 #endif
-        ITaskItem, ITaskItem2
+        ITaskItem2
     {
         #region Member Data
 
@@ -297,10 +297,25 @@ public void CopyMetadataTo(ITaskItem destinationItem)
 
             if (_metadata != null)
             {
-                // Avoid a copy if we can
-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem.Metadata == null)
+                if (destinationItem is TaskItem destinationAsTaskItem)
                 {
-                    destinationAsTaskItem.Metadata = _metadata.Clone(); // Copy on write!
+                    CopyOnWriteDictionary<string> copiedMetadata;
+                    // Avoid a copy if we can, and if not, minimize the number of items we have to set.
+                    if (destinationAsTaskItem.Metadata == null)
+                    {
+                        copiedMetadata = _metadata.Clone(); // Copy on write!
+                    }
+                    else if (destinationAsTaskItem.Metadata.Count < _metadata.Count)
+                    {
+                        copiedMetadata = _metadata.Clone(); // Copy on write!
+                        copiedMetadata.SetItems(destinationAsTaskItem.Metadata.Where(entry => !String.IsNullOrEmpty(entry.Value)));
+                    }
+                    else
+                    {
+                        copiedMetadata = destinationAsTaskItem.Metadata.Clone();
+                        copiedMetadata.SetItems(_metadata.Where(entry => !destinationAsTaskItem.Metadata.TryGetValue(entry.Key, out string val) || String.IsNullOrEmpty(val)));
+                    }
+                    destinationAsTaskItem.Metadata = copiedMetadata;
                 }
                 else
                 {
