diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index 43576fa5716..833150a1056 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -5,6 +5,10 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
+using System.Runtime.ConstrainedExecution;
+using System.Runtime.Serialization;
+using System.Text;
+
 using Microsoft.Build.Construction;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Shared;
@@ -723,12 +727,30 @@ public void ParseFirstProjectLineWhereProjectPathHasBackslash()
         internal static SolutionFile ParseSolutionHelper(string solutionFileContents)
         {
             solutionFileContents = solutionFileContents.Replace('\'', '"');
-            StreamReader sr = StreamHelpers.StringToStreamReader(solutionFileContents);
+
+#if FEATURE_ENCODING_DEFAULT
+            Encoding encoding = Encoding.Default;
+#else
+            Encoding encoding = Encoding.UTF8;
+#endif
+
+            MemoryStream stream = new();
+            StreamWriter writer = new(stream, encoding);
+
+            writer.Write(solutionFileContents);
+            writer.Flush();
+            stream.Seek(0, SeekOrigin.Begin);
+
+            ////StreamReader sr = StreamHelpers.StringToStreamReader(solutionFileContents);
 
             SolutionFile sp = new()
             {
                 SolutionFileDirectory = Path.GetTempPath(),
-                SolutionReader = sr,
+                SolutionReader = new(
+                    stream,
+                    encoding,
+                    byteBufferSize: 1024,
+                    charBufferSize: 1024),
                 FullPath = FileUtilities.GetTemporaryFileName(".sln")
             };
 
@@ -866,7 +888,8 @@ public void ParseSolutionFileWithDescriptionInformation()
         public void BasicSolution()
         {
             string solutionFileContents =
-                @"
+                """
+
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{F184B08F-C81C-45F6-A57F-5ABD9991F28F}') = 'ConsoleApplication1', 'ConsoleApplication1\ConsoleApplication1.vbproj', '{AB3413A6-D689-486D-B7F0-A095371B3F13}'
@@ -904,7 +927,7 @@ public void BasicSolution()
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
             SolutionFile solution = ParseSolutionHelper(solutionFileContents);
 
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index f7493839380..a79d6a757c1 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -19,7 +19,7 @@
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
-    <PackageReference Include="NuGet.Frameworks" >
+    <PackageReference Include="NuGet.Frameworks">
       <PrivateAssets>all</PrivateAssets>
     </PackageReference>
 
@@ -80,9 +80,6 @@
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\UnitTests\StreamHelpers.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\UnitTests\EngineTestEnvironment.cs">
       <Link>EngineTestEnvironment.cs</Link>
     </Compile>
diff --git a/src/Build.UnitTests/Utilities/StreamLineSpanReaderTests.cs b/src/Build.UnitTests/Utilities/StreamLineSpanReaderTests.cs
new file mode 100644
index 00000000000..920b5349547
--- /dev/null
+++ b/src/Build.UnitTests/Utilities/StreamLineSpanReaderTests.cs
@@ -0,0 +1,106 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.Text;
+
+using Xunit;
+
+namespace Microsoft.Build.Utilities;
+
+public class StreamLineSpanReaderTests
+{
+    [Fact]
+    public void Basics()
+    {
+        MemoryStream stream = new(Encoding.UTF8.GetBytes("Hello world!\nAnother string over here...\nAnd one last one"));
+        StreamLineSpanReader reader = new(stream, Encoding.UTF8, byteBufferSize: 10, charBufferSize: 100);
+
+        Assert.True(reader.TryReadLine(out ReadOnlySpan<char> line));
+        Assert.Equal("Hello world!", line.ToString());
+
+        Assert.True(reader.TryReadLine(out line));
+        Assert.Equal("Another string over here...", line.ToString());
+
+        Assert.True(reader.TryReadLine(out line));
+        Assert.Equal("And one last one", line.ToString());
+
+        Assert.False(reader.TryReadLine(out _));
+    }
+
+    [Fact]
+    public void LineExtendsBeyondEndOfCharBuffer()
+    {
+        MemoryStream stream = new(Encoding.UTF8.GetBytes("12345678901234567890\n12345678901234567890"));
+        StreamLineSpanReader reader = new(stream, Encoding.UTF8, byteBufferSize: 10, charBufferSize: 25);
+
+        Assert.True(reader.TryReadLine(out ReadOnlySpan<char> line));
+        Assert.Equal("12345678901234567890", line.ToString());
+
+        Assert.True(reader.TryReadLine(out line));
+        Assert.Equal("12345678901234567890", line.ToString());
+
+        Assert.False(reader.TryReadLine(out _));
+    }
+
+    [Fact]
+    public void LineLongerThanCharBuffer()
+    {
+        MemoryStream stream = new(Encoding.UTF8.GetBytes("12345678901234567890\n12345678901234567890"));
+        StreamLineSpanReader reader = new(stream, Encoding.UTF8, byteBufferSize: 10, charBufferSize: 10);
+
+        Assert.True(reader.TryReadLine(out ReadOnlySpan<char> line));
+        Assert.Equal("12345678901234567890", line.ToString());
+
+        Assert.True(reader.TryReadLine(out line));
+        Assert.Equal("12345678901234567890", line.ToString());
+
+        Assert.False(reader.TryReadLine(out _));
+    }
+
+    [Fact]
+    public void MixedNewlineCharacters()
+    {
+        MemoryStream stream = new(Encoding.UTF8.GetBytes("Abra\r\nCadabra\r\r\nBanana\n\nApple!"));
+        StreamLineSpanReader reader = new(stream, Encoding.UTF8, byteBufferSize: 10, charBufferSize: 10);
+
+        Assert.True(reader.TryReadLine(out ReadOnlySpan<char> line));
+        Assert.Equal("Abra", line.ToString());
+
+        Assert.True(reader.TryReadLine(out line));
+        Assert.Equal("Cadabra", line.ToString());
+
+        Assert.True(reader.TryReadLine(out line));
+        Assert.Equal("Banana", line.ToString());
+
+        Assert.True(reader.TryReadLine(out line));
+        Assert.Equal("", line.ToString());
+
+        Assert.True(reader.TryReadLine(out line));
+        Assert.Equal("Apple!", line.ToString());
+
+        Assert.False(reader.TryReadLine(out _));
+    }
+
+    [Fact]
+    public void NonLatin()
+    {
+        MemoryStream stream = new(Encoding.UTF8.GetBytes("걱정도 추억과 자랑처럼 아름다운 벌레는 강아지, 너무나 노새, 거외다.\n\n하나 잔디가 불러 이네들은 하나에 당신은 까닭입니다.\n"));
+        StreamLineSpanReader reader = new(stream, Encoding.UTF8, byteBufferSize: 10, charBufferSize: 10);
+
+        Assert.True(reader.TryReadLine(out ReadOnlySpan<char> line));
+        Assert.Equal("걱정도 추억과 자랑처럼 아름다운 벌레는 강아지, 너무나 노새, 거외다.", line.ToString());
+
+        Assert.True(reader.TryReadLine(out line));
+        Assert.Equal("", line.ToString());
+
+        Assert.True(reader.TryReadLine(out line));
+        Assert.Equal("하나 잔디가 불러 이네들은 하나에 당신은 까닭입니다.", line.ToString());
+
+        Assert.True(reader.TryReadLine(out line));
+        Assert.Equal("", line.ToString());
+
+        Assert.False(reader.TryReadLine(out _));
+    }
+}
diff --git a/src/Build.UnitTests/Utilities/StringPoolTests.cs b/src/Build.UnitTests/Utilities/StringPoolTests.cs
new file mode 100644
index 00000000000..0a95c91355e
--- /dev/null
+++ b/src/Build.UnitTests/Utilities/StringPoolTests.cs
@@ -0,0 +1,117 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+using Xunit;
+
+namespace Microsoft.Build.Utilities;
+
+public class StringPoolTests
+{
+    [Fact]
+    public void BasicUsage()
+    {
+        StringPool pool = new();
+
+        string str = "Hello, Hello!";
+
+        ReadOnlySpan<char> span1 = str.AsSpan().Slice(0, 5);
+        ReadOnlySpan<char> span2 = str.AsSpan().Slice(7, 5);
+
+        Assert.Equal("Hello", span1.ToString());
+        Assert.Equal("Hello", span2.ToString());
+
+        string result1 = pool.Intern(span1);
+        string result2 = pool.Intern(span2);
+
+        Assert.Equal("Hello", result1);
+        Assert.Equal("Hello", result2);
+
+        Assert.Same(result1, result2);
+    }
+
+    [Fact]
+    public void EmptyString()
+    {
+        StringPool pool = new();
+
+        Assert.Equal("", pool.Intern("hello".AsSpan().Slice(0, 0)));
+        Assert.Equal("", pool.Intern("hello".AsSpan().Slice(1, 0)));
+    }
+
+    [Fact]
+    public void InternalEquals()
+    {
+        Assert.True(StringPool.InternalEquals("Help", "ZHelpZ".AsSpan().Slice(1, 4)));
+        Assert.True(StringPool.InternalEquals("Help", "HelpZ".AsSpan().Slice(0, 4)));
+        Assert.True(StringPool.InternalEquals("Help", "ZHelp".AsSpan().Slice(1, 4)));
+
+        Assert.True(StringPool.InternalEquals("Hello!", "ZHello!Z".AsSpan().Slice(1, 6)));
+        Assert.True(StringPool.InternalEquals("Hello!!", "ZHello!!Z".AsSpan().Slice(1, 7)));
+        Assert.True(StringPool.InternalEquals("Hello", "ZHelloZ".AsSpan().Slice(1, 5)));
+
+        Assert.False(StringPool.InternalEquals("Hello", "Hello".AsSpan().Slice(0, 4)));
+        Assert.False(StringPool.InternalEquals("Hello", "HELLO".AsSpan().Slice(0, 5)));
+        Assert.False(StringPool.InternalEquals("Hello", "ZHell0Z".AsSpan().Slice(1, 5)));
+        Assert.False(StringPool.InternalEquals("Hello", "ZHel1oZ".AsSpan().Slice(1, 5)));
+
+        const string str = "ABCDEFGHIJKLMNOP";
+
+        //// Because our implementation does some loop unrolling, it's good to test a variety of lengths
+        //// and starting offsets.
+
+        for (int start = 0; start <= str.Length; start++)
+        {
+            for (int length = 0; length <= str.Length - start; length++)
+            {
+                Assert.True(
+                    StringPool.InternalEquals(
+                        str.Substring(start, length),
+                        str.AsSpan().Slice(start, length)),
+                    $"Different hash codes at start={start}, length={length}");
+            }
+        }
+    }
+
+    [Fact]
+    public void InternalGetHashCode()
+    {
+        Assert.Equal(0, StringPool.InternalGetHashCode(ReadOnlySpan<char>.Empty));
+
+        ReadOnlySpan<char> span = "Hello, Hello!".AsSpan();
+
+        for (int length = 0; length <= 5; length++)
+        {
+            if (StringPool.InternalGetHashCode(span.Slice(0, length)) !=
+                StringPool.InternalGetHashCode(span.Slice(7, length)))
+            {
+                Assert.True(false, $"Different hash codes at length={length}");
+            }
+        }
+
+        Assert.NotEqual(
+            StringPool.InternalGetHashCode(span.Slice(0, 5)),
+            StringPool.InternalGetHashCode(span.Slice(0, 4)));
+        Assert.NotEqual(
+            StringPool.InternalGetHashCode(span.Slice(0, 5)),
+            StringPool.InternalGetHashCode(span.Slice(1, 5)));
+
+        //// Because our implementation does some loop unrolling, it's good to test a variety of lengths
+        //// and starting offsets.
+
+        const string str = "ABCDEFGHIJKLMNOP";
+
+        for (int start = 0; start <= str.Length; start++)
+        {
+            for (int length = 0; length <= str.Length - start; length++)
+            {
+                if (StringPool.InternalGetHashCode(str.Substring(start, length).AsSpan()) !=
+                    StringPool.InternalGetHashCode(str.AsSpan().Slice(start, length)))
+                {
+                    Assert.True(false, $"Different hash codes at start={start}, length={length}");
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 0c1b9334958..8bc57ca3285 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -4,17 +4,16 @@
 using System;
 using System.Collections.Generic;
 using System.Collections.ObjectModel;
-using System.Globalization;
 using System.IO;
 using System.Runtime.InteropServices;
 using System.Security;
 using System.Text;
 using System.Text.Json;
 using System.Xml;
-
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Utilities;
 
 using BuildEventFileInfo = Microsoft.Build.Shared.BuildEventFileInfo;
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
@@ -164,7 +163,6 @@ internal SolutionFile()
         /// This is the read/write accessor for the solution file which we will parse.  This
         /// must be set before calling any other methods on this class.
         /// </summary>
-        /// <value></value>
         internal string FullPath
         {
             get => _solutionFile;
@@ -192,18 +190,11 @@ internal string FullPath
             }
         }
 
-        internal string SolutionFileDirectory
-        {
-            get;
-            // This setter is only used by the unit tests
-            set;
-        }
+        // Setter only used by the unit tests
+        internal string SolutionFileDirectory { get; set; }
 
-        /// <summary>
-        /// For unit-testing only.
-        /// </summary>
-        /// <value></value>
-        internal StreamReader SolutionReader { get; set; }
+        // Setter only used by the unit tests
+        internal StreamLineSpanReader SolutionReader { get; set; }
 
         /// <summary>
         /// The list of all full solution configurations (configuration + platform) in this solution
@@ -429,16 +420,16 @@ internal void AddSolutionConfiguration(string configurationName, string platform
 
         private bool TryReadLine(out ReadOnlySpan<char> span)
         {
-            string line = SolutionReader.ReadLine();
-
-            if (line is null)
+            // TODO avoid TextReader.ReadLine as it will always allocate a string. instead, use Decoder.Convert
+            // with shared byte[] and char[] buffers, then put a span on top of them. can do this in an efficient
+            // manner.
+            if (SolutionReader.TryReadLine(out span))
             {
-                span = default;
-                return false;
+                span = span.Trim();
+                return true;
             }
 
-            span = line.AsSpan().Trim();
-            return true;
+            return false;
         }
 
         /// <summary>
@@ -462,25 +453,25 @@ internal void ParseSolutionFile()
             ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(_solutionFile), "ParseSolutionFile() got a null solution file!");
             ErrorUtilities.VerifyThrowInternalRooted(_solutionFile);
 
-            FileStream fileStream = null;
             SolutionReader = null;
 
             try
             {
-                // Open the file
-                fileStream = File.OpenRead(_solutionFile);
-                SolutionReader = new StreamReader(fileStream, Encoding.GetEncoding(0)); // HIGHCHAR: If solution files have no byte-order marks, then assume ANSI rather than ASCII.
+                // Open the file.
+                using FileStream fileStream = File.OpenRead(_solutionFile);
+
+                SolutionReader = new StreamLineSpanReader(
+                    fileStream,
+                    Encoding.GetEncoding(0), // HIGHCHAR: If solution files have no byte-order marks, then assume ANSI rather than ASCII.
+                    byteBufferSize: 1024,
+                    charBufferSize: 1024);
+
                 ParseSolution();
             }
             catch (Exception e) when (ExceptionUtilities.IsIoRelatedException(e))
             {
                 ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(_solutionFile), "InvalidProjectFile", e.Message);
             }
-            finally
-            {
-                fileStream?.Dispose();
-                SolutionReader?.Dispose();
-            }
         }
 
         /// <summary>
@@ -499,7 +490,7 @@ internal void ParseSolution()
             _defaultPlatformName = null;
 
             // the raw list of project configurations in solution configurations, to be processed after it's fully read in.
-            Dictionary<string, string> rawProjectConfigurationsEntries = null;
+            Dictionary<ProjectConfigurationKey, string> rawProjectConfigurationsEntries = null;
 
             ParseFileHeader();
 
@@ -1255,6 +1246,7 @@ internal static bool TryParseFirstProjectLine(ReadOnlySpan<char> line, out strin
             //// Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build", "src\Build\Microsoft.Build.csproj", "{69BE05E2-CBDA-4D27-9733-44E12B0F5627}"
 
             if (!TrySkip(ref line, "Project(") ||
+                // TODO use pool here
                 !TryReadQuotedString(ref line, out projectTypeGuid) ||
                 !TrySkip(ref line, ")") ||
                 !TrySkipDelimiter(ref line, '=') ||
@@ -1262,6 +1254,7 @@ internal static bool TryParseFirstProjectLine(ReadOnlySpan<char> line, out strin
                 !TrySkipDelimiter(ref line, ',') ||
                 !TryReadQuotedString(ref line, out relativePath) ||
                 !TrySkipDelimiter(ref line, ',') ||
+                // TODO use pool here
                 !TryReadQuotedString(ref line, out projectGuid) ||
                 !line.IsEmpty)
             {
@@ -1440,6 +1433,7 @@ internal void ParseNestedProjects()
                         "SolutionParseNestedProjectError");
                 }
 
+                // TODO use pool here
                 string projectGuid = propertyName.ToString();
                 string parentProjectGuid = propertyValue.ToString();
 
@@ -1513,7 +1507,7 @@ internal void ParseSolutionConfigurations()
                         line.ToString());
                 }
 
-                var (configuration, platform) = ParseConfigurationName(name, FullPath, _currentLineNumber, line);
+                (string configuration, string platform) = ParseConfigurationName(name, FullPath, _currentLineNumber, line);
 
                 _solutionConfigurations.Add(new SolutionConfigurationInSolution(configuration, platform));
             }
@@ -1530,9 +1524,40 @@ internal static (string Configuration, string Platform) ParseConfigurationName(R
                     containingString.ToString());
             }
 
+            // TODO use pool here
             return (configuration.ToString(), platform.ToString());
         }
 
+        internal readonly struct ProjectConfigurationKey : IEquatable<ProjectConfigurationKey>
+        {
+            public string ProjectGuid { get; }
+
+            public string Suffix { get; }
+
+            public ProjectConfigurationKey(string projectGuid, string suffix)
+            {
+                ProjectGuid = projectGuid;
+                Suffix = suffix;
+            }
+
+            public override int GetHashCode()
+            {
+                return StringComparer.OrdinalIgnoreCase.GetHashCode(ProjectGuid)
+                     ^ StringComparer.Ordinal.GetHashCode(Suffix);
+            }
+
+            public bool Equals(ProjectConfigurationKey other)
+            {
+                return
+                    string.Equals(ProjectGuid, other.ProjectGuid, StringComparison.OrdinalIgnoreCase) &&
+                    string.Equals(Suffix, other.Suffix, StringComparison.Ordinal);
+            }
+
+            public override bool Equals(object obj) => obj is ProjectConfigurationKey key && Equals(key);
+
+            public override string ToString() => $"{ProjectGuid}.{Suffix}";
+        }
+
         /// <summary>
         /// Read project configurations in solution configurations section.
         /// </summary>
@@ -1554,9 +1579,12 @@ internal static (string Configuration, string Platform) ParseConfigurationName(R
         /// </code>
         /// </remarks>
         /// <returns>An unprocessed dictionary of entries in this section.</returns>
-        internal Dictionary<string, string> ParseProjectConfigurations()
+        internal Dictionary<ProjectConfigurationKey, string> ParseProjectConfigurations()
         {
-            Dictionary<string, string> rawProjectConfigurationsEntries = new(StringComparer.OrdinalIgnoreCase);
+            Dictionary<ProjectConfigurationKey, string> rawProjectConfigurationsEntries = new();
+
+            // TODO use pool in other places too, during parsing?
+            StringPool pool = new();
 
             while (TryReadLine(out ReadOnlySpan<char> line))
             {
@@ -1580,7 +1608,15 @@ internal Dictionary<string, string> ParseProjectConfigurations()
                         line.ToString());
                 }
 
-                rawProjectConfigurationsEntries[name.ToString()] = value.ToString();
+                int periodIndex = name.IndexOf('.');
+
+                if (periodIndex != -1)
+                {
+                    ReadOnlySpan<char> guid = name.Slice(0, periodIndex);
+                    ReadOnlySpan<char> suffix = name.Slice(periodIndex + 1);
+
+                    rawProjectConfigurationsEntries[new(pool.Intern(guid), pool.Intern(suffix))] = value.ToString();
+                }
             }
 
             return rawProjectConfigurationsEntries;
@@ -1591,7 +1627,7 @@ internal Dictionary<string, string> ParseProjectConfigurations()
         /// solution section data. 
         /// </summary>
         /// <param name="rawProjectConfigurationsEntries">Cached data from the project configuration section</param>
-        internal void ProcessProjectConfigurationSection(Dictionary<string, string> rawProjectConfigurationsEntries)
+        internal void ProcessProjectConfigurationSection(Dictionary<ProjectConfigurationKey, string> rawProjectConfigurationsEntries)
         {
             // Instead of parsing the data line by line, we parse it project by project, constructing the 
             // entry name (e.g. "{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Release|Any CPU.ActiveCfg") and retrieving its 
@@ -1609,16 +1645,18 @@ internal void ProcessProjectConfigurationSection(Dictionary<string, string> rawP
                     {
                         // The "ActiveCfg" entry defines the active project configuration in the given solution configuration
                         // This entry must be present for every possible solution configuration/project combination.
-                        string entryNameActiveConfig = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.ActiveCfg", project.ProjectGuid, solutionConfiguration.FullName);
+                        ProjectConfigurationKey activeConfigKey = new(project.ProjectGuid, $"{solutionConfiguration.FullName}.ActiveCfg");
+                        ////string entryNameActiveConfig = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.ActiveCfg", project.ProjectGuid, solutionConfiguration.FullName);
 
                         // The "Build.0" entry tells us whether to build the project configuration in the given solution configuration.
                         // Technically, it specifies a configuration name of its own which seems to be a remnant of an initial,
                         // more flexible design of solution configurations (as well as the '.0' suffix - no higher values are ever used).
                         // The configuration name is not used, and the whole entry means "build the project configuration"
                         // if it's present in the solution file, and "don't build" if it's not.
-                        string entryNameBuild = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.Build.0", project.ProjectGuid, solutionConfiguration.FullName);
+                        ////string entryNameBuild = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.Build.0", project.ProjectGuid, solutionConfiguration.FullName);
+                        ProjectConfigurationKey buildKey = new(project.ProjectGuid, $"{solutionConfiguration.FullName}.Build.0");
 
-                        if (rawProjectConfigurationsEntries.TryGetValue(entryNameActiveConfig, out string configurationPlatform))
+                        if (rawProjectConfigurationsEntries.TryGetValue(activeConfigKey, out string configurationPlatform))
                         {
                             // Project configuration may not necessarily contain the platform part. Some projects support only the configuration part.
                             if (!TryParseConfigurationPlatform(configurationPlatform.AsSpan(), isPlatformRequired: false, out ReadOnlySpan<char> configuration, out ReadOnlySpan<char> platform))
@@ -1627,13 +1665,13 @@ internal void ProcessProjectConfigurationSection(Dictionary<string, string> rawP
                                     "SubCategoryForSolutionParsingErrors",
                                     new BuildEventFileInfo(FullPath),
                                     "SolutionParseInvalidProjectSolutionConfigurationEntry",
-                                    $"{entryNameActiveConfig} = {configurationPlatform}");
+                                    $"{activeConfigKey} = {configurationPlatform}");
                             }
 
-                            var projectConfiguration = new ProjectConfigurationInSolution(
+                            ProjectConfigurationInSolution projectConfiguration = new(
                                 configuration.ToString(),
                                 platform.ToString(),
-                                rawProjectConfigurationsEntries.ContainsKey(entryNameBuild));
+                                includeInBuild: rawProjectConfigurationsEntries.ContainsKey(buildKey));
 
                             project.SetProjectConfiguration(solutionConfiguration.FullName, projectConfiguration);
                         }
@@ -1717,8 +1755,6 @@ public string GetDefaultPlatformName()
         /// This method takes a string representing one of the project's unique names (guid), and
         /// returns the corresponding "friendly" name for this project.
         /// </summary>
-        /// <param name="projectGuid"></param>
-        /// <returns></returns>
         internal string GetProjectUniqueNameByGuid(string projectGuid)
         {
             if (_projects.TryGetValue(projectGuid, out ProjectInSolution proj))
@@ -1733,8 +1769,6 @@ internal string GetProjectUniqueNameByGuid(string projectGuid)
         /// This method takes a string representing one of the project's unique names (guid), and
         /// returns the corresponding relative path to this project.
         /// </summary>
-        /// <param name="projectGuid"></param>
-        /// <returns></returns>
         internal string GetProjectRelativePathByGuid(string projectGuid)
         {
             if (_projects.TryGetValue(projectGuid, out ProjectInSolution proj))
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 6e6725c439d..f758cdb62fc 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -160,6 +160,8 @@
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
+    <Compile Include="Utilities\StringPool.cs" />
+    <Compile Include="Utilities\StreamLineSpanReader.cs" />
     <Compile Include="Evaluation\IItemTypeDefinition.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
diff --git a/src/Build/Utilities/StreamLineSpanReader.cs b/src/Build/Utilities/StreamLineSpanReader.cs
new file mode 100644
index 00000000000..4356957f19c
--- /dev/null
+++ b/src/Build/Utilities/StreamLineSpanReader.cs
@@ -0,0 +1,146 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.Text;
+
+namespace Microsoft.Build.Utilities;
+
+/// <summary>
+/// Reads lines of text from a <see cref="Stream"/> into <see cref="ReadOnlySpan{T}"/>s for further processing.
+/// Allows efficient, low-allocation consumption of textual data from a stream.
+/// </summary>
+internal sealed class StreamLineSpanReader
+{
+    private readonly Stream _stream;
+    private readonly Decoder _decoder;
+    private readonly byte[] _bytes;
+    private char[] _chars;
+
+    private int _byteOffset;
+    private int _bytesUntil;
+    private int _charOffset;
+    private int _lineStartOffset;
+
+    public StreamLineSpanReader(Stream stream, Encoding encoding, int byteBufferSize, int charBufferSize)
+    {
+        _stream = stream;
+        _decoder = encoding.GetDecoder();
+        _bytes = new byte[byteBufferSize];
+        _chars = new char[charBufferSize];
+    }
+
+    /// <summary>
+    /// Attempts to produce the next line of text from the stream.
+    /// </summary>
+    /// <remarks>
+    /// For performance, the reader internally shares a single character buffer, which <paramref name="line"/>
+    /// is backed by. This means that <paramref name="line"/> is only valid until the next call to this method,
+    /// after which the previous <paramref name="line"/> value will be in an undefined state.
+    /// </remarks>
+    /// <param name="line">The line of text that was just read. Must be consumed before the next call to this method.</param>
+    /// <returns>
+    /// <see langword="true"/> if a line was successfully retrieved, or <see langword="false"/> if the end of
+    /// the file has been reached.
+    /// </returns>
+    public bool TryReadLine(out ReadOnlySpan<char> line)
+    {
+        // This algorithm is juggling a few stores of data:
+        //
+        // - The stream, from which incoming bytes are sourced.
+        // - The byte array, via which incoming bytes are materialized in linear form.
+        // - The char array, into which bytes are decoded and from which we produce spans representing full lines of text.
+
+        do
+        {
+            if (_byteOffset == _bytesUntil)
+            {
+                // We have consumed all bytes from the byte buffer.
+                // Reset the offset.
+                _byteOffset = 0;
+
+                // Attempt to fill the byte buffer from the stream.
+                _bytesUntil = _stream.Read(_bytes, 0, _bytes.Length);
+            }
+
+            bool completed = false;
+
+            while (!completed)
+            {
+                UpdateCharBufferIfNecessary();
+
+                _decoder.Convert(
+                    bytes: _bytes,
+                    byteIndex: _byteOffset,
+                    byteCount: _bytesUntil - _byteOffset,
+                    chars: _chars,
+                    charIndex: _charOffset,
+                    charCount: _chars.Length - _charOffset,
+                    flush: _bytesUntil == 0, // If no more input bytes, flush decoder's internal buffer.
+                    out int bytesUsed,
+                    out int charsUsed,
+                    out completed);
+
+                _byteOffset += bytesUsed;
+                _charOffset += charsUsed;
+
+                if (completed && _bytesUntil == 0 && bytesUsed == 0 && charsUsed == 0 && _lineStartOffset == _charOffset + 1)
+                {
+                    // We have no more data.
+                    line = default;
+                    return false;
+                }
+
+                // Check whether we've found a full line of text yet.
+                int lineEndOffset = Array.IndexOf(_chars, '\n', _lineStartOffset, _charOffset - _lineStartOffset);
+
+                if (lineEndOffset == -1 && completed && _bytesUntil == 0)
+                {
+                    // We read the last line
+                    lineEndOffset = _charOffset;
+                }
+
+                if (lineEndOffset != -1)
+                {
+                    // We found a line!
+                    line = _chars.AsSpan().Slice(_lineStartOffset, lineEndOffset - _lineStartOffset);
+                    line = line.Trim('\r');
+
+                    // Prepare for the next line.
+                    _lineStartOffset = lineEndOffset + 1;
+
+                    return true;
+                }
+            }
+        }
+        while (_bytesUntil != 0);
+
+        // We have no more data.
+        line = default;
+        return false;
+
+        void UpdateCharBufferIfNecessary()
+        {
+            if (_charOffset == _chars.Length)
+            {
+                // We hit the end of the character buffer.
+                if (_lineStartOffset == 0)
+                {
+                    // There's no more room at the start of the buffer.
+                    // Grow the buffer.
+                    char[] larger = new char[_chars.Length * 2];
+                    Array.Copy(_chars, larger, _chars.Length);
+                    _chars = larger;
+                }
+                else
+                {
+                    // There's room at the start of the buffer, so move pending characters earlier.
+                    Array.Copy(_chars, _lineStartOffset, _chars, 0, _charOffset - _lineStartOffset);
+                    _charOffset -= _lineStartOffset;
+                    _lineStartOffset = 0;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Utilities/StringPool.cs b/src/Build/Utilities/StringPool.cs
new file mode 100644
index 00000000000..a2f0840f570
--- /dev/null
+++ b/src/Build/Utilities/StringPool.cs
@@ -0,0 +1,294 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Utilities;
+
+/// <summary>
+/// Facilitates pooling of strings constructed from <c>ReadOnlySpan&lt;char&gt;</c> values,
+/// providing zero-allocation lookup for strings that have been seen before.
+/// </summary>
+/// <remarks>
+/// Uses ordinal string comparison.
+/// </remarks>
+internal sealed class StringPool
+{
+    private int[]? _buckets;
+    private Slot[]? _slots;
+    private int _count;
+
+    /// <summary>
+    /// Returns a string containing the content of <paramref name="span"/>.
+    /// If this <see cref="StringPool"/> has seen such a string before,
+    /// the previously returned instance is returned again. Otherwise, a string
+    /// representing the character span is constructed and cached for future usage.
+    /// </summary>
+    /// <remarks>
+    /// Not thread safe.
+    /// </remarks>
+    /// <param name="span">The span of characters to return a string for.</param>
+    /// <returns>A string containing the characters in <paramref name="span"/>, from an internal cache of strings where possible.</returns>
+    public string Intern(ReadOnlySpan<char> span)
+    {
+        if (_buckets is null)
+        {
+            const int initialSize = 3; // must be prime
+            _buckets = new int[initialSize];
+            _slots = new Slot[initialSize];
+        }
+
+        int hashCode = InternalGetHashCode(span);
+
+        int bucketIndex = hashCode % _buckets.Length;
+
+        // Search for an existing entry.
+        for (int probeIndex = _buckets[hashCode % _buckets.Length] - 1; probeIndex >= 0;)
+        {
+            ref Slot slot = ref _slots![probeIndex];
+
+            if (slot.HashCode == hashCode && InternalEquals(slot.Value, span))
+            {
+                // Found a match! Return it.
+                return slot.Value;
+            }
+
+            // Follow the chain to find the next item.
+            probeIndex = slot.Next;
+        }
+
+        // We will add a new entry.
+        // Resize our storage if needed.
+        if (_count == _slots!.Length)
+        {
+            IncreaseCapacity();
+            bucketIndex = hashCode % _buckets.Length;
+        }
+
+        // Add the new entry in the last slot.
+        int slotIndex = _count++;
+
+        // Materialize a string for the span.
+        string str = span.ToString();
+
+        // Store the string.
+        _slots[slotIndex].HashCode = hashCode;
+        _slots[slotIndex].Value = str;
+        _slots[slotIndex].Next = _buckets[bucketIndex] - 1;
+        _buckets[bucketIndex] = slotIndex + 1;
+
+        // Return the newly created string.
+        return str;
+
+        void IncreaseCapacity()
+        {
+            int newSize = HashHelpers.ExpandPrime(_count);
+
+            if (newSize <= _count)
+            {
+                throw new OverflowException("StringPool size overflowed.");
+            }
+
+            Slot[] newSlots = new Slot[newSize];
+
+            if (_slots != null)
+            {
+                Array.Copy(_slots, 0, newSlots, 0, _count);
+            }
+
+            int[] newBuckets = new int[newSize];
+
+            for (int i = 0; i < _count; i++)
+            {
+                int num = newSlots[i].HashCode % newSize;
+                newSlots[i].Next = newBuckets[num] - 1;
+                newBuckets[num] = i + 1;
+            }
+
+            _slots = newSlots;
+            _buckets = newBuckets;
+        }
+    }
+
+    /// <summary>
+    /// Determines whether the provided string has equivalent content to the characters
+    /// in the provided span, using ordinal comparison.
+    /// </summary>
+    internal static unsafe bool InternalEquals(string str, ReadOnlySpan<char> span)
+    {
+        if (str.Length != span.Length)
+        {
+            return false;
+        }
+
+        // Walk both the string and the span
+        fixed (char* pStr0 = str)
+        {
+            fixed (char* pSpan0 = span)
+            {
+                // Reinterpret the characters (int16) as int (int32) so that we can
+                // compare two at a time per operation, for performance.
+                int* pStr = (int*)pStr0;
+                int* pSpan = (int*)pSpan0;
+
+                int charactersRemaining;
+
+                // Walk through the string, checking four characters at a time (two ints).
+                for (charactersRemaining = span.Length; charactersRemaining >= 4; charactersRemaining -= 4)
+                {
+                    if (*pStr != *pSpan || pStr[1] != pSpan[1])
+                    {
+                        return false;
+                    }
+
+                    pStr += 2;
+                    pSpan += 2;
+                }
+
+                if (charactersRemaining > 1)
+                {
+                    // There are at least two characters remaining, so use our int pointers again.
+                    if (*pStr != *pSpan)
+                    {
+                        return false;
+                    }
+
+                    charactersRemaining -= 2;
+                }
+
+                if (charactersRemaining == 1)
+                {
+                    // Check the last character in the string
+                    int lastCharacterIndex = str.Length - 1;
+                    if (pStr0[lastCharacterIndex] != pSpan0[lastCharacterIndex])
+                    {
+                        return false;
+                    }
+                }
+            }
+        }
+
+        return true;
+    }
+
+    /// <summary>
+    /// Gets a hash code for the characters present in <paramref name="span"/>.
+    /// </summary>
+    internal static unsafe int InternalGetHashCode(ReadOnlySpan<char> span)
+    {
+        if (span.Length == 0)
+        {
+            return 0;
+        }
+
+        fixed (char* pSpan0 = span)
+        {
+            int num1 = 0x15051505;
+            int num2 = num1;
+
+            int* pSpan = (int*)pSpan0;
+
+            int charactersRemaining;
+
+            for (charactersRemaining = span.Length; charactersRemaining >= 4; charactersRemaining -= 4)
+            {
+                num1 = ((num1 << 5) + num1 + (num1 >> 27)) ^ *pSpan;
+                num2 = ((num2 << 5) + num2 + (num2 >> 27)) ^ pSpan[1];
+                pSpan += 2;
+            }
+
+            if (charactersRemaining > 0)
+            {
+                num1 = ((num1 << 5) + num1 + (num1 >> 27)) ^ pSpan0[span.Length - 1];
+            }
+
+            return (num1 + (num2 * 0x5D588B65)) & 0x7FFFFFFF;
+        }
+    }
+
+    /// <summary>Models an entry in our hash table.</summary>
+    internal struct Slot
+    {
+        public int HashCode;
+        public int Next;
+        public string Value;
+    }
+
+    private static class HashHelpers
+    {
+        public static readonly int[] Primes =
+        {
+            3, 7, 11, 17, 23, 29, 37, 47, 59, 71,
+            89, 107, 131, 163, 197, 239, 293, 353, 431, 521,
+            631, 761, 919, 1103, 1327, 1597, 1931, 2333, 2801, 3371,
+            4049, 4861, 5839, 7013, 8419, 10103, 12143, 14591, 17519, 21023,
+            25229, 30293, 36353, 43627, 52361, 62851, 75431, 90523, 108631, 130363,
+            156437, 187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403,
+            968897, 1162687, 1395263, 1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 4999559,
+            5999471, 7199369
+        };
+
+        public static int ExpandPrime(int oldSize)
+        {
+            // Start by doubling the size.
+            int num = 2 * oldSize;
+
+            if ((uint)num > 0x7FEFFFFDu && oldSize < 0x7FEFFFFDu)
+            {
+                // If we overflowed int32, cap it.
+                return 0x7FEFFFFD;
+            }
+
+            return GetPrimeGreaterThan(num);
+
+            static int GetPrimeGreaterThan(int min)
+            {
+                if (min < 0)
+                {
+                    throw new OverflowException("StringPool size overflowed.");
+                }
+
+                for (int i = 0; i < Primes.Length; i++)
+                {
+                    int prime = Primes[i];
+                    if (prime >= min)
+                    {
+                        return prime;
+                    }
+                }
+
+                // If we get here, we're searching for a number greater than 7199369 which
+                // isn't something we have cached. Work it out by brute force.
+                for (int j = min | 1; j < int.MaxValue; j += 2)
+                {
+                    if ((j - 1) % 101 != 0 && IsPrime(j))
+                    {
+                        return j;
+                    }
+                }
+
+                return min;
+
+                static bool IsPrime(int candidate)
+                {
+                    if (((uint)candidate & (true ? 1u : 0u)) != 0)
+                    {
+                        int num = (int)Math.Sqrt(candidate);
+
+                        for (int i = 3; i <= num; i += 2)
+                        {
+                            if (candidate % i == 0)
+                            {
+                                return false;
+                            }
+                        }
+
+                        return true;
+                    }
+
+                    return candidate == 2;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Shared/UnitTests/StreamHelpers.cs b/src/Shared/UnitTests/StreamHelpers.cs
deleted file mode 100644
index f4150ee4723..00000000000
--- a/src/Shared/UnitTests/StreamHelpers.cs
+++ /dev/null
@@ -1,33 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.IO;
-
-#nullable disable
-
-namespace Microsoft.Build.UnitTests
-{
-    internal sealed class StreamHelpers
-    {
-        /// <summary>
-        /// Take a string and convert it to a StreamReader.
-        /// </summary>
-        /// <param name="value"></param>
-        /// <returns></returns>
-        internal static StreamReader StringToStreamReader(string value)
-        {
-            MemoryStream m = new MemoryStream();
-#if FEATURE_ENCODING_DEFAULT
-            TextWriter w = new StreamWriter(m, System.Text.Encoding.Default);
-#else
-            TextWriter w = new StreamWriter(m, System.Text.Encoding.UTF8);
-#endif
-
-            w.Write(value);
-            w.Flush();
-            m.Seek(0, SeekOrigin.Begin);
-
-            return new StreamReader(m);
-        }
-    }
-}
