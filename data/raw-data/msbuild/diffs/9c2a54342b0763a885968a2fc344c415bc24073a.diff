diff --git a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
index 022f11f942e..392c88c6c77 100644
--- a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
@@ -3248,7 +3248,7 @@ private static string AdjustSpacesForItem(string expectedItem)
             var itemSpace = "    ";
             var metadataSpace = itemSpace + "  ";
 
-            var splits = expectedItem.Split('\n');
+            var splits = expectedItem.Split(MSBuildConstants.NewlineChar);
             splits = splits.Select(s => s.Trim()).ToArray();
 
             Assert.True(splits.Length >= 1);
diff --git a/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs b/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
index 8d3238bd615..5dd66b6e929 100644
--- a/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
+++ b/src/Build.UnitTests/BackEnd/MockTaskBuilder.cs
@@ -113,8 +113,7 @@ public Task<WorkUnitResult> ExecuteTask(TargetLoggingContext targetLoggingContex
                 if (String.Equals(taskInstance.Name, "CallTarget", StringComparison.OrdinalIgnoreCase))
                 {
                     taskInstance.GetParameter("Targets");
-                    char[] splitter = new char[] { ';' };
-                    targetBuilderCallback.LegacyCallTarget(taskInstance.GetParameter("Targets").Split(splitter), false, taskInstance.Location);
+                    targetBuilderCallback.LegacyCallTarget(taskInstance.GetParameter("Targets").Split(MSBuildConstants.SemicolonChar), false, taskInstance.Location);
                 }
 
                 _taskNumber++;
diff --git a/src/Build.UnitTests/FileLogger_Tests.cs b/src/Build.UnitTests/FileLogger_Tests.cs
index 13d15145828..ba2dba2dc58 100644
--- a/src/Build.UnitTests/FileLogger_Tests.cs
+++ b/src/Build.UnitTests/FileLogger_Tests.cs
@@ -421,8 +421,8 @@ private void VerifyFileContent(string file, string expectedContent)
                 actualContent = sr.ReadToEnd();
             }
 
-            string[] actualLines = actualContent.Split(new char[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
-            string[] expectedLines = expectedContent.Split(new char[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
+            string[] actualLines = actualContent.Split(MSBuildConstants.NewlineChar, StringSplitOptions.RemoveEmptyEntries);
+            string[] expectedLines = expectedContent.Split(MSBuildConstants.NewlineChar, StringSplitOptions.RemoveEmptyEntries);
 
             Assert.Equal(expectedLines.Length, actualLines.Length);
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index 5fe1946d7bf..d586f4fb5c8 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -7,6 +7,7 @@
 using System.IO;
 using System.Threading.Tasks;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
@@ -252,7 +253,7 @@ public async Task<bool> ExecuteInternal()
             if (!String.IsNullOrEmpty(RemoveProperties))
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "General.UndefineProperties");
-                undefinePropertiesArray = RemoveProperties.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
+                undefinePropertiesArray = RemoveProperties.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries);
                 foreach (string property in undefinePropertiesArray)
                 {
                     Log.LogMessageFromText(String.Format(CultureInfo.InvariantCulture, "  {0}", property), MessageImportance.Low);
@@ -544,7 +545,7 @@ internal static async Task<bool> ExecuteTargets(
                     if (!String.IsNullOrEmpty(projects[i].GetMetadata("Properties")))
                     {
                         if (!PropertyParser.GetTableWithEscaping
-                             (log, ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("General.OverridingProperties", projectNames[i]), "Properties", projects[i].GetMetadata("Properties").Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries),
+                             (log, ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("General.OverridingProperties", projectNames[i]), "Properties", projects[i].GetMetadata("Properties").Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries),
                               out Dictionary<string, string> preProjectPropertiesTable)
                            )
                         {
@@ -564,7 +565,7 @@ internal static async Task<bool> ExecuteTargets(
                     string projectUndefineProperties = projects[i].GetMetadata("UndefineProperties");
                     if (!String.IsNullOrEmpty(projectUndefineProperties))
                     {
-                        string[] propertiesToUndefine = projectUndefineProperties.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
+                        string[] propertiesToUndefine = projectUndefineProperties.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries);
                         if (undefinePropertiesPerProject[i] == null)
                         {
                             undefinePropertiesPerProject[i] = new List<string>(propertiesToUndefine.Length);
@@ -586,7 +587,7 @@ internal static async Task<bool> ExecuteTargets(
                     if (!String.IsNullOrEmpty(projects[i].GetMetadata("AdditionalProperties")))
                     {
                         if (!PropertyParser.GetTableWithEscaping
-                             (log, ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("General.AdditionalProperties", projectNames[i]), "AdditionalProperties", projects[i].GetMetadata("AdditionalProperties").Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries),
+                             (log, ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("General.AdditionalProperties", projectNames[i]), "AdditionalProperties", projects[i].GetMetadata("AdditionalProperties").Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries),
                               out Dictionary<string, string> additionalProjectPropertiesTable)
                            )
                         {
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index c717e4143b8..da1c0e367d8 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.BackEnd
@@ -472,7 +473,7 @@ private void ReadHierarchy(StreamReader file)
                     return;
                 }
 
-                string[] values = line.Split(new char[] { ' ' });
+                string[] values = line.Split(Constants.SpaceChar);
                 if (values.Length < 1)
                 {
                     throw new InvalidDataException("Too few values in hierarchy");
@@ -503,7 +504,7 @@ private void ReadTimes(StreamReader file)
                     return;
                 }
 
-                string[] values = line.Split(new char[] { ' ' });
+                string[] values = line.Split(Constants.SemicolonChar);
                 if (values.Length < 3)
                 {
                     throw new InvalidDataException("Too few values in build plan.");
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 9511f2b4f38..c6db3e55145 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -747,7 +747,7 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
             // Get a list of properties which should be serialized
             if (!String.IsNullOrEmpty(forwardPropertiesFromChild))
             {
-                propertyListToSerialize = forwardPropertiesFromChild.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
+                propertyListToSerialize = forwardPropertiesFromChild.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries);
             }
 
             _loggingService.PropertiesToSerialize = propertyListToSerialize;
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index fb5b9ae0a6e..3b7f4e6f44e 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -1834,7 +1834,7 @@ internal List<ProjectImportElement> GetImplicitImportNodes(ProjectRootElement cu
 
         private static IEnumerable<SdkReference> ParseSdks(string sdks, IElementLocation sdkLocation)
         {
-            foreach (string sdk in sdks.Split(';').Select(i => i.Trim()))
+            foreach (string sdk in sdks.Split(MSBuildConstants.SemicolonChar).Select(i => i.Trim()))
             {
                 if (!SdkReference.TryParse(sdk, out SdkReference sdkReference))
                 {
diff --git a/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs b/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs
index 37d5aef9134..4f0edb13337 100644
--- a/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs
+++ b/src/Build/Construction/Solution/SolutionConfigurationInSolution.cs
@@ -14,6 +14,10 @@ public sealed class SolutionConfigurationInSolution
         /// </summary>
         internal const char ConfigurationPlatformSeparator = '|';
 
+        // One-time allocation to avoid implicit allocations for Split(), Trim().
+        // https://blog.marcgravell.com/2013/11/allocaction-allocation-allocation.html
+        internal static readonly char[] ConfigurationPlatformSeparatorArray = { ConfigurationPlatformSeparator };
+
         /// <summary>
         /// Constructor
         /// </summary>
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index b306fe8b2ae..95e2b759926 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -17,6 +17,7 @@
 using ResourceUtilities = Microsoft.Build.Shared.ResourceUtilities;
 using ExceptionUtilities = Microsoft.Build.Shared.ExceptionHandling;
 using System.Collections.ObjectModel;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Construction
 {
@@ -1033,7 +1034,7 @@ string propertyValue
                 // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
                 if (string.Compare(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase) == 0)
                 {
-                    string[] projectReferenceEntries = propertyValue.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
+                    string[] projectReferenceEntries = propertyValue.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries);
 
                     foreach (string projectReferenceEntry in projectReferenceEntries)
                     {
@@ -1225,7 +1226,7 @@ internal void ParseNestedProjects()
         /// </remarks>
         internal void ParseSolutionConfigurations()
         {
-            var nameValueSeparators = new[] { '=' };
+            var nameValueSeparators = MSBuildConstants.EqualsChar;
             var configPlatformSeparators = new[] { SolutionConfigurationInSolution.ConfigurationPlatformSeparator };
 
             do
@@ -1307,7 +1308,7 @@ internal Dictionary<string, string> ParseProjectConfigurations()
                     continue;
                 }
 
-                string[] nameValue = str.Split('=');
+                string[] nameValue = str.Split(MSBuildConstants.EqualsChar);
 
                 // There should be exactly one '=' character, separating the name and value. 
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(nameValue.Length == 2, "SubCategoryForSolutionParsingErrors",
@@ -1333,8 +1334,6 @@ internal void ProcessProjectConfigurationSection(Dictionary<string, string> rawP
             // parts of the entry name string. This could lead to ambiguous results if we tried to parse 
             // the entry name instead of constructing it and looking it up. Although it's pretty unlikely that
             // this would ever be a problem, it's safer to do it the same way VS IDE does it.
-            char[] configPlatformSeparators = { SolutionConfigurationInSolution.ConfigurationPlatformSeparator };
-
             foreach (ProjectInSolution project in _projectsInOrder)
             {
                 // Solution folders don't have configurations
@@ -1357,7 +1356,7 @@ internal void ProcessProjectConfigurationSection(Dictionary<string, string> rawP
 
                         if (rawProjectConfigurationsEntries.TryGetValue(entryNameActiveConfig, out string configurationPlatform))
                         {
-                            string[] configurationPlatformParts = configurationPlatform.Split(configPlatformSeparators);
+                            string[] configurationPlatformParts = configurationPlatform.Split(SolutionConfigurationInSolution.ConfigurationPlatformSeparatorArray);
 
                             // Project configuration may not necessarily contain the platform part. Some project support only the configuration part.
                             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(configurationPlatformParts.Length <= 2, "SubCategoryForSolutionParsingErrors",
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 5dd48012f3c..6aad1bc0493 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -169,7 +169,7 @@ private SolutionProjectGenerator(
 
             if (targetNames != null)
             {
-                _targetNames = targetNames.Select(i => i.Split(new[] {':'}, 2, StringSplitOptions.RemoveEmptyEntries).Last()).ToList();
+                _targetNames = targetNames.Select(i => i.Split(MSBuildConstants.ColonChar, 2, StringSplitOptions.RemoveEmptyEntries).Last()).ToList();
             }
         }
 
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index bcc5e5813af..67215eadefd 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -2450,7 +2450,7 @@ internal bool IsSuitableExistingItemXml(ProjectItemElement candidateExistingItem
 
             string evaluatedExistingInclude = _data.Expander.ExpandIntoStringLeaveEscaped(candidateExistingItemXml.Include, ExpanderOptions.ExpandProperties, candidateExistingItemXml.IncludeLocation);
 
-            string[] existingIncludePieces = evaluatedExistingInclude.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
+            string[] existingIncludePieces = evaluatedExistingInclude.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries);
 
             foreach (string existingIncludePiece in existingIncludePieces)
             {
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 6dfef1c027e..6f98ee8108f 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -40,7 +40,7 @@ internal class ToolsetConfigurationReader : ToolsetReader
         /// Character used to separate search paths specified for MSBuildExtensionsPath* in
         /// the config file
         /// </summary>
-        private char _separatorForExtensionsPathSearchPaths = ';';
+        private static readonly char[] s_separatorForExtensionsPathSearchPaths = MSBuildConstants.SemicolonChar;
 
         /// <summary>
         /// Cached values of tools version -> project import search paths table
@@ -237,7 +237,7 @@ private Dictionary<string, ProjectImportPathMatch> ComputeDistinctListOfSearchPa
 
                 //FIXME: handle ; in path on Unix
                 var paths = property.Value
-                    .Split(new[] {_separatorForExtensionsPathSearchPaths}, StringSplitOptions.RemoveEmptyEntries)
+                    .Split(s_separatorForExtensionsPathSearchPaths, StringSplitOptions.RemoveEmptyEntries)
                     .Distinct()
                     .Where(path => !string.IsNullOrEmpty(path));
 
@@ -267,4 +267,4 @@ private static Configuration ReadApplicationConfiguration()
             return ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 6c20c83fbf0..a94b9c960bb 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -66,7 +66,7 @@ internal class Evaluator<P, I, M, D>
         /// <summary>
         /// Character used to split InitialTargets and DefaultTargets lists
         /// </summary>
-        private static readonly char[] s_splitter = new char[] { ';' };
+        private static readonly char[] s_splitter = MSBuildConstants.SemicolonChar;
 
         /// <summary>
         /// Expander for evaluating conditions
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index c346adc0aea..816b3f3d22e 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -37,7 +37,7 @@ public sealed class ProjectGraph
         private const string ProjectReferenceTargetsMetadataName = "Targets";
         private const string DefaultTargetsMarker = ".default";
 
-        private static readonly char[] PropertySeparator = { ';' };
+        private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;
 
         private readonly ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode> _allParsedProjects =
             new ConcurrentDictionary<ConfigurationMetadata, ProjectGraphNode>();
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 107237467a8..9fea44cf03b 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -1123,12 +1123,12 @@ private bool ApplyVerbosityParameter(string parameterValue)
         /// <summary>
         /// Console logger parameters delimiters.
         /// </summary>
-        internal static readonly char[] parameterDelimiters = { ';' };
+        internal static readonly char[] parameterDelimiters = MSBuildConstants.SemicolonChar;
 
         /// <summary>
         /// Console logger parameter value split character.
         /// </summary>
-        private static readonly char[] s_parameterValueSplitCharacter = { '=' };
+        private static readonly char[] s_parameterValueSplitCharacter = MSBuildConstants.EqualsChar;
 
         /// <summary>
         /// When true, accumulate performance numbers.
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 1307342f9d4..32ddbcd659a 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -229,7 +229,7 @@ private void ProcessParameters()
                 throw new LoggerException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("InvalidBinaryLoggerParameters", ""));
             }
 
-            var parameters = Parameters.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
+            var parameters = Parameters.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries);
             foreach (var parameter in parameters)
             {
                 if (string.Equals(parameter, "ProjectImports=None", StringComparison.OrdinalIgnoreCase))
diff --git a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index d19eb478dbd..6b04b3cf31f 100644
--- a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -497,7 +497,7 @@ private bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity)
         /// <summary>
         /// Console logger parameters delimiters.
         /// </summary>
-        private static readonly char[] s_parameterDelimiters = { ';' };
+        private static readonly char[] s_parameterDelimiters = MSBuildConstants.SemicolonChar;
 
         /// <summary>
         /// Strings that users of this logger can pass in to enable specific events or logger output.
diff --git a/src/Build/Logging/FileLogger.cs b/src/Build/Logging/FileLogger.cs
index bf91189df3e..e18c73c75ff 100644
--- a/src/Build/Logging/FileLogger.cs
+++ b/src/Build/Logging/FileLogger.cs
@@ -258,12 +258,12 @@ private void ApplyFileLoggerParameter(string parameterName, string parameterValu
         /// <summary>
         /// File logger parameters delimiters.
         /// </summary>
-        private static readonly char[] s_fileLoggerParameterDelimiters = { ';' };
+        private static readonly char[] s_fileLoggerParameterDelimiters = MSBuildConstants.SemicolonChar;
 
         /// <summary>
         /// File logger parameter value split character.
         /// </summary>
-        private static readonly char[] s_fileLoggerParameterValueSplitCharacter = { '=' };
+        private static readonly char[] s_fileLoggerParameterValueSplitCharacter = MSBuildConstants.EqualsChar;
 
         #endregion
     }
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index d56b0fa05b5..35030eefbac 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -228,7 +228,7 @@ private static List<Regex> PopulateRegexFromEnvironment()
             else
             {
                 List<Regex> regexes = new List<Regex>();
-                foreach (string regex in wildCards.Split(';'))
+                foreach (string regex in wildCards.Split(MSBuildConstants.SemicolonChar))
                 {
                     Regex item = new Regex(regex, RegexOptions.Compiled | RegexOptions.Singleline | RegexOptions.IgnoreCase);
                     // trigger a match first?
diff --git a/src/Build/Utilities/RegistryKeyWrapper.cs b/src/Build/Utilities/RegistryKeyWrapper.cs
index d511fc96588..a410a39471f 100644
--- a/src/Build/Utilities/RegistryKeyWrapper.cs
+++ b/src/Build/Utilities/RegistryKeyWrapper.cs
@@ -176,7 +176,7 @@ public virtual RegistryKeyWrapper OpenSubKey(string name)
             ErrorUtilities.VerifyThrowArgumentLength(name, "name");
 
             RegistryKeyWrapper wrapper = this;
-            string[] keyNames = name.Split(new char[] { '\\' }, StringSplitOptions.RemoveEmptyEntries);
+            string[] keyNames = name.Split(MSBuildConstants.BackslashChar, StringSplitOptions.RemoveEmptyEntries);
 
             for (int i = 0; i < keyNames.Length && wrapper.Exists(); ++i)
             {
@@ -271,4 +271,4 @@ private void Dispose(bool disposing)
         }
     }
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/src/Framework/Sdk/SdkReference.cs b/src/Framework/Sdk/SdkReference.cs
index d095fd3a5a3..2fc413d4e65 100644
--- a/src/Framework/Sdk/SdkReference.cs
+++ b/src/Framework/Sdk/SdkReference.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Linq;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Framework
 {
@@ -66,7 +67,7 @@ public static bool TryParse(string sdk, out SdkReference sdkReference)
             sdkReference = null;
             if (string.IsNullOrWhiteSpace(sdk)) return false;
 
-            var parts = sdk.Split('/').Select(i => i.Trim()).ToArray();
+            var parts = sdk.Split(MSBuildConstants.ForwardSlash).Select(i => i.Trim()).ToArray();
 
             if (parts.Length < 1 || parts.Length > 2) return false;
             if (string.IsNullOrWhiteSpace(parts[0])) return false;
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 28e98d34d00..5f2d936f3ae 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -114,6 +114,10 @@ public enum ExitType
         /// </summary>
         private static CancellationTokenSource s_buildCancellationSource = new CancellationTokenSource();
 
+        // One-time allocation to avoid implicit allocations for Split(), Trim().
+        // https://blog.marcgravell.com/2013/11/allocaction-allocation-allocation.html
+        private static readonly char[] s_commaSemicolon = { ',', ';' };
+
         /// <summary>
         /// Static constructor
         /// </summary>
@@ -2326,7 +2330,7 @@ internal static ISet<string> ProcessWarnAsErrorSwitch(CommandLineSwitches comman
             ISet<string> warningsAsErrors = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             foreach (string code in parameters
-                .SelectMany(parameter => parameter?.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries) ?? new string[] { null }))
+                .SelectMany(parameter => parameter?.Split(s_commaSemicolon, StringSplitOptions.RemoveEmptyEntries) ?? new string[] { null }))
             {
                 if (code == null)
                 {
@@ -2355,7 +2359,7 @@ internal static ISet<string> ProcessWarnAsMessageSwitch(CommandLineSwitches comm
             ISet<string> warningsAsMessages = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             foreach (string code in parameters
-                .SelectMany(parameter => parameter?.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries))
+                .SelectMany(parameter => parameter?.Split(s_commaSemicolon, StringSplitOptions.RemoveEmptyEntries))
                 .Where(i => !String.IsNullOrWhiteSpace(i))
                 .Select(i => i.Trim()))
             {
@@ -2824,12 +2828,12 @@ private static string[] ProcessTargetSwitch(string[] parameters)
         /// <summary>
         /// The = sign is used to pair properties with their values on the command line.
         /// </summary>
-        private static readonly char[] s_propertyValueSeparator = { '=' };
+        private static readonly char[] s_propertyValueSeparator = MSBuildConstants.EqualsChar;
 
         /// <summary>
         /// This is a set of wildcard chars which can cause a file extension to be invalid 
         /// </summary>
-        private static readonly char[] s_wildcards = { '*', '?' };
+        private static readonly char[] s_wildcards = MSBuildConstants.WildcardChars;
 
         /// <summary>
         /// Determines which ToolsVersion was specified on the command line.  If more than
@@ -3174,7 +3178,7 @@ int cpuCount
         /// </summary>
         internal static string ExtractAnyLoggerParameter(string parameters, params string[] parameterNames)
         {
-            string[] nameValues = parameters.Split(';');
+            string[] nameValues = parameters.Split(MSBuildConstants.SemicolonChar);
             string result = null;
 
             foreach (string nameValue in nameValues)
@@ -3204,7 +3208,7 @@ private static string ExtractAnyParameterValue(string parameter)
 
             if (!String.IsNullOrEmpty(parameter))
             {
-                string[] nameValuePair = parameter.Split('=');
+                string[] nameValuePair = parameter.Split(MSBuildConstants.EqualsChar);
 
                 value = (nameValuePair.Length > 1) ? nameValuePair[1] : null;
             }
diff --git a/src/Samples/TaskUsageLogger/TaskUsageLogger.cs b/src/Samples/TaskUsageLogger/TaskUsageLogger.cs
index 1d792ee0aac..bf28365a775 100644
--- a/src/Samples/TaskUsageLogger/TaskUsageLogger.cs
+++ b/src/Samples/TaskUsageLogger/TaskUsageLogger.cs
@@ -44,6 +44,7 @@ namespace TaskUsageLogger
     public class TaskUsageLogger : Logger
     {
         private static readonly Regex s_msbuildPropertyRegex = new Regex(@"[\$][\(](?<name>.*?)[\)]", RegexOptions.ExplicitCapture);
+        private static readonly char[] s_semicolonChar = { ';' };
         private static readonly char[] s_disallowedCharactersForExpansion = new char[] { '@', '%' };
         private static readonly char[] s_fullyQualifiedTaskNameSeperators = new char[] { '.', '+' };
 
@@ -86,7 +87,7 @@ private void ProcessParameters()
             {
             }
 
-            string[] parameters = Parameters.Split(';');
+            string[] parameters = Parameters.Split(s_semicolonChar);
 
             if (parameters.Length != 1)
             {
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
index 9204e7f58ad..26f7c644e4f 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
@@ -5,6 +5,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Microsoft.Win32;
 using ProcessorArchitecture = System.Reflection.ProcessorArchitecture;
@@ -269,7 +270,7 @@ private bool MatchingPlatformExists(string platform, string platformValue)
 
             if (platformValue != null && platformValue.Length > 0)
             {
-                string[] platforms = platformValue.Split(';');
+                string[] platforms = platformValue.Split(MSBuildConstants.SemicolonChar);
                 foreach (string p in platforms)
                 {
                     if (String.Compare(p, platform, StringComparison.OrdinalIgnoreCase) == 0)
diff --git a/src/Shared/CanonicalError.cs b/src/Shared/CanonicalError.cs
index ca1c93a2811..b4346085d21 100644
--- a/src/Shared/CanonicalError.cs
+++ b/src/Shared/CanonicalError.cs
@@ -334,7 +334,7 @@ internal static Parts Parse(string message)
                 parsedMessage.text = (match.Groups["TEXT"].Value + messageOverflow).Trim();
                 parsedMessage.origin = match.Groups["FILENAME"].Value.Trim();
 
-                string[] explodedText = parsedMessage.text.Split(new char[] {'\''}, StringSplitOptions.RemoveEmptyEntries);
+                string[] explodedText = parsedMessage.text.Split(MSBuildConstants.SingleQuoteChar, StringSplitOptions.RemoveEmptyEntries);
                 if (explodedText.Length > 0)
                 {
                     parsedMessage.code = "G" + explodedText[0].GetHashCode().ToString("X8");
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 194449da891..b4b2bf9b02e 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.IO;
 using System.Reflection;
 
 // This file is compiled into both Microsoft.Build.Framework and Microsoft.Build.Tasks which can cause collisions.
@@ -83,6 +84,27 @@ internal static class MSBuildConstants
         /// The name of the item used to specify references to other msbuild projects
         /// </summary>
         internal const string ProjectReferenceItemName = "ProjectReference";
+
+        // One-time allocations to avoid implicit allocations for Split(), Trim().
+        // https://blog.marcgravell.com/2013/11/allocaction-allocation-allocation.html
+        internal static readonly char[] SemicolonChar = { ';' };
+        internal static readonly char[] SpaceChar = { ' ' };
+        internal static readonly char[] SingleQuoteChar = { '\'' };
+        internal static readonly char[] EqualsChar = { '=' };
+        internal static readonly char[] ColonChar = { ':' };
+        internal static readonly char[] BackslashChar = { '\\' };
+        internal static readonly char[] NewlineChar = { '\n' };
+        internal static readonly char[] CrLf = { '\r', '\n' };
+        internal static readonly char[] ForwardSlash = { '/' };
+        internal static readonly char[] ForwardSlashBackslash = { '/', '\\' };
+        internal static readonly char[] WildcardChars = { '*', '?' };
+        internal static readonly char[] CommaChar = { ',' };
+        internal static readonly char[] HyphenChar = { '-' };
+        internal static readonly char[] DirectorySeparatorChar = { Path.DirectorySeparatorChar };
+        internal static readonly char[] DotChar = { '.' };
+        internal static readonly string[] EnvironmentNewLine = { Environment.NewLine };
+        internal static readonly char[] PipeChar = { '|' };
+        internal static readonly char[] PathSeparatorChar = { Path.PathSeparator };
     }
 
     /// <summary>
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index 74a2098190f..6bc052bfc68 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -1177,7 +1177,7 @@ internal static int GetParentProcessId(int processId)
                     // One of the fields is the process name. It may contain any characters, but since it's
                     // in parenthesis, we can finds its end by looking for the last parenthesis. After that,
                     // there comes a space, then the second fields separated by a space is the parent id.
-                    string[] statFields = line.Substring(line.LastIndexOf(')')).Split(new[] { ' ' }, 4);
+                    string[] statFields = line.Substring(line.LastIndexOf(')')).Split(MSBuildConstants.SpaceChar, 4);
                     if (statFields.Length >= 3)
                     {
                         ParentID = Int32.Parse(statFields[2]);
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 4a1fed1e7da..b5239aa6bbb 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -470,7 +470,7 @@ private static List<ITaskItem> ParseExpectedItemsString(string expectedItemsStri
 
             // First, parse this massive string that we've been given, and create an ITaskItem[] out of it,
             // so we can more easily compare it against the actual items.
-            string[] expectedItemsStringSplit = expectedItemsString.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
+            string[] expectedItemsStringSplit = expectedItemsString.Split(MSBuildConstants.CrLf, StringSplitOptions.RemoveEmptyEntries);
             foreach (string singleExpectedItemString in expectedItemsStringSplit)
             {
                 string singleExpectedItemStringTrimmed = singleExpectedItemString.Trim();
@@ -493,7 +493,7 @@ private static List<ITaskItem> ParseExpectedItemsString(string expectedItemsStri
 
                         ITaskItem expectedItem = new Utilities.TaskItem(itemSpec);
 
-                        string[] itemMetadataPieces = itemMetadataString.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
+                        string[] itemMetadataPieces = itemMetadataString.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries);
                         foreach (string itemMetadataPiece in itemMetadataPieces)
                         {
                             string itemMetadataPieceTrimmed = itemMetadataPiece.Trim();
@@ -1556,7 +1556,7 @@ internal static TransientTestFile CreateProjectFile(
             sb.Append("</ItemGroup>");
 
             
-            foreach (var defaultTarget in (defaultTargets ?? string.Empty).Split(new[]{';'}, StringSplitOptions.RemoveEmptyEntries))
+            foreach (var defaultTarget in (defaultTargets ?? string.Empty).Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
             {
                 sb.Append($"<Target Name='{defaultTarget}'/>");
             }
@@ -1630,7 +1630,7 @@ private static string[] SplitPathIntoFragments(string path)
         {
             // Both Path.AltDirectorSeparatorChar and Path.DirectorySeparator char return '/' on OSX,
             // which renders them useless for the following case where I want to split a path that may contain either separator
-            var splits = path.Split('/', '\\');
+            var splits = path.Split(MSBuildConstants.ForwardSlashBackslash);
 
             // if the path is rooted then the first split is either empty (Unix) or 'c:' (Windows)
             // in this case the root must be restored back to '/' (Unix) or 'c:\' (Windows)
diff --git a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
index 74aff4b59e6..47b4e53c75c 100644
--- a/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
+++ b/src/Tasks.UnitTests/ToolTaskExtension_Tests.cs
@@ -111,7 +111,7 @@ public void UseNewLineSeparatorseInResponseFile()
 
             MyToolTaskExtension t = new MyToolTaskExtension(useNewLineSeparators: true, addResponseFileCommands: addResponseFileCommands);
             
-            string[] actual = t.GetResponseFileCommands().Split(new[] { Environment.NewLine }, StringSplitOptions.None);
+            string[] actual = t.GetResponseFileCommands().Split(MSBuildConstants.EnvironmentNewLine, StringSplitOptions.None);
             string[] expected =
             {
                 "/A:D66B977148114482A88B0EFC1E531F02",
diff --git a/src/Tasks.UnitTests/WinMDExp_Tests.cs b/src/Tasks.UnitTests/WinMDExp_Tests.cs
index 3d119160ad3..dfccd7131b3 100644
--- a/src/Tasks.UnitTests/WinMDExp_Tests.cs
+++ b/src/Tasks.UnitTests/WinMDExp_Tests.cs
@@ -128,7 +128,7 @@ public void ArgumentsAreUnquoted()
 
             t.AddResponseFileCommands(c);
 
-            string[] actual = c.ToString().Split(new [] { Environment.NewLine }, StringSplitOptions.None);
+            string[] actual = c.ToString().Split(MSBuildConstants.EnvironmentNewLine, StringSplitOptions.None);
             string[] expected =
             {
                 "/d:sp ace",
diff --git a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
index c2e4b4219b6..874718db236 100644
--- a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
+++ b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
@@ -11,6 +11,7 @@
 using Xunit;
 using System.Collections.Generic;
 using System.Linq;
+using MSBuildConstants = Microsoft.Build.Tasks.MSBuildConstants;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -690,7 +691,7 @@ private static void CheckContent(string actualContent, string[] expectedAttribut
             // we tolerate differences in whitespace and comments between platforms
             string normalizedActualContent = string.Join(
                 Environment.NewLine,
-                actualContent.Split('\r', '\n')
+                actualContent.Split(MSBuildConstants.CrLf)
                              .Select(line => line.Trim())
                              .Where(line => line.Length > 0 && !line.StartsWith(commentStart)));
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
index 27fbfdc15f0..dc63978daaf 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
@@ -147,7 +147,7 @@ private void LazyInitialize()
                         string value = conditions.Value.Trim();
 
                         // Parse the condition statement for OSVersion and Platform
-                        foreach (string c in value.Split(':'))
+                        foreach (string c in value.Split(MSBuildConstants.ColonChar))
                         {
                             if (String.Compare(c, 0, "OSVERSION=", 0, 10, StringComparison.OrdinalIgnoreCase) == 0)
                             {
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index 7d4faf7b546..9274492a3bf 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -85,7 +85,7 @@ internal AssemblyInformation(string sourceFile)
 #if FEATURE_ASSEMBLY_LOADFROM
         private static Assembly ReflectionOnlyAssemblyResolve(object sender, ResolveEventArgs args)
         {
-            string[] nameParts = args.Name.Split(',');
+            string[] nameParts = args.Name.Split(MSBuildConstants.CommaChar);
             Assembly assembly = null;
 
             if (args.RequestingAssembly != null && !string.IsNullOrEmpty(args.RequestingAssembly.Location) && nameParts.Length > 0)
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index 7014c037a74..567e98ca889 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -251,7 +251,7 @@ private void UpdateExistingBindingRedirects(XElement runtimeNode, IDictionary<As
                         continue;
                     }
 
-                    var oldVersionRange = oldVersionAttribute.Value.Split('-');
+                    var oldVersionRange = oldVersionAttribute.Value.Split(MSBuildConstants.HyphenChar);
                     if (oldVersionRange.Length == 0 || oldVersionRange.Length > 2)
                     {
                         continue;
diff --git a/src/Tasks/AssignProjectConfiguration.cs b/src/Tasks/AssignProjectConfiguration.cs
index 2d9f517e631..7c4f8841a24 100644
--- a/src/Tasks/AssignProjectConfiguration.cs
+++ b/src/Tasks/AssignProjectConfiguration.cs
@@ -390,11 +390,11 @@ private void SetupDefaultPlatformMappings()
         /// </summary>
         private void PopulateMappingDictionary(IDictionary<string, string> map, string mappingList)
         {
-            string[] mappings = mappingList.Split(';');
+            string[] mappings = mappingList.Split(MSBuildConstants.SemicolonChar);
 
             foreach (string mapping in mappings)
             {
-                string[] platforms = mapping.Split('=');
+                string[] platforms = mapping.Split(MSBuildConstants.EqualsChar);
 
                 if (platforms.Length != 2)
                 {
diff --git a/src/Tasks/CreateManifestResourceName.cs b/src/Tasks/CreateManifestResourceName.cs
index e491d34ebae..bc8c733e8ff 100644
--- a/src/Tasks/CreateManifestResourceName.cs
+++ b/src/Tasks/CreateManifestResourceName.cs
@@ -315,7 +315,7 @@ internal static string MakeValidEverettFolderIdentifier(string name)
             var everettId = new StringBuilder(name.Length + 1);
 
             // split folder name into subnames separated by '.', if any
-            string[] subNames = name.Split('.');
+            string[] subNames = name.Split(MSBuildConstants.DotChar);
 
             // convert each subname separately
             everettId.Append(MakeValidEverettSubFolderIdentifier(subNames[0]));
@@ -346,7 +346,7 @@ public static string MakeValidEverettIdentifier(string name)
             var everettId = new StringBuilder(name.Length);
 
             // split the name into folder names
-            string[] subNames = name.Split(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
+            string[] subNames = name.Split(MSBuildConstants.ForwardSlashBackslash);
 
             // convert every folder name
             everettId.Append(MakeValidEverettFolderIdentifier(subNames[0]));
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index a993c14ffb1..88abe02d007 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -215,7 +215,7 @@ public override bool Execute()
             if (!String.IsNullOrEmpty(RemoveProperties))
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "General.UndefineProperties");
-                undefinePropertiesArray = RemoveProperties.Split(';');
+                undefinePropertiesArray = RemoveProperties.Split(MSBuildConstants.SemicolonChar);
                 foreach (string property in undefinePropertiesArray)
                 {
                     Log.LogMessageFromText($"  {property}", MessageImportance.Low);
@@ -504,7 +504,7 @@ string toolsVersion
                     if (!String.IsNullOrEmpty(projects[i].GetMetadata("Properties")))
                     {
                         if (!PropertyParser.GetTableWithEscaping
-                             (log, ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("General.OverridingProperties", projectNames[i]), "Properties", projects[i].GetMetadata("Properties").Split(';'),
+                             (log, ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("General.OverridingProperties", projectNames[i]), "Properties", projects[i].GetMetadata("Properties").Split(MSBuildConstants.SemicolonChar),
                               out Dictionary<string, string> preProjectPropertiesTable)
                            )
                         {
@@ -523,7 +523,7 @@ string toolsVersion
                     string projectUndefineProperties = projects[i].GetMetadata("UndefineProperties");
                     if (!String.IsNullOrEmpty(projectUndefineProperties))
                     {
-                        string[] propertiesToUndefine = projectUndefineProperties.Split(';');
+                        string[] propertiesToUndefine = projectUndefineProperties.Split(MSBuildConstants.SemicolonChar);
                         if (undefinePropertiesPerProject[i] == null)
                         {
                             undefinePropertiesPerProject[i] = new List<string>(propertiesToUndefine.Length);
@@ -545,7 +545,7 @@ string toolsVersion
                     if (!String.IsNullOrEmpty(projects[i].GetMetadata("AdditionalProperties")))
                     {
                         if (!PropertyParser.GetTableWithEscaping
-                             (log, ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("General.AdditionalProperties", projectNames[i]), "AdditionalProperties", projects[i].GetMetadata("AdditionalProperties").Split(';'),
+                             (log, ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("General.AdditionalProperties", projectNames[i]), "AdditionalProperties", projects[i].GetMetadata("AdditionalProperties").Split(MSBuildConstants.SemicolonChar),
                               out Dictionary<string, string> additionalProjectPropertiesTable)
                            )
                         {
diff --git a/src/Tasks/ManifestUtil/PathUtil.cs b/src/Tasks/ManifestUtil/PathUtil.cs
index d164d77518d..672be35b390 100644
--- a/src/Tasks/ManifestUtil/PathUtil.cs
+++ b/src/Tasks/ManifestUtil/PathUtil.cs
@@ -29,7 +29,7 @@ public static string[] GetPathSegments(string path)
         {
             path = path.Replace(Path.AltDirectorySeparatorChar, Path.DirectorySeparatorChar);
             path = path.TrimEnd(Path.DirectorySeparatorChar);
-            return path.Split(Path.DirectorySeparatorChar);
+            return path.Split(MSBuildConstants.DirectorySeparatorChar);
         }
 
         //Resolves the path, and if path is a url also canonicalizes it.
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index e2cac016858..45a6f437167 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -310,7 +310,7 @@ internal bool ExtractFromManifest(
                                     itemTypeLib.SetMetadata(ComReferenceItemMetadataNames.wrapperTool, ComReferenceTypes.tlbimp);
                                     itemTypeLib.SetMetadata(ComReferenceItemMetadataNames.guid, typelib.TlbId);
                                     itemTypeLib.SetMetadata(ComReferenceItemMetadataNames.lcid, "0");
-                                    string[] verMajorAndMinor = typelib.Version.Split('.');
+                                    string[] verMajorAndMinor = typelib.Version.Split(MSBuildConstants.DotChar);
                                     // UNDONE: are major and minor version numbers in base 10 or 16?
                                     itemTypeLib.SetMetadata(ComReferenceItemMetadataNames.versionMajor, verMajorAndMinor[0]);
                                     itemTypeLib.SetMetadata(ComReferenceItemMetadataNames.versionMinor, verMajorAndMinor[1]);
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index c6d88669aad..85618b0140b 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -49,7 +49,7 @@ public class ResolveSDKReference : TaskExtension
         /// <summary>
         /// Split char for the appx attribute
         /// </summary>
-        private static readonly char[] s_appxSplitChar = { '-' };
+        private static readonly char[] s_appxSplitChar = MSBuildConstants.HyphenChar;
 
         /// <summary>
         /// SDKName
@@ -61,11 +61,6 @@ public class ResolveSDKReference : TaskExtension
         /// </summary>
         private const string SDKPlatformVersion = "PlatformVersion";
 
-        /// <summary>
-        /// Split char for strings
-        /// </summary>
-        private static readonly char[] s_semicolonSplitChar = { ';' };
-
         /// <summary>
         /// Default target platform version
         /// </summary>
@@ -535,7 +530,7 @@ internal static List<string> ParseDependsOnSDK(string dependsOnSDK)
         {
             if (!String.IsNullOrEmpty(dependsOnSDK))
             {
-                return dependsOnSDK.Split(s_semicolonSplitChar, StringSplitOptions.RemoveEmptyEntries).Select(x => x.Trim()).Where(y => y.Length > 0).ToList<string>();
+                return dependsOnSDK.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries).Select(x => x.Trim()).Where(y => y.Length > 0).ToList<string>();
             }
 
             return new List<string>();
@@ -647,7 +642,7 @@ internal class SDKReference : IEquatable<SDKReference>
             /// <summary>
             /// Delimiter for supported architectures
             /// </summary>
-            private static readonly char[] s_supportedArchitecturesSplitChars = { ';' };
+            private static readonly char[] s_supportedArchitecturesSplitChars = MSBuildConstants.SemicolonChar;
 
             /// <summary>
             /// Delimiter used to delimit the supported architectures in the error message
diff --git a/src/Tasks/Telemetry.cs b/src/Tasks/Telemetry.cs
index 6582b77e96e..0d01a0a0428 100644
--- a/src/Tasks/Telemetry.cs
+++ b/src/Tasks/Telemetry.cs
@@ -32,9 +32,9 @@ public override bool Execute()
 
             if (!String.IsNullOrEmpty(EventData))
             {
-                foreach (string pair in EventData.Split(new[] {';'}, StringSplitOptions.RemoveEmptyEntries))
+                foreach (string pair in EventData.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
                 {
-                    var item = pair.Split(new[] {'='}, 2, StringSplitOptions.RemoveEmptyEntries);
+                    var item = pair.Split(MSBuildConstants.EqualsChar, 2, StringSplitOptions.RemoveEmptyEntries);
 
                     if (item.Length != 2)
                     {
diff --git a/src/Tasks/XamlTaskFactory/RelationsParser.cs b/src/Tasks/XamlTaskFactory/RelationsParser.cs
index 02776ea99ea..50f1c3872cd 100644
--- a/src/Tasks/XamlTaskFactory/RelationsParser.cs
+++ b/src/Tasks/XamlTaskFactory/RelationsParser.cs
@@ -389,7 +389,7 @@ private bool ParseImportOption(XmlNode node)
                 {
                     if (String.Equals(attribute.Name, tasksAttribute, StringComparison.OrdinalIgnoreCase))
                     {
-                        importTasks = attribute.InnerText.Split(';');
+                        importTasks = attribute.InnerText.Split(MSBuildConstants.SemicolonChar);
                     }
                 }
                 _isImport = true;
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index 5c2add5889c..c4a7f87cfba 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -460,7 +460,7 @@ public XslCompiledTransform LoadXslt(bool useTrustedSettings)
                     case XslModes.XsltCompiledDll:
                         // We accept type in format: assembly_name[;type_name]. type_name may be omitted if assembly has just one type defined
                         string dll = _data;
-                        string[] pair = dll.Split(';');
+                        string[] pair = dll.Split(MSBuildConstants.SemicolonChar);
                         string assemblyPath = pair[0];
                         string typeName = (pair.Length == 2) ? pair[1] : null;
 
diff --git a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
index 99a58c7fd33..80543f08545 100644
--- a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
+++ b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
@@ -429,7 +429,7 @@ public void UseNewLineSeparators()
             c.AppendTextUnquoted("C7E1720B16E5477D8D15733006E68278");
 
 
-            string[] actual = c.ToString().Split(new[] {Environment.NewLine}, StringSplitOptions.None);
+            string[] actual = c.ToString().Split(MSBuildConstants.EnvironmentNewLine, StringSplitOptions.None);
             string[] expected = 
             {
                 "/foo:bar",
diff --git a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
index b2335ddc778..93f48e34af5 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
@@ -1687,7 +1687,7 @@ public void InProcTrackingChildCustomEnvironment()
 
                 if (envLine.StartsWith("TESTVAR=", StringComparison.OrdinalIgnoreCase) && varValue == null)
                 {
-                    string[] varVal = envLine.Split('=');
+                    string[] varVal = envLine.Split(MSBuildConstants.EqualsChar);
                     varValue = varVal[1];
                 }
                 else if (envLine.StartsWith("TRACKER_TOOLCHAIN=", StringComparison.OrdinalIgnoreCase) && toolChainValue == null)
diff --git a/src/Utilities/ExtensionSDK.cs b/src/Utilities/ExtensionSDK.cs
index c8898b9eb84..8034658dba2 100644
--- a/src/Utilities/ExtensionSDK.cs
+++ b/src/Utilities/ExtensionSDK.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Utilities
 {
@@ -147,11 +148,11 @@ public Version MaxPlatformVersion
         /// </summary>
         private void ParseMoniker(string moniker)
         {
-            string[] properties = moniker.Split(',');
+            string[] properties = moniker.Split(MSBuildConstants.CommaChar);
 
             foreach (string property in properties)
             {
-                string[] words = property.Split('=');
+                string[] words = property.Split(MSBuildConstants.EqualsChar);
 
                 if (words[0].Trim().StartsWith("Version", StringComparison.OrdinalIgnoreCase))
                 {
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 0895c3f9337..180945c61d0 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -252,7 +252,7 @@ public static class ToolLocationHelper
         /// Character used to separate search paths specified for MSBuildExtensionsPath* in
         /// the config file
         /// </summary>
-        private static char _separatorForFallbackSearchPaths = ';';
+        private static readonly char[] _separatorForFallbackSearchPaths = MSBuildConstants.SemicolonChar;
 
         private const string retailConfigurationName = "Retail";
         private const string neutralArchitectureName = "Neutral";
@@ -264,7 +264,7 @@ public static class ToolLocationHelper
         private const string uapDirectoryName = "Windows Kits";
         private const string uapRegistryName = "Windows";
         private const int uapVersion = 10;
-        private static readonly char[] s_diskRootSplitChars = { ';' };
+        private static readonly char[] s_diskRootSplitChars = MSBuildConstants.SemicolonChar;
 
         /// <summary>
         /// Delegate to a method which takes a version enumeration and return a string path
@@ -1477,8 +1477,8 @@ public static string FindRootFolderWhereAllFilesExist(string possibleRoots, stri
         {
             if (!string.IsNullOrEmpty(possibleRoots))
             {
-                var roots = possibleRoots.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
-                var files = relativeFilePaths.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
+                var roots = possibleRoots.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries);
+                var files = relativeFilePaths.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries);
 
                 bool allFilesFound;
                 foreach (var root in roots)
@@ -2181,7 +2181,7 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkR
 
             if (!string.IsNullOrEmpty(targetFrameworkFallbackSearchPaths))
             {
-                foreach (string rootPath in targetFrameworkFallbackSearchPaths.Split(new[]{_separatorForFallbackSearchPaths}, StringSplitOptions.RemoveEmptyEntries))
+                foreach (string rootPath in targetFrameworkFallbackSearchPaths.Split(_separatorForFallbackSearchPaths, StringSplitOptions.RemoveEmptyEntries))
                 {
                     pathsList = GetPathToReferenceAssemblies(rootPath, frameworkName);
                     if (pathsList?.Count > 0)
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index e97de111db3..6615918073f 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -1252,7 +1252,7 @@ internal static string FindOnPath(string filename)
         {
             // Get path from the environment and split path separator
             return Environment.GetEnvironmentVariable("PATH")?
-                .Split(Path.PathSeparator)?
+                .Split(MSBuildConstants.PathSeparatorChar)?
                 .Where(path =>
                 {
                     try
@@ -1590,7 +1590,7 @@ private bool LogEnvironmentVariable(bool alreadyLoggedEnvironmentHeader, string
         /// <summary>
         /// Splitter for environment variables
         /// </summary>
-        private static readonly char[] s_equalsSplitter = new char[] { '=' };
+        private static readonly char[] s_equalsSplitter = MSBuildConstants.EqualsChar;
 
         /// <summary>
         /// The actual importance at which standard out messages will be logged 
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
index 2d406c80951..5351c673e7c 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
@@ -29,7 +29,7 @@ internal static bool RootContainsAllSubRootComponents(string compositeRoot, stri
             }
 
             // look for each sub key in the main composite key
-            string[] rootComponents = compositeSubRoot.Split('|');
+            string[] rootComponents = compositeSubRoot.Split(MSBuildConstants.PipeChar);
             foreach (string subRoot in rootComponents)
             {
                 // we didn't find this subkey, so bail out
