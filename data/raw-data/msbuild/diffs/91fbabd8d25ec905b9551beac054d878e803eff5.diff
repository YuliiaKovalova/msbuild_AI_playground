diff --git a/.opt-prof.yml b/.opt-prof.yml
index c53ec2cfac1..ee9d1649fee 100644
--- a/.opt-prof.yml
+++ b/.opt-prof.yml
@@ -57,7 +57,7 @@ stages:
     cloudBuildResourceName: ComponentBuildUnderTest
     testLabPoolName: VS-Platform # The test lab pool to run your tests in
     testMachineCleanUpStrategy: ${{parameters.testMachineCleanUpStrategy}}
-    testMachineImageName: Windows-10-Enterprise-20H2
+    testMachineImageName: Windows-11-Enterprise-23H2
     visualStudioSigning: Test
     variables:
     - name: branchName # The branch in the VS repo the bootstrapper was based on
diff --git a/MSBuild.Dev.slnf b/MSBuild.Dev.slnf
index 39e25ebb5a8..79c1a4edfdf 100644
--- a/MSBuild.Dev.slnf
+++ b/MSBuild.Dev.slnf
@@ -9,13 +9,13 @@
       "src\\Framework\\Microsoft.Build.Framework.csproj",
       "src\\MSBuild.UnitTests\\Microsoft.Build.CommandLine.UnitTests.csproj",
       "src\\MSBuild\\MSBuild.csproj",
+      "src\\StringTools\\StringTools.csproj",
       "src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj",
       "src\\Tasks\\Microsoft.Build.Tasks.csproj",
+      "src\\UnitTests.Shared\\Microsoft.Build.UnitTests.Shared.csproj",
       "src\\Utilities.UnitTests\\Microsoft.Build.Utilities.UnitTests.csproj",
       "src\\Utilities\\Microsoft.Build.Utilities.csproj",
-      "src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj",
-      "src\\StringTools\\StringTools.csproj",
-      "src\\UnitTests.Shared\\Microsoft.Build.UnitTests.Shared.csproj"
+      "src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj"
     ]
   }
 }
\ No newline at end of file
diff --git a/MSBuild.sln b/MSBuild.sln
index d1daf054f9e..258d1a5c5d7 100644
--- a/MSBuild.sln
+++ b/MSBuild.sln
@@ -82,6 +82,8 @@ Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.UnitTests.S
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.BuildCheck.UnitTests", "src\BuildCheck.UnitTests\Microsoft.Build.BuildCheck.UnitTests.csproj", "{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}"
 EndProject
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Templates", "template_feed\Microsoft.Build.Templates.csproj", "{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -890,6 +892,30 @@ Global
 		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x64.Build.0 = Release|x64
 		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x86.ActiveCfg = Release|Any CPU
 		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x86.Build.0 = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|ARM64.Build.0 = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|x64.ActiveCfg = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|x64.Build.0 = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Debug|x86.Build.0 = Debug|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|x64.ActiveCfg = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|x64.Build.0 = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|Any CPU.Build.0 = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|ARM64.Build.0 = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|x64.ActiveCfg = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|x64.Build.0 = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|x86.ActiveCfg = Release|Any CPU
+		{A86EE74A-AEF0-42ED-A5A7-7A54BC0773D8}.Release|x86.Build.0 = Release|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff --git a/documentation/release-checklist.md b/documentation/release-checklist.md
new file mode 100644
index 00000000000..4f00f360e55
--- /dev/null
+++ b/documentation/release-checklist.md
@@ -0,0 +1,78 @@
+# MSBuild Release Checklist {{THIS_RELEASE_VERSION}}
+
+## At any time
+
+- [ ] Create a new issue to track the release checklist, with this checklist copied into the issue.
+  - [ ] Replace `{{PREVIOUS_RELEASE_VERSION}}` with the previous release version, for example `17.9`
+  - [ ] Replace `{{THIS_RELEASE_VERSION}}` with the current release version, for example `17.10`
+  - [ ] Replace `{{NEXT_VERSION}}` with the next release version, for example `17.11`
+- [ ]  Create `vs{{THIS_RELEASE_VERSION}}` branch
+- [ ]  Create darc channel for `VS {{NEXT_VERSION}}` if it doesn't already exist \
+`darc add-channel --name "VS {{NEXT_VERSION}}"`
+- [ ]  Ping internal "First Responders" Teams channel to get the new channel made available as a promotion target (e.g. dotnet/arcade#12150): {{URL_OF_CHANNEL_PROMOTION_PR}}
+
+## At release time
+
+- [ ] If the release is being cut more than a few days before the VS-side snap, do these two steps. Otherwise check them off.
+  - [ ]  Modify the VS insertion so that it flows from MSBuild `vs{{THIS_RELEASE_VERSION}}` to VS `main` [in the MSBuild-release-branch release definition](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=1319&view=mine&_a=releases) Edit -> Schedule set under Artifacts -> disable toggle
+AND
+  - [ ]  Disable automated run of [the MSBuild-main-branch release definition](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=2153&view=mine&_a=releases) (because our {{NEXT_VERSION}} builds don't have a place to go in VS yet)
+- [ ]  Remove the `main` to old release channel ({{THIS_RELEASE_VERSION}}) default channel \
+`darc delete-default-channel --repo https://github.com/dotnet/msbuild --branch main --channel "VS {{THIS_RELEASE_VERSION}}"`
+- [ ]  Associate the `main` branch with the next release channel \
+`darc add-default-channel  --channel "VS {{THIS_RELEASE_VERSION}}" --branch main --repo https://github.com/dotnet/msbuild`
+- [ ]  Check subscriptions for the forward-looking channel `VS {{NEXT_VERSION}}` and update as necessary (for instance, SDK's `main` branch should usually be updated, whereas release branches often should not be \
+`darc get-subscriptions --exact --source-repo https://github.com/dotnet/msbuild --channel "VS {{THIS_RELEASE_VERSION}}"`
+- [ ]  Update channel VS {{THIS_RELEASE_VERSION}} to VS {{NEXT_VERSION}} for the sdk main subscription and any others from the previous step
+`darc update-subscription --id sdk_main_branch_id`
+- [ ]  Ensure that the current release channel `VS {{THIS_RELEASE_VERSION}}` is associated with the correct release branch\
+`darc get-default-channels --source-repo https://github.com/dotnet/msbuild --branch vs{{THIS_RELEASE_VERSION}}` \
+if it is not, `darc add-default-channel  --channel "VS {{THIS_RELEASE_VERSION}}" --branch vs{{THIS_RELEASE_VERSION}} --repo https://github.com/dotnet/msbuild`
+- [ ]  If the branch was created before the fork: fast-forward merge the correct commit (the one that is currently inserted to VS main) to the `vs{{THIS_RELEASE_VERSION}}` branch \
+e.g.: `git push upstream 2e6f2ff7ea311214255b6b2ca5cc0554fba1b345:refs/heads/vs17.10` \
+_(This is for the case where we create the branch too early and want it to be based actually on a different commit. If you waited until a good point in time with `main` in a clean state, just branch off and you are done. The branch should point to a good, recent spot, so the final-branding PR goes in on top of the right set of commits.)_
+- [ ]  Update the branch merge flow in `dotnet/versions` to have the currently-in-servicing branches: {{URL_OF_VERSIONS_PR}}
+- [ ]  Fix OptProf data flow for the new vs{{THIS_RELEASE_VERSION}} branch
+  - [ ] Manually run [OptProf data collection](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=17389) pipeline for vs{{THIS_RELEASE_VERSION}} ('Run pipeline' in upper right)
+  - [ ] Run the [official build](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434) for vs{{THIS_RELEASE_VERSION}} without OptProf (set `SkipApplyOptimizationData` variable in 'Advanced options' section of the 'Run pipeline' menu to `true`)
+  - [ ] Run the [official build](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434) for vs{{THIS_RELEASE_VERSION}} with no extra customization - OptProf should succeed now
+- [ ]  Create {{NEXT_VERSION}} branding PR (in main): {{URL_OF_NEXT_VERSION_BRANDING_PR}}
+- [ ]  Create {{THIS_RELEASE_VERSION}} localization ticket: https://aka.ms/ceChangeLocConfig (requesting to add localization for {{THIS_RELEASE_VERSION}}): {{URL_OF_LOCALIZATION_TICKET}}
+https://ceapex.visualstudio.com/CEINTL/_workitems/edit/957875 (DONE)
+- [ ]  Enable {{THIS_RELEASE_VERSION}} localization - by setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/vs{{THIS_RELEASE_VERSION}}/.vsts-dotnet.yml) to `true`
+- [ ]  Disable {{PREVIOUS_RELEASE_VERSION}} localization -  by setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/vs{{PREVIOUS_RELEASE_VERSION}}/.vsts-dotnet.yml) to `false` clarify with @JanKrivanek
+- [ ]  Merge {{NEXT_VERSION}} branding PR
+- [ ]  Create and merge PR including public API baseline package version change (see https://github.com/dotnet/msbuild/pull/8116#discussion_r1049386978): #8949
+- [ ]  When VS main snaps to {{THIS_RELEASE_VERSION}} and updates its version to {{NEXT_VERSION}}, modify the VS insertion so that it flows from MSBuild main to VS main.
+- [ ]  Create {{PREVIOUS_RELEASE_VERSION}} localization ticket: https://aka.ms/ceChangeLocConfig (requesting to remove localization for {{PREVIOUS_RELEASE_VERSION}})
+{{URL_OF_LOCALIZATION_DISABLE_TICKET}}
+- [ ]  Remove MSBuild main from the experimental VS insertion flow.
+- [ ]  Update the [release-branch insertion release definition](https://dev.azure.com/devdiv/DevDiv/_releaseDefinition?definitionId=2153&_a=definition-variables) to have `InsertTargetBranch` `rel/d{{THIS_RELEASE_VERSION}}`.
+- [ ]  Turn [the release pipeline](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=2153&view=mine&_a=releases) back on.
+- [ ]  Prepare final branding PR for `vs{{THIS_RELEASE_VERSION}}`: {{URL_OF_FINAL_BRANDING_PR}}
+- [ ]  Merge final branding to `vs{{THIS_RELEASE_VERSION}}` branch
+- [ ]  Update perfstar MSBuild insertions configuration: [example PR](https://dev.azure.com/devdiv/DevDiv/_git/dotnet-perfstar/pullrequest/522843): {{URL_OF_PERFSTAR_PR}}
+- [ ] Note down the build (will be helpful for requesting nuget packages publishing): {{URL_OF_BUILD}}
+- [ ] Get M2 or QB approval as necessary per the VS schedule
+- [ ]  Merge to VS (babysit the automatically generated VS insertion PR https://devdiv.visualstudio.com/DevDiv/_git/VS/pullrequests for the MSBuild commit noted in above step): {{URL_OF_VS_INSERTION}}
+- [ ] Update the PackageValidationBaselineVersion to the latest released version ({{THIS_RELEASE_VERSION}}.0) - this might require temporary addition of the [build artifacts feed](https://github.com/dotnet/msbuild/blob/29397b577e3ec0fe0c7650c3ab0400909655dc88/NuGet.config#L9) as the new version is not yet added to the official feeds (this is post release). This can trigger a high severity CG error (https://eng.ms/docs/cloud-ai-platform/devdiv/one-engineering-system-1es/1es-docs/secure-supply-chain/how-to-securely-configure-package-source-files) - however it should be fine to keep this temporary feed untill the release.
+
+## ASAP On/After GA:
+
+Timing based on the [(Microsoft-internal) release schedule](https://dev.azure.com/devdiv/DevDiv/_wiki/wikis/DevDiv.wiki/10097/Dev17-Release).
+
+- [ ]  Push packages to nuget.org (not currently automated, contact dnceng - search "Publish MSBuild 17.6 to NuGet.org" email subject for template).
+- [ ]  Publish docs: submit reference request at https://aka.ms/publishondocs
+  - Click on the link labeled *Request – Reference Publishing*
+  - You can use existing [ticket](https://dev.azure.com/msft-skilling/Content/_workitems/edit/183613) as a reference
+- [ ] Remove the temporarily added [build feed from `nuget.config`](https://github.com/dotnet/msbuild/blob/29397b577e3ec0fe0c7650c3ab0400909655dc88/NuGet.config#L9) if it was added in the `Update the PackageValidationBaselineVersion` step
+- [ ]  Update `main` subscriptions to the new channel (this can be done before or after release - depending on when the source repos from our previous - VS {{THIS_RELEASE_VERSION}} - channle start to publish in the next - VS {{NEXT_VERSION}} - channel) \
+`darc get-subscriptions --exact --target-repo https://github.com/dotnet/msbuild --target-branch main`
+- [ ]  Create the {{THIS_RELEASE_VERSION}} release
+  - [ ]  Create tag (can be done upfront)
+  ```
+  git checkout <commit noted above>
+  git tag v{{THIS_RELEASE_VERSION}}.3
+  git push upstream v{{THIS_RELEASE_VERSION}}.3
+  ```
+  - [ ]  Create Release in Github with `Create Release from Tag` GH option (https://github.com/dotnet/msbuild/releases/new?tag=v17.9.3) - the release notes can be prepopulated (`Generate Release Notes`)
diff --git a/documentation/specs/proposed/BuildCheck-Architecture.md b/documentation/specs/proposed/BuildCheck-Architecture.md
index 70f64146ca8..f819a3d8d22 100644
--- a/documentation/specs/proposed/BuildCheck-Architecture.md
+++ b/documentation/specs/proposed/BuildCheck-Architecture.md
@@ -84,10 +84,36 @@ Planned model:
 
 **TBD** - implementation details to be amended by @f-alizada 
 
+## High-level logic
+
+MSBuild engine always finds and parses relevant `.editorconfig` files to see which analyzers should be enabled, if any. In typical builds this operation will not be expensive compared to everything else happening as part of building a project. It's a new cost to all builds though, and in the unlikely case that it starts showing as a perf bottleneck, we can cache the data relevant to MSBuild in a separate intermediate file, in a process-wide in-memory cache invalidated by timestamp checks, and so on.
+
+The rest of the configuration comes directly or indirectly from project files in the form of properties, which creates an interesting ordering issue. For the engine to know the final values of properties such as `TargetFramework`, it needs to evaluate the project. However, if it turns out that an analyzer should be enabled that is interested in _tracing_ the evaluation, it is already too late. It's important to note that this issue exists only for a subset of analyzers. Analyzers interested in the _result_ of evaluation, for example, are fine. The best way of handling this would be to simply evaluate again. Technically, we only need to finish Pass 1 of evaluation to know the value of properties and have the relevant property functions called, so the extra work can be limited to pass 0 and 1. Measurements show that 75% of evaluation is spent in passes 0 and 1. In the very worst case when an extra pass 0/1 runs for each project and lacks any kind of further optimization, single-process incremental build of OrchardCore has been measured to take about 5% longer. There are opportunities for optimizing this, for example by adding a marker to SDK targets files notifying MSBuild of the point after which `TargetFramework` is expected to be fixed so the engine can bail early.
+
+Once `TargetFramework` is known, we can combine the default analyzer config with what came from `.editorconfig`, restart evaluation if an evaluation-tracing analyzer just got enabled, and continue with the rest of the build. Unlike `TargetFramework` which has an additive effect on the enabled analyzers, a master switch like `RunMSBuildChecks` may instruct the engine to not run anything. It would be unfortunate if the user had to pay any extra cost when `RunMSBuildChecks` evaluates to false. So preferrably we don't do anything perf sensitive until we hit the point in evaluation when `TargetFramework`, `RunMSBuildChecks`, `SdkAnalysisLevel`, ... are all known and the set of analyzers to use is finalized.
+
+Since we are unlikely to enable any analyzers by default in .NET 9, the focus in this release should be on optimizing the `.editorconfig` handling.
+
 # Acquisition
 
-**TBD** - implementation details to be amended by @YuliiaKovalova
+BuildCheck employs two distinct types of analyzers: inbox and custom. As a result, the acquisition and distribution processes vary.
+Inbox rules are integrated into the MSBuild repository, while custom analyzers can be packaged as NuGet packages and detected by MSBuild provided they adhere to a specific structure. 
+
+To streamline the creation of custom rules, a special [template](https://learn.microsoft.com/dotnet/core/tools/custom-templates) has been introduced.
+To enable MSBuild to recognize a custom analyzer, it must invoke the intrinsic function [`void RegisterBuildCheck(string path)`](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/src/Build/Evaluation/IntrinsicFunctions.cs#L700), which requires the path to the assembly as input. Therefore, it's essential for the user to ensure that the assembly exists in the specified location.
+Additionally, the custom rule must use [`BuildAnalyzerRule`](https://github.com/dotnet/msbuild/blob/9cdb3615adb4115f92b390de2f258fac5f320909/src/Build/BuildCheck/API/BuildAnalyzerRule.cs#L11C14-L11C31) as a parent class; otherwise, MSBuild will not register it.
+
+Examples of custom rules can be found in the [end-to-end tests](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/src/BuildCheck.UnitTests/EndToEndTests.cs#L139), showcasing various scenarios:
+
+1. [`Single Custom Rule Packaged as a NuGet Package`](https://github.com/dotnet/msbuild/tree/main/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate): Demonstrates the implementation of a custom rule encapsulated within a NuGet package. It contains the process of creating, packaging, and integrating a single custom rule into a project.
+2. [`Project with Multiple Analyzers Referenced`](https://github.com/dotnet/msbuild/tree/main/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected): Illustrates a project setup where multiple custom analyzers are referenced. This scenario is common in larger projects where multiple rule sets need to be enforced simultaneously.
+
+Important Notes: 
+- In these examples, pay attention to the presence of the `CustomAnalyzerName.props` file. This file contains intrinsic function invocations necessary for successful rule registration. Understanding and correctly implementing these invocations are crucial for integrating custom rules into your projects effectively.
+- The examples do not include references to third-party assemblies that might be required in other custom analyzers. To load the custom instance in MSBuild, third-party assemblies have to be included in the NuGet package. The current implementation achieves this goal by using a special target: [AddNuGetDlls](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj#L22).
 
+### Future Enhancements
+As our library of custom rules expands, we plan to enrich this section with real-world production rule examples. These examples will showcase a diverse range of rules addressing common development challenges. Once these production rules are published and available on nuget.org, we will update this documentation accordingly.
 
 # Build OM for Analyzers Authoring
 
diff --git a/documentation/specs/proposed/BuildCheck-feature-threat-model.md b/documentation/specs/proposed/BuildCheck-feature-threat-model.md
new file mode 100644
index 00000000000..feeb937433a
--- /dev/null
+++ b/documentation/specs/proposed/BuildCheck-feature-threat-model.md
@@ -0,0 +1,84 @@
+
+# Threat model of MSBuild BuildCheck feature
+
+## BuildCheck Feature Description
+
+The infrastructure within MSBuild allowing pluggability and execution of
+Analyzers and their Rules previously known as "warning waves" and
+"MSBuild Analyzers".
+
+The feature is meant to help customers to improve and understand quality of their MSBuild scripts via rules violations reporting. It will allow MSBuild to gradually roll out additional rules, as users will be capable to configure their opt-in and severity of reports – preventing unwanted build breakages. And to equip powerusers to roll out their own quality checks – whether for general community or internal enterprise usage.
+
+[Design
+Spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck.md)
+
+[Architecture](https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md)
+
+# Threats Identification
+
+This feature does not alter existing nor create any new trust boundaries.
+
+It is assumed to rely on only trusted sources, be managed by trusted operators, and operated on trusted machines.
+
+For this document, we do not address any threats that result from violating these conditions.
+
+## Acquisition
+
+### Threat: Supply chain attack on custom analyzer
+
+Custom BuildCheck analyzers are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box.
+
+#### Mitigation
+
+Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
+
+Custom analyzers are delivered as regular nuget packages by MSBuild `<PackageReference />` element.
+Users is expected to implement process to detect and warn about known malicious custom analyzers.
+
+## Execution
+
+### Threat: Supply chain attack by custom analyzer
+
+Custom BuildCheck analyzers are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box, with intent to inject malicious behavior into build artifacts.
+
+#### Mitigation
+
+Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
+
+### Threat: Third-Party Vulnerabilities
+Vulnerabilities in custom analyzer or its dependencies.
+
+#### Mitigation
+
+Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
+
+## Configuration
+
+### Threat: Malicious configuration value
+
+Although .editorconfig shall be part of trusted sources, and hence not malicious, .editorconfig is looked up in parent folders up to the root. This can allow attacked to store malicious editor config up in parent folders with intent of disabling an analyzer or cause build malfunction for any reason.
+
+#### Mitigation
+
+This problem is identical to existing .editorconfig for Roslyn analyzers and since we share code for parsing it, we adopt same mitigation strategy, which is:
+
+- default template for editor config has `root = true` stopping parent config traversing
+- code is unit tested to verify and sanitize .editorconfig values
+
+### Threat: Intentional analyzer ID conflict or misleading ID
+
+Malicious actors can define analyzer ID to be identical or like existing well known analyzer ID to increase probability of executing malicious analyzer code.
+
+#### Mitigation
+
+Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
+
+## Declaration
+
+### Threat: Malicious analyzer registration property function
+
+Threat actor can write malicious analyzer registration property function in project files, with intent to run code from non-governed assemblies.
+
+#### Mitigation
+
+This threat is out of scope of this document, as this requires malicious modification of source code (repository) making these sources untrusted.
diff --git a/documentation/specs/proposed/BuildCheck.md b/documentation/specs/proposed/BuildCheck.md
index a6266df45d4..4fa78061b78 100644
--- a/documentation/specs/proposed/BuildCheck.md
+++ b/documentation/specs/proposed/BuildCheck.md
@@ -22,9 +22,11 @@ Users are able to tune the behavior of the checks via `.editorconfig` which brin
 
 Powerusers are able to develop, test and publish their custom analyzers easily and contribute them back to community. The local development scenario doesn’t require roundtrip through packaging.
 
-A solid set of in-the-box analyzers is provided by MSBuild and the .NET SDK, extended each release, with high quality reports (pointing exact locations of issue, offering clear and actionable explanations, not repetitive for builds with multi-execution or/and multi-importing of a same script in single build context). The existing in-the-box analyzers are gradually enabled by default and their severity increased - in waves (likely tied to sdk releases) - aiming to constantly increase quality of our customers build scripts. MSBuild.exe (and hence Visual Studio) builds will take more conservative approach with requiring an explicit opt-in into the analyzers - in order to not introduce upgrade blockers. 
+A solid set of in-the-box analyzers is provided by MSBuild and the .NET SDK, extended each release, with high quality reports (pointing exact locations of issue, offering clear and actionable explanations, not repetitive for builds with multi-execution or/and multi-importing of a same script in single build context). The existing in-the-box analyzers are gradually enabled by default and their severity increased - in waves (likely tied to sdk releases) - aiming to constantly increase the quality of our customers build scripts. To avoid breaking customers builds, there will still be an explicit user gesture required to opt into running the analysis. This will be done either by configuring the analyzers with `.editorconfig` or auto-enabling the analysis based on the TFM of the project. There will be no difference between building with `dotnet build` and with `MSBuild.exe`, they will follow the same enablement rules with the set of enabled built-in analyzers derived from `.editorconfig` and TFM/props. Building in Visual Studio will eventually reach parity with command-line build as well.
 
-The analysis has small impact on build duration with ability to disable analysis altogether which will remove all the performance costs associated with the analysis. The perf impact on representative projects is continuously monitored and documented by the MsBuild team.
+Projects that don't use the .NET SDK and those that are not SDK-style at all are TBD. There is a possibility of using a property like `MSBuildAnalysisLevel` to enable some base analyzers we believe will add value everywhere.
+
+The analysis has small impact on build duration with ability to disable analysis altogether which will remove all the performance costs associated with the analysis. The perf impact on representative projects is continuously monitored and documented by the MSBuild team.
 
 
 # Scope of initial iteration
@@ -99,7 +101,7 @@ The proposed initial configuration for those is TBD (as well based on initial te
 
 ### Live Build
 
-BuildCheck will run as part of the build and execute [inbox analyzers](#inbox-analyzers) and [custom analyzers](#acquisition-of-custom-analyzers) based on the [configuration](#configuration). Users will have an option to completely opt-out from BuildCheck to run via commandline switch.
+BuildCheck will run as part of the build and execute [inbox analyzers](#inbox-analyzers) and [custom analyzers](#acquisition-of-custom-analyzers) based on the [configuration](#configuration). Users will have an option to completely opt-out from BuildCheck to run via an MSBuild property (could be set in a project file or passed on the commandline).
 
 Findings - reports - of analyzers will be output as build messages/warnings/errors, and the message/warnings/error code should help distinguish BuildCheck produced reports from regular build errors/warnings.
 
@@ -128,9 +130,20 @@ We might as well consider specifying custom analyzers on a command line (as a no
 
 There will be 3 mechanisms of configuring the analyzers and rules:
 * The default configuration declared by the analyzers themselves ([more details on implementation](#rules-declaration))
-* [Sdk Analysis Level property](https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md) – mostly for the inbox analyzers
+* The TFM of the project and the [Sdk Analysis Level property](https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md) – mostly for the inbox analyzers
 * `.editorconfig` file
 
+We will also consider respecting `SdkAnalysisLevel` to override the per-TFM defaults. Additionally, we may introduce a new "master switch" property, tentatively called `RunMSBuildChecks`, to make it possible to disable everything whole-sale. This would be used in scenarios like F5 in VS.
+```
+Skipping analyzers to speed up the build. You can execute 'Build' or 'Rebuild' command to run analyzers.
+```
+
+Here's the proposed release schedule:
+- **.NET 9** - the feature is introduced and enabled in `dotnet build` and `MSBuild.exe` command-line builds. It is not enabled in VS just yet. No analyzers are enabled by default. It is not technically required to read the TFM or any other props during evaluation, though it would be nice to respect `RunMSBuildChecks` already in this release. `.editorconfig` can be the sole source of configuration.
+- **.NET 10** - based on feedback and testing, we choose a set of analyzers to enable by default for projects targeting `net10.0`, and enable the feature as a whole in Visual Studio. Depending on how we feel about the perf characteristics of evaluation, especially the "double evaluation" mandated by discovering evaluation-tracking analyzers just-in-time, we may want to omit such analyzers from the default set.
+- **.NET 11** and beyond - some more analyzers are enabled for projects targeting `net11.0`, the `net10.0` does not change. Everything is mature and performant enough that we are able to auto-enable any analyzer. The gradual tightening of rules enabled by default gets us closer to the long envisioned "strict mode", which will ultimately allow us to evolve MSBuild to be simpler and more performant.
+
+
 For the `.editorconfig` file configuration, following will apply:
 * Only `.editorconfig` files collocated with the project file or up the folder hierarchy will be considered.
 * `.editorconfig` files placed along with explicitly or implicitly imported msbuild files won’t be considered.
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 7744d96a090..c30d03cea0f 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -27,6 +27,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Log TaskParameterEvent for scalar parameters](https://github.com/dotnet/msbuild/pull/9908)
 - [Convert.ToString during a property evaluation uses the InvariantCulture for all types](https://github.com/dotnet/msbuild/pull/9874)
 - [Fix oversharing of build results in ResultsCache](https://github.com/dotnet/msbuild/pull/9987)
+- [Add ParameterName and PropertyName to TaskParameterEventArgs](https://github.com/dotnet/msbuild/pull/10130)
 
 ### 17.10
 - [AppDomain configuration is serialized without using BinFmt](https://github.com/dotnet/msbuild/pull/9320) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
diff --git a/eng/BootStrapMsBuild.targets b/eng/BootStrapMsBuild.targets
index 07531f6633b..9209876eecf 100644
--- a/eng/BootStrapMsBuild.targets
+++ b/eng/BootStrapMsBuild.targets
@@ -191,6 +191,15 @@
           DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\arm64\%(RecursiveDir)%(Filename)%(Extension)')"
           SkipUnchangedFiles="true" />
 
+    <!-- Disable workload resolver until we can figure out whether it can work in the bootstrap
+         https://github.com/dotnet/msbuild/issues/6566 -->
+    <MakeDir Directories="$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver" />
+    <Touch Files="$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\DisableWorkloadResolver.sentinel"
+           AlwaysCreate="true" />
+
+    <MakeDir Directories="$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver" />
+    <Touch Files="$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\DisableWorkloadResolver.sentinel"
+           AlwaysCreate="true" />
   </Target>
 
   <Target Name="BootstrapNetCore" DependsOnTargets="CleanBootstrapFolder">
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index bab7c907f04..31ea4f25ae9 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -2,9 +2,9 @@
 <Dependencies>
   <ProductDependencies>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.24163.3">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.24257.2">
       <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>79827eed138fd2575a8b24820b4f385ee4ffb6e6</Sha>
+      <Sha>6ed73280a6d70f7e7ac39c86f2abe8c10983f0bb</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
@@ -67,14 +67,14 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24204.3">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24270.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>188340e12c0a372b1681ad6a5e72c608021efdba</Sha>
+      <Sha>f2b2071632d5d4c46d0f904f2b0d917b1752551b</Sha>
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="8.0.0-beta.24204.3">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="8.0.0-beta.24270.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>188340e12c0a372b1681ad6a5e72c608021efdba</Sha>
+      <Sha>f2b2071632d5d4c46d0f904f2b0d917b1752551b</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23475.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
@@ -87,18 +87,18 @@
       <Sha>73f0850939d96131c28cf6ea6ee5aacb4da0083a</Sha>
       <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.10.0-preview.2.97">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.11.0-preview.2.66">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>fb50d1a45ed10b39b5f335bc3a4bdcaea9b951cf</Sha>
+      <Sha>a7131d98a28b0be1d21a125b5660fc8782c27ace</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24216.12">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.11.0-2.24274.2">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>3af0081a6e811b78d37c62e479914f7f4cfb0d1a</Sha>
+      <Sha>2e1435d1aadd8ddb90a171e207e3cb2ae67253f2</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24204.3">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24270.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>188340e12c0a372b1681ad6a5e72c608021efdba</Sha>
+      <Sha>f2b2071632d5d4c46d0f904f2b0d917b1752551b</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 939fba9aa49..fc9efd23ecf 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -48,11 +48,11 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24204.3</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24270.4</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24216.12</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.10.0-preview.2.97</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.11.0-2.24274.2</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.11.0-preview.2.66</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
diff --git a/eng/common/templates-official/job/source-index-stage1.yml b/eng/common/templates-official/job/source-index-stage1.yml
index f0513aee5b0..43ee0c202fc 100644
--- a/eng/common/templates-official/job/source-index-stage1.yml
+++ b/eng/common/templates-official/job/source-index-stage1.yml
@@ -1,6 +1,7 @@
 parameters:
   runAsPublic: false
-  sourceIndexPackageVersion: 1.0.1-20230228.2
+  sourceIndexUploadPackageVersion: 2.0.0-20240502.12
+  sourceIndexProcessBinlogPackageVersion: 1.0.1-20240129.2
   sourceIndexPackageSource: https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json
   sourceIndexBuildCommand: powershell -NoLogo -NoProfile -ExecutionPolicy Bypass -Command "eng/common/build.ps1 -restore -build -binarylog -ci"
   preSteps: []
@@ -14,15 +15,15 @@ jobs:
   dependsOn: ${{ parameters.dependsOn }}
   condition: ${{ parameters.condition }}
   variables:
-  - name: SourceIndexPackageVersion
-    value: ${{ parameters.sourceIndexPackageVersion }}
+  - name: SourceIndexUploadPackageVersion
+    value: ${{ parameters.sourceIndexUploadPackageVersion }}
+  - name: SourceIndexProcessBinlogPackageVersion
+    value: ${{ parameters.sourceIndexProcessBinlogPackageVersion }}
   - name: SourceIndexPackageSource
     value: ${{ parameters.sourceIndexPackageSource }}
   - name: BinlogPath
     value: ${{ parameters.binlogPath }}
-  - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
-    - group: source-dot-net stage1 variables
-  - template: /eng/common/templates-official/variables/pool-providers.yml
+  - template: /eng/common/templates/variables/pool-providers.yml
 
   ${{ if ne(parameters.pool, '') }}:
     pool: ${{ parameters.pool }}
@@ -33,24 +34,23 @@ jobs:
         demands: ImageOverride -equals windows.vs2019.amd64.open
       ${{ if eq(variables['System.TeamProject'], 'internal') }}:
         name: $(DncEngInternalBuildPool)
-        image: windows.vs2022.amd64
-        os: windows
+        demands: ImageOverride -equals windows.vs2019.amd64
 
   steps:
   - ${{ each preStep in parameters.preSteps }}:
     - ${{ preStep }}
 
   - task: UseDotNet@2
-    displayName: Use .NET Core SDK 6
+    displayName: Use .NET 8 SDK
     inputs:
       packageType: sdk
-      version: 6.0.x
+      version: 8.0.x
       installationPath: $(Agent.TempDirectory)/dotnet
       workingDirectory: $(Agent.TempDirectory)
 
   - script: |
-      $(Agent.TempDirectory)/dotnet/dotnet tool install BinLogToSln --version $(SourceIndexPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
-      $(Agent.TempDirectory)/dotnet/dotnet tool install UploadIndexStage1 --version $(SourceIndexPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
+      $(Agent.TempDirectory)/dotnet/dotnet tool install BinLogToSln --version $(sourceIndexProcessBinlogPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
+      $(Agent.TempDirectory)/dotnet/dotnet tool install UploadIndexStage1 --version $(sourceIndexUploadPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
     displayName: Download Tools
     # Set working directory to temp directory so 'dotnet' doesn't try to use global.json and use the repo's sdk.
     workingDirectory: $(Agent.TempDirectory)
@@ -62,7 +62,24 @@ jobs:
     displayName: Process Binlog into indexable sln
 
   - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
-    - script: $(Agent.TempDirectory)/.source-index/tools/UploadIndexStage1 -i .source-index/stage1output -n $(Build.Repository.Name)
-      displayName: Upload stage1 artifacts to source index
-      env:
-        BLOB_CONTAINER_URL: $(source-dot-net-stage1-blob-container-url)
+    - task: AzureCLI@2
+      displayName: Get stage 1 auth token
+      inputs:
+        azureSubscription: 'SourceDotNet Stage1 Publish'
+        addSpnToEnvironment: true
+        scriptType: 'ps'
+        scriptLocation: 'inlineScript'
+        inlineScript: |
+          echo "##vso[task.setvariable variable=ARM_CLIENT_ID]$env:servicePrincipalId"
+          echo "##vso[task.setvariable variable=ARM_ID_TOKEN]$env:idToken"
+          echo "##vso[task.setvariable variable=ARM_TENANT_ID]$env:tenantId"
+
+    - script: |
+        echo "Client ID: $(ARM_CLIENT_ID)"
+        echo "ID Token: $(ARM_ID_TOKEN)"
+        echo "Tenant ID: $(ARM_TENANT_ID)"
+        az login --service-principal -u $(ARM_CLIENT_ID) --tenant $(ARM_TENANT_ID) --allow-no-subscriptions --federated-token $(ARM_ID_TOKEN)
+      displayName: "Login to Azure"
+
+    - script: $(Agent.TempDirectory)/.source-index/tools/UploadIndexStage1 -i .source-index/stage1output -n $(Build.Repository.Name) -s netsourceindexstage1 -b stage1
+      displayName: Upload stage1 artifacts to source index
\ No newline at end of file
diff --git a/eng/common/templates/job/source-index-stage1.yml b/eng/common/templates/job/source-index-stage1.yml
index b98202aa02d..43ee0c202fc 100644
--- a/eng/common/templates/job/source-index-stage1.yml
+++ b/eng/common/templates/job/source-index-stage1.yml
@@ -1,6 +1,7 @@
 parameters:
   runAsPublic: false
-  sourceIndexPackageVersion: 1.0.1-20230228.2
+  sourceIndexUploadPackageVersion: 2.0.0-20240502.12
+  sourceIndexProcessBinlogPackageVersion: 1.0.1-20240129.2
   sourceIndexPackageSource: https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json
   sourceIndexBuildCommand: powershell -NoLogo -NoProfile -ExecutionPolicy Bypass -Command "eng/common/build.ps1 -restore -build -binarylog -ci"
   preSteps: []
@@ -14,14 +15,14 @@ jobs:
   dependsOn: ${{ parameters.dependsOn }}
   condition: ${{ parameters.condition }}
   variables:
-  - name: SourceIndexPackageVersion
-    value: ${{ parameters.sourceIndexPackageVersion }}
+  - name: SourceIndexUploadPackageVersion
+    value: ${{ parameters.sourceIndexUploadPackageVersion }}
+  - name: SourceIndexProcessBinlogPackageVersion
+    value: ${{ parameters.sourceIndexProcessBinlogPackageVersion }}
   - name: SourceIndexPackageSource
     value: ${{ parameters.sourceIndexPackageSource }}
   - name: BinlogPath
     value: ${{ parameters.binlogPath }}
-  - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
-    - group: source-dot-net stage1 variables
   - template: /eng/common/templates/variables/pool-providers.yml
 
   ${{ if ne(parameters.pool, '') }}:
@@ -40,16 +41,16 @@ jobs:
     - ${{ preStep }}
 
   - task: UseDotNet@2
-    displayName: Use .NET Core SDK 6
+    displayName: Use .NET 8 SDK
     inputs:
       packageType: sdk
-      version: 6.0.x
+      version: 8.0.x
       installationPath: $(Agent.TempDirectory)/dotnet
       workingDirectory: $(Agent.TempDirectory)
 
   - script: |
-      $(Agent.TempDirectory)/dotnet/dotnet tool install BinLogToSln --version $(SourceIndexPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
-      $(Agent.TempDirectory)/dotnet/dotnet tool install UploadIndexStage1 --version $(SourceIndexPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
+      $(Agent.TempDirectory)/dotnet/dotnet tool install BinLogToSln --version $(sourceIndexProcessBinlogPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
+      $(Agent.TempDirectory)/dotnet/dotnet tool install UploadIndexStage1 --version $(sourceIndexUploadPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
     displayName: Download Tools
     # Set working directory to temp directory so 'dotnet' doesn't try to use global.json and use the repo's sdk.
     workingDirectory: $(Agent.TempDirectory)
@@ -61,7 +62,24 @@ jobs:
     displayName: Process Binlog into indexable sln
 
   - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
-    - script: $(Agent.TempDirectory)/.source-index/tools/UploadIndexStage1 -i .source-index/stage1output -n $(Build.Repository.Name)
-      displayName: Upload stage1 artifacts to source index
-      env:
-        BLOB_CONTAINER_URL: $(source-dot-net-stage1-blob-container-url)
+    - task: AzureCLI@2
+      displayName: Get stage 1 auth token
+      inputs:
+        azureSubscription: 'SourceDotNet Stage1 Publish'
+        addSpnToEnvironment: true
+        scriptType: 'ps'
+        scriptLocation: 'inlineScript'
+        inlineScript: |
+          echo "##vso[task.setvariable variable=ARM_CLIENT_ID]$env:servicePrincipalId"
+          echo "##vso[task.setvariable variable=ARM_ID_TOKEN]$env:idToken"
+          echo "##vso[task.setvariable variable=ARM_TENANT_ID]$env:tenantId"
+
+    - script: |
+        echo "Client ID: $(ARM_CLIENT_ID)"
+        echo "ID Token: $(ARM_ID_TOKEN)"
+        echo "Tenant ID: $(ARM_TENANT_ID)"
+        az login --service-principal -u $(ARM_CLIENT_ID) --tenant $(ARM_TENANT_ID) --allow-no-subscriptions --federated-token $(ARM_ID_TOKEN)
+      displayName: "Login to Azure"
+
+    - script: $(Agent.TempDirectory)/.source-index/tools/UploadIndexStage1 -i .source-index/stage1output -n $(Build.Repository.Name) -s netsourceindexstage1 -b stage1
+      displayName: Upload stage1 artifacts to source index
\ No newline at end of file
diff --git a/global.json b/global.json
index 7c11ef6ece2..a2815a8c542 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
     "xcopy-msbuild": "17.8.5"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.24204.3"
+    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.24270.4"
   }
 }
diff --git a/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs b/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs
index 8cfb2d4a575..a0d79660060 100644
--- a/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs
@@ -7,6 +7,7 @@
 using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -52,7 +53,11 @@ public void GetBuckets()
             properties.Set(ProjectPropertyInstance.Create("UnitTests", "unittests.foo"));
             properties.Set(ProjectPropertyInstance.Create("OBJ", "obj"));
 
-            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), MockElementLocation.Instance);
+            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(
+                parameters,
+                CreateLookup(itemsByType, properties),
+                MockElementLocation.Instance,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             Assert.Equal(5, buckets.Count);
 
@@ -62,7 +67,14 @@ public void GetBuckets()
                 XmlAttribute tempXmlAttribute = (new XmlDocument()).CreateAttribute("attrib");
                 tempXmlAttribute.Value = "'$(Obj)'=='obj'";
 
-                Assert.True(ConditionEvaluator.EvaluateCondition(tempXmlAttribute.Value, ParserOptions.AllowAll, bucket.Expander, ExpanderOptions.ExpandAll, Directory.GetCurrentDirectory(), MockElementLocation.Instance, null, new BuildEventContext(1, 2, 3, 4), FileSystems.Default));
+                Assert.True(ConditionEvaluator.EvaluateCondition(
+                    tempXmlAttribute.Value,
+                    ParserOptions.AllowAll,
+                    bucket.Expander, ExpanderOptions.ExpandAll,
+                    Directory.GetCurrentDirectory(),
+                    MockElementLocation.Instance,
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
                 Assert.Equal("a.doc;b.doc;c.doc;d.doc;e.doc", bucket.Expander.ExpandIntoStringAndUnescape("@(doc)", ExpanderOptions.ExpandItems, MockElementLocation.Instance));
                 Assert.Equal("unittests.foo", bucket.Expander.ExpandIntoStringAndUnescape("$(bogus)$(UNITTESTS)", ExpanderOptions.ExpandPropertiesAndMetadata, MockElementLocation.Instance));
             }
@@ -130,7 +142,11 @@ public void ValidUnqualifiedMetadataReference()
 
             PropertyDictionary<ProjectPropertyInstance> properties = new PropertyDictionary<ProjectPropertyInstance>();
 
-            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), null);
+            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(
+                parameters,
+                CreateLookup(itemsByType, properties),
+                null,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             Assert.Equal(2, buckets.Count);
         }
 
@@ -164,7 +180,11 @@ public void InvalidUnqualifiedMetadataReference()
 
                 // This is expected to throw because not all items contain a value for metadata "Culture".
                 // Only a.foo has a Culture metadata.  b.foo does not.
-                BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), MockElementLocation.Instance);
+                BatchingEngine.PrepareBatchingBuckets(
+                    parameters,
+                    CreateLookup(itemsByType, properties),
+                    MockElementLocation.Instance,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             });
         }
         /// <summary>
@@ -185,7 +205,11 @@ public void NoItemsConsumed()
                 PropertyDictionary<ProjectPropertyInstance> properties = new PropertyDictionary<ProjectPropertyInstance>();
 
                 // This is expected to throw because we have no idea what item list %(Culture) refers to.
-                BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), MockElementLocation.Instance);
+                BatchingEngine.PrepareBatchingBuckets(
+                    parameters,
+                    CreateLookup(itemsByType, properties),
+                    MockElementLocation.Instance,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             });
         }
         /// <summary>
@@ -211,7 +235,11 @@ public void Regress_Mutation_DuplicateBatchingBucketsAreFoldedTogether()
 
             PropertyDictionary<ProjectPropertyInstance> properties = new PropertyDictionary<ProjectPropertyInstance>();
 
-            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), null);
+            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(
+                parameters,
+                CreateLookup(itemsByType, properties),
+                null,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             // If duplicate buckets have been folded correctly, then there will be exactly one bucket here
             // containing both a.foo and b.foo.
diff --git a/src/Build.UnitTests/BackEnd/MockHost.cs b/src/Build.UnitTests/BackEnd/MockHost.cs
index 920e49b51e1..1ff79810e54 100644
--- a/src/Build.UnitTests/BackEnd/MockHost.cs
+++ b/src/Build.UnitTests/BackEnd/MockHost.cs
@@ -5,7 +5,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
-using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Engine.UnitTests.BackEnd;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
diff --git a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
index 66a27a4e9d6..f94ef7e8ec0 100644
--- a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
@@ -83,7 +83,7 @@ public void TestConstructorNullTarget()
                 BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
                 BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
                 Lookup lookup = new Lookup(new ItemDictionary<ProjectItemInstance>(project.Items), new PropertyDictionary<ProjectPropertyInstance>(project.Properties));
-                TargetEntry entry = new TargetEntry(requestEntry, this, null, lookup, null, TargetBuiltReason.None, _host, false);
+                TargetEntry entry = new TargetEntry(requestEntry, this, null, lookup, null, TargetBuiltReason.None, _host, null, false);
             });
         }
         /// <summary>
@@ -97,7 +97,7 @@ public void TestConstructorNullLookup()
                 ProjectInstance project = CreateTestProject(true /* Returns enabled */);
                 BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
                 BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
-                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), null, null, TargetBuiltReason.None, _host, false);
+                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), null, null, TargetBuiltReason.None, _host, null, false);
             });
         }
         /// <summary>
@@ -113,7 +113,7 @@ public void TestConstructorNullHost()
                 BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
 
                 Lookup lookup = new Lookup(new ItemDictionary<ProjectItemInstance>(project.Items), new PropertyDictionary<ProjectPropertyInstance>(project.Properties));
-                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), lookup, null, TargetBuiltReason.None, null, false);
+                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), lookup, null, TargetBuiltReason.None, null, null, false);
             });
         }
         /// <summary>
@@ -1025,7 +1025,7 @@ private TargetEntry CreateStandardTargetEntry(ProjectInstance project, string ta
             BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
 
             Lookup lookup = new Lookup(new ItemDictionary<ProjectItemInstance>(project.Items), new PropertyDictionary<ProjectPropertyInstance>(project.Properties));
-            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(targetName, project.Targets[targetName].Location), lookup, null, TargetBuiltReason.None, _host, false);
+            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(targetName, project.Targets[targetName].Location), lookup, null, TargetBuiltReason.None, _host, null, false);
             return entry;
         }
 
@@ -1041,7 +1041,7 @@ private TargetEntry CreateStandardTargetEntry(ProjectInstance project, string ta
             BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
             config.Project = project;
             BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[1] { "foo" }), config);
-            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(target, project.Targets[target].Location), baseEntry.Lookup, baseEntry, TargetBuiltReason.None, _host, false);
+            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(target, project.Targets[target].Location), baseEntry.Lookup, baseEntry, TargetBuiltReason.None, _host, null, false);
             return entry;
         }
 
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index cd2a93acc25..d764e74ffc5 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -570,6 +570,7 @@ private DependencyAnalysisResult PerformDependencyAnalysisTestHelper(
 
                 // now do the dependency analysis
                 ItemBucket itemBucket = new ItemBucket(null, null, new Lookup(itemsByName, new PropertyDictionary<ProjectPropertyInstance>()), 0);
+                itemBucket.Initialize(null);
                 TargetUpToDateChecker analyzer = new TargetUpToDateChecker(p, p.Targets["Build"], _mockHost, BuildEventContext.Invalid);
 
                 return analyzer.PerformDependencyAnalysis(itemBucket, false, out changedTargetInputs, out upToDateTargetInputs);
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index ba22e2beed0..cdd57796d4d 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -1284,6 +1284,7 @@ private void InitializeHost(bool throwOnExecute)
             _twoItems = new ITaskItem[] { new TaskItem(item), new TaskItem(item2) };
 
             _bucket = new ItemBucket(Array.Empty<string>(), new Dictionary<string, string>(), new Lookup(itemsByName, new PropertyDictionary<ProjectPropertyInstance>()), 0);
+            _bucket.Initialize(null);
             _host.FindTask(null);
             _host.InitializeForBatch(talc, _bucket, null);
             _parametersSetOnTask = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
diff --git a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
index 1e8bcaf1f14..91d8bec792d 100644
--- a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Engine.UnitTests.TestComparers;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -2184,8 +2185,7 @@ internal TaskRegistry CreateTaskRegistryAndRegisterTasks(List<ProjectUsingTaskEl
 
             string currentDir = Directory.GetCurrentDirectory();
             TaskRegistry.InitializeTaskRegistryFromUsingTaskElements(
-                _loggingService,
-                _loggerContext,
+                _targetLoggingContext,
                 usingTaskElements.Select(el => (el, currentDir)),
                 registry,
                 RegistryExpander,
@@ -2249,7 +2249,11 @@ internal static Expander<ProjectPropertyInstance, ProjectItemInstance> GetExpand
             secondaryItemsByName.ImportItems(thirdItemGroup);
             secondaryItemsByName.ImportItems(trueItemGroup);
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, secondaryItemsByName, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(
+                pg,
+                secondaryItemsByName,
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             return expander;
         }
 
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index cb60a9f2d42..bd03a54d29a 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -650,12 +650,14 @@ public void RoundtripTaskParameterEventArgs()
                 new TaskItemData("ItemSpec1", null),
                 new TaskItemData("ItemSpec2", Enumerable.Range(1,3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
             };
-            var args = new TaskParameterEventArgs(TaskParameterMessageKind.TaskOutput, "ItemName", items, true, DateTime.MinValue);
+            var args = new TaskParameterEventArgs(TaskParameterMessageKind.TaskOutput, "ParameterName1", "PropertyName1", "ItemName1", items, true, DateTime.MinValue);
             args.LineNumber = 265;
             args.ColumnNumber = 6;
 
             Roundtrip(args,
                 e => e.Kind.ToString(),
+                e => e.ParameterName,
+                e => e.PropertyName,
                 e => e.ItemType,
                 e => e.LogItemMetadata.ToString(),
                 e => e.LineNumber.ToString(),
diff --git a/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs b/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
index 882753a8a50..4866a721238 100644
--- a/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
+++ b/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
@@ -180,7 +180,7 @@ public void ImportProperties()
         public void DeepClone()
         {
             CopyOnWritePropertyDictionary<MockValue> source = CreateInstance("a", "b", "c");
-            CopyOnWritePropertyDictionary<MockValue> clone = source.DeepClone();
+            CopyOnWritePropertyDictionary<MockValue> clone = (CopyOnWritePropertyDictionary<MockValue>)source.DeepClone();
 
             source.ShouldBe(clone);
             source.ShouldNotBeSameAs(clone);
diff --git a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
index b33fd7a00ce..f9157225a69 100644
--- a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
@@ -6,8 +6,10 @@
 using System.IO;
 using System.Text.RegularExpressions;
 using System.Xml;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -34,9 +36,9 @@ public void OverrideTasksAreFoundInOverridePath()
             string overrideDir = NativeMethodsShared.IsWindows ? "c:\\msbuildoverridetasks" : "/msbuildoverridetasks";
             Toolset t = new Toolset("toolsversionname", dir, new PropertyDictionary<ProjectPropertyInstance>(), new ProjectCollection(), new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), overrideDir, new DirectoryExists(this.directoryExists));
 
-            LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            LoggingContext loggingContext = TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
 
             string[] expectedRegisteredTasks = { "a1", "a2", "a3", "a4", "b1", "e1", "g1", "g2", "g3" };
             string[] expectedOverrideTasks = { "a1" /* special because it is in the override tasks file as well as in the tasks file*/, "oa1", "oa2", "og1", "ooo" };
@@ -79,8 +81,10 @@ public void OverrideTaskPathIsRelative()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", "msbuildoverridetasks");
@@ -96,8 +100,9 @@ public void OverrideTaskPathHasInvalidChars()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             mockLogger.AssertLogContains("MSB4194");
@@ -113,8 +118,9 @@ public void OverrideTaskPathHasTooLongOfAPath()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", tooLong);
@@ -131,8 +137,9 @@ public void OverrideTaskPathIsNotFound()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", "k:\\Thecatinthehat");
@@ -153,7 +160,8 @@ public void DefaultTasksAreFoundInToolsPath()
                 null,
                 new DirectoryExists(this.directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(null, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            LoggingContext loggingContext = TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             string[] expectedRegisteredTasks = { "a1", "a2", "a3", "a4", "b1", "e1", "g1", "g2", "g3" };
             string[] unexpectedRegisteredTasks = { "c1", "d1", "f1", "11", "12", "13", "21" };
@@ -178,10 +186,11 @@ public void WarningLoggedIfNoDefaultTasksFound()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, BuildEventContext.Invalid);
 
             Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2\\doesntexist", new PropertyDictionary<ProjectPropertyInstance>(), new ProjectCollection(), new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), null, new DirectoryExists(this.directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(service, BuildEventContext.Invalid, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             string[] unexpectedRegisteredTasks = { "a1", "a2", "a3", "a4", "b1", "c1", "d1", "e1", "f1", "g1", "g2", "g3", "11", "12", "13", "21" };
 
@@ -201,9 +210,10 @@ public void InvalidToolPath()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, BuildEventContext.Invalid);
             Toolset t = new Toolset("toolsversionname", "invalid||path", new PropertyDictionary<ProjectPropertyInstance>(), p, new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), null, new DirectoryExists(this.directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(service, BuildEventContext.Invalid, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             Console.WriteLine(mockLogger.FullLog);
             Assert.Equal(1, mockLogger.WarningCount); // "Expected a warning for invalid character in toolpath"
@@ -221,19 +231,18 @@ public void VerifyTasksFilesAreInSortedOrder()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, BuildEventContext.Invalid);
             string dir = NativeMethodsShared.IsWindows ? "c:\\directory1\\directory2" : "/directory1/directory2";
             string overrideDir = NativeMethodsShared.IsWindows ? "c:\\msbuildoverridetasks" : "/msbuildoverridetasks";
             string[] foundFiles = Toolset.GetTaskFiles(
                 new DirectoryGetFiles(this.getFiles),
-                service,
-                BuildEventContext.Invalid,
+                loggingContext,
                 "*.tasks",
                 dir,
                 String.Empty);
             string[] foundoverrideFiles = Toolset.GetTaskFiles(
                 new DirectoryGetFiles(this.getFiles),
-                service,
-                BuildEventContext.Invalid,
+                loggingContext,
                 "*.overridetasks",
                 overrideDir,
                 String.Empty);
@@ -894,7 +903,9 @@ public void InlineTasksInDotTasksFile()
                 null,
                 new DirectoryExists(directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(null, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            LoggingContext loggingContext = TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             // Did not crash due to trying to expand items without having items
         }
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 286d08a84a5..ce49dc0d6b7 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -12,6 +12,7 @@
 
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -4385,9 +4386,8 @@ public void VerifyConditionEvaluatorResetStateOnFailure()
                     ExpanderOptions.ExpandProperties,
                     Directory.GetCurrentDirectory(),
                     MockElementLocation.Instance,
-                    null,
-                    new BuildEventContext(1, 2, 3, 4),
-                    FileSystems.Default);
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
                 Assert.True(false, "Expect exception due to the value of property \"TargetOSFamily\" is not a number.");
             }
             catch (InvalidProjectFileException e)
@@ -4404,9 +4404,8 @@ public void VerifyConditionEvaluatorResetStateOnFailure()
                 ExpanderOptions.ExpandProperties,
                 Directory.GetCurrentDirectory(),
                 MockElementLocation.Instance,
-                null,
-                new BuildEventContext(1, 2, 3, 4),
-                FileSystems.Default));
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
         }
 
         /// <summary>
@@ -4991,7 +4990,6 @@ public void VerifyLogPropertyReassignment()
                       && r.Message.StartsWith($"{
                           ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                               "PropertyReassignment", propertyName, propertyNewValue, propertyOldValue, string.Empty)}"));
-                logger.BuildMessageEvents.ShouldBeOfTypes(new[] { typeof(PropertyReassignmentEventArgs) });
             }
         }
 
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 31dea1590f8..25187464656 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -95,7 +95,11 @@ public void ExpandAllIntoTaskItems3()
             itemsByType.ImportItems(ig);
             itemsByType.ImportItems(ig2);
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, itemsByType, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(
+                pg,
+                itemsByType,
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             IList<TaskItem> itemsOut = expander.ExpandIntoTaskItemsLeaveEscaped("foo;bar;@(compile);@(resource)", ExpanderOptions.ExpandPropertiesAndItems, MockElementLocation.Instance);
 
@@ -802,7 +806,11 @@ private Expander<ProjectPropertyInstance, ProjectItemInstance> CreateExpander()
             ig.Add(i0);
             ig.Add(i1);
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, ig, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(
+                pg,
+                ig,
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             return expander;
         }
@@ -2271,9 +2279,8 @@ public void PropertyFunctionInCondition()
                     ExpanderOptions.ExpandProperties,
                     Directory.GetCurrentDirectory(),
                     MockElementLocation.Instance,
-                    null,
-                    new BuildEventContext(1, 2, 3, 4),
-                    FileSystems.Default));
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
             Assert.True(
                 ConditionEvaluator.EvaluateCondition(
                     @"'$(PathRoot.EndsWith(" + Path.DirectorySeparatorChar + "))' == 'false'",
@@ -2282,9 +2289,8 @@ public void PropertyFunctionInCondition()
                     ExpanderOptions.ExpandProperties,
                     Directory.GetCurrentDirectory(),
                     MockElementLocation.Instance,
-                    null,
-                    new BuildEventContext(1, 2, 3, 4),
-                    FileSystems.Default));
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
         }
 
         /// <summary>
@@ -4383,13 +4389,13 @@ public void PropertyFunctionCheckFeatureAvailability(string featureName, string
         }
 
         [Theory]
-        [InlineData("\u3407\ud840\udc60\ud86a\ude30\ud86e\udc0a\ud86e\udda0\ud879\udeae\u2fd5\u0023", 0, 3, "\u3407\ud840\udc60\ud86a\ude30")]
-        [InlineData("\u3407\ud840\udc60\ud86a\ude30\ud86e\udc0a\ud86e\udda0\ud879\udeae\u2fd5\u0023", 2, 5, "\ud86a\ude30\ud86e\udc0a\ud86e\udda0\ud879\udeae\u2fd5")]
-        public void SubstringByTextElements(string featureName, int start, int length, string expected)
+        [InlineData("\u0074\u0068\u0069\u0073\u002a\u3407\ud840\udc60\ud86a\ude30\ud86e\udc0a\ud86e\udda0\ud879\udeae\u2fd5\u0023", 2, 10, "is________")]
+        [InlineData("\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66\u002e\u0070\u0072\u006f\u006a", 0, 8, "________")]
+        public void SubstringByAsciiChars(string featureName, int start, int length, string expected)
         {
             var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), FileSystems.Default);
 
-            var result = expander.ExpandIntoStringLeaveEscaped($"$([MSBuild]::SubstringByTextElements({featureName}, {start}, {length}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
+            var result = expander.ExpandIntoStringLeaveEscaped($"$([MSBuild]::SubstringByAsciiChars({featureName}, {start}, {length}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
             Assert.Equal(expected, result);
         }
@@ -5071,7 +5077,7 @@ private static bool ICUModeAvailable()
         }
 
         [Fact]
-        public void PropertyFunctionRegisterAnalyzer()
+        public void PropertyFunctionRegisterBuildCheck()
         {
             using (var env = TestEnvironment.Create())
             {
@@ -5083,8 +5089,8 @@ public void PropertyFunctionRegisterAnalyzer()
                     new BuildEventContext(0, 0, BuildEventContext.InvalidProjectContextId, 0, 0));
                 var dummyAssemblyFile = env.CreateFile(env.CreateFolder(), "test.dll");
 
-                var result = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), FileSystems.Default)
-                    .ExpandIntoStringLeaveEscaped($"$([MSBuild]::RegisterAnalyzer({dummyAssemblyFile.Path}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance, loggingContext);
+                var result = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), FileSystems.Default, loggingContext)
+                    .ExpandIntoStringLeaveEscaped($"$([MSBuild]::RegisterBuildCheck({dummyAssemblyFile.Path}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
                 result.ShouldBe(Boolean.TrueString);
                 _ = logger.AllBuildEvents.Select(be => be.ShouldBeOfType<BuildCheckAcquisitionEventArgs>());
diff --git a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
index 856de263ffe..06b32c45258 100644
--- a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
@@ -4,7 +4,9 @@
 using System.Collections.Generic;
 using System.IO;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.UnitTests.BackEnd;
@@ -87,7 +89,11 @@ private ProjectInstanceExpander CreateExpander(Dictionary<string, string[]> item
         {
             var itemDictionary = ToItemDictionary(items);
 
-            return new ProjectInstanceExpander(new PropertyDictionary<ProjectPropertyInstance>(), itemDictionary, (IFileSystem)FileSystems.Default);
+            return new ProjectInstanceExpander(
+                new PropertyDictionary<ProjectPropertyInstance>(),
+                itemDictionary,
+                (IFileSystem)FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
         }
 
         private static ItemDictionary<ProjectItemInstance> ToItemDictionary(Dictionary<string, string[]> itemTypes)
diff --git a/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs b/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
index 8ede8eec729..f9de1bc6144 100644
--- a/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
@@ -1,6 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using Microsoft.Build.Engine.UnitTests;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 
@@ -13,7 +15,7 @@ public sealed class UsedUninitializedProperties_Tests
     [Fact]
     public void Basics()
     {
-        UsedUninitializedProperties props = new();
+        PropertiesUseTracker props = new(TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, 3, 4)));
 
         Assert.False(props.TryGetPropertyElementLocation("Hello", out IElementLocation? elementLocation));
         Assert.Null(elementLocation);
diff --git a/src/Build.UnitTests/ExpressionTree_Tests.cs b/src/Build.UnitTests/ExpressionTree_Tests.cs
index 70ce8bb76d5..1c730e8d38d 100644
--- a/src/Build.UnitTests/ExpressionTree_Tests.cs
+++ b/src/Build.UnitTests/ExpressionTree_Tests.cs
@@ -99,7 +99,7 @@ public void FunctionTests()
         {
             Parser p = new Parser();
             GenericExpressionNode tree;
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), new ItemDictionary<ProjectItemInstance>(), FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), new ItemDictionary<ProjectItemInstance>(), FileSystems.Default, null);
             expander.Metadata = new StringMetadataTable(null);
             bool value;
 
@@ -149,7 +149,7 @@ public void PropertyTests()
             propertyBag.Set(ProjectPropertyInstance.Create("x86", "x86"));
             propertyBag.Set(ProjectPropertyInstance.Create("no", "no"));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default, null);
             AssertParseEvaluate(p, "$(foo)", expander, true);
             AssertParseEvaluate(p, "!$(foo)", expander, false);
             // Test properties with strings
@@ -187,7 +187,7 @@ public void ItemListTests()
             itemBag.Add(new ProjectItemInstance(parentProject, "Compile", "baz.cs", parentProject.FullPath));
             itemBag.Add(new ProjectItemInstance(parentProject, "Boolean", "true", parentProject.FullPath));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "@(Compile) == 'foo.cs;bar.cs;baz.cs'", expander, true);
             AssertParseEvaluate(p, "@(Compile,' ') == 'foo.cs bar.cs baz.cs'", expander, true);
@@ -230,7 +230,7 @@ public void StringExpansionTests()
             propertyBag.Set(ProjectPropertyInstance.Create("AnotherTestQuote", "Here's Johnny!"));
             propertyBag.Set(ProjectPropertyInstance.Create("Atsign", "Test the @ replacement"));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "'simplestring: true foo.cs;bar.cs;baz.cs' == '$(simple): $(foo) @(compile)'", expander, true);
             AssertParseEvaluate(p, "'$(c1) $(c2)' == 'Another (complex) one. Another (complex) one.'", expander, true);
@@ -262,7 +262,7 @@ public void ComplexTests()
             propertyBag.Set(ProjectPropertyInstance.Create("c1", "Another (complex) one."));
             propertyBag.Set(ProjectPropertyInstance.Create("c2", "Another (complex) one."));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "(($(foo) != 'two' and $(bar)) and 5 >= 1) or $(one) == 1", expander, true);
             AssertParseEvaluate(p, "(($(foo) != 'twoo' or !$(bar)) and 5 >= 1) or $(two) == 1", expander, true);
@@ -283,7 +283,7 @@ public void InvalidItemInConditionEvaluation()
 
             PropertyDictionary<ProjectPropertyInstance> propertyBag = new PropertyDictionary<ProjectPropertyInstance>();
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluateThrow(p, "@(Compile) > 0", expander, null);
         }
@@ -312,7 +312,7 @@ public void OldSyntaxTests()
             propertyBag.Set(ProjectPropertyInstance.Create("c1", "Another (complex) one."));
             propertyBag.Set(ProjectPropertyInstance.Create("c2", "Another (complex) one."));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "(($(foo) != 'two' and $(bar)) and 5 >= 1) or $(one) == 1", expander, true);
         }
@@ -329,7 +329,7 @@ public void ConditionedPropertyUpdateTests()
             itemBag.Add(new ProjectItemInstance(parentProject, "Compile", "bar.cs", parentProject.FullPath));
             itemBag.Add(new ProjectItemInstance(parentProject, "Compile", "baz.cs", parentProject.FullPath));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default, null);
             Dictionary<string, List<string>> conditionedProperties = new Dictionary<string, List<string>>();
             ConditionEvaluator.IConditionEvaluationState state =
                                new ConditionEvaluator.ConditionEvaluationState<ProjectPropertyInstance, ProjectItemInstance>(
@@ -416,7 +416,7 @@ public void NotTests()
             propertyBag.Set(ProjectPropertyInstance.Create("foo", "4"));
             propertyBag.Set(ProjectPropertyInstance.Create("bar", "32"));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default, null);
 
             AssertParseEvaluate(p, "!true", expander, false);
             AssertParseEvaluate(p, "!(true)", expander, false);
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index 9a9cc0eb4ca..c17a194274c 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -194,7 +194,7 @@ public void Metadata()
             item.MetadataCount.ShouldBe(s_builtInMetadataNames.Length + 2);
             item.DirectMetadataCount.ShouldBe(1);
 
-            CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = item.MetadataCollection;
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = item.MetadataCollection;
             metadata.Count.ShouldBe(2);
             metadata["a"].EvaluatedValue.ShouldBe("override");
             metadata["b"].EvaluatedValue.ShouldBe("base");
diff --git a/src/Build.UnitTests/TestLoggingContext.cs b/src/Build.UnitTests/TestLoggingContext.cs
new file mode 100644
index 00000000000..756f61b8284
--- /dev/null
+++ b/src/Build.UnitTests/TestLoggingContext.cs
@@ -0,0 +1,27 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Engine.UnitTests
+{
+    internal sealed class TestLoggingContext : LoggingContext
+    {
+        public TestLoggingContext(ILoggingService? loggingService, BuildEventContext eventContext) : base(
+            loggingService ?? Build.BackEnd.Logging.LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1), eventContext)
+        {
+            IsValid = true;
+        }
+
+        public static LoggingContext CreateTestContext(BuildEventContext buildEventContext)
+        {
+            return new TestLoggingContext(null, buildEventContext);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index ec86b218112..c30c97d672e 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -21,8 +21,8 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
-using Microsoft.Build.BuildCheck.Infrastructure;
-using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Logging;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
@@ -2989,10 +2989,22 @@ private ILoggingService CreateLoggingService(
                     ((IBuildComponentHost)this).GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider;
                 buildCheckManagerProvider!.Instance.SetDataSource(BuildCheckDataSource.EventArgs);
 
-                loggers = (loggers ?? Enumerable.Empty<ILogger>()).Concat(new[]
-                {
-                    new BuildCheckConnectorLogger(new AnalyzerLoggingContextFactory(loggingService), buildCheckManagerProvider.Instance)
-                });
+                // We do want to dictate our own forwarding logger (otherwise CentralForwardingLogger with minimum transferred importance MessageImportnace.Low is used)
+                // In the future we might optimize for single, in-node build scenario - where forwarding logger is not needed (but it's just quick pass-through)
+                LoggerDescription forwardingLoggerDescription = new LoggerDescription(
+                    loggerClassName: typeof(BuildCheckForwardingLogger).FullName,
+                    loggerAssemblyName: typeof(BuildCheckForwardingLogger).GetTypeInfo().Assembly.GetName().FullName,
+                    loggerAssemblyFile: null,
+                    loggerSwitchParameters: null,
+                    verbosity: LoggerVerbosity.Quiet);
+
+                ILogger buildCheckLogger =
+                    new BuildCheckConnectorLogger(new AnalyzerLoggingContextFactory(loggingService),
+                        buildCheckManagerProvider.Instance);
+
+                ForwardingLoggerRecord[] forwardingLogger = { new ForwardingLoggerRecord(buildCheckLogger, forwardingLoggerDescription) };
+
+                forwardingLoggers = forwardingLoggers?.Concat(forwardingLogger) ?? forwardingLogger;
             }
 
             try
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 826fbadef56..9657019dc00 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -231,7 +231,7 @@ public class BuildParameters : ITranslatable
         /// </summary>
         public BuildParameters()
         {
-            Initialize(Utilities.GetEnvironmentProperties(), new ProjectRootElementCache(false), null);
+            Initialize(Utilities.GetEnvironmentProperties(makeReadOnly: false), new ProjectRootElementCache(false), null);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
index abcb6c22fb0..dd833490899 100644
--- a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
+++ b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
@@ -4,7 +4,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Components.Caching;
 using Microsoft.Build.BackEnd.SdkResolution;
-using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 7e72bd3a159..4fc3f6db70a 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -10,7 +10,7 @@
 using System.Threading;
 using System.Threading.Tasks.Dataflow;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
diff --git a/src/Build/BackEnd/Components/Caching/IConfigCache.cs b/src/Build/BackEnd/Components/Caching/IConfigCache.cs
index 83b13f615fe..599a86d4c1d 100644
--- a/src/Build/BackEnd/Components/Caching/IConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/IConfigCache.cs
@@ -54,7 +54,7 @@ BuildRequestConfiguration this[int configId]
         BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata);
 
         /// <summary>
-        /// Gets a matching configuration.  If no such configration exists, one is created and optionally loaded.
+        /// Gets a matching configuration. If no such configuration exists, one is created and optionally loaded.
         /// </summary>
         /// <param name="configMetadata">The configuration metadata to match.</param>
         /// <param name="callback">Callback to be invoked if the configuration does not exist.</param>
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 308e26cae4d..8b8885b195e 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -2,7 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 885647baba0..1b19f496efa 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -9,6 +9,7 @@
 using System.Reflection;
 using System.Threading;
 using Microsoft.Build.BackEnd.Components.RequestBuilder;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -1758,6 +1759,10 @@ private void UpdateMinimumMessageImportance(ILogger logger)
                 Build.Logging.ConsoleLogger consoleLogger => consoleLogger.GetMinimumMessageImportance(),
                 Build.Logging.ConfigurableForwardingLogger forwardingLogger => forwardingLogger.GetMinimumMessageImportance(),
 
+                // The BuildCheck connector logger consumes only high priority messages.
+                BuildCheckForwardingLogger => MessageImportance.High,
+                BuildCheckConnectorLogger => MessageImportance.High,
+
                 // Central forwarding loggers are used in worker nodes if logging verbosity could not be optimized, i.e. in cases
                 // where we must log everything. They can be ignored in inproc nodes.
                 CentralForwardingLogger => (_nodeId > 1 ? MessageImportance.Low : null),
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index 646381478b9..40b58682006 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -80,9 +81,10 @@ internal static class BatchingEngine
         internal static List<ItemBucket> PrepareBatchingBuckets(
             List<string> batchableObjectParameters,
             Lookup lookup,
-            ElementLocation elementLocation)
+            ElementLocation elementLocation,
+            LoggingContext loggingContext)
         {
-            return PrepareBatchingBuckets(batchableObjectParameters, lookup, null, elementLocation);
+            return PrepareBatchingBuckets(batchableObjectParameters, lookup, null, elementLocation, loggingContext);
         }
 
         /// <summary>
@@ -94,12 +96,14 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
         /// <param name="lookup"></param>
         /// <param name="implicitBatchableItemType">Any item type that can be considered an implicit input to this batchable object.
         /// This is useful for items inside targets, where the item name is plainly an item type that's an "input" to the object.</param>
+        /// <param name="loggingContext"></param>
         /// <returns>List containing ItemBucket objects, each one representing an execution batch.</returns>
         internal static List<ItemBucket> PrepareBatchingBuckets(
             List<string> batchableObjectParameters,
             Lookup lookup,
             string implicitBatchableItemType,
-            ElementLocation elementLocation)
+            ElementLocation elementLocation,
+            LoggingContext loggingContext)
         {
             if (batchableObjectParameters == null)
             {
@@ -160,7 +164,7 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
                 {
                     // If the batchable object consumes item metadata as well as items to be batched,
                     // we need to partition the items consumed by the object.
-                    buckets = BucketConsumedItems(lookup, itemListsToBeBatched, consumedMetadataReferences, elementLocation);
+                    buckets = BucketConsumedItems(lookup, itemListsToBeBatched, consumedMetadataReferences, elementLocation, loggingContext);
                 }
             }
 
@@ -170,7 +174,12 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
             {
                 // create a default bucket that references the project items and properties -- this way we always have a bucket
                 buckets = new List<ItemBucket>(1);
-                buckets.Add(new ItemBucket(null, null, lookup, buckets.Count));
+                var bucket = new ItemBucket(null, null, lookup, buckets.Count);
+                if (loggingContext != null)
+                {
+                    bucket.Initialize(loggingContext);
+                }
+                buckets.Add(bucket);
             }
 
             return buckets;
@@ -292,7 +301,8 @@ private static List<ItemBucket> BucketConsumedItems(
             Lookup lookup,
             Dictionary<string, ICollection<ProjectItemInstance>> itemListsToBeBatched,
             Dictionary<string, MetadataReference> consumedMetadataReferences,
-            ElementLocation elementLocation)
+            ElementLocation elementLocation,
+            LoggingContext loggingContext)
         {
             ErrorUtilities.VerifyThrow(itemListsToBeBatched.Count > 0, "Need item types consumed by the batchable object.");
             ErrorUtilities.VerifyThrow(consumedMetadataReferences.Count > 0, "Need item metadata consumed by the batchable object.");
@@ -330,6 +340,10 @@ private static List<ItemBucket> BucketConsumedItems(
                         if (matchingBucket == null)
                         {
                             matchingBucket = new ItemBucket(itemListsToBeBatched.Keys, itemMetadataValues, lookup, buckets.Count);
+                            if (loggingContext != null)
+                            {
+                                matchingBucket.Initialize(loggingContext);
+                            }
 
                             // make sure to put the new bucket into the appropriate location
                             // in the sorted list as indicated by the binary search
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 08cc3e9f5e0..e5d09b99d8a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -58,7 +58,7 @@ internal override void ExecuteTask(Lookup lookup)
                 {
                     List<string> parameterValues = new List<string>();
                     GetBatchableValuesFromBuildItemGroupChild(parameterValues, child);
-                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, child.ItemType, _taskInstance.Location);
+                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, child.ItemType, _taskInstance.Location, LoggingContext);
 
                     // "Execute" each bucket
                     foreach (ItemBucket bucket in buckets)
@@ -70,9 +70,8 @@ internal override void ExecuteTask(Lookup lookup)
                             ExpanderOptions.ExpandAll,
                             Project.Directory,
                             child.ConditionLocation,
-                            LoggingContext.LoggingService,
-                            LoggingContext.BuildEventContext,
-                            FileSystems.Default);
+                            FileSystems.Default,
+                            LoggingContext);
 
                         if (condition)
                         {
@@ -83,7 +82,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.KeepMetadata))
                             {
-                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation, LoggingContext).ToList();
+                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation).ToList();
                                 if (keepMetadataEvaluated.Count > 0)
                                 {
                                     keepMetadata = new HashSet<string>(keepMetadataEvaluated);
@@ -92,7 +91,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.RemoveMetadata))
                             {
-                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation, LoggingContext).ToList();
+                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation).ToList();
                                 if (removeMetadataEvaluated.Count > 0)
                                 {
                                     removeMetadata = new HashSet<string>(removeMetadataEvaluated);
@@ -101,7 +100,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.MatchOnMetadata))
                             {
-                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation, LoggingContext).ToList();
+                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation).ToList();
                                 if (matchOnMetadataEvaluated.Count > 0)
                                 {
                                     matchOnMetadata = new HashSet<string>(matchOnMetadataEvaluated);
@@ -177,8 +176,6 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                     ExpanderOptions.ExpandAll,
                     Project.Directory,
                     metadataInstance.Location,
-                    LoggingContext.LoggingService,
-                    LoggingContext.BuildEventContext,
                     FileSystems.Default,
                     loggingContext: loggingContext);
 
@@ -194,7 +191,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                         expanderOptions |= ExpanderOptions.LogOnItemMetadataSelfReference;
                     }
 
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, expanderOptions, metadataInstance.Location, loggingContext);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, expanderOptions, metadataInstance.Location);
 
                     // This both stores the metadata so we can add it to all the items we just created later, and
                     // exposes this metadata to further metadata evaluations in subsequent loop iterations.
@@ -216,15 +213,16 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                 ExpanderOptions.ExpandAll,
                 Project.Directory,
                 child.KeepDuplicatesLocation,
-                LoggingContext.LoggingService,
-                LoggingContext.BuildEventContext,
-                FileSystems.Default);
+                FileSystems.Default,
+                LoggingContext);
 
             if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToAdd?.Count > 0)
             {
                 ItemGroupLoggingHelper.LogTaskParameter(
                     LoggingContext,
                     TaskParameterMessageKind.AddItem,
+                    parameterName: null,
+                    propertyName: null,
                     child.ItemType,
                     itemsToAdd,
                     logItemMetadata: true,
@@ -255,7 +253,7 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
             List<ProjectItemInstance> itemsToRemove;
             if (matchOnMetadata == null)
             {
-                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander, LoggingContext);
+                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander);
             }
             else
             {
@@ -269,6 +267,8 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                     ItemGroupLoggingHelper.LogTaskParameter(
                         LoggingContext,
                         TaskParameterMessageKind.RemoveItem,
+                        parameterName: null,
+                        propertyName: null,
                         child.ItemType,
                         itemsToRemove,
                         logItemMetadata: true,
@@ -325,14 +325,12 @@ private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                     ExpanderOptions.ExpandAll,
                     Project.Directory,
                     metadataInstance.ConditionLocation,
-                    LoggingContext.LoggingService,
-                    LoggingContext.BuildEventContext,
                     FileSystems.Default,
                     loggingContext: loggingContext);
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location);
                     metadataToSet[metadataInstance.Name] = Lookup.MetadataModification.CreateFromNewValue(evaluatedValue);
                 }
             }
@@ -387,7 +385,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
             List<ProjectItemInstance> items = new List<ProjectItemInstance>();
 
             // Expand properties and metadata in Include
-            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation, loggingContext);
+            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation);
 
             if (evaluatedInclude.Length == 0)
             {
@@ -398,7 +396,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
             var excludes = ImmutableList<string>.Empty.ToBuilder();
             if (originalItem.Exclude.Length > 0)
             {
-                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation, loggingContext);
+                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation);
 
                 if (evaluatedExclude.Length > 0)
                 {
@@ -459,7 +457,8 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
                             includeSplit /* before wildcard expansion */,
                             null,
                             null,
-                            originalItem.Location.File));
+                            originalItem.Location.File,
+                            useItemDefinitionsWithoutModification: false));
                     }
                 }
             }
@@ -537,14 +536,12 @@ private HashSet<string> EvaluateExcludePaths(IReadOnlyList<string> excludes, Ele
         /// <param name="specification">The specification to match against the items.</param>
         /// <param name="specificationLocation">The specification to match against the provided items</param>
         /// <param name="expander">The expander to use</param>
-        /// <param name="loggingContext">Context for logging</param>
         /// <returns>A list of matching items</returns>
         private List<ProjectItemInstance> FindItemsMatchingSpecification(
             ICollection<ProjectItemInstance> items,
             string specification,
             ElementLocation specificationLocation,
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander,
-            LoggingContext loggingContext = null)
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander)
         {
             if (items.Count == 0 || specification.Length == 0)
             {
@@ -556,7 +553,7 @@ private List<ProjectItemInstance> FindItemsMatchingSpecification(
             HashSet<string> specificationsToFind = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             // Split by semicolons
-            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation, loggingContext);
+            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation);
 
             foreach (string piece in specificationPieces)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
index df32111f095..deae62102f0 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
@@ -10,6 +10,7 @@
 #endif
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -35,6 +36,7 @@ internal static class ItemGroupLoggingHelper
         internal static string ItemGroupIncludeLogMessagePrefix = ResourceUtilities.GetResourceString("ItemGroupIncludeLogMessagePrefix");
         internal static string ItemGroupRemoveLogMessage = ResourceUtilities.GetResourceString("ItemGroupRemoveLogMessage");
         internal static string OutputItemParameterMessagePrefix = ResourceUtilities.GetResourceString("OutputItemParameterMessagePrefix");
+        internal static string OutputPropertyLogMessagePrefix = ResourceUtilities.GetResourceString("OutputPropertyLogMessagePrefix");
         internal static string TaskParameterPrefix = ResourceUtilities.GetResourceString("TaskParameterPrefix");
         internal static string SkipTargetUpToDateInputs = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("SkipTargetUpToDateInputs", string.Empty);
         internal static string SkipTargetUpToDateOutputs = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("SkipTargetUpToDateOutputs", string.Empty);
@@ -255,6 +257,8 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob
         internal static void LogTaskParameter(
             LoggingContext loggingContext,
             TaskParameterMessageKind messageKind,
+            string parameterName,
+            string propertyName,
             string itemType,
             IList items,
             bool logItemMetadata,
@@ -263,6 +267,8 @@ internal static void LogTaskParameter(
             var args = CreateTaskParameterEventArgs(
                 loggingContext.BuildEventContext,
                 messageKind,
+                parameterName,
+                propertyName,
                 itemType,
                 items,
                 logItemMetadata,
@@ -276,6 +282,8 @@ internal static void LogTaskParameter(
         internal static TaskParameterEventArgs CreateTaskParameterEventArgs(
             BuildEventContext buildEventContext,
             TaskParameterMessageKind messageKind,
+            string parameterName,
+            string propertyName,
             string itemType,
             IList items,
             bool logItemMetadata,
@@ -290,6 +298,8 @@ internal static TaskParameterEventArgs CreateTaskParameterEventArgs(
 
             var args = new TaskParameterEventArgs(
                 messageKind,
+                parameterName,
+                propertyName,
                 itemType,
                 items,
                 logItemMetadata,
@@ -355,26 +365,23 @@ private static void CreateItemsSnapshot(ref IList items)
 #endif
 
         internal static string GetTaskParameterText(TaskParameterEventArgs args)
-            => GetTaskParameterText(args.Kind, args.ItemType, args.Items, args.LogItemMetadata);
-
-        internal static string GetTaskParameterText(TaskParameterMessageKind messageKind, string itemType, IList items, bool logItemMetadata)
         {
-            var resourceText = messageKind switch
+            var resourceText = args.Kind switch
             {
                 TaskParameterMessageKind.AddItem => ItemGroupIncludeLogMessagePrefix,
                 TaskParameterMessageKind.RemoveItem => ItemGroupRemoveLogMessage,
                 TaskParameterMessageKind.TaskInput => TaskParameterPrefix,
-                TaskParameterMessageKind.TaskOutput => OutputItemParameterMessagePrefix,
+                TaskParameterMessageKind.TaskOutput => args.PropertyName is null ? OutputItemParameterMessagePrefix : OutputPropertyLogMessagePrefix,
                 TaskParameterMessageKind.SkippedTargetInputs => SkipTargetUpToDateInputs,
                 TaskParameterMessageKind.SkippedTargetOutputs => SkipTargetUpToDateOutputs,
-                _ => throw new NotImplementedException($"Unsupported {nameof(TaskParameterMessageKind)} value: {messageKind}")
+                _ => throw new NotImplementedException($"Unsupported {nameof(TaskParameterMessageKind)} value: {args.Kind}")
             };
 
             var itemGroupText = GetParameterText(
                 resourceText,
-                itemType,
-                items,
-                logItemMetadata);
+                args.PropertyName ?? args.ItemType,
+                args.Items,
+                args.LogItemMetadata);
             return itemGroupText;
         }
     }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
index 419ff97e0bd..18d85f2323c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
@@ -52,7 +52,7 @@ internal override void ExecuteTask(Lookup lookup)
                     // Find all the metadata references in order to create buckets
                     List<string> parameterValues = new List<string>();
                     GetBatchableValuesFromProperty(parameterValues, property);
-                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, property.Location);
+                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, property.Location, LoggingContext);
 
                     // "Execute" each bucket
                     foreach (ItemBucket bucket in buckets)
@@ -64,9 +64,8 @@ internal override void ExecuteTask(Lookup lookup)
                             ExpanderOptions.ExpandAll,
                             Project.Directory,
                             property.ConditionLocation,
-                            LoggingContext.LoggingService,
-                            LoggingContext.BuildEventContext,
-                            FileSystems.Default);
+                            FileSystems.Default,
+                            LoggingContext);
 
                         if (condition)
                         {
@@ -78,7 +77,12 @@ internal override void ExecuteTask(Lookup lookup)
                                 "CannotModifyReservedProperty",
                                 property.Name);
 
+                            bucket.Expander.PropertiesUseTracker.CurrentlyEvaluatingPropertyElementName = property.Name;
+                            bucket.Expander.PropertiesUseTracker.PropertyReadContext =
+                                PropertyReadContext.PropertyEvaluation;
+
                             string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(property.Value, ExpanderOptions.ExpandAll, property.Location);
+                            bucket.Expander.PropertiesUseTracker.CheckPreexistingUndefinedUsage(property, evaluatedValue, LoggingContext);
 
                             if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents)
                             {
@@ -97,6 +101,8 @@ internal override void ExecuteTask(Lookup lookup)
                         foreach (ItemBucket bucket in buckets)
                         {
                             bucket.LeaveScope();
+                            // We are now done processing this property - so no need to pop its previous context.
+                            bucket.Expander.PropertiesUseTracker.ResetPropertyReadContext(pop: false);
                         }
                     }
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
index 21650e6448f..950b2848a68 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
@@ -3,6 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Diagnostics;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -30,12 +33,12 @@ internal sealed class ItemBucket : IComparable
         /// <summary>
         /// Metadata in this bucket
         /// </summary>
-        private Dictionary<string, string> _metadata;
+        private readonly Dictionary<string, string> _metadata;
 
         /// <summary>
         /// The items for this bucket.
         /// </summary>
-        private Lookup _lookup;
+        private readonly Lookup _lookup;
 
         /// <summary>
         /// When buckets are being created for batching purposes, this indicates which order the
@@ -44,22 +47,23 @@ internal sealed class ItemBucket : IComparable
         /// bucket created gets bucketSequenceNumber=0, the second bucket created gets
         /// bucketSequenceNumber=1, etc.
         /// </summary>
-        private int _bucketSequenceNumber;
+        private readonly int _bucketSequenceNumber;
 
         /// <summary>
         /// The entry we enter when we create the bucket.
         /// </summary>
-        private Lookup.Scope _lookupEntry;
+        private readonly Lookup.Scope _lookupEntry;
 
         #endregion
 
         #region Constructors
 
         /// <summary>
-        /// Private default constructor disallows parameterless instantiation.
+        /// Private constructor for creating comparison bucket.
         /// </summary>
-        private ItemBucket()
+        private ItemBucket(Dictionary<string, string> metadata)
         {
+            _metadata = metadata;
             // do nothing
         }
 
@@ -95,11 +99,19 @@ internal ItemBucket(
             }
 
             _metadata = metadata;
-            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(metadata), FileSystems.Default);
 
             _bucketSequenceNumber = bucketSequenceNumber;
         }
 
+        /// <summary>
+        /// Updates the logging context that this bucket is going to use.
+        /// </summary>
+        /// <param name="loggingContext"></param>
+        internal void Initialize(LoggingContext loggingContext)
+        {
+            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(_metadata), FileSystems.Default, loggingContext);
+        }
+
         #endregion
 
         #region Comparison methods
@@ -131,8 +143,7 @@ public int CompareTo(object obj)
         /// <returns>An item bucket that is invalid for everything except comparisons.</returns>
         internal static ItemBucket GetDummyBucketForComparisons(Dictionary<string, string> metadata)
         {
-            ItemBucket bucket = new ItemBucket();
-            bucket._metadata = metadata;
+            ItemBucket bucket = new ItemBucket(metadata);
 
             return bucket;
         }
@@ -147,6 +158,7 @@ internal Expander<ProjectPropertyInstance, ProjectItemInstance> Expander
         {
             get
             {
+                Debug.Assert(_expander != null, "ItemBucket.Initialize was not properly called");
                 return _expander;
             }
         }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 55cce8824b6..859675070ae 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -10,7 +10,7 @@
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index 2d39b0a89a9..1613f016e22 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -740,11 +740,11 @@ private async Task<bool> PushTargets(IList<TargetSpecification> targets, TargetE
                 TargetEntry newEntry;
                 if (buildReason == TargetBuiltReason.None)
                 {
-                    newEntry = new TargetEntry(_requestEntry, this as ITargetBuilderCallback, targetSpecification, baseLookup, parentTargetEntry, targetSpecification._targetBuiltReason, _componentHost, stopProcessingOnCompletion);
+                    newEntry = new TargetEntry(_requestEntry, this as ITargetBuilderCallback, targetSpecification, baseLookup, parentTargetEntry, targetSpecification._targetBuiltReason, _componentHost, _projectLoggingContext, stopProcessingOnCompletion);
                 }
                 else
                 {
-                    newEntry = new TargetEntry(_requestEntry, this as ITargetBuilderCallback, targetSpecification, baseLookup, parentTargetEntry, buildReason, _componentHost, stopProcessingOnCompletion);
+                    newEntry = new TargetEntry(_requestEntry, this as ITargetBuilderCallback, targetSpecification, baseLookup, parentTargetEntry, buildReason, _componentHost, _projectLoggingContext, stopProcessingOnCompletion);
                 }
                 newEntry.ErrorTarget = addAsErrorTarget;
                 targetsToPush.Add(newEntry);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index bbfc80ae5d9..cc277b9d048 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -7,6 +7,7 @@
 using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
@@ -162,8 +163,17 @@ internal class TargetEntry : IEquatable<TargetEntry>
         /// <param name="parentTarget">The parent of this entry, if any.</param>
         /// <param name="buildReason">The reason the parent built this target.</param>
         /// <param name="host">The Build Component Host to use.</param>
+        /// <param name="loggingContext"></param>
         /// <param name="stopProcessingOnCompletion">True if the target builder should stop processing the current target stack when this target is complete.</param>
-        internal TargetEntry(BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, TargetSpecification targetSpecification, Lookup baseLookup, TargetEntry parentTarget, TargetBuiltReason buildReason, IBuildComponentHost host, bool stopProcessingOnCompletion)
+        internal TargetEntry(
+            BuildRequestEntry requestEntry,
+            ITargetBuilderCallback targetBuilderCallback,
+            TargetSpecification targetSpecification,
+            Lookup baseLookup, TargetEntry parentTarget,
+            TargetBuiltReason buildReason,
+            IBuildComponentHost host,
+            LoggingContext loggingContext,
+            bool stopProcessingOnCompletion)
         {
             ErrorUtilities.VerifyThrowArgumentNull(requestEntry, nameof(requestEntry));
             ErrorUtilities.VerifyThrowArgumentNull(targetBuilderCallback, nameof(targetBuilderCallback));
@@ -176,7 +186,7 @@ internal TargetEntry(BuildRequestEntry requestEntry, ITargetBuilderCallback targ
             _targetSpecification = targetSpecification;
             _parentTarget = parentTarget;
             _buildReason = buildReason;
-            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(baseLookup, baseLookup, FileSystems.Default);
+            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(baseLookup, baseLookup, FileSystems.Default, loggingContext);
             _state = TargetEntryState.Dependencies;
             _baseLookup = baseLookup;
             _host = host;
@@ -351,8 +361,6 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 ExpanderOptions.ExpandPropertiesAndItems,
                 _requestEntry.ProjectRootDirectory,
                 _target.ConditionLocation,
-                projectLoggingContext.LoggingService,
-                projectLoggingContext.BuildEventContext,
                 FileSystems.Default,
                 loggingContext: projectLoggingContext);
 
@@ -393,7 +401,7 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 return new List<TargetSpecification>();
             }
 
-            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation, projectLoggingContext);
+            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation);
             List<TargetSpecification> dependencyTargets = new List<TargetSpecification>();
             foreach (string escapedDependency in dependencies)
             {
@@ -420,7 +428,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
 
                 // Generate the batching buckets.  Note that each bucket will get a lookup based on the baseLookup.  This lookup will be in its
                 // own scope, which we will collapse back down into the baseLookup at the bottom of the function.
-                List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location);
+                List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location, null);
 
                 WorkUnitResult aggregateResult = new WorkUnitResult();
                 TargetLoggingContext targetLoggingContext = null;
@@ -445,6 +453,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                     }
 
                     targetLoggingContext = projectLoggingContext.LogTargetBatchStarted(projectFullPath, _target, parentTargetName, _buildReason);
+                    bucket.Initialize(targetLoggingContext);
                     WorkUnitResult bucketResult = null;
                     targetSuccess = false;
 
@@ -612,14 +621,14 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                                  ExpanderOptions.ExpandPropertiesAndItems,
                                  requestEntry.ProjectRootDirectory,
                                  _target.KeepDuplicateOutputsLocation,
-                                 projectLoggingContext.LoggingService,
-                                 projectLoggingContext.BuildEventContext, FileSystems.Default);
+                                 FileSystems.Default,
+                                 projectLoggingContext);
 
                         // NOTE: we need to gather the outputs in batches, because the output specification may reference item metadata
                         // Also, we are using the baseLookup, which has possibly had changes made to it since the project started.  Because of this, the
                         // set of outputs calculated here may differ from those which would have been calculated at the beginning of the target.  It is
                         // assumed the user intended this.
-                        List<ItemBucket> batchingBuckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location);
+                        List<ItemBucket> batchingBuckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location, targetLoggingContext);
 
                         if (keepDupes)
                         {
@@ -704,8 +713,8 @@ internal List<TargetSpecification> GetErrorTargets(ProjectLoggingContext project
                     ExpanderOptions.ExpandPropertiesAndItems,
                     _requestEntry.ProjectRootDirectory,
                     errorTargetInstance.ConditionLocation,
-                    projectLoggingContext.LoggingService,
-                    projectLoggingContext.BuildEventContext, FileSystems.Default);
+                    FileSystems.Default,
+                    projectLoggingContext);
 
                 if (condition)
                 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index 4b40715d67b..9940131c9e9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -368,6 +368,8 @@ private void LogUniqueInputsAndOutputs()
             var args = ItemGroupLoggingHelper.CreateTaskParameterEventArgs(
                 _buildEventContext,
                 TaskParameterMessageKind.SkippedTargetInputs,
+                parameterName: null,
+                propertyName: null,
                 itemType: null,
                 _uniqueTargetInputs.Keys.ToArray(),
                 logItemMetadata: false,
@@ -377,6 +379,8 @@ private void LogUniqueInputsAndOutputs()
             args = ItemGroupLoggingHelper.CreateTaskParameterEventArgs(
                 _buildEventContext,
                 TaskParameterMessageKind.SkippedTargetOutputs,
+                parameterName: null,
+                propertyName: null,
                 itemType: null,
                 _uniqueTargetOutputs.Keys.ToArray(),
                 logItemMetadata: false,
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 485ee854f73..6bc0dd7fc23 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -313,7 +313,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                 }
 
                 List<string> taskParameterValues = CreateListOfParameterValues();
-                buckets = BatchingEngine.PrepareBatchingBuckets(taskParameterValues, lookup, _targetChildInstance.Location);
+                buckets = BatchingEngine.PrepareBatchingBuckets(taskParameterValues, lookup, _targetChildInstance.Location, _targetLoggingContext);
 
                 Dictionary<string, string> lookupHash = null;
 
@@ -379,8 +379,6 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 ExpanderOptions.ExpandAll,
                 _buildRequestEntry.ProjectRootDirectory,
                 _targetChildInstance.ConditionLocation,
-                _targetLoggingContext.LoggingService,
-                _targetLoggingContext.BuildEventContext,
                 FileSystems.Default,
                 loggingContext: _targetLoggingContext);
 
@@ -614,7 +612,7 @@ private void LogSkippedTask(ItemBucket bucket, TaskExecutionMode howToExecuteTas
                     if (!_targetLoggingContext.LoggingService.OnlyLogCriticalEvents)
                     {
                         // Expand the expression for the Log.  Since we know the condition evaluated to false, leave unexpandable properties in the condition so as not to cause an error
-                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation, loggingContext: _targetLoggingContext);
+                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation);
 
                         // Whilst we are within the processing of the task, we haven't actually started executing it, so
                         // our skip task message needs to be in the context of the target. However any errors should be reported
@@ -1080,9 +1078,8 @@ private bool GatherTaskOutputs(TaskExecutionHost taskExecutionHost, TaskExecutio
                     ExpanderOptions.ExpandAll,
                     _buildRequestEntry.ProjectRootDirectory,
                     taskOutputSpecification.ConditionLocation,
-                    _targetLoggingContext.LoggingService,
-                    _targetLoggingContext.BuildEventContext,
-                    FileSystems.Default);
+                    FileSystems.Default,
+                    _targetLoggingContext);
 
                 if (condition)
                 {
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index fdff89eb618..1a2ba345658 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -1177,7 +1177,7 @@ private bool InitializeTaskScalarParameter(
                 else
                 {
                     // Expand out all the metadata, properties, and item vectors in the string.
-                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation, _targetLoggingContext);
+                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation);
 
                     if (expandedParameterValue.Length == 0)
                     {
@@ -1317,10 +1317,14 @@ private bool InternalSetTaskParameter(
                     // Structured logging for all parameters that have logging enabled and are not empty lists.
                     if (parameterValueAsList?.Count > 0 || (parameterValueAsList == null && !legacyBehavior))
                     {
+                        // Note: We're setting TaskParameterEventArgs.ItemType to parameter name for backward compatibility with
+                        // older loggers and binlog viewers.
                         ItemGroupLoggingHelper.LogTaskParameter(
                             _taskLoggingContext,
                             TaskParameterMessageKind.TaskInput,
-                            parameter.Name,
+                            parameterName: parameter.Name,
+                            propertyName: null,
+                            itemType: parameter.Name,
                             parameterValueAsList ?? new object[] { parameterValue },
                             parameter.LogItemMetadata);
                     }
@@ -1429,7 +1433,9 @@ static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(IDictionary c
                         ItemGroupLoggingHelper.LogTaskParameter(
                             _taskLoggingContext,
                             TaskParameterMessageKind.TaskOutput,
-                            outputTargetName,
+                            parameterName: parameter.Name,
+                            propertyName: null,
+                            itemType: outputTargetName,
                             outputs,
                             parameter.LogItemMetadata);
                     }
@@ -1470,7 +1476,23 @@ static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(IDictionary c
                         var outputString = joinedOutputs.ToString();
                         if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents)
                         {
-                            _taskLoggingContext.LogComment(MessageImportance.Low, "OutputPropertyLogMessage", outputTargetName, outputString);
+                            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12))
+                            {
+                                // Note: We're setting TaskParameterEventArgs.ItemType to property name for backward compatibility with
+                                // older loggers and binlog viewers.
+                                ItemGroupLoggingHelper.LogTaskParameter(
+                                    _taskLoggingContext,
+                                    TaskParameterMessageKind.TaskOutput,
+                                    parameterName: parameter.Name,
+                                    propertyName: outputTargetName,
+                                    itemType: outputTargetName,
+                                    new object[] { outputString },
+                                    parameter.LogItemMetadata);
+                            }
+                            else
+                            {
+                                _taskLoggingContext.LogComment(MessageImportance.Low, "OutputPropertyLogMessage", outputTargetName, outputString);
+                            }
                         }
 
                         _batchBucket.Lookup.SetProperty(ProjectPropertyInstance.Create(outputTargetName, outputString, parameterLocation, _projectInstance.IsImmutable));
@@ -1505,7 +1527,9 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                         ItemGroupLoggingHelper.LogTaskParameter(
                             _taskLoggingContext,
                             TaskParameterMessageKind.TaskOutput,
-                            outputTargetName,
+                            parameterName: parameter.Name,
+                            propertyName: null,
+                            itemType: outputTargetName,
                             outputs,
                             parameter.LogItemMetadata);
                     }
@@ -1539,7 +1563,23 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                         var outputString = joinedOutputs.ToString();
                         if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents)
                         {
-                            _taskLoggingContext.LogComment(MessageImportance.Low, "OutputPropertyLogMessage", outputTargetName, outputString);
+                            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12))
+                            {
+                                // Note: We're setting TaskParameterEventArgs.ItemType to property name for backward compatibility with
+                                // older loggers and binlog viewers.
+                                ItemGroupLoggingHelper.LogTaskParameter(
+                                    _taskLoggingContext,
+                                    TaskParameterMessageKind.TaskOutput,
+                                    parameterName: parameter.Name,
+                                    propertyName: outputTargetName,
+                                    itemType: outputTargetName,
+                                    new object[] { outputString },
+                                    parameter.LogItemMetadata);
+                            }
+                            else
+                            {
+                                _taskLoggingContext.LogComment(MessageImportance.Low, "OutputPropertyLogMessage", outputTargetName, outputString);
+                            }
                         }
 
                         _batchBucket.Lookup.SetProperty(ProjectPropertyInstance.Create(outputTargetName, outputString, parameterLocation, _projectInstance.IsImmutable));
diff --git a/src/Build/BuildCheck/.editorconfig b/src/Build/BuildCheck/.editorconfig
new file mode 100644
index 00000000000..731ad1c1785
--- /dev/null
+++ b/src/Build/BuildCheck/.editorconfig
@@ -0,0 +1,2 @@
+[*.cs]
+csharp_style_namespace_declarations = file_scoped:warning
diff --git a/src/Build/BuildCheck/API/BuildAnalyzer.cs b/src/Build/BuildCheck/API/BuildAnalyzer.cs
index f249dc98cc5..0c6ed5a0752 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzer.cs
+++ b/src/Build/BuildCheck/API/BuildAnalyzer.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Collections.Immutable;
-using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs b/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
index 4940db20fd1..ab817077725 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
+++ b/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
@@ -1,6 +1,10 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
@@ -42,4 +46,73 @@ public class BuildAnalyzerConfiguration
     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.
     /// </summary>
     public bool? IsEnabled { get; internal init; }
+
+    /// <summary>
+    /// Creates a <see cref="BuildAnalyzerConfiguration"/> object based on the provided configuration dictionary.
+    /// If the BuildAnalyzerConfiguration's property name presented in the dictionary, the value of this key-value pair is parsed and assigned to the instance's field.
+    /// If parsing failed the value will be equal to null.
+    /// </summary>
+    /// <param name="configDictionary">The configuration dictionary containing the settings for the build analyzer. The configuration's keys are expected to be in lower case or the EqualityComparer to ignore case.</param>
+    /// <returns>A new instance of <see cref="BuildAnalyzerConfiguration"/> with the specified settings.</returns>
+    internal static BuildAnalyzerConfiguration Create(Dictionary<string, string>? configDictionary)
+    {
+        return new()
+        {
+            EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,
+            Severity = TryExtractValue(nameof(Severity), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,
+            IsEnabled = TryExtractValue(nameof(IsEnabled), configDictionary, out bool isEnabled) ? isEnabled : null,
+        };
+    }
+
+    private static bool TryExtractValue<T>(string key, Dictionary<string, string>? config, out T value) where T : struct, Enum
+    {
+        value = default;
+
+        if (config == null || !config.TryGetValue(key.ToLower(), out var stringValue) || stringValue is null)
+        {
+            return false;
+        }
+
+        var isParsed = Enum.TryParse(stringValue, true, out value);
+
+        if (!isParsed)
+        {
+            ThrowIncorrectValueException(key, stringValue);
+        }
+
+        return isParsed;
+    }
+
+    private static bool TryExtractValue(string key, Dictionary<string, string>? config, out bool value)
+    {
+        value = default;
+
+        if (config == null || !config.TryGetValue(key.ToLower(), out var stringValue) || stringValue is null)
+        {
+            return false;
+        }
+
+        bool isParsed = false;
+        
+        if (bool.TryParse(stringValue, out bool boolValue))
+        {
+            value = boolValue;
+            isParsed = true;
+        }
+        
+        if (!isParsed)
+        {
+            ThrowIncorrectValueException(key, stringValue);
+        }
+
+        return isParsed;
+    }
+
+    private static void ThrowIncorrectValueException(string key, string value)
+    {
+        // TODO: It will be nice to have the filename where the incorrect configuration was placed. 
+        throw new BuildCheckConfigurationException(
+                $"Incorrect value provided in config for key {key}: '{value}'",
+                buildCheckConfigurationErrorScope: BuildCheckConfigurationErrorScope.EditorConfigParser);
+    }
 }
diff --git a/src/Build/BuildCheck/API/ConfigurationContext.cs b/src/Build/BuildCheck/API/ConfigurationContext.cs
index 49dcdcfafec..3ecdd7c6527 100644
--- a/src/Build/BuildCheck/API/ConfigurationContext.cs
+++ b/src/Build/BuildCheck/API/ConfigurationContext.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
@@ -20,19 +20,9 @@ private ConfigurationContext(CustomConfigurationData[] customConfigurationData)
 
     internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData[] customConfigurationData)
     {
-        if (!customConfigurationData.Any(BuildCheck.CustomConfigurationData.NotNull))
-        {
-            return Null;
-        }
-
-        return new ConfigurationContext(
-            customConfigurationData
-                .Where(BuildCheck.CustomConfigurationData.NotNull)
-                .ToArray());
+        return new ConfigurationContext(customConfigurationData);
     }
 
-    internal static ConfigurationContext Null { get; } = new(Array.Empty<CustomConfigurationData>());
-
     /// <summary>
     /// Custom configuration data - per each rule that has some specified.
     /// </summary>
diff --git a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
index 04cdf5aa87f..d8ad5a396ef 100644
--- a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
+++ b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
@@ -9,4 +9,5 @@ public interface IBuildCheckRegistrationContext
 {
     void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction);
     void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction);
+    void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction);
 }
diff --git a/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs b/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
index 125dc27458e..908aa931bef 100644
--- a/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
+++ b/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
@@ -8,7 +8,7 @@
 using System.Threading.Tasks;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace Microsoft.Build.BuildCheck.Acquisition;
+namespace Microsoft.Build.Experimental.BuildCheck.Acquisition;
 
 // https://github.com/dotnet/msbuild/issues/9633
 // Acquisition
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index 1d2ff00841e..ee755cc7352 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -6,12 +6,12 @@
 using System.Linq;
 using System.Reflection;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-namespace Microsoft.Build.BuildCheck.Acquisition;
+namespace Microsoft.Build.Experimental.BuildCheck.Acquisition;
 
 internal class BuildCheckAcquisitionModule : IBuildCheckAcquisitionModule
 {
@@ -42,18 +42,17 @@ public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisiti
             assembly = Assembly.LoadFrom(analyzerAcquisitionData.AssemblyPath);
 #endif
 
-            IEnumerable<Type> analyzerTypes = assembly.GetExportedTypes().Where(t => typeof(BuildAnalyzer).IsAssignableFrom(t));
+            IList<Type> availableTypes = assembly.GetExportedTypes();
+            IList<Type> analyzerTypes = availableTypes.Where(t => typeof(BuildAnalyzer).IsAssignableFrom(t)).ToArray();
 
-            foreach (Type analyzerType in analyzerTypes)
+            foreach (Type analyzerCandidate in analyzerTypes)
             {
-                if (Activator.CreateInstance(analyzerType) is BuildAnalyzer instance)
-                {
-                    analyzersFactories.Add(() => instance);
-                }
-                else
-                {
-                    throw new InvalidOperationException($"Failed to create an instance of type {analyzerType.FullName} as BuildAnalyzer.");
-                }
+                analyzersFactories.Add(() => (BuildAnalyzer)Activator.CreateInstance(analyzerCandidate)!);
+            }
+
+            if (availableTypes.Count != analyzerTypes.Count)
+            {
+                availableTypes.Except(analyzerTypes).ToList().ForEach(t => _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerBaseTypeNotAssignable", t.Name, t.Assembly));
             }
         }
         catch (ReflectionTypeLoadException ex)
diff --git a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
index e86dc7d0c4a..efb860ef844 100644
--- a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
@@ -2,10 +2,10 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Collections.Generic;
-using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
 
-namespace Microsoft.Build.BuildCheck.Acquisition;
+namespace Microsoft.Build.Experimental.BuildCheck.Acquisition;
 
 internal interface IBuildCheckAcquisitionModule
 {
diff --git a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs b/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
index 174fb305b83..a09866ebb22 100644
--- a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
+++ b/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
@@ -6,11 +6,11 @@
 using System.Collections.Immutable;
 using System.Diagnostics;
 using System.IO;
-using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace Microsoft.Build.BuildCheck.Analyzers;
+namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;
 
 internal sealed class SharedOutputPathAnalyzer : BuildAnalyzer
 {
@@ -21,7 +21,7 @@ internal sealed class SharedOutputPathAnalyzer : BuildAnalyzer
 
     public override string FriendlyName => "MSBuild.SharedOutputPathAnalyzer";
 
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } =[SupportedRule];
+    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs
index c2c36c813f9..9d7738922e7 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs
@@ -3,7 +3,7 @@
 
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure;
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
 /// Counterpart type for BuildAnalyzerConfiguration - with all properties non-nullable
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
index 06e0aaa2439..598d0be021d 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
@@ -8,7 +8,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure;
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
 /// A wrapping, enriching class for BuildAnalyzer - so that we have additional data and functionality.
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index 9995aef71b3..32078038875 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -8,18 +8,26 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure;
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
 /// A manager of the runs of the analyzers - deciding based on configuration of what to run and what to postfilter.
 /// </summary>
 internal sealed class BuildCheckCentralContext
 {
+    private readonly ConfigurationProvider _configurationProvider;
+
+    internal BuildCheckCentralContext(ConfigurationProvider configurationProvider)
+    {
+        _configurationProvider = configurationProvider;
+    }
+
     private record CallbackRegistry(
         List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>>)> EvaluatedPropertiesActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<ParsedItemsAnalysisData>>)> ParsedItemsActions)
+        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<ParsedItemsAnalysisData>>)> ParsedItemsActions,
+        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<TaskInvocationAnalysisData>>)> TaskInvocationActions)
     {
-        public CallbackRegistry() : this([],[]) { }
+        public CallbackRegistry() : this([], [], []) { }
     }
 
     // In a future we can have callbacks per project as well
@@ -27,8 +35,9 @@ public CallbackRegistry() : this([],[]) { }
 
     // This we can potentially use to subscribe for receiving evaluated props in the
     //  build event args. However - this needs to be done early on, when analyzers might not be known yet
-    internal bool HasEvaluatedPropertiesActions => _globalCallbacks.EvaluatedPropertiesActions.Any();
-    internal bool HasParsedItemsActions => _globalCallbacks.ParsedItemsActions.Any();
+    internal bool HasEvaluatedPropertiesActions => _globalCallbacks.EvaluatedPropertiesActions.Count > 0;
+    internal bool HasParsedItemsActions => _globalCallbacks.ParsedItemsActions.Count > 0;
+    internal bool HasTaskInvocationActions => _globalCallbacks.TaskInvocationActions.Count > 0;
 
     internal void RegisterEvaluatedPropertiesAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction)
         // Here we might want to communicate to node that props need to be sent.
@@ -38,6 +47,9 @@ internal void RegisterEvaluatedPropertiesAction(BuildAnalyzerWrapper analyzer, A
     internal void RegisterParsedItemsAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction)
         => RegisterAction(analyzer, parsedItemsAction, _globalCallbacks.ParsedItemsActions);
 
+    internal void RegisterTaskInvocationAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
+        => RegisterAction(analyzer, taskInvocationAction, _globalCallbacks.TaskInvocationActions);
+
     private void RegisterAction<T>(
         BuildAnalyzerWrapper wrappedAnalyzer,
         Action<BuildCheckDataContext<T>> handler,
@@ -60,6 +72,7 @@ internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
     {
         _globalCallbacks.EvaluatedPropertiesActions.RemoveAll(a => a.Item1 == analyzer);
         _globalCallbacks.ParsedItemsActions.RemoveAll(a => a.Item1 == analyzer);
+        _globalCallbacks.TaskInvocationActions.RemoveAll(a => a.Item1 == analyzer);
     }
 
     internal void RunEvaluatedPropertiesActions(
@@ -78,6 +91,14 @@ internal void RunParsedItemsActions(
         => RunRegisteredActions(_globalCallbacks.ParsedItemsActions, parsedItemsAnalysisData,
             loggingContext, resultHandler);
 
+    internal void RunTaskInvocationActions(
+        TaskInvocationAnalysisData taskInvocationAnalysisData,
+        LoggingContext loggingContext,
+        Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult>
+            resultHandler)
+        => RunRegisteredActions(_globalCallbacks.TaskInvocationActions, taskInvocationAnalysisData,
+            loggingContext, resultHandler);
+
     private void RunRegisteredActions<T>(
         List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
         T analysisData,
@@ -112,7 +133,7 @@ private void RunRegisteredActions<T>(
                 else
                 {
                     configPerRule =
-                        ConfigurationProvider.GetMergedConfigurations(projectFullPath,
+                        _configurationProvider.GetMergedConfigurations(projectFullPath,
                             analyzerCallback.Item1.BuildAnalyzer);
                     if (configPerRule.All(c => !c.IsEnabled))
                     {
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationErrorScope.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationErrorScope.cs
new file mode 100644
index 00000000000..9c4c06511be
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationErrorScope.cs
@@ -0,0 +1,17 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+internal enum BuildCheckConfigurationErrorScope
+{
+    /// <summary>
+    /// Error related to the single rule.
+    /// </summary>
+    SingleRule,
+
+    /// <summary>
+    /// Error related to the parsing of .editorconfig file. 
+    /// </summary>
+    EditorConfigParser
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
index 29a0a8acf50..69f3335681d 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
@@ -7,7 +7,7 @@
 using System.Text;
 using System.Threading.Tasks;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure;
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal sealed class BuildCheckConfigurationException : Exception
 {
@@ -15,7 +15,15 @@ internal sealed class BuildCheckConfigurationException : Exception
     /// Exception to communicate issues with user specified configuration - unsupported scenarios, malformations, etc.
     /// This exception usually leads to defuncting the particular analyzer for the rest of the build (even if issue occured with a single project).
     /// </summary>
-    public BuildCheckConfigurationException(string message) : base(message)
+    internal BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope;
+
+    public BuildCheckConfigurationException(string message, Exception innerException, BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope = BuildCheckConfigurationErrorScope.SingleRule) : base(message, innerException)
+    {
+        this.buildCheckConfigurationErrorScope = buildCheckConfigurationErrorScope;
+    }
+
+    public BuildCheckConfigurationException(string message, BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope = BuildCheckConfigurationErrorScope.SingleRule) : base(message)
     {
+        this.buildCheckConfigurationErrorScope = buildCheckConfigurationErrorScope;
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index 361c30c4200..7dad5f0c4da 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -5,12 +5,12 @@
 using System.Collections.Generic;
 using System.Linq;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.BuildCheck.Acquisition;
+using Microsoft.Build.Experimental.BuildCheck.Acquisition;
+using Microsoft.Build.Experimental.BuildCheck.Utilities;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
-using static Microsoft.Build.BuildCheck.Infrastructure.BuildCheckManagerProvider;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure;
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal sealed class BuildCheckConnectorLogger : ILogger
 {
@@ -36,6 +36,10 @@ public void Initialize(IEventSource eventSource)
         eventSource.AnyEventRaised += EventSource_AnyEventRaised;
         eventSource.BuildFinished += EventSource_BuildFinished;
 
+        if (eventSource is IEventSource3 eventSource3)
+        {
+            eventSource3.IncludeTaskInputs();
+        }
         if (eventSource is IEventSource4 eventSource4)
         {
             eventSource4.IncludeEvaluationPropertiesAndItems();
@@ -66,6 +70,35 @@ private void HandleProjectEvaluationStartedEvent(ProjectEvaluationStartedEventAr
         }
     }
 
+    private void HandleBuildCheckTracingEvent(BuildCheckTracingEventArgs eventArgs)
+    {
+        if (!eventArgs.IsAggregatedGlobalReport)
+        {
+            _stats.Merge(eventArgs.TracingData, (span1, span2) => span1 + span2);
+        }
+    }
+
+    private void HandleTaskStartedEvent(TaskStartedEventArgs eventArgs)
+    {
+        _buildCheckManager.ProcessTaskStartedEventArgs(
+            _loggingContextFactory.CreateLoggingContext(eventArgs.BuildEventContext!),
+            eventArgs);
+    }
+
+    private void HandleTaskFinishedEvent(TaskFinishedEventArgs eventArgs)
+    {
+        _buildCheckManager.ProcessTaskFinishedEventArgs(
+            _loggingContextFactory.CreateLoggingContext(eventArgs.BuildEventContext!),
+            eventArgs);
+    }
+
+    private void HandleTaskParameterEvent(TaskParameterEventArgs eventArgs)
+    {
+        _buildCheckManager.ProcessTaskParameterEventArgs(
+            _loggingContextFactory.CreateLoggingContext(eventArgs.BuildEventContext!),
+            eventArgs);
+    }
+
     private bool IsMetaProjFile(string? projectFile) => !string.IsNullOrEmpty(projectFile) && projectFile!.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase);
 
     private void EventSource_AnyEventRaised(object sender, BuildEventArgs e)
@@ -80,29 +113,64 @@ private void EventSource_AnyEventRaised(object sender, BuildEventArgs e)
 
     private void EventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
     {
-        _stats.Merge(_buildCheckManager.CreateTracingStats(), (span1, span2) => span1 + span2);
-        string msg = string.Join(Environment.NewLine, _stats.Select(a => a.Key + ": " + a.Value));
+        LoggingContext loggingContext = _loggingContextFactory.CreateLoggingContext(GetBuildEventContext(e));
 
-        BuildEventContext buildEventContext = e.BuildEventContext
-            ?? new BuildEventContext(
-                BuildEventContext.InvalidNodeId,
-                BuildEventContext.InvalidTargetId,
-                BuildEventContext.InvalidProjectContextId,
-                BuildEventContext.InvalidTaskId);
+        _stats.Merge(_buildCheckManager.CreateAnalyzerTracingStats(), (span1, span2) => span1 + span2);
+        LogAnalyzerStats(loggingContext);
+    }
+
+    private void LogAnalyzerStats(LoggingContext loggingContext)
+    {
+        Dictionary<string, TimeSpan> infraStats = new Dictionary<string, TimeSpan>();
+        Dictionary<string, TimeSpan> analyzerStats = new Dictionary<string, TimeSpan>();
+
+        foreach (var stat in _stats)
+        {
+            if (stat.Key.StartsWith(BuildCheckConstants.infraStatPrefix))
+            {
+                string newKey = stat.Key.Substring(BuildCheckConstants.infraStatPrefix.Length);
+                infraStats[newKey] = stat.Value;
+            }
+            else
+            {
+                analyzerStats[stat.Key] = stat.Value;
+            }
+        }
+
+        BuildCheckTracingEventArgs statEvent = new BuildCheckTracingEventArgs(_stats, true)
+        { BuildEventContext = loggingContext.BuildEventContext };
 
-        LoggingContext loggingContext = _loggingContextFactory.CreateLoggingContext(buildEventContext);
+        loggingContext.LogBuildEvent(statEvent);
 
-        // Tracing: https://github.com/dotnet/msbuild/issues/9629
-        loggingContext.LogCommentFromText(MessageImportance.High, msg);
+        loggingContext.LogCommentFromText(MessageImportance.Low, $"BuildCheck run times{Environment.NewLine}");
+        string infraData = BuildCsvString("Infrastructure run times", infraStats);
+        loggingContext.LogCommentFromText(MessageImportance.Low, infraData);
+        string analyzerData = BuildCsvString("Analyzer run times", analyzerStats);
+        loggingContext.LogCommentFromText(MessageImportance.Low, analyzerData);
+    }
+
+    private string BuildCsvString(string title, Dictionary<string, TimeSpan> rowData)
+    {
+        return title + Environment.NewLine + String.Join(Environment.NewLine, rowData.Select(a => $"{a.Key},{a.Value}")) + Environment.NewLine;
     }
 
     private Dictionary<Type, Action<BuildEventArgs>> GetBuildEventHandlers() => new()
     {
-        { typeof(ProjectEvaluationFinishedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationFinishedEvent((ProjectEvaluationFinishedEventArgs) e) },
-        { typeof(ProjectEvaluationStartedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs) e) },
+        { typeof(ProjectEvaluationFinishedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationFinishedEvent((ProjectEvaluationFinishedEventArgs)e) },
+        { typeof(ProjectEvaluationStartedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs)e) },
         { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => _buildCheckManager.StartProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
         { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => _buildCheckManager.EndProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
-        { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => _stats.Merge(((BuildCheckTracingEventArgs)e).TracingData, (span1, span2) => span1 + span2) },
-        { typeof(BuildCheckAcquisitionEventArgs), (BuildEventArgs e) => _buildCheckManager.ProcessAnalyzerAcquisition(((BuildCheckAcquisitionEventArgs)e).ToAnalyzerAcquisitionData(), e.BuildEventContext!) },
+        { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => HandleBuildCheckTracingEvent((BuildCheckTracingEventArgs)e) },
+        { typeof(BuildCheckAcquisitionEventArgs), (BuildEventArgs e) => _buildCheckManager.ProcessAnalyzerAcquisition(((BuildCheckAcquisitionEventArgs)e).ToAnalyzerAcquisitionData(), GetBuildEventContext(e)) },
+        { typeof(TaskStartedEventArgs), (BuildEventArgs e) => HandleTaskStartedEvent((TaskStartedEventArgs)e) },
+        { typeof(TaskFinishedEventArgs), (BuildEventArgs e) => HandleTaskFinishedEvent((TaskFinishedEventArgs)e) },
+        { typeof(TaskParameterEventArgs), (BuildEventArgs e) => HandleTaskParameterEvent((TaskParameterEventArgs)e) },
     };
+
+    private BuildEventContext GetBuildEventContext(BuildEventArgs e) => e.BuildEventContext
+        ?? new BuildEventContext(
+                BuildEventContext.InvalidNodeId,
+                BuildEventContext.InvalidTargetId,
+                BuildEventContext.InvalidProjectContextId,
+                BuildEventContext.InvalidTaskId);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
index 19a4e3d6967..76ac5ec7767 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
@@ -5,7 +5,7 @@
 using System.Threading;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure;
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal sealed class BuildCheckRegistrationContext(BuildAnalyzerWrapper analyzerWrapper, BuildCheckCentralContext buildCheckCentralContext) : IBuildCheckRegistrationContext
 {
@@ -18,4 +18,9 @@ public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAn
     {
         buildCheckCentralContext.RegisterParsedItemsAction(analyzerWrapper, parsedItemsAction);
     }
+
+    public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
+    {
+        buildCheckCentralContext.RegisterTaskInvocationAction(analyzerWrapper, taskInvocationAction);
+    }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
new file mode 100644
index 00000000000..6e8f969b544
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
@@ -0,0 +1,19 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+/// <summary>
+/// Forwarding logger for the build check infrastructure.
+/// For now we jus want to forward all events, while disable verbose logging of tasks.
+/// In the future we may need more specific behavior.
+/// </summary>
+internal class BuildCheckForwardingLogger : CentralForwardingLogger
+{ }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 33985a81707..f76b6434356 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -3,18 +3,19 @@
 
 using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Linq;
 using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.BuildCheck.Acquisition;
-using Microsoft.Build.BuildCheck.Analyzers;
-using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Experimental.BuildCheck.Acquisition;
+using Microsoft.Build.Experimental.BuildCheck.Analyzers;
+using Microsoft.Build.Experimental.BuildCheck.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure;
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal delegate BuildAnalyzer BuildAnalyzerFactory();
 internal delegate BuildAnalyzerWrapper BuildAnalyzerWrapperFactory(ConfigurationContext configurationContext);
@@ -63,7 +64,8 @@ public void InitializeComponent(IBuildComponentHost host)
     internal sealed class BuildCheckManager : IBuildCheckManager
     {
         private readonly TracingReporter _tracingReporter = new TracingReporter();
-        private readonly BuildCheckCentralContext _buildCheckCentralContext = new();
+        private readonly ConfigurationProvider _configurationProvider = new ConfigurationProvider();
+        private readonly BuildCheckCentralContext _buildCheckCentralContext;
         private readonly ILoggingService _loggingService;
         private readonly List<BuildAnalyzerFactoryContext> _analyzersRegistry;
         private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
@@ -75,6 +77,7 @@ internal BuildCheckManager(ILoggingService loggingService)
             _analyzersRegistry = new List<BuildAnalyzerFactoryContext>();
             _acquisitionModule = new BuildCheckAcquisitionModule(loggingService);
             _loggingService = loggingService;
+            _buildCheckCentralContext = new(_configurationProvider);
             _buildEventsProcessor = new(_buildCheckCentralContext);
         }
 
@@ -88,15 +91,19 @@ internal BuildCheckManager(ILoggingService loggingService)
         /// <param name="buildCheckDataSource"></param>
         public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
         {
+            Stopwatch stopwatch = Stopwatch.StartNew();
             if (!_enabledDataSources[(int)buildCheckDataSource])
             {
                 _enabledDataSources[(int)buildCheckDataSource] = true;
                 RegisterBuiltInAnalyzers(buildCheckDataSource);
             }
+            stopwatch.Stop();
+            _tracingReporter.AddSetDataSourceStats(stopwatch.Elapsed);
         }
 
         public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext)
         {
+            Stopwatch stopwatch = Stopwatch.StartNew();
             if (IsInProcNode)
             {
                 var analyzersFactories = _acquisitionModule.CreateBuildAnalyzerFactories(acquisitionData, buildEventContext);
@@ -116,6 +123,8 @@ public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData,
 
                 _loggingService.LogBuildEvent(eventArgs);
             }
+            stopwatch.Stop();
+            _tracingReporter.AddAcquisitionStats(stopwatch.Elapsed);
         }
 
         private static T Construct<T>() where T : new() => new();
@@ -130,11 +139,23 @@ private static readonly (string[] ruleIds, bool defaultEnablement, BuildAnalyzer
             []
         ];
 
+        /// <summary>
+        /// For tests only. TODO: Remove when analyzer acquisition is done.
+        /// </summary>
+        internal static (string[] ruleIds, bool defaultEnablement, BuildAnalyzerFactory factory)[][]? s_testFactoriesPerDataSource;
+
         private void RegisterBuiltInAnalyzers(BuildCheckDataSource buildCheckDataSource)
         {
             _analyzersRegistry.AddRange(
                 s_builtInFactoriesPerDataSource[(int)buildCheckDataSource]
                     .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
+
+            if (s_testFactoriesPerDataSource is not null)
+            {
+                _analyzersRegistry.AddRange(
+                    s_testFactoriesPerDataSource[(int)buildCheckDataSource]
+                        .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
+            }
         }
 
         /// <summary>
@@ -194,7 +215,7 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
             if (analyzerFactoryContext.MaterializedAnalyzer == null)
             {
                 BuildAnalyzerConfiguration[] userConfigs =
-                    ConfigurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                    _configurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
 
                 if (userConfigs.All(c => !(c.IsEnabled ?? analyzerFactoryContext.IsEnabledByDefault)))
                 {
@@ -203,7 +224,7 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
                 }
 
                 CustomConfigurationData[] customConfigData =
-                    ConfigurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                    _configurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
 
                 ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData);
 
@@ -227,7 +248,7 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
                         $"The analyzer '{analyzer.FriendlyName}' exposes rules '{analyzer.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{analyzerFactoryContext.RuleIds.ToCsvString()}'");
                 }
 
-                configurations = ConfigurationProvider.GetMergedConfigurations(userConfigs, analyzer);
+                configurations = _configurationProvider.GetMergedConfigurations(userConfigs, analyzer);
 
                 // technically all analyzers rules could be disabled, but that would mean
                 // that the provided 'IsEnabledByDefault' value wasn't correct - the only
@@ -242,9 +263,9 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
             {
                 wrapper = analyzerFactoryContext.MaterializedAnalyzer;
 
-                configurations = ConfigurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
+                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
 
-                ConfigurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
+                _configurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
                     analyzerFactoryContext.RuleIds[0]);
 
                 // Update the wrapper
@@ -266,7 +287,7 @@ private void SetupAnalyzersForNewProject(string projectFullPath, BuildEventConte
             // On an execution node - we might remove and dispose the analyzers once project is done
 
             // If it's already constructed - just control the custom settings do not differ
-
+            Stopwatch stopwatch = Stopwatch.StartNew();
             List<BuildAnalyzerFactoryContext> analyzersToRemove = new();
             foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
             {
@@ -291,9 +312,12 @@ private void SetupAnalyzersForNewProject(string projectFullPath, BuildEventConte
             foreach (var analyzerToRemove in analyzersToRemove.Select(a => a.MaterializedAnalyzer).Where(a => a != null))
             {
                 _buildCheckCentralContext.DeregisterAnalyzer(analyzerToRemove!);
-                _tracingReporter.AddStats(analyzerToRemove!.BuildAnalyzer.FriendlyName, analyzerToRemove.Elapsed);
+                _tracingReporter.AddAnalyzerStats(analyzerToRemove!.BuildAnalyzer.FriendlyName, analyzerToRemove.Elapsed);
                 analyzerToRemove.BuildAnalyzer.Dispose();
             }
+
+            stopwatch.Stop();
+            _tracingReporter.AddNewProjectStats(stopwatch.Elapsed);
         }
 
         public void ProcessEvaluationFinishedEventArgs(
@@ -302,19 +326,37 @@ public void ProcessEvaluationFinishedEventArgs(
             => _buildEventsProcessor
                 .ProcessEvaluationFinishedEventArgs(buildAnalysisContext, evaluationFinishedEventArgs);
 
-        // Tracing: https://github.com/dotnet/msbuild/issues/9629
-        public Dictionary<string, TimeSpan> CreateTracingStats()
+        public void ProcessTaskStartedEventArgs(
+            AnalyzerLoggingContext buildAnalysisContext,
+            TaskStartedEventArgs taskStartedEventArgs)
+            => _buildEventsProcessor
+                .ProcessTaskStartedEventArgs(buildAnalysisContext, taskStartedEventArgs);
+
+        public void ProcessTaskFinishedEventArgs(
+            AnalyzerLoggingContext buildAnalysisContext,
+            TaskFinishedEventArgs taskFinishedEventArgs)
+            => _buildEventsProcessor
+                .ProcessTaskFinishedEventArgs(buildAnalysisContext, taskFinishedEventArgs);
+
+        public void ProcessTaskParameterEventArgs(
+            AnalyzerLoggingContext buildAnalysisContext,
+            TaskParameterEventArgs taskParameterEventArgs)
+            => _buildEventsProcessor
+                .ProcessTaskParameterEventArgs(buildAnalysisContext, taskParameterEventArgs);
+
+        public Dictionary<string, TimeSpan> CreateAnalyzerTracingStats()
         {
             foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
             {
                 if (analyzerFactoryContext.MaterializedAnalyzer != null)
                 {
-                    _tracingReporter.AddStats(analyzerFactoryContext.FriendlyName,
+                    _tracingReporter.AddAnalyzerStats(analyzerFactoryContext.FriendlyName,
                         analyzerFactoryContext.MaterializedAnalyzer.Elapsed);
                     analyzerFactoryContext.MaterializedAnalyzer.ClearStats();
                 }
             }
 
+            _tracingReporter.AddAnalyzerInfraStats();
             return _tracingReporter.TracingStats;
         }
 
@@ -326,9 +368,11 @@ public void FinalizeProcessing(LoggingContext loggingContext)
                 return;
             }
 
-            BuildCheckTracingEventArgs eventArgs =
-                new(CreateTracingStats()) { BuildEventContext = loggingContext.BuildEventContext };
-            loggingContext.LogBuildEvent(eventArgs);
+            var analyzerEventStats = CreateAnalyzerTracingStats();
+
+            BuildCheckTracingEventArgs analyzerEventArg =
+                new(analyzerEventStats) { BuildEventContext = loggingContext.BuildEventContext };
+            loggingContext.LogBuildEvent(analyzerEventArg);
         }
 
         public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext,
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
index 9514f0a7ca0..aa804067b60 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -12,8 +12,8 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Components.Caching;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.BuildCheck.Analyzers;
-using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Experimental.BuildCheck.Analyzers;
+using Microsoft.Build.Experimental.BuildCheck.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
@@ -21,13 +21,31 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure;
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal class BuildEventsProcessor(BuildCheckCentralContext buildCheckCentralContext)
 {
+    /// <summary>
+    /// Represents a task currently being executed.
+    /// </summary>
+    /// <remarks>
+    /// <see cref="TaskParameters"/> is stored in its own field typed as a mutable dictionary because <see cref="AnalysisData"/>
+    /// is immutable.
+    /// </remarks>
+    private struct ExecutingTaskData
+    {
+        public TaskInvocationAnalysisData AnalysisData;
+        public Dictionary<string, TaskInvocationAnalysisData.TaskParameter> TaskParameters;
+    }
+
     private readonly SimpleProjectRootElementCache _cache = new SimpleProjectRootElementCache();
     private readonly BuildCheckCentralContext _buildCheckCentralContext = buildCheckCentralContext;
 
+    /// <summary>
+    /// Keeps track of in-flight tasks. Keyed by task ID as passed in <see cref="BuildEventContext.TaskId"/>.
+    /// </summary>
+    private readonly Dictionary<int, ExecutingTaskData> _tasksBeingExecuted = [];
+
     // This requires MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION set to 1
     internal void ProcessEvaluationFinishedEventArgs(
         AnalyzerLoggingContext buildAnalysisContext,
@@ -55,6 +73,95 @@ internal void ProcessEvaluationFinishedEventArgs(
         }
     }
 
+    internal void ProcessTaskStartedEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        TaskStartedEventArgs taskStartedEventArgs)
+    {
+        if (!_buildCheckCentralContext.HasTaskInvocationActions)
+        {
+            // No analyzer is interested in task invocation actions -> nothing to do.
+            return;
+        }
+
+        if (taskStartedEventArgs.BuildEventContext is not null)
+        {
+            ElementLocation invocationLocation = ElementLocation.Create(
+                taskStartedEventArgs.TaskFile,
+                taskStartedEventArgs.LineNumber,
+                taskStartedEventArgs.ColumnNumber);
+
+            // Add a new entry to _tasksBeingExecuted. TaskParameters are initialized empty and will be recorded
+            // based on TaskParameterEventArgs we receive later.
+            Dictionary<string, TaskInvocationAnalysisData.TaskParameter> taskParameters = new();
+
+            ExecutingTaskData taskData = new()
+            {
+                TaskParameters = taskParameters,
+                AnalysisData = new(
+                    projectFilePath: taskStartedEventArgs.ProjectFile!,
+                    taskInvocationLocation: invocationLocation,
+                    taskName: taskStartedEventArgs.TaskName,
+                    taskAssemblyLocation: taskStartedEventArgs.TaskAssemblyLocation,
+                    parameters: taskParameters),
+            };
+
+            _tasksBeingExecuted.Add(taskStartedEventArgs.BuildEventContext.TaskId, taskData);
+        }
+    }
+
+    internal void ProcessTaskFinishedEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        TaskFinishedEventArgs taskFinishedEventArgs)
+    {
+        if (!_buildCheckCentralContext.HasTaskInvocationActions)
+        {
+            // No analyzer is interested in task invocation actions -> nothing to do.
+            return;
+        }
+
+        if (taskFinishedEventArgs.BuildEventContext is not null &&
+            _tasksBeingExecuted.TryGetValue(taskFinishedEventArgs.BuildEventContext.TaskId, out ExecutingTaskData taskData))
+        {
+            // All task parameters have been recorded by now so remove the task from the dictionary and fire the registered build check actions.
+            _tasksBeingExecuted.Remove(taskFinishedEventArgs.BuildEventContext.TaskId);
+            _buildCheckCentralContext.RunTaskInvocationActions(taskData.AnalysisData, buildAnalysisContext, ReportResult);
+        }
+    }
+
+    internal void ProcessTaskParameterEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        TaskParameterEventArgs taskParameterEventArgs)
+    {
+        if (!_buildCheckCentralContext.HasTaskInvocationActions)
+        {
+            // No analyzer is interested in task invocation actions -> nothing to do.
+            return;
+        }
+
+        bool isOutput;
+        switch (taskParameterEventArgs.Kind)
+        {
+            case TaskParameterMessageKind.TaskInput: isOutput = false; break;
+            case TaskParameterMessageKind.TaskOutput: isOutput = true; break;
+            default: return;
+        }
+
+        if (taskParameterEventArgs.BuildEventContext is not null &&
+            _tasksBeingExecuted.TryGetValue(taskParameterEventArgs.BuildEventContext.TaskId, out ExecutingTaskData taskData))
+        {
+            // Add the parameter name and value to the matching entry in _tasksBeingExecuted. Parameters come typed as IList
+            // but it's more natural to pass them as scalar values so we unwrap one-element lists.
+            string parameterName = taskParameterEventArgs.ParameterName;
+            object? parameterValue = taskParameterEventArgs.Items?.Count switch
+            {
+                1 => taskParameterEventArgs.Items[0],
+                _ => taskParameterEventArgs.Items,
+            };
+
+            taskData.TaskParameters[parameterName] = new TaskInvocationAnalysisData.TaskParameter(parameterValue, isOutput);
+        }
+    }
+
     private static void ReportResult(
         BuildAnalyzerWrapper analyzerWrapper,
         LoggingContext loggingContext,
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
index 67c2155500e..ab2e298879b 100644
--- a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -3,72 +3,39 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
-using System.IO;
 using System.Linq;
-using System.Text;
-using System.Text.Json.Serialization;
-using System.Text.Json;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
 using Microsoft.Build.Experimental.BuildCheck;
-using System.Configuration;
+using System.Collections.Concurrent;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure;
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-
-// Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)
-// Tracked via: https://github.com/dotnet/msbuild/issues/9828
-internal static class ConfigurationProvider
+internal sealed class ConfigurationProvider
 {
-    // We might want to have a mechanism for removing unneeded configurations
-    //  (disabled rules and analyzers that need to run in different node)
-    private static readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = LoadConfiguration();
-
-    // This is just a testing implementation for quicker unblock of testing.
-    // Real implementation will use .editorconfig file.
-    // Sample json:
-    /////*lang=json,strict*/
-    ////"""
-    ////    {
-    ////        "ABC123": {
-    ////            "IsEnabled": true,
-    ////            "Severity": "Info"
-    ////        },
-    ////        "COND0543": {
-    ////            "IsEnabled": false,
-    ////            "Severity": "Error",
-    ////    		"EvaluationAnalysisScope": "AnalyzedProjectOnly",
-    ////    		"CustomSwitch": "QWERTY"
-    ////        },
-    ////        "BLA": {
-    ////            "IsEnabled": false
-    ////        }
-    ////    }
-    ////    """
-    //
-    // Plus there will need to be a mechanism of distinguishing different configs in different folders
-    //  - e.g. - what to do if we analyze two projects (not sharing output path) and they have different .editorconfig files?
-    private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration()
-    {
-        const string configFileName = "editorconfig.json";
-        string configPath = configFileName;
+    private readonly EditorConfigParser _editorConfigParser = new EditorConfigParser();
 
-        if (!File.Exists(configPath))
-        {
-            // This is just a dummy implementation for testing purposes
-            var dir = Environment.CurrentDirectory;
-            configPath = Path.Combine(dir, configFileName);
+    private const string BuildCheck_ConfigurationKey = "build_check";
 
-            if (!File.Exists(configPath))
-            {
-                return new Dictionary<string, BuildAnalyzerConfiguration>();
-            }
-        }
+    /// <summary>
+    /// The dictionary used for storing the BuildAnalyzerConfiguration per projectfile and rule id. The key is equal to {projectFullPath}-{ruleId}.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, BuildAnalyzerConfiguration> _buildAnalyzerConfiguration = new ConcurrentDictionary<string, BuildAnalyzerConfiguration>(StringComparer.InvariantCultureIgnoreCase);
 
-        var json = File.ReadAllText(configPath);
-        var DeserializationOptions = new JsonSerializerOptions { Converters = { new JsonStringEnumConverter() } };
-        return JsonSerializer.Deserialize<Dictionary<string, BuildAnalyzerConfiguration>>(json, DeserializationOptions) ??
-               new Dictionary<string, BuildAnalyzerConfiguration>();
-    }
+    /// <summary>
+    /// The dictionary used for storing the key-value pairs retrieved from the .editorconfigs for specific projectfile. The key is equal to projectFullPath.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, Dictionary<string, string>> _editorConfigData = new ConcurrentDictionary<string, Dictionary<string, string>>(StringComparer.InvariantCultureIgnoreCase);
+
+    /// <summary>
+    /// The dictionary used for storing the CustomConfigurationData per ruleId. The key is equal to ruleId.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, CustomConfigurationData> _customConfigurationData = new ConcurrentDictionary<string, CustomConfigurationData>(StringComparer.InvariantCultureIgnoreCase);
+
+    private readonly string[] _infrastructureConfigurationKeys = new string[] {
+        nameof(BuildAnalyzerConfiguration.EvaluationAnalysisScope).ToLower(),
+        nameof(BuildAnalyzerConfiguration.IsEnabled).ToLower(),
+        nameof(BuildAnalyzerConfiguration.Severity).ToLower()
+    };
 
     /// <summary>
     /// Gets the user specified unrecognized configuration for the given analyzer rule.
@@ -80,39 +47,82 @@ private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration(
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <returns></returns>
-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)
+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)
     {
-        return CustomConfigurationData.Null;
+        var configuration = GetConfiguration(projectFullPath, ruleId);
+
+        if (configuration is null)
+        {
+            return CustomConfigurationData.Null;
+        }
+
+        // remove the infrastructure owned key names
+        foreach (var infraConfigurationKey in _infrastructureConfigurationKeys)
+        {
+            configuration.Remove(infraConfigurationKey);
+        }
+
+        if (!configuration.Any())
+        {
+            return CustomConfigurationData.Null;
+        }
+
+        var data = new CustomConfigurationData(ruleId, configuration);
+
+        if (!_customConfigurationData.ContainsKey(ruleId))
+        {
+            _customConfigurationData[ruleId] = data;
+        }
+
+        return data;
     }
 
     /// <summary>
-    /// 
+    /// Verifies if previously fetched custom configurations are equal to current one. 
     /// </summary>
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <throws><see cref="BuildCheckConfigurationException"/> If CustomConfigurationData differs in a build for a same ruleId</throws>
     /// <returns></returns>
-    public static void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
+    internal void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
     {
-        // TBD
+        var configuration = GetCustomConfiguration(projectFullPath, ruleId);
+        VerifyCustomConfigurationEquality(ruleId, configuration);
     }
 
-    public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
+    internal void VerifyCustomConfigurationEquality(string ruleId, CustomConfigurationData configurationData)
+    {
+        if (_customConfigurationData.TryGetValue(ruleId, out var storedConfiguration))
+        {
+            if (!storedConfiguration.Equals(configurationData))
+            {
+                throw new BuildCheckConfigurationException("Custom configuration should be equal between projects");
+            }
+        }
+    }
+
+    internal BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
         string projectFullPath,
         BuildAnalyzer analyzer)
         => FillConfiguration(projectFullPath, analyzer.SupportedRules, GetMergedConfiguration);
 
-    public static BuildAnalyzerConfiguration[] GetUserConfigurations(
+    internal BuildAnalyzerConfiguration[] GetUserConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetUserConfiguration);
 
-    public static CustomConfigurationData[] GetCustomConfigurations(
+    /// <summary>
+    /// Retrieve array of CustomConfigurationData for a given projectPath and ruleIds
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <param name="ruleIds"></param>
+    /// <returns></returns>
+    public CustomConfigurationData[] GetCustomConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetCustomConfiguration);
 
-    public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
+    internal BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
         BuildAnalyzerConfiguration[] userConfigs,
         BuildAnalyzer analyzer)
     {
@@ -120,7 +130,7 @@ public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
 
         for (int idx = 0; idx < userConfigs.Length; idx++)
         {
-            configurations[idx] = ConfigurationProvider.MergeConfiguration(
+            configurations[idx] = MergeConfiguration(
                 analyzer.SupportedRules[idx].Id,
                 analyzer.SupportedRules[idx].DefaultConfiguration,
                 userConfigs[idx]);
@@ -129,7 +139,7 @@ public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
         return configurations;
     }
 
-    private static TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPath, IReadOnlyList<TRule> ruleIds, Func<string, TRule, TConfig> configurationProvider)
+    private TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPath, IReadOnlyList<TRule> ruleIds, Func<string, TRule, TConfig> configurationProvider)
     {
         TConfig[] configurations = new TConfig[ruleIds.Count];
         for (int i = 0; i < ruleIds.Count; i++)
@@ -140,6 +150,72 @@ private static TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPat
         return configurations;
     }
 
+
+    /// <summary>
+    /// Generates a new dictionary that contains the key-value pairs from the original dictionary if the key starts with 'keyFilter'.
+    /// If updateKey is set to 'true', the keys of the new dictionary will not include keyFilter.
+    /// </summary>
+    /// <param name="keyFilter"></param>
+    /// <param name="originalConfiguration"></param>
+    /// <param name="updateKey"></param>
+    /// <returns></returns>
+    private Dictionary<string, string> FilterDictionaryByKeys(string keyFilter, Dictionary<string, string> originalConfiguration, bool updateKey = false)
+    {
+        var filteredConfig = new Dictionary<string, string>();
+
+        foreach (var kv in originalConfiguration)
+        {
+            if (kv.Key.StartsWith(keyFilter, StringComparison.OrdinalIgnoreCase))
+            {
+                var newKey = kv.Key;
+                if (updateKey)
+                {
+                    newKey = kv.Key.Substring(keyFilter.Length);
+                }
+
+                filteredConfig[newKey] = kv.Value;
+            }
+        }
+
+        return filteredConfig;
+    }
+
+    /// <summary>
+    /// Fetches the .editorconfig data in form of Key-Value pair.
+    /// Resulted dictionary will contain only BuildCheck related rules.
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <returns></returns>
+    /// <exception cref="BuildCheckConfigurationException"></exception>
+    private Dictionary<string, string> FetchEditorConfigRules(string projectFullPath)
+    {
+        var editorConfigRules = _editorConfigData.GetOrAdd(projectFullPath, (key) =>
+        {
+            Dictionary<string, string> config;
+            try
+            {
+                config = _editorConfigParser.Parse(projectFullPath);
+            }
+            catch (Exception exception)
+            {
+                throw new BuildCheckConfigurationException($"Parsing editorConfig data failed", exception, BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+
+            // clear the dictionary from the key-value pairs not BuildCheck related and
+            // store the data so there is no need to parse the .editorconfigs all over again
+            Dictionary<string, string> filteredData = FilterDictionaryByKeys($"{BuildCheck_ConfigurationKey}.", config);
+            return filteredData;
+        });
+        
+        return editorConfigRules;
+    }
+
+    internal Dictionary<string, string> GetConfiguration(string projectFullPath, string ruleId)
+    {
+        var config = FetchEditorConfigRules(projectFullPath);
+        return FilterDictionaryByKeys($"{BuildCheck_ConfigurationKey}.{ruleId}.", config, updateKey: true);
+    }
+
     /// <summary>
     /// Gets effective user specified (or default) configuration for the given analyzer rule.
     /// The configuration values CAN be null upon this operation.
@@ -150,14 +226,24 @@ private static TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPat
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <returns></returns>
-    public static BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
+    internal BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
     {
-        if (!_editorConfig.TryGetValue(ruleId, out BuildAnalyzerConfiguration? editorConfig))
+        var cacheKey = $"{ruleId}-{projectFullPath}";
+
+        var editorConfigValue = _buildAnalyzerConfiguration.GetOrAdd(cacheKey, (key) =>
         {
-            editorConfig = BuildAnalyzerConfiguration.Null;
-        }
+            BuildAnalyzerConfiguration? editorConfig = BuildAnalyzerConfiguration.Null;
+            var config = GetConfiguration(projectFullPath, ruleId);
+
+            if (config.Any())
+            {
+                editorConfig = BuildAnalyzerConfiguration.Create(config);
+            }
+
+            return editorConfig;
+        });
 
-        return editorConfig;
+        return editorConfigValue;
     }
 
     /// <summary>
@@ -167,10 +253,10 @@ public static BuildAnalyzerConfiguration GetUserConfiguration(string projectFull
     /// <param name="projectFullPath"></param>
     /// <param name="analyzerRule"></param>
     /// <returns></returns>
-    public static BuildAnalyzerConfigurationInternal GetMergedConfiguration(string projectFullPath, BuildAnalyzerRule analyzerRule)
+    internal BuildAnalyzerConfigurationInternal GetMergedConfiguration(string projectFullPath, BuildAnalyzerRule analyzerRule)
         => GetMergedConfiguration(projectFullPath, analyzerRule.Id, analyzerRule.DefaultConfiguration);
 
-    public static BuildAnalyzerConfigurationInternal MergeConfiguration(
+    internal BuildAnalyzerConfigurationInternal MergeConfiguration(
         string ruleId,
         BuildAnalyzerConfiguration defaultConfig,
         BuildAnalyzerConfiguration editorConfig)
@@ -180,13 +266,13 @@ public static BuildAnalyzerConfigurationInternal MergeConfiguration(
             isEnabled: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.IsEnabled),
             severity: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.Severity));
 
-    private static BuildAnalyzerConfigurationInternal GetMergedConfiguration(
+    private BuildAnalyzerConfigurationInternal GetMergedConfiguration(
         string projectFullPath,
         string ruleId,
         BuildAnalyzerConfiguration defaultConfig)
         => MergeConfiguration(ruleId, defaultConfig, GetUserConfiguration(projectFullPath, ruleId));
 
-    private static T GetConfigValue<T>(
+    private T GetConfigValue<T>(
         BuildAnalyzerConfiguration editorConfigValue,
         BuildAnalyzerConfiguration defaultValue,
         Func<BuildAnalyzerConfiguration, T?> propertyGetter) where T : struct
diff --git a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
index d200d48ee66..afd3645cf2e 100644
--- a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
+++ b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
@@ -15,17 +15,27 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 ///  that were attribute to a particular rule, but were not recognized by the infrastructure.
 /// The configuration data that is recognized by the infrastructure is passed as <see cref="BuildAnalyzerConfiguration"/>.
 /// </summary>
-/// <param name="ruleId"></param>
-public class CustomConfigurationData(string ruleId)
+public sealed class CustomConfigurationData
 {
     public static CustomConfigurationData Null { get; } = new(string.Empty);
 
     public static bool NotNull(CustomConfigurationData data) => !Null.Equals(data);
 
+    public CustomConfigurationData(string ruleId)
+    {
+        RuleId = ruleId;
+    }
+
+    public CustomConfigurationData(string ruleId, Dictionary<string, string> properties)
+    {
+        RuleId = ruleId;
+        ConfigurationData = properties;
+    }
+
     /// <summary>
     /// Identifier of the rule that the configuration data is for.
     /// </summary>
-    public string RuleId { get; init; } = ruleId;
+    public string RuleId { get; init; }
 
     /// <summary>
     /// Key-value pairs of unstructured data from .editorconfig file.
@@ -50,15 +60,43 @@ public override bool Equals(object? obj)
             return true;
         }
 
-        if (obj.GetType() != this.GetType())
+        if (obj is not CustomConfigurationData)
         {
             return false;
         }
 
-        return Equals((CustomConfigurationData)obj);
-    }
+        var customConfigObj = (CustomConfigurationData) obj;
 
-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);
+        if (customConfigObj.RuleId != RuleId)
+        {
+            return false;
+        }
 
-    public override int GetHashCode() => (ConfigurationData != null ? ConfigurationData.GetHashCode() : 0);
+        // validate keys and values
+        if (customConfigObj.ConfigurationData != null && ConfigurationData != null && ConfigurationData.Count == customConfigObj.ConfigurationData.Count)
+        {
+            foreach (var keyVal in customConfigObj.ConfigurationData)
+            {
+                if (!ConfigurationData.TryGetValue(keyVal.Key, out var value) || value != keyVal.Value)
+                {
+                    return false;
+                }
+            }
+        }
+        else if (customConfigObj.ConfigurationData == null && ConfigurationData == null)
+        {
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+
+        return true;
+    }
+
+    public override int GetHashCode()
+    {
+        throw new NotImplementedException("CustomConfigurationData does not implement GetHashCode method");
+    }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
new file mode 100644
index 00000000000..d2f93664369
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
@@ -0,0 +1,184 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// Note:
+// Code and logic is copied from the https://github.com/dotnet/roslyn/blob/06d3f153ed6af6f2b78028a1e1e6ecc55c8ff101/src/Compilers/Core/Portable/CommandLine/AnalyzerConfig.cs
+// with slight changes like:
+//  1. Remove dependency from Source text.
+//  2. Remove support of globalconfig
+//  3. Remove the FilePath and receive only the text
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+
+internal partial class EditorConfigFile
+{
+    // Matches EditorConfig section header such as "[*.{js,py}]", see https://editorconfig.org for details
+    private const string s_sectionMatcherPattern = @"^\s*\[(([^#;]|\\#|\\;)+)\]\s*([#;].*)?$";
+
+    // Matches EditorConfig property such as "indent_style = space", see https://editorconfig.org for details
+    private const string s_propertyMatcherPattern = @"^\s*([\w\.\-_]+)\s*[=:]\s*(.*?)\s*([#;].*)?$";
+
+#if NETCOREAPP
+
+[GeneratedRegex(s_sectionMatcherPattern)]
+private static partial Regex GetSectionMatcherRegex();
+
+[GeneratedRegex(s_propertyMatcherPattern)]
+private static partial Regex GetPropertyMatcherRegex();
+
+#else
+    private static readonly Regex s_sectionMatcher = new Regex(s_sectionMatcherPattern, RegexOptions.Compiled);
+
+    private static readonly Regex s_propertyMatcher = new Regex(s_propertyMatcherPattern, RegexOptions.Compiled);
+
+    private static Regex GetSectionMatcherRegex() => s_sectionMatcher;
+
+    private static Regex GetPropertyMatcherRegex() => s_propertyMatcher;
+
+#endif
+
+    internal Section GlobalSection { get; }
+
+    internal ImmutableArray<Section> NamedSections { get; }
+
+    /// <summary>
+    /// Gets whether this editorconfig is a topmost editorconfig.
+    /// </summary>
+    internal bool IsRoot => GlobalSection.Properties.TryGetValue("root", out string? val) && val?.ToLower() == "true";
+
+    private EditorConfigFile(
+        Section globalSection,
+        ImmutableArray<Section> namedSections)
+    {
+        GlobalSection = globalSection;
+        NamedSections = namedSections;
+    }
+
+    /// <summary>
+    /// Parses an editor config file text located at the given path. No parsing
+    /// errors are reported. If any line contains a parse error, it is dropped.
+    /// </summary>
+    internal static EditorConfigFile Parse(string text)
+    {
+        Section? globalSection = null;
+        var namedSectionBuilder = ImmutableArray.CreateBuilder<Section>();
+
+        // N.B. The editorconfig documentation is quite loose on property interpretation.
+        // Specifically, it says:
+        //      Currently all properties and values are case-insensitive.
+        //      They are lowercased when parsed.
+        // To accommodate this, we use a lower case Unicode mapping when adding to the
+        // dictionary, but we also use a case-insensitive key comparer when doing lookups
+        var activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>(StringComparer.OrdinalIgnoreCase);
+        string activeSectionName = "";
+        var lines = string.IsNullOrEmpty(text) ? Array.Empty<string>() : text.Split(new string[] { Environment.NewLine }, StringSplitOptions.None);
+
+        foreach(var line in lines)
+        {
+            if (string.IsNullOrWhiteSpace(line))
+            {
+                continue;
+            }
+
+            if (IsComment(line))
+            {
+                continue;
+            }
+
+            var sectionMatches = GetSectionMatcherRegex().Matches(line);
+            if (sectionMatches.Count > 0 && sectionMatches[0].Groups.Count > 0)
+            {
+                addNewSection();
+
+                var sectionName = sectionMatches[0].Groups[1].Value;
+                Debug.Assert(!string.IsNullOrEmpty(sectionName));
+
+                activeSectionName = sectionName;
+                activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>();
+                continue;
+            }
+
+            var propMatches = GetPropertyMatcherRegex().Matches(line);
+            if (propMatches.Count > 0 && propMatches[0].Groups.Count > 1)
+            {
+                var key = propMatches[0].Groups[1].Value.ToLower();
+                var value = propMatches[0].Groups[2].Value;
+
+                Debug.Assert(!string.IsNullOrEmpty(key));
+                Debug.Assert(key == key.Trim());
+                Debug.Assert(value == value?.Trim());
+
+                activeSectionProperties[key] = value ?? "";
+                continue;
+            }
+        }
+
+        // Add the last section
+        addNewSection();
+
+        return new EditorConfigFile(globalSection!, namedSectionBuilder.ToImmutable());
+
+        void addNewSection()
+        {
+            // Close out the previous section
+            var previousSection = new Section(activeSectionName, activeSectionProperties.ToImmutable());
+            if (activeSectionName == "")
+            {
+                // This is the global section
+                globalSection = previousSection;
+            }
+            else
+            {
+                namedSectionBuilder.Add(previousSection);
+            }
+        }
+    }
+
+    private static bool IsComment(string line)
+    {
+        foreach (char c in line)
+        {
+            if (!char.IsWhiteSpace(c))
+            {
+                return c == '#' || c == ';';
+            }
+        }
+
+        return false;
+    }
+
+    /// <summary>
+    /// Represents a named section of the editorconfig file, which consists of a name followed by a set
+    /// of key-value pairs.
+    /// </summary>
+    internal sealed class Section
+    {
+        public Section(string name, ImmutableDictionary<string, string> properties)
+        {
+            Name = name;
+            Properties = properties;
+        }
+
+        /// <summary>
+        /// For regular files, the name as present directly in the section specification of the editorconfig file. For sections in
+        /// global configs, this is the unescaped full file path.
+        /// </summary>
+        public string Name { get; }
+
+        /// <summary>
+        /// Keys and values for this section. All keys are lower-cased according to the
+        /// EditorConfig specification and keys are compared case-insensitively. 
+        /// </summary>
+        public ImmutableDictionary<string, string> Properties { get; }
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs
new file mode 100644
index 00000000000..60df42cb36d
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs
@@ -0,0 +1,614 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// Note:
+// Copied from https://github.com/dotnet/roslyn/blob/06d3f153ed6af6f2b78028a1e1e6ecc55c8ff101/src/Compilers/Core/Portable/CommandLine/AnalyzerConfig.SectionNameMatching.cs
+// with some changes to make it quicker to integrate into the MSBuild.
+// Changes:
+//  1. ArrayBuilder was replaced with List.
+//  2. Exceptions. Wrap in try/catch blocks for proper reporting
+
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+
+internal class EditorConfigGlobsMatcher
+{
+    internal readonly struct SectionNameMatcher
+    {
+        private readonly ImmutableArray<(int minValue, int maxValue)> _numberRangePairs;
+
+        internal Regex Regex { get; }
+
+        internal SectionNameMatcher(
+            Regex regex,
+            ImmutableArray<(int minValue, int maxValue)> numberRangePairs)
+        {
+            Debug.Assert(regex.GetGroupNumbers().Length - 1 == numberRangePairs.Length);
+            Regex = regex;
+            _numberRangePairs = numberRangePairs;
+        }
+
+        internal bool IsMatch(string s)
+        {
+            if (_numberRangePairs.IsEmpty)
+            {
+                return Regex.IsMatch(s);
+            }
+
+            var match = Regex.Match(s);
+            if (!match.Success)
+            {
+                return false;
+            }
+
+            Debug.Assert(match.Groups.Count - 1 == _numberRangePairs.Length);
+            for (int i = 0; i < _numberRangePairs.Length; i++)
+            {
+                var (minValue, maxValue) = _numberRangePairs[i];
+                // Index 0 is the whole regex
+                if (!int.TryParse(match.Groups[i + 1].Value, out int matchedNum) ||
+                    matchedNum < minValue ||
+                    matchedNum > maxValue)
+                {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
+
+    /// <summary>
+    /// Takes a <see cref="EditorConfigFile.Section.Name"/> and creates a matcher that
+    /// matches the given language. Returns null if the section name is
+    /// invalid.
+    /// </summary>
+    internal static SectionNameMatcher? TryCreateSectionNameMatcher(string sectionName)
+    {
+        // An editorconfig section name is a language for recognizing file paths
+        // defined by the following grammar:
+        //
+        // <path> ::= <path-list>
+        // <path-list> ::= <path-item> | <path-item> <path-list>
+        // <path-item> ::= "*"  | "**" | "?" | <char> | <choice> | <range>
+        // <char> ::= any unicode character
+        // <choice> ::= "{" <choice-list> "}"
+        // <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+        // <range> ::= "{" <integer> ".." <integer> "}"
+        // <integer> ::= "-" <digit-list> | <digit-list>
+        // <digit-list> ::= <digit> | <digit> <digit-list>
+        // <digit> ::= 0-9
+
+        var sb = new StringBuilder();
+        sb.Append('^');
+
+        // EditorConfig matching depends on the whether or not there are
+        // directory separators and where they are located in the section
+        // name. Specifically, the editorconfig core parser says:
+        // https://github.com/editorconfig/editorconfig-core-c/blob/5d3996811e962a717a7d7fdd0a941192382241a7/src/lib/editorconfig.c#L231
+        //
+        //     Pattern would be:
+        //     /dir/of/editorconfig/file[double_star]/[section] if section does not contain '/',
+        //     /dir/of/editorconfig/file[section] if section starts with a '/', or
+        //     /dir/of/editorconfig/file/[section] if section contains '/' but does not start with '/'.
+
+        if (!sectionName.Contains("/"))
+        {
+            sb.Append(".*/");
+        }
+        else if (sectionName[0] != '/')
+        {
+            sb.Append('/');
+        }
+
+        var lexer = new SectionNameLexer(sectionName);
+        var numberRangePairs = new List<(int minValue, int maxValue)>();
+        if (!TryCompilePathList(ref lexer, sb, parsingChoice: false, numberRangePairs))
+        {
+            numberRangePairs.Clear();
+            return null;
+        }
+        sb.Append('$');
+
+
+        var imArray = ImmutableArray.CreateBuilder<(int, int)>(numberRangePairs is null ? 0 : numberRangePairs.Count);
+        if (numberRangePairs?.Count > 0)
+        {
+            imArray.AddRange(numberRangePairs);
+        }
+
+        return new SectionNameMatcher(
+            new Regex(sb.ToString(), RegexOptions.Compiled),
+            imArray.ToImmutableArray());
+    }
+
+    internal static string UnescapeSectionName(string sectionName)
+    {
+        var sb = new StringBuilder();
+        SectionNameLexer lexer = new SectionNameLexer(sectionName);
+        while (!lexer.IsDone)
+        {
+            var tokenKind = lexer.Lex();
+            if (tokenKind == TokenKind.SimpleCharacter)
+            {
+                sb.Append(lexer.EatCurrentCharacter());
+            }
+            else
+            {
+                // We only call this on strings that were already passed through IsAbsoluteEditorConfigPath, so
+                // we shouldn't have any other token kinds here.
+                throw new BuildCheckConfigurationException($"UnexpectedToken: {tokenKind}", BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+        }
+        return sb.ToString();
+    }
+
+    internal static bool IsAbsoluteEditorConfigPath(string sectionName)
+    {
+        // NOTE: editorconfig paths must use '/' as a directory separator character on all OS.
+
+        // on all unix systems this is thus a simple test: does the path start with '/'
+        // and contain no special chars?
+
+        // on windows, a path can be either drive rooted or not (e.g. start with 'c:' or just '')
+        // in addition to being absolute or relative.
+        // for example c:myfile.cs is a relative path, but rooted on drive c:
+        // /myfile2.cs is an absolute path but rooted to the current drive.
+
+        // in addition there are UNC paths and volume guids (see https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats)
+        // but these start with \\ (and thus '/' in editor config terminology)
+
+        // in this implementation we choose to ignore the drive root for the purposes of
+        // determining validity. On windows c:/file.cs and /file.cs are both assumed to be
+        // valid absolute paths, even though the second one is technically relative to
+        // the current drive of the compiler working directory. 
+
+        // Note that this check has no impact on config correctness. Files on windows
+        // will still be compared using their full path (including drive root) so it's
+        // not possible to target the wrong file. It's just possible that the user won't
+        // receive a warning that this section is ignored on windows in this edge case.
+
+        SectionNameLexer nameLexer = new SectionNameLexer(sectionName);
+        bool sawStartChar = false;
+        int logicalIndex = 0;
+        while (!nameLexer.IsDone)
+        {
+            if (nameLexer.Lex() != TokenKind.SimpleCharacter)
+            {
+                return false;
+            }
+            var simpleChar = nameLexer.EatCurrentCharacter();
+
+            // check the path starts with '/'
+            if (logicalIndex == 0)
+            {
+                if (simpleChar == '/')
+                {
+                    sawStartChar = true;
+                }
+                else if (Path.DirectorySeparatorChar == '/')
+                {
+                    return false;
+                }
+            }
+            // on windows we get a second chance to find the start char
+            else if (!sawStartChar && Path.DirectorySeparatorChar == '\\')
+            {
+                if (logicalIndex == 1 && simpleChar != ':')
+                {
+                    return false;
+                }
+                else if (logicalIndex == 2)
+                {
+                    if (simpleChar != '/')
+                    {
+                        return false;
+                    }
+                    else
+                    {
+                        sawStartChar = true;
+                    }
+                }
+            }
+            logicalIndex++;
+        }
+        return sawStartChar;
+    }
+
+
+    /// <summary>
+    /// <![CDATA[
+    /// <path-list> ::= <path-item> | <path-item> <path-list>
+    /// <path-item> ::= "*"  | "**" | "?" | <char> | <choice> | <range>
+    /// <char> ::= any unicode character
+    /// <choice> ::= "{" <choice-list> "}"
+    /// <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+    /// ]]>
+    /// </summary>
+    private static bool TryCompilePathList(
+        ref SectionNameLexer lexer,
+        StringBuilder sb,
+        bool parsingChoice,
+        List<(int minValue, int maxValue)> numberRangePairs)
+    {
+        while (!lexer.IsDone)
+        {
+            var tokenKind = lexer.Lex();
+            switch (tokenKind)
+            {
+                case TokenKind.BadToken:
+                    // Parsing failure
+                    return false;
+                case TokenKind.SimpleCharacter:
+                    // Matches just this character
+                    sb.Append(Regex.Escape(lexer.EatCurrentCharacter().ToString()));
+                    break;
+                case TokenKind.Question:
+                    // '?' matches any single character
+                    sb.Append('.');
+                    break;
+                case TokenKind.Star:
+                    // Matches any string of characters except directory separator
+                    // Directory separator is defined in editorconfig spec as '/'
+                    sb.Append("[^/]*");
+                    break;
+                case TokenKind.StarStar:
+                    // Matches any string of characters
+                    sb.Append(".*");
+                    break;
+                case TokenKind.OpenCurly:
+                    // Back up token stream. The following helpers all expect a '{'
+                    lexer.Position--;
+                    // This is ambiguous between {num..num} and {item1,item2}
+                    // We need to look ahead to disambiguate. Looking for {num..num}
+                    // is easier because it can't be recursive.
+                    (string numStart, string numEnd)? rangeOpt = TryParseNumberRange(ref lexer);
+                    if (rangeOpt is null)
+                    {
+                        // Not a number range. Try a choice expression
+                        if (!TryCompileChoice(ref lexer, sb, numberRangePairs))
+                        {
+                            return false;
+                        }
+                        // Keep looping. There may be more after the '}'.
+                        break;
+                    }
+                    else
+                    {
+                        (string numStart, string numEnd) = rangeOpt.GetValueOrDefault();
+                        if (int.TryParse(numStart, out var intStart) && int.TryParse(numEnd, out var intEnd))
+                        {
+                            var pair = intStart < intEnd ? (intStart, intEnd) : (intEnd, intStart);
+                            numberRangePairs.Add(pair);
+                            // Group allowing any digit sequence. The validity will be checked outside of the regex
+                            sb.Append("(-?[0-9]+)");
+                            // Keep looping
+                            break;
+                        }
+                        return false;
+                    }
+                case TokenKind.CloseCurly:
+                    // Either the end of a choice, or a failed parse
+                    return parsingChoice;
+                case TokenKind.Comma:
+                    // The end of a choice section, or a failed parse
+                    return parsingChoice;
+                case TokenKind.OpenBracket:
+                    sb.Append('[');
+                    if (!TryCompileCharacterClass(ref lexer, sb))
+                    {
+                        return false;
+                    }
+                    break;
+                default:
+                    throw new BuildCheckConfigurationException($"UnexpectedToken: {tokenKind}", BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+        }
+        // If we're parsing a choice we should not exit without a closing '}'
+        return !parsingChoice;
+    }
+
+    /// <summary>
+    /// Compile a globbing character class of the form [...]. Returns true if
+    /// the character class was successfully compiled. False if there was a syntax
+    /// error. The starting character is expected to be directly after the '['.
+    /// </summary>
+    private static bool TryCompileCharacterClass(ref SectionNameLexer lexer, StringBuilder sb)
+    {
+        // [...] should match any of the characters in the brackets, with special
+        // behavior for four characters: '!' immediately after the opening bracket
+        // implies the negation of the character class, '-' implies matching
+        // between the locale-dependent range of the previous and next characters,
+        // '\' escapes the following character, and ']' ends the range
+        if (!lexer.IsDone && lexer.CurrentCharacter == '!')
+        {
+            sb.Append('^');
+            lexer.Position++;
+        }
+        while (!lexer.IsDone)
+        {
+            var currentChar = lexer.EatCurrentCharacter();
+            switch (currentChar)
+            {
+                case '-':
+                    // '-' means the same thing in regex as it does in the glob, so
+                    // put it in verbatim
+                    sb.Append(currentChar);
+                    break;
+
+                case '\\':
+                    // Escape the next char
+                    if (lexer.IsDone)
+                    {
+                        return false;
+                    }
+                    sb.Append('\\');
+                    sb.Append(lexer.EatCurrentCharacter());
+                    break;
+
+                case ']':
+                    sb.Append(currentChar);
+                    return true;
+
+                default:
+                    sb.Append(Regex.Escape(currentChar.ToString()));
+                    break;
+            }
+        }
+        // Stream ended without a closing bracket
+        return false;
+    }
+
+    /// <summary>
+    /// Parses choice defined by the following grammar:
+    /// <![CDATA[
+    /// <choice> ::= "{" <choice-list> "}"
+    /// <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+    /// ]]>
+    /// </summary>
+    private static bool TryCompileChoice(
+        ref SectionNameLexer lexer,
+        StringBuilder sb,
+        List<(int, int)> numberRangePairs)
+    {
+        if (lexer.Lex() != TokenKind.OpenCurly)
+        {
+            return false;
+        }
+
+        // Start a non-capturing group for the choice
+        sb.Append("(?:");
+
+        // We start immediately after a '{'
+        // Try to compile the nested <path-list>
+        while (TryCompilePathList(ref lexer, sb, parsingChoice: true, numberRangePairs))
+        {
+            // If we've successfully compiled a <path-list> the last token should
+            // have been a ',' or a '}'
+            char lastChar = lexer[lexer.Position - 1];
+            if (lastChar == ',')
+            {
+                // Another option
+                sb.Append('|');
+            }
+            else if (lastChar == '}')
+            {
+                // Close out the capture group
+                sb.Append(')');
+                return true;
+            }
+            else
+            {
+                throw new BuildCheckConfigurationException($"UnexpectedValue: {lastChar}", BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+        }
+
+        // Propagate failure
+        return false;
+    }
+
+    /// <summary>
+    /// Parses range defined by the following grammar.
+    /// <![CDATA[
+    /// <range> ::= "{" <integer> ".." <integer> "}"
+    /// <integer> ::= "-" <digit-list> | <digit-list>
+    /// <digit-list> ::= <digit> | <digit> <digit-list>
+    /// <digit> ::= 0-9
+    /// ]]>
+    /// </summary>
+    private static (string numStart, string numEnd)? TryParseNumberRange(ref SectionNameLexer lexer)
+    {
+        var saved = lexer.Position;
+        if (lexer.Lex() != TokenKind.OpenCurly)
+        {
+            lexer.Position = saved;
+            return null;
+        }
+
+        var numStart = lexer.TryLexNumber();
+        if (numStart is null)
+        {
+            // Not a number
+            lexer.Position = saved;
+            return null;
+        }
+
+        // The next two characters must be ".."
+        if (!lexer.TryEatCurrentCharacter(out char c) || c != '.' ||
+            !lexer.TryEatCurrentCharacter(out c) || c != '.')
+        {
+            lexer.Position = saved;
+            return null;
+        }
+
+        // Now another number
+        var numEnd = lexer.TryLexNumber();
+        if (numEnd is null || lexer.IsDone || lexer.Lex() != TokenKind.CloseCurly)
+        {
+            // Not a number or no '}'
+            lexer.Position = saved;
+            return null;
+        }
+
+        return (numStart, numEnd);
+    }
+
+    private struct SectionNameLexer
+    {
+        private readonly string _sectionName;
+
+        internal int Position { get; set; }
+
+        internal SectionNameLexer(string sectionName)
+        {
+            _sectionName = sectionName;
+            Position = 0;
+        }
+
+        internal bool IsDone => Position >= _sectionName.Length;
+
+        internal TokenKind Lex()
+        {
+            int lexemeStart = Position;
+            switch (_sectionName[Position])
+            {
+                case '*':
+                    {
+                        int nextPos = Position + 1;
+                        if (nextPos < _sectionName.Length &&
+                            _sectionName[nextPos] == '*')
+                        {
+                            Position += 2;
+                            return TokenKind.StarStar;
+                        }
+                        else
+                        {
+                            Position++;
+                            return TokenKind.Star;
+                        }
+                    }
+
+                case '?':
+                    Position++;
+                    return TokenKind.Question;
+
+                case '{':
+                    Position++;
+                    return TokenKind.OpenCurly;
+
+                case ',':
+                    Position++;
+                    return TokenKind.Comma;
+
+                case '}':
+                    Position++;
+                    return TokenKind.CloseCurly;
+
+                case '[':
+                    Position++;
+                    return TokenKind.OpenBracket;
+
+                case '\\':
+                    {
+                        // Backslash escapes the next character
+                        Position++;
+                        if (IsDone)
+                        {
+                            return TokenKind.BadToken;
+                        }
+
+                        return TokenKind.SimpleCharacter;
+                    }
+
+                default:
+                    // Don't increment position, since caller needs to fetch the character
+                    return TokenKind.SimpleCharacter;
+            }
+        }
+
+        internal char CurrentCharacter => _sectionName[Position];
+
+        /// <summary>
+        /// Call after getting <see cref="TokenKind.SimpleCharacter" /> from <see cref="Lex()" />
+        /// </summary>
+        internal char EatCurrentCharacter() => _sectionName[Position++];
+
+        /// <summary>
+        /// Returns false if there are no more characters in the lex stream.
+        /// Otherwise, produces the next character in the stream and returns true.
+        /// </summary>
+        internal bool TryEatCurrentCharacter(out char nextChar)
+        {
+            if (IsDone)
+            {
+                nextChar = default;
+                return false;
+            }
+            else
+            {
+                nextChar = EatCurrentCharacter();
+                return true;
+            }
+        }
+
+        internal char this[int position] => _sectionName[position];
+
+        /// <summary>
+        /// Returns the string representation of a decimal integer, or null if
+        /// the current lexeme is not an integer.
+        /// </summary>
+        internal string? TryLexNumber()
+        {
+            bool start = true;
+            var sb = new StringBuilder();
+
+            while (!IsDone)
+            {
+                char currentChar = CurrentCharacter;
+                if (start && currentChar == '-')
+                {
+                    Position++;
+                    sb.Append('-');
+                }
+                else if (char.IsDigit(currentChar))
+                {
+                    Position++;
+                    sb.Append(currentChar);
+                }
+                else
+                {
+                    break;
+                }
+                start = false;
+            }
+
+            var str = sb.ToString();
+            return str.Length == 0 || str == "-"
+                ? null
+                : str;
+        }
+    }
+
+    private enum TokenKind
+    {
+        BadToken,
+        SimpleCharacter,
+        Star,
+        StarStar,
+        Question,
+        OpenCurly,
+        CloseCurly,
+        Comma,
+        DoubleDot,
+        OpenBracket,
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
new file mode 100644
index 00000000000..76baa1f1e66
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
@@ -0,0 +1,104 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Concurrent;
+using System.Collections.Generic;
+using System.Drawing.Design;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Shared;
+using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+
+internal sealed class EditorConfigParser
+{
+    private const string EditorconfigFile = ".editorconfig";
+
+    /// <summary>
+    /// Cache layer of the parsed editor configs the key is the path to the .editorconfig file.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, EditorConfigFile> _editorConfigFileCache = new ConcurrentDictionary<string, EditorConfigFile>(StringComparer.InvariantCultureIgnoreCase);
+
+    internal Dictionary<string, string> Parse(string filePath)
+    {
+        var editorConfigs = DiscoverEditorConfigFiles(filePath);
+        return MergeEditorConfigFiles(editorConfigs, filePath);
+    }
+
+    /// <summary>
+    /// Fetches the list of EditorconfigFile ordered from the nearest to the filePath.
+    /// </summary>
+    /// <param name="filePath"></param>
+    internal List<EditorConfigFile> DiscoverEditorConfigFiles(string filePath)
+    {
+        var editorConfigDataFromFilesList = new List<EditorConfigFile>();
+
+        var directoryOfTheProject = Path.GetDirectoryName(filePath);
+        // The method will look for the file in parent directory if not found in current until found or the directory is root. 
+        var editorConfigFilePath = FileUtilities.GetPathOfFileAbove(EditorconfigFile, directoryOfTheProject);
+
+        while (editorConfigFilePath != string.Empty)
+        {
+            var editorConfig = _editorConfigFileCache.GetOrAdd(editorConfigFilePath, (key) =>
+            {
+                using (FileStream stream = new FileStream(editorConfigFilePath, FileMode.Open, System.IO.FileAccess.Read, FileShare.Read))
+                {
+                    using StreamReader sr = new StreamReader(editorConfigFilePath);
+                    var editorConfigfileContent = sr.ReadToEnd();
+                    return EditorConfigFile.Parse(editorConfigfileContent);
+                }
+            });
+
+            editorConfigDataFromFilesList.Add(editorConfig);
+
+            if (editorConfig.IsRoot)
+            {
+                break;
+            }
+            else
+            {
+                // search in upper directory
+                editorConfigFilePath = FileUtilities.GetPathOfFileAbove(EditorconfigFile, Path.GetDirectoryName(Path.GetDirectoryName(editorConfigFilePath)));
+            }
+        }
+
+        return editorConfigDataFromFilesList;
+    }
+
+    /// <summary>
+    /// Retrieves the config dictionary from the sections that matched the filePath. 
+    /// </summary>
+    /// <param name="editorConfigFiles"></param>
+    /// <param name="filePath"></param>
+    internal Dictionary<string, string> MergeEditorConfigFiles(List<EditorConfigFile> editorConfigFiles, string filePath)
+    {
+        var resultingDictionary = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
+
+        for (int i = editorConfigFiles.Count - 1; i >= 0; i--)
+        {
+            foreach (var section in editorConfigFiles[i].NamedSections)
+            {
+                SectionNameMatcher? sectionNameMatcher = TryCreateSectionNameMatcher(section.Name);
+                if (sectionNameMatcher != null)
+                {
+                    if (sectionNameMatcher.Value.IsMatch(NormalizeWithForwardSlash(filePath)))
+                    {
+                        foreach (var property in section.Properties)
+                        {
+                            resultingDictionary[property.Key] = property.Value;
+                        }
+                    }
+                }
+            }
+        }
+        
+        return resultingDictionary;
+    }
+
+    internal static string NormalizeWithForwardSlash(string p) => Path.DirectorySeparatorChar == '/' ? p : p.Replace(Path.DirectorySeparatorChar, '/');
+}
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
new file mode 100644
index 00000000000..e19b61c2c40
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
@@ -0,0 +1,98 @@
+﻿# EditorConfigParser
+
+Logic of parsing and matching copied from Roslyn implementation.
+To track the request on sharing the code: https://github.com/dotnet/roslyn/issues/72324
+
+
+In current implementation the usage of the editorconfig is internal only and exposed via ConfigurationProvider functionality. 
+
+Configuration divided into two categories: 
+- Infra related configuration. IsEnabled, Severity, EvaluationAnalysisScope
+- Custom configuration, any other config specified by user for this particular rule
+
+### Example
+For the file/folder structure: 
+```
+├── folder1/
+│   └── .editorconfig
+│   └── folder2/
+        ├── folder3/
+        │   └── .editorconfig
+        │   └── test.proj
+        └── .editorconfig
+```
+
+we want to fetch configuration for the project: /full/path/folder1/folder2/folder3/test.proj 
+
+Infra related and custom configuration flows have one common logic: Fetching the configs from editorconfig
+
+```
+while(editorConfig is not root && parent directory exists){
+        collect, parse editorconfigs 
+}
+
+list<editorConfig>{
+    folder1/folder2/folder3/.editorconfig
+    folder1/folder2/.editorconfig
+    folder1/.editorconfig
+}
+```
+Reverse the order and collect all matching section key-value pairs into new dictionary
+Remove non-msbuild-analyzer related key-values (keys not starting with msbuild_analyzer.RULEID)
+
+The implementation differs depending on category: 
+ - Infra related config: Merges the configuration retrieved from configuration module with default values (respecting the specified configs in editorconfig) 
+ - Custom configuration: Remove all infra related keys from dictionary
+
+Four levels of cache introduced: 
+- When retrieving and parsing the editor config -> Parsed results are saved into dictionary: editorconfigPath = ParsedEditorConfig
+- When retrieving and merging the editor config data for project -> Parsed and merged results are saved into dictionary: projectFilePath = MargedData of ParsedEditorConfig
+- When retrieving Infra related config: ruleId-projectPath = BuildConfigInstance
+- CustomConfigurationData: In order to verify that the config data is the same between projects
+
+Usage examples (API)
+
+```
+var editorConfigParser = new EditorConfigParser();
+editorConfigParser.Parse("path/to/the/file")
+```
+
+The snippet above will return all applied key-value Dictionary<string, string> pairs collected from .editorconfig files
+
+Currently EditorConfigParser is used by [ConfigurationProvider](https://github.com/dotnet/msbuild/blob/e0dfb8d1ce5fc1de5153e65ea04c66a6dcac6279/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs#L129).
+
+#### Cache lifetime
+The lifetime of the cached configuration is defined by the usage of the instance of ConfigurationProvider. The instance of the ConfigurationProvider is created per BuildCheckManager.
+Lifecycle of BuildCheckManager could be found [here](https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#handling-the-distributed-model)
+
+
+#### Custom configuration data
+CustomConfigurationData is propogated to the BuildCheck Analyzer instance by passing the instance of [ConfigurationContext](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/ConfigurationContext.cs#L14)
+during the initialization of the [BuildAnalyzer](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/BuildAnalyzer.cs#L36).
+
+
+#### Example of consuming the CustomConfigurationData
+The `Initialize` method of BuildCheck Analyzer:
+```C#
+public override void Initialize(ConfigurationContext configurationContext)
+{
+    Console.WriteLine(configurationContext.CustomConfigurationData.Count);
+    for (int i = 0; i < configurationContext.CustomConfigurationData.Count; i++)
+    {
+        var customConfigPerRule = configurationContext.CustomConfigurationData[i]; 
+        Console.WriteLine(customConfigPerRule.RuleId); 
+
+        if (customConfigPerRule.ConfigurationData is not null) // null when the configuration was not provided from editorconfig
+        {
+            foreach (var kv in customConfigPerRule.ConfigurationData)
+            {
+                Console.WriteLine($"{kv.Key}------{kv.Value}");
+            }
+        }
+        else
+        {
+            Console.WriteLine($"The data is null for index: {i}");
+        }
+    }
+}
+```
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
index 331502e95e0..9f39f8dcb69 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -4,8 +4,8 @@
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.BuildCheck.Acquisition;
-using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Experimental.BuildCheck.Acquisition;
+using Microsoft.Build.Experimental.BuildCheck.Logging;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
@@ -40,11 +40,23 @@ void ProcessEvaluationFinishedEventArgs(
         AnalyzerLoggingContext buildAnalysisContext,
         ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs);
 
+    void ProcessTaskStartedEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        TaskStartedEventArgs taskStartedEventArgs);
+
+    void ProcessTaskFinishedEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        TaskFinishedEventArgs taskFinishedEventArgs);
+
+    void ProcessTaskParameterEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        TaskParameterEventArgs taskParameterEventArgs);
+
     void SetDataSource(BuildCheckDataSource buildCheckDataSource);
 
     void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext);
 
-    Dictionary<string, TimeSpan> CreateTracingStats();
+    Dictionary<string, TimeSpan> CreateAnalyzerTracingStats();
 
     void FinalizeProcessing(LoggingContext loggingContext);
 
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs
index 6b8bdea6080..43b08b39111 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs
@@ -9,7 +9,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure;
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal interface IBuildCheckManagerProvider : IBuildComponent
 {
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
index 45ed260d425..a0136eafac8 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -4,12 +4,12 @@
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.BuildCheck.Acquisition;
-using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Experimental.BuildCheck.Acquisition;
+using Microsoft.Build.Experimental.BuildCheck.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure;
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal class NullBuildCheckManager : IBuildCheckManager
 {
@@ -27,11 +27,24 @@ public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
     {
     }
 
-    public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext) 
+    public void ProcessTaskStartedEventArgs(AnalyzerLoggingContext buildAnalysisContext,
+        TaskStartedEventArgs taskStartedEventArgs)
+    {
+    }
+
+    public void ProcessTaskFinishedEventArgs(AnalyzerLoggingContext buildAnalysisContext,
+        TaskFinishedEventArgs taskFinishedEventArgs)
+    {
+    }
+
+    public void ProcessTaskParameterEventArgs(AnalyzerLoggingContext buildAnalysisContext,
+        TaskParameterEventArgs taskParameterEventArgs)
     {
     }
 
-    public Dictionary<string, TimeSpan> CreateTracingStats() => throw new NotImplementedException();
+    public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext) 
+    {
+    }
 
     public void FinalizeProcessing(LoggingContext loggingContext)
     {
@@ -60,4 +73,15 @@ public void YieldProject(BuildCheckDataSource buildCheckDataSource, BuildEventCo
     public void ResumeProject(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
     {
     }
+
+    public Dictionary<string, TimeSpan> CreateAnalyzerTracingStats() => new Dictionary<string, TimeSpan>();
+
+    public void StartTaskInvocation(BuildCheckDataSource buildCheckDataSource, TaskStartedEventArgs eventArgs)
+    { }
+
+    public void EndTaskInvocation(BuildCheckDataSource buildCheckDataSource, TaskFinishedEventArgs eventArgs)
+    { }
+
+    public void ProcessTaskParameter(BuildCheckDataSource buildCheckDataSource, TaskParameterEventArgs eventArg)
+    { }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManagerProvider.cs
index c6dcbd84f8d..6005d4a7ea8 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManagerProvider.cs
@@ -9,7 +9,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure;
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal class NullBuildCheckManagerProvider : IBuildCheckManagerProvider
 {
diff --git a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
index 2d6d850737b..9809ad27e49 100644
--- a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
+++ b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
@@ -6,14 +6,22 @@
 using System.Linq;
 using System.Text;
 using System.Threading.Tasks;
+using Microsoft.Build.Experimental.BuildCheck.Utilities;
+using Microsoft.Build.Experimental.BuildCheck;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure;
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal class TracingReporter
 {
     internal Dictionary<string, TimeSpan> TracingStats { get; } = new();
 
-    public void AddStats(string name, TimeSpan subtotal)
+    // Infrastructure time keepers
+    // TODO: add more timers throughout BuildCheck run
+    private TimeSpan analyzerAcquisitionTime;
+    private TimeSpan analyzerSetDataSourceTime;
+    private TimeSpan newProjectAnalyzersTime;
+
+    public void AddAnalyzerStats(string name, TimeSpan subtotal)
     {
         if (TracingStats.TryGetValue(name, out TimeSpan existing))
         {
@@ -24,4 +32,30 @@ public void AddStats(string name, TimeSpan subtotal)
             TracingStats[name] = subtotal;
         }
     }
+
+    public void AddAcquisitionStats(TimeSpan subtotal)
+    {
+        analyzerAcquisitionTime += subtotal;
+    }
+
+    public void AddSetDataSourceStats(TimeSpan subtotal)
+    {
+        analyzerSetDataSourceTime += subtotal;
+    }
+
+    public void AddNewProjectStats(TimeSpan subtotal)
+    {
+        newProjectAnalyzersTime += subtotal;
+    }
+
+    public void AddAnalyzerInfraStats()
+    {
+        var infraStats = new Dictionary<string, TimeSpan>() {
+                { $"{BuildCheckConstants.infraStatPrefix}analyzerAcquisitionTime", analyzerAcquisitionTime },
+                { $"{BuildCheckConstants.infraStatPrefix}analyzerSetDataSourceTime", analyzerSetDataSourceTime },
+                { $"{BuildCheckConstants.infraStatPrefix}newProjectAnalyzersTime", newProjectAnalyzersTime }
+            };
+
+        TracingStats.Merge(infraStats, (span1, span2) => span1 + span2);
+    }
 }
diff --git a/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs b/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs
index 1b3eb9cb4bb..b7e39eaa8b0 100644
--- a/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs
+++ b/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs
@@ -5,7 +5,7 @@
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 
-namespace Microsoft.Build.BuildCheck.Logging;
+namespace Microsoft.Build.Experimental.BuildCheck.Logging;
 
 internal class AnalyzerLoggingContext : LoggingContext
 {
diff --git a/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs b/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs
index 3b1e035aed9..06b7dd6e033 100644
--- a/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs
+++ b/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs
@@ -5,7 +5,7 @@
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 
-namespace Microsoft.Build.BuildCheck.Logging;
+namespace Microsoft.Build.Experimental.BuildCheck.Logging;
 
 internal class AnalyzerLoggingContextFactory(ILoggingService loggingService) : IBuildAnalysisLoggingContextFactory
 {
diff --git a/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs b/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs
index e5188703ff7..bbb562c5ec9 100644
--- a/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs
+++ b/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Microsoft.Build.BuildCheck.Logging;
+using Microsoft.Build.Experimental.BuildCheck.Logging;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
index d0738fe6b71..f0623e4a822 100644
--- a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -7,7 +7,7 @@
 using System.Text;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental;
 using Microsoft.Build.Framework;
 
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// Base for a data passed from infrastructure to build analyzers.
 /// </summary>
-/// <param name="projectFilePath">Currently build project.</param>
+/// <param name="projectFilePath">Currently built project.</param>
 public abstract class AnalysisData(string projectFilePath)
 {
     /// <summary>
diff --git a/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs b/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
index a6b34446258..86598ada553 100644
--- a/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
+++ b/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
@@ -4,9 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 
@@ -53,3 +50,53 @@ internal ParsedItemsAnalysisData(
 
     public ItemsHolder ItemsHolder { get; }
 }
+
+/// <summary>
+/// BuildCheck OM data representing a task executed by a project.
+/// </summary>
+public sealed class TaskInvocationAnalysisData : AnalysisData
+{
+    /// <summary>
+    /// Represents an input or output parameter of a task.
+    /// </summary>
+    /// <param name="Value">The value passed to (when <paramref name="IsOutput"/> is false) or from
+    /// (when <paramref name="IsOutput"/> is true) a task. This object can be of any type supported
+    /// in task parameters: <see cref="Framework.ITaskItem"/>, <see cref="Framework.ITaskItem"/>[],
+    /// bool, string, or anything else convertible to/from string.</param>
+    /// <param name="IsOutput">True for output parameters, false for input parameters.</param>
+    public record class TaskParameter(object? Value, bool IsOutput);
+
+    internal TaskInvocationAnalysisData(
+        string projectFilePath,
+        ElementLocation taskInvocationLocation,
+        string taskName,
+        string taskAssemblyLocation,
+        IReadOnlyDictionary<string, TaskParameter> parameters)
+        : base(projectFilePath)
+    {
+        TaskInvocationLocation = taskInvocationLocation;
+        TaskName = taskName;
+        TaskAssemblyLocation = taskAssemblyLocation;
+        Parameters = parameters;
+    }
+
+    /// <summary>
+    /// The project file and line/column number where the task is invoked.
+    /// </summary>
+    public ElementLocation TaskInvocationLocation { get; }
+
+    /// <summary>
+    /// Name of the task.
+    /// </summary>
+    public string TaskName { get; }
+
+    /// <summary>
+    /// The location of the assembly containing the implementation of the task.
+    /// </summary>
+    public string TaskAssemblyLocation { get; }
+
+    /// <summary>
+    /// The parameters of the task, keyed by parameter name.
+    /// </summary>
+    public IReadOnlyDictionary<string, TaskParameter> Parameters { get; }
+}
diff --git a/src/Build/BuildCheck/Utilities/Constants.cs b/src/Build/BuildCheck/Utilities/Constants.cs
new file mode 100644
index 00000000000..50a3d1bc63c
--- /dev/null
+++ b/src/Build/BuildCheck/Utilities/Constants.cs
@@ -0,0 +1,18 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Utilities;
+
+/// <summary>
+/// Constants to be shared within BuildCheck infrastructure
+/// </summary>
+internal static class BuildCheckConstants
+{
+    internal const string infraStatPrefix = "infrastructureStat_";
+}
diff --git a/src/Build/Collections/CopyOnWritePropertyDictionary.cs b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
index 76e975fe3c3..44e7fe20555 100644
--- a/src/Build/Collections/CopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
@@ -36,18 +36,18 @@ namespace Microsoft.Build.Collections
     /// </remarks>
     /// <typeparam name="T">Property or Metadata class type to store</typeparam>
     [DebuggerDisplay("#Entries={Count}")]
-    internal sealed class CopyOnWritePropertyDictionary<T> : IEnumerable<T>, IEquatable<CopyOnWritePropertyDictionary<T>>, IDictionary<string, T>
+    internal sealed class CopyOnWritePropertyDictionary<T> : ICopyOnWritePropertyDictionary<T>, IEquatable<CopyOnWritePropertyDictionary<T>>
         where T : class, IKeyed, IValued, IEquatable<T>, IImmutable
     {
         private static readonly ImmutableDictionary<string, T> NameComparerDictionaryPrototype = ImmutableDictionary.Create<string, T>(MSBuildNameIgnoreCaseComparer.Default);
 
         /// <summary>
-        /// Backing dictionary
+        /// Backing dictionary.
         /// </summary>
         private ImmutableDictionary<string, T> _backing;
 
         /// <summary>
-        /// Creates empty dictionary
+        /// Creates empty dictionary.
         /// </summary>
         public CopyOnWritePropertyDictionary()
         {
@@ -55,7 +55,7 @@ public CopyOnWritePropertyDictionary()
         }
 
         /// <summary>
-        /// Cloning constructor, with deferred cloning semantics
+        /// Cloning constructor, with deferred cloning semantics.
         /// </summary>
         private CopyOnWritePropertyDictionary(CopyOnWritePropertyDictionary<T> that)
         {
@@ -63,12 +63,12 @@ private CopyOnWritePropertyDictionary(CopyOnWritePropertyDictionary<T> that)
         }
 
         /// <summary>
-        /// Accessor for the list of property names
+        /// Accessor for the list of property names.
         /// </summary>
         ICollection<string> IDictionary<string, T>.Keys => ((IDictionary<string, T>)_backing).Keys;
 
         /// <summary>
-        /// Accessor for the list of properties
+        /// Accessor for the list of properties.
         /// </summary>
         ICollection<T> IDictionary<string, T>.Values => ((IDictionary<string, T>)_backing).Values;
 
@@ -115,6 +115,16 @@ public T this[string name]
         /// </summary>
         public bool Contains(string name) => _backing.ContainsKey(name);
 
+        public string GetEscapedValue(string name)
+        {
+            if (_backing.TryGetValue(name, out T value))
+            {
+                return value?.EscapedValue;
+            }
+
+            return null;
+        }
+
         /// <summary>
         /// Empties the collection
         /// </summary>
@@ -134,7 +144,7 @@ public void Clear()
         /// </summary>
         IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
 
-        #region IEquatable<PropertyDictionary<T>> Members
+        #region IEquatable<CopyOnWritePropertyDictionary<T>> Members
 
         /// <summary>
         /// Compares two property dictionaries for equivalence.  They are equal if each contains the same properties with the
@@ -180,6 +190,56 @@ public bool Equals(CopyOnWritePropertyDictionary<T> other)
 
         #endregion
 
+        #region IEquatable<CopyOnWritePropertyDictionary<T>> Members
+
+        /// <summary>
+        /// Compares two property dictionaries for equivalence.  They are equal if each contains the same properties with the
+        /// same values as the other, unequal otherwise.
+        /// </summary>
+        /// <param name="other">The dictionary to which this should be compared</param>
+        /// <returns>True if they are equivalent, false otherwise.</returns>
+        public bool Equals(ICopyOnWritePropertyDictionary<T> other)
+        {
+            if (other == null)
+            {
+                return false;
+            }
+
+            ImmutableDictionary<string, T> thisBacking = _backing;
+            IDictionary<string, T> otherDict = other;
+
+            if (other is CopyOnWritePropertyDictionary<T> otherCopyOnWritePropertyDictionary)
+            {
+                // If the backing collections are the same, we are equal.
+                // Note that with this check, we intentionally avoid the common reference
+                // comparison between 'this' and 'other'.
+                if (ReferenceEquals(thisBacking, otherCopyOnWritePropertyDictionary._backing))
+                {
+                    return true;
+                }
+
+                otherDict = otherCopyOnWritePropertyDictionary._backing;
+            }
+
+            if (thisBacking.Count != otherDict.Count)
+            {
+                return false;
+            }
+
+            foreach (T thisProp in thisBacking.Values)
+            {
+                if (!otherDict.TryGetValue(thisProp.Key, out T thatProp) ||
+                    !EqualityComparer<T>.Default.Equals(thisProp, thatProp))
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        #endregion
+
         #region IDictionary<string,T> Members
 
         /// <summary>
@@ -274,7 +334,7 @@ public bool Remove(string name)
         /// Overwrites any property with the same name already in the collection.
         /// To remove a property, use Remove(...) instead.
         /// </summary>
-        internal void Set(T projectProperty)
+        public void Set(T projectProperty)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectProperty, nameof(projectProperty));
 
@@ -285,7 +345,7 @@ internal void Set(T projectProperty)
         /// Adds the specified properties to this dictionary.
         /// </summary>
         /// <param name="other">An enumerator over the properties to add.</param>
-        internal void ImportProperties(IEnumerable<T> other)
+        public void ImportProperties(IEnumerable<T> other)
         {
             _backing = _backing.SetItems(Items());
 
@@ -302,7 +362,7 @@ IEnumerable<KeyValuePair<string, T>> Items()
         /// Clone. As we're copy on write, this
         /// should be cheap.
         /// </summary>
-        internal CopyOnWritePropertyDictionary<T> DeepClone()
+        public ICopyOnWritePropertyDictionary<T> DeepClone()
         {
             return new CopyOnWritePropertyDictionary<T>(this);
         }
diff --git a/src/Build/Collections/ICopyOnWritePropertyDictionary.cs b/src/Build/Collections/ICopyOnWritePropertyDictionary.cs
new file mode 100644
index 00000000000..310476fa83b
--- /dev/null
+++ b/src/Build/Collections/ICopyOnWritePropertyDictionary.cs
@@ -0,0 +1,65 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using Microsoft.Build.Shared;
+
+#nullable disable
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// An interface that represents a dictionary of unordered property or metadata name/value pairs with copy-on-write semantics.
+    /// </summary>
+    /// <remarks>
+    /// The value that this adds over IDictionary&lt;string, T&gt; is:
+    ///     - supports copy on write
+    ///     - enforces that key = T.Name
+    ///     - default enumerator is over values
+    ///     - (marginal) enforces the correct key comparer
+    ///
+    /// Really a Dictionary&lt;string, T&gt; where the key (the name) is obtained from IKeyed.Key.
+    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and
+    /// either not expose this collection or expose it through a readonly wrapper.
+    ///
+    /// This collection is safe for concurrent readers and a single writer.
+    /// </remarks>
+    /// <typeparam name="T">Property or Metadata class type to store</typeparam>
+    internal interface ICopyOnWritePropertyDictionary<T> : IEnumerable<T>, IEquatable<ICopyOnWritePropertyDictionary<T>>, IDictionary<string, T>
+        where T : class, IKeyed, IValued, IEquatable<T>, IImmutable
+    {
+        /// <summary>
+        /// Returns true if a property with the specified name is present in the collection, otherwise false.
+        /// </summary>
+        bool Contains(string name);
+
+        /// <summary>
+        /// Add the specified property to the collection.
+        /// Overwrites any property with the same name already in the collection.
+        /// To remove a property, use Remove(...) instead.
+        /// </summary>
+        void Set(T projectProperty);
+
+        /// <summary>
+        /// Adds the specified properties to this dictionary.
+        /// </summary>
+        /// <param name="other">An enumerator over the properties to add.</param>
+        void ImportProperties(IEnumerable<T> other);
+
+        /// <summary>
+        /// Clone. As we're copy on write, this should be cheap.
+        /// </summary>
+        ICopyOnWritePropertyDictionary<T> DeepClone();
+
+        /// <summary>
+        /// <typeparamref name="T"/> must implement <see cref="IKeyed"/>, which means it contains an
+        /// EscapedValue. This method allows retrieving the EscapedValue of an object in the dictionary
+        /// directly.
+        /// </summary>
+        string GetEscapedValue(string name);
+    }
+}
diff --git a/src/Build/Collections/IMultiDictionary.cs b/src/Build/Collections/IMultiDictionary.cs
new file mode 100644
index 00000000000..1fece50dc23
--- /dev/null
+++ b/src/Build/Collections/IMultiDictionary.cs
@@ -0,0 +1,24 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// Represents a dictionary that can hold more than one distinct value with the same key.
+    /// All keys must have at least one value: null values are currently rejected.
+    /// </summary>
+    /// <typeparam name="K">Type of key</typeparam>
+    /// <typeparam name="V">Type of value</typeparam>
+    internal interface IMultiDictionary<K, V>
+        where K : class
+        where V : class
+    {
+        IEnumerable<V> this[K key] { get; }
+    }
+}
diff --git a/src/Build/Collections/MultiDictionary.cs b/src/Build/Collections/MultiDictionary.cs
index b2fc7427261..ef8c02c8c8e 100644
--- a/src/Build/Collections/MultiDictionary.cs
+++ b/src/Build/Collections/MultiDictionary.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.Collections
     /// <typeparam name="K">Type of key</typeparam>
     /// <typeparam name="V">Type of value</typeparam>
     [DebuggerDisplay("#Keys={KeyCount} #Values={ValueCount}")]
-    internal class MultiDictionary<K, V>
+    internal class MultiDictionary<K, V> : IMultiDictionary<K, V>
         where K : class
         where V : class
     {
@@ -86,7 +86,7 @@ internal MultiDictionary(IEqualityComparer<K> keyComparer)
         /// <summary>
         /// Enumerator over values that have the specified key.
         /// </summary>
-        internal IEnumerable<V> this[K key]
+        public IEnumerable<V> this[K key]
         {
             get
             {
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index 96884a1914d..c105e12083b 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -42,14 +42,14 @@ internal sealed class PropertyDictionary<T> : IEnumerable<T>, IEquatable<Propert
         /// Backing dictionary
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
-        private readonly IRetrievableEntryHashSet<T> _properties;
+        private readonly IRetrievableValuedEntryHashSet<T> _properties;
 
         /// <summary>
         /// Creates empty dictionary
         /// </summary>
         public PropertyDictionary()
         {
-            _properties = new RetrievableEntryHashSet<T>(MSBuildNameIgnoreCaseComparer.Default);
+            _properties = new RetrievableValuedEntryHashSet<T>(MSBuildNameIgnoreCaseComparer.Default);
         }
 
         /// <summary>
@@ -57,7 +57,7 @@ public PropertyDictionary()
         /// </summary>
         internal PropertyDictionary(int capacity)
         {
-            _properties = new RetrievableEntryHashSet<T>(capacity, MSBuildNameIgnoreCaseComparer.Default);
+            _properties = new RetrievableValuedEntryHashSet<T>(capacity, MSBuildNameIgnoreCaseComparer.Default);
         }
 
         /// <summary>
@@ -77,7 +77,7 @@ internal PropertyDictionary(IEnumerable<T> elements)
         /// </summary>
         internal PropertyDictionary(MSBuildNameIgnoreCaseComparer comparer)
         {
-            _properties = new RetrievableEntryHashSet<T>(comparer);
+            _properties = new RetrievableValuedEntryHashSet<T>(comparer);
         }
 
         /// <summary>
@@ -96,7 +96,7 @@ internal PropertyDictionary(int capacity, IEnumerable<T> elements)
         /// Initializes a new instance of the <see cref="PropertyDictionary{T}"/> class.
         /// </summary>
         /// <param name="propertiesHashSet">The collection of properties to use.</param>
-        internal PropertyDictionary(IRetrievableEntryHashSet<T> propertiesHashSet)
+        internal PropertyDictionary(IRetrievableValuedEntryHashSet<T> propertiesHashSet)
         {
             _properties = propertiesHashSet;
         }
@@ -135,16 +135,7 @@ ICollection<T> IDictionary<string, T>.Values
         /// Returns the number of properties in the collection
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-        int ICollection<KeyValuePair<string, T>>.Count
-        {
-            get
-            {
-                lock (_properties)
-                {
-                    return ((ICollection<T>)_properties).Count;
-                }
-            }
-        }
+        int ICollection<KeyValuePair<string, T>>.Count => Count;
 
         /// <summary>
         /// Whether the collection is read-only.
@@ -155,7 +146,7 @@ int ICollection<KeyValuePair<string, T>>.Count
         /// <summary>
         /// Returns the number of property in the collection.
         /// </summary>
-        internal int Count
+        public int Count
         {
             get
             {
@@ -333,6 +324,24 @@ public T Get(string keyString, int startIndex, int endIndex)
             return GetProperty(keyString, startIndex, endIndex);
         }
 
+        /// <summary>
+        /// Gets the unescaped value of a particular property.
+        /// </summary>
+        /// <param name="propertyName">The name of the property whose value is sought.</param>
+        /// <param name="unescapedValue">The out parameter by which a successfully retrieved value is returned.</param>
+        /// <returns>True if a property with a matching name was found. False otherwise.</returns>
+        public bool TryGetPropertyUnescapedValue(string propertyName, out string unescapedValue)
+        {
+            if (_properties.TryGetEscapedValue(propertyName, out string escapedValue) && escapedValue != null)
+            {
+                unescapedValue = EscapingUtilities.UnescapeAll(escapedValue);
+                return true;
+            }
+
+            unescapedValue = null;
+            return false;
+        }
+
         #region IDictionary<string,T> Members
 
         /// <summary>
diff --git a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
index 3100e7914a8..4d271575848 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
@@ -8,6 +8,12 @@
 
 namespace Microsoft.Build.Collections
 {
+    /// <summary>
+    /// Represents a hash set mapping string to <typeparamref name="T"/>, with the specialization that
+    /// value lookup supports using substrings of a provided key without requiring instantiating the substring
+    /// (in order to avoid the memory usage of string allocation).
+    /// </summary>
+    /// <typeparam name="T">The type of data the hash set contains (which must be <see cref="IKeyed"/>).</typeparam>
     internal interface IRetrievableEntryHashSet<T> :
         ICollection<T>,
         ISerializable,
diff --git a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs
new file mode 100644
index 00000000000..e3b10556772
--- /dev/null
+++ b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs
@@ -0,0 +1,34 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using System.Runtime.Serialization;
+
+#nullable disable
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// Like <see cref="IRetrievableEntryHashSet{T}"/>, this represents a hash set mapping string to <typeparamref name="T"/>
+    /// with the specialization that value lookup supports using substrings of a provided key without requiring instantiating
+    /// the substring (in order to avoid the memory usage of string allocation).
+    ///
+    /// This interface extends the functionality of <see cref="IRetrievableEntryHashSet{T}"/> by introducing the ability
+    /// to directly retrieve the Value of an instance of T instead of retrieving the instance of T itself. Implementations of
+    /// this interface can avoid the cost of allocating an instance of <typeparamref name="T"/> when the caller requests only
+    /// the Value.
+    /// </summary>
+    /// <typeparam name="T">The type of data the hash set contains (which must be
+    /// <see cref="IKeyed"/> and also <see cref="IValued"/>).</typeparam>
+    internal interface IRetrievableValuedEntryHashSet<T> : IRetrievableEntryHashSet<T>
+        where T : class, IKeyed, IValued
+    {
+        /// <summary>
+        /// Gets the <see cref="IValued.EscapedValue"/> of the item whose <see cref="IKeyed.Key"/> matches <paramref name="key"/>.
+        /// </summary>
+        /// <param name="key">The key of the item whose value is sought.</param>
+        /// <param name="escapedValue">The out parameter by which a successfully retrieved <see cref="IValued.EscapedValue"/> is returned.</param>
+        /// <returns>True if an item whose <see cref="IKeyed.Key"/> matches <paramref name="key"/> was found. False otherwise.</returns>
+        bool TryGetEscapedValue(string key, out string escapedValue);
+    }
+}
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
similarity index 99%
rename from src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
rename to src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
index e6160cec90f..dc8d96f9f7c 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
@@ -320,7 +320,7 @@ public bool TryGetValue(string key, out T item)
         /// Gets the item if any with the given name
         /// </summary>
         /// <param name="key">key to check for containment</param>
-        /// <returns>true if item contained; false if not</returns>
+        /// <returns>The item, if it was found. Otherwise, default(T).</returns>
         public T Get(string key)
         {
             return GetCore(key, 0, key?.Length ?? 0);
diff --git a/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs
new file mode 100644
index 00000000000..c45da4e12b6
--- /dev/null
+++ b/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs
@@ -0,0 +1,53 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+#nullable disable
+
+namespace Microsoft.Build.Collections
+{
+    /// <inheritdoc />
+    [DebuggerTypeProxy(typeof(HashSetDebugView<>))]
+    [DebuggerDisplay("Count = {Count}")]
+#if FEATURE_SECURITY_PERMISSIONS
+    [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
+#endif
+    internal class RetrievableValuedEntryHashSet<T> : RetrievableEntryHashSet<T>, IRetrievableValuedEntryHashSet<T>
+        where T : class, IKeyed, IValued
+    {
+        /// <summary>
+        /// Initializes a new instance of the RetrievableValuedEntryHashSet class.
+        /// </summary>
+        /// <param name="comparer">A comparer with which the items' <see cref="IKeyed.Key"/> key values are compared.</param>
+        public RetrievableValuedEntryHashSet(IEqualityComparer<string> comparer)
+            : base(comparer)
+        {
+        }
+
+        /// <summary>
+        /// Initializes a new instance of the RetrievableValuedEntryHashSet class.
+        /// </summary>
+        /// <param name="suggestedCapacity">A value suggesting a good approximate minimum size for the initial collection.</param>
+        /// <param name="comparer">A comparer with which the items' <see cref="IKeyed.Key"/> key values are compared.</param>
+        public RetrievableValuedEntryHashSet(int suggestedCapacity, IEqualityComparer<string> comparer)
+            : base(suggestedCapacity, comparer)
+        {
+        }
+
+        /// <inheritdoc />
+        public bool TryGetEscapedValue(string key, out string escapedValue)
+        {
+            if (TryGetValue(key, out T item) && item != null)
+            {
+                escapedValue = item.EscapedValue;
+                return true;
+            }
+
+            escapedValue = null;
+            return false;
+        }
+    }
+}
diff --git a/src/Build/Construction/ProjectPropertyElement.cs b/src/Build/Construction/ProjectPropertyElement.cs
index c9020db30ba..8929dea6406 100644
--- a/src/Build/Construction/ProjectPropertyElement.cs
+++ b/src/Build/Construction/ProjectPropertyElement.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Diagnostics;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Internal;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
@@ -20,7 +21,7 @@ namespace Microsoft.Build.Construction
     /// So the CM only represents Normal properties.
     /// </remarks>
     [DebuggerDisplay("{Name} Value={Value} Condition={Condition}")]
-    public class ProjectPropertyElement : ProjectElement
+    public class ProjectPropertyElement : ProjectElement, IPropertyElementWithLocation
     {
         internal ProjectPropertyElementLink PropertyLink => (ProjectPropertyElementLink)Link;
 
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 791c88c741c..741babe959c 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -4263,7 +4263,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Prepares the data object for evaluation.
             /// </summary>
-            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
+            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext)
             {
                 DefaultTargets = null;
                 Properties = new PropertyDictionary<ProjectProperty>();
@@ -4271,7 +4271,7 @@ public void InitializeForEvaluation(IToolsetProvider toolsetProvider, Evaluation
                 Items = new ItemDictionary<ProjectItem>();
                 ItemsIgnoringCondition = new ItemDictionary<ProjectItem>();
                 ItemsByEvaluatedIncludeCache = new MultiDictionary<string, ProjectItem>(StringComparer.OrdinalIgnoreCase);
-                Expander = new Expander<ProjectProperty, ProjectItem>(Properties, Items, evaluationContext);
+                Expander = new Expander<ProjectProperty, ProjectItem>(Properties, Items, evaluationContext, loggingContext);
                 ItemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinition>(MSBuildNameIgnoreCaseComparer.Default);
                 Targets = new RetrievableEntryHashSet<ProjectTargetInstance>(StringComparer.OrdinalIgnoreCase);
                 ImportClosure = new List<ResolvedImport>();
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 11dd0a1143d..cf70b8f41fa 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -887,6 +887,21 @@ internal PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesCollection
         /// Returns the property dictionary containing the properties representing the environment.
         /// </summary>
         internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
+        {
+            get
+            {
+                // Retrieves the environment properties.
+                // This is only done once, when the project collection is created. Any subsequent
+                // environment changes will be ignored. Child nodes will be passed this set
+                // of properties in their build parameters.
+                return new PropertyDictionary<ProjectPropertyInstance>(SharedReadOnlyEnvironmentProperties);
+            }
+        }
+
+        /// <summary>
+        /// Returns a shared immutable property dictionary containing the properties representing the environment.
+        /// </summary>
+        internal PropertyDictionary<ProjectPropertyInstance> SharedReadOnlyEnvironmentProperties
         {
             get
             {
@@ -898,7 +913,7 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
                 {
                     if (_environmentProperties != null)
                     {
-                        return new PropertyDictionary<ProjectPropertyInstance>(_environmentProperties);
+                        return _environmentProperties;
                     }
                 }
 
@@ -906,9 +921,9 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
                 {
                     if (_environmentProperties == null)
                     {
-                        _environmentProperties = Utilities.GetEnvironmentProperties();
+                        _environmentProperties = Utilities.GetEnvironmentProperties(makeReadOnly: true);
                     }
-                    return new PropertyDictionary<ProjectPropertyInstance>(_environmentProperties);
+                    return _environmentProperties;
                 }
             }
         }
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index bf9ae352007..eee61cb02f5 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -9,6 +9,7 @@
 using System.Linq;
 using System.Xml;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
@@ -685,7 +686,7 @@ internal static Toolset FactoryForDeserialization(ITranslator translator)
         /// <summary>
         /// Given a search path and a task pattern get a list of task or override task files.
         /// </summary>
-        internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingService loggingServices, BuildEventContext buildEventContext, string taskPattern, string searchPath, string taskFileWarning)
+        internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, LoggingContext loggingContext, string taskPattern, string searchPath, string taskFileWarning)
         {
             string[] defaultTasksFiles = null;
 
@@ -703,8 +704,7 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingServic
 
                 if (defaultTasksFiles.Length == 0)
                 {
-                    loggingServices.LogWarning(
-                        buildEventContext,
+                    loggingContext.LogWarning(
                         null,
                         new BuildEventFileInfo(/* this warning truly does not involve any file */ String.Empty),
                         taskFileWarning,
@@ -715,8 +715,7 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingServic
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                loggingServices.LogWarning(
-                    buildEventContext,
+                loggingContext.LogWarning(
                     null,
                     new BuildEventFileInfo(/* this warning truly does not involve any file */ String.Empty),
                     taskFileWarning,
@@ -819,13 +818,12 @@ internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution)
         /// <summary>
         /// Return a task registry stub for the tasks in the *.tasks file for this toolset
         /// </summary>
-        /// <param name="loggingServices">The logging services used to log during task registration.</param>
-        /// <param name="buildEventContext">The build event context used to log during task registration.</param>
+        /// <param name="loggingContext">The logging context used to log during task registration.</param>
         /// <param name="projectRootElementCache">The <see cref="ProjectRootElementCache"/> to use.</param>
         /// <returns>The task registry</returns>
-        internal TaskRegistry GetTaskRegistry(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        internal TaskRegistry GetTaskRegistry(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
-            RegisterDefaultTasks(loggingServices, buildEventContext, projectRootElementCache);
+            RegisterDefaultTasks(loggingContext, projectRootElementCache);
             return _defaultTaskRegistry;
         }
 
@@ -846,13 +844,12 @@ internal string GenerateSubToolsetVersionUsingVisualStudioVersion(IDictionary<st
         /// <summary>
         /// Return a task registry for the override tasks in the *.overridetasks file for this toolset
         /// </summary>
-        /// <param name="loggingServices">The logging services used to log during task registration.</param>
-        /// <param name="buildEventContext">The build event context used to log during task registration.</param>
+        /// <param name="loggingContext">The logging context used to log during task registration.</param>
         /// <param name="projectRootElementCache">The <see cref="ProjectRootElementCache"/> to use.</param>
         /// <returns>The task registry</returns>
-        internal TaskRegistry GetOverrideTaskRegistry(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        internal TaskRegistry GetOverrideTaskRegistry(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
-            RegisterOverrideTasks(loggingServices, buildEventContext, projectRootElementCache);
+            RegisterOverrideTasks(loggingContext, projectRootElementCache);
             return _overrideTaskRegistry;
         }
 
@@ -867,10 +864,9 @@ internal TaskRegistry GetOverrideTaskRegistry(ILoggingService loggingServices, B
         /// 3) comment tags are always ignored regardless of their placement
         /// 4) the rest of the tags are expected to be &lt;UsingTask&gt; tags
         /// </remarks>
-        /// <param name="loggingServices">The logging services to use to log during this registration.</param>
-        /// <param name="buildEventContext">The build event context to use to log during this registration.</param>
+        /// <param name="loggingContext">The logging context to use to log during this registration.</param>
         /// <param name="projectRootElementCache">The <see cref="ProjectRootElementCache"/> to use.</param>
-        private void RegisterDefaultTasks(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        private void RegisterDefaultTasks(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
             if (!_defaultTasksRegistrationAttempted)
             {
@@ -878,10 +874,10 @@ private void RegisterDefaultTasks(ILoggingService loggingServices, BuildEventCon
                 {
                     _defaultTaskRegistry = new TaskRegistry(projectRootElementCache);
 
-                    InitializeProperties(loggingServices, buildEventContext);
+                    InitializeProperties(loggingContext);
 
-                    string[] defaultTasksFiles = GetTaskFiles(_getFiles, loggingServices, buildEventContext, DefaultTasksFilePattern, ToolsPath, "DefaultTasksFileLoadFailureWarning");
-                    LoadAndRegisterFromTasksFile(defaultTasksFiles, loggingServices, buildEventContext, "DefaultTasksFileFailure", projectRootElementCache, _defaultTaskRegistry);
+                    string[] defaultTasksFiles = GetTaskFiles(_getFiles, loggingContext, DefaultTasksFilePattern, ToolsPath, "DefaultTasksFileLoadFailureWarning");
+                    LoadAndRegisterFromTasksFile(defaultTasksFiles, loggingContext, "DefaultTasksFileFailure", projectRootElementCache, _defaultTaskRegistry);
                 }
                 finally
                 {
@@ -893,7 +889,7 @@ private void RegisterDefaultTasks(ILoggingService loggingServices, BuildEventCon
         /// <summary>
         /// Initialize the properties which are used to evaluate the tasks files.
         /// </summary>
-        private void InitializeProperties(ILoggingService loggingServices, BuildEventContext buildEventContext)
+        private void InitializeProperties(LoggingContext loggingContext)
         {
             if (_expander != null)
             {
@@ -965,18 +961,18 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
 
                 propertyBag.ImportProperties(_globalProperties);
 
-                _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, FileSystems.Default);
+                _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, FileSystems.Default, loggingContext);
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                loggingServices.LogError(buildEventContext, new BuildEventFileInfo(/* this warning truly does not involve any file it is just gathering properties */String.Empty), "TasksPropertyBagError", e.Message);
+                loggingContext.LogError(new BuildEventFileInfo(/* this warning truly does not involve any file it is just gathering properties */String.Empty), "TasksPropertyBagError", e.Message);
             }
         }
 
         /// <summary>
         /// Used to load information about MSBuild override tasks i.e. tasks that override tasks declared in tasks or project files.
         /// </summary>
-        private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        private void RegisterOverrideTasks(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
             if (!_overrideTasksRegistrationAttempted)
             {
@@ -1005,23 +1001,23 @@ private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventCo
                             if (!overrideDirectoryExists)
                             {
                                 string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", _overrideTasksPath);
-                                loggingServices.LogWarning(buildEventContext, null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
+                                loggingContext.LogWarning(null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
                             }
                         }
                     }
                     catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                     {
                         string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskProblemWithPath", _overrideTasksPath, e.Message);
-                        loggingServices.LogWarning(buildEventContext, null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
+                        loggingContext.LogWarning(null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
                     }
 
                     if (overrideDirectoryExists)
                     {
-                        InitializeProperties(loggingServices, buildEventContext);
-                        string[] overrideTasksFiles = GetTaskFiles(_getFiles, loggingServices, buildEventContext, OverrideTasksFilePattern, _overrideTasksPath, "OverrideTasksFileLoadFailureWarning");
+                        InitializeProperties(loggingContext);
+                        string[] overrideTasksFiles = GetTaskFiles(_getFiles, loggingContext, OverrideTasksFilePattern, _overrideTasksPath, "OverrideTasksFileLoadFailureWarning");
 
                         // Load and register any override tasks
-                        LoadAndRegisterFromTasksFile(overrideTasksFiles, loggingServices, buildEventContext, "OverrideTasksFileFailure", projectRootElementCache, _overrideTaskRegistry);
+                        LoadAndRegisterFromTasksFile(overrideTasksFiles, loggingContext, "OverrideTasksFileFailure", projectRootElementCache, _overrideTaskRegistry);
                     }
                 }
                 finally
@@ -1034,14 +1030,13 @@ private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventCo
         /// <summary>
         /// Do the actual loading of the tasks or override tasks file and register the tasks in the task registry
         /// </summary>
-        private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingService loggingServices, BuildEventContext buildEventContext, string taskFileError, ProjectRootElementCacheBase projectRootElementCache, TaskRegistry registry)
+        private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, LoggingContext loggingContext, string taskFileError, ProjectRootElementCacheBase projectRootElementCache, TaskRegistry registry)
         {
             string currentTasksFile = null;
             try
             {
                 TaskRegistry.InitializeTaskRegistryFromUsingTaskElements<ProjectPropertyInstance, ProjectItemInstance>(
-                    loggingServices,
-                    buildEventContext,
+                    loggingContext,
                     EnumerateTasksRegistrations(),
                     registry,
                     _expander,
@@ -1056,7 +1051,7 @@ private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingSer
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                loggingServices.LogError(buildEventContext, new BuildEventFileInfo(currentTasksFile),
+                loggingContext.LogError(new BuildEventFileInfo(currentTasksFile),
                     taskFileError, e.Message);
             }
 
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 1d231597726..f7918c19052 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -186,11 +186,9 @@ internal static bool EvaluateCondition<P, I>(
             ExpanderOptions expanderOptions,
             string evaluationDirectory,
             ElementLocation elementLocation,
-            ILoggingService loggingServices,
-            BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase? projectRootElementCache = null,
-            LoggingContext? loggingContext = null)
+            LoggingContext? loggingContext,
+            ProjectRootElementCacheBase? projectRootElementCache = null)
             where P : class, IProperty
             where I : class, IItem
         {
@@ -202,11 +200,9 @@ internal static bool EvaluateCondition<P, I>(
                 conditionedPropertiesTable: null /* do not collect conditioned properties */,
                 evaluationDirectory,
                 elementLocation,
-                loggingServices,
-                buildEventContext,
                 fileSystem,
-                projectRootElementCache,
-                loggingContext);
+                loggingContext,
+                projectRootElementCache);
         }
 
         /// <summary>
@@ -224,18 +220,15 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
             Dictionary<string, List<string>>? conditionedPropertiesTable,
             string evaluationDirectory,
             ElementLocation elementLocation,
-            ILoggingService loggingServices,
-            BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase? projectRootElementCache = null,
-            LoggingContext? loggingContext = null)
+            LoggingContext? loggingContext,
+            ProjectRootElementCacheBase? projectRootElementCache = null)
             where P : class, IProperty
             where I : class, IItem
         {
             ErrorUtilities.VerifyThrowArgumentNull(condition, nameof(condition));
             ErrorUtilities.VerifyThrowArgumentNull(expander, nameof(expander));
             ErrorUtilities.VerifyThrowArgumentLength(evaluationDirectory, nameof(evaluationDirectory));
-            ErrorUtilities.VerifyThrowArgumentNull(buildEventContext, nameof(buildEventContext));
 
             // An empty condition is equivalent to a "true" condition.
             if (condition.Length == 0)
@@ -263,8 +256,8 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
                 var conditionParser = new Parser();
 
                 #region REMOVE_COMPAT_WARNING
-                conditionParser.LoggingServices = loggingServices;
-                conditionParser.LogBuildEventContext = buildEventContext;
+                conditionParser.LoggingServices = loggingContext?.LoggingService;
+                conditionParser.LogBuildEventContext = loggingContext?.BuildEventContext ?? BuildEventContext.Invalid;
                 #endregion
 
                 parsedExpression = conditionParser.Parse(condition, options, elementLocation);
@@ -282,13 +275,14 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
                 fileSystem,
                 projectRootElementCache);
 
+            expander.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluation;
             // We are evaluating this expression now and it can cache some state for the duration,
             // so we don't want multiple threads working on the same expression
             lock (parsedExpression)
             {
                 try
                 {
-                    result = parsedExpression.Evaluate(state, loggingContext);
+                    result = parsedExpression.Evaluate(state);
                 }
                 finally
                 {
@@ -298,6 +292,7 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
                         // Finished using the expression tree. Add it back to the pool so other threads can use it.
                         expressionPool.Push(parsedExpression);
                     }
+                    expander.PropertiesUseTracker.ResetPropertyReadContext();
                 }
             }
 
@@ -350,6 +345,8 @@ internal interface IConditionEvaluationState
 
             ElementLocation ElementLocation { get; }
 
+            PropertiesUseTracker PropertiesUseTracker { get; }
+
             /// <summary>
             ///     Table of conditioned properties and their values.
             ///     Used to populate configuration lists in some project systems.
@@ -362,7 +359,7 @@ internal interface IConditionEvaluationState
             ///     May return null if the expression would expand to non-empty and it broke out early.
             ///     Otherwise, returns the correctly expanded expression.
             /// </summary>
-            string ExpandIntoStringBreakEarly(string expression, LoggingContext? loggingContext = null);
+            string ExpandIntoStringBreakEarly(string expression);
 
             /// <summary>
             ///     Expands the specified expression into a list of TaskItem's.
@@ -372,7 +369,7 @@ internal interface IConditionEvaluationState
             /// <summary>
             ///     Expands the specified expression into a string.
             /// </summary>
-            string ExpandIntoString(string expression, LoggingContext? loggingContext = null);
+            string ExpandIntoString(string expression);
 
             /// <summary>
             ///     PRE cache
@@ -403,6 +400,8 @@ internal class ConditionEvaluationState<P, I> : IConditionEvaluationState
 
             public ElementLocation ElementLocation { get; }
 
+            public PropertiesUseTracker PropertiesUseTracker => _expander.PropertiesUseTracker;
+
             public IFileSystem FileSystem { get; }
 
             /// <summary>
@@ -447,13 +446,9 @@ internal ConditionEvaluationState(
             /// May return null if the expression would expand to non-empty and it broke out early.
             /// Otherwise, returns the correctly expanded expression.
             /// </summary>
-            public string ExpandIntoStringBreakEarly(string expression, LoggingContext? loggingContext = null)
+            public string ExpandIntoStringBreakEarly(string expression)
             {
-                var originalValue = _expander.WarnForUninitializedProperties;
-
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation, loggingContext);
-
-                _expander.WarnForUninitializedProperties = originalValue;
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation);
 
                 return expression;
             }
@@ -465,12 +460,8 @@ public string ExpandIntoStringBreakEarly(string expression, LoggingContext? logg
             /// <returns>A list of items.</returns>
             public IList<TaskItem> ExpandIntoTaskItems(string expression)
             {
-                var originalValue = _expander.WarnForUninitializedProperties;
-
                 var items = _expander.ExpandIntoTaskItemsLeaveEscaped(expression, _expanderOptions, ElementLocation);
 
-                _expander.WarnForUninitializedProperties = originalValue;
-
                 return items;
             }
 
@@ -478,15 +469,10 @@ public IList<TaskItem> ExpandIntoTaskItems(string expression)
             /// Expands the specified expression into a string.
             /// </summary>
             /// <param name="expression">The expression to expand.</param>
-            /// <param name="loggingContext"></param>
             /// <returns>The expanded string.</returns>
-            public string ExpandIntoString(string expression, LoggingContext? loggingContext = null)
+            public string ExpandIntoString(string expression)
             {
-                var originalValue = _expander.WarnForUninitializedProperties;
-
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation, loggingContext);
-
-                _expander.WarnForUninitializedProperties = originalValue;
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation);
 
                 return expression;
             }
diff --git a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
index ce021dc2f10..1303731a2f6 100644
--- a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
@@ -19,9 +19,9 @@ internal sealed class AndExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                      state.ElementLocation,
@@ -38,7 +38,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                          state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index e16e7537379..6d7b27eb243 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -30,7 +30,7 @@ internal FunctionCallExpressionNode(string functionName, List<GenericExpressionN
         /// <summary>
         /// Evaluate node as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (String.Equals(_functionName, "exists", StringComparison.OrdinalIgnoreCase))
             {
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index 3d0d6d99456..e8a7858d415 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -14,9 +14,9 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class GenericExpressionNode
     {
-        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null);
-        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null);
-        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null);
+        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result);
+        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result);
+        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result);
 
         /// <summary>
         /// Returns true if this node evaluates to an empty string,
@@ -25,7 +25,7 @@ internal abstract class GenericExpressionNode
         /// to empty than to fully evaluate it.)
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
         {
             return false;
         }
@@ -34,7 +34,7 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
+        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state);
 
         /// <summary>
         /// Value before any item and property expressions are expanded
@@ -42,6 +42,12 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// <returns></returns>
         internal abstract string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluationState state);
 
+        /// <summary>
+        /// Checks if value is empty before any item and property expressions are expanded
+        /// </summary>
+        /// <returns></returns>
+        internal abstract bool IsUnexpandedValueEmpty();
+
         /// <summary>
         /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
@@ -52,17 +58,16 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// The main evaluate entry point for expression trees
         /// </summary>
         /// <param name="state"></param>
-        /// <param name="loggingContext"></param>
         /// <returns></returns>
-        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!TryBoolEvaluate(state, out bool boolValue, loggingContext))
+            if (!TryBoolEvaluate(state, out bool boolValue))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ConditionNotBooleanDetail",
                     state.Condition,
-                    GetExpandedValue(state, loggingContext));
+                    GetExpandedValue(state));
             }
 
             return boolValue;
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index 208794b3603..f398e8d740a 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -37,7 +37,7 @@ internal abstract class MultipleComparisonNode : OperatorExpressionNode
         /// Order in which comparisons are attempted is numeric, boolean, then string.
         /// Updates conditioned properties table.
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
             ProjectErrorUtilities.VerifyThrowInvalidProject(
                 LeftChild != null && RightChild != null,
@@ -51,8 +51,18 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             // and we know which do, then we already have enough information to evaluate this expression.
             // That means we don't have to fully expand a condition like " '@(X)' == '' "
             // which is a performance advantage if @(X) is a huge item list.
-            bool leftEmpty = LeftChild.EvaluatesToEmpty(state, loggingContext);
-            bool rightEmpty = RightChild.EvaluatesToEmpty(state, loggingContext);
+
+            // This is the possible case of an expression similar to '$(a)' == '', where a usage of uninitialized
+            //  property is reasonable and should not be flagged by uninitialized reads detection.
+            // So if at least one side is empty, we know to signal to PropertiesUseTracker to not flag in this scope.
+            // The other side might not be property at all - that's fine, as then PropertiesUseTracker won't be even called.
+            if (LeftChild.IsUnexpandedValueEmpty() || RightChild.IsUnexpandedValueEmpty())
+            {
+                state.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluationWithOneSideEmpty;
+            }
+
+            bool leftEmpty = LeftChild.EvaluatesToEmpty(state);
+            bool rightEmpty = RightChild.EvaluatesToEmpty(state);
             if (leftEmpty || rightEmpty)
             {
                 UpdateConditionedProperties(state);
@@ -69,13 +79,13 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                 // is 17.0).
                 return Compare(leftNumericValue, rightNumericValue);
             }
-            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue, loggingContext) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue, loggingContext))
+            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue))
             {
                 return Compare(leftBoolValue, rightBoolValue);
             }
 
-            string leftExpandedValue = LeftChild.GetExpandedValue(state, loggingContext);
-            string rightExpandedValue = RightChild.GetExpandedValue(state, loggingContext);
+            string leftExpandedValue = LeftChild.GetExpandedValue(state);
+            string rightExpandedValue = RightChild.GetExpandedValue(state);
 
             ProjectErrorUtilities.VerifyThrowInvalidProject(
                 leftExpandedValue != null && rightExpandedValue != null,
@@ -85,6 +95,9 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
 
             UpdateConditionedProperties(state);
 
+            // reset back the property read context (it's no longer a condition with one side empty)
+            state.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluation;
+
             return Compare(leftExpandedValue, rightExpandedValue);
         }
 
diff --git a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
index 71dec16ec3d..66bfc64c1c2 100644
--- a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
@@ -19,9 +19,9 @@ internal sealed class NotExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue, loggingContext))
+            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
@@ -42,12 +42,15 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
             return "!" + LeftChild.GetUnexpandedValue(state);
         }
 
+        /// <inheritdoc cref="GenericExpressionNode"/>
+        internal override bool IsUnexpandedValueEmpty() => false;
+
         /// <summary>
         /// Returns expanded value with '!' prepended. Useful for error messages.
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
-            return "!" + LeftChild.GetExpandedValue(state, loggingContext);
+            return "!" + LeftChild.GetExpandedValue(state);
         }
 
         internal override string DebuggerDisplay => $"(not {LeftChild.DebuggerDisplay})";
diff --git a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
index a371e9a0850..fb6cc3b3a71 100644
--- a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
@@ -38,7 +38,7 @@ internal abstract class NumericComparisonExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
             bool isLeftNum = LeftChild.TryNumericEvaluate(state, out double leftNum);
             bool isLeftVersion = LeftChild.TryVersionEvaluate(state, out Version leftVersion);
@@ -53,7 +53,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                     state.Condition,
                     /* helpfully display unexpanded token and expanded result in error message */
                     isLeftNum ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
-                    isLeftNum ? RightChild.GetExpandedValue(state, loggingContext) : LeftChild.GetExpandedValue(state, loggingContext));
+                    isLeftNum ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
             }
 
             return (isLeftNum, isLeftVersion, isRightNum, isRightVersion) switch
diff --git a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
index acfdd72bce9..6089e5dd255 100644
--- a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
@@ -3,11 +3,8 @@
 
 using System;
 using System.Diagnostics;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
@@ -16,29 +13,34 @@ namespace Microsoft.Build.Evaluation
     [DebuggerDisplay("{DebuggerDisplay,nq}")]
     internal sealed class NumericExpressionNode : OperandExpressionNode
     {
-        private string _value;
+        private readonly string _value;
 
         internal NumericExpressionNode(string value)
         {
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(value), "NumericExpressionNode cannot have empty value");
             _value = value;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
             return ConversionUtilities.TryConvertDecimalOrHexToDouble(_value, out result);
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version? result)
         {
             return Version.TryParse(_value, out result);
         }
 
+        /// <inheritdoc cref="GenericExpressionNode"/>
+        internal override bool IsUnexpandedValueEmpty()
+            => false;
+
         /// <summary>
         /// Get the unexpanded value
         /// </summary>
@@ -50,7 +52,7 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// <summary>
         /// Get the expanded value
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
             return _value;
         }
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index 2c172a9af0a..55cf768c60b 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -3,6 +3,7 @@
 
 using System;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
 
 #nullable disable
 
@@ -13,21 +14,21 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class OperatorExpressionNode : GenericExpressionNode
     {
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            result = BoolEvaluate(state, loggingContext);
+            result = BoolEvaluate(state);
             return true;
         }
 
-        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
+        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
             result = default;
             return false;
@@ -37,11 +38,15 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
             return null;
         }
 
+        /// <inheritdoc cref="GenericExpressionNode"/>
+        internal override bool IsUnexpandedValueEmpty()
+            => (LeftChild?.IsUnexpandedValueEmpty() ?? true) && (RightChild?.IsUnexpandedValueEmpty() ?? true);
+
         /// <summary>
         /// Value before any item and property expressions are expanded
         /// </summary>
diff --git a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
index 9d4add7436e..dae691252e2 100644
--- a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
@@ -19,15 +19,15 @@ internal sealed class OrExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ExpressionDoesNotEvaluateToBoolean",
                     LeftChild.GetUnexpandedValue(state),
-                    LeftChild.GetExpandedValue(state, loggingContext),
+                    LeftChild.GetExpandedValue(state),
                     state.Condition);
             }
 
@@ -38,7 +38,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                         state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index 2c3dcc080df..f66e2d5efee 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -31,34 +31,34 @@ internal StringExpressionNode(string value, bool expandable)
             _expandable = expandable;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state, loggingContext), out result);
+            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state), out result);
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
+            if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
                 result = ConversionUtilities.ConvertDecimalOrHexToDouble(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state, loggingContext), out result);
+                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state), out result);
             }
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
+            if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
                 result = Version.Parse(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return Version.TryParse(GetExpandedValue(state, loggingContext), out result);
+                return Version.TryParse(GetExpandedValue(state), out result);
             }
         }
 
@@ -69,7 +69,7 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// to empty than to fully evaluate it.
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (_cachedExpandedValue == null)
             {
@@ -94,7 +94,7 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
                             break;
                     }
 
-                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value, loggingContext);
+                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value);
 
                     if (expandBreakEarly == null)
                     {
@@ -117,6 +117,10 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
         }
 
 
+        /// <inheritdoc cref="GenericExpressionNode"/>
+        internal override bool IsUnexpandedValueEmpty() 
+            => string.IsNullOrEmpty(_value);
+
         /// <summary>
         /// Value before any item and property expressions are expanded
         /// </summary>
@@ -130,13 +134,13 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (_cachedExpandedValue == null)
             {
                 if (_expandable)
                 {
-                    _cachedExpandedValue = state.ExpandIntoString(_value, loggingContext);
+                    _cachedExpandedValue = state.ExpandIntoString(_value);
                 }
                 else
                 {
@@ -169,7 +173,7 @@ internal override void ResetState()
         /// but now cause the project to throw InvalidProjectException when
         /// ToolsVersion is "Current". https://github.com/dotnet/msbuild/issues/4150
         /// </remarks>
-        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (!_shouldBeTreatedAsVisualStudioVersion.HasValue)
             {
@@ -177,7 +181,7 @@ private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionE
 
                 // Do this check first, because if it's not (common) we can early-out and the next
                 // expansion will be cheap because this will populate the cached expanded value.
-                if (string.Equals(GetExpandedValue(state, loggingContext), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
+                if (string.Equals(GetExpandedValue(state), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
                 {
                     // and it is just an expansion of MSBuildToolsVersion
                     _shouldBeTreatedAsVisualStudioVersion = string.Equals(_value, "$(MSBuildToolsVersion)", StringComparison.OrdinalIgnoreCase);
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 85447378533..b82733a9d8e 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -12,6 +12,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Components.Logging;
 using Microsoft.Build.BackEnd.Components.RequestBuilder;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -223,12 +224,8 @@ private Evaluator(
                 buildEventContext,
                 string.IsNullOrEmpty(projectRootElement.ProjectFileLocation.File) ? "(null)" : projectRootElement.ProjectFileLocation.File);
 
-            // If someone sets the 'MsBuildLogPropertyTracking' environment variable to a non-zero value, wrap property accesses for event reporting.
-            if (Traits.Instance.LogPropertyTracking > 0)
-            {
-                // Wrap the IEvaluatorData<> object passed in.
-                data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);
-            }
+            // Wrap the IEvaluatorData<> object passed in.
+            data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);
 
             // If the host wishes to provide a directory cache for this evaluation, create a new EvaluationContext with the right file system.
             _evaluationContext = evaluationContext;
@@ -240,12 +237,10 @@ private Evaluator(
             }
 
             // Create containers for the evaluation results
-            data.InitializeForEvaluation(toolsetProvider, _evaluationContext);
+            data.InitializeForEvaluation(toolsetProvider, _evaluationContext, _evaluationLoggingContext);
 
             _expander = new Expander<P, I>(data, data, _evaluationContext, _evaluationLoggingContext);
 
-            // This setting may change after the build has started, therefore if the user has not set the property to true on the build parameters we need to check to see if it is set to true on the environment variable.
-            _expander.WarnForUninitializedProperties = BuildParameters.WarnOnUninitializedProperty || Traits.Instance.EscapeHatches.WarnOnUninitializedProperty;
             _data = data;
             _itemGroupElements = new List<ProjectItemGroupElement>();
             _itemDefinitionGroupElements = new List<ProjectItemDefinitionGroupElement>();
@@ -713,8 +708,7 @@ private void Evaluate()
                 {
                     // Evaluate the usingtask and add the result into the data passed in
                     TaskRegistry.InitializeTaskRegistryFromUsingTaskElements<P, I>(
-                        _evaluationLoggingContext.LoggingService,
-                        _evaluationLoggingContext.BuildEventContext,
+                        _evaluationLoggingContext,
                         _usingTaskElements.Select(p => (p.Value, p.Key)),
                         _data.TaskRegistry,
                         _expander,
@@ -860,12 +854,12 @@ private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)
             using (_evaluationProfiler.TrackFile(currentProjectOrImport.FullPath))
             {
                 // We accumulate InitialTargets from the project and each import
-                var initialTargets = _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.InitialTargets, ExpanderOptions.ExpandProperties, currentProjectOrImport.InitialTargetsLocation, _evaluationLoggingContext);
+                var initialTargets = _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.InitialTargets, ExpanderOptions.ExpandProperties, currentProjectOrImport.InitialTargetsLocation);
                 _initialTargetsList.AddRange(initialTargets);
 
                 if (!Traits.Instance.EscapeHatches.IgnoreTreatAsLocalProperty)
                 {
-                    foreach (string propertyName in _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.TreatAsLocalProperty, ExpanderOptions.ExpandProperties, currentProjectOrImport.TreatAsLocalPropertyLocation, _evaluationLoggingContext))
+                    foreach (string propertyName in _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.TreatAsLocalProperty, ExpanderOptions.ExpandProperties, currentProjectOrImport.TreatAsLocalPropertyLocation))
                     {
                         XmlUtilities.VerifyThrowProjectValidElementName(propertyName, currentProjectOrImport.Location);
                         _data.GlobalPropertiesToTreatAsLocal.Add(propertyName);
@@ -1051,8 +1045,8 @@ private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList<Pr
         /// </summary>
         private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement, Dictionary<string, LinkedListNode<ProjectTargetElement>> activeTargets, Dictionary<string, List<TargetSpecification>> targetsWhichRunBeforeByTarget, Dictionary<string, List<TargetSpecification>> targetsWhichRunAfterByTarget)
         {
-            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation, _evaluationLoggingContext);
-            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation, _evaluationLoggingContext);
+            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation);
+            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation);
 
             foreach (string beforeTarget in beforeTargets)
             {
@@ -1285,90 +1279,23 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
                     return;
                 }
 
+                _expander.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluation;
                 if (!EvaluateConditionCollectingConditionedProperties(propertyElement, ExpanderOptions.ExpandProperties, ParserOptions.AllowProperties))
                 {
                     return;
                 }
 
+                _expander.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.PropertyEvaluation;
+
                 // Set the name of the property we are currently evaluating so when we are checking to see if we want to add the property to the list of usedUninitialized properties we can not add the property if
                 // it is the same as what we are setting the value on. Note: This needs to be set before we expand the property we are currently setting.
-                _expander.UsedUninitializedProperties.CurrentlyEvaluatingPropertyElementName = propertyElement.Name;
-
-                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location, _evaluationLoggingContext);
-
-                // If we are going to set a property to a value other than null or empty we need to check to see if it has been used
-                // during evaluation.
-                if (evaluatedValue.Length > 0 && _expander.WarnForUninitializedProperties)
-                {
-                    // Is the property we are currently setting in the list of properties which have been used but not initialized
-                    IElementLocation elementWhichUsedProperty;
-                    bool isPropertyInList = _expander.UsedUninitializedProperties.TryGetPropertyElementLocation(propertyElement.Name, out elementWhichUsedProperty);
-
-                    if (isPropertyInList)
-                    {
-                        // Once we are going to warn for a property once, remove it from the list so we do not add it again.
-                        _expander.UsedUninitializedProperties.RemoveProperty(propertyElement.Name);
-                        _evaluationLoggingContext.LogWarning(null, new BuildEventFileInfo(propertyElement.Location), "UsedUninitializedProperty", propertyElement.Name, elementWhichUsedProperty.LocationString);
-                    }
-                }
-
-                _expander.UsedUninitializedProperties.CurrentlyEvaluatingPropertyElementName = null;
-
-                if (Traits.Instance.LogPropertyTracking == 0)
-                {
-                    P predecessor = _data.GetProperty(propertyElement.Name);
-                    P property = _data.SetProperty(propertyElement, evaluatedValue);
-
-                    if (predecessor != null)
-                    {
-                        LogPropertyReassignment(predecessor, property, propertyElement.Location.LocationString);
-                    }
-                }
-                else
-                {
-                    _data.SetProperty(propertyElement, evaluatedValue);
-                }
-            }
-        }
+                _expander.PropertiesUseTracker.CurrentlyEvaluatingPropertyElementName = propertyElement.Name;
 
-        private void LogPropertyReassignment(P predecessor, P property, string location)
-        {
-            string newValue = property.EvaluatedValue;
-            string oldValue = predecessor?.EvaluatedValue;
-
-            if (string.Equals(property.Name, "MSBuildAllProjects", StringComparison.OrdinalIgnoreCase))
-            {
-                // There's a huge perf cost to logging this and it increases the binlog size significantly.
-                // Meanwhile the usefulness of logging this is very low.
-                return;
-            }
+                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location);
 
-            if (newValue != oldValue)
-            {
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))
-                {
-                    var args = new PropertyReassignmentEventArgs(
-                        property.Name,
-                        oldValue,
-                        newValue,
-                        location,
-                        message: null)
-                    {
-                        BuildEventContext = _evaluationLoggingContext.BuildEventContext,
-                    };
+                _expander.PropertiesUseTracker.CheckPreexistingUndefinedUsage(propertyElement, evaluatedValue, _evaluationLoggingContext);
 
-                    _evaluationLoggingContext.LogBuildEvent(args);
-                }
-                else
-                {
-                    _evaluationLoggingContext.LogComment(
-                        MessageImportance.Low,
-                        "PropertyReassignment",
-                        property.Name,
-                        newValue,
-                        oldValue,
-                        location);
-                }
+                _data.SetProperty(propertyElement, evaluatedValue);
             }
         }
 
@@ -2035,7 +1962,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
         {
             imports = null;
 
-            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation, _evaluationLoggingContext);
+            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation);
             ElementLocation importLocationInProject = importElement.Location;
 
             if (String.IsNullOrWhiteSpace(importExpressionEscaped))
@@ -2459,8 +2386,6 @@ private bool EvaluateCondition(ProjectElement element, string condition, Expande
                     expanderOptions,
                     GetCurrentDirectoryForConditionEvaluation(element),
                     element.ConditionLocation,
-                    _evaluationLoggingContext.LoggingService,
-                    _evaluationLoggingContext.BuildEventContext,
                     _evaluationContext.FileSystem,
                     loggingContext: _evaluationLoggingContext);
 
@@ -2498,9 +2423,8 @@ private bool EvaluateConditionCollectingConditionedProperties(ProjectElement ele
                     _data.ConditionedProperties,
                     GetCurrentDirectoryForConditionEvaluation(element),
                     element.ConditionLocation,
-                    _evaluationLoggingContext.LoggingService,
-                    _evaluationLoggingContext.BuildEventContext,
                     _evaluationContext.FileSystem,
+                    _evaluationLoggingContext,
                     projectRootElementCache);
 
                 return result;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index ffbdbb5e855..c64d877596a 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -307,7 +307,7 @@ private void FlushFirstValueIfNeeded()
         /// <summary>
         /// Set of properties which are null during expansion.
         /// </summary>
-        private UsedUninitializedProperties _usedUninitializedProperties;
+        private PropertiesUseTracker _propertiesUseTracker;
 
         private readonly IFileSystem _fileSystem;
 
@@ -318,25 +318,42 @@ private void FlushFirstValueIfNeeded()
         /// </summary>
         internal EvaluationContext EvaluationContext { get; }
 
+        private Expander(IPropertyProvider<P> properties, LoggingContext loggingContext)
+        {
+            _properties = properties;
+            _propertiesUseTracker = new PropertiesUseTracker(loggingContext);
+            _loggingContext = loggingContext;
+        }
+
         /// <summary>
         /// Creates an expander passing it some properties to use.
         /// Properties may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem)
+        internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem, LoggingContext loggingContext)
+            : this(properties, loggingContext)
         {
-            _properties = properties;
-            _usedUninitializedProperties = new UsedUninitializedProperties();
             _fileSystem = fileSystem;
         }
 
+        /// <summary>
+        /// Creates an expander passing it some properties to use.
+        /// Properties may be null.
+        ///
+        /// Used for tests and for ToolsetReader - that operates agnostic on the project
+        ///   - so no logging context is passed, and no BuildCheck analysis will be executed.
+        /// </summary>
+        internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem)
+        : this(properties, fileSystem, null)
+        { }
+
         /// <summary>
         /// Creates an expander passing it some properties to use and the evaluation context.
         /// Properties may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, EvaluationContext evaluationContext)
+        internal Expander(IPropertyProvider<P> properties, EvaluationContext evaluationContext,
+            LoggingContext loggingContext)
+            : this(properties, loggingContext)
         {
-            _properties = properties;
-            _usedUninitializedProperties = new UsedUninitializedProperties();
             _fileSystem = evaluationContext.FileSystem;
             EvaluationContext = evaluationContext;
         }
@@ -345,8 +362,8 @@ internal Expander(IPropertyProvider<P> properties, EvaluationContext evaluationC
         /// Creates an expander passing it some properties and items to use.
         /// Either or both may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFileSystem fileSystem)
-            : this(properties, fileSystem)
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFileSystem fileSystem, LoggingContext loggingContext)
+            : this(properties, fileSystem, loggingContext)
         {
             _items = items;
         }
@@ -356,45 +373,57 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFile
         /// Creates an expander passing it some properties and items to use, and the evaluation context.
         /// Either or both may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, EvaluationContext evaluationContext)
-            : this(properties, evaluationContext)
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, EvaluationContext evaluationContext, LoggingContext loggingContext)
+            : this(properties, evaluationContext, loggingContext)
         {
             _items = items;
         }
 
         /// <summary>
-        /// Initializes a new instance of the <see cref="Expander{P, I}"/> class with the specified property provider, item provider, evaluation context, and logging context.
+        /// Creates an expander passing it some properties, items, and/or metadata to use.
+        /// Any or all may be null.
         /// </summary>
-        /// <param name="properties">The property provider supplying properties for expansion.</param>
-        /// <param name="items">The item provider supplying items for expansion.</param>
-        /// <param name="evaluationContext">The evaluation context used during expansion.</param>
-        /// <param name="loggingContext">The logging context used for logging or emmitting events during expansion.</param>
-        /// <exception cref="ArgumentNullException">Thrown when either <paramref name="properties"/> or <paramref name="evaluationContext"/> is null.</exception>
-        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, EvaluationContext evaluationContext, LoggingContext loggingContext)
-            : this(properties, evaluationContext)
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMetadataTable metadata, IFileSystem fileSystem, LoggingContext loggingContext)
+            : this(properties, items, fileSystem, loggingContext)
         {
-            _items = items;
-            _loggingContext = loggingContext;
+            _metadata = metadata;
         }
 
         /// <summary>
         /// Creates an expander passing it some properties, items, and/or metadata to use.
         /// Any or all may be null.
+        ///
+        /// This is for the purpose of evaluations through API calls, that might not be able to pass the logging context
+        ///  - BuildCheck analysis won't be executed for those.
+        /// (for one of the calls we can actually pass IDataConsumingContext - as we have logging service and project)
+        /// 
         /// </summary>
         internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMetadataTable metadata, IFileSystem fileSystem)
-            : this(properties, items, fileSystem)
+            : this(properties, items, fileSystem, null)
         {
             _metadata = metadata;
         }
 
+        private Expander(
+            IPropertyProvider<P> properties,
+            IItemProvider<I> items,
+            IMetadataTable metadata,
+            IFileSystem fileSystem,
+            EvaluationContext evaluationContext,
+            LoggingContext loggingContext)
+            : this(properties, items, metadata, fileSystem, loggingContext)
+        {
+            EvaluationContext = evaluationContext;
+        }
+
         /// <summary>
-        /// Whether to warn when we set a property for the first time, after it was previously used.
-        /// Default is false, unless MSBUILDWARNONUNINITIALIZEDPROPERTY is set.
+        /// Recreates the expander with passed in logging context
         /// </summary>
-        internal bool WarnForUninitializedProperties
+        /// <param name="loggingContext"></param>
+        /// <returns></returns>
+        internal Expander<P, I> WithLoggingContext(LoggingContext loggingContext)
         {
-            get { return _usedUninitializedProperties.Warn; }
-            set { _usedUninitializedProperties.Warn = value; }
+            return new Expander<P, I>(_properties, _items, _metadata, _fileSystem, EvaluationContext, loggingContext);
         }
 
         /// <summary>
@@ -411,10 +440,10 @@ internal IMetadataTable Metadata
         /// If a property is expanded but evaluates to null then it is considered to be un-initialized.
         /// We want to keep track of these properties so that we can warn if the property gets set later on.
         /// </summary>
-        internal UsedUninitializedProperties UsedUninitializedProperties
+        internal PropertiesUseTracker PropertiesUseTracker
         {
-            get { return _usedUninitializedProperties; }
-            set { _usedUninitializedProperties = value; }
+            get { return _propertiesUseTracker; }
+            set { _propertiesUseTracker = value; }
         }
 
         /// <summary>
@@ -443,9 +472,9 @@ internal static bool ExpressionContainsItemVector(string expression)
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
+        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
-            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext);
+            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation);
 
             return (result == null) ? null : EscapingUtilities.UnescapeAll(result);
         }
@@ -457,7 +486,7 @@ internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions o
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
+        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
             if (expression.Length == 0)
             {
@@ -466,8 +495,8 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
 
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
-            string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation, loggingContext);
-            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem, loggingContext);
+            string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation, _loggingContext);
+            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _propertiesUseTracker, _fileSystem);
             result = ItemExpander.ExpandItemVectorsIntoString<I>(this, result, _items, options, elementLocation);
             result = FileUtilities.MaybeAdjustFilePath(result);
 
@@ -488,7 +517,7 @@ internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, Expander
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string metaExpanded = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
-            return PropertyExpander<P>.ExpandPropertiesLeaveTypedAndEscaped(metaExpanded, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
+            return PropertyExpander<P>.ExpandPropertiesLeaveTypedAndEscaped(metaExpanded, _properties, options, elementLocation, _propertiesUseTracker, _fileSystem);
         }
 
         /// <summary>
@@ -497,11 +526,11 @@ internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, Expander
         /// Use this form when the result is going to be processed further, for example by matching against the file system,
         /// so literals must be distinguished, and you promise to unescape after that.
         /// </summary>
-        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
+        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
             ErrorUtilities.VerifyThrow((options & ExpanderOptions.BreakOnNotEmpty) == 0, "not supported");
 
-            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext));
+            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation));
         }
 
         /// <summary>
@@ -536,7 +565,7 @@ internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             expression = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
-            expression = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(expression, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
+            expression = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(expression, _properties, options, elementLocation, _propertiesUseTracker, _fileSystem);
             expression = FileUtilities.MaybeAdjustFilePath(expression);
 
             List<T> result = new List<T>();
@@ -1121,9 +1150,8 @@ internal static string ExpandPropertiesLeaveEscaped(
                 IPropertyProvider<T> properties,
                 ExpanderOptions options,
                 IElementLocation elementLocation,
-                UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem,
-                LoggingContext loggingContext = null)
+                PropertiesUseTracker propertiesUseTracker,
+                IFileSystem fileSystem)
             {
                 return
                     ConvertToString(
@@ -1132,9 +1160,8 @@ internal static string ExpandPropertiesLeaveEscaped(
                             properties,
                             options,
                             elementLocation,
-                            usedUninitializedProperties,
-                            fileSystem,
-                            loggingContext));
+                            propertiesUseTracker,
+                            fileSystem));
             }
 
             /// <summary>
@@ -1159,9 +1186,8 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 IPropertyProvider<T> properties,
                 ExpanderOptions options,
                 IElementLocation elementLocation,
-                UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem,
-                LoggingContext loggingContext = null)
+                PropertiesUseTracker propertiesUseTracker,
+                IFileSystem fileSystem)
             {
                 if (((options & ExpanderOptions.ExpandProperties) == 0) || String.IsNullOrEmpty(expression))
                 {
@@ -1270,13 +1296,12 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                                 properties,
                                 options,
                                 elementLocation,
-                                usedUninitializedProperties,
-                                fileSystem,
-                                loggingContext);
+                                propertiesUseTracker,
+                                fileSystem);
                         }
                         else // This is a regular property
                         {
-                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties, loggingContext);
+                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, propertiesUseTracker);
                         }
 
                         if (propertyValue != null)
@@ -1319,9 +1344,8 @@ internal static object ExpandPropertyBody(
                 IPropertyProvider<T> properties,
                 ExpanderOptions options,
                 IElementLocation elementLocation,
-                UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem,
-                LoggingContext loggingContext)
+                PropertiesUseTracker propertiesUseTracker,
+                IFileSystem fileSystem)
             {
                 Function<T> function = null;
                 string propertyName = propertyBody;
@@ -1351,9 +1375,9 @@ internal static object ExpandPropertyBody(
                             propertyBody,
                             elementLocation,
                             propertyValue,
-                            usedUninitializedProperties,
+                            propertiesUseTracker,
                             fileSystem,
-                            loggingContext);
+                            propertiesUseTracker.LoggingContext);
 
                         // We may not have been able to parse out a function
                         if (function != null)
@@ -1381,7 +1405,7 @@ internal static object ExpandPropertyBody(
                         }
                         else
                         {
-                            propertyValue = LookupProperty(properties, propertyBody, 0, indexerStart - 1, elementLocation, usedUninitializedProperties);
+                            propertyValue = LookupProperty(properties, propertyBody, 0, indexerStart - 1, elementLocation, propertiesUseTracker);
                             propertyBody = propertyBody.Substring(indexerStart);
 
                             // recurse so that the function representing the indexer can be executed on the property value
@@ -1391,9 +1415,8 @@ internal static object ExpandPropertyBody(
                                 properties,
                                 options,
                                 elementLocation,
-                                usedUninitializedProperties,
-                                fileSystem,
-                                loggingContext);
+                                propertiesUseTracker,
+                                fileSystem);
                         }
                     }
                     else
@@ -1410,7 +1433,7 @@ internal static object ExpandPropertyBody(
                 // doesn't exist in the collection, and we're not executing a static function
                 if (!String.IsNullOrEmpty(propertyName))
                 {
-                    propertyValue = LookupProperty(properties, propertyName, elementLocation, usedUninitializedProperties);
+                    propertyValue = LookupProperty(properties, propertyName, elementLocation, propertiesUseTracker);
                 }
 
                 if (function != null)
@@ -1517,21 +1540,26 @@ internal static string ConvertToString(object valueToConvert)
             /// <summary>
             /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)
+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, PropertiesUseTracker propertiesUseTracker)
             {
-                return LookupProperty(properties, propertyName, 0, propertyName.Length - 1, elementLocation, usedUninitializedProperties);
+                return LookupProperty(properties, propertyName, 0, propertyName.Length - 1, elementLocation, propertiesUseTracker);
             }
 
             /// <summary>
             /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties, LoggingContext loggingContext = null)
+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, PropertiesUseTracker propertiesUseTracker)
             {
                 T property = properties.GetProperty(propertyName, startIndex, endIndex);
 
                 object propertyValue;
 
-                if (property == null && ((endIndex - startIndex) >= 7) && MSBuildNameIgnoreCaseComparer.Default.Equals("MSBuild", propertyName, startIndex, 7))
+                bool isArtifical = property == null && ((endIndex - startIndex) >= 7) &&
+                                   MSBuildNameIgnoreCaseComparer.Default.Equals("MSBuild", propertyName, startIndex, 7);
+
+                propertiesUseTracker.TrackRead(propertyName, startIndex, endIndex, elementLocation, property == null, isArtifical);
+                
+                if (isArtifical)
                 {
                     // It could be one of the MSBuildThisFileXXXX properties,
                     // whose values vary according to the file they are in.
@@ -1546,31 +1574,13 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                 }
                 else if (property == null)
                 {
-                    // We have evaluated a property to null. We now need to see if we need to add it to the list of properties which are used before they have been initialized
-                    //
-                    // We also do not want to add the property to the list if the environment variable is not set, also we do not want to add the property to the list if we are currently
-                    // evaluating a condition because a common pattern for msbuild projects is to see if the property evaluates to empty and then set a value as this would cause a considerable number of false positives.   <A Condition="'$(A)' == ''">default</A>
-                    //
-                    // Another pattern used is where a property concatenates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of
-                    // false positives. Therefore we check to see what element we are currently evaluating and if it is the same as our property we do not add the property to the list.
-                    if (usedUninitializedProperties.Warn && usedUninitializedProperties.CurrentlyEvaluatingPropertyElementName != null)
-                    {
-                        // Check to see if the property name does not match the property we are currently evaluating, note the property we are currently evaluating in the element name, this means no $( or )
-                        if (!MSBuildNameIgnoreCaseComparer.Default.Equals(usedUninitializedProperties.CurrentlyEvaluatingPropertyElementName, propertyName, startIndex, endIndex - startIndex + 1))
-                        {
-                            usedUninitializedProperties.TryAdd(
-                                propertyName: propertyName.Substring(startIndex, endIndex - startIndex + 1),
-                                elementLocation);
-                        }
-                    }
-
                     propertyValue = String.Empty;
                 }
                 else
                 {
                     if (property is ProjectPropertyInstance.EnvironmentDerivedProjectPropertyInstance environmentDerivedProperty)
                     {
-                        environmentDerivedProperty.loggingContext = loggingContext;
+                        environmentDerivedProperty.loggingContext = propertiesUseTracker.LoggingContext;
                     }
 
                     propertyValue = property.EvaluatedValueEscaped;
@@ -2755,7 +2765,7 @@ internal static IEnumerable<KeyValuePair<string, S>> ExecuteStringFunction(
                             arguments,
                             BindingFlags.Public | BindingFlags.InvokeMethod,
                             string.Empty,
-                            expander.UsedUninitializedProperties,
+                            expander.PropertiesUseTracker,
                             expander._fileSystem,
                             expander._loggingContext);
 
@@ -3187,7 +3197,7 @@ private struct FunctionBuilder<T>
             /// <summary>
             /// List of properties which have been used but have not been initialized yet.
             /// </summary>
-            public UsedUninitializedProperties UsedUninitializedProperties { get; set; }
+            public PropertiesUseTracker PropertiesUseTracker { get; set; }
 
             internal readonly Function<T> Build()
             {
@@ -3199,7 +3209,7 @@ internal readonly Function<T> Build()
                     Arguments,
                     BindingFlags,
                     Remainder,
-                    UsedUninitializedProperties,
+                    PropertiesUseTracker,
                     FileSystem,
                     LoggingContext);
             }
@@ -3251,7 +3261,7 @@ internal class Function<T>
             /// <summary>
             /// List of properties which have been used but have not been initialized yet.
             /// </summary>
-            private readonly UsedUninitializedProperties _usedUninitializedProperties;
+            private PropertiesUseTracker _propertiesUseTracker;
 
             private readonly IFileSystem _fileSystem;
 
@@ -3268,7 +3278,7 @@ internal Function(
                 string[] arguments,
                 BindingFlags bindingFlags,
                 string remainder,
-                UsedUninitializedProperties usedUninitializedProperties,
+                PropertiesUseTracker propertiesUseTracker,
                 IFileSystem fileSystem,
                 LoggingContext loggingContext)
             {
@@ -3287,7 +3297,7 @@ internal Function(
                 _receiverType = receiverType;
                 _bindingFlags = bindingFlags;
                 _remainder = remainder;
-                _usedUninitializedProperties = usedUninitializedProperties;
+                _propertiesUseTracker = propertiesUseTracker;
                 _fileSystem = fileSystem;
                 _loggingContext = loggingContext;
             }
@@ -3311,7 +3321,7 @@ internal static Function<T> ExtractPropertyFunction(
                 string expressionFunction,
                 IElementLocation elementLocation,
                 object propertyValue,
-                UsedUninitializedProperties usedUnInitializedProperties,
+                PropertiesUseTracker propertiesUseTracker,
                 IFileSystem fileSystem,
                 LoggingContext loggingContext)
             {
@@ -3335,7 +3345,7 @@ internal static Function<T> ExtractPropertyFunction(
                 ProjectErrorUtilities.VerifyThrowInvalidProject(!expressionRoot.IsEmpty, elementLocation, "InvalidFunctionPropertyExpression", expressionFunction, String.Empty);
 
                 functionBuilder.Expression = expressionFunction;
-                functionBuilder.UsedUninitializedProperties = usedUnInitializedProperties;
+                functionBuilder.PropertiesUseTracker = propertiesUseTracker;
 
                 // This is a static method call
                 // A static method is the content that follows the last "::", the rest being the type
@@ -3487,7 +3497,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                             properties,
                             options,
                             elementLocation,
-                            _usedUninitializedProperties,
+                            _propertiesUseTracker,
                             _fileSystem);
 
                         if (argument is string argumentValue)
@@ -3621,9 +3631,8 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                         properties,
                         options,
                         elementLocation,
-                        _usedUninitializedProperties,
-                        _fileSystem,
-                        _loggingContext);
+                        _propertiesUseTracker,
+                        _fileSystem);
                 }
 
                 // Exceptions coming from the actual function called are wrapped in a TargetInvocationException
@@ -3917,12 +3926,12 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                     }
                     else if (_receiverType == typeof(IntrinsicFunctions))
                     {
-                        if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RegisterAnalyzer), StringComparison.OrdinalIgnoreCase))
+                        if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RegisterBuildCheck), StringComparison.OrdinalIgnoreCase))
                         {
-                            ErrorUtilities.VerifyThrow(_loggingContext != null, $"The logging context is missed. {nameof(IntrinsicFunctions.RegisterAnalyzer)} can not be invoked.");
+                            ErrorUtilities.VerifyThrow(_loggingContext != null, $"The logging context is missed. {nameof(IntrinsicFunctions.RegisterBuildCheck)} can not be invoked.");
                             if (TryGetArg(args, out string arg0))
                             {
-                                returnVal = IntrinsicFunctions.RegisterAnalyzer(arg0, _loggingContext);
+                                returnVal = IntrinsicFunctions.RegisterBuildCheck(arg0, _loggingContext);
                                 return true;
                             }
                         }
@@ -4229,11 +4238,11 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.SubstringByTextElements), StringComparison.OrdinalIgnoreCase))
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.SubstringByAsciiChars), StringComparison.OrdinalIgnoreCase))
                         {
                             if (TryGetArgs(args, out string arg0, out int arg1, out int arg2))
                             {
-                                returnVal = IntrinsicFunctions.SubstringByTextElements(arg0, arg1, arg2);
+                                returnVal = IntrinsicFunctions.SubstringByAsciiChars(arg0, arg1, arg2);
                                 return true;
                             }
                         }
@@ -5490,64 +5499,6 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
     }
 
 #nullable enable
-    /// <summary>
-    /// This class wraps information about properties which have been used before they are initialized.
-    /// </summary>
-    internal sealed class UsedUninitializedProperties
-    {
-        /// <summary>
-        /// Lazily allocated collection of properties and the element which used them.
-        /// </summary>
-        private Dictionary<string, IElementLocation>? _properties;
-
-        internal void TryAdd(string propertyName, IElementLocation elementLocation)
-        {
-            if (_properties is null)
-            {
-                _properties = new(StringComparer.OrdinalIgnoreCase);
-            }
-            else if (_properties.ContainsKey(propertyName))
-            {
-                return;
-            }
-
-            _properties.Add(propertyName, elementLocation);
-        }
-
-        internal bool TryGetPropertyElementLocation(string propertyName, [NotNullWhen(returnValue: true)] out IElementLocation? elementLocation)
-        {
-            if (_properties is null)
-            {
-                elementLocation = null;
-                return false;
-            }
-
-            return _properties.TryGetValue(propertyName, out elementLocation);
-        }
-
-        internal void RemoveProperty(string propertyName)
-        {
-            _properties?.Remove(propertyName);
-        }
-
-        /// <summary>
-        ///  Are we currently supposed to warn if we used an uninitialized property.
-        /// </summary>
-        internal bool Warn
-        {
-            get;
-            set;
-        }
-
-        /// <summary>
-        ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property.
-        /// </summary>
-        internal string? CurrentlyEvaluatingPropertyElementName
-        {
-            get;
-            set;
-        }
-    }
 
     internal static class IntrinsicFunctionOverload
     {
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index 4d5b2ea8e98..12d42a71ea9 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -212,7 +213,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Prepares the data block for a new evaluation pass
         /// </summary>
-        void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext);
+        void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext);
 
         /// <summary>
         /// Indicates to the data block that evaluation has completed,
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 611b8af238d..17e67ce123a 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -9,7 +9,6 @@
 using System.Runtime.Versioning;
 using System.Text;
 using System.Text.RegularExpressions;
-using System.Globalization;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
@@ -19,6 +18,7 @@
 using Microsoft.Build.Utilities;
 using Microsoft.NET.StringTools;
 using Microsoft.Win32;
+using System.Linq;
 
 // Needed for DoesTaskHostExistForParameters
 using NodeProviderOutOfProcTaskHost = Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost;
@@ -629,10 +629,30 @@ internal static bool AreFeaturesEnabled(Version wave)
             return ChangeWaves.AreFeaturesEnabled(wave);
         }
 
-        internal static string SubstringByTextElements(string input, int start, int length)
+        internal static string SubstringByAsciiChars(string input, int start, int length)
         {
-            StringInfo stringInfo = new StringInfo(input);
-            return stringInfo.SubstringByTextElements(start, length);
+            if (start > input.Length)
+            {
+                return string.Empty;
+            }
+            if (start + length > input.Length)
+            {
+                length = input.Length - start;
+            }
+            StringBuilder sb = new StringBuilder();
+            for (int i = start; i < start + length; i++)
+            {
+                char c = input[i];
+                if (c >= 32 && c <= 126 && !FileUtilities.InvalidFileNameChars.Contains(c))
+                {
+                    sb.Append(c);
+                }
+                else
+                {
+                    sb.Append('_');
+                }
+            }
+            return sb.ToString();
         }
 
         internal static string CheckFeatureAvailability(string featureName)
@@ -677,7 +697,7 @@ public static string GetMSBuildExtensionsPath()
 
         public static bool IsRunningFromVisualStudio() => BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio;
 
-        public static bool RegisterAnalyzer(string pathToAssembly, LoggingContext loggingContext)
+        public static bool RegisterBuildCheck(string pathToAssembly, LoggingContext loggingContext)
         {
             pathToAssembly = FileUtilities.GetFullPathNoThrow(pathToAssembly);
             if (File.Exists(pathToAssembly))
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index c45edf0764b..e9b381b5aa1 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -157,23 +157,21 @@ private bool InitReferencedItemsIfNecessary()
         /// <param name="itemSpecLocation">The xml location the itemspec comes from</param>
         /// <param name="projectDirectory">The directory that the project is in.</param>
         /// <param name="expandProperties">Expand properties before breaking down fragments. Defaults to true</param>
-        /// <param name="loggingContext">Context in which to log</param>
         public ItemSpec(
             string itemSpec,
             Expander<P, I> expander,
             IElementLocation itemSpecLocation,
             string projectDirectory,
-            bool expandProperties = true,
-            LoggingContext loggingContext = null)
+            bool expandProperties = true)
         {
             ItemSpecString = itemSpec;
             Expander = expander;
             ItemSpecLocation = itemSpecLocation;
 
-            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties, loggingContext);
+            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties);
         }
 
-        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties, LoggingContext loggingContext)
+        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties)
         {
             // Code corresponds to Evaluator.CreateItemsFromInclude
             var evaluatedItemspecEscaped = ItemSpecString;
@@ -189,8 +187,7 @@ private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocat
                 evaluatedItemspecEscaped = Expander.ExpandIntoStringLeaveEscaped(
                     ItemSpecString,
                     ExpanderOptions.ExpandProperties,
-                    itemSpecLocation,
-                    loggingContext);
+                    itemSpecLocation);
             }
 
             var semicolonCount = 0;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 79cd844c167..248945f74fd 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -291,9 +291,9 @@ public ProjectTargetInstance GetTarget(string targetName)
                 return _wrappedData.GetTarget(targetName);
             }
 
-            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
+            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext)
             {
-                _wrappedData.InitializeForEvaluation(toolsetProvider, evaluationContext);
+                _wrappedData.InitializeForEvaluation(toolsetProvider, evaluationContext, loggingContext);
             }
 
             public void RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult)
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index d40ea3145fa..bc35e8ce8b8 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -109,14 +109,14 @@ protected override ImmutableArray<I> SelectItems(OrderedItemDataCollection.Build
                                 MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory ?? string.Empty, glob, string.Join(", ", excludePatternsForGlobs));
                             }
 
-                            using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
+                            using (_lazyEvaluator?._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
                             {
                                 includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
                                     _rootDirectory,
                                     glob,
                                     excludePatternsForGlobs,
                                     fileMatcher: FileMatcher,
-                                    loggingMechanism: _lazyEvaluator._loggingContext,
+                                    loggingMechanism: _lazyEvaluator?._loggingContext,
                                     includeLocation: _itemElement.IncludeLocation,
                                     excludeLocation: _itemElement.ExcludeLocation);
                             }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 6bf5b325d63..56d1c41e44e 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -248,7 +248,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                                 continue;
                             }
 
-                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location, _lazyEvaluator._loggingContext);
+                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location);
                             evaluatedValue = FileUtilities.MaybeAdjustFilePath(evaluatedValue, metadataElement.ContainingProject.DirectoryPath);
 
                             metadataTable.SetValue(metadataElement, evaluatedValue);
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index bb298ee7662..4b658abbecf 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -54,7 +54,7 @@ public LazyItemEvaluator(IEvaluatorData<P, I, M, D> data, IItemFactory<I, I> ite
             _outerEvaluatorData = data;
             _outerExpander = new Expander<P, I>(_outerEvaluatorData, _outerEvaluatorData, evaluationContext, loggingContext);
             _evaluatorData = new EvaluatorData(_outerEvaluatorData, _itemLists);
-            _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext);
+            _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext, loggingContext);
             _itemFactory = itemFactory;
             _loggingContext = loggingContext;
             _evaluationProfiler = evaluationProfiler;
@@ -90,8 +90,6 @@ private static bool EvaluateCondition(
                     expanderOptions,
                     GetCurrentDirectoryForConditionEvaluation(element, lazyEvaluator),
                     element.ConditionLocation,
-                    lazyEvaluator._loggingContext.LoggingService,
-                    lazyEvaluator._loggingContext.BuildEventContext,
                     lazyEvaluator.FileSystem,
                     loggingContext: lazyEvaluator._loggingContext);
                 MSBuildEventSource.Log.EvaluateConditionStop(condition, result);
@@ -619,7 +617,7 @@ private RemoveOperation BuildRemoveOperation(string rootDirectory, ProjectItemEl
 
         private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLocation itemSpecLocation, OperationBuilder builder)
         {
-            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory, loggingContext: _loggingContext);
+            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory);
 
             foreach (ItemSpecFragment fragment in builder.ItemSpec.Fragments)
             {
@@ -630,7 +628,7 @@ private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLoca
             }
         }
 
-        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander, LoggingContext loggingContext = null)
+        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander)
         {
             // Since we're just attempting to expand properties in order to find referenced items and not expanding metadata,
             // unexpected errors may occur when evaluating property functions on unexpanded metadata. Just ignore them if that happens.
@@ -644,8 +642,7 @@ private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(IColle
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Value,
                     expanderOptions,
-                    metadatumElement.Location,
-                    loggingContext);
+                    metadatumElement.Location);
 
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Condition,
@@ -660,7 +657,7 @@ private void ProcessMetadataElements(ProjectItemElement itemElement, OperationBu
             {
                 operationBuilder.Metadata.AddRange(itemElement.Metadata);
 
-                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander, _loggingContext));
+                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander));
                 if (itemsAndMetadataFound.Items != null)
                 {
                     foreach (var itemType in itemsAndMetadataFound.Items)
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 0a910c0a334..143587d96ee 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -273,7 +273,7 @@ internal override ProjectRootElement Get(string projectFile, OpenProjectRootElem
             try
             {
                 // We are about to load. Take a per-file lock to prevent multiple threads from duplicating the work multiple times.
-                object perFileLock = _fileLoadLocks.GetOrAdd(projectFile, () => new object());
+                object perFileLock = _fileLoadLocks.GetOrAdd(projectFile, static _ => new object());
                 lock (perFileLock)
                 {
                     // Call GetOrLoad again, this time with the OpenProjectRootElement callback.
diff --git a/src/Build/Evaluation/PropertiesUseTracker.cs b/src/Build/Evaluation/PropertiesUseTracker.cs
new file mode 100644
index 00000000000..b88423adff1
--- /dev/null
+++ b/src/Build/Evaluation/PropertiesUseTracker.cs
@@ -0,0 +1,158 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics.CodeAnalysis;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+#nullable enable
+
+namespace Microsoft.Build.Evaluation;
+
+/// <summary>
+/// This class tracks reads of properties - so that it can detect uninitialized usages
+///  and so that it can forward the accessing information to further interested consumers (e.g. BuildCheck).
+/// </summary>
+internal sealed class PropertiesUseTracker
+{
+    internal LoggingContext LoggingContext { get; init; }
+
+    public PropertiesUseTracker(LoggingContext loggingContext) => LoggingContext = loggingContext;
+
+    /// <summary>
+    /// Whether to warn when we set a property for the first time, after it was previously used.
+    /// Default is false, unless MSBUILDWARNONUNINITIALIZEDPROPERTY is set.
+    /// </summary>
+    // This setting may change after the build has started, therefore if the user has not set the property to true on the build parameters we need to check to see if it is set to true on the environment variable.
+    private bool _warnForUninitializedProperties = BuildParameters.WarnOnUninitializedProperty || Traits.Instance.EscapeHatches.WarnOnUninitializedProperty;
+
+    /// <summary>
+    /// Lazily allocated collection of properties and the element which used them.
+    /// </summary>
+    private Dictionary<string, IElementLocation>? _properties;
+
+    internal void TrackRead(string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, bool isUninitialized, bool isArtificial)
+    {
+        if (isArtificial || !isUninitialized)
+        {
+            return;
+        }
+
+        // We have evaluated a property to null. We now need to see if we need to add it to the list of properties which are used before they have been initialized
+        //
+        // We also do not want to add the property to the list if the environment variable is not set, also we do not want to add the property to the list if we are currently
+        // evaluating a condition because a common pattern for msbuild projects is to see if the property evaluates to empty and then set a value as this would cause a considerable number of false positives.   <A Condition="'$(A)' == ''">default</A>
+        //
+        // Another pattern used is where a property concatenates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of
+        // false positives. Therefore we check to see what element we are currently evaluating and if it is the same as our property we do not add the property to the list.
+
+        // here handle null probably (or otherwise execution)
+        if (_warnForUninitializedProperties && CurrentlyEvaluatingPropertyElementName != null)
+        {
+            // Check to see if the property name does not match the property we are currently evaluating, note the property we are currently evaluating in the element name, this means no $( or )
+            if (!MSBuildNameIgnoreCaseComparer.Default.Equals(CurrentlyEvaluatingPropertyElementName, propertyName, startIndex, endIndex - startIndex + 1))
+            {
+                TryAdd(
+                    propertyName: propertyName.Substring(startIndex, endIndex - startIndex + 1),
+                    elementLocation);
+            }
+        }
+    }
+
+    internal void TryAdd(string propertyName, IElementLocation elementLocation)
+    {
+        if (_properties is null)
+        {
+            _properties = new(StringComparer.OrdinalIgnoreCase);
+        }
+        else if (_properties.ContainsKey(propertyName))
+        {
+            return;
+        }
+
+        _properties.Add(propertyName, elementLocation);
+    }
+
+    internal bool TryGetPropertyElementLocation(string propertyName, [NotNullWhen(returnValue: true)] out IElementLocation? elementLocation)
+    {
+        if (_properties is null)
+        {
+            elementLocation = null;
+            return false;
+        }
+
+        return _properties.TryGetValue(propertyName, out elementLocation);
+    }
+
+    internal void RemoveProperty(string propertyName)
+    {
+        _properties?.Remove(propertyName);
+    }
+
+    /// <summary>
+    ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property.
+    /// </summary>
+    internal string? CurrentlyEvaluatingPropertyElementName
+    {
+        get;
+        set;
+    }
+
+    internal void CheckPreexistingUndefinedUsage(IPropertyElementWithLocation propertyElement, string evaluatedValue, LoggingContext loggingContext)
+    {
+        // If we are going to set a property to a value other than null or empty we need to check to see if it has been used
+        // during evaluation.
+        if (evaluatedValue.Length > 0 && _warnForUninitializedProperties)
+        {
+            // Is the property we are currently setting in the list of properties which have been used but not initialized
+            IElementLocation? elementWhichUsedProperty;
+            bool isPropertyInList = TryGetPropertyElementLocation(propertyElement.Name, out elementWhichUsedProperty);
+
+            if (isPropertyInList)
+            {
+                // Once we are going to warn for a property once, remove it from the list so we do not add it again.
+                RemoveProperty(propertyElement.Name);
+                loggingContext.LogWarning(null, new BuildEventFileInfo(propertyElement.Location), "UsedUninitializedProperty", propertyElement.Name, elementWhichUsedProperty?.LocationString);
+            }
+        }
+
+        CurrentlyEvaluatingPropertyElementName = null;
+        PropertyReadContext = PropertyReadContext.Other;
+    }
+
+    private PropertyReadContext _propertyReadContext;
+    private PropertyReadContext _previousPropertyReadContext = PropertyReadContext.Other;
+    internal PropertyReadContext PropertyReadContext
+    {
+        private get => _propertyReadContext;
+        set
+        {
+            _previousPropertyReadContext = _propertyReadContext;
+            _propertyReadContext = value;
+        }
+    }
+
+    internal void ResetPropertyReadContext(bool pop = true)
+    {
+        _propertyReadContext = pop ? _previousPropertyReadContext : PropertyReadContext.Other;
+        _previousPropertyReadContext = PropertyReadContext.Other;
+    }
+}
+
+/// <summary>
+/// Type of the context in which a property is read.
+/// </summary>
+internal enum PropertyReadContext
+{
+    // we are not interested in distinguishing the item read etc.
+    Other,
+    ConditionEvaluation,
+    ConditionEvaluationWithOneSideEmpty,
+    PropertyEvaluation,
+    PropertyEvaluationSelf,
+}
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 51117c2d7c1..4b2cd613881 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Components.Logging;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation.Context;
@@ -13,8 +14,6 @@
 using Microsoft.Build.Shared;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
 
-#nullable disable
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
@@ -61,7 +60,11 @@ public PropertyTrackingEvaluatorDataWrapper(IEvaluatorData<P, I, M, D> dataToWra
         public P GetProperty(string name)
         {
             P prop = _wrapped.GetProperty(name);
-            this.TrackPropertyRead(name, prop);
+            if (IsPropertyReadTrackingRequested)
+            {
+                this.TrackPropertyRead(name, prop);
+            }
+
             return prop;
         }
 
@@ -72,22 +75,26 @@ public P GetProperty(string name)
         public P GetProperty(string name, int startIndex, int endIndex)
         {
             P prop = _wrapped.GetProperty(name, startIndex, endIndex);
-            this.TrackPropertyRead(name.Substring(startIndex, endIndex - startIndex + 1), prop);
+            if (IsPropertyReadTrackingRequested)
+            {
+                this.TrackPropertyRead(name.Substring(startIndex, endIndex - startIndex + 1), prop);
+            }
+
             return prop;
         }
 
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null)
+        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, LoggingContext? loggingContext = null)
         {
-            P originalProperty = _wrapped.GetProperty(name);
-            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable, loggingContext);
+            P? originalProperty = _wrapped.GetProperty(name);
+            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable, _evaluationLoggingContext);
 
             this.TrackPropertyWrite(
                 originalProperty,
                 newProperty,
-                string.Empty,
+                null,
                 this.DeterminePropertySource(isGlobalProperty, mayBeReserved, isEnvironmentVariable));
 
             return newProperty;
@@ -102,17 +109,18 @@ public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalPro
         /// </summary>
         public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped)
         {
-            P originalProperty = _wrapped.GetProperty(propertyElement.Name);
+            P? originalProperty = _wrapped.GetProperty(propertyElement.Name);
             P newProperty = _wrapped.SetProperty(propertyElement, evaluatedValueEscaped);
 
             this.TrackPropertyWrite(
                 originalProperty,
                 newProperty,
-                propertyElement.Location.LocationString,
+                propertyElement.Location,
                 PropertySource.Xml);
 
             return newProperty;
         }
+
         #endregion
 
         #region IEvaluatorData<> members that are forwarded directly to wrapped object.
@@ -137,7 +145,7 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
         public IItemDictionary<I> Items => _wrapped.Items;
         public List<ProjectItemElement> EvaluatedItemElements => _wrapped.EvaluatedItemElements;
         public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => _wrapped.EnvironmentVariablePropertiesDictionary;
-        public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext) => _wrapped.InitializeForEvaluation(toolsetProvider, evaluationContext);
+        public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext) => _wrapped.InitializeForEvaluation(toolsetProvider, evaluationContext, loggingContext);
         public void FinishEvaluation() => _wrapped.FinishEvaluation();
         public void AddItem(I item) => _wrapped.AddItem(item);
         public void AddItemIgnoringCondition(I item) => _wrapped.AddItemIgnoringCondition(item);
@@ -155,6 +163,16 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
         #endregion
 
         #region Private Methods...
+
+        private bool IsPropertyReadTrackingRequested
+            => IsEnvironmentVariableReadTrackingRequested ||
+               (_settings & PropertyTrackingSetting.UninitializedPropertyRead) ==
+               PropertyTrackingSetting.UninitializedPropertyRead;
+
+        private bool IsEnvironmentVariableReadTrackingRequested
+            => (_settings & PropertyTrackingSetting.EnvironmentVariableRead) ==
+               PropertyTrackingSetting.EnvironmentVariableRead;
+
         /// <summary>
         /// Logic containing what to do when a property is read.
         /// </summary>
@@ -172,7 +190,7 @@ private void TrackPropertyRead(string name, P property)
 
             // If a property matches the name of an environment variable, but has NOT been overwritten by a non-environment-variable property
             // track it as an environment variable read.
-            if (_wrapped.EnvironmentVariablePropertiesDictionary.Contains(name) && !_overwrittenEnvironmentVariables.Contains(name))
+            if (IsEnvironmentVariableReadTrackingRequested && _wrapped.EnvironmentVariablePropertiesDictionary.Contains(name) && !_overwrittenEnvironmentVariables.Contains(name))
             {
                 this.TrackEnvironmentVariableRead(name);
             }
@@ -220,16 +238,10 @@ private void TrackUninitializedPropertyRead(string name)
             _evaluationLoggingContext.LogBuildEvent(args);
         }
 
-        private void TrackPropertyWrite(P predecessor, P property, string location, PropertySource source)
+        private void TrackPropertyWrite(P? predecessor, P property, IElementLocation? location, PropertySource source)
         {
             string name = property.Name;
 
-            // If this property was an environment variable but no longer is, track it.
-            if (_wrapped.EnvironmentVariablePropertiesDictionary.Contains(name) && source != PropertySource.EnvironmentVariable)
-            {
-                _overwrittenEnvironmentVariables.Add(name);
-            }
-
             if (predecessor == null)
             {
                 // If this property had no previous value, then track an initial value.
@@ -238,7 +250,13 @@ private void TrackPropertyWrite(P predecessor, P property, string location, Prop
             else
             {
                 // There was a previous value, and it might have been changed. Track that.
-                TrackPropertyReassignment(predecessor, property, location);
+                TrackPropertyReassignment(predecessor, property, location?.LocationString);
+            }
+
+            // If this property was an environment variable but no longer is, track it.
+            if (IsEnvironmentVariableReadTrackingRequested && _wrapped.EnvironmentVariablePropertiesDictionary.Contains(name) && source != PropertySource.EnvironmentVariable)
+            {
+                _overwrittenEnvironmentVariables.Add(name);
             }
         }
 
@@ -270,14 +288,9 @@ private void TrackPropertyInitialValueSet(P property, PropertySource source)
         /// <param name="predecessor">The property's preceding state. Null if none.</param>
         /// <param name="property">The property's current state.</param>
         /// <param name="location">The location of this property's reassignment.</param>
-        private void TrackPropertyReassignment(P predecessor, P property, string location)
+        private void TrackPropertyReassignment(P? predecessor, P property, string? location)
         {
-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment)
-            {
-                return;
-            }
-
-            if (string.Equals(property.Name, "MSBuildAllProjects", StringComparison.OrdinalIgnoreCase))
+            if (MSBuildNameIgnoreCaseComparer.Default.Equals(property.Name, "MSBuildAllProjects"))
             {
                 // There's a huge perf cost to logging this and it increases the binlog size significantly.
                 // Meanwhile the usefulness of logging this is very low.
@@ -285,21 +298,37 @@ private void TrackPropertyReassignment(P predecessor, P property, string locatio
             }
 
             string newValue = property.EvaluatedValue;
-            string oldValue = predecessor.EvaluatedValue;
+            string? oldValue = predecessor?.EvaluatedValue;
             if (newValue == oldValue)
             {
                 return;
             }
 
-            var args = new PropertyReassignmentEventArgs(
-                property.Name,
-                oldValue,
-                newValue,
-                location,
-                message: null);
-            args.BuildEventContext = _evaluationLoggingContext.BuildEventContext;
-
-            _evaluationLoggingContext.LogBuildEvent(args);
+            // Either we want to specifically track property reassignments
+            // or we do not want to track nothing - in which case the prop reassignment is enabled by default.
+            if ((_settings & PropertyTrackingSetting.PropertyReassignment) == PropertyTrackingSetting.PropertyReassignment ||
+                (_settings == 0 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)))
+            {
+                var args = new PropertyReassignmentEventArgs(
+                        property.Name,
+                        oldValue,
+                        newValue,
+                        location,
+                        message: null)
+                    { BuildEventContext = _evaluationLoggingContext.BuildEventContext, };
+
+                _evaluationLoggingContext.LogBuildEvent(args);
+            }
+            else
+            {
+                _evaluationLoggingContext.LogComment(
+                    MessageImportance.Low,
+                    "PropertyReassignment",
+                    property.Name,
+                    newValue,
+                    oldValue,
+                    location);
+            }
         }
 
         /// <summary>
diff --git a/src/Build/Instance/IImmutableInstanceProvider.cs b/src/Build/Instance/IImmutableInstanceProvider.cs
index a862a12cf13..4b39fc66288 100644
--- a/src/Build/Instance/IImmutableInstanceProvider.cs
+++ b/src/Build/Instance/IImmutableInstanceProvider.cs
@@ -9,6 +9,19 @@ namespace Microsoft.Build.Execution
     /// <typeparam name="T">The Instance type.</typeparam>
     internal interface IImmutableInstanceProvider<T>
     {
-        T ImmutableInstance { get; set; }
+        /// <summary>
+        /// Gets the Immutable Instance.
+        /// </summary>
+        T ImmutableInstance { get; }
+
+        /// <summary>
+        /// If the ImmutableInstance has not already been set, then this
+        /// method sets the ImmutableInstance to the requested value.
+        /// An already set ImmutableInstance is never replaced.
+        /// </summary>
+        /// <param name="instance">An instance that will be set as the immutable instance, provided that
+        /// the immutable instance has not already been set.</param>
+        /// <returns>The immutable instance, which may or may not be the supplied <paramref name="instance"/>.</returns>
+        T GetOrSetImmutableInstance(T instance);
     }
 }
diff --git a/src/Build/Instance/IPropertyElementWithLocation.cs b/src/Build/Instance/IPropertyElementWithLocation.cs
new file mode 100644
index 00000000000..f77282d9590
--- /dev/null
+++ b/src/Build/Instance/IPropertyElementWithLocation.cs
@@ -0,0 +1,28 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Construction;
+
+namespace Microsoft.Build.Execution
+{
+    /// <summary>
+    /// Represents a xml node in a project file that defines a property.
+    /// </summary>
+    internal interface IPropertyElementWithLocation
+    {
+        /// <summary>
+        /// Name of the property.
+        /// </summary>
+        string Name { get; }
+
+        /// <summary>
+        /// Unevaluated value of the property.
+        /// </summary>
+        string Value { get; }
+
+        /// <summary>
+        /// Location of the property element within build scripts.
+        /// </summary>
+        ElementLocation Location { get; }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
index ae164108704..f15fd45f63e 100644
--- a/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
@@ -6,11 +6,8 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Data;
 using System.Runtime.Serialization;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Instance
@@ -18,20 +15,19 @@ namespace Microsoft.Build.Instance
     /// <summary>
     /// A specialized collection used when element data originates in an immutable Project.
     /// </summary>
-    internal sealed class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>
+    internal class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>
         where T : class, IKeyed
     {
-        private readonly IDictionary<string, TCached> _projectElements;
-        private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;
+        protected readonly IDictionary<string, TCached> _projectElements;
         private readonly ValuesCollection _values;
 
         public ImmutableElementCollectionConverter(
             IDictionary<string, TCached> projectElements,
-            IDictionary<(string, int, int), TCached> constrainedProjectElements)
+            IDictionary<(string, int, int), TCached> constrainedProjectElements,
+            Func<TCached, T> convertElement)
         {
             _projectElements = projectElements;
-            _constrainedProjectElements = constrainedProjectElements;
-            _values = new ValuesCollection(_projectElements, _constrainedProjectElements);
+            _values = new ValuesCollection(_projectElements, constrainedProjectElements, convertElement);
         }
 
         public T this[string key]
@@ -110,13 +106,16 @@ private sealed class ValuesCollection : ICollection<T>
         {
             private readonly IDictionary<string, TCached> _projectElements;
             private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;
+            private readonly Func<TCached, T> _getElementInstance;
 
             public ValuesCollection(
                 IDictionary<string, TCached> projectElements,
-                IDictionary<(string, int, int), TCached> constrainedProjectElements)
+                IDictionary<(string, int, int), TCached> constrainedProjectElements,
+                Func<TCached, T> getElementInstance)
             {
                 _projectElements = projectElements;
                 _constrainedProjectElements = constrainedProjectElements;
+                _getElementInstance = getElementInstance;
             }
 
             public int Count => _projectElements.Count;
@@ -155,7 +154,7 @@ public void CopyTo(T[] array, int arrayIndex, int count)
                 int endIndex = arrayIndex + count;
                 foreach (var item in _projectElements.Values)
                 {
-                    array[index] = GetElementInstance(item);
+                    array[index] = _getElementInstance(item);
                     ++index;
                     if (index >= endIndex)
                     {
@@ -171,7 +170,7 @@ public void CopyTo(KeyValuePair<string, T>[] array, int arrayIndex)
                 int index = arrayIndex;
                 foreach (var item in _projectElements.Values)
                 {
-                    var itemInstance = GetElementInstance(item);
+                    var itemInstance = _getElementInstance(item);
                     array[index] = new KeyValuePair<string, T>(itemInstance.Key, itemInstance);
                     ++index;
                 }
@@ -181,7 +180,7 @@ public IEnumerator<T> GetEnumerator()
             {
                 foreach (var item in _projectElements.Values)
                 {
-                    yield return GetElementInstance(item);
+                    yield return _getElementInstance(item);
                 }
             }
 
@@ -189,7 +188,7 @@ public IEnumerator<KeyValuePair<string, T>> GetKvpEnumerator()
             {
                 foreach (var kvp in _projectElements)
                 {
-                    T instance = GetElementInstance(kvp.Value);
+                    T instance = _getElementInstance(kvp.Value);
                     yield return new KeyValuePair<string, T>(kvp.Key, instance);
                 }
             }
@@ -200,7 +199,7 @@ IEnumerator IEnumerable.GetEnumerator()
             {
                 foreach (var item in _projectElements.Values)
                 {
-                    yield return GetElementInstance(item);
+                    yield return _getElementInstance(item);
                 }
             }
 
@@ -208,7 +207,7 @@ public T Get(string key)
             {
                 if (_projectElements.TryGetValue(key, out TCached element))
                 {
-                    return GetElementInstance(element);
+                    return _getElementInstance(element);
                 }
 
                 return null;
@@ -216,9 +215,14 @@ public T Get(string key)
 
             public T Get(string keyString, int startIndex, int length)
             {
+                if (_constrainedProjectElements == null)
+                {
+                    return Get(keyString);
+                }
+
                 if (_constrainedProjectElements.TryGetValue((keyString, startIndex, length), out TCached element))
                 {
-                    return GetElementInstance(element);
+                    return _getElementInstance(element);
                 }
 
                 return null;
@@ -232,19 +236,9 @@ public bool TryGetValue(string key, out T value)
                     return false;
                 }
 
-                value = GetElementInstance(element);
+                value = _getElementInstance(element);
                 return value != null;
             }
-
-            private T GetElementInstance(TCached element)
-            {
-                if (element is IImmutableInstanceProvider<T> instanceProvider)
-                {
-                    return instanceProvider.ImmutableInstance;
-                }
-
-                return null;
-            }
         }
     }
 }
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs
new file mode 100644
index 00000000000..b5579adf088
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs
@@ -0,0 +1,251 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.CodeDom;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Runtime.Serialization;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Shared;
+
+#nullable disable
+
+namespace Microsoft.Build.Instance.ImmutableProjectCollections
+{
+    /// <summary>
+    /// A collection representing the set of Global ProjectPropertyInstance objects.
+    /// </summary>
+    /// <remarks>This class is used only when the containing ProjectInstance originates from an
+    /// immutable linked project source. It's specialized in order to reduce required allocations
+    /// by instead relying on the linked project source's collection of global properties
+    /// (the IDictionary _globalProperties) and the ProjectInstance's collection of all
+    /// properties (the PropertyDictionary _allProperties). When a property is requested,
+    /// _globalProperties is checked to determine whether the named property is actually
+    /// a global property and, if it is, then instance is retrieved from _allProperties.
+    /// </remarks>
+    internal class ImmutableGlobalPropertiesCollectionConverter : IRetrievableEntryHashSet<ProjectPropertyInstance>
+    {
+        private readonly IDictionary<string, string> _globalProperties;
+        private readonly PropertyDictionary<ProjectPropertyInstance> _allProperties;
+        private readonly ValuesCollection _values;
+
+        public ImmutableGlobalPropertiesCollectionConverter(
+            IDictionary<string, string> globalProperties,
+            PropertyDictionary<ProjectPropertyInstance> allProperties)
+        {
+            _globalProperties = globalProperties;
+            _allProperties = allProperties;
+            _values = new ValuesCollection(this);
+        }
+
+        public ProjectPropertyInstance this[string key]
+        {
+            set => throw new NotSupportedException();
+            get
+            {
+                if (_globalProperties.ContainsKey(key))
+                {
+                    return _allProperties[key];
+                }
+
+                return null;
+            }
+        }
+
+        public int Count => _globalProperties.Count;
+
+        public bool IsReadOnly => true;
+
+        public ICollection<string> Keys => _globalProperties.Keys;
+
+        public ICollection<ProjectPropertyInstance> Values => _values;
+
+        public void Add(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+        public void Add(string key, ProjectPropertyInstance value) => throw new NotSupportedException();
+
+        public void Add(KeyValuePair<string, ProjectPropertyInstance> item) => throw new NotSupportedException();
+
+        public void Clear() => throw new NotSupportedException();
+
+        public bool Contains(ProjectPropertyInstance item) => _values.Contains(item);
+
+        public bool Contains(KeyValuePair<string, ProjectPropertyInstance> itemKvp) => _values.Contains(itemKvp.Value);
+
+        public bool ContainsKey(string key) => _globalProperties.ContainsKey(key);
+
+        public void CopyTo(ProjectPropertyInstance[] array) => _values.CopyTo(array, arrayIndex: 0);
+
+        public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);
+
+        public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex, int count) => _values.CopyTo(array, arrayIndex, count);
+
+        public void CopyTo(KeyValuePair<string, ProjectPropertyInstance>[] array, int arrayIndex)
+        {
+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _globalProperties.Count);
+
+            int currentIndex = arrayIndex;
+            foreach (var itemKey in _globalProperties.Keys)
+            {
+                ProjectPropertyInstance instance = _allProperties[itemKey];
+                if (instance != null)
+                {
+                    array[currentIndex] = new KeyValuePair<string, ProjectPropertyInstance>(itemKey, instance);
+                    ++currentIndex;
+                }
+            }
+        }
+
+        public ProjectPropertyInstance Get(string key)
+        {
+            return this[key];
+        }
+
+        public ProjectPropertyInstance Get(string key, int index, int length)
+        {
+            // The PropertyDictionary containing all of the properties can efficiently
+            // look up the requested property while honoring the specific index and length
+            // constraints. We then just have to verify that it's one of the global properties.
+            ProjectPropertyInstance actualProperty = _allProperties.Get(key, index, length);
+            if (actualProperty != null && _globalProperties.ContainsKey(actualProperty.Name))
+            {
+                return actualProperty;
+            }
+
+            return null;
+        }
+
+        public IEnumerator<ProjectPropertyInstance> GetEnumerator() => _values.GetEnumerator();
+
+        public void GetObjectData(SerializationInfo info, StreamingContext context) => throw new NotSupportedException();
+
+        public void OnDeserialization(object sender) => throw new NotSupportedException();
+
+        public bool Remove(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+        public bool Remove(string key) => throw new NotSupportedException();
+
+        public bool Remove(KeyValuePair<string, ProjectPropertyInstance> item) => throw new NotSupportedException();
+
+        public void TrimExcess()
+        {
+        }
+
+        public bool TryGetValue(string key, out ProjectPropertyInstance value)
+        {
+            ProjectPropertyInstance instance = Get(key);
+            value = instance;
+            return instance != null;
+        }
+
+        public void UnionWith(IEnumerable<ProjectPropertyInstance> other) => throw new NotSupportedException();
+
+        IEnumerator<KeyValuePair<string, ProjectPropertyInstance>> IEnumerable<KeyValuePair<string, ProjectPropertyInstance>>.GetEnumerator()
+        {
+            foreach (var itemKey in _globalProperties.Keys)
+            {
+                ProjectPropertyInstance instance = _allProperties[itemKey];
+                if (instance != null)
+                {
+                    yield return new KeyValuePair<string, ProjectPropertyInstance>(itemKey, instance);
+                }
+            }
+        }
+
+        IEnumerator IEnumerable.GetEnumerator() => _values.GetEnumerator();
+
+        private class ValuesCollection : ICollection<ProjectPropertyInstance>
+        {
+            private readonly ImmutableGlobalPropertiesCollectionConverter _parent;
+
+            public ValuesCollection(ImmutableGlobalPropertiesCollectionConverter parent)
+            {
+                _parent = parent;
+            }
+
+            public int Count => _parent._globalProperties.Count;
+
+            public bool IsReadOnly => true;
+
+            public void Add(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+            public void Clear() => throw new NotSupportedException();
+
+            public bool Remove(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+            public bool Contains(ProjectPropertyInstance item)
+            {
+                if (!_parent._globalProperties.ContainsKey(item.Name))
+                {
+                    return false;
+                }
+
+                ProjectPropertyInstance actualInstance = _parent._allProperties[item.Name];
+
+                if (actualInstance == null)
+                {
+                    return false;
+                }
+
+                return actualInstance.Equals(item);
+            }
+
+            public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex)
+            {
+                CopyTo(array, arrayIndex, _parent._globalProperties.Count);
+            }
+
+            public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex, int count)
+            {
+                ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _parent._globalProperties.Count);
+
+                int currentIndex = arrayIndex;
+                int currentCount = 0;
+                foreach (var itemKey in _parent._globalProperties.Keys)
+                {
+                    if (currentCount >= count)
+                    {
+                        return;
+                    }
+
+                    ProjectPropertyInstance instance = _parent._allProperties[itemKey];
+                    if (instance != null)
+                    {
+                        array[currentIndex] = instance;
+                        ++currentIndex;
+                        ++currentCount;
+                    }
+                }
+            }
+
+            public IEnumerator<ProjectPropertyInstance> GetEnumerator()
+            {
+                foreach (var itemKey in _parent._globalProperties.Keys)
+                {
+                    ProjectPropertyInstance instance = _parent._allProperties[itemKey];
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+
+            IEnumerator IEnumerable.GetEnumerator()
+            {
+                foreach (var itemKey in _parent._globalProperties.Keys)
+                {
+                    ProjectPropertyInstance instance = _parent._allProperties[itemKey];
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs
new file mode 100644
index 00000000000..1a1d499b0aa
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs
@@ -0,0 +1,182 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Instance
+{
+    internal class ImmutableItemDefinitionsListConverter<TCached, T> : IList<T>
+        where T : IKeyed
+        where TCached : IKeyed
+    {
+        private readonly IList<TCached>? _itemList;
+        private readonly TCached? _itemTypeDefinition;
+        private readonly Func<TCached, T> _getInstance;
+
+        public ImmutableItemDefinitionsListConverter(
+            IList<TCached>? itemList,
+            TCached? itemTypeDefinition,
+            Func<TCached, T> getInstance)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(getInstance, nameof(getInstance));
+
+            _itemList = itemList;
+            _itemTypeDefinition = itemTypeDefinition;
+            _getInstance = getInstance;
+        }
+
+        public T this[int index]
+        {
+            set => throw new NotSupportedException();
+            get
+            {
+                if (_itemList == null)
+                {
+                    if (index != 0 || _itemTypeDefinition == null)
+                    {
+                        throw new IndexOutOfRangeException();
+                    }
+
+                    return _getInstance(_itemTypeDefinition);
+                }
+
+                if (index > _itemList.Count)
+                {
+                    throw new IndexOutOfRangeException();
+                }
+
+                if (index == _itemList.Count)
+                {
+                    if (_itemTypeDefinition == null)
+                    {
+                        throw new IndexOutOfRangeException();
+                    }
+
+                    return _getInstance(_itemTypeDefinition);
+                }
+
+                return _getInstance(_itemList[index]);
+            }
+        }
+
+        public int Count => (_itemList == null ? 0 : _itemList.Count) + (_itemTypeDefinition == null ? 0 : 1);
+
+        public bool IsReadOnly => true;
+
+        public void Add(T item) => throw new NotSupportedException();
+
+        public void Clear() => throw new NotSupportedException();
+
+        public void Insert(int index, T item) => throw new NotSupportedException();
+
+        public bool Remove(T item) => throw new NotSupportedException();
+
+        public void RemoveAt(int index) => throw new NotSupportedException();
+
+        public bool Contains(T item)
+        {
+            return IndexOf(item) >= 0;
+        }
+
+        public void CopyTo(T[] array, int arrayIndex)
+        {
+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), Count);
+
+            int currentIndex = arrayIndex;
+            void PutItemIntoArray(TCached item)
+            {
+                array[currentIndex] = _getInstance(item);
+                ++currentIndex;
+            }
+
+            if (_itemList != null)
+            {
+                foreach (var item in _itemList)
+                {
+                    PutItemIntoArray(item);
+                }
+            }
+
+            if (_itemTypeDefinition != null)
+            {
+                PutItemIntoArray(_itemTypeDefinition);
+            }
+        }
+
+        public IEnumerator<T> GetEnumerator() => GetEnumeratorImpl();
+
+        public int IndexOf(T item)
+        {
+            int currentIndex = 0;
+            if (_itemList != null)
+            {
+                foreach (var cachedItem in _itemList)
+                {
+                    if (IsMatchingItem(cachedItem, item))
+                    {
+                        return currentIndex;
+                    }
+
+                    ++currentIndex;
+                }
+            }
+
+            if (_itemTypeDefinition != null)
+            {
+                if (IsMatchingItem(_itemTypeDefinition, item))
+                {
+                    return currentIndex;
+                }
+            }
+
+            return -1;
+        }
+
+        IEnumerator IEnumerable.GetEnumerator() => GetEnumeratorImpl();
+
+        private bool IsMatchingItem(TCached cachedItem, T item)
+        {
+            if (MSBuildNameIgnoreCaseComparer.Default.Equals(cachedItem.Key, item.Key))
+            {
+                T? foundItem = _getInstance(cachedItem);
+                if (foundItem is not null && foundItem.Equals(item))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        private IEnumerator<T> GetEnumeratorImpl()
+        {
+            if (_itemList != null)
+            {
+                foreach (var item in _itemList)
+                {
+                    T? instance = _getInstance(item);
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+
+            if (_itemTypeDefinition != null)
+            {
+                T? instance = _getInstance(_itemTypeDefinition);
+                if (instance != null)
+                {
+                    yield return instance;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
index 74919a57b97..de2d06522ae 100644
--- a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
@@ -19,29 +19,28 @@ namespace Microsoft.Build.Instance
     /// </summary>
     internal sealed class ImmutableItemDictionary<TCached, T> : IItemDictionary<T>
         where T : class, IKeyed, IItem
+        where TCached : IKeyed, IItem
     {
         private readonly IDictionary<string, ICollection<TCached>> _itemsByType;
-        private readonly ICollection<T> _allItems;
-
-        public ImmutableItemDictionary(IDictionary<string, ICollection<TCached>> itemsByType, ICollection<TCached> allItems)
+        private readonly ICollection<TCached> _allCachedItems;
+        private readonly Func<TCached, T?> _getInstance;
+        private readonly Func<T, string?> _getItemType;
+
+        public ImmutableItemDictionary(
+            ICollection<TCached> allItems,
+            IDictionary<string, ICollection<TCached>> itemsByType,
+            Func<TCached, T?> getInstance,
+            Func<T, string?> getItemType)
         {
-            _itemsByType = itemsByType ?? throw new ArgumentNullException(nameof(itemsByType));
-
             if (allItems == null)
             {
                 throw new ArgumentNullException(nameof(allItems));
             }
 
-            var convertedItems = new HashSet<T>(allItems.Count);
-            foreach (var item in allItems)
-            {
-                T? instance = GetInstance(item);
-                if (instance != null)
-                {
-                    convertedItems.Add(instance);
-                }
-            }
-            _allItems = new ReadOnlyCollection<T>(convertedItems);
+            _allCachedItems = allItems;
+            _itemsByType = itemsByType ?? throw new ArgumentNullException(nameof(itemsByType));
+            _getInstance = getInstance;
+            _getItemType = getItemType;
         }
 
         /// <inheritdoc />
@@ -54,12 +53,12 @@ public ICollection<T> this[string itemType]
                     return Array.Empty<T>();
                 }
 
-                return new ListConverter(itemType, _allItems, list);
+                return new ListConverter(itemType, list, _getInstance);
             }
         }
 
         /// <inheritdoc />
-        public int Count => _allItems.Count;
+        public int Count => _allCachedItems.Count;
 
         /// <inheritdoc />
         public ICollection<string> ItemTypes => _itemsByType.Keys;
@@ -77,7 +76,22 @@ public ICollection<T> this[string itemType]
         public void Clear() => throw new NotSupportedException();
 
         /// <inheritdoc />
-        public bool Contains(T projectItem) => _allItems.Contains(projectItem);
+        public bool Contains(T projectItem)
+        {
+            if (projectItem == null)
+            {
+                return false;
+            }
+
+            string? itemType = _getItemType(projectItem);
+            if (itemType == null)
+            {
+                return false;
+            }
+
+            ICollection<T> items = GetItems(itemType);
+            return items.Contains(projectItem);
+        }
 
         /// <inheritdoc />
         public void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)
@@ -90,31 +104,55 @@ public void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallbac
                     continue;
                 }
 
-                itemTypeCallback(kvp.Key, new ListConverter(kvp.Key, _allItems, kvp.Value));
+                itemTypeCallback(kvp.Key, new ListConverter(kvp.Key, kvp.Value, _getInstance));
             }
         }
 
         /// <inheritdoc />
         public IEnumerable<TResult> GetCopyOnReadEnumerable<TResult>(Func<T, TResult> selector)
         {
-            foreach (var item in _allItems)
+            foreach (var cachedItem in _allCachedItems)
             {
-                yield return selector(item);
+                T? item = _getInstance(cachedItem);
+                if (item is not null)
+                {
+                    yield return selector(item);
+                }
             }
         }
 
         /// <inheritdoc />
-        public IEnumerator<T> GetEnumerator() => _allItems.GetEnumerator();
+        public IEnumerator<T> GetEnumerator()
+        {
+            foreach (var cachedItem in _allCachedItems)
+            {
+                T? item = _getInstance(cachedItem);
+                if (item is not null)
+                {
+                    yield return item;
+                }
+            }
+        }
 
         /// <inheritdoc />
-        IEnumerator IEnumerable.GetEnumerator() => _allItems.GetEnumerator();
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            foreach (var cachedItem in _allCachedItems)
+            {
+                T? item = _getInstance(cachedItem);
+                if (item is not null)
+                {
+                    yield return item;
+                }
+            }
+        }
 
         /// <inheritdoc />
         public ICollection<T> GetItems(string itemType)
         {
             if (_itemsByType.TryGetValue(itemType, out ICollection<TCached>? items))
             {
-                return new ListConverter(itemType, _allItems, items);
+                return new ListConverter(itemType, items, _getInstance);
             }
 
             return Array.Empty<T>();
@@ -138,27 +176,17 @@ public ICollection<T> GetItems(string itemType)
         /// <inheritdoc />
         public void Replace(T existingItem, T newItem) => throw new NotSupportedException();
 
-        private static T? GetInstance(TCached item)
-        {
-            if (item is IImmutableInstanceProvider<T> instanceProvider)
-            {
-                return instanceProvider.ImmutableInstance;
-            }
-
-            return null;
-        }
-
         private sealed class ListConverter : ICollection<T>
         {
             private readonly string _itemType;
-            private readonly ICollection<T> _allItems;
             private readonly ICollection<TCached> _list;
+            private readonly Func<TCached, T?> _getInstance;
 
-            public ListConverter(string itemType, ICollection<T> allItems, ICollection<TCached> list)
+            public ListConverter(string itemType, ICollection<TCached> list, Func<TCached, T?> getInstance)
             {
                 _itemType = itemType;
-                _allItems = allItems;
                 _list = list;
+                _getInstance = getInstance;
             }
 
             public int Count => _list.Count;
@@ -173,8 +201,20 @@ public ListConverter(string itemType, ICollection<T> allItems, ICollection<TCach
 
             public bool Contains(T item)
             {
-                return MSBuildNameIgnoreCaseComparer.Default.Equals(item.Key, _itemType) &&
-                       _allItems.Contains(item);
+                return _list.Any(
+                    cachedItem =>
+                    {
+                        if (MSBuildNameIgnoreCaseComparer.Default.Equals(cachedItem.EvaluatedIncludeEscaped, item.EvaluatedIncludeEscaped))
+                        {
+                            T? foundItem = _getInstance(cachedItem);
+                            if (foundItem is not null && foundItem.Equals(item))
+                            {
+                                return true;
+                            }
+                        }
+
+                        return false;
+                    });
             }
 
             public void CopyTo(T[] array, int arrayIndex)
@@ -184,7 +224,7 @@ public void CopyTo(T[] array, int arrayIndex)
                 int currentIndex = arrayIndex;
                 foreach (var item in _list)
                 {
-                    T? instance = GetInstance(item);
+                    T? instance = _getInstance(item);
                     if (instance != null)
                     {
                         array[currentIndex] = instance;
@@ -197,7 +237,7 @@ public IEnumerator<T> GetEnumerator()
             {
                 foreach (var item in _list)
                 {
-                    T? instance = GetInstance(item);
+                    T? instance = _getInstance(item);
                     if (instance != null)
                     {
                         yield return instance;
@@ -209,7 +249,7 @@ IEnumerator IEnumerable.GetEnumerator()
             {
                 foreach (var item in _list)
                 {
-                    T? instance = GetInstance(item);
+                    T? instance = _getInstance(item);
                     if (instance != null)
                     {
                         yield return instance;
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs
new file mode 100644
index 00000000000..1b11db2341a
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs
@@ -0,0 +1,43 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
+
+namespace Microsoft.Build.Instance.ImmutableProjectCollections
+{
+    internal class ImmutableLinkedMultiDictionaryConverter<K, VCached, V> : IMultiDictionary<K, V>
+        where K : class
+        where V : class
+        where VCached : class
+    {
+        private readonly Func<K, IEnumerable<VCached>> _getCachedValues;
+        private readonly Func<VCached, V> _getInstance;
+
+        public ImmutableLinkedMultiDictionaryConverter(Func<K, IEnumerable<VCached>> getCachedValues, Func<VCached, V> getInstance)
+        {
+            _getCachedValues = getCachedValues;
+            _getInstance = getInstance;
+        }
+
+        public IEnumerable<V> this[K key]
+        {
+            get
+            {
+                IEnumerable<VCached> cachedValues = _getCachedValues(key);
+                if (cachedValues != null)
+                {
+                    foreach (var cachedValue in cachedValues)
+                    {
+                        yield return _getInstance(cachedValue);
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs
new file mode 100644
index 00000000000..27610c71543
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs
@@ -0,0 +1,72 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Collections;
+
+namespace Microsoft.Build.Instance
+{
+    internal class ImmutablePropertyCollectionConverter<TCached, T> : ImmutableElementCollectionConverter<TCached, T>, ICopyOnWritePropertyDictionary<T>
+        where T : class, IKeyed, IValued, IEquatable<T>, IImmutable
+        where TCached : class, IValued, IEquatable<TCached>
+    {
+        public ImmutablePropertyCollectionConverter(IDictionary<string, TCached> properties, Func<TCached, T> convertProperty)
+            : base(properties, constrainedProjectElements: null, convertProperty)
+        {
+        }
+
+        public bool Contains(string name) => ContainsKey(name);
+
+        public string? GetEscapedValue(string name)
+        {
+            if (_projectElements.TryGetValue(name, out TCached? value))
+            {
+                return value?.EscapedValue;
+            }
+
+            return null;
+        }
+
+        public ICopyOnWritePropertyDictionary<T> DeepClone() => this;
+
+        public void ImportProperties(IEnumerable<T> other) => throw new NotSupportedException();
+
+        public void Set(T projectProperty) => throw new NotSupportedException();
+
+        public bool Equals(ICopyOnWritePropertyDictionary<T>? other)
+        {
+            if (other == null || Count != other.Count)
+            {
+                return false;
+            }
+
+            if (other is ImmutablePropertyCollectionConverter<TCached, T> otherImmutableDict)
+            {
+                // When comparing to another CollectionConverter we compare the TCached values
+                // in order to avoid causing the instantiation of each T instance.
+                foreach (var propKvp in _projectElements)
+                {
+                    if (!otherImmutableDict._projectElements.TryGetValue(propKvp.Key, out TCached? otherProperty) ||
+                        !EqualityComparer<TCached>.Default.Equals(propKvp.Value, otherProperty))
+                    {
+                        return false;
+                    }
+                }
+            }
+            else
+            {
+                foreach (T thisProp in Values)
+                {
+                    if (!other.TryGetValue(thisProp.Key, out T? thatProp) ||
+                        !EqualityComparer<T>.Default.Equals(thisProp, thatProp))
+                    {
+                        return false;
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableStringValuedListConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableStringValuedListConverter.cs
new file mode 100644
index 00000000000..89e12f7c0a1
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableStringValuedListConverter.cs
@@ -0,0 +1,99 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Instance
+{
+    internal class ImmutableStringValuedListConverter<T> : IList<string>, IReadOnlyList<string>
+    {
+        private readonly IList<T> _itemList;
+        private readonly Func<T, string> _getStringValue;
+
+        public ImmutableStringValuedListConverter(IList<T> itemList, Func<T, string> getStringValue)
+        {
+            _itemList = itemList;
+            _getStringValue = getStringValue;
+        }
+
+        public string this[int index]
+        {
+            set => throw new NotSupportedException();
+            get => _getStringValue(_itemList[index]);
+        }
+
+        public int Count => _itemList.Count;
+
+        public bool IsReadOnly => true;
+
+        public void Add(string item) => throw new NotSupportedException();
+
+        public void Clear() => throw new NotSupportedException();
+
+        public void Insert(int index, string item) => throw new NotSupportedException();
+
+        public bool Remove(string item) => throw new NotSupportedException();
+
+        public void RemoveAt(int index) => throw new NotSupportedException();
+
+        public bool Contains(string item)
+        {
+            return IndexOf(item) >= 0;
+        }
+
+        public void CopyTo(string[] array, int arrayIndex)
+        {
+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _itemList.Count);
+
+            int currentIndex = arrayIndex;
+            foreach (var item in _itemList)
+            {
+                array[currentIndex] = _getStringValue(item);
+                ++currentIndex;
+            }
+        }
+
+        public IEnumerator<string> GetEnumerator()
+        {
+            foreach (var item in _itemList)
+            {
+                string? stringValue = _getStringValue(item);
+                if (stringValue != null)
+                {
+                    yield return stringValue;
+                }
+            }
+        }
+
+        public int IndexOf(string item)
+        {
+            for (int i = 0; i < _itemList.Count; ++i)
+            {
+                T cachedItem = _itemList[i];
+                string stringValue = _getStringValue(cachedItem);
+                if (MSBuildNameIgnoreCaseComparer.Default.Equals(stringValue, item))
+                {
+                    return i;
+                }
+            }
+
+            return -1;
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            foreach (var item in _itemList)
+            {
+                string? instance = _getStringValue(item);
+                if (instance != null)
+                {
+                    yield return instance;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableValuedElementCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableValuedElementCollectionConverter.cs
new file mode 100644
index 00000000000..5477ba57c28
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableValuedElementCollectionConverter.cs
@@ -0,0 +1,37 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Collections;
+
+namespace Microsoft.Build.Instance
+{
+    /// <inheritdoc />
+    internal sealed class ImmutableValuedElementCollectionConverter<TCached, T> : ImmutableElementCollectionConverter<TCached, T>, IRetrievableValuedEntryHashSet<T>
+        where T : class, IKeyed, IValued
+        where TCached : IValued
+    {
+        public ImmutableValuedElementCollectionConverter(
+            IDictionary<string, TCached> projectElements,
+            IDictionary<(string, int, int), TCached> constrainedProjectElements,
+            Func<TCached, T> convertElement)
+            : base(projectElements, constrainedProjectElements, convertElement)
+        {
+        }
+
+        public bool TryGetEscapedValue(string key, out string escapedValue)
+        {
+            if (_projectElements.TryGetValue(key, out TCached value) && value != null)
+            {
+                escapedValue = value.EscapedValue;
+                return true;
+            }
+
+            escapedValue = null;
+            return false;
+        }
+    }
+}
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 32a408a5ca4..1c3be29274f 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -14,6 +14,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.Experimental.BuildCheck.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Definition;
@@ -22,6 +23,7 @@
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Instance;
+using Microsoft.Build.Instance.ImmutableProjectCollections;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -92,9 +94,9 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
 
         private List<string> _initialTargets;
 
-        private List<string> _importPaths;
+        private IList<string> _importPaths;
 
-        private List<string> _importPathsIncludingDuplicates;
+        private IList<string> _importPathsIncludingDuplicates;
 
         /// <summary>
         /// The global properties evaluation occurred with.
@@ -131,7 +133,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         /// <summary>
         /// Items organized by evaluatedInclude value
         /// </summary>
-        private MultiDictionary<string, ProjectItemInstance> _itemsByEvaluatedInclude;
+        private IMultiDictionary<string, ProjectItemInstance> _itemsByEvaluatedInclude;
 
         /// <summary>
         /// The project's root directory, for evaluation of relative paths and
@@ -434,41 +436,41 @@ private ProjectInstance(Project linkedProject, bool fastItemLookupNeeded)
             EvaluationId = linkedProject.EvaluationCounter;
 
             // ProjectProperties
-            InitializeImmutableProjectPropertyInstances(linkedProject.Properties);
-            var projectPropertiesConverter = GetImmutableElementCollectionConverter<ProjectProperty, ProjectPropertyInstance>(linkedProject.Properties);
-            _properties = new PropertyDictionary<ProjectPropertyInstance>(projectPropertiesConverter);
+            _properties = GetImmutablePropertyDictionaryFromImmutableProject(linkedProject);
 
             // ProjectItemDefinitions
-            InitializeImmutableProjectItemDefinitionInstances(linkedProject.ItemDefinitions);
-            _itemDefinitions = GetImmutableElementCollectionConverter<ProjectItemDefinition, ProjectItemDefinitionInstance>(linkedProject.ItemDefinitions);
+            _itemDefinitions = GetImmutableItemDefinitionsHashSetFromImmutableProject(linkedProject);
 
             // ProjectItems
-            InitializeImmutableProjectItemInstances(linkedProject.Items);
-            var itemsByType = linkedProject.Items as IDictionary<string, ICollection<ProjectItem>>;
-            _items = new ImmutableItemDictionary<ProjectItem, ProjectItemInstance>(itemsByType, linkedProject.Items);
+            _items = GetImmutableItemsDictionaryFromImmutableProject(linkedProject, this);
 
             // ItemsByEvaluatedInclude
             if (fastItemLookupNeeded)
             {
-                _itemsByEvaluatedInclude = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
-                foreach (var item in linkedProject.Items)
-                {
-                    if (item is IImmutableInstanceProvider<ProjectItemInstance> immutableInstanceProvider)
-                    {
-                        _itemsByEvaluatedInclude.Add(item.EvaluatedInclude, immutableInstanceProvider.ImmutableInstance);
-                    }
-                }
+                _itemsByEvaluatedInclude = new ImmutableLinkedMultiDictionaryConverter<string, ProjectItem, ProjectItemInstance>(
+                                                linkedProject.GetItemsByEvaluatedInclude,
+                                                item => ConvertCachedProjectItemToInstance(linkedProject, this, item));
             }
 
-            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(linkedProject.GlobalPropertiesCount);
-            foreach (var property in linkedProject.GlobalPropertiesEnumerable)
-            {
-                _globalProperties.Set(ProjectPropertyInstance.Create(property.Key, property.Value));
-            }
+            // GlobalProperties
+            var globalPropertiesRetrievableHashSet = new ImmutableGlobalPropertiesCollectionConverter(linkedProject.GlobalProperties, _properties);
+            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(globalPropertiesRetrievableHashSet);
+
+            // EnvironmentVariableProperties
+            _environmentVariableProperties = linkedProject.ProjectCollection.SharedReadOnlyEnvironmentProperties;
 
-            CreateEnvironmentVariablePropertiesSnapshot(linkedProject.ProjectCollection.EnvironmentProperties);
-            CreateTargetsSnapshot(linkedProject.Targets, null, null, null, null);
-            CreateImportsSnapshot(linkedProject.Imports, linkedProject.ImportsIncludingDuplicates);
+            // Targets
+            _targets = linkedProject.Targets;
+            InitializeTargetsData(null, null, null, null);
+
+            // Imports
+            var importsListConverter = new ImmutableStringValuedListConverter<ResolvedImport>(linkedProject.Imports, GetImportFullPath);
+            _importPaths = importsListConverter;
+            ImportPaths = importsListConverter;
+
+            importsListConverter = new ImmutableStringValuedListConverter<ResolvedImport>(linkedProject.ImportsIncludingDuplicates, GetImportFullPath);
+            _importPathsIncludingDuplicates = importsListConverter;
+            ImportPathsIncludingDuplicates = importsListConverter;
 
             Toolset = linkedProject.ProjectCollection.GetToolset(linkedProject.ToolsVersion);
             SubToolsetVersion = linkedProject.SubToolsetVersion;
@@ -549,9 +551,9 @@ internal ProjectInstance(string projectFile, ProjectInstance projectToInheritFro
             this.TaskRegistry = projectToInheritFrom.TaskRegistry;
             _isImmutable = projectToInheritFrom._isImmutable;
             _importPaths = projectToInheritFrom._importPaths;
-            ImportPaths = _importPaths.AsReadOnly();
+            ImportPaths = new ObjectModel.ReadOnlyCollection<string>(_importPaths);
             _importPathsIncludingDuplicates = projectToInheritFrom._importPathsIncludingDuplicates;
-            ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+            ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates);
 
             this.EvaluatedItemElements = new List<ProjectItemElement>();
 
@@ -753,9 +755,9 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                 _itemDefinitions = that._itemDefinitions;
                 _explicitToolsVersionSpecified = that._explicitToolsVersionSpecified;
                 _importPaths = that._importPaths;
-                ImportPaths = _importPaths.AsReadOnly();
+                ImportPaths = new ObjectModel.ReadOnlyCollection<string>(_importPaths);
                 _importPathsIncludingDuplicates = that._importPathsIncludingDuplicates;
-                ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+                ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates);
 
                 this.EvaluatedItemElements = that.EvaluatedItemElements;
 
@@ -898,9 +900,145 @@ public static ProjectInstance FromImmutableProjectSource(Project project, Projec
             return new ProjectInstance(project, fastItemLookupNeeded);
         }
 
-        private static ImmutableElementCollectionConverter<TCached, T> GetImmutableElementCollectionConverter<TCached, T>(
-            ICollection<TCached> elementsCollection)
-            where T : class, IKeyed
+        private static IRetrievableEntryHashSet<ProjectItemDefinitionInstance> GetImmutableItemDefinitionsHashSetFromImmutableProject(Project linkedProject)
+        {
+            IDictionary<string, ProjectItemDefinition> linkedProjectItemDefinitions = linkedProject.ItemDefinitions;
+            VerifyCollectionImplementsRequiredDictionaryInterfaces(
+                linkedProjectItemDefinitions,
+                out IDictionary<string, ProjectItemDefinition> elementsDictionary,
+                out IDictionary<(string, int, int), ProjectItemDefinition> constrainedElementsDictionary);
+
+            var hashSet = new ImmutableElementCollectionConverter<ProjectItemDefinition, ProjectItemDefinitionInstance>(
+                                elementsDictionary,
+                                constrainedElementsDictionary,
+                                ConvertCachedItemDefinitionToInstance);
+
+            return hashSet;
+        }
+
+        private static ImmutableItemDictionary<ProjectItem, ProjectItemInstance> GetImmutableItemsDictionaryFromImmutableProject(
+            Project linkedProject,
+            ProjectInstance owningProjectInstance)
+        {
+            var itemsByType = linkedProject.Items as IDictionary<string, ICollection<ProjectItem>>;
+            if (itemsByType == null)
+            {
+                throw new ArgumentException(nameof(linkedProject));
+            }
+
+            Func<ProjectItem, ProjectItemInstance> convertCachedItemToInstance =
+                projectItem => ConvertCachedProjectItemToInstance(linkedProject, owningProjectInstance, projectItem);
+
+            var itemDictionary = new ImmutableItemDictionary<ProjectItem, ProjectItemInstance>(
+                linkedProject.Items,
+                itemsByType,
+                convertCachedItemToInstance,
+                projectItemInstance => projectItemInstance.ItemType);
+
+            return itemDictionary;
+        }
+
+        private static ProjectItemInstance ConvertCachedProjectItemToInstance(
+            Project linkedProject,
+            ProjectInstance owningProjectInstance,
+            ProjectItem projectItem)
+        {
+            ProjectItemInstance result = null;
+            if (projectItem is IImmutableInstanceProvider<ProjectItemInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    var newInstance = InstantiateProjectItemInstanceFromImmutableProjectSource(
+                        linkedProject,
+                        owningProjectInstance,
+                        projectItem);
+
+                    result = instanceProvider.GetOrSetImmutableInstance(newInstance);
+                }
+            }
+
+            return result;
+        }
+
+        private static ProjectItemDefinitionInstance ConvertCachedItemDefinitionToInstance(ProjectItemDefinition projectItemDefinition)
+        {
+            ProjectItemDefinitionInstance result = null;
+
+            if (projectItemDefinition is IImmutableInstanceProvider<ProjectItemDefinitionInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    IDictionary<string, ProjectMetadataInstance> metadata = null;
+                    if (projectItemDefinition.Metadata is IDictionary<string, ProjectMetadata> linkedMetadataDict)
+                    {
+                        metadata = new ImmutableElementCollectionConverter<ProjectMetadata, ProjectMetadataInstance>(
+                                        linkedMetadataDict,
+                                        constrainedProjectElements: null,
+                                        ConvertCachedProjectMetadataToInstance);
+                    }
+
+                    result = instanceProvider.GetOrSetImmutableInstance(
+                        new ProjectItemDefinitionInstance(projectItemDefinition.ItemType, metadata));
+                }
+            }
+
+            return result;
+        }
+
+        private static ProjectMetadataInstance ConvertCachedProjectMetadataToInstance(ProjectMetadata projectMetadata)
+        {
+            ProjectMetadataInstance result = null;
+
+            if (projectMetadata is IImmutableInstanceProvider<ProjectMetadataInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    result = instanceProvider.GetOrSetImmutableInstance(new ProjectMetadataInstance(projectMetadata));
+                }
+            }
+
+            return result;
+        }
+
+        private static PropertyDictionary<ProjectPropertyInstance> GetImmutablePropertyDictionaryFromImmutableProject(Project linkedProject)
+        {
+            ICollection<ProjectProperty> linkedProjectProperties = linkedProject.Properties;
+            VerifyCollectionImplementsRequiredDictionaryInterfaces(
+                linkedProjectProperties,
+                out IDictionary<string, ProjectProperty> elementsDictionary,
+                out IDictionary<(string, int, int), ProjectProperty> constrainedElementsDictionary);
+
+            var hashSet = new ImmutableValuedElementCollectionConverter<ProjectProperty, ProjectPropertyInstance>(
+                                elementsDictionary,
+                                constrainedElementsDictionary,
+                                ConvertCachedPropertyToInstance);
+
+            return new PropertyDictionary<ProjectPropertyInstance>(hashSet);
+        }
+
+        private static ProjectPropertyInstance ConvertCachedPropertyToInstance(ProjectProperty property)
+        {
+            ProjectPropertyInstance result = null;
+
+            if (property is IImmutableInstanceProvider<ProjectPropertyInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    result = instanceProvider.GetOrSetImmutableInstance(InstantiateProjectPropertyInstance(property, isImmutable: true));
+                }
+            }
+
+            return result;
+        }
+
+        private static void VerifyCollectionImplementsRequiredDictionaryInterfaces<TCached>(
+            object elementsCollection,
+            out IDictionary<string, TCached> elementsDictionary,
+            out IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
         {
             // The elementsCollection we receive here is implemented in CPS as a special collection
             // that is both IDictionary<string, TCached> and also IDictionary<(string, int, int), TCached>.
@@ -911,25 +1049,14 @@ private static ImmutableElementCollectionConverter<TCached, T> GetImmutableEleme
             // represents the elementsCollection as an IRetrievableEntryHashSet<T>.
             // That IRetrievableEntryHashSet is then used either directly or as a backing source for
             // another collection wrapper (e.g. PropertyDictionary).
-            if (elementsCollection is not IDictionary<string, TCached> elementsDictionary ||
-                elementsCollection is not IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
+            if (elementsCollection is not IDictionary<string, TCached> elementsDict ||
+                elementsCollection is not IDictionary<(string, int, int), TCached> constrainedElementsDict)
             {
                 throw new ArgumentException(nameof(elementsCollection));
             }
 
-            return new ImmutableElementCollectionConverter<TCached, T>(elementsDictionary, constrainedElementsDictionary);
-        }
-
-        private static ImmutableElementCollectionConverter<TCached, T> GetImmutableElementCollectionConverter<TCached, T>(
-            IDictionary<string, TCached> elementsDictionary)
-            where T : class, IKeyed
-        {
-            if (elementsDictionary is not IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
-            {
-                throw new ArgumentException(nameof(elementsDictionary));
-            }
-
-            return new ImmutableElementCollectionConverter<TCached, T>(elementsDictionary, constrainedElementsDictionary);
+            elementsDictionary = elementsDict;
+            constrainedElementsDictionary = constrainedElementsDict;
         }
 
         /// <summary>
@@ -1556,7 +1683,7 @@ ICollection<ProjectItemInstance> IItemProvider<ProjectItemInstance>.GetItems(str
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
         void IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.
-            InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
+            InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext)
         {
             // All been done in the constructor.  We don't allow re-evaluation of project instances.
         }
@@ -1764,10 +1891,12 @@ ProjectPropertyInstance IPropertyProvider<ProjectPropertyInstance>.GetProperty(s
         /// </remarks>
         public string GetPropertyValue(string name)
         {
-            ProjectPropertyInstance property = _properties[name];
-            string value = (property == null) ? String.Empty : property.EvaluatedValue;
+            if (!_properties.TryGetPropertyUnescapedValue(name, out string unescapedValue))
+            {
+                unescapedValue = String.Empty;
+            }
 
-            return value;
+            return unescapedValue;
         }
 
         /// <summary>
@@ -2089,7 +2218,7 @@ public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<Fo
         /// </comment>
         public string ExpandString(string unexpandedValue)
         {
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default, _loggingContext);
 
             string result = expander.ExpandIntoStringAndUnescape(unexpandedValue, ExpanderOptions.ExpandPropertiesAndItems, ProjectFileLocation);
 
@@ -2107,7 +2236,7 @@ public string ExpandString(string unexpandedValue)
         /// </comment>
         public bool EvaluateCondition(string condition)
         {
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default, _loggingContext);
 
             bool result = ConditionEvaluator.EvaluateCondition(
                 condition,
@@ -2116,9 +2245,8 @@ public bool EvaluateCondition(string condition)
                 ExpanderOptions.ExpandPropertiesAndItems,
                 Directory,
                 ProjectFileLocation,
-                null /* no logging service */,
-                BuildEventContext.Invalid,
-                FileSystems.Default);
+                FileSystems.Default,
+                null /* no logging context */);
 
             return result;
         }
@@ -2859,28 +2987,6 @@ private static IDictionary<string, TValue> CreateCloneDictionary<TValue>(IDictio
             }
         }
 
-        private static void InitializeImmutableProjectItemDefinitionInstances(IDictionary<string, ProjectItemDefinition> projectItemDefinitions)
-        {
-            foreach (var projectItemDefinition in projectItemDefinitions.Values)
-            {
-                if (projectItemDefinition is IImmutableInstanceProvider<ProjectItemDefinitionInstance> immutableInstanceProvider)
-                {
-                    immutableInstanceProvider.ImmutableInstance = new ProjectItemDefinitionInstance(projectItemDefinition);
-                }
-            }
-        }
-
-        private static void InitializeImmutableProjectPropertyInstances(ICollection<ProjectProperty> projectProperties)
-        {
-            foreach (var projectProperty in projectProperties)
-            {
-                if (projectProperty is IImmutableInstanceProvider<ProjectPropertyInstance> immutableInstanceProvider)
-                {
-                    immutableInstanceProvider.ImmutableInstance = InstantiateProjectPropertyInstance(projectProperty, isImmutable: true);
-                }
-            }
-        }
-
         private static ProjectPropertyInstance InstantiateProjectPropertyInstance(ProjectProperty property, bool isImmutable)
         {
             // Allow reserved property names, since this is how they are added to the project instance.
@@ -2894,6 +3000,12 @@ private static ProjectPropertyInstance InstantiateProjectPropertyInstance(Projec
             return instance;
         }
 
+        /// <summary>
+        /// Logging context - set during the evaluation.
+        /// Can be null - especially if the project was fetched from the cache.
+        /// </summary>
+        private LoggingContext _loggingContext;
+
         /// <summary>
         /// Common code for the constructors that evaluate directly.
         /// Global properties may be null.
@@ -2926,15 +3038,15 @@ private void Initialize(
             _actualTargets = new RetrievableEntryHashSet<ProjectTargetInstance>(StringComparer.OrdinalIgnoreCase);
             _targets = new ObjectModel.ReadOnlyDictionary<string, ProjectTargetInstance>(_actualTargets);
             _importPaths = new List<string>();
-            ImportPaths = _importPaths.AsReadOnly();
+            ImportPaths = new ObjectModel.ReadOnlyCollection<string>(_importPaths);
             _importPathsIncludingDuplicates = new List<string>();
-            ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+            ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates);
             _globalProperties = new PropertyDictionary<ProjectPropertyInstance>((globalProperties == null) ? 0 : globalProperties.Count);
             _environmentVariableProperties = buildParameters.EnvironmentPropertiesInternal;
             _itemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(MSBuildNameIgnoreCaseComparer.Default);
             _hostServices = buildParameters.HostServices;
             this.ProjectRootElementCache = buildParameters.ProjectRootElementCache;
-
+            _loggingContext = new AnalyzerLoggingContext(loggingService, buildEventContext);
             this.EvaluatedItemElements = new List<ProjectItemElement>();
 
             _explicitToolsVersionSpecified = (explicitToolsVersion != null);
@@ -3045,8 +3157,16 @@ private void CreateTargetsSnapshot(
             // ProjectTargetInstances are immutable so only the dictionary must be cloned
             _targets = CreateCloneDictionary(targets);
 
-            this.DefaultTargets = defaultTargets == null ? new List<string>(0) : new List<string>(defaultTargets);
-            this.InitialTargets = defaultTargets == null ? new List<string>(0) : new List<string>(initialTargets);
+            InitializeTargetsData(defaultTargets, initialTargets, beforeTargets, afterTargets);
+        }
+
+        private void InitializeTargetsData(List<string> defaultTargets,
+            List<string> initialTargets,
+            IDictionary<string, List<TargetSpecification>> beforeTargets,
+            IDictionary<string, List<TargetSpecification>> afterTargets)
+        {
+            DefaultTargets = defaultTargets == null ? new List<string>(0) : new List<string>(defaultTargets);
+            InitialTargets = initialTargets == null ? new List<string>(0) : new List<string>(initialTargets);
             ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).BeforeTargets = CreateCloneDictionary(beforeTargets, StringComparer.OrdinalIgnoreCase);
             ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).AfterTargets = CreateCloneDictionary(afterTargets, StringComparer.OrdinalIgnoreCase);
         }
@@ -3056,29 +3176,31 @@ private void CreateTargetsSnapshot(
         /// </summary>
         private void CreateImportsSnapshot(IList<ResolvedImport> importClosure, IList<ResolvedImport> importClosureWithDuplicates)
         {
-            _importPaths = new List<string>(Math.Max(0, importClosure.Count - 1) /* outer project */);
+            var importPaths = new List<string>(Math.Max(0, importClosure.Count - 1) /* outer project */);
             foreach (var resolvedImport in importClosure)
             {
                 // Exclude outer project itself
                 if (resolvedImport.ImportingElement != null)
                 {
-                    _importPaths.Add(resolvedImport.ImportedProject.FullPath);
+                    importPaths.Add(resolvedImport.ImportedProject.FullPath);
                 }
             }
 
-            ImportPaths = _importPaths.AsReadOnly();
+            _importPaths = importPaths;
+            ImportPaths = importPaths.AsReadOnly();
 
-            _importPathsIncludingDuplicates = new List<string>(Math.Max(0, importClosureWithDuplicates.Count - 1) /* outer project */);
+            var importPathsIncludingDuplicates = new List<string>(Math.Max(0, importClosureWithDuplicates.Count - 1) /* outer project */);
             foreach (var resolvedImport in importClosureWithDuplicates)
             {
                 // Exclude outer project itself
                 if (resolvedImport.ImportingElement != null)
                 {
-                    _importPathsIncludingDuplicates.Add(resolvedImport.ImportedProject.FullPath);
+                    importPathsIncludingDuplicates.Add(resolvedImport.ImportedProject.FullPath);
                 }
             }
 
-            ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+            _importPathsIncludingDuplicates = importPathsIncludingDuplicates;
+            ImportPathsIncludingDuplicates = importPathsIncludingDuplicates.AsReadOnly();
         }
 
         /// <summary>
@@ -3117,11 +3239,13 @@ private void CreateEvaluatedIncludeSnapshotIfRequested(bool keepEvaluationCache,
                 return;
             }
 
-            _itemsByEvaluatedInclude = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
+            var multiDictionary = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
             foreach (var item in items)
             {
-                _itemsByEvaluatedInclude.Add(item.EvaluatedInclude, projectItemToInstanceMap[item]);
+                multiDictionary.Add(item.EvaluatedInclude, projectItemToInstanceMap[item]);
             }
+
+            _itemsByEvaluatedInclude = multiDictionary;
         }
 
         /// <summary>
@@ -3143,22 +3267,9 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(ICollec
             return projectItemToInstanceMap;
         }
 
-        private void InitializeImmutableProjectItemInstances(ICollection<ProjectItem> projectItems)
-        {
-            foreach (var projectItem in projectItems)
-            {
-                if (projectItem is IImmutableInstanceProvider<ProjectItemInstance> immutableInstanceProvider)
-                {
-                    ProjectItemInstance instance = InstantiateProjectItemInstance(projectItem);
-                    immutableInstanceProvider.ImmutableInstance = instance;
-                }
-            }
-        }
-
         private ProjectItemInstance InstantiateProjectItemInstance(ProjectItem item)
         {
             List<ProjectItemDefinitionInstance> inheritedItemDefinitions = null;
-
             if (item.InheritedItemDefinitions != null)
             {
                 inheritedItemDefinitions = new List<ProjectItemDefinitionInstance>(item.InheritedItemDefinitions.Count);
@@ -3172,7 +3283,6 @@ private ProjectItemInstance InstantiateProjectItemInstance(ProjectItem item)
             }
 
             CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = null;
-
             if (item.DirectMetadata != null)
             {
                 directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
@@ -3181,16 +3291,87 @@ private ProjectItemInstance InstantiateProjectItemInstance(ProjectItem item)
                 directMetadata.ImportProperties(projectMetadataInstances);
             }
 
+            GetEvaluatedIncludesFromProjectItem(
+                item,
+                out string evaluatedIncludeEscaped,
+                out string evaluatedIncludeBeforeWildcardExpansionEscaped);
+
+            var instance = new ProjectItemInstance(
+                this,
+                item.ItemType,
+                evaluatedIncludeEscaped,
+                evaluatedIncludeBeforeWildcardExpansionEscaped,
+                directMetadata,
+                inheritedItemDefinitions,
+                item.Xml.ContainingProject.EscapedFullPath,
+                useItemDefinitionsWithoutModification: false);
+
+            return instance;
+        }
+
+        private static void GetEvaluatedIncludesFromProjectItem(
+            ProjectItem item,
+            out string evaluatedIncludeEscaped,
+            out string evaluatedIncludeBeforeWildcardExpansionEscaped)
+        {
             // For externally constructed ProjectItem, fall back to the publicly available EvaluateInclude
-            var evaluatedIncludeEscaped = ((IItem)item).EvaluatedIncludeEscaped;
+            evaluatedIncludeEscaped = ((IItem)item).EvaluatedIncludeEscaped;
             evaluatedIncludeEscaped ??= item.EvaluatedInclude;
-            var evaluatedIncludeBeforeWildcardExpansionEscaped = item.EvaluatedIncludeBeforeWildcardExpansionEscaped;
+            evaluatedIncludeBeforeWildcardExpansionEscaped = item.EvaluatedIncludeBeforeWildcardExpansionEscaped;
             evaluatedIncludeBeforeWildcardExpansionEscaped ??= item.EvaluatedInclude;
+        }
+
+        private static ProjectItemInstance InstantiateProjectItemInstanceFromImmutableProjectSource(
+            Project linkedProject,
+            ProjectInstance projectInstance,
+            ProjectItem item)
+        {
+            linkedProject.ItemDefinitions.TryGetValue(item.ItemType, out ProjectItemDefinition itemTypeDefinition);
+
+            IList<ProjectItemDefinitionInstance> inheritedItemDefinitions =
+                new ImmutableItemDefinitionsListConverter<ProjectItemDefinition, ProjectItemDefinitionInstance>(
+                    item.InheritedItemDefinitions,
+                    itemTypeDefinition,
+                    ConvertCachedItemDefinitionToInstance);
 
-            ProjectItemInstance instance = new ProjectItemInstance(this, item.ItemType, evaluatedIncludeEscaped, evaluatedIncludeBeforeWildcardExpansionEscaped, directMetadata, inheritedItemDefinitions, item.Xml.ContainingProject.EscapedFullPath);
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = null;
+            if (item.DirectMetadata is not null)
+            {
+                if (item.DirectMetadata is IDictionary<string, ProjectMetadata> metadataDict)
+                {
+                    directMetadata = new ImmutablePropertyCollectionConverter<ProjectMetadata, ProjectMetadataInstance>(metadataDict, ConvertCachedProjectMetadataToInstance);
+                }
+                else
+                {
+                    directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+
+                    IEnumerable<ProjectMetadataInstance> projectMetadataInstances = item.DirectMetadata.Select(directMetadatum => new ProjectMetadataInstance(directMetadatum));
+                    directMetadata.ImportProperties(projectMetadataInstances);
+                }
+            }
+
+            GetEvaluatedIncludesFromProjectItem(
+                item,
+                out string evaluatedIncludeEscaped,
+                out string evaluatedIncludeBeforeWildcardExpansionEscaped);
+
+            ProjectItemInstance instance = new ProjectItemInstance(
+                projectInstance,
+                item.ItemType,
+                evaluatedIncludeEscaped,
+                evaluatedIncludeBeforeWildcardExpansionEscaped,
+                directMetadata,
+                inheritedItemDefinitions,
+                item.Xml.ContainingProject.EscapedFullPath,
+                useItemDefinitionsWithoutModification: true);
             return instance;
         }
 
+        private static string GetImportFullPath(ResolvedImport import)
+        {
+            return import.ImportedProject.FullPath;
+        }
+
         /// <summary>
         /// Create ItemDefinitions snapshot
         /// </summary>
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index fa41b3882ec..2051107c8bd 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Instance;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -31,9 +32,8 @@ public class ProjectItemDefinitionInstance : IKeyed, IMetadataTable, IItemDefini
         /// <summary>
         /// Collection of metadata that link the XML metadata and instance metadata
         /// Since evaluation has occurred, this is an unordered collection.
-        /// Is never null or empty.
         /// </summary>
-        private CopyOnWritePropertyDictionary<ProjectMetadataInstance> _metadata;
+        private IDictionary<string, ProjectMetadataInstance> _metadata;
 
         /// <summary>
         /// Constructs an empty project item definition instance.
@@ -58,13 +58,25 @@ internal ProjectItemDefinitionInstance(ProjectItemDefinition itemDefinition)
         {
             if (itemDefinition.MetadataCount > 0)
             {
-                _metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-
+                var copyOnWriteMetadataDictionary = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
                 IEnumerable<ProjectMetadataInstance> projectMetadataInstances = itemDefinition.Metadata.Select(originalMetadata => new ProjectMetadataInstance(originalMetadata));
-                _metadata.ImportProperties(projectMetadataInstances);
+                copyOnWriteMetadataDictionary.ImportProperties(projectMetadataInstances);
+
+                _metadata = copyOnWriteMetadataDictionary;
             }
         }
 
+        /// <summary>
+        /// Initializes a new instance of the <see cref="ProjectItemDefinitionInstance"/> class.
+        /// </summary>
+        /// <param name="itemType">The type of item this definition object represents.</param>
+        /// <param name="metadata">A (possibly null) collection of the metadata associated with this item definition.</param>
+        internal ProjectItemDefinitionInstance(string itemType, IDictionary<string, ProjectMetadataInstance> metadata)
+            : this(itemType)
+        {
+            _metadata = metadata;
+        }
+
         private ProjectItemDefinitionInstance()
         {
         }
@@ -95,7 +107,7 @@ public ICollection<ProjectMetadataInstance> Metadata
                     return ReadOnlyEmptyCollection<ProjectMetadataInstance>.Instance;
                 }
 
-                return new ReadOnlyCollection<ProjectMetadataInstance>(_metadata);
+                return new ReadOnlyCollection<ProjectMetadataInstance>(_metadata.Values);
             }
         }
 
@@ -110,21 +122,7 @@ public int MetadataCount
         /// <summary>
         /// Names of all metadata on this item definition
         /// </summary>
-        public IEnumerable<string> MetadataNames
-        {
-            get
-            {
-                if (_metadata == null)
-                {
-                    yield break;
-                }
-
-                foreach (ProjectMetadataInstance metadatum in _metadata)
-                {
-                    yield return metadatum.Name;
-                }
-            }
-        }
+        public IEnumerable<string> MetadataNames => _metadata == null ? Enumerable.Empty<string>() : _metadata.Keys;
 
         /// <summary>
         /// Implementation of IKeyed exposing the item type, so these
@@ -213,8 +211,9 @@ internal ProjectItemDefinitionElement ToProjectItemDefinitionElement(ProjectElem
         {
             ProjectItemDefinitionElement element = parent.ContainingProject.CreateItemDefinitionElement(ItemType);
             parent.AppendChild(element);
-            foreach (ProjectMetadataInstance metadataInstance in _metadata)
+            foreach (var kvp in _metadata)
             {
+                ProjectMetadataInstance metadataInstance = kvp.Value;
                 element.AddMetadata(metadataInstance.Name, metadataInstance.EvaluatedValue);
             }
 
@@ -224,7 +223,7 @@ internal ProjectItemDefinitionElement ToProjectItemDefinitionElement(ProjectElem
         void ITranslatable.Translate(ITranslator translator)
         {
             translator.Translate(ref _itemType);
-            translator.TranslateDictionary(ref _metadata, ProjectMetadataInstance.FactoryForDeserialization);
+            translator.TranslateDictionary(ref _metadata, ProjectMetadataInstance.FactoryForDeserialization, CreateMetadataCollection);
         }
 
         internal static ProjectItemDefinitionInstance FactoryForDeserialization(ITranslator translator)
@@ -236,5 +235,10 @@ internal static ProjectItemDefinitionInstance FactoryForDeserialization(ITransla
         }
 
         string IItemTypeDefinition.ItemType => _itemType;
+
+        private static IDictionary<string, ProjectMetadataInstance> CreateMetadataCollection(int capacity)
+        {
+            return new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+        }
     }
 }
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index cf6fc186770..5769a0fa12e 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -77,7 +77,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
         /// Mutability follows the project.
         /// </summary>
         internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string includeBeforeWildcardExpansionEscaped, string definingFileEscaped)
-            : this(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, null /* no direct metadata */, null /* need to add item definition metadata */, definingFileEscaped)
+            : this(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, null /* no direct metadata */, null /* need to add item definition metadata */, definingFileEscaped, useItemDefinitionsWithoutModification: false)
         {
         }
 
@@ -94,9 +94,17 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
         /// <remarks>
         /// Not public since the only creation scenario is setting on a project.
         /// </remarks>
-        internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string includeBeforeWildcardExpansionEscaped, CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata, List<ProjectItemDefinitionInstance> itemDefinitions, string definingFileEscaped)
+        internal ProjectItemInstance(
+            ProjectInstance project,
+            string itemType,
+            string includeEscaped,
+            string includeBeforeWildcardExpansionEscaped,
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
+            IList<ProjectItemDefinitionInstance> itemDefinitions,
+            string definingFileEscaped,
+            bool useItemDefinitionsWithoutModification)
         {
-            CommonConstructor(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, directMetadata, itemDefinitions, definingFileEscaped);
+            CommonConstructor(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, directMetadata, itemDefinitions, definingFileEscaped, useItemDefinitionsWithoutModification);
         }
 
         /// <summary>
@@ -121,7 +129,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
                 metadata.ImportProperties(directMetadataInstances);
             }
 
-            CommonConstructor(project, itemType, includeEscaped, includeEscaped, metadata, null /* need to add item definition metadata */, definingFileEscaped);
+            CommonConstructor(project, itemType, includeEscaped, includeEscaped, metadata, null /* need to add item definition metadata */, definingFileEscaped, useItemDefinitionsWithoutModification: false);
         }
 
         /// <summary>
@@ -615,7 +623,7 @@ internal static ProjectItemInstance FactoryForDeserialization(ITranslator transl
         /// Add a metadata with the specified names and values.
         /// Overwrites any metadata with the same name already in the collection.
         /// </summary>
-        internal void SetMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataDictionary)
+        internal void SetMetadata(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataDictionary)
         {
             _project.VerifyThrowNotImmutable();
 
@@ -682,33 +690,53 @@ internal ProjectItemElement ToProjectItemElement(ProjectElementContainer parent)
         /// Inherited item definition metadata may be null. It is assumed to ALREADY HAVE BEEN CLONED.
         /// Mutability follows the project.
         /// </summary>
-        private void CommonConstructor(ProjectInstance projectToUse, string itemTypeToUse, string includeEscaped, string includeBeforeWildcardExpansionEscaped, CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata, List<ProjectItemDefinitionInstance> itemDefinitions, string definingFileEscaped)
+        private void CommonConstructor(
+            ProjectInstance projectToUse,
+            string itemTypeToUse,
+            string includeEscaped,
+            string includeBeforeWildcardExpansionEscaped,
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
+            IList<ProjectItemDefinitionInstance> itemDefinitions,
+            string definingFileEscaped,
+            bool useItemDefinitionsWithoutModification)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectToUse, "project");
             ErrorUtilities.VerifyThrowArgumentLength(itemTypeToUse, "itemType");
             XmlUtilities.VerifyThrowArgumentValidElementName(itemTypeToUse);
             ErrorUtilities.VerifyThrowArgument(!XMakeElements.ReservedItemNames.Contains(itemTypeToUse), "OM_ReservedName", itemTypeToUse);
 
-            // TaskItems don't have an item type. So for their benefit, we have to lookup and add the regular item definition.
-            List<ProjectItemDefinitionInstance> inheritedItemDefinitions = (itemDefinitions == null) ? null : new List<ProjectItemDefinitionInstance>(itemDefinitions);
+            IList<ProjectItemDefinitionInstance> inheritedItemDefinitions;
+            if (itemDefinitions == null || !useItemDefinitionsWithoutModification)
+            {
+                // TaskItems don't have an item type. So for their benefit, we have to lookup and add the regular item definition.
+                inheritedItemDefinitions = (itemDefinitions == null) ? null : new List<ProjectItemDefinitionInstance>(itemDefinitions);
 
-            ProjectItemDefinitionInstance itemDefinition;
-            if (projectToUse.ItemDefinitions.TryGetValue(itemTypeToUse, out itemDefinition))
+                ProjectItemDefinitionInstance itemDefinition;
+                if (projectToUse.ItemDefinitions.TryGetValue(itemTypeToUse, out itemDefinition))
+                {
+                    inheritedItemDefinitions ??= new List<ProjectItemDefinitionInstance>();
+                    inheritedItemDefinitions.Add(itemDefinition);
+                }
+            }
+            else
             {
-                inheritedItemDefinitions ??= new List<ProjectItemDefinitionInstance>();
-                inheritedItemDefinitions.Add(itemDefinition);
+                // In this case the caller specifying useItemDefinitionsWithoutModification is guaranteeing that
+                // the itemDefinitions collection contains all necessary definitions (including the definition
+                // associated with itemTypeToUse) and, for performance reasons, the provided (immutable) collection
+                // should be used as is.
+                inheritedItemDefinitions = itemDefinitions;
             }
 
             _project = projectToUse;
             _itemType = itemTypeToUse;
             _taskItem = new TaskItem(
-                                        includeEscaped,
-                                        includeBeforeWildcardExpansionEscaped,
-                                        directMetadata?.DeepClone(), // copy on write!
-                                        inheritedItemDefinitions,
-                                        _project.Directory,
-                                        _project.IsImmutable,
-                                        definingFileEscaped);
+                            includeEscaped,
+                            includeBeforeWildcardExpansionEscaped,
+                            directMetadata?.DeepClone(), // copy on write!
+                            inheritedItemDefinitions,
+                            _project.Directory,
+                            _project.IsImmutable,
+                            definingFileEscaped);
         }
 
         /// <summary>
@@ -751,7 +779,7 @@ internal sealed class TaskItem :
             /// Lazily created, as there are huge numbers of items generated in
             /// a build that have no metadata at all.
             /// </remarks>
-            private CopyOnWritePropertyDictionary<ProjectMetadataInstance> _directMetadata;
+            private ICopyOnWritePropertyDictionary<ProjectMetadataInstance> _directMetadata;
 
             /// <summary>
             /// Cached value of the fullpath metadata. All other metadata are computed on demand.
@@ -765,7 +793,7 @@ internal sealed class TaskItem :
             /// be item definitions inherited from items that were
             /// used to create this item.
             /// </summary>
-            private List<ProjectItemDefinitionInstance> _itemDefinitions;
+            private IList<ProjectItemDefinitionInstance> _itemDefinitions;
 
             /// <summary>
             /// Directory of the associated project. If this is available,
@@ -794,8 +822,8 @@ internal TaskItem(string includeEscaped, string definingFileEscaped)
             internal TaskItem(
                               string includeEscaped,
                               string includeBeforeWildcardExpansionEscaped,
-                              CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
-                              List<ProjectItemDefinitionInstance> itemDefinitions,
+                              ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
+                              IList<ProjectItemDefinitionInstance> itemDefinitions,
                               string projectDirectory,
                               bool immutable,
                               string definingFileEscaped) // the actual project file (or import) that defines this item.
@@ -909,11 +937,11 @@ public ICollection MetadataNames
             {
                 get
                 {
-                    CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataCollection = MetadataCollection;
+                    ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataCollection = MetadataCollection;
 
                     List<string> names = new List<string>(capacity: metadataCollection.Count + FileUtilities.ItemSpecModifiers.All.Length);
 
-                    foreach (ProjectMetadataInstance metadatum in metadataCollection)
+                    foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)metadataCollection)
                     {
                         names.Add(metadatum.Name);
                     }
@@ -1058,11 +1086,11 @@ public void ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
             /// </summary>
             /// <param name="list">The source list to return metadata from.</param>
             /// <returns>An array of string key-value pairs representing metadata.</returns>
-            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(CopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
+            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
             {
                 var result = new List<KeyValuePair<string, string>>(list.Count);
 
-                foreach (var projectMetadataInstance in list)
+                foreach (var projectMetadataInstance in list.Values)
                 {
                     if (projectMetadataInstance != null)
                     {
@@ -1074,9 +1102,9 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(CopyOnW
                 return result.ToArray();
             }
 
-            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
+            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
             {
-                foreach (var projectMetadataInstance in list)
+                foreach (var projectMetadataInstance in list.Values)
                 {
                     if (projectMetadataInstance != null)
                     {
@@ -1093,7 +1121,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(CopyOnWriteP
             /// This is a read-only collection. To modify the metadata, use <see cref="SetMetadata(string, string)"/>.
             /// Computed, not necessarily fast.
             /// </summary>
-            internal CopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollection
+            internal ICopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollection
             {
                 get
                 {
@@ -1137,7 +1165,7 @@ IEnumerable<ProjectMetadataInstance> metaData()
                         // Finally any direct metadata win.
                         if (_directMetadata != null)
                         {
-                            foreach (ProjectMetadataInstance metadatum in _directMetadata)
+                            foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)_directMetadata)
                             {
                                 if (metadatum != null)
                                 {
@@ -1287,16 +1315,16 @@ public string GetMetadataEscaped(string metadataName)
                     ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
                 }
 
-                ProjectMetadataInstance metadatum;
                 if (_directMetadata != null)
                 {
-                    metadatum = _directMetadata[metadataName];
-                    if (metadatum != null)
+                    string escapedValue = _directMetadata.GetEscapedValue(metadataName);
+                    if (escapedValue != null)
                     {
-                        return metadatum.EvaluatedValueEscaped;
+                        return escapedValue;
                     }
                 }
 
+                ProjectMetadataInstance metadatum;
                 metadatum = GetItemDefinitionMetadata(metadataName);
 
                 if (metadatum != null && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
@@ -1404,7 +1432,10 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                     }
                     else if (_itemDefinitions != null)
                     {
-                        destinationAsTaskItem._itemDefinitions.AddRange(_itemDefinitions);
+                        foreach (var itemDefinition in _itemDefinitions)
+                        {
+                            destinationAsTaskItem._itemDefinitions.Add(itemDefinition);
+                        }
                     }
                 }
                 else if (destinationItem is IMetadataContainer destinationItemAsMetadataContainer)
@@ -1428,7 +1459,7 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                 else
                 {
                     // OK, most likely the destination item was a Microsoft.Build.Utilities.TaskItem.
-                    foreach (ProjectMetadataInstance metadatum in MetadataCollection)
+                    foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)MetadataCollection)
                     {
                         // When copying metadata, we do NOT overwrite metadata already on the destination item.
                         string destinationValue = destinationItem.GetMetadata(metadatum.Name);
@@ -1460,7 +1491,7 @@ public IDictionary CloneCustomMetadata()
                 var metadata = MetadataCollection;
                 Dictionary<string, string> clonedMetadata = new Dictionary<string, string>(metadata.Count, MSBuildNameIgnoreCaseComparer.Default);
 
-                foreach (ProjectMetadataInstance metadatum in metadata)
+                foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)metadata)
                 {
                     clonedMetadata[metadatum.Name] = metadatum.EvaluatedValue;
                 }
@@ -1477,7 +1508,7 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()
             {
                 Dictionary<string, string> clonedMetadata = new Dictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
 
-                foreach (ProjectMetadataInstance metadatum in MetadataCollection)
+                foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)MetadataCollection)
                 {
                     clonedMetadata[metadatum.Name] = metadatum.EvaluatedValueEscaped;
                 }
@@ -1501,8 +1532,17 @@ void ITranslatable.Translate(ITranslator translator)
                 translator.Translate(ref _isImmutable);
                 translator.Translate(ref _definingFileEscaped);
 
-                translator.Translate(ref _itemDefinitions, ProjectItemDefinitionInstance.FactoryForDeserialization);
-                translator.TranslateDictionary(ref _directMetadata, ProjectMetadataInstance.FactoryForDeserialization);
+                TranslatorHelpers.Translate(
+                    translator,
+                    ref _itemDefinitions,
+                    ProjectItemDefinitionInstance.FactoryForDeserialization,
+                    (capacity) => new List<ProjectItemDefinitionInstance>(capacity));
+
+                TranslatorHelpers.TranslateDictionary(
+                    translator,
+                    ref _directMetadata,
+                    ProjectMetadataInstance.FactoryForDeserialization,
+                    (capacity) => new CopyOnWritePropertyDictionary<ProjectMetadataInstance>());
 
                 if (_itemDefinitions?.Count == 0)
                 {
@@ -1580,7 +1620,8 @@ public bool Equals(TaskItem other)
                 // the set of metadata names on 'this', to avoid computing the full metadata collection
                 // of both 'this' and 'other'. Once we have the names for 'this', we enumerate 'other'
                 // and ensure the names we see there are set-equal to the names we produce here.
-                var thisNames = new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+                int capacity = _itemDefinitions?.Count ?? 0 + _directMetadata?.Count ?? 0;
+                var thisNames = new HashSet<string>(capacity, MSBuildNameIgnoreCaseComparer.Default);
 
                 if (_itemDefinitions is not null)
                 {
@@ -1592,20 +1633,20 @@ public bool Equals(TaskItem other)
 
                 if (_directMetadata is not null)
                 {
-                    foreach (ProjectMetadataInstance metadatum in _directMetadata)
+                    foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)_directMetadata)
                     {
                         thisNames.Add(metadatum.Name);
                     }
                 }
 
-                CopyOnWritePropertyDictionary<ProjectMetadataInstance> otherMetadata = other.MetadataCollection;
+                ICopyOnWritePropertyDictionary<ProjectMetadataInstance> otherMetadata = other.MetadataCollection;
 
                 if (otherMetadata.Count != thisNames.Count)
                 {
                     return false;
                 }
 
-                foreach (ProjectMetadataInstance metadatum in otherMetadata)
+                foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)otherMetadata)
                 {
                     string name = metadatum.Name;
 
@@ -1702,7 +1743,11 @@ private void ReadInternString(ITranslator translator, LookasideStringInterner in
             /// </summary>
             internal void TranslateWithInterning(ITranslator translator, LookasideStringInterner interner)
             {
-                translator.Translate(ref _itemDefinitions, ProjectItemDefinitionInstance.FactoryForDeserialization);
+                TranslatorHelpers.Translate(
+                    translator,
+                    ref _itemDefinitions,
+                    ProjectItemDefinitionInstance.FactoryForDeserialization,
+                    (capacity) => new List<ProjectItemDefinitionInstance>(capacity));
                 translator.Translate(ref _isImmutable);
                 translator.Translate(ref _includeEscaped);
 
@@ -1711,14 +1756,14 @@ internal void TranslateWithInterning(ITranslator translator, LookasideStringInte
                     WriteInternString(translator, interner, ref _includeBeforeWildcardExpansionEscaped);
                     WriteInternString(translator, interner, ref _definingFileEscaped);
 
-                    CopyOnWritePropertyDictionary<ProjectMetadataInstance> temp = MetadataCollection;
+                    ICopyOnWritePropertyDictionary<ProjectMetadataInstance> temp = MetadataCollection;
 
                     // Intern the metadata
                     if (translator.TranslateNullable(temp))
                     {
                         int count = temp.Count;
                         translator.Writer.Write(count);
-                        foreach (ProjectMetadataInstance metadatum in temp)
+                        foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)temp)
                         {
                             int key = interner.Intern(metadatum.Name);
                             int value = interner.Intern(metadatum.EvaluatedValueEscaped);
@@ -1779,7 +1824,7 @@ internal ProjectMetadataInstance GetMetadataObject(string name)
             /// Add a metadata with the specified name and value.
             /// Overwrites any metadata with the same name already in the collection.
             /// </summary>
-            internal void SetMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata)
+            internal void SetMetadata(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata)
             {
                 ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
 
@@ -2051,7 +2096,7 @@ private ProjectItemInstance CreateItem(string includeEscaped, string includeBefo
                         itemDefinitionsClone.Add(sourceItemDefinition);
                     }
 
-                    return new ProjectItemInstance(_project, ItemType, includeEscaped, includeBeforeWildcardExpansionEscaped, source._taskItem._directMetadata, itemDefinitionsClone, definingProject);
+                    return new ProjectItemInstance(_project, ItemType, includeEscaped, includeBeforeWildcardExpansionEscaped, source._taskItem._directMetadata, itemDefinitionsClone, definingProject, useItemDefinitionsWithoutModification: false);
                 }
             }
 
diff --git a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
index 6eb9b3f1972..5ce7695e734 100644
--- a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Execution
     /// Immutable.
     /// </summary>
     [DebuggerDisplay("{_name}={Value} Condition={_condition}")]
-    public class ProjectPropertyGroupTaskPropertyInstance : ITranslatable
+    public class ProjectPropertyGroupTaskPropertyInstance : ITranslatable, IPropertyElementWithLocation
     {
         /// <summary>
         /// Name of the property
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 5b65829e926..598819b3cd4 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -11,6 +11,7 @@
 using System.Reflection;
 using System.Threading;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
@@ -249,8 +250,7 @@ internal IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> TaskReg
         /// <typeparam name="P">A type derived from IProperty</typeparam>
         /// <typeparam name="I">A type derived from IItem</typeparam>
         internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
-            ILoggingService loggingService,
-            BuildEventContext buildEventContext,
+            LoggingContext loggingContext,
             IEnumerable<(ProjectUsingTaskElement projectUsingTaskXml, string directoryOfImportingFile)> registrations,
             TaskRegistry taskRegistry,
             Expander<P, I> expander,
@@ -262,8 +262,7 @@ internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
             foreach ((ProjectUsingTaskElement projectUsingTaskXml, string directoryOfImportingFile) registration in registrations)
             {
                 RegisterTasksFromUsingTaskElement(
-                    loggingService,
-                    buildEventContext,
+                    loggingContext,
                     registration.directoryOfImportingFile,
                     registration.projectUsingTaskXml,
                     taskRegistry,
@@ -284,8 +283,7 @@ internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
         /// <typeparam name="I">A type derived from IItem</typeparam>
         private static void RegisterTasksFromUsingTaskElement
             <P, I>(
-            ILoggingService loggingService,
-            BuildEventContext buildEventContext,
+            LoggingContext loggingContext,
             string directoryOfImportingFile,
             ProjectUsingTaskElement projectUsingTaskXml,
             TaskRegistry taskRegistry,
@@ -307,9 +305,8 @@ private static void RegisterTasksFromUsingTaskElement
                     expanderOptions,
                     projectUsingTaskXml.ContainingProject.DirectoryPath,
                     projectUsingTaskXml.ConditionLocation,
-                    loggingService,
-                    buildEventContext,
-                    fileSystem))
+                    fileSystem,
+                    loggingContext))
             {
                 return;
             }
@@ -444,7 +441,7 @@ private static void RegisterTasksFromUsingTaskElement
                 taskFactoryParameters.Add(XMakeAttributes.architecture, architecture == String.Empty ? XMakeAttributes.MSBuildArchitectureValues.any : architecture);
             }
 
-            taskRegistry.RegisterTask(taskName, AssemblyLoadInfo.Create(assemblyName, assemblyFile), taskFactory, taskFactoryParameters, parameterGroupAndTaskElementRecord, loggingService, buildEventContext, projectUsingTaskXml, ConversionUtilities.ValidBooleanTrue(overrideUsingTask));
+            taskRegistry.RegisterTask(taskName, AssemblyLoadInfo.Create(assemblyName, assemblyFile), taskFactory, taskFactoryParameters, parameterGroupAndTaskElementRecord, loggingContext, projectUsingTaskXml, ConversionUtilities.ValidBooleanTrue(overrideUsingTask));
         }
 
         private static Dictionary<string, string> CreateTaskFactoryParametersDictionary(int? initialCount = null)
@@ -547,7 +544,7 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
             // Try the override task registry first
             if (_toolset != null)
             {
-                TaskRegistry toolsetRegistry = _toolset.GetOverrideTaskRegistry(targetLoggingContext.LoggingService, targetLoggingContext.BuildEventContext, RootElementCache);
+                TaskRegistry toolsetRegistry = _toolset.GetOverrideTaskRegistry(targetLoggingContext, RootElementCache);
                 taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
             }
 
@@ -606,7 +603,7 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
             // If we didn't find the task but we have a fallback registry in the toolset state, try that one.
             if (taskRecord == null && _toolset != null)
             {
-                TaskRegistry toolsetRegistry = _toolset.GetTaskRegistry(targetLoggingContext.LoggingService, targetLoggingContext.BuildEventContext, RootElementCache);
+                TaskRegistry toolsetRegistry = _toolset.GetTaskRegistry(targetLoggingContext, RootElementCache);
                 taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
             }
 
@@ -687,8 +684,7 @@ private void RegisterTask(
             string taskFactory,
             Dictionary<string, string> taskFactoryParameters,
             RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord,
-            ILoggingService loggingService,
-            BuildEventContext context,
+            LoggingContext loggingContext,
             ProjectUsingTaskElement projectUsingTaskInXml,
             bool overrideTask = false)
         {
@@ -733,7 +729,7 @@ private void RegisterTask(
                     {
                         if (rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase))
                         {
-                            loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), "DuplicateOverrideUsingTaskElement", taskName);
+                            loggingContext.LogError(new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), "DuplicateOverrideUsingTaskElement", taskName);
                             break;
                         }
                     }
@@ -745,7 +741,7 @@ private void RegisterTask(
                     List<RegisteredTaskRecord> unqualifiedTaskNameMatches = new();
                     unqualifiedTaskNameMatches.Add(newRecord);
                     _overriddenTasks.Add(unqualifiedTaskName, unqualifiedTaskNameMatches);
-                    loggingService.LogComment(context, MessageImportance.Low, "OverrideUsingTaskElementCreated", taskName, projectUsingTaskInXml.OverrideLocation);
+                    loggingContext.LogComment(MessageImportance.Low, "OverrideUsingTaskElementCreated", taskName, projectUsingTaskInXml.OverrideLocation);
                 }
             }
 
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index a7b005a1925..d4c37461938 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -71,6 +71,8 @@ public sealed class BinaryLogger : ILogger
         //   - GeneratedFileUsedEventArgs exposed for brief period of time (so let's continue with 20)
         // version 20:
         //   - TaskStartedEventArgs: Added TaskAssemblyLocation property
+        // version 21:
+        //   - TaskParameterEventArgs: Added ParameterName and PropertyName properties
 
         // This should be never changed.
         // The minimum version of the binary log reader that can read log of above version.
@@ -78,7 +80,7 @@ public sealed class BinaryLogger : ILogger
 
         // The current version of the binary log representation.
         // Changes with each update of the binary log format.
-        internal const int FileFormatVersion = 20;
+        internal const int FileFormatVersion = 21;
 
         // The minimum version of the binary log reader that can read log of above version.
         // This should be changed only when the binary log format is changed in a way that would prevent it from being
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 03ce7bed76c..358c410265f 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -1022,10 +1022,15 @@ private BuildEventArgs ReadTaskParameterEventArgs()
             var kind = (TaskParameterMessageKind)ReadInt32();
             var itemType = ReadDeduplicatedString();
             var items = ReadTaskItemList() as IList;
+            var (parameterName, propertyName) = _fileFormatVersion >= 21
+                ? (ReadDeduplicatedString(), ReadDeduplicatedString())
+                : (null, null);
 
             var e = ItemGroupLoggingHelper.CreateTaskParameterEventArgs(
                 fields.BuildEventContext,
                 kind,
+                parameterName,
+                propertyName,
                 itemType,
                 items,
                 logItemMetadata: true,
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 0c5c82846b3..a9a734b1638 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -571,6 +571,8 @@ private BinaryLogRecordKind Write(TaskParameterEventArgs e)
             Write((int)e.Kind);
             WriteDeduplicatedString(e.ItemType);
             WriteTaskItemList(e.Items, e.LogItemMetadata);
+            WriteDeduplicatedString(e.ParameterName);
+            WriteDeduplicatedString(e.PropertyName);
             if (e.Kind == TaskParameterMessageKind.AddItem
                || e.Kind == TaskParameterMessageKind.TaskOutput)
             {
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index d2801b103f0..04a1000d9cf 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -30,11 +30,7 @@
   <ItemGroup>
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
-
-    <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
-    <PackageReference Include="System.Security.Principal.Windows" />
-    <PackageReference Include="System.Threading.Tasks.Dataflow" />
 
     <PackageReference Include="System.Reflection.MetadataLoadContext" />
 
@@ -49,7 +45,10 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <Reference Include="System.IO.Compression" />
     <PackageReference Include="System.Memory" />
+    <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Text.Json" />
+    <PackageReference Include="System.Collections.Immutable" />
+    <PackageReference Include="System.Threading.Tasks.Dataflow" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
@@ -161,11 +160,16 @@
     <Compile Include="BuildCheck\Acquisition\IBuildCheckAcquisitionModule.cs" />
     <Compile Include="BuildCheck\Analyzers\SharedOutputPathAnalyzer.cs" />
     <Compile Include="BuildCheck\Infrastructure\BuildCheckConfigurationException.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckForwardingLogger.cs" />
     <Compile Include="BuildCheck\Infrastructure\BuildEventsProcessor.cs" />
     <Compile Include="BuildCheck\Infrastructure\IBuildCheckManagerProvider.cs" />
     <Compile Include="BuildCheck\Infrastructure\NullBuildCheckManager.cs" />
     <Compile Include="BuildCheck\Infrastructure\NullBuildCheckManagerProvider.cs" />
     <Compile Include="BuildCheck\Infrastructure\TracingReporter.cs" />
+    <Compile Include="BuildCheck\Infrastructure\EditorConfig\EditorConfigFile.cs" />
+    <Compile Include="BuildCheck\Infrastructure\EditorConfig\EditorConfigGlobsMatcher.cs" />
+    <Compile Include="BuildCheck\Infrastructure\EditorConfig\EditorConfigParser.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckConfigurationErrorScope.cs" />
     <Compile Include="BuildCheck\OM\BuildCheckDataContext.cs" />
     <Compile Include="BuildCheck\API\BuildAnalyzer.cs" />
     <Compile Include="BuildCheck\API\BuildAnalyzerConfiguration.cs" />
@@ -187,8 +191,10 @@
     <Compile Include="BuildCheck\Logging\IBuildAnalysisLoggingContextFactory.cs" />
     <Compile Include="BuildCheck\OM\EvaluatedPropertiesAnalysisData.cs" />
     <Compile Include="BuildCheck\OM\ParsedItemsAnalysisData.cs" />
+    <Compile Include="BuildCheck\Utilities\Constants.cs" />
     <Compile Include="BuildCheck\Utilities\EnumerableExtensions.cs" />
     <Compile Include="Evaluation\IItemTypeDefinition.cs" />
+    <Compile Include="Evaluation\PropertiesUseTracker.cs" />
     <Compile Include="FileAccess\DesiredAccess.cs" />
     <Compile Include="FileAccess\FileAccessData.cs" />
     <Compile Include="FileAccess\FlagsAndAttributes.cs" />
@@ -197,6 +203,7 @@
     <Compile Include="FileAccess\RequestedAccess.cs" />
     <Compile Include="BuildCheck\Logging\AnalyzerLoggingContext.cs" />
     <Compile Include="BuildCheck\Logging\AnalyzerLoggingContextFactory.cs" />
+    <Compile Include="Instance\IPropertyElementWithLocation.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
@@ -277,14 +284,6 @@
     <Compile Include="BackEnd\Components\SdkResolution\SdkResultFactory.cs" />
     <Compile Include="BackEnd\Node\LoggingNodeConfiguration.cs" />
     <Compile Include="BackEnd\Shared\ConfigurationMetadata.cs" />
-    <Compile Include="Collections\ConcurrentQueueExtensions.cs" />
-    <Compile Include="Collections\ConcurrentStackExtensions.cs" />
-    <Compile Include="Collections\LookasideStringInterner.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\HashSet.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\BitHelper.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\HashSetDebugView.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\IRetrievableEntryHashSet.cs" />
     <Compile Include="Construction\ImplicitImportLocation.cs" />
     <Compile Include="Construction\ProjectSdkElement.cs" />
     <Compile Include="Definition\ProjectOptions.cs" />
@@ -394,6 +393,9 @@
     <Compile Include="BackEnd\TaskExecutionHost\TaskExecutionHost.cs" />
     <!-- #### COLLECTIONS ### -->
     <Compile Include="..\Shared\CollectionHelpers.cs" />
+    <Compile Include="Collections\ArrayDictionary.cs" />
+    <Compile Include="Collections\ConcurrentQueueExtensions.cs" />
+    <Compile Include="Collections\ConcurrentStackExtensions.cs" />
     <Compile Include="Collections\ConvertingEnumerable.cs" />
     <Compile Include="Collections\CopyOnReadEnumerable.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
@@ -403,17 +405,25 @@
     <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
     <Compile Include="Collections\HashTableUtility.cs" />
     <Compile Include="Collections\IConstrainableDictionary.cs" />
+    <Compile Include="Collections\ICopyOnWritePropertyDictionary.cs" />
     <Compile Include="Collections\IItemDictionary.cs" />
+    <Compile Include="Collections\IMultiDictionary.cs" />
     <Compile Include="Collections\ItemDictionary.cs" />
     <Compile Include="Collections\IImmutable.cs" />
     <Compile Include="Collections\MultiDictionary.cs" />
     <Compile Include="Collections\IValued.cs" />
+    <Compile Include="Collections\LookasideStringInterner.cs" />
     <Compile Include="Collections\PropertyDictionary.cs" />
     <Compile Include="..\Shared\ReadOnlyCollection.cs" />
     <Compile Include="Collections\ReadOnlyConvertingDictionary.cs" />
-    <!-- ######################## -->
+    <Compile Include="Collections\RetrievableEntryHashSet\BitHelper.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\HashSetDebugView.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\IRetrievableEntryHashSet.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\IRetrievableValuedEntryHashSet.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\RetrievableEntryHashSet.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\RetrievableValuedEntryHashSet.cs" />
     <Compile Include="Collections\WeakValueDictionary.cs" />
-    <Compile Include="Collections\ArrayDictionary.cs" />
     <!-- #### CONSTRUCTION MODEL ### -->
     <Compile Include="Construction\ProjectElement.cs" />
     <Compile Include="Construction\ProjectElementContainer.cs" />
@@ -528,7 +538,13 @@
     <!-- #### INSTANCE MODEL ### -->
     <Compile Include="Instance\IImmutableInstanceProvider.cs" />
     <Compile Include="Instance\ImmutableProjectCollections\ImmutableElementCollectionConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableGlobalPropertiesCollectionConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableItemDefinitionsListConverter.cs" />
     <Compile Include="Instance\ImmutableProjectCollections\ImmutableItemDictionary.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableLinkedMultiDictionaryConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutablePropertyCollectionConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableStringValuedListConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableValuedElementCollectionConverter.cs" />
     <Compile Include="Instance\ReflectableTaskPropertyInfo.cs" />
     <Compile Include="Instance\HostServices.cs" />
     <Compile Include="Instance\ProjectTargetInstanceChild.cs" />
diff --git a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
index c0165f577a5..4618292cc2d 100644
--- a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
+++ b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Collections.Generic;
+using System.Threading;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -234,18 +235,27 @@ public UsingTaskParameterGroupElement Create(UsingTaskParameterGroupElementLink
 
         #region Linked classes helpers
         // Using the pattern with overloaded classes that provide "Link" object so we ensure we do not increase the
-        // memory storage of original items (with the Link field) while it is small, some of the MSbuild items can be created
+        // memory storage of original items (with the Link field) while it is small, some of the MSBuild items can be created
         // in millions so it does adds up otherwise.
 
         private class LinkedProjectItem : ProjectItem, ILinkableObject, IImmutableInstanceProvider<ProjectItemInstance>
         {
+            private ProjectItemInstance _immutableInstance;
+
             internal LinkedProjectItem(ProjectItemElement xml, Project project, ProjectItemLink link)
                 : base(xml, project)
             {
                 Link = link;
             }
 
-            public ProjectItemInstance ImmutableInstance { get; set; }
+            public ProjectItemInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectItemInstance GetOrSetImmutableInstance(ProjectItemInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
 
             internal override ProjectItemLink Link { get; }
 
@@ -254,32 +264,54 @@ internal LinkedProjectItem(ProjectItemElement xml, Project project, ProjectItemL
 
         private class LinkedProjectItemDefinition : ProjectItemDefinition, ILinkableObject, IImmutableInstanceProvider<ProjectItemDefinitionInstance>
         {
+            private ProjectItemDefinitionInstance _immutableInstance;
+
             internal LinkedProjectItemDefinition(ProjectItemDefinitionLink link, Project project, string itemType)
                 : base(project, itemType)
             {
                 Link = link;
             }
 
-            public ProjectItemDefinitionInstance ImmutableInstance { get; set; }
+            public ProjectItemDefinitionInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectItemDefinitionInstance GetOrSetImmutableInstance(ProjectItemDefinitionInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
 
             internal override ProjectItemDefinitionLink Link { get; }
             object ILinkableObject.Link => Link;
         }
 
-        private class LinkedProjectMetadata : ProjectMetadata, ILinkableObject
+        private class LinkedProjectMetadata : ProjectMetadata, ILinkableObject, IImmutableInstanceProvider<ProjectMetadataInstance>
         {
+            private ProjectMetadataInstance _immutableInstance;
+
             internal LinkedProjectMetadata(object parent, ProjectMetadataLink link)
                 : base(parent, link.Xml)
             {
                 Link = link;
             }
 
+            public ProjectMetadataInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectMetadataInstance GetOrSetImmutableInstance(ProjectMetadataInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
+
             internal override ProjectMetadataLink Link { get; }
             object ILinkableObject.Link => Link;
         }
 
         private class LinkedProjectProperty : ProjectProperty, ILinkableObject, IImmutableInstanceProvider<ProjectPropertyInstance>
         {
+            private ProjectPropertyInstance _immutableInstance;
+
             internal ProjectPropertyLink Link { get; }
             object ILinkableObject.Link => Link;
 
@@ -295,7 +327,14 @@ internal LinkedProjectProperty(Project project, ProjectPropertyLink link)
                 Link = link;
             }
 
-            public ProjectPropertyInstance ImmutableInstance { get; set;  }
+            public ProjectPropertyInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectPropertyInstance GetOrSetImmutableInstance(ProjectPropertyInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
 
             public override string Name => Link.Name;
 
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 62bcd2464c3..c1fd804eefc 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1102,6 +1102,9 @@
   <data name="OutputItemParameterMessagePrefix" xml:space="preserve">
     <value>Output Item(s): </value>
   </data>
+  <data name="OutputPropertyLogMessagePrefix" xml:space="preserve">
+    <value>Output Property: </value>
+  </data>
   <data name="OutputPropertyLogMessage" xml:space="preserve">
     <value>Output Property: {0}={1}</value>
   </data>
@@ -2111,6 +2114,10 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</value>
     <comment>The message is emitted when the custom analyzer assembly can not be found.</comment>
   </data>
+  <data name="CustomAnalyzerBaseTypeNotAssignable" xml:space="preserve">
+    <value>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</value>
+    <comment>The message is emitted when the custom analyzer assembly can not be successfully registered.</comment>
+  </data>
   <data name="TaskAssemblyLocationMismatch" xml:space="preserve">
     <value>Task assembly was loaded from '{0}' while the desired location was '{1}'.</value>
   </data>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 805b9010ea3..18b181ccbed 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -209,22 +209,27 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Nepodařilo se najít zadané sestavení vlastního analyzátoru: {0}. Zkontrolujte prosím, jestli existuje.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Nepodařilo se načíst vlastní typ analyzátoru: {0} ze sestavení: {1}. Ujistěte se, že dědí základní třídu Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Pokud se nemá jednat o vlastní analyzátor, neměl by být odkrytý. Další informace: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Nepodařilo se zaregistrovat vlastní analyzátor: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Nepovedlo se vytvořit instanci pravidla vlastního analyzátoru s následující výjimkou: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Pravidlo vlastního analyzátoru: {0} se úspěšně zaregistrovalo.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -393,6 +398,11 @@
         <target state="translated">Metoda {0} se nedá zavolat s kolekcí, která obsahuje prázdné cílové názvy nebo názvy null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Výstupní vlastnost: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Vytvořilo se přepsání pomocí úlohy: {0} v {1}</target>
@@ -618,7 +628,7 @@ Chyby: {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">Sestavení úlohy bylo načteno z{0}, ale požadované umístění bylo{1}.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index ee28388b3e7..d1939e8c983 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -209,22 +209,27 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Fehler beim Suchen der angegebenen benutzerdefinierten Analysetoolassembly: {0}. Überprüfen Sie, ob sie vorhanden ist.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Fehler beim Laden des benutzerdefinierten Analysetooltyps „{0}“ aus der Assembly „{1}“. Stellen Sie sicher, dass es die Basisklasse „Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer“ erbt. Wenn es sich nicht um ein benutzerdefiniertes Analysetool handelt, sollte es nicht verfügbar gemacht werden. Weitere Informationen: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Fehler beim Registrieren des benutzerdefinierten Analysetools: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Fehler beim Instanziieren der benutzerdefinierten Analysetoolregel mit der folgenden Ausnahme: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Benutzerdefinierte Analysetoolregel {0} wurde erfolgreich registriert.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -393,6 +398,11 @@
         <target state="translated">Die Methode "{0}" kann nicht mit einer Sammlung aufgerufen werden, die NULL oder leere Zielnamen enthält.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Ausgabeeigenschaft: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Außerkraftsetzung mit Task erstellt: {0} bei {1}</target>
@@ -618,7 +628,7 @@ Fehler: {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">Die Aufgabenassembly wurde aus „{0}“ geladen, während der gewünschte Speicherort „{1}“ war.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 257fde173bd..5c249e91567 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -209,22 +209,27 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">No se ha podido encontrar el ensamblado del analizador personalizado especificado: {0}. Compruebe si existe.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">No se pudo cargar el tipo de analizador personalizado: {0} del ensamblado: {1}. Asegúrese de que hereda la clase base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Si no está pensado para ser un analizador personalizado, entonces no debería exponerse. Más información: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">No se ha podido registrar el analizador personalizado: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">No se ha podido crear una instancia de la regla del analizador personalizado con la siguiente excepción: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Regla del analizador personalizado: {0} se ha registrado correctamente.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -393,6 +398,11 @@
         <target state="translated">No se puede llamar al método {0} con una colección que contiene nombres de destino nulos o vacíos.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Propiedad de salida: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Se creó una invalidación mediante la tarea: {0} en {1}</target>
@@ -618,7 +628,7 @@ Errores: {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">El ensamblado de tarea se cargó desde "{0}" mientras que la ubicación deseada era "{1}".</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index c5d61abb801..544d09a28ea 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -209,22 +209,27 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Impossible de trouver l’assemblée d'analyseur personnalisé spécifié : {0}. Vérifiez s’il existe.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Échec du chargement du type d’analyseur personnalisé : {0} à partir de l’assembly : {1}. Assurez-vous qu’il hérite de la classe de base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. S’il ne doit pas être un analyseur personnalisé, il ne doit pas être exposé. Plus d’informations : https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Échec de l’inscription de l’analyseur personnalisé : {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Échec de l’instanciation de la règle d’analyseur personnalisé avec l’exception suivante : {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Règle de l’analyseur personnalisé : {0} a été correctement inscrit.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -393,6 +398,11 @@
         <target state="translated">Impossible d'appeler la méthode {0} avec une collection contenant des noms de cibles qui ont une valeur null ou qui sont vides.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Propriété de sortie : </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Remplacement créé à l’aide de la tâche : {0} au {1}</target>
@@ -618,7 +628,7 @@ Erreurs : {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">L’assembly de tâche a été chargé à partir de « {0} » alors que l’emplacement souhaité était « {1} ».</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 82875aa922e..2242fb24438 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -209,22 +209,27 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Impossibile trovare l'assembly dell'analizzatore personalizzato specificato: {0}. Verificare se esiste.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Non è stato possibile caricare il tipo di analizzatore diagnostico personalizzato: {0} dall'assembly: {1}. Assicurarsi che erediti la classe di base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Se non è destinato a essere un analizzatore personalizzato, non deve essere esposto. Per altre informazioni: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Impossibile registrare l'analizzatore personalizzato: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Impossibile creare un'istanza della regola dell'analizzatore personalizzato con l'eccezione seguente: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Regola dell'analizzatore personalizzato: {0} è stata registrata.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -393,6 +398,11 @@
         <target state="translated">Non è possibile chiamare il metodo {0} con una raccolta contenente nomi di destinazione Null o vuoti.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Proprietà di output: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">È stata creata una sostituzione con l'attività: {0} in {1}</target>
@@ -618,7 +628,7 @@ Errori: {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">L'assembly attività è stato caricato da "{0}" mentre era "{1}" il percorso desiderato.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 745ed6f66cb..f2d35e4d44e 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -209,22 +209,27 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">指定されたカスタム アナライザー アセンブリが見つかりませんでした: {0}。存在するかどうか確認してください。</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">カスタム アナライザーの種類を読み込めませんでした: アセンブリ {1} の {0}。Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基底クラスを継承していることを確認してください。カスタム アナライザーを意図していない場合は、公開しないでください。詳細情報: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">カスタム アナライザーを登録できませんでした: {0}</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">次の例外により、カスタム アナライザー ルールのインスタンスを作成できませんでした: {0}。</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">カスタム アナライザー ルール: {0} が正常に登録されました。</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -393,6 +398,11 @@
         <target state="translated">Null または空のターゲット名を含むコレクションを指定してメソッド {0} を呼び出すことはできません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">プロパティの出力: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">タスクを使用してオーバーライドを作成しました: {1} の {0}</target>
@@ -618,7 +628,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">タスク アセンブリは '{0}' から読み込まれましたが、必要な場所は '{1}' でした。</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index c965e326ed9..b15a7cd0dcf 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -209,22 +209,27 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">지정한 사용자 지정 분석기 어셈블리를 찾지 못했습니다. {0}. 존재하는지 확인하세요.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">사용자 지정 분석기 형식을 로드하지 못했습니다. 어셈블리에서 {0} : {1}. Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 기본 클래스를 상속해야 합니다. 사용자 지정 분석기가 아닌 경우 노출되지 않아야 합니다. 추가 정보: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">사용자 지정 분석기를 등록하지 못했습니다. {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">다음 예외로 인해 사용자 지정 분석기 규칙을 인스턴스화하지 못했습니다. {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">사용자 지정 분석기 규칙: {0}이(가) 등록되었습니다.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -393,6 +398,11 @@
         <target state="translated">null 또는 빈 대상 이름을 포함하는 컬렉션을 사용하여 {0} 메서드를 호출할 수 없습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">출력 속성: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">다음 작업을 사용하여 재정의를 만들었습니다. {1}의 {0}</target>
@@ -618,7 +628,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">원하는 위치가 '{1}'인 동안 '{0}'에서 작업 어셈블리를 로드했습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 34dbe8205e9..57e7834317c 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -209,22 +209,27 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Nie można odnaleźć określonego zestawu analizatora niestandardowego: {0}. Sprawdź, czy istnieje.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Nie udało się załadować niestandardowego analizatora typu: {0} z zestawu: {1}. Upewnij się, że dziedziczy po klasie bazowej Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Jeśli nie jest przeznaczony do niestandardowego analizatora, nie powinien być ujawniany. Więcej informacji: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Nie można zarejestrować analizatora niestandardowego: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Nie można utworzyć wystąpienia niestandardowej reguły analizatora z następującym wyjątkiem: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Niestandardowa reguła analizatora: {0} została pomyślnie zarejestrowana.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -393,6 +398,11 @@
         <target state="translated">Metody {0} nie można wywołać przy użyciu kolekcji zawierającej nazwy docelowe o wartości null lub puste.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Właściwość danych wyjściowych: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Utworzono zastąpienie przy użyciu zadania: {0} o {1}</target>
@@ -618,7 +628,7 @@ Błędy: {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">Zestaw zadania został załadowany z lokalizacji „{0}”, gdy żądana lokalizacja to „{1}”.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 888dcdb0508..70fce9b1272 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -209,22 +209,27 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Falha ao localizar o assembly do analisador personalizado especificado: {0}. Verifique se existe.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Falha ao carregar o tipo de analisador personalizado: {0} do assembly: {1}. Certifique-se de que ele herde a classe base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Se não se destina a ser um analisador personalizado, ele não deve ser exposto. Mais informações: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Falha ao registrar o analisador personalizado: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Falha ao criar uma instância da regra do analisador personalizado com a seguinte exceção: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Regra do analisador personalizado: {0} foi registrado com sucesso.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -393,6 +398,11 @@
         <target state="translated">O método {0} não pode ser chamado com uma coleção que contém nomes de destino nulos ou vazios.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Propriedade de Saída: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Criou uma substituição usando a tarefa: {0} em {1}</target>
@@ -618,7 +628,7 @@ Erros: {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">O assembly da tarefa foi carregado de "{0}" enquanto o local desejado era "{1}".</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 57544712fe8..c57aef79086 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -209,22 +209,27 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Не удалось найти указанную сборку настраиваемого анализатора: {0}. Убедитесь, что она существует.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Не удалось загрузить настраиваемый тип анализатора {0} из сборки {1}. Убедитесь, что он наследует базовый класс Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Если он не предназначен для настраиваемого анализатора, его не следует предоставлять. Дополнительные сведения: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Не удалось зарегистрировать настраиваемый анализатор: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Не удалось создать экземпляр правила настраиваемого анализатора со следующим исключением: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">Зарегистрировано правило настраиваемого анализатора: {0}.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -393,6 +398,11 @@
         <target state="translated">Метод {0} не может быть вызван с коллекцией, содержащей целевые имена, которые пусты или равны NULL.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Выходное свойство: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Создано переопределение с помощью задачи {0} в {1}</target>
@@ -618,7 +628,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">Сборка задачи была загружена из "{0}", а нужное расположение — "{1}".</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 0e42c1af423..cef442b611a 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -209,22 +209,27 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">Belirtilen {0} özel çözümleyici derlemesi bulunamadı. Lütfen var olup olmadığını kontrol edin.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Özel çözümleyici türü yüklenemedi: {0} derlemeden: {1}. Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer temel sınıf devralınmış olduğundan emin olun. Özel bir çözümleyici olması amaçlanmadıysa açığa çıkarılmaması gerekir. Daha fazla bilgi: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">Özel çözümleyici kaydedilemedi: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">Özel çözümleyici kuralı şu özel durumla başlatılamadı: {0}.</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">{0} özel çözümleyici kuralı başarıyla kaydedildi.</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -393,6 +398,11 @@
         <target state="translated">{0} metosu null veya boş hedef adları içeren bir koleksiyonla çağrılamaz.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">Çıkış Özelliği: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">{0} görevi kullanılarak geçersiz kılma işlemi oluşturuldu, saat: {1}</target>
@@ -618,7 +628,7 @@ Hatalar: {3}</target>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">İstenilen konum '{1}' iken görev derlemesi '{0}'dan yüklendi.</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index d23e8334597..f2cd331de9b 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -209,22 +209,27 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">找不到指定的自定义分析器程序集: {0}。请检查它是否存在。</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">未能从程序集 {1} 加载自定义分析器类型 {0}。请确保它继承 Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基类。如果不打算将其作为自定义分析器，则不应将其公开。详细信息: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">无法注册自定义分析器: {0}。</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">无法实例化自定义分析器规则，出现以下异常: {0}。</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">自定义分析器规则: {0} 已成功注册。</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -393,6 +398,11 @@
         <target state="translated">无法使用包含 null 或空目标名称的集合调用方法 {0}。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">输出属性: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">已使用任务创建替代: {0} 位于 {1}</target>
@@ -618,7 +628,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">已从“{0}”加载任务程序集，但所需位置为“{1}”。</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index f6f3cff5721..8a8c9980020 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -209,22 +209,27 @@
       </trans-unit>
       <trans-unit id="CustomAnalyzerAssemblyNotExist">
         <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="new">Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</target>
+        <target state="translated">找不到指定的自訂分析器組件: {0}。請檢查它是否存在。</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">無法從組件 {1} 載入自訂分析器類型 {0}。請確定它繼承 Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基類。如果不是要作為自訂分析器，則不應公開。更多資訊: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="new">Failed to register the custom analyzer: {0}.</target>
+        <target state="translated">無法登錄自訂分析器: {0}。</target>
         <note>The message is emitted on failed loading of the custom analyzer in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedRuleLoading">
         <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="new">Failed to instantiate the custom analyzer rule with the following exception: {0}.</target>
+        <target state="translated">無法具現化自訂分析器規則，發生下列例外狀況: {0}。</target>
         <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="new">Custom analyzer rule: {0} has been registered successfully.</target>
+        <target state="translated">自訂分析器規則: 已成功登錄 {0}。</target>
         <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
@@ -393,6 +398,11 @@
         <target state="translated">無法使用內含 null 或空白目標名稱的集合呼叫方法 {0}。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="translated">輸出屬性: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">已使用下列工作建立覆寫: 於 {1} 的 {0}</target>
@@ -618,7 +628,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="TaskAssemblyLocationMismatch">
         <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
-        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <target state="translated">工作組件已從 '{0}' 載入，但 '{1}' 才是所需的位置。</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskReleasedCores">
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index 67b454cc023..e8bf893be60 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -462,11 +462,11 @@ private static bool UsingDifferentToolsVersionFromProjectFile(string toolsVersio
         /// Retrieves properties derived from the current
         /// environment variables.
         /// </summary>
-        internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProperties()
+        internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProperties(bool makeReadOnly)
         {
             IDictionary<string, string> environmentVariablesBag = CommunicationsUtilities.GetEnvironmentVariables();
 
-            PropertyDictionary<ProjectPropertyInstance> environmentProperties = new PropertyDictionary<ProjectPropertyInstance>(environmentVariablesBag.Count + 2);
+            var envPropertiesHashSet = new RetrievableValuedEntryHashSet<ProjectPropertyInstance>(environmentVariablesBag.Count + 2, MSBuildNameIgnoreCaseComparer.Default);
 
             // We set the MSBuildExtensionsPath variables here because we don't want to make them official
             // reserved properties; we need the ability for people to override our default in their
@@ -483,11 +483,11 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                                           ? Path.Combine(programFiles32, ReservedPropertyNames.extensionsPathSuffix)
                                           : programFiles32;
 #endif
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath32, extensionsPath32, true));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath32, extensionsPath32, true));
 
 #if !FEATURE_INSTALLED_MSBUILD
             string extensionsPath64 = extensionsPath;
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
 #else
             // "MSBuildExtensionsPath64". This points to whatever the value of "Program Files" environment variable is on a
             // 64-bit machine, and is empty on a 32-bit machine.
@@ -500,7 +500,7 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                                                   FrameworkLocationHelper.programFiles64,
                                                   ReservedPropertyNames.extensionsPathSuffix)
                                               : FrameworkLocationHelper.programFiles64;
-                environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
+                envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
             }
 #endif
 
@@ -523,13 +523,13 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
             }
 #endif
 
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath, extensionsPath, true));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath, extensionsPath, true));
 
             // Windows XP and Windows Server 2003 don't define LocalAppData in their environment.
             // We'll set it here if the environment doesn't have it so projects can reliably
             // depend on $(LocalAppData).
             string localAppData = String.Empty;
-            ProjectPropertyInstance localAppDataProp = environmentProperties.GetProperty(ReservedPropertyNames.localAppData);
+            ProjectPropertyInstance localAppDataProp = envPropertiesHashSet.Get(ReservedPropertyNames.localAppData);
             if (localAppDataProp != null)
             {
                 localAppData = localAppDataProp.EvaluatedValue;
@@ -551,11 +551,11 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
             }
 
 
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.localAppData, localAppData));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.localAppData, localAppData));
 
             // Add MSBuildUserExtensionsPath at $(LocalAppData)\Microsoft\MSBuild
             string userExtensionsPath = Path.Combine(localAppData, ReservedPropertyNames.userExtensionsPathSuffix);
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.userExtensionsPath, userExtensionsPath));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.userExtensionsPath, userExtensionsPath));
 
             foreach (KeyValuePair<string, string> environmentVariable in environmentVariablesBag)
             {
@@ -570,7 +570,7 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                 {
                     ProjectPropertyInstance environmentProperty = ProjectPropertyInstance.Create(environmentVariableName, environmentVariable.Value);
 
-                    environmentProperties.Set(environmentProperty);
+                    envPropertiesHashSet.Add(environmentProperty);
                 }
                 else
                 {
@@ -579,6 +579,12 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                 }
             }
 
+            if (makeReadOnly)
+            {
+                envPropertiesHashSet.MakeReadOnly();
+            }
+
+            var environmentProperties = new PropertyDictionary<ProjectPropertyInstance>(envPropertiesHashSet);
             return environmentProperties;
         }
 
diff --git a/src/BuildCheck.UnitTests/AssemblyInfo.cs b/src/BuildCheck.UnitTests/AssemblyInfo.cs
index 3b5d7bbb185..5b383e24105 100644
--- a/src/BuildCheck.UnitTests/AssemblyInfo.cs
+++ b/src/BuildCheck.UnitTests/AssemblyInfo.cs
@@ -2,3 +2,13 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
+
+namespace Microsoft.Build.UnitTests.Shared;
+
+[System.AttributeUsage(System.AttributeTargets.Assembly)]
+internal sealed class BootstrapLocationAttribute(string bootstrapRoot, string bootstrapMsbuildBinaryLocation)
+    : System.Attribute
+{
+    public string BootstrapRoot { get; } = bootstrapRoot;
+    public string BootstrapMsbuildBinaryLocation { get; } = bootstrapMsbuildBinaryLocation;
+}
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
index 248b66ea6b0..7bd57f8014b 100644
--- a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
+++ b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
@@ -1,13 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Xunit;
-using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
 using Shouldly;
 
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
new file mode 100644
index 00000000000..edfdfaf4589
--- /dev/null
+++ b/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
@@ -0,0 +1,113 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class BuildAnalyzerConfiguration_Test
+{
+    [Fact]
+    public void CreateWithNull_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = BuildAnalyzerConfiguration.Create(null);
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Fact]
+    public void CreateWithEmpty_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = BuildAnalyzerConfiguration.Create(new Dictionary<string, string>());
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("error", BuildAnalyzerResultSeverity.Error)]
+    [InlineData("info", BuildAnalyzerResultSeverity.Info)]
+    [InlineData("warning", BuildAnalyzerResultSeverity.Warning)]
+    [InlineData("WARNING", BuildAnalyzerResultSeverity.Warning)]
+    public void CreateBuildAnalyzerConfiguration_Severity(string parameter, BuildAnalyzerResultSeverity? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "severity" , parameter },
+        };
+        var buildConfig = BuildAnalyzerConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBe(expected);
+
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("true", true)]
+    [InlineData("TRUE", true)]
+    [InlineData("false", false)]
+    [InlineData("FALSE", false)]
+    public void CreateBuildAnalyzerConfiguration_IsEnabled(string parameter, bool? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "isenabled" , parameter },
+        };
+
+        var buildConfig = BuildAnalyzerConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.IsEnabled.ShouldBe(expected);
+
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("ProjectOnly", EvaluationAnalysisScope.ProjectOnly)]
+    [InlineData("ProjectWithImportsFromCurrentWorkTree", EvaluationAnalysisScope.ProjectWithImportsFromCurrentWorkTree)]
+    [InlineData("ProjectWithImportsWithoutSdks", EvaluationAnalysisScope.ProjectWithImportsWithoutSdks)]
+    [InlineData("ProjectWithAllImports", EvaluationAnalysisScope.ProjectWithAllImports)]
+    [InlineData("projectwithallimports", EvaluationAnalysisScope.ProjectWithAllImports)]
+    public void CreateBuildAnalyzerConfiguration_EvaluationAnalysisScope(string parameter, EvaluationAnalysisScope? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "evaluationanalysisscope" , parameter },
+        };
+
+        var buildConfig = BuildAnalyzerConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBe(expected);
+
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.Severity.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("evaluationanalysisscope", "incorrec-value")]
+    [InlineData("isenabled", "incorrec-value")]
+    [InlineData("severity", "incorrec-value")]
+    public void CreateBuildAnalyzerConfiguration_ExceptionOnInvalidInputValue(string key, string value)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { key , value },
+        };
+
+        var exception = Should.Throw<BuildCheckConfigurationException>(() => {
+            BuildAnalyzerConfiguration.Create(config);
+        });
+        exception.Message.ShouldContain($"Incorrect value provided in config for key {key}");
+    }
+}
diff --git a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
index 1518241d42f..bf1ccb8105a 100644
--- a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
+++ b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
@@ -5,8 +5,8 @@
 using System.Linq;
 using System.Reflection;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.BuildCheck.Acquisition;
-using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Acquisition;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
@@ -14,7 +14,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using static Microsoft.Build.BuildCheck.Infrastructure.BuildCheckManagerProvider;
+using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.BuildCheckManagerProvider;
 
 namespace Microsoft.Build.BuildCheck.UnitTests;
 
diff --git a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
new file mode 100644
index 00000000000..d559e1724b1
--- /dev/null
+++ b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
@@ -0,0 +1,221 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class ConfigurationProvider_Tests
+{
+    [Fact]
+    public void GetRuleIdConfiguration_ReturnsEmptyConfig()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        test_key=test_value_updated
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var configs = configurationProvider.GetConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // empty
+        configs.ShouldBe(new Dictionary<string, string>());
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_ReturnsConfiguration()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var configs = configurationProvider.GetConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        configs.Keys.Count.ShouldBe(2);
+
+        configs.ContainsKey("property1").ShouldBeTrue();
+        configs.ContainsKey("property2").ShouldBeTrue();
+
+        configs["property2"].ShouldBe("value2");
+        configs["property1"].ShouldBe("value1");
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationData()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+        any_other_key1=any_other_value1
+        any_other_key2=any_other_value2
+        any_other_key3=any_other_value3
+        any_other_key3=any_other_value3
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var customConfiguration = configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+        var configs = customConfiguration.ConfigurationData;
+
+        configs!.Keys.Count().ShouldBe(3);
+
+        configs.ContainsKey("property1").ShouldBeTrue();
+        configs.ContainsKey("property2").ShouldBeTrue();
+        configs.ContainsKey("isenabled2").ShouldBeTrue();
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_ReturnsBuildRuleConfiguration()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.Severity=Error
+        build_check.rule_id.EvaluationAnalysisScope=ProjectOnly
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var buildConfig = configurationProvider.GetUserConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        buildConfig.ShouldNotBeNull();
+
+        buildConfig.IsEnabled?.ShouldBeTrue();
+        buildConfig.Severity?.ShouldBe(BuildAnalyzerResultSeverity.Error);
+        buildConfig.EvaluationAnalysisScope?.ShouldBe(EvaluationAnalysisScope.ProjectOnly);
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationValidity_NotValid_DifferentValues()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+
+        [test123.csproj]
+        build_check.rule_id.property1=value2
+        build_check.rule_id.property2=value3
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=tru1
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // should not fail => configurations are the same
+        Should.Throw<BuildCheckConfigurationException>(() =>
+        {
+            configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
+        });
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationValidity_NotValid_DifferentKeys()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled2=true
+
+        [test123.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled2=true
+        build_check.rule_id.isEnabled3=true
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // should not fail => configurations are the same
+        Should.Throw<BuildCheckConfigurationException>(() =>
+        {
+            configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
+        });
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationValidity_Valid()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+
+        [test123.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // should fail, because the configs are the different
+        Should.NotThrow(() =>
+        {
+            configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
+        });
+    }
+}
diff --git a/src/BuildCheck.UnitTests/CustomConfigurationData_Tests.cs b/src/BuildCheck.UnitTests/CustomConfigurationData_Tests.cs
new file mode 100644
index 00000000000..e8ff337e1a8
--- /dev/null
+++ b/src/BuildCheck.UnitTests/CustomConfigurationData_Tests.cs
@@ -0,0 +1,140 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class CustomConfigurationData_Tests
+{
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_NullInstance()
+    {
+        var customConfigurationData1 = CustomConfigurationData.Null;
+        var customConfigurationData2 = CustomConfigurationData.Null;
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_SameInstance()
+    {
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId");
+        var customConfigurationData2 = customConfigurationData1;
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_DifferentObjectType()
+    {
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId");
+        var customConfigurationData2 = new object();
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_DifferentInstanceSameValues()
+    {
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId");
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId");
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_CustomConfigDataSame()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferent()
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId");
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferentKeys()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key2", "val2" }
+        };
+
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferentValues()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key1", "val2" }
+        };
+
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_CustomConfigDataKeysOrderDiffers()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" },
+            { "key2", "val2" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key2", "val2" },
+            { "key1", "val1" }
+        };
+
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+}
diff --git a/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs b/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs
new file mode 100644
index 00000000000..17bd60abbd1
--- /dev/null
+++ b/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs
@@ -0,0 +1,119 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class EditorConfigParser_Tests
+{
+    [Fact]
+    public void NoSectionConfigured_ResultsEmptyResultConfig()
+    {
+        var configs = new List<EditorConfigFile>(){
+            EditorConfigFile.Parse(""""
+                    property1=value1
+""""),
+            EditorConfigFile.Parse(""""
+                property1=value2
+                """"),
+            EditorConfigFile.Parse(""""
+                property1=value3
+                """"),
+        };
+
+        var parser = new EditorConfigParser();
+        var mergedResult = parser.MergeEditorConfigFiles(configs, "/some/path/to/file");
+        mergedResult.Keys.Count.ShouldBe(0);
+    }
+
+    [Fact]
+    public void ProperOrderOfconfiguration_ClosestToTheFileShouldBeApplied()
+    {
+        var configs = new List<EditorConfigFile>(){
+            EditorConfigFile.Parse(""""
+                    [*]
+                    property1=value1
+""""),
+            EditorConfigFile.Parse(""""
+                [*]
+                property1=value2
+                """"),
+            EditorConfigFile.Parse(""""
+                [*]
+                property1=value3
+                """"),
+        };
+
+        var parser = new EditorConfigParser();
+        var mergedResult = parser.MergeEditorConfigFiles(configs, "/some/path/to/file.proj");
+        mergedResult.Keys.Count.ShouldBe(1);
+        mergedResult["property1"].ShouldBe("value1");
+    }
+
+    [Fact]
+    public void EditorconfigFileDiscovery_RootTrue()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFolder workFolder2 = testEnvironment.CreateFolder(Path.Combine(workFolder1.Path, "subfolder"), createFolder: true);
+
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder2, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        test_key=test_value_updated
+        """);
+
+
+        TransientTestFile config2 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        [*.csproj]
+        test_key=should_not_be_respected_and_parsed
+        """);
+
+        var parser = new EditorConfigParser();
+        var listOfEditorConfigFile = parser.DiscoverEditorConfigFiles(Path.Combine(workFolder1.Path, "subfolder", "projectfile.proj") ).ToList();
+        // should be one because root=true so we do not need to go further
+        listOfEditorConfigFile.Count.ShouldBe(1);
+        listOfEditorConfigFile[0].IsRoot.ShouldBeTrue();
+        listOfEditorConfigFile[0].NamedSections[0].Name.ShouldBe("*.csproj");
+        listOfEditorConfigFile[0].NamedSections[0].Properties["test_key"].ShouldBe("test_value_updated");
+    }
+
+    [Fact]
+    public void EditorconfigFileDiscovery_RootFalse()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFolder workFolder2 = testEnvironment.CreateFolder(Path.Combine(workFolder1.Path, "subfolder"), createFolder: true);
+
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder2, ".editorconfig",
+        """
+        [*.csproj]
+        test_key=test_value_updated
+        """);
+
+        TransientTestFile config2 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        [*.csproj]
+        test_key=will_be_there
+        """);
+
+        var parser = new EditorConfigParser();
+        var listOfEditorConfigFile = parser.DiscoverEditorConfigFiles(Path.Combine(workFolder1.Path, "subfolder", "projectfile.proj")).ToList();
+
+        listOfEditorConfigFile.Count.ShouldBe(2);
+        listOfEditorConfigFile[0].IsRoot.ShouldBeFalse();
+        listOfEditorConfigFile[0].NamedSections[0].Name.ShouldBe("*.csproj");
+    }
+}
diff --git a/src/BuildCheck.UnitTests/EditorConfig_Tests.cs b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
new file mode 100644
index 00000000000..1b1b0c5aaa4
--- /dev/null
+++ b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
@@ -0,0 +1,1078 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Reflection;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+using Xunit;
+using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
+
+#nullable disable
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class EditorConfig_Tests
+{
+
+    #region AssertEqualityComparer<T>
+    private sealed class AssertEqualityComparer<T> : IEqualityComparer<T>
+    {
+        public static readonly IEqualityComparer<T> Instance = new AssertEqualityComparer<T>();
+
+        private static bool CanBeNull()
+        {
+            var type = typeof(T);
+            return !type.GetTypeInfo().IsValueType ||
+                (type.GetTypeInfo().IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>));
+        }
+
+        public static bool IsNull(T @object)
+        {
+            if (!CanBeNull())
+            {
+                return false;
+            }
+
+            return object.Equals(@object, default(T));
+        }
+
+        public static bool Equals(T left, T right)
+        {
+            return Instance.Equals(left, right);
+        }
+
+        bool IEqualityComparer<T>.Equals(T x, T y)
+        {
+            if (CanBeNull())
+            {
+                if (object.Equals(x, default(T)))
+                {
+                    return object.Equals(y, default(T));
+                }
+
+                if (object.Equals(y, default(T)))
+                {
+                    return false;
+                }
+            }
+
+            if (x.GetType() != y.GetType())
+            {
+                return false;
+            }
+
+            if (x is IEquatable<T> equatable)
+            {
+                return equatable.Equals(y);
+            }
+
+            if (x is IComparable<T> comparableT)
+            {
+                return comparableT.CompareTo(y) == 0;
+            }
+
+            if (x is IComparable comparable)
+            {
+                return comparable.CompareTo(y) == 0;
+            }
+
+            var enumerableX = x as IEnumerable;
+            var enumerableY = y as IEnumerable;
+
+            if (enumerableX != null && enumerableY != null)
+            {
+                var enumeratorX = enumerableX.GetEnumerator();
+                var enumeratorY = enumerableY.GetEnumerator();
+
+                while (true)
+                {
+                    bool hasNextX = enumeratorX.MoveNext();
+                    bool hasNextY = enumeratorY.MoveNext();
+
+                    if (!hasNextX || !hasNextY)
+                    {
+                        return hasNextX == hasNextY;
+                    }
+
+                    if (!Equals(enumeratorX.Current, enumeratorY.Current))
+                    {
+                        return false;
+                    }
+                }
+            }
+
+            return object.Equals(x, y);
+        }
+
+        int IEqualityComparer<T>.GetHashCode(T obj)
+        {
+            throw new NotImplementedException();
+        }
+    }
+
+    #endregion
+
+    // Section Matchin Test cases: https://github.com/dotnet/roslyn/blob/ba163e712b01358a217065eec8a4a82f94a7efd5/src/Compilers/Core/CodeAnalysisTest/Analyzers/AnalyzerConfigTests.cs#L337
+    #region Section Matching Tests
+    [Fact]
+    public void SimpleNameMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc").Value;
+        Assert.Equal("^.*/abc$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc"));
+        Assert.False(matcher.IsMatch("/aabc"));
+        Assert.False(matcher.IsMatch("/ abc"));
+        Assert.False(matcher.IsMatch("/cabc"));
+    }
+
+    [Fact]
+    public void StarOnlyMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("*").Value;
+        Assert.Equal("^.*/[^/]*$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc"));
+        Assert.True(matcher.IsMatch("/123"));
+        Assert.True(matcher.IsMatch("/abc/123"));
+    }
+
+    [Fact]
+    public void StarNameMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("*.cs").Value;
+        Assert.Equal("^.*/[^/]*\\.cs$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/123.cs"));
+        Assert.True(matcher.IsMatch("/dir/subpath.cs"));
+        // Only '/' is defined as a directory separator, so the caller
+        // is responsible for converting any other machine directory
+        // separators to '/' before matching
+        Assert.True(matcher.IsMatch("/dir\\subpath.cs"));
+
+        Assert.False(matcher.IsMatch("/abc.vb"));
+    }
+
+    [Fact]
+    public void StarStarNameMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("**.cs").Value;
+        Assert.Equal("^.*/.*\\.cs$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/dir/subpath.cs"));
+    }
+
+    [Fact]
+    public void EscapeDot()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("...").Value;
+        Assert.Equal("^.*/\\.\\.\\.$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/..."));
+        Assert.True(matcher.IsMatch("/subdir/..."));
+        Assert.False(matcher.IsMatch("/aaa"));
+        Assert.False(matcher.IsMatch("/???"));
+        Assert.False(matcher.IsMatch("/abc"));
+    }
+
+    [Fact]
+    public void EndBackslashMatch()
+    {
+        SectionNameMatcher? matcher = TryCreateSectionNameMatcher("abc\\");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void QuestionMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab?def").Value;
+        Assert.Equal("^.*/ab.def$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abcdef"));
+        Assert.True(matcher.IsMatch("/ab?def"));
+        Assert.True(matcher.IsMatch("/abzdef"));
+        Assert.True(matcher.IsMatch("/ab/def"));
+        Assert.True(matcher.IsMatch("/ab\\def"));
+    }
+
+    [Fact]
+    public void LiteralBackslash()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab\\\\c").Value;
+        Assert.Equal("^.*/ab\\\\c$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/ab\\c"));
+        Assert.False(matcher.IsMatch("/ab/c"));
+        Assert.False(matcher.IsMatch("/ab\\\\c"));
+    }
+
+    [Fact]
+    public void LiteralStars()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("\\***\\*\\**").Value;
+        Assert.Equal("^.*/\\*.*\\*\\*[^/]*$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/*ab/cd**efg*"));
+        Assert.False(matcher.IsMatch("/ab/cd**efg*"));
+        Assert.False(matcher.IsMatch("/*ab/cd*efg*"));
+        Assert.False(matcher.IsMatch("/*ab/cd**ef/gh"));
+    }
+
+    [Fact]
+    public void LiteralQuestions()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("\\??\\?*\\??").Value;
+        Assert.Equal("^.*/\\?.\\?[^/]*\\?.$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/?a?cde?f"));
+        Assert.True(matcher.IsMatch("/???????f"));
+        Assert.False(matcher.IsMatch("/aaaaaaaa"));
+        Assert.False(matcher.IsMatch("/aa?cde?f"));
+        Assert.False(matcher.IsMatch("/?a?cdexf"));
+        Assert.False(matcher.IsMatch("/?axcde?f"));
+    }
+
+    [Fact]
+    public void LiteralBraces()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc\\{\\}def").Value;
+        Assert.Equal(@"^.*/abc\{}def$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc{}def"));
+        Assert.True(matcher.IsMatch("/subdir/abc{}def"));
+        Assert.False(matcher.IsMatch("/abcdef"));
+        Assert.False(matcher.IsMatch("/abc}{def"));
+    }
+
+    [Fact]
+    public void LiteralComma()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc\\,def").Value;
+        Assert.Equal("^.*/abc,def$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc,def"));
+        Assert.True(matcher.IsMatch("/subdir/abc,def"));
+        Assert.False(matcher.IsMatch("/abcdef"));
+        Assert.False(matcher.IsMatch("/abc\\,def"));
+        Assert.False(matcher.IsMatch("/abc`def"));
+    }
+
+    [Fact]
+    public void SimpleChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("*.{cs,vb,fs}").Value;
+        Assert.Equal("^.*/[^/]*\\.(?:cs|vb|fs)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/abc.vb"));
+        Assert.True(matcher.IsMatch("/abc.fs"));
+        Assert.True(matcher.IsMatch("/subdir/abc.cs"));
+        Assert.True(matcher.IsMatch("/subdir/abc.vb"));
+        Assert.True(matcher.IsMatch("/subdir/abc.fs"));
+
+        Assert.False(matcher.IsMatch("/abcxcs"));
+        Assert.False(matcher.IsMatch("/abcxvb"));
+        Assert.False(matcher.IsMatch("/abcxfs"));
+        Assert.False(matcher.IsMatch("/subdir/abcxcs"));
+        Assert.False(matcher.IsMatch("/subdir/abcxcb"));
+        Assert.False(matcher.IsMatch("/subdir/abcxcs"));
+    }
+
+    [Fact]
+    public void OneChoiceHasSlashes()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{*.cs,subdir/test.vb}").Value;
+        // This is an interesting case that may be counterintuitive.  A reasonable understanding
+        // of the section matching could interpret the choice as generating multiple identical
+        // sections, so [{a, b, c}] would be equivalent to [a] ... [b] ... [c] with all of the
+        // same properties in each section. This is somewhat true, but the rules of how the matching
+        // prefixes are constructed violate this assumption because they are defined as whether or
+        // not a section contains a slash, not whether any of the choices contain a slash. So while
+        // [*.cs] usually translates into '**/*.cs' because it contains no slashes, the slashes in
+        // the second choice make this into '/*.cs', effectively matching only files in the root
+        // directory of the match, instead of all subdirectories.
+        Assert.Equal("^/(?:[^/]*\\.cs|subdir/test\\.vb)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/test.cs"));
+        Assert.True(matcher.IsMatch("/subdir/test.vb"));
+
+        Assert.False(matcher.IsMatch("/subdir/test.cs"));
+        Assert.False(matcher.IsMatch("/subdir/subdir/test.vb"));
+        Assert.False(matcher.IsMatch("/test.vb"));
+    }
+
+    [Fact]
+    public void EmptyChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{}").Value;
+        Assert.Equal("^.*/(?:)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/"));
+        Assert.True(matcher.IsMatch("/subdir/"));
+        Assert.False(matcher.IsMatch("/."));
+        Assert.False(matcher.IsMatch("/anything"));
+    }
+
+    [Fact]
+    public void SingleChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{*.cs}").Value;
+        Assert.Equal("^.*/(?:[^/]*\\.cs)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/test.cs"));
+        Assert.True(matcher.IsMatch("/subdir/test.cs"));
+        Assert.False(matcher.IsMatch("test.vb"));
+        Assert.False(matcher.IsMatch("testxcs"));
+    }
+
+    [Fact]
+    public void UnmatchedBraces()
+    {
+        SectionNameMatcher? matcher = TryCreateSectionNameMatcher("{{{{}}");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CommaOutsideBraces()
+    {
+        SectionNameMatcher? matcher = TryCreateSectionNameMatcher("abc,def");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void RecursiveChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{test{.cs,.vb},other.{a{bb,cc}}}").Value;
+        Assert.Equal("^.*/(?:test(?:\\.cs|\\.vb)|other\\.(?:a(?:bb|cc)))$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/test.cs"));
+        Assert.True(matcher.IsMatch("/test.vb"));
+        Assert.True(matcher.IsMatch("/subdir/test.cs"));
+        Assert.True(matcher.IsMatch("/subdir/test.vb"));
+        Assert.True(matcher.IsMatch("/other.abb"));
+        Assert.True(matcher.IsMatch("/other.acc"));
+
+        Assert.False(matcher.IsMatch("/test.fs"));
+        Assert.False(matcher.IsMatch("/other.bbb"));
+        Assert.False(matcher.IsMatch("/other.ccc"));
+        Assert.False(matcher.IsMatch("/subdir/other.bbb"));
+        Assert.False(matcher.IsMatch("/subdir/other.ccc"));
+    }
+
+    [Fact]
+    public void DashChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab{-}cd{-,}ef").Value;
+        Assert.Equal("^.*/ab(?:-)cd(?:-|)ef$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/ab-cd-ef"));
+        Assert.True(matcher.IsMatch("/ab-cdef"));
+
+        Assert.False(matcher.IsMatch("/abcdef"));
+        Assert.False(matcher.IsMatch("/ab--cd-ef"));
+        Assert.False(matcher.IsMatch("/ab--cd--ef"));
+    }
+
+    [Fact]
+    public void MiddleMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab{cs,vb,fs}cd").Value;
+        Assert.Equal("^.*/ab(?:cs|vb|fs)cd$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abcscd"));
+        Assert.True(matcher.IsMatch("/abvbcd"));
+        Assert.True(matcher.IsMatch("/abfscd"));
+
+        Assert.False(matcher.IsMatch("/abcs"));
+        Assert.False(matcher.IsMatch("/abcd"));
+        Assert.False(matcher.IsMatch("/vbcd"));
+    }
+
+    private static IEnumerable<(string, string)> RangeAndInverse(string s1, string s2)
+    {
+        yield return (s1, s2);
+        yield return (s2, s1);
+    }
+
+    [Fact]
+    public void NumberMatch()
+    {
+        foreach (var (i1, i2) in RangeAndInverse("0", "10"))
+        {
+            var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
+
+            Assert.True(matcher.IsMatch("/0"));
+            Assert.True(matcher.IsMatch("/10"));
+            Assert.True(matcher.IsMatch("/5"));
+            Assert.True(matcher.IsMatch("/000005"));
+            Assert.False(matcher.IsMatch("/-1"));
+            Assert.False(matcher.IsMatch("/-00000001"));
+            Assert.False(matcher.IsMatch("/11"));
+        }
+    }
+
+    [Fact]
+    public void NumberMatchNegativeRange()
+    {
+        foreach (var (i1, i2) in RangeAndInverse("-10", "0"))
+        {
+            var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
+
+            Assert.True(matcher.IsMatch("/0"));
+            Assert.True(matcher.IsMatch("/-10"));
+            Assert.True(matcher.IsMatch("/-5"));
+            Assert.False(matcher.IsMatch("/1"));
+            Assert.False(matcher.IsMatch("/-11"));
+            Assert.False(matcher.IsMatch("/--0"));
+        }
+    }
+
+    [Fact]
+    public void NumberMatchNegToPos()
+    {
+        foreach (var (i1, i2) in RangeAndInverse("-10", "10"))
+        {
+            var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
+
+            Assert.True(matcher.IsMatch("/0"));
+            Assert.True(matcher.IsMatch("/-5"));
+            Assert.True(matcher.IsMatch("/5"));
+            Assert.True(matcher.IsMatch("/-10"));
+            Assert.True(matcher.IsMatch("/10"));
+            Assert.False(matcher.IsMatch("/-11"));
+            Assert.False(matcher.IsMatch("/11"));
+            Assert.False(matcher.IsMatch("/--0"));
+        }
+    }
+
+    [Fact]
+    public void MultipleNumberRanges()
+    {
+        foreach (var matchString in new[] { "a{-10..0}b{0..10}", "a{0..-10}b{10..0}" })
+        {
+            var matcher = TryCreateSectionNameMatcher(matchString).Value;
+
+            Assert.True(matcher.IsMatch("/a0b0"));
+            Assert.True(matcher.IsMatch("/a-5b0"));
+            Assert.True(matcher.IsMatch("/a-5b5"));
+            Assert.True(matcher.IsMatch("/a-5b10"));
+            Assert.True(matcher.IsMatch("/a-10b10"));
+            Assert.True(matcher.IsMatch("/a-10b0"));
+            Assert.True(matcher.IsMatch("/a-0b0"));
+            Assert.True(matcher.IsMatch("/a-0b-0"));
+
+            Assert.False(matcher.IsMatch("/a-11b10"));
+            Assert.False(matcher.IsMatch("/a-11b10"));
+            Assert.False(matcher.IsMatch("/a-10b11"));
+        }
+    }
+
+    [Fact]
+    public void BadNumberRanges()
+    {
+        var matcherOpt = TryCreateSectionNameMatcher("{0..");
+
+        Assert.Null(matcherOpt);
+
+        var matcher = TryCreateSectionNameMatcher("{0..}").Value;
+
+        Assert.True(matcher.IsMatch("/0.."));
+        Assert.False(matcher.IsMatch("/0"));
+        Assert.False(matcher.IsMatch("/0."));
+        Assert.False(matcher.IsMatch("/0abc"));
+
+        matcher = TryCreateSectionNameMatcher("{0..A}").Value;
+        Assert.True(matcher.IsMatch("/0..A"));
+        Assert.False(matcher.IsMatch("/0"));
+        Assert.False(matcher.IsMatch("/0abc"));
+
+        // The reference implementation uses atoi here so we can presume
+        // numbers out of range of Int32 are not well supported
+        matcherOpt = TryCreateSectionNameMatcher($"{{0..{UInt32.MaxValue}}}");
+
+        Assert.Null(matcherOpt);
+    }
+
+    [Fact]
+    public void CharacterClassSimple()
+    {
+        var matcher = TryCreateSectionNameMatcher("*.[cf]s").Value;
+        Assert.Equal(@"^.*/[^/]*\.[cf]s$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/abc.fs"));
+        Assert.False(matcher.IsMatch("/abc.vs"));
+    }
+
+    [Fact]
+    public void CharacterClassNegative()
+    {
+        var matcher = TryCreateSectionNameMatcher("*.[!cf]s").Value;
+        Assert.Equal(@"^.*/[^/]*\.[^cf]s$", matcher.Regex.ToString());
+
+        Assert.False(matcher.IsMatch("/abc.cs"));
+        Assert.False(matcher.IsMatch("/abc.fs"));
+        Assert.True(matcher.IsMatch("/abc.vs"));
+        Assert.True(matcher.IsMatch("/abc.xs"));
+        Assert.False(matcher.IsMatch("/abc.vxs"));
+    }
+
+    [Fact]
+    public void CharacterClassCaret()
+    {
+        var matcher = TryCreateSectionNameMatcher("*.[^cf]s").Value;
+        Assert.Equal(@"^.*/[^/]*\.[\^cf]s$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/abc.fs"));
+        Assert.True(matcher.IsMatch("/abc.^s"));
+        Assert.False(matcher.IsMatch("/abc.vs"));
+        Assert.False(matcher.IsMatch("/abc.xs"));
+        Assert.False(matcher.IsMatch("/abc.vxs"));
+    }
+
+    [Fact]
+    public void CharacterClassRange()
+    {
+        var matcher = TryCreateSectionNameMatcher("[0-9]x").Value;
+        Assert.Equal("^.*/[0-9]x$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/0x"));
+        Assert.True(matcher.IsMatch("/1x"));
+        Assert.True(matcher.IsMatch("/9x"));
+        Assert.False(matcher.IsMatch("/yx"));
+        Assert.False(matcher.IsMatch("/00x"));
+    }
+
+    [Fact]
+    public void CharacterClassNegativeRange()
+    {
+        var matcher = TryCreateSectionNameMatcher("[!0-9]x").Value;
+        Assert.Equal("^.*/[^0-9]x$", matcher.Regex.ToString());
+
+        Assert.False(matcher.IsMatch("/0x"));
+        Assert.False(matcher.IsMatch("/1x"));
+        Assert.False(matcher.IsMatch("/9x"));
+        Assert.True(matcher.IsMatch("/yx"));
+        Assert.False(matcher.IsMatch("/00x"));
+    }
+
+    [Fact]
+    public void CharacterClassRangeAndChoice()
+    {
+        var matcher = TryCreateSectionNameMatcher("[ab0-9]x").Value;
+        Assert.Equal("^.*/[ab0-9]x$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/ax"));
+        Assert.True(matcher.IsMatch("/bx"));
+        Assert.True(matcher.IsMatch("/0x"));
+        Assert.True(matcher.IsMatch("/1x"));
+        Assert.True(matcher.IsMatch("/9x"));
+        Assert.False(matcher.IsMatch("/yx"));
+        Assert.False(matcher.IsMatch("/0ax"));
+    }
+
+    [Fact]
+    public void CharacterClassOpenEnded()
+    {
+        var matcher = TryCreateSectionNameMatcher("[");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CharacterClassEscapedOpenEnded()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[\]");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CharacterClassEscapeAtEnd()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[\");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CharacterClassOpenBracketInside()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[[a]bc").Value;
+
+        Assert.True(matcher.IsMatch("/abc"));
+        Assert.True(matcher.IsMatch("/[bc"));
+        Assert.False(matcher.IsMatch("/ab"));
+        Assert.False(matcher.IsMatch("/[b"));
+        Assert.False(matcher.IsMatch("/bc"));
+        Assert.False(matcher.IsMatch("/ac"));
+        Assert.False(matcher.IsMatch("/[c"));
+
+        Assert.Equal(@"^.*/[\[a]bc$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassStartingDash()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[-ac]bd").Value;
+
+        Assert.True(matcher.IsMatch("/abd"));
+        Assert.True(matcher.IsMatch("/cbd"));
+        Assert.True(matcher.IsMatch("/-bd"));
+        Assert.False(matcher.IsMatch("/bbd"));
+        Assert.False(matcher.IsMatch("/-cd"));
+        Assert.False(matcher.IsMatch("/bcd"));
+
+        Assert.Equal(@"^.*/[-ac]bd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassEndingDash()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[ac-]bd").Value;
+
+        Assert.True(matcher.IsMatch("/abd"));
+        Assert.True(matcher.IsMatch("/cbd"));
+        Assert.True(matcher.IsMatch("/-bd"));
+        Assert.False(matcher.IsMatch("/bbd"));
+        Assert.False(matcher.IsMatch("/-cd"));
+        Assert.False(matcher.IsMatch("/bcd"));
+
+        Assert.Equal(@"^.*/[ac-]bd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassEndBracketAfter()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[ab]]cd").Value;
+
+        Assert.True(matcher.IsMatch("/a]cd"));
+        Assert.True(matcher.IsMatch("/b]cd"));
+        Assert.False(matcher.IsMatch("/acd"));
+        Assert.False(matcher.IsMatch("/bcd"));
+        Assert.False(matcher.IsMatch("/acd"));
+
+        Assert.Equal(@"^.*/[ab]]cd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassEscapeBackslash()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[ab\\]cd").Value;
+
+        Assert.True(matcher.IsMatch("/acd"));
+        Assert.True(matcher.IsMatch("/bcd"));
+        Assert.True(matcher.IsMatch("/\\cd"));
+        Assert.False(matcher.IsMatch("/dcd"));
+        Assert.False(matcher.IsMatch("/\\\\cd"));
+        Assert.False(matcher.IsMatch("/cd"));
+
+        Assert.Equal(@"^.*/[ab\\]cd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void EscapeOpenBracket()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"ab\[cd").Value;
+
+        Assert.True(matcher.IsMatch("/ab[cd"));
+        Assert.False(matcher.IsMatch("/ab[[cd"));
+        Assert.False(matcher.IsMatch("/abc"));
+        Assert.False(matcher.IsMatch("/abd"));
+
+        Assert.Equal(@"^.*/ab\[cd$", matcher.Regex.ToString());
+    }
+    #endregion
+
+    #region Parsing Tests
+
+    private static void SetEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual, IEqualityComparer<T> comparer = null, string message = null)
+    {
+        var expectedSet = new HashSet<T>(expected, comparer);
+        var result = expected.Count() == actual.Count() && expectedSet.SetEquals(actual);
+        Assert.True(result, message);
+    }
+
+    private static void Equal<T>(
+        IEnumerable<T> expected,
+        IEnumerable<T> actual,
+        IEqualityComparer<T> comparer = null,
+        string message = null)
+    {
+        if (expected == null)
+        {
+            Assert.Null(actual);
+        }
+        else
+        {
+            Assert.NotNull(actual);
+        }
+
+        if (SequenceEqual(expected, actual, comparer))
+        {
+            return;
+        }
+
+        Assert.True(false, message);
+    }
+
+    private static bool SequenceEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual, IEqualityComparer<T> comparer = null)
+    {
+        if (ReferenceEquals(expected, actual))
+        {
+            return true;
+        }
+
+        var enumerator1 = expected.GetEnumerator();
+        var enumerator2 = actual.GetEnumerator();
+
+        while (true)
+        {
+            var hasNext1 = enumerator1.MoveNext();
+            var hasNext2 = enumerator2.MoveNext();
+
+            if (hasNext1 != hasNext2)
+            {
+                return false;
+            }
+
+            if (!hasNext1)
+            {
+                break;
+            }
+
+            var value1 = enumerator1.Current;
+            var value2 = enumerator2.Current;
+
+            if (!(comparer != null ? comparer.Equals(value1, value2) : AssertEqualityComparer<T>.Equals(value1, value2)))
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public static KeyValuePair<K, V> Create<K, V>(K key, V value)
+    {
+        return new KeyValuePair<K, V>(key, value);
+    }
+
+    [Fact]
+    public void SimpleCase()
+    {
+        var config = EditorConfigFile.Parse("""
+root = true
+
+# Comment1
+# Comment2
+##################################
+
+my_global_prop = my_global_val
+
+[*.cs]
+my_prop = my_val
+""");
+        Assert.Equal("", config.GlobalSection.Name);
+        var properties = config.GlobalSection.Properties;
+
+        SetEqual(
+            new[] { Create("my_global_prop", "my_global_val") ,
+                    Create("root", "true") },
+            properties);
+
+        var namedSections = config.NamedSections;
+        Assert.Equal("*.cs", namedSections[0].Name);
+        SetEqual(
+            new[] { Create("my_prop", "my_val") },
+            namedSections[0].Properties);
+        
+        Assert.True(config.IsRoot);
+    }
+
+    
+    [Fact]
+    // [WorkItem(52469, "https://github.com/dotnet/roslyn/issues/52469")]
+    public void ConfigWithEscapedValues()
+    {
+        var config = EditorConfigFile.Parse(@"is_global = true
+
+[c:/\{f\*i\?le1\}.cs]
+build_metadata.Compile.ToRetrieve = abc123
+
+[c:/f\,ile\#2.cs]
+build_metadata.Compile.ToRetrieve = def456
+
+[c:/f\;i\!le\[3\].cs]
+build_metadata.Compile.ToRetrieve = ghi789
+");
+
+        var namedSections = config.NamedSections;
+        Assert.Equal("c:/\\{f\\*i\\?le1\\}.cs", namedSections[0].Name);
+        Equal(
+            new[] { Create("build_metadata.compile.toretrieve", "abc123") },
+            namedSections[0].Properties);
+
+        Assert.Equal("c:/f\\,ile\\#2.cs", namedSections[1].Name);
+        Equal(
+            new[] { Create("build_metadata.compile.toretrieve", "def456") },
+            namedSections[1].Properties);
+
+        Assert.Equal("c:/f\\;i\\!le\\[3\\].cs", namedSections[2].Name);
+        Equal(
+            new[] { Create("build_metadata.compile.toretrieve", "ghi789") },
+            namedSections[2].Properties);
+    }
+
+    /*
+    [Fact]
+    [WorkItem(52469, "https://github.com/dotnet/roslyn/issues/52469")]
+    public void CanGetSectionsWithSpecialCharacters()
+    {
+        var config = ParseConfigFile(@"is_global = true
+
+[/home/foo/src/\{releaseid\}.cs]
+build_metadata.Compile.ToRetrieve = abc123
+
+[/home/foo/src/Pages/\#foo/HomePage.cs]
+build_metadata.Compile.ToRetrieve = def456
+");
+
+        var set = AnalyzerConfigSet.Create(ImmutableArray.Create(config));
+
+        var sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/{releaseid}.cs");
+        Assert.Equal("abc123", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+
+        sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/Pages/#foo/HomePage.cs");
+        Assert.Equal("def456", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+    }*/
+
+    [Fact]
+    public void MissingClosingBracket()
+    {
+        var config = EditorConfigFile.Parse(@"
+[*.cs
+my_prop = my_val");
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop", "my_val") },
+            properties);
+
+        Assert.Equal(0, config.NamedSections.Length);
+    }
+
+    
+    [Fact]
+    public void EmptySection()
+    {
+        var config = EditorConfigFile.Parse(@"
+[]
+my_prop = my_val");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(new[] { Create("my_prop", "my_val") }, properties);
+        Assert.Equal(0, config.NamedSections.Length);
+    }
+
+    
+    [Fact]
+    public void CaseInsensitivePropKey()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_PROP = my_VAL");
+        var properties = config.GlobalSection.Properties;
+
+        Assert.True(properties.TryGetValue("my_PrOp", out var val));
+        Assert.Equal("my_VAL", val);
+        Assert.Equal("my_prop", properties.Keys.Single());
+    }
+
+    // there is no reversed keys support for msbuild
+    /*[Fact]
+    public void NonReservedKeyPreservedCaseVal()
+    {
+        var config = ParseConfigFile(string.Join(Environment.NewLine,
+            AnalyzerConfig.ReservedKeys.Select(k => "MY_" + k + " = MY_VAL")));
+        AssertEx.SetEqual(
+            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create("my_" + k, "MY_VAL")).ToList(),
+            config.GlobalSection.Properties);
+    }*/
+
+
+    [Fact]
+    public void DuplicateKeys()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop = my_val
+my_prop = my_other_val");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(new[] { Create("my_prop", "my_other_val") }, properties);
+    }
+
+    
+    [Fact]
+    public void DuplicateKeysCasing()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop = my_val
+my_PROP = my_other_val");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(new[] { Create("my_prop", "my_other_val") }, properties);
+    }
+
+    
+    [Fact]
+    public void MissingKey()
+    {
+        var config = EditorConfigFile.Parse(@"
+= my_val1
+my_prop = my_val2");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop", "my_val2") },
+            properties);
+    }
+
+    
+
+    [Fact]
+    public void MissingVal()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop1 =
+my_prop2 = my_val");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop1", ""),
+                    Create("my_prop2", "my_val") },
+            properties);
+    }
+
+    
+    [Fact]
+    public void SpacesInProperties()
+    {
+        var config = EditorConfigFile.Parse(@"
+my prop1 = my_val1
+my_prop2 = my val2");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop2", "my val2") },
+            properties);
+    }
+
+    
+    [Fact]
+    public void EndOfLineComments()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop2 = my val2 # Comment");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop2", "my val2") },
+            properties);
+    }
+    
+    [Fact]
+    public void SymbolsStartKeys()
+    {
+        var config = EditorConfigFile.Parse(@"
+@!$abc = my_val1
+@!$\# = my_val2");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(0, properties.Count);
+    }
+
+    
+    [Fact]
+    public void EqualsAndColon()
+    {
+        var config = EditorConfigFile.Parse(@"
+my:key1 = my_val
+my_key2 = my:val");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my", "key1 = my_val"),
+                    Create("my_key2", "my:val")},
+            properties);
+    }
+    
+    [Fact]
+    public void SymbolsInProperties()
+    {
+        var config = EditorConfigFile.Parse(@"
+my@key1 = my_val
+my_key2 = my@val");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_key2", "my@val") },
+            properties);
+    }
+    
+    [Fact]
+    public void LongLines()
+    {
+        // This example is described in the Python ConfigParser as allowing
+        // line continuation via the RFC 822 specification, section 3.1.1
+        // LONG HEADER FIELDS. The VS parser does not accept this as a
+        // valid parse for an editorconfig file. We follow similarly.
+        var config = EditorConfigFile.Parse(@"
+long: this value continues
+   in the next line");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("long", "this value continues") },
+            properties);
+    }
+
+    
+    [Fact]
+    public void CaseInsensitiveRoot()
+    {
+        var config = EditorConfigFile.Parse(@"
+RoOt = TruE");
+        Assert.True(config.IsRoot);
+    }
+
+
+    /*
+    Reserved values are not supported at the moment
+    [Fact]
+    public void ReservedValues()
+    {
+        int index = 0;
+        var config = ParseConfigFile(string.Join(Environment.NewLine,
+            AnalyzerConfig.ReservedValues.Select(v => "MY_KEY" + (index++) + " = " + v.ToUpperInvariant())));
+        index = 0;
+        AssertEx.SetEqual(
+            AnalyzerConfig.ReservedValues.Select(v => KeyValuePair.Create("my_key" + (index++), v)).ToList(),
+            config.GlobalSection.Properties);
+    }
+    */
+
+    /*
+    [Fact]
+    public void ReservedKeys()
+    {
+        var config = ParseConfigFile(string.Join(Environment.NewLine,
+            AnalyzerConfig.ReservedKeys.Select(k => k + " = MY_VAL")));
+        AssertEx.SetEqual(
+            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create(k, "my_val")).ToList(),
+            config.GlobalSection.Properties);
+    }
+    */
+    #endregion
+}
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index 9351612060f..47ef63417cb 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -2,12 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
+using System.Xml;
+using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
@@ -19,6 +16,7 @@ namespace Microsoft.Build.BuildCheck.UnitTests;
 public class EndToEndTests : IDisposable
 {
     private readonly TestEnvironment _env;
+
     public EndToEndTests(ITestOutputHelper output)
     {
         _env = TestEnvironment.Create(output);
@@ -27,6 +25,10 @@ public EndToEndTests(ITestOutputHelper output)
         _env.WithEnvironmentInvariant();
     }
 
+    private static string AssemblyLocation { get; } = Path.Combine(Path.GetDirectoryName(typeof(EndToEndTests).Assembly.Location) ?? AppContext.BaseDirectory);
+
+    private static string TestAssetsRootPath { get; } = Path.Combine(AssemblyLocation, "TestAssets");
+
     public void Dispose() => _env.Dispose();
 
     [Theory]
@@ -62,7 +64,6 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool ana
 
         string contents2 = $"""
             <Project Sdk="Microsoft.NET.Sdk">
-                               
                 <PropertyGroup>
                 <OutputType>Exe</OutputType>
                 <TargetFramework>net8.0</TargetFramework>
@@ -88,28 +89,20 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool ana
         TransientTestFile projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
         TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
 
-        // var cache = new SimpleProjectRootElementCache();
-        // ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile.Path, /*unused*/null, /*unused*/null, cache, false /*Not explicitly loaded - unused*/);
+        TransientTestFile config = _env.CreateFile(workFolder, ".editorconfig",
+            """
+            root=true
+
+            [*.csproj]
+            build_check.BC0101.IsEnabled=true
+            build_check.BC0101.Severity=warning
 
+            build_check.COND0543.IsEnabled=false
+            build_check.COND0543.Severity=Error
+            build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
+            build_check.COND0543.CustomSwitch=QWERTY
 
-        TransientTestFile config = _env.CreateFile(workFolder, "editorconfig.json",
-            /*lang=json,strict*/
-            """
-            {
-                "BC0101": {
-                    "IsEnabled": true,
-                    "Severity": "Error"
-                },
-                "COND0543": {
-                    "IsEnabled": false,
-                    "Severity": "Error",
-                    "EvaluationAnalysisScope": "AnalyzedProjectOnly",
-                    "CustomSwitch": "QWERTY"
-                },
-                "BLA": {
-                    "IsEnabled": false
-                }
-            }
+            build_check.BLA.IsEnabled=false
             """);
 
         // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
@@ -121,7 +114,7 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool ana
         _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "1");
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
             $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore" +
-            (analysisRequested ? " -analyze" : string.Empty), out bool success, false, _env.Output);
+            (analysisRequested ? " -analyze" : string.Empty), out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
         _env.Output.WriteLine(output);
         success.ShouldBeTrue();
         // The conflicting outputs warning appears - but only if analysis was requested
@@ -134,4 +127,70 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool ana
             output.ShouldNotContain("BC0101");
         }
     }
+
+    [Theory]
+    [InlineData("AnalysisCandidate", new[] { "CustomRule1", "CustomRule2" })]
+    [InlineData("AnalysisCandidateWithMultipleAnalyzersInjected", new[] { "CustomRule1", "CustomRule2", "CustomRule3" }, true)]
+    public void CustomAnalyzerTest(string analysisCandidate, string[] expectedRegisteredRules, bool expectedRejectedAnalyzers = false)
+    {
+        using (var env = TestEnvironment.Create())
+        {
+            var analysisCandidatePath = Path.Combine(TestAssetsRootPath, analysisCandidate);
+            AddCustomDataSourceToNugetConfig(analysisCandidatePath);
+
+            string projectAnalysisBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
+                $"{Path.Combine(analysisCandidatePath, $"{analysisCandidate}.csproj")} /m:1 -nr:False -restore /p:OutputPath={env.CreateFolder().Path} -analyze -verbosity:n",
+                out bool successBuild);
+            successBuild.ShouldBeTrue(projectAnalysisBuildLog);
+
+            foreach (string registeredRule in expectedRegisteredRules)
+            {
+                projectAnalysisBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CustomAnalyzerSuccessfulAcquisition", registeredRule));
+            }
+
+            if (expectedRejectedAnalyzers)
+            {
+                projectAnalysisBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CustomAnalyzerBaseTypeNotAssignable", "InvalidAnalyzer", "InvalidCustomAnalyzer, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"));
+            }
+        }
+    }
+
+    private void AddCustomDataSourceToNugetConfig(string analysisCandidatePath)
+    {
+        var nugetTemplatePath = Path.Combine(analysisCandidatePath, "nugetTemplate.config");
+
+        var doc = new XmlDocument();
+        doc.LoadXml(File.ReadAllText(nugetTemplatePath));
+        if (doc.DocumentElement != null)
+        {
+            XmlNode? packageSourcesNode = doc.SelectSingleNode("//packageSources");
+
+            // The test packages are generated during the test project build and saved in CustomAnalyzers folder.
+            string analyzersPackagesPath = Path.Combine(Directory.GetParent(AssemblyLocation)?.Parent?.FullName ?? string.Empty, "CustomAnalyzers");
+            AddPackageSource(doc, packageSourcesNode, "Key", analyzersPackagesPath);
+
+            doc.Save(Path.Combine(analysisCandidatePath, "nuget.config"));
+        }
+    }
+
+    private void AddPackageSource(XmlDocument doc, XmlNode? packageSourcesNode, string key, string value)
+    {
+        if (packageSourcesNode != null)
+        {
+            XmlElement addNode = doc.CreateElement("add");
+
+            PopulateXmlAttribute(doc, addNode, "key", key);
+            PopulateXmlAttribute(doc, addNode, "value", value);
+
+            packageSourcesNode.AppendChild(addNode);
+        }
+    }
+
+    private void PopulateXmlAttribute(XmlDocument doc, XmlNode node, string attributeName, string attributeValue)
+    {
+        node.ShouldNotBeNull($"The attribute {attributeName} can not be populated with {attributeValue}. Xml node is null.");
+        var attribute = doc.CreateAttribute(attributeName);
+        attribute.Value = attributeValue;
+        node.Attributes!.Append(attribute);
+    }
 }
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index 3aa9eaff7d1..6a72903b8e6 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -11,9 +11,16 @@
 
   <ItemGroup>
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
+    <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
     <ProjectReference Include="..\UnitTests.Shared\Microsoft.Build.UnitTests.Shared.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
   </ItemGroup>
+  
+  <ItemGroup Label="TestAssests">
+    <ProjectReference Include=".\TestAssets\CustomAnalyzer\CustomAnalyzer.csproj" />
+    <ProjectReference Include=".\TestAssets\CustomAnalyzer2\CustomAnalyzer2.csproj" />
+    <ProjectReference Include=".\TestAssets\InvalidCustomAnalyzer\InvalidCustomAnalyzer.csproj" />
+  </ItemGroup>
 
   <ItemGroup>
     <PackageReference Include="System.Collections.Immutable" />
@@ -33,5 +40,9 @@
     <None Include="..\Shared\UnitTests\xunit.runner.json">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
+    <None Include="TestAssets\**\*">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
   </ItemGroup>
+
 </Project>
diff --git a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
index 05d1266d2ac..7734c19f311 100644
--- a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
+++ b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
@@ -1,12 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.UnitTests;
diff --git a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
new file mode 100644
index 00000000000..67d7cf784ef
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
@@ -0,0 +1,148 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.BuildCheckManagerProvider;
+
+namespace Microsoft.Build.BuildCheck.UnitTests
+{
+    public class TaskInvocationAnalysisDataTests : IDisposable
+    {
+        internal sealed class TestAnalyzer : BuildAnalyzer
+        {
+            #region BuildAnalyzer initialization
+
+            public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("BC0000", "TestRule", "TestDescription", "TestMessage",
+                new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });
+
+            public override string FriendlyName => "MSBuild.TestAnalyzer";
+
+            public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+
+            public override void Initialize(ConfigurationContext configurationContext)
+            { }
+
+            public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+            {
+                registrationContext.RegisterTaskInvocationAction(TaskInvocationAction);
+            }
+
+            #endregion
+
+            /// <summary>
+            /// Stores all TaskInvocationAnalysisData reported during the build.
+            /// </summary>
+            public List<TaskInvocationAnalysisData> AnalysisData = new();
+
+            private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+            {
+                AnalysisData.Add(context.Data);
+            }
+        }
+
+        private static TestAnalyzer? s_testAnalyzer;
+
+        public TaskInvocationAnalysisDataTests()
+        {
+            BuildCheckManager.s_testFactoriesPerDataSource =
+            [
+                // BuildCheckDataSource.EventArgs
+                [
+                    ([TestAnalyzer.SupportedRule.Id], true, () => (s_testAnalyzer = new TestAnalyzer())),
+                ],
+                // BuildCheckDataSource.Execution
+                [],
+            ];
+
+            s_testAnalyzer?.AnalysisData.Clear();
+        }
+
+        public void Dispose()
+        {
+            BuildCheckManager.s_testFactoriesPerDataSource = null;
+        }
+
+        private void BuildProject(string taskInvocation)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var testProject = env.CreateTestProjectWithFiles($"<Project><Target Name=\"Build\">{taskInvocation}</Target></Project>");
+
+                using (var buildManager = new BuildManager())
+                {
+                    var request = new BuildRequestData(testProject.ProjectFile, new Dictionary<string, string>(), MSBuildConstants.CurrentToolsVersion, [], null, BuildRequestDataFlags.None);
+                    var parameters = new BuildParameters
+                    {
+                        LogTaskInputs = true,
+                        IsBuildCheckEnabled = true,
+                        ShutdownInProcNodeOnBuildFinish = true,
+                    };
+
+                    var result = buildManager.Build(parameters, request);
+
+                    result.OverallResult.ShouldBe(BuildResultCode.Success);
+                }
+
+                foreach (var data in s_testAnalyzer!.AnalysisData)
+                {
+                    data.ProjectFilePath.ShouldBe(testProject.ProjectFile);
+                    data.TaskInvocationLocation.Line.ShouldBeGreaterThan(0);
+                    data.TaskInvocationLocation.Column.ShouldBeGreaterThan(0);
+                }
+            }
+        }
+
+        [Fact]
+        public void ReportsSimpleTaskParameters()
+        {
+            BuildProject("<Message Text='Hello'/>");
+
+            s_testAnalyzer!.AnalysisData.Count.ShouldBe(1);
+            var data = s_testAnalyzer.AnalysisData[0];
+            data.TaskName.ShouldBe("Message");
+            data.Parameters.Count.ShouldBe(1);
+            data.Parameters["Text"].IsOutput.ShouldBe(false);
+            data.Parameters["Text"].Value.ShouldBe("Hello");
+        }
+
+        [Theory]
+        [InlineData("<Output TaskParameter='CombinedPaths' ItemName='OutputDirectories' />")]
+        [InlineData("<Output TaskParameter='CombinedPaths' PropertyName='OutputDirectories' />")]
+        public void ReportsComplexTaskParameters(string outputElement)
+        {
+            BuildProject($"""
+                <ItemGroup>
+                  <TestItem Include='item1;item2'/>
+                </ItemGroup>
+                <CombinePath BasePath='base' Paths='@(TestItem)'>
+                    {outputElement}
+                </CombinePath>
+            """);
+
+            s_testAnalyzer!.AnalysisData.Count.ShouldBe(1);
+            var data = s_testAnalyzer.AnalysisData[0];
+            data.TaskName.ShouldBe("CombinePath");
+            data.Parameters.Count.ShouldBe(3);
+
+            data.Parameters["Paths"].IsOutput.ShouldBe(false);
+            data.Parameters["Paths"].Value.ShouldBeAssignableTo(typeof(IList));
+            IList listValue = (IList)data.Parameters["Paths"].Value!;
+            listValue.Count.ShouldBe(2);
+            listValue[0]!.ShouldBeAssignableTo(typeof(ITaskItem));
+            listValue[1]!.ShouldBeAssignableTo(typeof(ITaskItem));
+            ((ITaskItem)listValue[0]!).ItemSpec.ShouldBe("item1");
+            ((ITaskItem)listValue[1]!).ItemSpec.ShouldBe("item2");
+            data.Parameters["CombinedPaths"].IsOutput.ShouldBe(true);
+            data.Parameters["CombinedPaths"].Value.ShouldNotBeNull();
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/AnalysisCandidate.csproj b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/AnalysisCandidate.csproj
new file mode 100644
index 00000000000..52f65afffee
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/AnalysisCandidate.csproj
@@ -0,0 +1,18 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <PropertyGroup>
+    <TargetFramework>net8.0</TargetFramework>
+    <Nullable>enable</Nullable>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <PackageReference Include="CustomAnalyzer" Version="1.0.0"/>
+  </ItemGroup>
+
+  <ItemGroup>
+    <None Include="nuget.config">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
+  </ItemGroup>
+
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config
new file mode 100644
index 00000000000..aa5beec8aa0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<configuration>
+  <packageSources>
+  </packageSources>
+</configuration>
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj
new file mode 100644
index 00000000000..0ffaa8d26b7
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj
@@ -0,0 +1,20 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <PropertyGroup>
+    <TargetFramework>net8.0</TargetFramework>
+    <Nullable>enable</Nullable>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <PackageReference Include="CustomAnalyzer" Version="1.0.0"/>
+    <PackageReference Include="CustomAnalyzer2" Version="1.0.0"/>
+    <PackageReference Include="InvalidCustomAnalyzer" Version="1.0.0"/>
+  </ItemGroup>
+
+  <ItemGroup>
+    <None Include="nuget.config">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
+  </ItemGroup>
+
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config
new file mode 100644
index 00000000000..1c0c23b1405
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="utf-8"?>
+<configuration>
+   <packageSources>
+  </packageSources>
+</configuration>
diff --git a/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
new file mode 100644
index 00000000000..4e4cb1c0796
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
@@ -0,0 +1,17 @@
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
+  <!-- The properties need to be redefined to have a nuget package built as a part of MSBuild build. -->
+  <PropertyGroup>
+    <IsPackable>true</IsPackable>
+    <IsShipping>false</IsShipping>
+    <PackageVersion>1.0.0</PackageVersion>
+    <ArtifactsNonShippingPackagesDir>$(ArtifactsBinDir)Microsoft.Build.BuildCheck.UnitTests\CustomAnalyzers</ArtifactsNonShippingPackagesDir>
+    <NoWarn>NU5101;NU5128;MSB3277;NU1507;NU1701;NU1702;NU5104</NoWarn>
+  </PropertyGroup>
+
+  <!-- In the real world scenario, the dependencies are added as Nuget PackageReference, modified for test purposes only. -->
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\Build\Microsoft.Build.csproj" IncludeInPackage="true" />
+  </ItemGroup>
+
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.targets b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.targets
new file mode 100644
index 00000000000..a1ea76b439e
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.targets
@@ -0,0 +1,41 @@
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
+  <Target Name="AddNuGetDlls" BeforeTargets="_GetPackageFiles">
+    <!-- Resolve the project references to get their output DLL paths -->
+    <ItemGroup>
+      <ResolvedProjectReference Include="@(ReferencePath)" Condition="%(ReferencePath.ReferenceSourceTarget) == 'ProjectReference'">
+        <OutputPath>%(ReferencePath.OriginalItemSpec)</OutputPath>
+      </ResolvedProjectReference>
+
+      <!-- Add the DLL produced by the referenced project to the _PackagesToPack list -->
+      <_PackagesToPack Include="@(ResolvedProjectReference->'%(OutputPath)')">
+          <NuGetPackageId>@(ResolvedProjectReference->'%(AssemblyName)')</NuGetPackageId>
+      </_PackagesToPack>
+    </ItemGroup>
+    
+    <!-- Merge the collection of PackageReference and Assemblies using the NuGetPackageId key.
+       This produces a new list containing the DLL path and the "IncludeInPackage" metadata-->
+    <JoinItems Left="@(ResolvedCompileFileDefinitions)" LeftKey="NuGetPackageId" LeftMetadata="*" Right="@(ProjectReference)" RightKey="" RightMetadata="*" ItemSpecToUse="Left">
+      <Output TaskParameter="JoinResult" ItemName="_PackagesToPack" />
+    </JoinItems>
+
+    <ItemGroup>
+      <Message Importance="High" Text="Adding DLLs from the following packages: @(_PackagesToPack->'%(NuGetPackageId)')" />
+
+      <!-- Remove NETStandard DLLs -->
+      <_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(NuGetPackageId) == 'NETStandard.Library'" />
+      <_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(_PackagesToPack.IncludeInPackage) != 'true'" />
+    </ItemGroup>
+
+    <Message Importance="High" Text="Adding DLLs from the following packages: @(ResolvedProjectReferences->'%(OutputPath)%(AssemblyName).dll')" />
+
+    <ItemGroup>
+      <!-- Update the collection of items to pack with the DLLs from the NuGet packages -->
+      <None Include="@(_PackagesToPack)" Pack="true" PackagePath="build" Visible="false" />
+
+      <!-- Add the DLL produced by the current project to the NuGet package -->
+      <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="build" Visible="false" />
+    </ItemGroup>
+  </Target>
+
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer1.cs b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer1.cs
new file mode 100644
index 00000000000..5cd1d3317c0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer1.cs
@@ -0,0 +1,38 @@
+﻿using System.Collections.Generic;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace CustomAnalyzer
+{
+    public sealed class Analyzer1 : BuildAnalyzer
+    {
+        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+            "X01234",
+            "Title",
+            "Description",
+            "Message format: {0}",
+            new BuildAnalyzerConfiguration());
+
+        public override string FriendlyName => "CustomRule1";
+
+        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+
+        public override void Initialize(ConfigurationContext configurationContext)
+        {
+            // configurationContext to be used only if analyzer needs external configuration data.
+        }
+
+        public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+        {
+            registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+        }
+
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        {
+            context.ReportResult(BuildCheckResult.Create(
+                SupportedRule,
+                ElementLocation.EmptyLocation,
+                "Argument for the message format"));
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer2.cs b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer2.cs
new file mode 100644
index 00000000000..714a82ae95a
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer2.cs
@@ -0,0 +1,38 @@
+﻿using System.Collections.Generic;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace CustomAnalyzer
+{
+    public sealed class Analyzer2 : BuildAnalyzer
+    {
+        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+            "X01235",
+            "Title",
+            "Description",
+            "Message format: {0}",
+            new BuildAnalyzerConfiguration());
+
+        public override string FriendlyName => "CustomRule2";
+
+        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+
+        public override void Initialize(ConfigurationContext configurationContext)
+        {
+            // configurationContext to be used only if analyzer needs external configuration data.
+        }
+
+        public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+        {
+            registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+        }
+
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        {
+            context.ReportResult(BuildCheckResult.Create(
+                SupportedRule,
+                ElementLocation.EmptyLocation,
+                "Argument for the message format"));
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj
new file mode 100644
index 00000000000..f27ab620690
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj
@@ -0,0 +1,17 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <Import Project="..\Common\CommonTest.props" />
+
+  <PropertyGroup>
+    <TargetFramework>netstandard2.0</TargetFramework>
+    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <None Include="CustomAnalyzer.props" Pack="true" PackagePath="build\CustomAnalyzer.props" />
+    <Content Include="README.md" />
+  </ItemGroup>
+
+  <Import Project="..\Common\CommonTest.targets" />
+
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.props b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.props
new file mode 100644
index 00000000000..31a9526dd62
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)CustomAnalyzer.dll))</MSBuildAnalyzer>
+  </PropertyGroup>
+</Project>
diff --git a/template_feed/Microsoft.AnalyzerTemplate/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md
similarity index 100%
rename from template_feed/Microsoft.AnalyzerTemplate/README.md
rename to src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Analyzer3.cs b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Analyzer3.cs
new file mode 100644
index 00000000000..c0272937c87
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Analyzer3.cs
@@ -0,0 +1,38 @@
+﻿using System.Collections.Generic;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace CustomAnalyzer2
+{
+    public sealed class Analyzer3 : BuildAnalyzer
+    {
+        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+            "X01235",
+            "Title",
+            "Description",
+            "Message format: {0}",
+            new BuildAnalyzerConfiguration());
+
+        public override string FriendlyName => "CustomRule3";
+
+        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+
+        public override void Initialize(ConfigurationContext configurationContext)
+        {
+            // configurationContext to be used only if analyzer needs external configuration data.
+        }
+
+        public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+        {
+            registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+        }
+
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        {
+            context.ReportResult(BuildCheckResult.Create(
+                SupportedRule,
+                ElementLocation.EmptyLocation,
+                "Argument for the message format"));
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj
new file mode 100644
index 00000000000..a405546f1cc
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj
@@ -0,0 +1,17 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <Import Project="..\Common\CommonTest.props" />
+
+  <PropertyGroup>
+    <TargetFramework>netstandard2.0</TargetFramework>
+    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <None Include="CustomAnalyzer2.props" Pack="true" PackagePath="build\CustomAnalyzer2.props" />
+    <Content Include="README.md" />
+  </ItemGroup>
+
+  <Import Project="..\Common\CommonTest.targets" />
+  
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.props b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.props
new file mode 100644
index 00000000000..869000fa12f
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)CustomAnalyzer2.dll))</MSBuildAnalyzer>
+  </PropertyGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md
new file mode 100644
index 00000000000..4f29145e7f0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Analyzer Template
+
+## Overview
+MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild analyzer libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom analysis rules.
+
+## Getting Started
+To use the MSBuild Custom Analyzer Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildanalyzer
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildanalyzer -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs
new file mode 100644
index 00000000000..e5f466ce414
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs
@@ -0,0 +1,9 @@
+﻿using System.Collections.Generic;
+
+namespace InvalidCustomAnalyzer
+{
+    public sealed class InvalidAnalyzer
+    {
+        public string FriendlyName => "InvalidAnalyzer";
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj
new file mode 100644
index 00000000000..4ef7f0674ca
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj
@@ -0,0 +1,17 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <Import Project="..\Common\CommonTest.props" />
+
+  <PropertyGroup>
+    <TargetFramework>netstandard2.0</TargetFramework>
+    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <None Include="InvalidCustomAnalyzer.props" Pack="true" PackagePath="build\InvalidCustomAnalyzer.props" />
+    <Content Include="README.md" />
+  </ItemGroup>
+
+  <Import Project="..\Common\CommonTest.targets" />
+
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props
new file mode 100644
index 00000000000..52a9bab57c0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)InvalidCustomAnalyzer.dll))</MSBuildAnalyzer>
+  </PropertyGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md
new file mode 100644
index 00000000000..4f29145e7f0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Analyzer Template
+
+## Overview
+MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild analyzer libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom analysis rules.
+
+## Getting Started
+To use the MSBuild Custom Analyzer Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildanalyzer
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildanalyzer -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/Framework/BuildCheck/BuildCheckEventArgs.cs b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
index b7edcb5161a..7789ba37d18 100644
--- a/src/Framework/BuildCheck/BuildCheckEventArgs.cs
+++ b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
@@ -30,6 +30,17 @@ internal BuildCheckTracingEventArgs()
     {
     }
 
+    internal BuildCheckTracingEventArgs(Dictionary<string, TimeSpan> data, bool isAggregatedGlobalReport) : this(data)
+    {
+        IsAggregatedGlobalReport = isAggregatedGlobalReport;
+    }
+
+    /// <summary>
+    /// When true, the tracing information is from the whole build for logging purposes
+    /// When false, the tracing is being used for communication between nodes and central process
+    /// </summary>
+    public bool IsAggregatedGlobalReport { get; private set; } = false;
+
     public Dictionary<string, TimeSpan> TracingData { get; private set; } = tracingData;
 
     internal override void WriteToStream(BinaryWriter writer)
diff --git a/src/Framework/Logging/AnsiDetector.cs b/src/Framework/Logging/AnsiDetector.cs
new file mode 100644
index 00000000000..2b0c0e8b38a
--- /dev/null
+++ b/src/Framework/Logging/AnsiDetector.cs
@@ -0,0 +1,53 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// Portions of the code in this file were ported from the spectre.console by Patrik Svensson, Phil Scott, Nils Andresen
+// https://github.com/spectreconsole/spectre.console/blob/main/src/Spectre.Console/Internal/Backends/Ansi/AnsiDetector.cs
+// and from the supports-ansi project by Qingrong Ke
+// https://github.com/keqingrong/supports-ansi/blob/master/index.js
+
+using System;
+using System.Linq;
+using System.Text.RegularExpressions;
+
+namespace Microsoft.Build.Framework.Logging
+{
+    internal class AnsiDetector
+    {
+        private static readonly Regex[] terminalsRegexes =
+        {
+            new("^xterm"), // xterm, PuTTY, Mintty
+            new("^rxvt"), // RXVT
+            new("^(?!eterm-color).*eterm.*"), // Accepts eterm, but not eterm-color, which does not support moving the cursor, see #9950.
+            new("^screen"), // GNU screen, tmux
+            new("tmux"), // tmux
+            new("^vt100"), // DEC VT series
+            new("^vt102"), // DEC VT series
+            new("^vt220"), // DEC VT series
+            new("^vt320"), // DEC VT series
+            new("ansi"), // ANSI
+            new("scoansi"), // SCO ANSI
+            new("cygwin"), // Cygwin, MinGW
+            new("linux"), // Linux console
+            new("konsole"), // Konsole
+            new("bvterm"), // Bitvise SSH Client
+            new("^st-256color"), // Suckless Simple Terminal, st
+            new("alacritty"), // Alacritty
+        };
+
+        internal static bool IsAnsiSupported(string termType)
+        {
+            if (string.IsNullOrEmpty(termType))
+            {
+                return false;
+            }
+
+            if (terminalsRegexes.Any(regex => regex.IsMatch(termType)))
+            {
+                return true;
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 747a065590e..3cd7934c726 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -10,7 +10,7 @@
 using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
-
+using Microsoft.Build.Framework.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Win32;
 using Microsoft.Win32.SafeHandles;
@@ -1493,8 +1493,8 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
         }
         else
         {
-            // On posix OSes we expect console always supports VT100 coloring unless it is explicitly marked as "dumb".
-            acceptAnsiColorCodes = Environment.GetEnvironmentVariable("TERM") != "dumb";
+            // On posix OSes detect whether the terminal supports VT100 from the value of the TERM environment variable.
+            acceptAnsiColorCodes = AnsiDetector.IsAnsiSupported(Environment.GetEnvironmentVariable("TERM"));
             // It wasn't redirected as tested above so we assume output is screen/console
             outputIsScreen = true;
         }
diff --git a/src/Framework/TaskParameterEventArgs.cs b/src/Framework/TaskParameterEventArgs.cs
index 7aa294f828c..8dcf97730c7 100644
--- a/src/Framework/TaskParameterEventArgs.cs
+++ b/src/Framework/TaskParameterEventArgs.cs
@@ -34,6 +34,8 @@ public class TaskParameterEventArgs : BuildMessageEventArgs
         /// </summary>
         public TaskParameterEventArgs(
             TaskParameterMessageKind kind,
+            string parameterName,
+            string propertyName,
             string itemType,
             IList items,
             bool logItemMetadata,
@@ -41,14 +43,57 @@ public TaskParameterEventArgs(
             : base(null, null, null, MessageImportance.Low, eventTimestamp)
         {
             Kind = kind;
+            ParameterName = parameterName;
+            PropertyName = propertyName;
             ItemType = itemType;
             Items = items;
             LogItemMetadata = logItemMetadata;
         }
 
+        /// <summary>
+        /// Creates an instance of this class for the given task parameter.
+        /// </summary>
+        public TaskParameterEventArgs(
+            TaskParameterMessageKind kind,
+            string itemType,
+            IList items,
+            bool logItemMetadata,
+            DateTime eventTimestamp)
+            : this(kind, parameterName: null, propertyName: null, itemType, items, logItemMetadata, eventTimestamp)
+        { }
+
+        /// <summary>
+        /// The kind of event represented by this instance.
+        /// </summary>
         public TaskParameterMessageKind Kind { get; private set; }
+
+        /// <summary>
+        /// The name of the parameter if <see cref="Kind"/> is <see cref="TaskParameterMessageKind.TaskInput"/> or <see cref="TaskParameterMessageKind.TaskOutput"/>,
+        /// null otherwise.
+        /// </summary>
+        public string ParameterName { get; private set; }
+
+        /// <summary>
+        /// The name of the property if <see cref="Kind"/> is <see cref="TaskParameterMessageKind.TaskOutput"/> and the task output
+        /// is assigned to a property, null otherwise.
+        /// </summary>
+        public string PropertyName { get; private set; }
+
+        /// <summary>
+        /// The name of the item being manipulated, e.g. "Compile" if this is an item operation. If this object represents a task input, this property should be set
+        /// to the same value as <see cref="ParameterName"/> for backward compatibility. Similarly, if this object represents a task output assigned to a property,
+        /// this should be set to the same value as <see cref="PropertyName"/> for backward compatibility.
+        /// </summary>
         public string ItemType { get; private set; }
+
+        /// <summary>
+        /// The values being manipulated (added, removed, passed to/from task).
+        /// </summary>
         public IList Items { get; private set; }
+
+        /// <summary>
+        /// True if the <see cref="Message"/> string should include metadata.
+        /// </summary>
         public bool LogItemMetadata { get; private set; }
 
         /// <summary>
@@ -85,6 +130,8 @@ internal override void CreateFromStream(BinaryReader reader, int version)
             RawTimestamp = reader.ReadTimestamp();
             BuildEventContext = reader.ReadOptionalBuildEventContext();
             Kind = (TaskParameterMessageKind)reader.Read7BitEncodedInt();
+            ParameterName = reader.ReadOptionalString();
+            PropertyName = reader.ReadOptionalString();
             ItemType = reader.ReadOptionalString();
             LineNumber = reader.Read7BitEncodedInt();
             ColumnNumber = reader.Read7BitEncodedInt();
@@ -134,6 +181,8 @@ internal override void WriteToStream(BinaryWriter writer)
             writer.WriteTimestamp(RawTimestamp);
             writer.WriteOptionalBuildEventContext(BuildEventContext);
             writer.Write7BitEncodedInt((int)Kind);
+            writer.WriteOptionalString(ParameterName);
+            writer.WriteOptionalString(PropertyName);
             writer.WriteOptionalString(ItemType);
             writer.Write7BitEncodedInt(LineNumber);
             writer.Write7BitEncodedInt(ColumnNumber);
diff --git a/src/Framework/TaskStartedEventArgs.cs b/src/Framework/TaskStartedEventArgs.cs
index 288a0193524..db1f450e95b 100644
--- a/src/Framework/TaskStartedEventArgs.cs
+++ b/src/Framework/TaskStartedEventArgs.cs
@@ -171,22 +171,22 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         public string ProjectFile => projectFile;
 
         /// <summary>
-        /// MSBuild file where this task was defined.
+        /// MSBuild file in which this task was invoked.
         /// </summary>
         public string TaskFile => taskFile;
 
         /// <summary>
-        /// Line number of the task invocation in the project file
+        /// Line number of the task invocation in the project file.
         /// </summary>
         public int LineNumber { get; internal set; }
 
         /// <summary>
-        /// Column number of the task invocation in the project file
+        /// Column number of the task invocation in the project file.
         /// </summary>
         public int ColumnNumber { get; internal set; }
 
         /// <summary>
-        /// The location of the assembly containing the implementation of the task
+        /// The location of the assembly containing the implementation of the task.
         /// </summary>
         public string TaskAssemblyLocation { get; private set; }
 
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 73b4b3e282b..c33b4e8da98 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -2626,16 +2626,24 @@ public void EndToEndVersionMessage(string arguments, bool shouldContainVersionMe
         [InlineData("/v:normal", MessageImportance.Normal)]
         [InlineData("/v:minimal", MessageImportance.High)]
         [InlineData("/v:quiet", MessageImportance.High - 1)]
+
         [InlineData("/v:diagnostic /bl", MessageImportance.Low)]
         [InlineData("/v:detailed /bl", MessageImportance.Low)]
         [InlineData("/v:normal /bl", MessageImportance.Low)] // v:normal but with binary logger so everything must be logged
         [InlineData("/v:minimal /bl", MessageImportance.Low)] // v:minimal but with binary logger so everything must be logged
         [InlineData("/v:quiet /bl", MessageImportance.Low)] // v:quiet but with binary logger so everything must be logged
+
         [InlineData("/v:diagnostic /analyze", MessageImportance.Low)]
         [InlineData("/v:detailed /analyze", MessageImportance.Low)]
-        [InlineData("/v:normal /analyze", MessageImportance.Low)] // v:normal but with analyzers so everything must be logged
-        [InlineData("/v:minimal /analyze", MessageImportance.Low)] // v:minimal but with analyzers so everything must be logged
-        [InlineData("/v:quiet /analyze", MessageImportance.Low)] // v:quiet but with analyzers so everything must be logged
+        [InlineData("/v:normal /analyze", MessageImportance.Normal)]
+        [InlineData("/v:minimal /analyze", MessageImportance.High)]
+        [InlineData("/v:quiet /analyze", MessageImportance.High)]
+
+        [InlineData("/v:diagnostic /tl", MessageImportance.Low)]
+        [InlineData("/v:detailed /tl", MessageImportance.Low)]
+        [InlineData("/v:normal /tl", MessageImportance.Normal)]
+        [InlineData("/v:minimal /tl", MessageImportance.High)]
+        [InlineData("/v:quiet /tl", MessageImportance.High - 1)]
         public void EndToEndMinimumMessageImportance(string arguments, MessageImportance expectedMinimumMessageImportance)
         {
             using TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create();
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index f396ca22cfe..b84cdc9dcd6 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -194,7 +194,6 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework' AND '$(DotNetBuildFromSource)' != 'true'">
     <!-- Bump these to the latest version despite transitive references to older -->
     <PackageReference Include="System.Private.Uri" PrivateAssets="all" />
-    <PackageReference Include="System.Runtime" PrivateAssets="all" />
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
diff --git a/src/MSBuild/TerminalLogger/Project.cs b/src/MSBuild/TerminalLogger/Project.cs
index 959bab12960..eabfd989c3e 100644
--- a/src/MSBuild/TerminalLogger/Project.cs
+++ b/src/MSBuild/TerminalLogger/Project.cs
@@ -51,6 +51,11 @@ public Project(string? targetFramework, StopwatchAbstraction? stopwatch)
     /// </summary>
     public bool IsTestProject { get; set; }
 
+    /// <summary>
+    /// True when the project has run target with name "_CachePluginRunStart" defined in <see cref="TerminalLogger._cachePluginStartTarget"/>.
+    /// </summary>
+    public bool IsCachePluginProject { get; set; }
+
     /// <summary>
     /// A lazily initialized list of build messages/warnings/errors raised during the build.
     /// </summary>
diff --git a/src/MSBuild/TerminalLogger/Terminal.cs b/src/MSBuild/TerminalLogger/Terminal.cs
index 91565e1f797..16651d85fb9 100644
--- a/src/MSBuild/TerminalLogger/Terminal.cs
+++ b/src/MSBuild/TerminalLogger/Terminal.cs
@@ -200,6 +200,15 @@ public void WriteColorLine(TerminalColor color, string text)
     /// <inheritdoc/>
     public void Dispose()
     {
-        Console.OutputEncoding = _originalOutputEncoding;
+        try
+        {
+            Console.OutputEncoding = _originalOutputEncoding;
+        }
+        catch
+        {
+            // In some terminal emulators setting back the previous console output encoding fails.
+            // See https://github.com/dotnet/msbuild/issues/9662.
+            // We do not want to throw an exception if it happens, since it is a non-essentual failure in the logger.
+        }
     }
 }
diff --git a/src/MSBuild/TerminalLogger/TerminalLogger.cs b/src/MSBuild/TerminalLogger/TerminalLogger.cs
index 71749e72717..64fe4a5a594 100644
--- a/src/MSBuild/TerminalLogger/TerminalLogger.cs
+++ b/src/MSBuild/TerminalLogger/TerminalLogger.cs
@@ -70,6 +70,11 @@ public ProjectContext(BuildEventContext context)
 
     internal Func<StopwatchAbstraction>? CreateStopwatch = null;
 
+    /// <summary>
+    /// Name of target that identifies the project cache plugin run has just started.
+    /// </summary>
+    private const string CachePluginStartTarget = "_CachePluginRunStart";
+
     /// <summary>
     /// Protects access to state shared between the logger callbacks and the rendering thread.
     /// </summary>
@@ -91,6 +96,10 @@ public ProjectContext(BuildEventContext context)
     /// <summary>
     /// Tracks the work currently being done by build nodes. Null means the node is not doing any work worth reporting.
     /// </summary>
+    /// <remarks>
+    /// There is no locking around access to this data structure despite it being accessed concurrently by multiple threads.
+    /// However, reads and writes to locations in an array is atomic, so locking is not required.
+    /// </remarks>
     private NodeStatus?[] _nodes = Array.Empty<NodeStatus>();
 
     /// <summary>
@@ -202,6 +211,11 @@ public ProjectContext(BuildEventContext context)
     /// </summary>
     private DateTime? _testEndTime;
 
+    /// <summary>
+    /// Demonstrates whether there exists at least one project which is a cache plugin project.
+    /// </summary>
+    private bool _hasUsedCache = false;
+
     /// <summary>
     /// Whether to show TaskCommandLineEventArgs high-priority messages. 
     /// </summary>
@@ -679,12 +693,17 @@ private void TargetStarted(object sender, TargetStartedEventArgs e)
 
             string projectFile = Path.GetFileNameWithoutExtension(e.ProjectFile);
 
+            string targetName = e.TargetName;
+            if (targetName == CachePluginStartTarget)
+            {
+                project.IsCachePluginProject = true;
+                _hasUsedCache = true;
+            }
 
-            var isTestTarget = e.TargetName == _testStartTarget;
-
-            var targetName = isTestTarget ? "Testing" : e.TargetName;
-            if (isTestTarget)
+            if (targetName == _testStartTarget)
             {
+                targetName = "Testing";
+
                 // Use the minimal start time, so if we run tests in parallel, we can calculate duration
                 // as this start time, minus time when tests finished.
                 _testStartTime = _testStartTime == null
@@ -701,11 +720,8 @@ private void TargetStarted(object sender, TargetStartedEventArgs e)
 
     private void UpdateNodeStatus(BuildEventContext buildEventContext, NodeStatus? nodeStatus)
     {
-        lock (_lock)
-        {
-            int nodeIndex = NodeIndexForContext(buildEventContext);
-            _nodes[nodeIndex] = nodeStatus;
-        }
+        int nodeIndex = NodeIndexForContext(buildEventContext);
+        _nodes[nodeIndex] = nodeStatus;
     }
 
     /// <summary>
@@ -713,6 +729,24 @@ private void UpdateNodeStatus(BuildEventContext buildEventContext, NodeStatus? n
     /// </summary>
     private void TargetFinished(object sender, TargetFinishedEventArgs e)
     {
+        // For cache plugin projects which result in a cache hit, ensure the output path is set
+        // to the item spec corresponding to the GetTargetPath target upon completion.
+        var buildEventContext = e.BuildEventContext;
+        if (_restoreContext is null
+            && buildEventContext is not null
+            && _hasUsedCache
+            && e.TargetName == "GetTargetPath"
+            && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+        {
+            if (project.IsCachePluginProject)
+            {
+                foreach (ITaskItem output in e.TargetOutputs)
+                {
+                    project.OutputPath = output.ItemSpec.AsMemory();
+                    break;
+                }
+            }
+        }
     }
 
     /// <summary>
@@ -917,7 +951,7 @@ private void ErrorRaised(object sender, BuildErrorEventArgs e)
         }
     }
 
-    #endregion
+#endregion
 
     #region Refresher thread implementation
 
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 9fa6956ae03..088d2c00179 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1336,7 +1336,7 @@ internal static bool BuildProject(
                 // This is a hack for now to make sure the perf hit only happens
                 // on diagnostic. This should be changed to pipe it through properly,
                 // perhaps as part of a fuller tracing feature.
-                bool logTaskInputs = verbosity == LoggerVerbosity.Diagnostic;
+                bool logTaskInputs = verbosity == LoggerVerbosity.Diagnostic || isBuildCheckEnabled;
 
                 if (!logTaskInputs)
                 {
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index adecc536031..38ae4cbb8d4 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -227,6 +227,8 @@
             <property name="VSToolsPath" value="$(MSBuildProgramFiles32)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)"/>
           </searchPaths>
         </projectImportSearchPaths>
+
+        <property name="WindowsKitsRoot" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Kits\Installed Roots', 'KitsRoot10', null, RegistryView.Registry32, RegistryView.Default))" />
       </toolset>
     </msbuildToolsets>
   </configuration>
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 2a2ad570ff3..6fc1459176b 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -176,6 +176,8 @@
             <property name="VSToolsPath" value="$(MSBuildProgramFiles32)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)"/>
           </searchPaths>
         </projectImportSearchPaths>
+
+        <property name="WindowsKitsRoot" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Kits\Installed Roots', 'KitsRoot10', null, RegistryView.Registry32, RegistryView.Default))" />
       </toolset>
     </msbuildToolsets>
   </configuration>
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 26ad0cf2151..470c4c7dd7d 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -136,6 +136,9 @@
     <Compile Include="..\Framework\NativeMethods.cs">
       <Link>NativeMethodsShared.cs</Link>
     </Compile>
+    <Compile Include="..\Framework\Logging\AnsiDetector.cs">
+      <Link>AnsiDetector.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\NodeBuildComplete.cs">
       <Link>NodeBuildComplete.cs</Link>
     </Compile>
@@ -241,7 +244,7 @@
     </EmbeddedResource>
   </ItemGroup>
   <ItemGroup>
-    <Content Include="..\MSBuild.ico" />
+    <Content Include="..\MSBuild\MSBuild.ico" />
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
diff --git a/src/Package/GetBinPaths.Arm64.targets b/src/Package/GetBinPaths.Arm64.targets
index 21a6684a86f..59e61789962 100644
--- a/src/Package/GetBinPaths.Arm64.targets
+++ b/src/Package/GetBinPaths.Arm64.targets
@@ -14,6 +14,11 @@
                       Private="false"
                       ReferenceOutputAssembly="false"
                       OutputItemType="FrameworkResolvedProjectReferencePath" />
+
+    <Arm64ProjectReference Include="$(MSBuildThisFileDirectory)\..\MSBuildTaskHost\MSBuildTaskHost.csproj"
+                      SetPlatform="Platform=arm64"
+                      OutputItemType="MSBuildTaskHostArm64ResolvedProjectReferencePath"
+                      GlobalPropertiesToRemove="TargetFramework" />
   </ItemGroup>
 
   <Target Name="SetBinPathsArm64" DependsOnTargets="ResolveProjectReferences">
@@ -29,6 +34,8 @@
     <PropertyGroup>
       <FrameworkBinPath>@(FrameworkResolvedProjectReferencePath->'%(RootDir)%(Directory)')</FrameworkBinPath>
       <Arm64BinPath>@(MSBuildArm64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</Arm64BinPath>
+      <MSBuildTaskHostArm64BinPath>@(MSBuildTaskHostArm64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</MSBuildTaskHostArm64BinPath>
+
     </PropertyGroup>
   </Target>
 
diff --git a/src/Package/MSBuild.VSSetup.Arm64/MSBuild.VSSetup.Arm64.csproj b/src/Package/MSBuild.VSSetup.Arm64/MSBuild.VSSetup.Arm64.csproj
index 2886ce40bc8..6b9d4cebbf8 100644
--- a/src/Package/MSBuild.VSSetup.Arm64/MSBuild.VSSetup.Arm64.csproj
+++ b/src/Package/MSBuild.VSSetup.Arm64/MSBuild.VSSetup.Arm64.csproj
@@ -29,6 +29,7 @@
       <SwrProperty Include="Version=$(VsixVersion)" />
       <SwrProperty Include="FrameworkBinPath=$(FrameworkBinPath)" />
       <SwrProperty Include="Arm64BinPath=$(Arm64BinPath)" />
+      <SwrProperty Include="TaskHostArm64BinPath=$(MSBuildTaskHostArm64BinPath)" />
     </ItemGroup>
   </Target>
 
diff --git a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
index 845c52c7b8c..9a6ef830231 100644
--- a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
+++ b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
@@ -50,28 +50,80 @@ folder InstallDir:\MSBuild\Current\Bin\arm64\MSBuild
   file source=$(Arm64BinPath)\MSBuild\Microsoft.Build.CommonTypes.xsd
 
 folder InstallDir:\MSBuild\Current\Bin\arm64\cs
+  file source=$(Arm64BinPath)cs\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)cs\MSBuild.resources.dll
+  file source=$(Arm64BinPath)cs\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)cs\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)cs\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\de
+  file source=$(Arm64BinPath)de\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)de\MSBuild.resources.dll
+  file source=$(Arm64BinPath)de\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)de\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)de\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\es
+  file source=$(Arm64BinPath)es\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)es\MSBuild.resources.dll
+  file source=$(Arm64BinPath)es\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)es\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)es\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\fr
+  file source=$(Arm64BinPath)fr\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)fr\MSBuild.resources.dll
+  file source=$(Arm64BinPath)fr\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)fr\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)fr\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\it
+  file source=$(Arm64BinPath)it\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)it\MSBuild.resources.dll
+  file source=$(Arm64BinPath)it\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)it\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)it\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\ja
+  file source=$(Arm64BinPath)ja\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)ja\MSBuild.resources.dll
+  file source=$(Arm64BinPath)ja\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)ja\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)ja\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\ko
+  file source=$(Arm64BinPath)ko\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)ko\MSBuild.resources.dll
+  file source=$(Arm64BinPath)ko\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)ko\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)ko\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\pl
+  file source=$(Arm64BinPath)pl\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)pl\MSBuild.resources.dll
+  file source=$(Arm64BinPath)pl\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)pl\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)pl\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\pt-BR
+  file source=$(Arm64BinPath)pt-BR\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)pt-BR\MSBuild.resources.dll
+  file source=$(Arm64BinPath)pt-BR\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)pt-BR\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)pt-BR\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\ru
+  file source=$(Arm64BinPath)ru\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)ru\MSBuild.resources.dll
+  file source=$(Arm64BinPath)ru\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)ru\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)ru\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\tr
+  file source=$(Arm64BinPath)tr\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)tr\MSBuild.resources.dll
+  file source=$(Arm64BinPath)tr\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)tr\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)tr\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hans
+  file source=$(Arm64BinPath)zh-Hans\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)zh-Hans\MSBuild.resources.dll
+  file source=$(Arm64BinPath)zh-Hans\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)zh-Hans\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)zh-Hans\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hant
+  file source=$(Arm64BinPath)zh-Hant\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)zh-Hant\MSBuild.resources.dll
+  file source=$(Arm64BinPath)zh-Hant\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(Arm64BinPath)zh-Hant\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(TaskHostArm64BinPath)zh-Hant\MSBuildTaskHost.resources.dll
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 77978ac3749..e0ac6bae417 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -203,6 +203,8 @@ internal static class ItemMetadataNames
         internal const string assemblyName = "AssemblyName";
         internal const string assemblyVersion = "AssemblyVersion";
         internal const string publicKeyToken = "PublicKeyToken";
+        internal const string culture = "Culture";
+        internal const string withCulture = "WithCulture";
 
         /// <summary>
         /// The output path for a given item.
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index f8601953836..5e2425fa76d 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 #nullable disable
@@ -335,39 +335,49 @@ internal static void UnhandledExceptionHandler(object sender, UnhandledException
         /// </summary>
         internal static void DumpExceptionToFile(Exception ex)
         {
-            // Locking on a type is not recommended.  However, we are doing it here to be extra cautious about compatibility because
-            //  this method previously had a [MethodImpl(MethodImplOptions.Synchronized)] attribute, which does lock on the type when
-            //  applied to a static method.
-            lock (typeof(ExceptionHandling))
+            try
             {
-                if (s_dumpFileName == null)
+                // Locking on a type is not recommended.  However, we are doing it here to be extra cautious about compatibility because
+                //  this method previously had a [MethodImpl(MethodImplOptions.Synchronized)] attribute, which does lock on the type when
+                //  applied to a static method.
+                lock (typeof(ExceptionHandling))
                 {
-                    Guid guid = Guid.NewGuid();
-
-                    // For some reason we get Watson buckets because GetTempPath gives us a folder here that doesn't exist.
-                    // Either because %TMP% is misdefined, or because they deleted the temp folder during the build.
-                    // If this throws, no sense catching it, we can't log it now, and we're here
-                    // because we're a child node with no console to log to, so die
-                    Directory.CreateDirectory(DebugDumpPath);
-
-                    var pid = Process.GetCurrentProcess().Id;
-                    // This naming pattern is assumed in ReadAnyExceptionFromFile
-                    s_dumpFileName = Path.Combine(DebugDumpPath, $"MSBuild_pid-{pid}_{guid:n}.failure.txt");
+                    if (s_dumpFileName == null)
+                    {
+                        Guid guid = Guid.NewGuid();
+
+                        // For some reason we get Watson buckets because GetTempPath gives us a folder here that doesn't exist.
+                        // Either because %TMP% is misdefined, or because they deleted the temp folder during the build.
+                        // If this throws, no sense catching it, we can't log it now, and we're here
+                        // because we're a child node with no console to log to, so die
+                        Directory.CreateDirectory(DebugDumpPath);
+
+                        var pid = Process.GetCurrentProcess().Id;
+                        // This naming pattern is assumed in ReadAnyExceptionFromFile
+                        s_dumpFileName = Path.Combine(DebugDumpPath, $"MSBuild_pid-{pid}_{guid:n}.failure.txt");
+
+                        using (StreamWriter writer = FileUtilities.OpenWrite(s_dumpFileName, append: true))
+                        {
+                            writer.WriteLine("UNHANDLED EXCEPTIONS FROM PROCESS {0}:", pid);
+                            writer.WriteLine("=====================");
+                        }
+                    }
 
                     using (StreamWriter writer = FileUtilities.OpenWrite(s_dumpFileName, append: true))
                     {
-                        writer.WriteLine("UNHANDLED EXCEPTIONS FROM PROCESS {0}:", pid);
-                        writer.WriteLine("=====================");
+                        // "G" format is, e.g., 6/15/2008 9:15:07 PM
+                        writer.WriteLine(DateTime.Now.ToString("G", CultureInfo.CurrentCulture));
+                        writer.WriteLine(ex.ToString());
+                        writer.WriteLine("===================");
                     }
                 }
-
-                using (StreamWriter writer = FileUtilities.OpenWrite(s_dumpFileName, append: true))
-                {
-                    // "G" format is, e.g., 6/15/2008 9:15:07 PM
-                    writer.WriteLine(DateTime.Now.ToString("G", CultureInfo.CurrentCulture));
-                    writer.WriteLine(ex.ToString());
-                    writer.WriteLine("===================");
-                }
+            }
+            
+            // Some customers experience exceptions such as 'OutOfMemory' errors when msbuild attempts to log errors to a local file.
+            // This catch helps to prevent the application from crashing in this best-effort dump-diagnostics path,
+            // but doesn't prevent the overall crash from going to Watson.
+            catch
+            {
             }
         }
 
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 3a67481a23e..0eacfd24c73 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -1458,7 +1458,7 @@ internal static string GetDirectoryNameOfFileAbove(string startingDirectory, str
             while (lookInDirectory != null);
 
             // When we didn't find the location, then return an empty string
-            return String.Empty;
+            return string.Empty;
         }
 
         /// <summary>
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 291594fcfdc..3770b80c09d 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -11,7 +11,7 @@
 
 #if !TASKHOST
 using Microsoft.Build.Experimental.BuildCheck;
-using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 #endif
 
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
diff --git a/src/Tasks.UnitTests/AssignCulture_Tests.cs b/src/Tasks.UnitTests/AssignCulture_Tests.cs
index e26e33a7668..47ceeb5d7b0 100644
--- a/src/Tasks.UnitTests/AssignCulture_Tests.cs
+++ b/src/Tasks.UnitTests/AssignCulture_Tests.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
@@ -14,11 +15,9 @@ namespace Microsoft.Build.UnitTests
 {
     public sealed class AssignCulture_Tests
     {
-        /*
-        * Method:   Basic
-        *
-        * Test the basic functionality.
-        */
+        /// <summary>
+        /// Tests the basic functionality.
+        /// </summary>
         [Fact]
         public void Basic()
         {
@@ -35,11 +34,9 @@ public void Basic()
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
 
-        /*
-        * Method:   CultureAttributePrecedence
-        *
-        * Any pre-existing Culture attribute on the item is to be ignored
-        */
+        /// <summary>
+        /// Any pre-existing Culture attribute on the item is to be ignored
+        /// </summary>
         [Fact]
         public void CultureAttributePrecedence()
         {
@@ -57,13 +54,11 @@ public void CultureAttributePrecedence()
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
 
-        /*
-        * Method:   CultureAttributePrecedenceWithBogusCulture
-        *
-        * This is really a corner case.
-        * If the incoming item has a 'Culture' attribute already, but that culture is invalid,
-        * we still overwrite that culture.
-        */
+        /// <summary>
+        /// This is really a corner case.
+        /// If the incoming item has a 'Culture' attribute already, but that culture is invalid,
+        /// we still overwrite that culture.
+        /// </summary>
         [Fact]
         public void CultureAttributePrecedenceWithBogusCulture()
         {
@@ -81,14 +76,10 @@ public void CultureAttributePrecedenceWithBogusCulture()
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
 
-
-
-        /*
-        * Method:   AttributeForwarding
-        *
-        * Make sure that attributes set on input items are forwarded to output items.
-        * This applies to every attribute except for the one pointed to by CultureAttribute.
-        */
+        /// <summary>
+        /// Make sure that attributes set on input items are forwarded to output items.
+        /// This applies to every attribute except for the one pointed to by CultureAttribute.
+        /// </summary>
         [Fact]
         public void AttributeForwarding()
         {
@@ -108,12 +99,10 @@ public void AttributeForwarding()
         }
 
 
-        /*
-        * Method:   NoCulture
-        *
-        * Test the case where an item has no embedded culture. For example,
-        * "MyResource.resx"
-        */
+        /// <summary>
+        /// Test the case where an item has no embedded culture. For example:
+        /// "MyResource.resx"
+        /// </summary>
         [Fact]
         public void NoCulture()
         {
@@ -130,11 +119,9 @@ public void NoCulture()
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
 
-        /*
-        * Method:   NoExtension
-        *
-        * Test the case where an item has no extension. For example "MyResource".
-        */
+        /// <summary>
+        /// Test the case where an item has no extension. For example "MyResource".
+        /// </summary>
         [Fact]
         public void NoExtension()
         {
@@ -151,12 +138,10 @@ public void NoExtension()
             Assert.Equal("MyResource", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
 
-        /*
-        * Method:   DoubleDot
-        *
-        * Test the case where an item has two dots embedded, but otherwise looks
-        * like a well-formed item. For example "MyResource..resx".
-        */
+        /// <summary>
+        ///  Test the case where an item has two dots embedded, but otherwise looks
+        /// like a well-formed item.For example "MyResource..resx".
+        /// </summary>
         [Fact]
         public void DoubleDot()
         {
@@ -194,12 +179,11 @@ public void Regress283991()
             Assert.Single(t.AssignedFilesWithNoCulture);
         }
 
-        /*
-        * Method:   PseudoLocalization
-        *
-        * Test the usage of Windows Pseudo-Locales
-        * https://docs.microsoft.com/en-gb/windows/desktop/Intl/pseudo-locales
-        */
+        /// <summary>
+        /// Test the usage of Windows Pseudo-Locales
+        /// https://docs.microsoft.com/en-gb/windows/desktop/Intl/pseudo-locales
+        /// </summary>
+        /// <param name="culture"></param>
         [Theory]
         [InlineData("qps-ploc")]
         [InlineData("qps-plocm")]
@@ -277,5 +261,47 @@ public void Pseudolocales_CaseInsensitive()
             Assert.Equal($"MyResource.{culture}.resx", t.AssignedFiles[0].ItemSpec);
             Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
         }
+
+        /// <summary>
+        /// Any pre-existing Culture attribute on the item is to be respected
+        /// </summary>
+        [Fact]
+        public void CultureMetaDataShouldBeRespected()
+        {
+            AssignCulture t = new AssignCulture();
+            t.BuildEngine = new MockEngine();
+            ITaskItem i = new TaskItem("MyResource.fr.resx");
+            i.SetMetadata("Culture", "en-GB");
+            t.Files = new ITaskItem[] { i };
+            t.RespectAlreadyAssignedItemCulture = true;
+            t.Execute();
+
+            Assert.Single(t.AssignedFiles);
+            Assert.Single(t.CultureNeutralAssignedFiles);
+            Assert.Equal("en-GB", t.AssignedFiles[0].GetMetadata("Culture"));
+            Assert.Equal("MyResource.fr.resx", t.AssignedFiles[0].ItemSpec);
+            Assert.Equal("MyResource.fr.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
+        }
+
+        /// <summary>
+        /// Any pre-existing Culture attribute on the item is not to be respected, because culture is not set
+        /// </summary>
+        [Fact]
+        public void CultureMetaDataShouldNotBeRespected()
+        {
+            AssignCulture t = new AssignCulture();
+            t.BuildEngine = new MockEngine();
+            ITaskItem i = new TaskItem("MyResource.fr.resx");
+            i.SetMetadata("Culture", "");
+            t.Files = new ITaskItem[] { i };
+            t.RespectAlreadyAssignedItemCulture = true;
+            t.Execute();
+
+            Assert.Single(t.AssignedFiles);
+            Assert.Single(t.CultureNeutralAssignedFiles);
+            Assert.Equal("fr", t.AssignedFiles[0].GetMetadata("Culture"));
+            Assert.Equal("MyResource.fr.resx", t.AssignedFiles[0].ItemSpec);
+            Assert.Equal("MyResource.resx", t.CultureNeutralAssignedFiles[0].ItemSpec);
+        }
     }
 }
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index f55d2fd6268..277145c17d7 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -41,6 +41,12 @@ public class AssignCulture : TaskExtension
         [Required]
         public ITaskItem[] Files { get; set; } = Array.Empty<ITaskItem>();
 
+        /// <summary>
+        /// If the flag set to 'true' the incoming list with existing Culture metadata will not be ammended and CultureNeutralAssignedFiles filename will be equal to the original.
+        /// In case the Culture metadata was not provided, the logic of RespectAlreadyAssignedItemCulture will not take any effect.
+        /// </summary>
+        public bool RespectAlreadyAssignedItemCulture { get; set; } = false;
+
         /// <summary>
         /// This outgoing list of files is exactly the same as the incoming Files
         /// list except that an attribute name "Culture" will have been added if
@@ -134,32 +140,44 @@ public override bool Execute()
                     AssignedFiles[i] = new TaskItem(Files[i]);
 
                     string dependentUpon = AssignedFiles[i].GetMetadata(ItemMetadataNames.dependentUpon);
-                    Culture.ItemCultureInfo info = Culture.GetItemCultureInfo(
-                            AssignedFiles[i].ItemSpec,
-                            dependentUpon,
-                            // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
-                            // https://github.com/dotnet/msbuild/issues/3064
-                            ConversionUtilities.ValidBooleanFalse(AssignedFiles[i].GetMetadata("WithCulture")));
-
-                    if (!string.IsNullOrEmpty(info.culture))
+                    string existingCulture = AssignedFiles[i].GetMetadata(ItemMetadataNames.culture);
+                    
+                    if (RespectAlreadyAssignedItemCulture && !string.IsNullOrEmpty(existingCulture))
                     {
-                        AssignedFiles[i].SetMetadata("Culture", info.culture);
-                        AssignedFiles[i].SetMetadata("WithCulture", "true");
+                        AssignedFiles[i].SetMetadata(ItemMetadataNames.withCulture, "true");
                         cultureList.Add(AssignedFiles[i]);
+
+                        CultureNeutralAssignedFiles[i] = new TaskItem(AssignedFiles[i]);
                     }
                     else
                     {
-                        noCultureList.Add(AssignedFiles[i]);
-                        AssignedFiles[i].SetMetadata("WithCulture", "false");
-                    }
-
-                    CultureNeutralAssignedFiles[i] =
+                        Culture.ItemCultureInfo info = Culture.GetItemCultureInfo(
+                            AssignedFiles[i].ItemSpec,
+                            dependentUpon,
+                            // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
+                            // https://github.com/dotnet/msbuild/issues/3064
+                            ConversionUtilities.ValidBooleanFalse(AssignedFiles[i].GetMetadata(ItemMetadataNames.withCulture)));
+
+                        if (!string.IsNullOrEmpty(info.culture))
+                        {
+                            AssignedFiles[i].SetMetadata(ItemMetadataNames.culture, info.culture);
+                            AssignedFiles[i].SetMetadata(ItemMetadataNames.withCulture, "true");
+                            cultureList.Add(AssignedFiles[i]);
+                        }
+                        else
+                        {
+                            noCultureList.Add(AssignedFiles[i]);
+                            AssignedFiles[i].SetMetadata(ItemMetadataNames.withCulture, "false");
+                        }
+
+                        CultureNeutralAssignedFiles[i] =
                         new TaskItem(AssignedFiles[i]) { ItemSpec = info.cultureNeutralFilename };
+                    }
 
                     Log.LogMessageFromResources(
                         MessageImportance.Low,
                         "AssignCulture.Comment",
-                        AssignedFiles[i].GetMetadata("Culture"),
+                        AssignedFiles[i].GetMetadata(ItemMetadataNames.culture),
                         AssignedFiles[i].ItemSpec);
                 }
                 catch (ArgumentException e)
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index 76e17988b08..accb98d7438 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -829,81 +829,44 @@ private XmlDocument LoadAndValidateXmlDocument(string filePath, bool validateFil
 
                 if (fileExists)
                 {
-                    var xmlTextReader = new XmlTextReader(filePath) { DtdProcessing = DtdProcessing.Ignore };
-
-                    XmlReader xmlReader = xmlTextReader;
-
+                    XmlReaderSettings xmlReaderSettings = new XmlReaderSettings();
+                    xmlReaderSettings.DtdProcessing = DtdProcessing.Ignore;
                     if (validate)
                     {
-#pragma warning disable 618 // Using XmlValidatingReader. TODO: We need to switch to using XmlReader.Create() with validation.
-                        using var validatingReader = new XmlValidatingReader(xmlReader);
-#pragma warning restore 618
-                        var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
-                        FileStream fs = File.OpenRead(schemaPath);
-                        using (XmlReader xr = XmlReader.Create(fs, xrSettings))
+                        xmlReaderSettings.ValidationType = ValidationType.Schema;
+                        xmlReaderSettings.XmlResolver = null;
+                        xmlReaderSettings.ValidationEventHandler += results.SchemaValidationEventHandler; ;
+                        xmlReaderSettings.Schemas.Add(null, schemaPath);
+                    }
+
+                    using (StreamReader streamReader = new StreamReader(filePath))
+                    {
+                        using (XmlReader xmlReader = XmlReader.Create(streamReader, xmlReaderSettings, filePath))
                         {
                             try
                             {
-                                // first, add our schema to the validating reader's collection of schemas
-                                var xmlSchema = validatingReader.Schemas.Add(null, xr);
-
-                                // if our schema namespace gets out of sync,
-                                //   then all of our calls to SelectNodes and SelectSingleNode will fail
-                                Debug.Assert((xmlSchema != null) &&
-                                    string.Equals(schemaNamespace, xmlSchema.TargetNamespace, StringComparison.Ordinal),
-                                    System.IO.Path.GetFileName(schemaPath) + " and BootstrapperBuilder.vb have mismatched namespaces, so the BootstrapperBuilder will fail to work.");
-
-                                // if we're supposed to be validating, then hook up our handler
-                                validatingReader.ValidationEventHandler += results.SchemaValidationEventHandler;
-
-                                // switch readers so the doc does the actual read over the validating
-                                //   reader so we get validation events as we load the document
-                                xmlReader = validatingReader;
+                                Debug.Assert(_document != null, "our document should have been created by now!");
+                                xmlDocument = new XmlDocument(_document.NameTable);
+                                xmlDocument.Load(xmlReader);
                             }
                             catch (XmlException ex)
                             {
-                                Debug.Fail("Failed to load schema '" + schemaPath + "' due to the following exception:\r\n" + ex.Message);
-                                validate = false;
+                                Debug.Fail("Failed to load document '" + filePath + "' due to the following exception:\r\n" + ex.Message);
+                                return null;
                             }
                             catch (System.Xml.Schema.XmlSchemaException ex)
                             {
-                                Debug.Fail("Failed to load schema '" + schemaPath + "' due to the following exception:\r\n" + ex.Message);
-                                validate = false;
+                                Debug.Fail("Failed to load document '" + filePath + "' due to the following exception:\r\n" + ex.Message);
+                                return null;
                             }
                         }
                     }
 
-                    try
-                    {
-                        Debug.Assert(_document != null, "our document should have been created by now!");
-                        xmlDocument = new XmlDocument(_document.NameTable);
-                        xmlDocument.Load(xmlReader);
-                    }
-                    catch (XmlException ex)
-                    {
-                        Debug.Fail("Failed to load document '" + filePath + "' due to the following exception:\r\n" + ex.Message);
-                        return null;
-                    }
-                    catch (System.Xml.Schema.XmlSchemaException ex)
-                    {
-                        Debug.Fail("Failed to load document '" + filePath + "' due to the following exception:\r\n" + ex.Message);
-                        return null;
-                    }
-                    finally
-                    {
-                        xmlReader.Close();
-                    }
-
                     // Note that the xml document's default namespace must match the schema namespace
                     //   or none of our SelectNodes/SelectSingleNode calls will succeed
                     Debug.Assert(xmlDocument.DocumentElement != null &&
-                        string.Equals(xmlDocument.DocumentElement.NamespaceURI, schemaNamespace, StringComparison.Ordinal),
-                        "'" + xmlDocument.DocumentElement.NamespaceURI + "' is not '" + schemaNamespace + "'...");
-
-                    if ((xmlDocument.DocumentElement == null) ||
-                       (!string.Equals(xmlDocument.DocumentElement.NamespaceURI, schemaNamespace, StringComparison.Ordinal)))
-                    {
-                    }
+                                string.Equals(xmlDocument.DocumentElement.NamespaceURI, schemaNamespace, StringComparison.Ordinal),
+                                "'" + xmlDocument.DocumentElement.NamespaceURI + "' is not '" + schemaNamespace + "'...");
                 }
             }
 
diff --git a/src/Tasks/FileIO/GetFileHash.cs b/src/Tasks/FileIO/GetFileHash.cs
index 23ae783b33f..2d1ec4f5308 100644
--- a/src/Tasks/FileIO/GetFileHash.cs
+++ b/src/Tasks/FileIO/GetFileHash.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Security.Cryptography;
+using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -17,7 +18,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Computes the checksum for a single file.
     /// </summary>
-    public sealed class GetFileHash : TaskExtension
+    public sealed class GetFileHash : TaskExtension, ICancelableTask
     {
         internal const string _defaultFileHashAlgorithm = "SHA256";
         internal const string _hashEncodingHex = "hex";
@@ -77,8 +78,10 @@ public override bool Execute()
                 return false;
             }
 
+            var parallelOptions = new ParallelOptions() { CancellationToken = _cancellationTokenSource.Token };
+
             var writeLock = new object();
-            Parallel.For(0, Files.Length, index =>
+            Parallel.For(0, Files.Length, parallelOptions, index =>
             {
                 var file = Files[index];
 
@@ -88,7 +91,7 @@ public override bool Execute()
                     return;
                 }
 
-                var hash = ComputeHash(algorithmFactory, file.ItemSpec);
+                var hash = ComputeHash(algorithmFactory, file.ItemSpec, _cancellationTokenSource.Token);
                 var encodedHash = EncodeHash(encoding, hash);
 
                 lock (writeLock)
@@ -115,6 +118,13 @@ public override bool Execute()
             return !Log.HasLoggedErrors;
         }
 
+        private readonly CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();
+
+        public void Cancel()
+        {
+            _cancellationTokenSource.Cancel();
+        }
+
         internal static string EncodeHash(HashEncoding encoding, byte[] hash)
         {
             return encoding switch
@@ -128,12 +138,16 @@ internal static string EncodeHash(HashEncoding encoding, byte[] hash)
         internal static bool TryParseHashEncoding(string value, out HashEncoding encoding)
             => Enum.TryParse<HashEncoding>(value, /*ignoreCase:*/ true, out encoding);
 
-        internal static byte[] ComputeHash(Func<HashAlgorithm> algorithmFactory, string filePath)
+        internal static byte[] ComputeHash(Func<HashAlgorithm> algorithmFactory, string filePath, CancellationToken ct)
         {
             using (var stream = File.OpenRead(filePath))
             using (var algorithm = algorithmFactory())
             {
+#if NET5_0_OR_GREATER
+                return algorithm.ComputeHashAsync(stream, ct).Result;
+#else
                 return algorithm.ComputeHash(stream);
+#endif
             }
         }
     }
diff --git a/src/Tasks/FileIO/VerifyFileHash.cs b/src/Tasks/FileIO/VerifyFileHash.cs
index 11b168b7cd2..9c3eca7556b 100644
--- a/src/Tasks/FileIO/VerifyFileHash.cs
+++ b/src/Tasks/FileIO/VerifyFileHash.cs
@@ -4,6 +4,7 @@
 using System;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
+using System.Threading;
 
 #nullable disable
 
@@ -12,7 +13,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Verifies that a file matches the expected file hash.
     /// </summary>
-    public sealed class VerifyFileHash : TaskExtension
+    public sealed class VerifyFileHash : TaskExtension, ICancelableTask
     {
         /// <summary>
         /// The file path.
@@ -56,7 +57,7 @@ public override bool Execute()
                 return false;
             }
 
-            byte[] hash = GetFileHash.ComputeHash(algorithmFactory, File);
+            byte[] hash = GetFileHash.ComputeHash(algorithmFactory, File, _cancellationTokenSource.Token);
             string actualHash = GetFileHash.EncodeHash(encoding, hash);
             var comparison = encoding == Tasks.HashEncoding.Hex
                 ? StringComparison.OrdinalIgnoreCase
@@ -69,5 +70,12 @@ public override bool Execute()
 
             return !Log.HasLoggedErrors;
         }
+
+        private readonly CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();
+
+        public void Cancel()
+        {
+            _cancellationTokenSource.Cancel();
+        }
     }
 }
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 3fc9a9c4d00..5e81c64c525 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -385,11 +385,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <_GenerateBindingRedirectsIntermediateAppConfig>$(IntermediateOutputPath)$(TargetFileName).config</_GenerateBindingRedirectsIntermediateAppConfig>
   </PropertyGroup>
-  
+
   <PropertyGroup Condition="'$(MSBuildCopyMarkerName)' == ''">
     <MSBuildCopyMarkerName>$(MSBuildProjectFile)</MSBuildCopyMarkerName>
     <!-- For a long MSBuildProjectFile let's shorten this to 17 chars - using the first 8 codepoints of the filename and a filename hash. -->
-    <MSBuildCopyMarkerName Condition="'$(MSBuildCopyMarkerName.Length)' &gt; '17'">$([MSBuild]::SubstringByTextElements($(MSBuildProjectFile), 0, 8)).$([MSBuild]::StableStringHash($(MSBuildProjectFile)).ToString("X8"))</MSBuildCopyMarkerName>
+    <MSBuildCopyMarkerName Condition="'$(MSBuildCopyMarkerName.Length)' &gt; '17'">$([MSBuild]::SubstringByAsciiChars($(MSBuildProjectFile), 0, 8)).$([MSBuild]::StableStringHash($(MSBuildProjectFile)).ToString("X8"))</MSBuildCopyMarkerName>
     <MSBuildCopyMarkerName>$(MSBuildCopyMarkerName).Up2Date</MSBuildCopyMarkerName>
   </PropertyGroup>
 
@@ -2566,7 +2566,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <SDKReferenceRegistryRoot Condition="'$(SDKReferenceRegistryRoot)' == ''">Software\Microsoft\Microsoft SDKs</SDKReferenceRegistryRoot>
     <SDKReferenceDirectoryRoot Condition="'$(SDKReferenceDirectoryRoot)' == ''">$(LocalAppData)\Microsoft SDKs;$(MSBuildProgramFiles32)\Microsoft SDKs</SDKReferenceDirectoryRoot>
     <!-- Manifest driven extension SDK locations -->
-    <SDKExtensionDirectoryRoot Condition="'$(SDKExtensionDirectoryRoot)' == '' and '$(SDKIdentifier)' != ''">$(MSBuildProgramFiles32)\Microsoft SDKs\Windows Kits\10;$(MSBuildProgramFiles32)\Windows Kits\10</SDKExtensionDirectoryRoot>
+    <SDKExtensionDirectoryRoot Condition="'$(SDKExtensionDirectoryRoot)' == '' and '$(SDKIdentifier)' != ''">$(MSBuildProgramFiles32)\Microsoft SDKs\Windows Kits\10;$(WindowsKitsRoot)</SDKExtensionDirectoryRoot>
 
     <!-- UAP projects by default should support Windows 8.1 SDKs -->
     <SupportWindows81SDKs Condition="'$(SupportWindows81SDKs)' == '' and '$(Support81SDKs)' != 'false' and '$(TargetPlatformIdentifier)' == 'UAP'">true</SupportWindows81SDKs>
@@ -3244,6 +3244,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       Name="SplitResourcesByCulture"
       DependsOnTargets="AssignTargetPaths">
 
+    <PropertyGroup>
+      <RespectAlreadyAssignedItemCulture Condition="'$(RespectAlreadyAssignedItemCulture)' == ''">false</RespectAlreadyAssignedItemCulture>
+    </PropertyGroup>
+
     <Warning Condition="'@(ResxWithNoCulture)'!=''" Code="MSB9000" Text="ResxWithNoCulture item type is deprecated. Use EmbeddedResource items instead."/>
     <Warning Condition="'@(ResxWithCulture)'!=''" Code="MSB9001" Text="ResxWithCulture item type is deprecated. Use EmbeddedResource items instead."/>
     <Warning Condition="'@(NonResxWithCulture)'!=''" Code="MSB9002" Text="NonResxWithCulture item type is deprecated. Use EmbeddedResource items instead."/>
@@ -3261,7 +3265,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </EmbeddedResource>
     </ItemGroup>
 
-    <AssignCulture Files="@(EmbeddedResource)" Condition="'%(Extension)'!='.licx'">
+    <AssignCulture Files="@(EmbeddedResource)" Condition="'%(Extension)'!='.licx'"  RespectAlreadyAssignedItemCulture="$(RespectAlreadyAssignedItemCulture)">
       <!-- Create the list of culture resx and embedded resource files -->
       <Output TaskParameter="AssignedFilesWithCulture" ItemName="_MixedResourceWithCulture"/>
       <!-- Create the list of non-culture resx and embedded resource files -->
@@ -6819,7 +6823,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <Import Project="$(MsTestToolsTargets)" Condition="Exists('$(MsTestToolsTargets)')" />
-  
+
   <PropertyGroup>
     <UseMSBuildTestInfrastructure Condition="'$(UseMSBuildTestInfrastructure)' == ''">false</UseMSBuildTestInfrastructure>
   </PropertyGroup>
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index a61f1a9fb4c..8264bc07be9 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -52,7 +52,13 @@ public static string ExecMSBuild(string pathToMsBuildExe, string msbuildParamete
             return RunProcessAndGetOutput(pathToExecutable, msbuildParameters, out successfulExit, shellExecute, outputHelper);
         }
 
-        public static string ExecBootstrapedMSBuild(string msbuildParameters, out bool successfulExit, bool shellExecute = false, ITestOutputHelper outputHelper = null)
+        public static string ExecBootstrapedMSBuild(
+            string msbuildParameters,
+            out bool successfulExit,
+            bool shellExecute = false,
+            ITestOutputHelper outputHelper = null,
+            bool attachProcessId = true,
+            int timeoutMilliseconds = 30_000)
         {
             BootstrapLocationAttribute attribute = Assembly.GetExecutingAssembly().GetCustomAttribute<BootstrapLocationAttribute>()
                                                    ?? throw new InvalidOperationException("This test assembly does not have the BootstrapLocationAttribute");
@@ -64,7 +70,7 @@ public static string ExecBootstrapedMSBuild(string msbuildParameters, out bool s
 #else
             string pathToExecutable = Path.Combine(binaryFolder, "MSBuild.exe");
 #endif
-            return RunProcessAndGetOutput(pathToExecutable, msbuildParameters, out successfulExit, shellExecute, outputHelper);
+            return RunProcessAndGetOutput(pathToExecutable, msbuildParameters, out successfulExit, shellExecute, outputHelper, attachProcessId, timeoutMilliseconds);
         }
 
         private static void AdjustForShellExecution(ref string pathToExecutable, ref string arguments)
@@ -84,9 +90,16 @@ private static void AdjustForShellExecution(ref string pathToExecutable, ref str
         }
 
         /// <summary>
-        /// Run the process and get stdout and stderr
+        /// Run the process and get stdout and stderr.
         /// </summary>
-        public static string RunProcessAndGetOutput(string process, string parameters, out bool successfulExit, bool shellExecute = false, ITestOutputHelper outputHelper = null)
+        public static string RunProcessAndGetOutput(
+            string process,
+            string parameters,
+            out bool successfulExit,
+            bool shellExecute = false,
+            ITestOutputHelper outputHelper = null,
+            bool attachProcessId = true,
+            int timeoutMilliseconds = 30_000)
         {
             if (shellExecute)
             {
@@ -127,16 +140,17 @@ public static string RunProcessAndGetOutput(string process, string parameters, o
                 p.BeginErrorReadLine();
                 p.StandardInput.Dispose();
 
+                TimeSpan timeout = TimeSpan.FromMilliseconds(timeoutMilliseconds);
                 if (Traits.Instance.DebugUnitTests)
                 {
                     p.WaitForExit();
                 }
-                else if (!p.WaitForExit(30_000))
+                else if (!p.WaitForExit(timeoutMilliseconds))
                 {
-                    // Let's not create a unit test for which we need more than 30 sec to execute.
+                    // Let's not create a unit test for which we need more than requested timeout to execute.
                     // Please consider carefully if you would like to increase the timeout.
                     p.KillTree(1000);
-                    throw new TimeoutException($"Test failed due to timeout: process {p.Id} is active for more than 30 sec.");
+                    throw new TimeoutException($"Test failed due to timeout: process {p.Id} is active for more than {timeout.TotalSeconds} sec.");
                 }
 
                 // We need the WaitForExit call without parameters because our processing of output/error streams is not synchronous.
@@ -148,10 +162,13 @@ public static string RunProcessAndGetOutput(string process, string parameters, o
                 successfulExit = p.ExitCode == 0;
             }
 
-            WriteOutput("Process ID is " + pid + "\r\n");
-            WriteOutput("==============");
+            if (attachProcessId)
+            {
+                output += "Process ID is " + pid + "\r\n";
+                WriteOutput("Process ID is " + pid + "\r\n");
+                WriteOutput("==============");
+            }
 
-            output += "Process ID is " + pid + "\r\n";
             return output;
 
             void WriteOutput(string data)
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index 822c68ad317..11f275f9709 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -26,7 +26,7 @@ public ToolTask_Tests(ITestOutputHelper testOutput)
             _output = testOutput;
         }
 
-        private sealed class MyTool : ToolTask, IDisposable
+        private class MyTool : ToolTask, IDisposable
         {
             private string _fullToolName;
             private string _responseFileCommands = string.Empty;
@@ -737,6 +737,41 @@ public void VisualBasicLikeEscapedQuotesInCommandAreNotMadeForwardSlashes()
             engine.Errors.ShouldBe(0);
         }
 
+        private sealed class MyToolWithCustomProcess : MyTool
+        {
+            protected override Process StartToolProcess(Process proc)
+            {
+                Process customProcess = new Process();
+                customProcess.StartInfo = proc.StartInfo;
+
+                customProcess.EnableRaisingEvents = true;
+                customProcess.Exited += ReceiveExitNotification;
+
+                customProcess.ErrorDataReceived += ReceiveStandardErrorData;
+                customProcess.OutputDataReceived += ReceiveStandardOutputData;
+
+                return base.StartToolProcess(customProcess);
+            }
+        }
+
+        [Fact]
+        public void UsesCustomProcess()
+        {
+            using (MyToolWithCustomProcess t = new MyToolWithCustomProcess())
+            {
+                MockEngine3 engine = new MockEngine3();
+                t.BuildEngine = engine;
+                t.MockCommandLineCommands = NativeMethodsShared.IsWindows
+                    ? "/C echo hello_stdout & echo hello_stderr >&2"
+                    : "-c \"echo hello_stdout ; echo hello_stderr >&2\"";
+
+                t.Execute();
+
+                engine.AssertLogContains("\nhello_stdout");
+                engine.AssertLogContains("\nhello_stderr");
+            }
+        }
+
         /// <summary>
         /// Verifies that a ToolTask running under the command processor on Windows has autorun
         /// disabled or enabled depending on an escape hatch.
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 52313983a33..2443ff50c43 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -1172,7 +1172,7 @@ private void ReceiveTimeoutNotification(object unused)
         /// <remarks>This method is used as a System.EventHandler delegate.</remarks>
         /// <param name="sender"></param>
         /// <param name="e"></param>
-        private void ReceiveExitNotification(object sender, EventArgs e)
+        protected void ReceiveExitNotification(object sender, EventArgs e)
         {
             ErrorUtilities.VerifyThrow(_toolExited != null,
                 "The signalling event for tool exit must be available.");
@@ -1195,7 +1195,7 @@ private void ReceiveExitNotification(object sender, EventArgs e)
         /// <remarks>This method is used as a System.Diagnostics.DataReceivedEventHandler delegate.</remarks>
         /// <param name="sender"></param>
         /// <param name="e"></param>
-        private void ReceiveStandardErrorData(object sender, DataReceivedEventArgs e) => ReceiveStandardErrorOrOutputData(e, _standardErrorData, _standardErrorDataAvailable);
+        protected void ReceiveStandardErrorData(object sender, DataReceivedEventArgs e) => ReceiveStandardErrorOrOutputData(e, _standardErrorData, _standardErrorDataAvailable);
 
         /// <summary>
         /// Queues up the output from the stdout stream of the process executing
@@ -1206,7 +1206,7 @@ private void ReceiveExitNotification(object sender, EventArgs e)
         /// <remarks>This method is used as a System.Diagnostics.DataReceivedEventHandler delegate.</remarks>
         /// <param name="sender"></param>
         /// <param name="e"></param>
-        private void ReceiveStandardOutputData(object sender, DataReceivedEventArgs e) => ReceiveStandardErrorOrOutputData(e, _standardOutputData, _standardOutputDataAvailable);
+        protected void ReceiveStandardOutputData(object sender, DataReceivedEventArgs e) => ReceiveStandardErrorOrOutputData(e, _standardOutputData, _standardOutputDataAvailable);
 
         /// <summary>
         /// Queues up the output from either the stderr or stdout stream of the
diff --git a/template_feed/Microsoft.Build.Templates.csproj b/template_feed/Microsoft.Build.Templates.csproj
new file mode 100644
index 00000000000..d56a04b4c27
--- /dev/null
+++ b/template_feed/Microsoft.Build.Templates.csproj
@@ -0,0 +1,29 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <PropertyGroup>
+    <PackageId>Microsoft.Build.Templates</PackageId>
+    <Authors>Microsoft</Authors>
+    <Description>Common Microsoft Build Templates</Description>
+    <PackageProjectUrl>https://github.com/dotnet/msbuild</PackageProjectUrl>
+    <PackageType>Template</PackageType>
+    <TargetFramework>$(LatestDotNetCoreForMSBuild)</TargetFramework>
+    <IncludeBuildOutput>false</IncludeBuildOutput>
+    <NoWarn>$(NoWarn);NU5128</NoWarn>
+    <IsPackable>true</IsPackable>
+    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <LocalizeTemplates>false</LocalizeTemplates>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <PackageReference Include="Microsoft.TemplateEngine.Tasks" Version="*" PrivateAssets="all" IsImplicitlyDefined="true"/>
+  </ItemGroup>
+
+  <ItemGroup>
+    <Content Include="content\**" Exclude="content\**\bin\**;content\**\obj\**" PackagePath="content"/>
+    <Compile Remove="**\*" />
+  </ItemGroup>
+
+</Project>
diff --git a/template_feed/README.md b/template_feed/README.md
new file mode 100644
index 00000000000..f2b021d3647
--- /dev/null
+++ b/template_feed/README.md
@@ -0,0 +1,9 @@
+## MSBuild Custom Analyzer Template Package
+
+The package contains the template designed to streamline the creation of MSBuild analyzer libraries.
+| Template name | Short name | Description|
+|---|---|---|
+|MSBuild Custom Analyzer Template|`msbuildanalyzer`|A project for creating a MSBuild analyzer library that targets .NET Standard.|
+
+The package is available for download from nuget.org.
+Please feel to contribute or provide the feedback in discussions or via opening the issue in dotnet/msbuild repo.
diff --git a/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json b/template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json
similarity index 99%
rename from template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json
rename to template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json
index 52c4467e930..8bd2d1853e3 100644
--- a/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json
+++ b/template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json
@@ -46,4 +46,4 @@
         "continueOnError": true
       }
     ]
-  }
\ No newline at end of file
+  }
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Analyzer1.cs b/template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs
similarity index 100%
rename from template_feed/Microsoft.AnalyzerTemplate/Analyzer1.cs
rename to template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj b/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
similarity index 96%
rename from template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
rename to template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
index 0a1b8f974fc..33d8c992326 100644
--- a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
+++ b/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
@@ -36,10 +36,10 @@
 
     <ItemGroup>
     <!-- Update the collection of items to pack with the DLLs from the NuGet packages -->
-    <None Include="@(_PackagesToPack)" Pack="true" PackagePath="lib" Visible="false" />
+    <None Include="@(_PackagesToPack)" Pack="true" PackagePath="build" Visible="false" />
 
     <!-- Add the DLL produced by the current project to the NuGet package -->
-    <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="lib" Visible="false" />
+    <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="build" Visible="false" />
     </ItemGroup>
   </Target>
 </Project>
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props b/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
similarity index 62%
rename from template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
rename to template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
index 3b752b831cc..5a606b3cac6 100644
--- a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
+++ b/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Project>
   <PropertyGroup>
-	  <MSBuildAnalyzer>$([MSBuild]::RegisterAnalyzer($(MSBuildThisFileDirectory)..\lib\Company.AnalyzerTemplate.dll))</MSBuildAnalyzer>
+	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)Company.AnalyzerTemplate.dll))</MSBuildAnalyzer>
   </PropertyGroup>
   <ItemGroup>
     <PackageVersion Include="Microsoft.Build" Version="1.0.0-MicrosoftBuildPackageVersion" />
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/README.md b/template_feed/content/Microsoft.AnalyzerTemplate/README.md
new file mode 100644
index 00000000000..4f29145e7f0
--- /dev/null
+++ b/template_feed/content/Microsoft.AnalyzerTemplate/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Analyzer Template
+
+## Overview
+MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild analyzer libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom analysis rules.
+
+## Getting Started
+To use the MSBuild Custom Analyzer Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildanalyzer
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildanalyzer -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
\ No newline at end of file
