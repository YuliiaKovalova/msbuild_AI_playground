diff --git a/.editorconfig b/.editorconfig
index 7b0f1419bb8..01161a81aa6 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -1,4 +1,4 @@
-# editorconfig.org
+ï»¿# editorconfig.org
 
 # top-most EditorConfig file
 root = true
@@ -163,6 +163,9 @@ dotnet_code_quality.ca2208.api_surface = public
 # CA1852: Seal internal types
 dotnet_diagnostic.ca1852.severity = warning
 
+# CA2000: Dispose objects before losing scope
+dotnet_diagnostic.ca2000.severity = error
+
 # RS0037: Enable tracking of nullability of reference types in the declared API
 # Our API is not annotated but new classes get nullable enabled so disable this.
 # We'd be happy if everything was annotated and this could be removed.
@@ -409,3 +412,6 @@ dotnet_diagnostic.IDE0290.severity = suggestion
 dotnet_diagnostic.IDE0300.severity = suggestion
 dotnet_diagnostic.IDE0301.severity = suggestion
 dotnet_diagnostic.IDE0305.severity = suggestion
+
+# Temporarily disable SA1010 "Opening square brackets should not be preceded by a space" until https://github.com/DotNetAnalyzers/StyleCopAnalyzers/issues/3687 is fixed
+dotnet_diagnostic.SA1010.severity = none
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 12768a44440..daf200ae88e 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -4,7 +4,43 @@ trigger:
 - vs*
 
 jobs:
+- job: CheckVersionBumpOnReleaseBranches
+  displayName: "Check Version Bump On Release Branches"
+  steps:
+  - powershell: |
+      $versionsFile = "eng/Versions.props"
+      $changedFiles = git diff --name-only HEAD HEAD~1
+      $changedVersionsFile = $changedFiles | Where-Object { $_ -eq $versionsFile }
+      $isInitialCommit = $false
+      $isVersionBumped = $false
+      if ($changedVersionsFile -ne $null) {
+        $difference = git diff HEAD~1 $versionsFile
+        $changedContent = $difference -join " "
+        # 'DotNetFinalVersionKind' is expected to be added only during the initial setup of the release branch
+        $initialCommitPattern = '-\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix> \+\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix>.*<DotNetFinalVersionKind>release<\/DotNetFinalVersionKind>'
+        $isInitialCommit = $changedContent -match $initialCommitPattern
+        $pattern = '-\s*<VersionPrefix>\d+\.\d+\.(?<previous>\d+)<\/VersionPrefix>.* \+\s*<VersionPrefix>\d+\.\d+\.(?<current>\d+)<\/VersionPrefix>'
+        if (!($isInitialCommit) -and ($changedContent -match $pattern)) {
+          try {
+            $previousPatch = [Convert]::ToInt32($Matches.previous)
+            $currentPatch = [Convert]::ToInt32($Matches.current)
+            if ($currentPatch -gt $previousPatch) {
+              $isVersionBumped = $true
+            }
+          } catch {
+            Write-Host "An error occurred during conversion: $_"
+          }
+        }
+      }
+
+      if (!($isInitialCommit -or $isVersionBumped)) {
+        throw "Hello! I noticed that you're targeting one of our servicing branches. You need to increase the revision version number (the last part) of 'VersionPrefix' in eng/Versions.props."
+      }
+    condition: startsWith(variables['System.PullRequest.TargetBranch'], 'vs')
+    displayName: "Check if patch version is bumped up"
+
 - job: IfOnlyDocumentionChanged
+  dependsOn: CheckVersionBumpOnReleaseBranches
   displayName: "Check whether Test Results need to be executed"
   steps:
   - powershell: |
diff --git a/README.md b/README.md
index bb357a2ad6d..f770f459200 100644
--- a/README.md
+++ b/README.md
@@ -2,7 +2,7 @@
 
 The Microsoft Build Engine is a platform for building applications. This engine, also known as MSBuild, provides an XML schema for a project file that controls how the build platform processes and builds software. Visual Studio uses MSBuild, but MSBuild can run without Visual Studio. By invoking msbuild.exe on your project or solution file, you can orchestrate and build products in environments where Visual Studio isn't installed.
 
-For more information on MSBuild, see the [MSBuild documentation](https://docs.microsoft.com/visualstudio/msbuild/msbuild) on docs.microsoft.com.
+For more information on MSBuild, see the [MSBuild documentation](https://learn.microsoft.com/visualstudio/msbuild/msbuild) on learn.microsoft.com.
 
 The [changelog](documentation/Changelog.md) has detailed information about changes made in different releases.
 
@@ -15,12 +15,12 @@ For the full supported experience, you will need to have Visual Studio 2022 or h
 To get started on **Visual Studio 2022**:
 
 1. [Install Visual Studio 2022](https://www.visualstudio.com/vs/).  Select the following Workloads:
-  - .NET desktop development
-  - .NET Core cross-platform development
+   - .NET desktop development
+   - .NET Core cross-platform development
 2. Ensure [long path support](https://learn.microsoft.com/windows/win32/fileio/maximum-file-path-limitation?tabs=registry#enable-long-paths-in-windows-10-version-1607-and-later) is enabled at the Windows level.
 3. Open a `Developer Command Prompt for VS 2022` prompt.
 4. Clone the source code: `git clone https://github.com/dotnet/msbuild`
-  - You may have to [download Git](https://git-scm.com/downloads) first.
+   - You may have to [download Git](https://git-scm.com/downloads) first.
 5. Run `.\build.cmd` from the root of the repo to build the code. This also restores packages needed to open the projects in Visual Studio.
 6. Open `MSBuild.sln` or `MSBuild.Dev.slnf` in Visual Studio 2022.
 
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 000d4675069..7744d96a090 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -26,6 +26,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 ### 17.12
 - [Log TaskParameterEvent for scalar parameters](https://github.com/dotnet/msbuild/pull/9908)
 - [Convert.ToString during a property evaluation uses the InvariantCulture for all types](https://github.com/dotnet/msbuild/pull/9874)
+- [Fix oversharing of build results in ResultsCache](https://github.com/dotnet/msbuild/pull/9987)
 
 ### 17.10
 - [AppDomain configuration is serialized without using BinFmt](https://github.com/dotnet/msbuild/pull/9320) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
diff --git a/eng/Common.globalconfig b/eng/Common.globalconfig
index dd47c3b3336..57c789f0371 100644
--- a/eng/Common.globalconfig
+++ b/eng/Common.globalconfig
@@ -321,9 +321,6 @@ dotnet_diagnostic.CA1837.severity = suggestion
 # Avoid 'StringBuilder' parameters for P/Invokes
 dotnet_diagnostic.CA1838.severity = warning
 
-# Dispose objects before losing scope
-dotnet_diagnostic.CA2000.severity = none
-
 # Do not lock on objects with weak identity
 dotnet_diagnostic.CA2002.severity = none
 
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 3112f090fca..bab7c907f04 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -91,9 +91,9 @@
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>fb50d1a45ed10b39b5f335bc3a4bdcaea9b951cf</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24212.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24216.12">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>0b1fefc344701f2669b2190fbfda5ca588083605</Sha>
+      <Sha>3af0081a6e811b78d37c62e479914f7f4cfb0d1a</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24204.3">
diff --git a/eng/Versions.props b/eng/Versions.props
index 0aefadce05d..939fba9aa49 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -51,7 +51,7 @@
     <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24204.3</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24212.1</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24216.12</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.10.0-preview.2.97</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
diff --git a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
index 5cd20e9d57a..6a31254da54 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
@@ -6,6 +6,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using System.Reflection;
 using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
@@ -1089,7 +1090,7 @@ public void TaskStartedNullBuildEventContext()
             Assert.Throws<InternalErrorException>(() =>
             {
                 ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
-                service.LogTaskStarted(null, "MyTask", "ProjectFile", "ProjectFileOfTask");
+                service.LogTaskStarted(taskBuildEventContext: null, "MyTask", "ProjectFile", "ProjectFileOfTask", taskAssemblyLocation: null);
             });
         }
 
@@ -1443,14 +1444,15 @@ private void TestProjectFinishedEvent(string projectFile, bool success)
         private void TestTaskStartedEvent(string taskName, string projectFile, string projectFileOfTask)
         {
             string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("TaskStarted", taskName);
+            string taskAssemblyLocation = Assembly.GetExecutingAssembly().Location;
 
             ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
-            service.LogTaskStarted(s_buildEventContext, taskName, projectFile, projectFileOfTask);
-            VerifyTaskStartedEvent(taskName, projectFile, projectFileOfTask, message, service);
+            service.LogTaskStarted(s_buildEventContext, taskName, projectFile, projectFileOfTask, taskAssemblyLocation);
+            VerifyTaskStartedEvent(taskName, projectFile, projectFileOfTask, message, service, taskAssemblyLocation);
 
             service.ResetProcessedBuildEvent();
             service.OnlyLogCriticalEvents = true;
-            service.LogTaskStarted(s_buildEventContext, taskName, projectFile, projectFileOfTask);
+            service.LogTaskStarted(s_buildEventContext, taskName, projectFile, projectFileOfTask, taskAssemblyLocation);
             Assert.Null(service.ProcessedBuildEvent);
         }
 
@@ -1631,7 +1633,7 @@ private void VerifyTaskFinishedEvent(string taskName, string projectFile, string
         /// <param name="projectFileOfTask">ProjectFileOfTask to create the comparison event with.</param>
         /// <param name="message">Message to create the comparison event with.</param>
         /// <param name="service">LoggingService mock object which overrides ProcessBuildEvent and can provide a ProcessedBuildEvent (the event which would have been sent to the loggers)</param>
-        private void VerifyTaskStartedEvent(string taskName, string projectFile, string projectFileOfTask, string message, ProcessBuildEventHelper service)
+        private void VerifyTaskStartedEvent(string taskName, string projectFile, string projectFileOfTask, string message, ProcessBuildEventHelper service, string taskAssemblyLocation)
         {
             TaskStartedEventArgs taskEvent = new TaskStartedEventArgs(
                  message,
@@ -1639,7 +1641,8 @@ private void VerifyTaskStartedEvent(string taskName, string projectFile, string
                   projectFile,
                   projectFileOfTask,
                   taskName,
-                  service.ProcessedBuildEvent.Timestamp);
+                  service.ProcessedBuildEvent.Timestamp,
+                  taskAssemblyLocation);
             taskEvent.BuildEventContext = s_buildEventContext;
             Assert.True(((TaskStartedEventArgs)service.ProcessedBuildEvent).IsEquivalent(taskEvent));
         }
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index b3ceffe4bd5..a62b03686d4 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -573,7 +573,8 @@ public void LogTargetFinished(BuildEventContext targetBuildEventContext, string
         /// <param name="taskName">The name of the task</param>
         /// <param name="projectFile">The project file</param>
         /// <param name="projectFileOfTaskNode">The project file containing the task node.</param>
-        public void LogTaskStarted(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode)
+        /// <param name="taskAssemblyLocation">>The location of the assembly containing the implementation of the task.</param>
+        public void LogTaskStarted(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, string taskAssemblyLocation)
         {
         }
 
@@ -584,8 +585,9 @@ public void LogTaskStarted(BuildEventContext targetBuildEventContext, string tas
         /// <param name="taskName">The name of the task</param>
         /// <param name="projectFile">The project file</param>
         /// <param name="projectFileOfTaskNode">The project file containing the task node.</param>
+        /// <param name="taskAssemblyLocation">>The location of the assembly containing the implementation of the task.</param>
         /// <returns>The task logging context</returns>
-        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column)
+        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column, string taskAssemblyLocation)
         {
             return new BuildEventContext(0, 0, 0, 0);
         }
diff --git a/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs b/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs
index 0e83218dce7..4f35fa823fe 100644
--- a/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs
@@ -18,7 +18,7 @@ public async Task EmitConsoleMessages()
         {
             StringBuilder sb = new StringBuilder();
 
-            using (TextWriter writer = OutOfProcServerNode.RedirectConsoleWriter.Create(text => sb.Append(text)))
+            using (var writer = OutOfProcServerNode.RedirectConsoleWriter.Create(text => sb.Append(text)))
             {
                 writer.WriteLine("Line 1");
                 await Task.Delay(80); // should be somehow bigger than `RedirectConsoleWriter` flush period - see its constructor
diff --git a/src/Build.UnitTests/BackEnd/RequestedProjectState_Tests.cs b/src/Build.UnitTests/BackEnd/RequestedProjectState_Tests.cs
new file mode 100644
index 00000000000..034b3d1594a
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/RequestedProjectState_Tests.cs
@@ -0,0 +1,208 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using FluentAssertions;
+using Microsoft.Build.Execution;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.UnitTests.BackEnd
+{
+    public class RequestedProjectState_Tests
+    {
+        [Fact]
+        public void DeepCloneEmpty()
+        {
+            RequestedProjectState state = new();
+            RequestedProjectState clone = state.DeepClone();
+
+            clone.PropertyFilters.Should().BeNull();
+            clone.ItemFilters.Should().BeNull();
+        }
+
+        [Fact]
+        public void DeepCloneProperties()
+        {
+            List<string> properties = ["prop1", "prop2"];
+            RequestedProjectState state = new()
+            {
+                PropertyFilters = properties,
+            };
+            RequestedProjectState clone = state.DeepClone();
+
+            clone.PropertyFilters.Should().BeEquivalentTo(properties);
+            clone.ItemFilters.Should().BeNull();
+
+            // Mutating the original instance is not reflected in the clone.
+            properties.Add("prop3");
+            clone.PropertyFilters.Count.Should().NotBe(properties.Count);
+        }
+
+        [Fact]
+        public void DeepCloneItemsNoMetadata()
+        {
+            Dictionary<string, List<string>> items = new()
+            {
+                { "item1", null! },
+                { "item2", null! },
+            };
+            RequestedProjectState state = new()
+            {
+                ItemFilters = items,
+            };
+            RequestedProjectState clone = state.DeepClone();
+
+            clone.PropertyFilters.Should().BeNull();
+            clone.ItemFilters.Should().BeEquivalentTo(items);
+
+            // Mutating the original instance is not reflected in the clone.
+            items.Add("item3", null!);
+            clone.ItemFilters.Count.Should().NotBe(items.Count);
+        }
+
+        [Fact]
+        public void DeepCloneItemsWithMetadata()
+        {
+            Dictionary<string, List<string>> items = new()
+            {
+                { "item1", ["metadatum1", "metadatum2"] },
+                { "item2", ["metadatum3"] },
+            };
+            RequestedProjectState state = new()
+            {
+                ItemFilters = items,
+            };
+            RequestedProjectState clone = state.DeepClone();
+
+            clone.PropertyFilters.Should().BeNull();
+            clone.ItemFilters.Should().BeEquivalentTo(items);
+
+            // Mutating the original instance is not reflected in the clone.
+            items["item2"].Add("metadatum4");
+            clone.ItemFilters["item2"].Count.Should().NotBe(items["item2"].Count);
+        }
+
+        [Fact]
+        public void IsSubsetOfEmpty()
+        {
+            RequestedProjectState state1 = new();
+            RequestedProjectState state2 = new();
+
+            // Empty instances are subsets of each other.
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeTrue();
+
+            state1.PropertyFilters = ["prop1"];
+            state1.ItemFilters = new Dictionary<string, List<string>>()
+            {
+                { "item1", null! },
+            };
+
+            // Non-empty instance is a subset of empty instance but not the other way round.
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+        }
+
+        [Fact]
+        public void IsSubsetOfProperties()
+        {
+            RequestedProjectState state1 = new()
+            {
+                PropertyFilters = ["prop1"],
+            };
+            RequestedProjectState state2 = new()
+            {
+                PropertyFilters = ["prop1", "prop2"],
+            };
+
+            // "prop1" is a subset of "prop1", "prop2".
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+
+            state1.PropertyFilters.Add("prop3");
+
+            // Disjoint sets are not subsets of each other.
+            state1.IsSubsetOf(state2).Should().BeFalse();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+
+            state1.PropertyFilters.Clear();
+
+            // Empty props is a subset of anything.
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+        }
+
+        [Fact]
+        public void IsSubsetOfItemsNoMetadata()
+        {
+            RequestedProjectState state1 = new()
+            {
+                ItemFilters = new Dictionary<string, List<string>>()
+                {
+                    { "item1", null! },
+                },
+            };
+            RequestedProjectState state2 = new()
+            {
+                ItemFilters = new Dictionary<string, List<string>>()
+                {
+                    { "item1", null! },
+                    { "item2", null! },
+                },
+            };
+
+            // "item1" is a subset of "item1", "item2".
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+
+            state1.ItemFilters.Add("item3", null!);
+
+            // Disjoint sets are not subsets of each other.
+            state1.IsSubsetOf(state2).Should().BeFalse();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+
+            state1.ItemFilters.Clear();
+
+            // Empty items is a subset of anything.
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+        }
+
+        [Fact]
+        public void IsSubsetOfItemsWithMetadata()
+        {
+            RequestedProjectState state1 = new()
+            {
+                ItemFilters = new Dictionary<string, List<string>>()
+                {
+                    { "item1", ["metadatum1"] },
+                },
+            };
+            RequestedProjectState state2 = new()
+            {
+                ItemFilters = new Dictionary<string, List<string>>()
+                {
+                    { "item1", null! },
+                },
+            };
+
+            // "item1" with "metadatum1" is a subset of "item1" with no metadata filter.
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+
+            state2.ItemFilters["item1"] = ["metadatum2"];
+
+            // Disjoint metadata filters are not subsets of each other.
+            state1.IsSubsetOf(state2).Should().BeFalse();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+
+            state1.ItemFilters["item1"] = [];
+
+            // Empty metadata filter is a subset of any other metadata filter.
+            state1.IsSubsetOf(state2).Should().BeTrue();
+            state2.IsSubsetOf(state1).Should().BeFalse();
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
index d832aa878b3..ac421399121 100644
--- a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
@@ -3,8 +3,12 @@
 
 using System;
 using System.Collections.Generic;
+using System.IO;
 using System.Linq;
+using System.Xml;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
@@ -188,6 +192,153 @@ public void TestRetrieveSubsetTargetsFromResult()
             Assert.Equal(BuildResultCode.Success, response.Results.OverallResult);
         }
 
+        [Fact]
+        public void TestCacheOnDifferentBuildFlagsPerRequest_ProvideProjectStateAfterBuild()
+        {
+            string targetName = "testTarget1";
+            int submissionId = 1;
+            int nodeRequestId = 0;
+            int configurationId = 1;
+
+            BuildRequest requestWithNoBuildDataFlags = new BuildRequest(
+               submissionId,
+               nodeRequestId,
+               configurationId,
+               new string[1] { targetName } /* escapedTargets */,
+               null /* hostServices */,
+               BuildEventContext.Invalid /* parentBuildEventContext */,
+               null /* parentRequest */,
+               BuildRequestDataFlags.None);
+
+            BuildRequest requestWithProjectStateFlag = new BuildRequest(
+               submissionId,
+               nodeRequestId,
+               configurationId,
+               new string[1] { targetName } /* escapedTargets */,
+               null /* hostServices */,
+               BuildEventContext.Invalid /* parentBuildEventContext */,
+               null /* parentRequest */,
+               BuildRequestDataFlags.ProvideProjectStateAfterBuild);
+
+            BuildRequest requestWithNoBuildDataFlags2 = new BuildRequest(
+               submissionId,
+               nodeRequestId,
+               configurationId,
+               new string[1] { targetName } /* escapedTargets */,
+               null /* hostServices */,
+               BuildEventContext.Invalid /* parentBuildEventContext */,
+               null /* parentRequest */,
+               BuildRequestDataFlags.None);
+
+            BuildResult resultForRequestWithNoBuildDataFlags = new(requestWithNoBuildDataFlags);
+            resultForRequestWithNoBuildDataFlags.AddResultsForTarget(targetName, BuildResultUtilities.GetEmptySucceedingTargetResult());
+            ResultsCache cache = new();
+            cache.AddResult(resultForRequestWithNoBuildDataFlags);
+
+            ResultsCacheResponse cacheResponseForRequestWithNoBuildDataFlags = cache.SatisfyRequest(
+               requestWithNoBuildDataFlags,
+               new List<string>(),
+               new List<string>(new string[] { targetName }),
+               skippedResultsDoNotCauseCacheMiss: false);
+
+            ResultsCacheResponse cachedResponseForProjectState = cache.SatisfyRequest(
+               requestWithProjectStateFlag,
+               new List<string>(),
+               new List<string>(new string[] { targetName }),
+               skippedResultsDoNotCauseCacheMiss: false);
+
+            ResultsCacheResponse cacheResponseForNoBuildDataFlags2 = cache.SatisfyRequest(
+               requestWithNoBuildDataFlags2,
+               new List<string>(),
+               new List<string>(new string[] { targetName }),
+               skippedResultsDoNotCauseCacheMiss: false);
+
+            Assert.Equal(ResultsCacheResponseType.Satisfied, cacheResponseForRequestWithNoBuildDataFlags.Type);
+
+            // Because ProvideProjectStateAfterBuildFlag was provided as a part of BuildRequest
+            Assert.Equal(ResultsCacheResponseType.NotSatisfied, cachedResponseForProjectState.Type);
+
+            Assert.Equal(ResultsCacheResponseType.Satisfied, cacheResponseForNoBuildDataFlags2.Type);
+        }
+
+        [Fact]
+        public void TestCacheOnDifferentBuildFlagsPerRequest_ProvideSubsetOfStateAfterBuild()
+        {
+            string targetName = "testTarget1";
+            int submissionId = 1;
+            int nodeRequestId = 0;
+            int configurationId = 1;
+
+            RequestedProjectState requestedProjectState1 = new()
+            {
+                PropertyFilters = ["property1", "property2"],
+            };
+            BuildRequest requestWithSubsetFlag1 = new BuildRequest(
+                submissionId,
+                nodeRequestId,
+                configurationId,
+                new string[1] { targetName } /* escapedTargets */,
+                null /* hostServices */,
+                BuildEventContext.Invalid /* parentBuildEventContext */,
+                null /* parentRequest */,
+                BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild,
+                requestedProjectState1);
+
+            RequestedProjectState requestedProjectState2 = new()
+            {
+                PropertyFilters = ["property1"],
+            };
+            BuildRequest requestWithSubsetFlag2 = new BuildRequest(
+                submissionId,
+                nodeRequestId,
+                configurationId,
+                new string[1] { targetName } /* escapedTargets */,
+                null /* hostServices */,
+                BuildEventContext.Invalid /* parentBuildEventContext */,
+                null /* parentRequest */,
+                BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild,
+                requestedProjectState2);
+
+            BuildResult resultForRequestWithSubsetFlag1 = new(requestWithSubsetFlag1);
+            resultForRequestWithSubsetFlag1.AddResultsForTarget(targetName, BuildResultUtilities.GetEmptySucceedingTargetResult());
+
+            using TextReader textReader = new StringReader(@"
+              <Project>
+                <PropertyGroup>
+                  <property1>Value1</property1>
+                  <property2>Value2</property2>
+                </PropertyGroup>
+              </Project>
+            ");
+            using XmlReader xmlReader = XmlReader.Create(textReader);
+            resultForRequestWithSubsetFlag1.ProjectStateAfterBuild = new ProjectInstance(ProjectRootElement.Create(xmlReader)).FilteredCopy(requestedProjectState1);
+
+            ResultsCache cache = new();
+            cache.AddResult(resultForRequestWithSubsetFlag1);
+
+            ResultsCacheResponse cachedResponseWithSubsetFlag1 = cache.SatisfyRequest(
+                requestWithSubsetFlag1,
+                new List<string>(),
+                new List<string>(new string[] { targetName }),
+                skippedResultsDoNotCauseCacheMiss: false);
+
+            ResultsCacheResponse cachedResponseWithSubsetFlag2 = cache.SatisfyRequest(
+                requestWithSubsetFlag2,
+                new List<string>(),
+                new List<string>(new string[] { targetName }),
+                skippedResultsDoNotCauseCacheMiss: false);
+
+            // We used the same filter that was used for the ProjectInstance in the cache -> cache hit.
+            Assert.Equal(ResultsCacheResponseType.Satisfied, cachedResponseWithSubsetFlag1.Type);
+            Assert.Equal("Value1", cachedResponseWithSubsetFlag1.Results.ProjectStateAfterBuild.GetPropertyValue("property1"));
+            Assert.Equal("Value2", cachedResponseWithSubsetFlag1.Results.ProjectStateAfterBuild.GetPropertyValue("property2"));
+
+            // We used a filter that's a subset of the one used for the ProjectInstance in the cache -> cache hit.
+            Assert.Equal(ResultsCacheResponseType.Satisfied, cachedResponseWithSubsetFlag2.Type);
+            Assert.Equal("Value1", cachedResponseWithSubsetFlag2.Results.ProjectStateAfterBuild.GetPropertyValue("property1"));
+            Assert.Equal("", cachedResponseWithSubsetFlag2.Results.ProjectStateAfterBuild.GetPropertyValue("property2"));
+        }
+
         [Fact]
         public void TestClearResultsCache()
         {
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index b1516503006..ba22e2beed0 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -46,7 +46,7 @@ public class TaskExecutionHost_Tests : ITestTaskHost, IBuildEngine2, IDisposable
         /// <summary>
         /// The task execution host
         /// </summary>
-        private ITaskExecutionHost _host;
+        private TaskExecutionHost _host;
 
         /// <summary>
         /// The mock logging service
@@ -1245,7 +1245,7 @@ private void InitializeHost(bool throwOnExecute)
 #else
             AssemblyLoadInfo loadInfo = AssemblyLoadInfo.Create(typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).GetTypeInfo().FullName, null);
 #endif
-            LoadedType loadedType = new LoadedType(typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory), loadInfo, typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).GetTypeInfo().Assembly, typeof(ITaskItem));
+            LoadedType loadedType = new LoadedType(typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory), loadInfo, typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).Assembly, typeof(ITaskItem));
 
             TaskBuilderTestTask.TaskBuilderTestTaskFactory taskFactory = new TaskBuilderTestTask.TaskBuilderTestTaskFactory();
             taskFactory.ThrowOnExecute = throwOnExecute;
@@ -1266,7 +1266,7 @@ private void InitializeHost(bool throwOnExecute)
                 CancellationToken.None);
 
             ProjectTaskInstance taskInstance = project.Targets["foo"].Tasks.First();
-            TaskLoggingContext talc = tlc.LogTaskBatchStarted(".", taskInstance);
+            TaskLoggingContext talc = tlc.LogTaskBatchStarted(".", taskInstance, typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).Assembly.GetName().FullName);
 
             ItemDictionary<ProjectItemInstance> itemsByName = new ItemDictionary<ProjectItemInstance>();
 
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 46170961e81..cb60a9f2d42 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -191,7 +191,9 @@ public void RoundtripTaskStartedEventArgs()
                 null,
                 projectFile: "C:\\project.proj",
                 taskFile: "C:\\common.targets",
-                taskName: "Csc");
+                taskName: "Csc",
+                DateTime.Now,
+                "TaskAssemblyLocation");
             args.LineNumber = 42;
             args.ColumnNumber = 999;
 
@@ -200,7 +202,8 @@ public void RoundtripTaskStartedEventArgs()
                 e => e.TaskFile,
                 e => e.TaskName,
                 e => e.LineNumber.ToString(),
-                e => e.ColumnNumber.ToString());
+                e => e.ColumnNumber.ToString(),
+                e => e.TaskAssemblyLocation);
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 2306910aabc..6ab7a893816 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -2299,6 +2299,50 @@ public void CustomTargetNamesAreInInMetaproj()
             Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Six", StringComparison.OrdinalIgnoreCase)));
         }
 
+        /// <summary>
+        /// Verifies that disambiguated target names are used when a project name matches a standard solution entry point.
+        /// </summary>
+        [Fact]
+        public void DisambiguatedTargetNamesAreInInMetaproj()
+        {
+            foreach(string projectName in ProjectInSolution.projectNamesToDisambiguate)
+            {
+                SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(
+                $$"""
+                    Microsoft Visual Studio Solution File, Format Version 14.00
+                    # Visual Studio 2015
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "{{projectName}}", "{{projectName}}.csproj", "{6185CC21-BE89-448A-B3C0-D1C27112E595}"
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Release|Any CPU = Release|Any CPU
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+                        EndGlobalSection
+                    EndGlobal
+                """);
+
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), null);
+
+                foreach (string targetName in ProjectInSolution.projectNamesToDisambiguate)
+                {
+                    // The entry point still exists normally.
+                    Assert.True(instances[0].Targets.ContainsKey(targetName));
+
+                    // The traversal target should be disambiguated with a "Solution:" prefix.
+                    // Note: The default targets are used instead of "Build".
+                    string traversalTargetName = targetName.Equals("Build", StringComparison.OrdinalIgnoreCase)
+                        ? $"Solution:{projectName}"
+                        : $"Solution:{projectName}:{targetName}";
+                    Assert.True(instances[0].Targets.ContainsKey(traversalTargetName));
+                }
+            }
+        }
+
         /// <summary>
         /// Verifies that illegal user target names (the ones already used internally) don't crash the SolutionProjectGenerator
         /// </summary>
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 26729eee551..351bef34086 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -2808,6 +2808,119 @@ public void MultitargettingTargetsWithBuildProjectReferencesFalse()
             }
         }
 
+        [Theory]
+        // Built-in targets
+        [InlineData(new string[0], new[] { "Project1Default" }, new[] { "Project2Default" })]
+        [InlineData(new[] { "Build" }, new[] { "Project1Default" }, new[] { "Project2Default" })]
+        [InlineData(new[] { "Rebuild" }, new[] { "Rebuild" }, new[] { "Rebuild" })]
+        [InlineData(new[] { "Clean" }, new[] { "Clean" }, new[] { "Clean" })]
+        [InlineData(new[] { "Publish" }, new[] { "Publish" }, new[] { "Publish" })]
+        // Traversal targets
+        [InlineData(new[] { "Project1" }, new[] { "Project1Default" }, new string[0])]
+        [InlineData(new[] { "Project2" }, new string[0], new[] { "Project2Default" })]
+        [InlineData(new[] { "Project1", "Project2" }, new[] { "Project1Default" }, new[] { "Project2Default" })]
+        [InlineData(new[] { "Project1:Rebuild" }, new[] { "Rebuild" }, new string[0])]
+        [InlineData(new[] { "Project2:Rebuild" }, new string[0], new[] { "Rebuild" })]
+        [InlineData(new[] { "Project1:Rebuild", "Project2:Clean" }, new[] { "Rebuild" }, new[] { "Clean" })]
+        [InlineData(new[] { "CustomTarget" }, new[] { "CustomTarget" }, new[] { "CustomTarget" })]
+        [InlineData(new[] { "Project1:CustomTarget" }, new[] { "CustomTarget" }, new string[0])]
+        [InlineData(new[] { "Project2:CustomTarget" }, new string[0], new[] { "CustomTarget" })]
+        [InlineData(new[] { "Project1:CustomTarget", "Project2:CustomTarget" }, new[] { "CustomTarget" }, new[] { "CustomTarget" })]
+        public void GetTargetListsWithSolution(string[] entryTargets, string[] expectedProject1Targets, string[] expectedProject2Targets)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                const string ExtraContent = """
+                    <Target Name="CustomTarget" />
+                    """;
+                TransientTestFile project1File = CreateProjectFile(env: env, projectNumber: 1, defaultTargets: "Project1Default", extraContent: ExtraContent);
+                TransientTestFile project2File = CreateProjectFile(env: env, projectNumber: 2, defaultTargets: "Project2Default", extraContent: ExtraContent);
+
+                string solutionFileContents = $$"""
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 17
+                    VisualStudioVersion = 17.0.31903.59
+                    MinimumVisualStudioVersion = 17.0.31903.59
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Project1", "{{project1File.Path}}", "{8761499A-7280-43C4-A32F-7F41C47CA6DF}"
+                    EndProject
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Project2", "{{project2File.Path}}", "{2022C11A-1405-4983-BEC2-3A8B0233108F}"
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|x64 = Debug|x64
+                            Release|x64 = Release|x64
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.ActiveCfg = Debug|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.Build.0 = Debug|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.ActiveCfg = Release|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.Build.0 = Release|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x64.ActiveCfg = Debug|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Debug|x64.Build.0 = Debug|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x64.ActiveCfg = Release|x64
+                            {2022C11A-1405-4983-BEC2-3A8B0233108F}.Release|x64.Build.0 = Release|x64
+                        EndGlobalSection
+                        GlobalSection(SolutionProperties) = preSolution
+                            HideSolutionNode = FALSE
+                        EndGlobalSection
+                    EndGlobal
+                    """;
+                TransientTestFile slnFile = env.CreateFile(@"Solution.sln", solutionFileContents);
+                SolutionFile solutionFile = SolutionFile.Parse(slnFile.Path);
+
+                ProjectGraph projectGraph = new(slnFile.Path);
+                ProjectGraphNode project1Node = GetFirstNodeWithProjectNumber(projectGraph, 1);
+                ProjectGraphNode project2Node = GetFirstNodeWithProjectNumber(projectGraph, 2);
+
+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(entryTargets);
+                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
+                targetLists[project1Node].ShouldBe(expectedProject1Targets);
+                targetLists[project2Node].ShouldBe(expectedProject2Targets);
+            }
+        }
+
+        [Theory]
+        [InlineData("Project1:Build")]
+        [InlineData("Project1:")]
+        public void GetTargetListsWithSolutionInvalidTargets(string entryTarget)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                TransientTestFile project1File = CreateProjectFile(env: env, projectNumber: 1);
+                string solutionFileContents = $$"""
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 17
+                    VisualStudioVersion = 17.0.31903.59
+                    MinimumVisualStudioVersion = 17.0.31903.59
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Project1", "{{project1File.Path}}", "{8761499A-7280-43C4-A32F-7F41C47CA6DF}"
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|x64 = Debug|x64
+                            Release|x64 = Release|x64
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.ActiveCfg = Debug|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Debug|x64.Build.0 = Debug|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.ActiveCfg = Release|x64
+                            {8761499A-7280-43C4-A32F-7F41C47CA6DF}.Release|x64.Build.0 = Release|x64
+                        EndGlobalSection
+                        GlobalSection(SolutionProperties) = preSolution
+                            HideSolutionNode = FALSE
+                        EndGlobalSection
+                    EndGlobal
+                    """;
+                TransientTestFile slnFile = env.CreateFile(@"Solution.sln", solutionFileContents);
+                SolutionFile solutionFile = SolutionFile.Parse(slnFile.Path);
+
+                ProjectGraph projectGraph = new(slnFile.Path);
+
+                var getTargetListsFunc = (() => projectGraph.GetTargetLists([entryTarget]));
+                InvalidProjectFileException exception = getTargetListsFunc.ShouldThrow<InvalidProjectFileException>();
+                exception.Message.ShouldContain($"The target \"{entryTarget}\" does not exist in the project.");
+            }
+        }
+
         public void Dispose()
         {
             _env.Dispose();
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 25bcabbeed3..ec86b218112 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1965,11 +1965,10 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
 
                 // Non-graph builds verify this in RequestBuilder, but for graph builds we need to disambiguate
                 // between entry nodes and other nodes in the graph since only entry nodes should error. Just do
-                // the verification expicitly before the build even starts.
+                // the verification explicitly before the build even starts.
                 foreach (ProjectGraphNode entryPointNode in projectGraph.EntryPointNodes)
                 {
-                    ImmutableList<string> targetList = targetsPerNode[entryPointNode];
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(targetList.Count > 0, entryPointNode.ProjectInstance.ProjectFileLocation, "NoTargetSpecified");
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(entryPointNode.ProjectInstance.Targets.Count > 0, entryPointNode.ProjectInstance.ProjectFileLocation, "NoTargetSpecified");
                 }
 
                 resultsPerNode = BuildGraph(projectGraph, targetsPerNode, submission.BuildRequestData);
@@ -2007,7 +2006,7 @@ private Dictionary<ProjectGraphNode, BuildResult> BuildGraph(
             IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetsPerNode,
             GraphBuildRequestData graphBuildRequestData)
         {
-            var waitHandle = new AutoResetEvent(true);
+            using var waitHandle = new AutoResetEvent(true);
             var graphBuildStateLock = new object();
 
             var blockedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes);
diff --git a/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs b/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
index 5670a61e3f1..33dc9fe2cc4 100644
--- a/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
+++ b/src/Build/BackEnd/BuildManager/LegacyThreadingData.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Diagnostics.CodeAnalysis;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd;
@@ -82,6 +83,7 @@ internal int MainThreadSubmissionId
         /// Given a submission ID, assign it "start" and "finish" events to track its use of
         /// the legacy thread.
         /// </summary>
+        [SuppressMessage("Microsoft.Dispose", "CA2000:Dispose objects before losing scope", Justification = "The events are disposed in UnregisterSubmissionForLegacyThread")]
         internal void RegisterSubmissionForLegacyThread(int submissionId)
         {
             lock (_legacyThreadingEventsLock)
@@ -104,6 +106,10 @@ internal void UnregisterSubmissionForLegacyThread(int submissionId)
             {
                 ErrorUtilities.VerifyThrow(_legacyThreadingEventsById.ContainsKey(submissionId), "Submission {0} should have been previously registered with LegacyThreadingData", submissionId);
 
+                // Dispose the events
+                _legacyThreadingEventsById[submissionId].Item1?.Dispose();
+                _legacyThreadingEventsById[submissionId].Item2?.Dispose();
+
                 _legacyThreadingEventsById.Remove(submissionId);
             }
         }
diff --git a/src/Build/BackEnd/BuildManager/RequestedProjectState.cs b/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
index d195131a51c..fa324777269 100644
--- a/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
+++ b/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Linq;
 using Microsoft.Build.BackEnd;
 
 #nullable disable
@@ -35,6 +36,94 @@ public IDictionary<string, List<string>> ItemFilters
             set => _itemFilters = value;
         }
 
+        /// <summary>
+        /// Creates a deep copy of this instance.
+        /// </summary>
+        internal RequestedProjectState DeepClone()
+        {
+            RequestedProjectState result = new RequestedProjectState();
+            if (PropertyFilters is not null)
+            {
+                result.PropertyFilters = new List<string>(PropertyFilters);
+            }
+            if (ItemFilters is not null)
+            {
+                result.ItemFilters = ItemFilters.ToDictionary(
+                    kvp => kvp.Key,
+                    kvp => kvp.Value == null ? null : new List<string>(kvp.Value));
+            }
+            return result;
+        }
+
+        /// <summary>
+        /// Returns true if this instance contains all property and item filters present in another instance.
+        /// </summary>
+        /// <param name="another">The instance to compare against.</param>
+        /// <returns>True if this instance is equivalent or a strict subset of <paramref name="another"/>.</returns>
+        internal bool IsSubsetOf(RequestedProjectState another)
+        {
+            if (PropertyFilters is null)
+            {
+                if (another.PropertyFilters is not null)
+                {
+                    // The instance to compare against has filtered props and we need everything -> not a subset.
+                    return false;
+                }
+            }
+            else if (another.PropertyFilters is not null)
+            {
+                HashSet<string> anotherPropertyFilters = new HashSet<string>(another.PropertyFilters);
+                foreach (string propertyFilter in PropertyFilters)
+                {
+                    if (!anotherPropertyFilters.Contains(propertyFilter))
+                    {
+                        return false;
+                    }
+                }
+            }
+
+            if (ItemFilters is null)
+            {
+                if (another.ItemFilters is not null)
+                {
+                    // The instance to compare against has filtered items and we need everything -> not a subset.
+                    return false;
+                }
+            }
+            else if (another.ItemFilters is not null)
+            {
+                foreach (KeyValuePair<string, List<string>> kvp in ItemFilters)
+                {
+                    if (!another.ItemFilters.TryGetValue(kvp.Key, out List<string> metadata))
+                    {
+                        // The instance to compare against doesn't have this item -> not a subset.
+                        return false;
+                    }
+                    if (kvp.Value is null)
+                    {
+                        if (metadata is not null)
+                        {
+                            // The instance to compare against has filtered metadata for this item and we need everything - not a subset.
+                            return false;
+                        }
+                    }
+                    else if (metadata is not null)
+                    {
+                        HashSet<string> anotherMetadata = new HashSet<string>(metadata);
+                        foreach (string metadatum in kvp.Value)
+                        {
+                            if (!anotherMetadata.Contains(metadatum))
+                            {
+                                return false;
+                            }
+                        }
+                    }
+                }
+            }
+
+            return true;
+        }
+
         void ITranslatable.Translate(ITranslator translator)
         {
             translator.Translate(ref _propertyFilters);
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 0823f86cffe..34480ff2142 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -18,6 +18,14 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal class ResultsCache : IResultsCache
     {
+        /// <summary>
+        /// The presence of any of these flags affects build result for the specified request. Not included are ProvideProjectStateAfterBuild
+        /// and ProvideSubsetOfStateAfterBuild which require additional checks.
+        /// </summary>
+        private const BuildRequestDataFlags FlagsAffectingBuildResults =
+            BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports
+            | BuildRequestDataFlags.FailOnUnresolvedSdk;
+
         /// <summary>
         /// The table of all build results.  This table is indexed by configuration id and
         /// contains BuildResult objects which have all of the target information.
@@ -140,10 +148,11 @@ public BuildResult GetResultsForConfiguration(int configurationId)
 
         /// <summary>
         /// Attempts to satisfy the request from the cache.  The request can be satisfied only if:
-        /// 1. All specified targets in the request have successful results in the cache or if the sequence of target results
+        /// 1. The passed BuildRequestDataFlags and RequestedProjectStateFilter are compatible with the result data.
+        /// 2. All specified targets in the request have successful results in the cache or if the sequence of target results
         ///    includes 0 or more successful targets followed by at least one failed target.
-        /// 2. All initial targets in the configuration for the request have non-skipped results in the cache.
-        /// 3. If there are no specified targets, then all default targets in the request must have non-skipped results
+        /// 3. All initial targets in the configuration for the request have non-skipped results in the cache.
+        /// 4. If there are no specified targets, then all default targets in the request must have non-skipped results
         ///    in the cache.
         /// </summary>
         /// <param name="request">The request whose results we should return.</param>
@@ -163,47 +172,53 @@ public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> co
             {
                 if (_resultsByConfiguration.TryGetValue(request.ConfigurationId, out BuildResult allResults))
                 {
-                    // Check for targets explicitly specified.
-                    bool explicitTargetsSatisfied = CheckResults(allResults, request.Targets, response.ExplicitTargetsToBuild, skippedResultsDoNotCauseCacheMiss);
+                    bool buildDataFlagsSatisfied = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
+                        ? AreBuildResultFlagsCompatible(request, allResults) : true;
 
-                    if (explicitTargetsSatisfied)
+                    if (buildDataFlagsSatisfied)
                     {
-                        // All of the explicit targets, if any, have been satisfied
-                        response.Type = ResultsCacheResponseType.Satisfied;
+                        // Check for targets explicitly specified.
+                        bool explicitTargetsSatisfied = CheckResults(allResults, request.Targets, response.ExplicitTargetsToBuild, skippedResultsDoNotCauseCacheMiss);
 
-                        // Check for the initial targets.  If we don't know what the initial targets are, we assume they are not satisfied.
-                        if (configInitialTargets == null || !CheckResults(allResults, configInitialTargets, null, skippedResultsDoNotCauseCacheMiss))
+                        if (explicitTargetsSatisfied)
                         {
-                            response.Type = ResultsCacheResponseType.NotSatisfied;
-                        }
+                            // All of the explicit targets, if any, have been satisfied
+                            response.Type = ResultsCacheResponseType.Satisfied;
 
-                        // We could still be missing implicit targets, so check those...
-                        if (request.Targets.Count == 0)
-                        {
-                            // Check for the default target, if necessary.  If we don't know what the default targets are, we
-                            // assume they are not satisfied.
-                            if (configDefaultTargets == null || !CheckResults(allResults, configDefaultTargets, null, skippedResultsDoNotCauseCacheMiss))
+                            // Check for the initial targets.  If we don't know what the initial targets are, we assume they are not satisfied.
+                            if (configInitialTargets == null || !CheckResults(allResults, configInitialTargets, null, skippedResultsDoNotCauseCacheMiss))
                             {
                                 response.Type = ResultsCacheResponseType.NotSatisfied;
                             }
-                        }
-
-                        // Now report those results requested, if they are satisfied.
-                        if (response.Type == ResultsCacheResponseType.Satisfied)
-                        {
-                            List<string> targetsToAddResultsFor = new List<string>(configInitialTargets);
 
-                            // Now report either the explicit targets or the default targets
-                            if (request.Targets.Count > 0)
+                            // We could still be missing implicit targets, so check those...
+                            if (request.Targets.Count == 0)
                             {
-                                targetsToAddResultsFor.AddRange(request.Targets);
+                                // Check for the default target, if necessary.  If we don't know what the default targets are, we
+                                // assume they are not satisfied.
+                                if (configDefaultTargets == null || !CheckResults(allResults, configDefaultTargets, null, skippedResultsDoNotCauseCacheMiss))
+                                {
+                                    response.Type = ResultsCacheResponseType.NotSatisfied;
+                                }
                             }
-                            else
+
+                            // Now report those results requested, if they are satisfied.
+                            if (response.Type == ResultsCacheResponseType.Satisfied)
                             {
-                                targetsToAddResultsFor.AddRange(configDefaultTargets);
+                                List<string> targetsToAddResultsFor = new List<string>(configInitialTargets);
+
+                                // Now report either the explicit targets or the default targets
+                                if (request.Targets.Count > 0)
+                                {
+                                    targetsToAddResultsFor.AddRange(request.Targets);
+                                }
+                                else
+                                {
+                                    targetsToAddResultsFor.AddRange(configDefaultTargets);
+                                }
+
+                                response.Results = new BuildResult(request, allResults, targetsToAddResultsFor.ToArray(), null);
                             }
-
-                            response.Results = new BuildResult(request, allResults, targetsToAddResultsFor.ToArray(), null);
                         }
                     }
                 }
@@ -328,6 +343,56 @@ private static bool CheckResults(BuildResult result, List<string> targets, HashS
             return returnValue;
         }
 
+        /// <summary>
+        /// Returns true if the flags and project state filter of the given build request are compatible with the given build result.
+        /// </summary>
+        /// <param name="buildRequest">The current build request.</param>
+        /// <param name="buildResult">The candidate build result.</param>
+        /// <returns>True if the flags and project state filter of the build request is compatible with the build result.</returns>
+        private static bool AreBuildResultFlagsCompatible(BuildRequest buildRequest, BuildResult buildResult)
+        {
+            BuildRequestDataFlags buildRequestDataFlags = buildRequest.BuildRequestDataFlags;
+            BuildRequestDataFlags buildResultDataFlags = buildResult.BuildRequestDataFlags;
+
+            if ((buildRequestDataFlags & FlagsAffectingBuildResults) != (buildResultDataFlags & FlagsAffectingBuildResults))
+            {
+                // Mismatch in flags that can affect build results -> not compatible.
+                return false;
+            }
+
+            if (HasProvideProjectStateAfterBuild(buildRequestDataFlags))
+            {
+                // If full state is requested, we must have full state in the result.
+                return HasProvideProjectStateAfterBuild(buildResultDataFlags);
+            }
+
+            if (HasProvideSubsetOfStateAfterBuild(buildRequestDataFlags))
+            {
+                // If partial state is requested, we must have full or partial-and-compatible state in the result.
+                if (HasProvideProjectStateAfterBuild(buildResultDataFlags))
+                {
+                    return true;
+                }
+                if (!HasProvideSubsetOfStateAfterBuild(buildResultDataFlags))
+                {
+                    return false;
+                }
+
+                // Verify that the requested subset is compatible with the result.
+                return buildRequest.RequestedProjectState is not null &&
+                    buildResult.ProjectStateAfterBuild?.RequestedProjectStateFilter is not null &&
+                    buildRequest.RequestedProjectState.IsSubsetOf(buildResult.ProjectStateAfterBuild.RequestedProjectStateFilter);
+            }
+
+            return true;
+
+            static bool HasProvideProjectStateAfterBuild(BuildRequestDataFlags flags)
+                => (flags & BuildRequestDataFlags.ProvideProjectStateAfterBuild) == BuildRequestDataFlags.ProvideProjectStateAfterBuild;
+
+            static bool HasProvideSubsetOfStateAfterBuild(BuildRequestDataFlags flags)
+                => (flags & BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild) == BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild;
+        }
+
         public IEnumerator<BuildResult> GetEnumerator()
         {
             return _resultsByConfiguration.Values.GetEnumerator();
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 6d4973bc223..3e44402a61e 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -570,7 +570,8 @@ BuildEventContext LogProjectStarted(
         /// <param name="taskName">The name of the task</param>
         /// <param name="projectFile">The project file which is being built</param>
         /// <param name="projectFileOfTaskNode">The file in which the task is defined - typically a .targets file</param>
-        void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode);
+        /// <param name="taskAssemblyLocation">>The location of the assembly containing the implementation of the task.</param>
+        void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, string taskAssemblyLocation);
 
         /// <summary>
         /// Log that a task is about to start
@@ -581,8 +582,9 @@ BuildEventContext LogProjectStarted(
         /// <param name="projectFileOfTaskNode">The file in which the task is defined - typically a .targets file</param>
         /// <param name="line">The line number in the file where the task invocation is located.</param>
         /// <param name="column">The column number in the file where the task invocation is located.</param>
+        /// <param name="taskAssemblyLocation">>The location of the assembly containing the implementation of the task.</param>
         /// <returns>The task build event context</returns>
-        BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column);
+        BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column, string taskAssemblyLocation);
 
         /// <summary>
         /// Log that a task has just completed
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 9ef9a58f17b..547554d06d8 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -688,8 +688,9 @@ public void LogTargetFinished(BuildEventContext targetBuildEventContext, string
         /// <param name="taskName">Task Name</param>
         /// <param name="projectFile">Project file being built</param>
         /// <param name="projectFileOfTaskNode">Project file which contains the task</param>
+        /// <param name="taskAssemblyLocation">>The location of the assembly containing the implementation of the task.</param>
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
-        public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode)
+        public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, string taskAssemblyLocation)
         {
             ErrorUtilities.VerifyThrow(taskBuildEventContext != null, "targetBuildEventContext is null");
             if (!OnlyLogCriticalEvents)
@@ -699,7 +700,8 @@ public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskN
                         helpKeyword: null,
                         projectFile,
                         projectFileOfTaskNode,
-                        taskName);
+                        taskName,
+                        taskAssemblyLocation);
                 buildEvent.BuildEventContext = taskBuildEventContext;
                 ProcessLoggingEvent(buildEvent);
             }
@@ -714,9 +716,10 @@ public void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskN
         /// <param name="projectFileOfTaskNode">Project file which contains the task</param>
         /// <param name="line">The line number in the file where the task invocation is located.</param>
         /// <param name="column">The column number in the file where the task invocation is located.</param>
+        /// <param name="taskAssemblyLocation">>The location of the assembly containing the implementation of the task.</param>
         /// <returns>The build event context for the task.</returns>
         /// <exception cref="InternalErrorException">BuildEventContext is null</exception>
-        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column)
+        public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column, string taskAssemblyLocation)
         {
             ErrorUtilities.VerifyThrow(targetBuildEventContext != null, "targetBuildEventContext is null");
             BuildEventContext taskBuildEventContext = new BuildEventContext(
@@ -734,7 +737,8 @@ public BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventConte
                         helpKeyword: null,
                         projectFile,
                         projectFileOfTaskNode,
-                        taskName);
+                        taskName,
+                        taskAssemblyLocation);
                 buildEvent.BuildEventContext = taskBuildEventContext;
                 buildEvent.LineNumber = line;
                 buildEvent.ColumnNumber = column;
diff --git a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
index 3d9a25df6cc..af37bd0f690 100644
--- a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
@@ -108,11 +108,11 @@ internal void LogTargetBatchFinished(string projectFullPath, bool success, IEnum
         /// <summary>
         /// Log that a task is about to start
         /// </summary>
-        internal TaskLoggingContext LogTaskBatchStarted(string projectFullPath, ProjectTargetInstanceChild task)
+        internal TaskLoggingContext LogTaskBatchStarted(string projectFullPath, ProjectTargetInstanceChild task, string taskAssemblyLocation)
         {
             ErrorUtilities.VerifyThrow(IsValid, "Should be valid");
 
-            return new TaskLoggingContext(this, projectFullPath, task);
+            return new TaskLoggingContext(this, projectFullPath, task, taskAssemblyLocation);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
index 2728ed5592e..f962f3da74d 100644
--- a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
@@ -34,7 +34,7 @@ internal class TaskLoggingContext : BuildLoggingContext
         /// <summary>
         /// Constructs a task logging context from a parent target context and a task node.
         /// </summary>
-        internal TaskLoggingContext(TargetLoggingContext targetLoggingContext, string projectFullPath, ProjectTargetInstanceChild task)
+        internal TaskLoggingContext(TargetLoggingContext targetLoggingContext, string projectFullPath, ProjectTargetInstanceChild task, string taskAssemblyLocation)
             : base(targetLoggingContext)
         {
             _targetLoggingContext = targetLoggingContext;
@@ -72,7 +72,8 @@ internal TaskLoggingContext(TargetLoggingContext targetLoggingContext, string pr
                 projectFullPath,
                 task.Location.File,
                 task.Location.Line,
-                task.Location.Column);
+                task.Location.Column,
+                taskAssemblyLocation);
             this.IsValid = true;
         }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index b4d621fce8d..485ee854f73 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -115,7 +115,7 @@ internal class TaskBuilder : ITaskBuilder, IBuildComponent
         /// <summary>
         /// The task execution host for in-proc tasks.
         /// </summary>
-        private ITaskExecutionHost _taskExecutionHost;
+        private TaskExecutionHost _taskExecutionHost;
 
         /// <summary>
         /// The object used to synchronize access to the task execution host.
@@ -423,10 +423,12 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 {
                     // We need to find the task before logging the task started event so that the using task statement comes before the task started event
                     IDictionary<string, string> taskIdentityParameters = GatherTaskIdentityParameters(bucket.Expander);
-                    TaskRequirements? requirements = _taskExecutionHost.FindTask(taskIdentityParameters);
+                    (TaskRequirements? requirements, TaskFactoryWrapper taskFactoryWrapper) = _taskExecutionHost.FindTask(taskIdentityParameters);
+                    string taskAssemblyLocation = taskFactoryWrapper?.TaskFactoryLoadedType?.Path;
+
                     if (requirements != null)
                     {
-                        TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
+                        TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance, taskAssemblyLocation);
                         MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
                         _buildRequestEntry.Request.CurrentTaskContext = taskLoggingContext.BuildEventContext;
 
@@ -652,7 +654,7 @@ private async Task<WorkUnitResult> InitializeAndExecuteTask(TaskLoggingContext t
                 ProjectErrorUtilities.ThrowInvalidProject(_targetChildInstance.Location, "TaskDeclarationOrUsageError", _taskNode.Name);
             }
 
-            using var assemblyLoadsTracker = AssemblyLoadsTracker.StartTracking(taskLoggingContext, AssemblyLoadingContext.TaskRun, (_taskExecutionHost as TaskExecutionHost)?.TaskInstance?.GetType());
+            using var assemblyLoadsTracker = AssemblyLoadsTracker.StartTracking(taskLoggingContext, AssemblyLoadingContext.TaskRun, _taskExecutionHost?.TaskInstance?.GetType());
 
             try
             {
@@ -734,7 +736,7 @@ private void UpdateContinueOnError(ItemBucket bucket, TaskHost taskHost)
         /// <param name="bucket">The batching bucket</param>
         /// <param name="howToExecuteTask">The task execution mode</param>
         /// <returns>The result of running the task.</returns>
-        private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost, TaskLoggingContext taskLoggingContext, TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask)
+        private async Task<WorkUnitResult> ExecuteInstantiatedTask(TaskExecutionHost taskExecutionHost, TaskLoggingContext taskLoggingContext, TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask)
         {
             UpdateContinueOnError(bucket, taskHost);
 
@@ -754,20 +756,13 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                 Exception taskException = null;
 
                 // If this is the MSBuild task, we need to execute it's special internal method.
-                TaskExecutionHost host = taskExecutionHost as TaskExecutionHost;
-                Type taskType = host.TaskInstance.GetType();
-
                 try
                 {
-                    if (taskType == typeof(MSBuild))
+                    if (taskExecutionHost.TaskInstance is MSBuild msbuildTask)
                     {
-                        MSBuild msbuildTask = host.TaskInstance as MSBuild;
-
-                        ErrorUtilities.VerifyThrow(msbuildTask != null, "Unexpected MSBuild internal task.");
-
                         var undeclaredProjects = GetUndeclaredProjects(msbuildTask);
 
-                        if (undeclaredProjects != null && undeclaredProjects.Count != 0)
+                        if (undeclaredProjects?.Count > 0)
                         {
                             _continueOnError = ContinueOnError.ErrorAndStop;
 
@@ -799,9 +794,8 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                             }
                         }
                     }
-                    else if (taskType == typeof(CallTarget))
+                    else if (taskExecutionHost.TaskInstance is CallTarget callTargetTask)
                     {
-                        CallTarget callTargetTask = host.TaskInstance as CallTarget;
                         taskResult = await callTargetTask.ExecuteInternal();
                     }
                     else
@@ -951,7 +945,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                 // When a task fails it must log an error. If a task fails to do so,
                 // that is logged as an error. MSBuild tasks are an exception because
                 // errors are not logged directly from them, but the tasks spawned by them.
-                IBuildEngine be = host.TaskInstance.BuildEngine;
+                IBuildEngine be = taskExecutionHost.TaskInstance.BuildEngine;
                 if (taskReturned // if the task returned
                     && !taskResult // and it returned false
                     && !taskLoggingContext.HasLoggedErrors // and it didn't log any errors
@@ -1072,7 +1066,7 @@ private List<string> GetUndeclaredProjects(MSBuild msbuildTask)
         /// <param name="howToExecuteTask">The task execution mode</param>
         /// <param name="bucket">The bucket to which the task execution belongs.</param>
         /// <returns>true, if successful</returns>
-        private bool GatherTaskOutputs(ITaskExecutionHost taskExecutionHost, TaskExecutionMode howToExecuteTask, ItemBucket bucket)
+        private bool GatherTaskOutputs(TaskExecutionHost taskExecutionHost, TaskExecutionMode howToExecuteTask, ItemBucket bucket)
         {
             bool gatheredTaskOutputsSuccessfully = true;
 
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index 6b2715903e7..4f9e62b9343 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -4,6 +4,9 @@
 using System;
 using System.Collections.Concurrent;
 using System.IO;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+using System.Text;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd;
@@ -430,28 +433,115 @@ private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)
             _shutdownReason = _cancelRequested ? NodeEngineShutdownReason.BuildComplete : NodeEngineShutdownReason.BuildCompleteReuse;
             _shutdownEvent.Set();
         }
-        internal sealed class RedirectConsoleWriter : StringWriter
+
+        internal sealed class RedirectConsoleWriter : TextWriter
         {
             private readonly Action<string> _writeCallback;
             private readonly Timer _timer;
             private readonly TextWriter _syncWriter;
 
+            private readonly StringWriter _internalWriter;
+
             private RedirectConsoleWriter(Action<string> writeCallback)
             {
                 _writeCallback = writeCallback;
-                _syncWriter = Synchronized(this);
+                _internalWriter = new StringWriter();
+                _syncWriter = Synchronized(_internalWriter);
                 _timer = new Timer(TimerCallback, null, 0, 40);
             }
 
+            public override Encoding Encoding => _internalWriter.Encoding;
+
             public static TextWriter Create(Action<string> writeCallback)
             {
-                RedirectConsoleWriter writer = new(writeCallback);
-                return writer._syncWriter;
+                RedirectConsoleWriter writer = new RedirectConsoleWriter(writeCallback);
+
+                return writer;
             }
 
+            public override void Flush()
+            {
+                var sb = _internalWriter.GetStringBuilder();
+                string captured = sb.ToString();
+                sb.Clear();
+
+                _writeCallback(captured);
+                _internalWriter.Flush();
+            }
+
+            public override void Write(char value) => _syncWriter.Write(value);
+
+            public override void Write(char[]? buffer) => _syncWriter.Write(buffer);
+
+            public override void Write(char[] buffer, int index, int count) => _syncWriter.Write(buffer, index, count);
+
+            public override void Write(bool value) => _syncWriter.Write(value);
+
+            public override void Write(int value) => _syncWriter.Write(value);
+
+            public override void Write(uint value) => _syncWriter.Write(value);
+
+            public override void Write(long value) => _syncWriter.Write(value);
+
+            public override void Write(ulong value) => _syncWriter.Write(value);
+ 
+            public override void Write(float value) => _syncWriter.Write(value);
+
+            public override void Write(double value) => _syncWriter.Write(value);
+
+            public override void Write(decimal value) => _syncWriter.Write(value);
+
+            public override void Write(string? value) => _syncWriter.Write(value);
+
+            public override void Write(object? value) => _syncWriter.Write(value);
+
+            public override void Write(string format, object? arg0) => _syncWriter.Write(format, arg0);
+
+            public override void Write(string format, object? arg0, object? arg1) => _syncWriter.Write(format, arg0, arg1);
+
+            public override void Write(string format, object? arg0, object? arg1, object? arg2) => _syncWriter.Write(format, arg0, arg1, arg2);
+
+            public override void Write(string format, params object?[] arg) => _syncWriter.WriteLine(format, arg);
+
+            public override void WriteLine() => _syncWriter.WriteLine();
+
+            public override void WriteLine(char value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(decimal value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(char[]? buffer) => _syncWriter.WriteLine(buffer);
+
+            public override void WriteLine(char[] buffer, int index, int count) => _syncWriter.WriteLine(buffer, index, count);
+
+            public override void WriteLine(bool value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(int value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(uint value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(long value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(ulong value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(float value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(double value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(string? value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(object? value) => _syncWriter.WriteLine(value);
+
+            public override void WriteLine(string format, object? arg0) => _syncWriter.WriteLine(format, arg0);
+
+            public override void WriteLine(string format, object? arg0, object? arg1) => _syncWriter.WriteLine(format, arg0, arg1);
+
+            public override void WriteLine(string format, object? arg0, object? arg1, object? arg2) => _syncWriter.WriteLine(format, arg0, arg1, arg2);
+
+            public override void WriteLine(string format, params object?[] arg) => _syncWriter.WriteLine(format, arg);
+
             private void TimerCallback(object? state)
             {
-                if (GetStringBuilder().Length > 0)
+                if (_internalWriter.GetStringBuilder().Length > 0)
                 {
                     _syncWriter.Flush();
                 }
@@ -463,20 +553,11 @@ protected override void Dispose(bool disposing)
                 {
                     _timer.Dispose();
                     Flush();
+                    _internalWriter?.Dispose();
                 }
 
                 base.Dispose(disposing);
             }
-
-            public override void Flush()
-            {
-                var sb = GetStringBuilder();
-                var captured = sb.ToString();
-                sb.Clear();
-                _writeCallback(captured);
-
-                base.Flush();
-            }
         }
     }
 }
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index 428eea19656..8951500b8d6 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -119,6 +119,11 @@ private BuildRequest(
             _nodeRequestId = nodeRequestId;
             _buildRequestDataFlags = buildRequestDataFlags;
             _requestedProjectState = requestedProjectState;
+
+            if (_requestedProjectState != null)
+            {
+                _buildRequestDataFlags |= BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild;
+            }
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 27e1b307aab..c5ef050807f 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -699,9 +699,21 @@ public void CacheIfPossible()
                 {
                     if (IsCacheable)
                     {
-                        using ITranslator translator = GetConfigurationTranslator(TranslationDirection.WriteToStream);
+                        string cacheFile = GetCacheFile();
+                        try
+                        {
+                            Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));
+                            using Stream stream = File.Create(cacheFile);
+                            using ITranslator translator = GetConfigurationTranslator(TranslationDirection.WriteToStream, stream);
+
+                            _project.Cache(translator);
+                        }
+                        catch (Exception e) when (e is DirectoryNotFoundException or UnauthorizedAccessException)
+                        {
+                            ErrorUtilities.ThrowInvalidOperation("CacheFileInaccessible", cacheFile, e);
+                            throw;
+                        }
 
-                        _project.Cache(translator);
                         _baseLookup = null;
 
                         IsCached = true;
@@ -727,9 +739,19 @@ public void RetrieveFromCache()
                     return;
                 }
 
-                using ITranslator translator = GetConfigurationTranslator(TranslationDirection.ReadFromStream);
+                string cacheFile = GetCacheFile();
+                try
+                {
+                    using Stream stream = File.OpenRead(cacheFile);
+                    using ITranslator translator = GetConfigurationTranslator(TranslationDirection.ReadFromStream, stream);
 
-                _project.RetrieveFromCache(translator);
+                    _project.RetrieveFromCache(translator);
+                }
+                catch (Exception e) when (e is DirectoryNotFoundException or UnauthorizedAccessException)
+                {
+                    ErrorUtilities.ThrowInvalidOperation("CacheFileInaccessible", cacheFile, e);
+                    throw;
+                }
 
                 IsCached = false;
             }
@@ -940,6 +962,7 @@ internal void ApplyTransferredState(ProjectInstance instance)
         internal string GetCacheFile()
         {
             string filename = Path.Combine(FileUtilities.GetCacheDirectory(), String.Format(CultureInfo.InvariantCulture, "Configuration{0}.cache", _configId));
+
             return filename;
         }
 
@@ -1025,27 +1048,10 @@ private static string ResolveToolsVersion(BuildRequestData data, string defaultT
         /// <summary>
         /// Gets the translator for this configuration.
         /// </summary>
-        private ITranslator GetConfigurationTranslator(TranslationDirection direction)
-        {
-            string cacheFile = GetCacheFile();
-            try
-            {
-                if (direction == TranslationDirection.WriteToStream)
-                {
-                    Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));
-                    return BinaryTranslator.GetWriteTranslator(File.Create(cacheFile));
-                }
-                else
-                {
+        private ITranslator GetConfigurationTranslator(TranslationDirection direction, Stream stream) =>
+            direction == TranslationDirection.WriteToStream
+                    ? BinaryTranslator.GetWriteTranslator(stream)
                     // Not using sharedReadBuffer because this is not a memory stream and so the buffer won't be used anyway.
-                    return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), InterningBinaryReader.PoolingBuffer);
-                }
-            }
-            catch (Exception e) when (e is DirectoryNotFoundException || e is UnauthorizedAccessException)
-            {
-                ErrorUtilities.ThrowInvalidOperation("CacheFileInaccessible", cacheFile, e);
-                throw;
-            }
-        }
+                    : BinaryTranslator.GetReadTranslator(stream, InterningBinaryReader.PoolingBuffer);
     }
 }
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 68aa197381f..208fa2e7b9a 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -116,6 +116,11 @@ public class BuildResult : INodePacket, IBuildResults
         /// </summary>
         private ProjectInstance _projectStateAfterBuild;
 
+        /// <summary>
+        /// The flags provide additional control over the build results and may affect the cached value.
+        /// </summary>
+        private BuildRequestDataFlags _buildRequestDataFlags;
+
         private string _schedulerInducedError;
 
         private HashSet<string> _projectTargets;
@@ -172,6 +177,8 @@ internal BuildResult(BuildResult existingResults, string[] targetNames)
             _requestException = existingResults._requestException;
             _resultsByTarget = CreateTargetResultDictionaryWithContents(existingResults, targetNames);
             _baseOverallResult = existingResults.OverallResult == BuildResultCode.Success;
+            _buildRequestDataFlags = existingResults._buildRequestDataFlags;
+            _projectStateAfterBuild = existingResults._projectStateAfterBuild;
 
             _circularDependency = existingResults._circularDependency;
         }
@@ -204,6 +211,7 @@ internal BuildResult(BuildRequest request, BuildResult existingResults, string[]
             _nodeRequestId = request.NodeRequestId;
             _circularDependency = false;
             _baseOverallResult = true;
+            _buildRequestDataFlags = request.BuildRequestDataFlags;
 
             if (existingResults == null)
             {
@@ -214,6 +222,10 @@ internal BuildResult(BuildRequest request, BuildResult existingResults, string[]
             {
                 _requestException = exception ?? existingResults._requestException;
                 _resultsByTarget = targetNames == null ? existingResults._resultsByTarget : CreateTargetResultDictionaryWithContents(existingResults, targetNames);
+                if (request.RequestedProjectState != null)
+                {
+                    _projectStateAfterBuild = existingResults._projectStateAfterBuild?.FilteredCopy(request.RequestedProjectState);
+                }
             }
         }
 
@@ -380,6 +392,12 @@ public ProjectInstance ProjectStateAfterBuild
             set => _projectStateAfterBuild = value;
         }
 
+        /// <summary>
+        /// Gets the flags that were used in the build request to which these results are associated.
+        /// See <see cref="Execution.BuildRequestDataFlags"/> for examples of the available flags.
+        /// </summary>
+        public BuildRequestDataFlags BuildRequestDataFlags => _buildRequestDataFlags;
+
         /// <summary>
         /// Returns the node packet type.
         /// </summary>
@@ -581,6 +599,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _savedCurrentDirectory);
             translator.Translate(ref _schedulerInducedError);
             translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);
+            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index d435d1c3606..5418d5aee52 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -245,15 +245,23 @@ internal void CacheItems(int configId, string targetName)
                     return;
                 }
 
-                using ITranslator translator = GetResultsCacheTranslator(configId, targetName, TranslationDirection.WriteToStream);
+                string cacheFile = GetCacheFile(configId, targetName);
+                Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));
 
-                // If the translator is null, it means these results were cached once before.  Since target results are immutable once they
-                // have been created, there is no point in writing them again.
-                if (translator != null)
+                // If the file doesn't already exists, then we haven't cached this once before. We need to cache it again since it could have changed.
+                if (!FileSystems.Default.FileExists(cacheFile))
                 {
-                    TranslateItems(translator);
-                    _items = null;
-                    _cacheInfo = new CacheInfo(configId, targetName);
+                    using Stream stream = File.Create(cacheFile);
+                    using ITranslator translator = GetResultsCacheTranslator(TranslationDirection.WriteToStream, stream);
+
+                    // If the translator is null, it means these results were cached once before.  Since target results are immutable once they
+                    // have been created, there is no point in writing them again.
+                    if (translator != null)
+                    {
+                        TranslateItems(translator);
+                        _items = null;
+                        _cacheInfo = new CacheInfo(configId, targetName);
+                    }
                 }
             }
         }
@@ -279,7 +287,9 @@ private void RetrieveItemsFromCache()
             {
                 if (_items == null)
                 {
-                    using ITranslator translator = GetResultsCacheTranslator(_cacheInfo.ConfigId, _cacheInfo.TargetName, TranslationDirection.ReadFromStream);
+                    string cacheFile = GetCacheFile(_cacheInfo.ConfigId, _cacheInfo.TargetName);
+                    using Stream stream = File.OpenRead(cacheFile);
+                    using ITranslator translator = GetResultsCacheTranslator(TranslationDirection.ReadFromStream, stream);
 
                     TranslateItems(translator);
                     _cacheInfo = new CacheInfo();
@@ -339,25 +349,10 @@ private void TranslateItems(ITranslator translator)
         /// <summary>
         /// Gets the translator for this configuration.
         /// </summary>
-        private static ITranslator GetResultsCacheTranslator(int configId, string targetToCache, TranslationDirection direction)
-        {
-            string cacheFile = GetCacheFile(configId, targetToCache);
-            if (direction == TranslationDirection.WriteToStream)
-            {
-                Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));
-                if (FileSystems.Default.FileExists(cacheFile))
-                {
-                    // If the file already exists, then we have cached this once before.  No need to cache it again since it cannot have changed.
-                    return null;
-                }
-
-                return BinaryTranslator.GetWriteTranslator(File.Create(cacheFile));
-            }
-            else
-            {
-                return BinaryTranslator.GetReadTranslator(File.OpenRead(cacheFile), InterningBinaryReader.PoolingBuffer);
-            }
-        }
+        private static ITranslator GetResultsCacheTranslator(TranslationDirection direction, Stream stream) =>
+            direction == TranslationDirection.WriteToStream
+                    ? BinaryTranslator.GetWriteTranslator(stream)
+                    : BinaryTranslator.GetReadTranslator(stream, InterningBinaryReader.PoolingBuffer);
 
         /// <summary>
         /// Information about where the cache for the items in this result are stored.
diff --git a/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs
deleted file mode 100644
index 60dfee13d2c..00000000000
--- a/src/Build/BackEnd/TaskExecutionHost/AddInParts/ITaskExecutionHost.cs
+++ /dev/null
@@ -1,111 +0,0 @@
-ï»¿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.Threading;
-using Microsoft.Build.Execution;
-using Microsoft.Build.Framework;
-using ElementLocation = Microsoft.Build.Construction.ElementLocation;
-using TargetLoggingContext = Microsoft.Build.BackEnd.Logging.TargetLoggingContext;
-using TaskLoggingContext = Microsoft.Build.BackEnd.Logging.TaskLoggingContext;
-
-#nullable disable
-
-namespace Microsoft.Build.BackEnd
-{
-    /// <summary>
-    /// Flags requrned by ITaskExecutionHost.FindTask().
-    /// </summary>
-    [Flags]
-    internal enum TaskRequirements
-    {
-        /// <summary>
-        /// The task was not found.
-        /// </summary>
-        None = 0,
-
-        /// <summary>
-        /// The task must be executed on an STA thread.
-        /// </summary>
-        RequireSTAThread = 0x01,
-
-        /// <summary>
-        /// The task must be executed in a separate AppDomain.
-        /// </summary>
-        RequireSeparateAppDomain = 0x02
-    }
-
-    /// <summary>
-    /// This interface represents the host for task execution.  When used in the in-proc scenario, these method calls essentially
-    /// are pass-throughs to just set some member variables and call methods directly on the task and associated objects.
-    /// In the out-of-proc/AppDomain-isolated case, the object implementing these methods may break apart the information
-    /// in the parameters to be consumed by the IContract representing the remote object through MAF.
-    ///
-    /// REFACTOR - Eliminate this interface.
-    /// </summary>
-    internal interface ITaskExecutionHost
-    {
-        /// <summary>
-        /// The associated project.
-        /// </summary>
-        ProjectInstance ProjectInstance
-        {
-            get;
-        }
-
-        /// <summary>
-        /// Flag to determine whether or not to log task inputs.
-        /// </summary>
-        bool LogTaskInputs { get; }
-
-        /// <summary>
-        /// Initialize the host with the objects required to communicate with the host process.
-        /// </summary>
-        void InitializeForTask(IBuildEngine2 buildEngine, TargetLoggingContext loggingContext, ProjectInstance projectInstance, string taskName, ElementLocation taskLocation, ITaskHost taskHost, bool continueOnError,
-#if FEATURE_APPDOMAIN
-            AppDomainSetup appDomainSetup,
-#endif
-            bool isOutOfProc, CancellationToken cancellationToken);
-
-        /// <summary>
-        /// Ask the task host to find its task in the registry and get it ready for initializing the batch
-        /// </summary>
-        /// <returns>The task requirements if the task is found, null otherwise.</returns>
-        TaskRequirements? FindTask(IDictionary<string, string> taskIdentityParameters);
-
-        /// <summary>
-        /// Initializes for running a particular batch
-        /// </summary>
-        /// <returns>True if the task is instantiated, false otherwise.</returns>
-        bool InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket batchBucket, IDictionary<string, string> taskIdentityParameters);
-
-        /// <summary>
-        /// Sets a task parameter using an unevaluated value, which will be expanded by the batch bucket.
-        /// </summary>
-        bool SetTaskParameters(IDictionary<string, (string, ElementLocation)> parameters);
-
-        /// <summary>
-        /// Gets all of the outputs and stores them in the batch bucket.
-        /// </summary>
-        bool GatherTaskOutputs(string parameterName, ElementLocation parameterLocation, bool outputTargetIsItem, string outputTargetName);
-
-        /// <summary>
-        /// Signal that we are done with this bucket.
-        /// </summary>
-        void CleanupForBatch();
-
-        /// <summary>
-        /// Signal that we are done with this task.
-        /// </summary>
-        void CleanupForTask();
-
-        /// <summary>
-        /// Executes the task.
-        /// </summary>
-        /// <returns>
-        /// True if execution succeeded, false otherwise.
-        /// </returns>
-        bool Execute();
-    }
-}
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 8296519a5b0..fdff89eb618 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -29,12 +29,34 @@
 
 namespace Microsoft.Build.BackEnd
 {
+    /// <summary>
+    /// Flags returned by TaskExecutionHost.FindTask().
+    /// </summary>
+    [Flags]
+    internal enum TaskRequirements
+    {
+        /// <summary>
+        /// The task was not found.
+        /// </summary>
+        None = 0,
+
+        /// <summary>
+        /// The task must be executed on an STA thread.
+        /// </summary>
+        RequireSTAThread = 0x01,
+
+        /// <summary>
+        /// The task must be executed in a separate AppDomain.
+        /// </summary>
+        RequireSeparateAppDomain = 0x02
+    }
+
     /// <summary>
     /// The TaskExecutionHost is responsible for instantiating tasks, setting their parameters and gathering outputs using
     /// reflection, and executing the task in the appropriate context.The TaskExecutionHost does not deal with any part of the task declaration or
     /// XML.
     /// </summary>
-    internal class TaskExecutionHost : ITaskExecutionHost, IDisposable
+    internal class TaskExecutionHost : IDisposable
     {
         /// <summary>
         /// Time interval in miliseconds to wait between receiving a cancelation signal and emitting the first warning that a non-cancelable task has not finished
@@ -178,7 +200,7 @@ internal TaskExecutionHost()
         /// <summary>
         /// The associated project.
         /// </summary>
-        ProjectInstance ITaskExecutionHost.ProjectInstance => _projectInstance;
+        public ProjectInstance ProjectInstance => _projectInstance;
 
         /// <summary>
         /// Gets the task instance
@@ -220,7 +242,7 @@ public virtual void Dispose()
         /// <summary>
         /// Initialize to run a specific task.
         /// </summary>
-        void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggingContext loggingContext, ProjectInstance projectInstance, string taskName, ElementLocation taskLocation, ITaskHost taskHost, bool continueOnError,
+        public void InitializeForTask(IBuildEngine2 buildEngine, TargetLoggingContext loggingContext, ProjectInstance projectInstance, string taskName, ElementLocation taskLocation, ITaskHost taskHost, bool continueOnError,
 #if FEATURE_APPDOMAIN
             AppDomainSetup appDomainSetup,
 #endif
@@ -243,17 +265,14 @@ void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggi
         /// <summary>
         /// Ask the task host to find its task in the registry and get it ready for initializing the batch
         /// </summary>
-        /// <returns>True if the task is found in the task registry false if otherwise.</returns>
-        TaskRequirements? ITaskExecutionHost.FindTask(IDictionary<string, string> taskIdentityParameters)
+        /// <returns>The task requirements and task factory wrapper if the task is found, (null, null) otherwise.</returns>
+        public (TaskRequirements? requirements, TaskFactoryWrapper taskFactoryWrapper) FindTask(IDictionary<string, string> taskIdentityParameters)
         {
-            if (_taskFactoryWrapper == null)
-            {
-                _taskFactoryWrapper = FindTaskInRegistry(taskIdentityParameters);
-            }
+            _taskFactoryWrapper ??= FindTaskInRegistry(taskIdentityParameters);
 
-            if (_taskFactoryWrapper == null)
+            if (_taskFactoryWrapper is null)
             {
-                return null;
+                return (null, null);
             }
 
             TaskRequirements requirements = TaskRequirements.None;
@@ -272,13 +291,13 @@ void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggi
                 _remotedTaskItems = new List<TaskItem>();
             }
 
-            return requirements;
+            return (requirements, _taskFactoryWrapper);
         }
 
         /// <summary>
         /// Initialize to run a specific batch of the current task.
         /// </summary>
-        bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket batchBucket, IDictionary<string, string> taskIdentityParameters)
+        public bool InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket batchBucket, IDictionary<string, string> taskIdentityParameters)
         {
             ErrorUtilities.VerifyThrowArgumentNull(loggingContext, nameof(loggingContext));
             ErrorUtilities.VerifyThrowArgumentNull(batchBucket, nameof(batchBucket));
@@ -313,6 +332,13 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It
                 return false;
             }
 
+            string realTaskAssemblyLoaction = TaskInstance.GetType().Assembly.Location;
+            if (!string.IsNullOrWhiteSpace(realTaskAssemblyLoaction) &&
+                realTaskAssemblyLoaction != _taskFactoryWrapper.TaskFactoryLoadedType.Path)
+            {
+                _taskLoggingContext.LogComment(MessageImportance.Normal, "TaskAssemblyLocationMismatch", realTaskAssemblyLoaction, _taskFactoryWrapper.TaskFactoryLoadedType.Path);
+            }
+
             TaskInstance.BuildEngine = _buildEngine;
             TaskInstance.HostObject = _taskHost;
 
@@ -324,7 +350,7 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It
         /// </summary>
         /// <param name="parameters">The name/value pairs for the parameters.</param>
         /// <returns>True if the parameters were set correctly, false otherwise.</returns>
-        bool ITaskExecutionHost.SetTaskParameters(IDictionary<string, (string, ElementLocation)> parameters)
+        public bool SetTaskParameters(IDictionary<string, (string, ElementLocation)> parameters)
         {
             ErrorUtilities.VerifyThrowArgumentNull(parameters, nameof(parameters));
 
@@ -395,7 +421,7 @@ bool ITaskExecutionHost.SetTaskParameters(IDictionary<string, (string, ElementLo
         /// Retrieve the outputs from the task.
         /// </summary>
         /// <returns>True of the outputs were gathered successfully, false otherwise.</returns>
-        bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation parameterLocation, bool outputTargetIsItem, string outputTargetName)
+        public bool GatherTaskOutputs(string parameterName, ElementLocation parameterLocation, bool outputTargetIsItem, string outputTargetName)
         {
             ErrorUtilities.VerifyThrow(_taskFactoryWrapper != null, "Need a taskFactoryWrapper to retrieve outputs from.");
 
@@ -500,7 +526,7 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
         /// <summary>
         /// Cleans up after running a batch.
         /// </summary>
-        void ITaskExecutionHost.CleanupForBatch()
+        public void CleanupForBatch()
         {
             try
             {
@@ -518,7 +544,7 @@ void ITaskExecutionHost.CleanupForBatch()
         /// <summary>
         /// Cleans up after running the task.
         /// </summary>
-        void ITaskExecutionHost.CleanupForTask()
+        public void CleanupForTask()
         {
 #if FEATURE_APPDOMAIN
             if (_resolver != null)
@@ -541,7 +567,7 @@ void ITaskExecutionHost.CleanupForTask()
         /// <summary>
         /// Executes the task.
         /// </summary>
-        bool ITaskExecutionHost.Execute()
+        public bool Execute()
         {
             // If cancel is called before we get here, we simply don't execute and return failure.  If cancel is called after this check
             // the task needs to be able to handle the possibility that Cancel has been called before the task has done anything meaningful,
@@ -923,17 +949,11 @@ private ITask InstantiateTask(IDictionary<string, string> taskIdentityParameters
                 else
                 {
                     TaskFactoryLoggingHost loggingHost = new TaskFactoryLoggingHost(_buildEngine.IsRunningMultipleNodes, _taskLocation, _taskLoggingContext);
-                    ITaskFactory2 taskFactory2 = _taskFactoryWrapper.TaskFactory as ITaskFactory2;
                     try
                     {
-                        if (taskFactory2 == null)
-                        {
-                            task = _taskFactoryWrapper.TaskFactory.CreateTask(loggingHost);
-                        }
-                        else
-                        {
-                            task = taskFactory2.CreateTask(loggingHost, taskIdentityParameters);
-                        }
+                        task = _taskFactoryWrapper.TaskFactory is ITaskFactory2 taskFactory2 ?
+                            taskFactory2.CreateTask(loggingHost, taskIdentityParameters) :
+                            _taskFactoryWrapper.TaskFactory.CreateTask(loggingHost);
                     }
                     finally
                     {
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 6f8c5ed00f6..92c09ec6c01 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -291,6 +291,7 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
                         return string.Empty;
                     }
 
+#pragma warning disable CA2000 // Dispose objects before losing scope is false positive here.
                     using (RegistryKey key = GetBaseKeyFromKeyName(keyName, view, out string subKeyName))
                     {
                         if (key != null)
@@ -311,6 +312,7 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
                             }
                         }
                     }
+#pragma warning restore CA2000 // Dispose objects before losing scope
                 }
             }
 
@@ -446,12 +448,13 @@ internal static object StableStringHash(string toHash, StringHashingAlgorithm al
 
         private static string CalculateSha256(string toHash)
         {
-            var sha = System.Security.Cryptography.SHA256.Create();
+            using var sha = System.Security.Cryptography.SHA256.Create();
             var hashResult = new StringBuilder();
             foreach (byte theByte in sha.ComputeHash(Encoding.UTF8.GetBytes(toHash)))
             {
                 hashResult.Append(theByte.ToString("x2"));
             }
+
             return hashResult.ToString();
         }
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index 9dfd281b165..d40ea3145fa 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Collections.Immutable;
+using System.Diagnostics.CodeAnalysis;
 using System.Linq;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Eventing;
@@ -33,6 +34,7 @@ public IncludeOperation(IncludeOperationBuilder builder, LazyItemEvaluator<P, I,
                 _metadata = builder.Metadata.ToImmutable();
             }
 
+            [SuppressMessage("Microsoft.Dispose", "CA2000:Dispose objects before losing scope", Justification = "_lazyEvaluator._evaluationProfiler has own dipose logic.")]
             protected override ImmutableArray<I> SelectItems(OrderedItemDataCollection.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
             {
                 ImmutableArray<I>.Builder? itemsToAdd = null;
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index dabd4276bc6..311392df81f 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -38,6 +38,8 @@ internal class GraphBuilder
 
         public GraphEdges Edges { get; private set; }
 
+        public SolutionFile Solution { get; private set; }
+
         private readonly List<ConfigurationMetadata> _entryPointConfigurationMetadata;
 
         private readonly ParallelWorkSet<ConfigurationMetadata, ParsedProject> _graphWorkSet;
@@ -269,43 +271,43 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
                 solutionGlobalPropertiesBuilder.AddRange(solutionEntryPoint.GlobalProperties);
             }
 
-            var solution = SolutionFile.Parse(solutionEntryPoint.ProjectFile);
+            Solution = SolutionFile.Parse(solutionEntryPoint.ProjectFile);
 
-            if (solution.SolutionParserWarnings.Count != 0 || solution.SolutionParserErrorCodes.Count != 0)
+            if (Solution.SolutionParserWarnings.Count != 0 || Solution.SolutionParserErrorCodes.Count != 0)
             {
                 throw new InvalidProjectFileException(
                     ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                         "StaticGraphSolutionLoaderEncounteredSolutionWarningsAndErrors",
                         solutionEntryPoint.ProjectFile,
-                        string.Join(";", solution.SolutionParserWarnings),
-                        string.Join(";", solution.SolutionParserErrorCodes)));
+                        string.Join(";", Solution.SolutionParserWarnings),
+                        string.Join(";", Solution.SolutionParserErrorCodes)));
             }
 
             // Mimic behavior of SolutionProjectGenerator
-            SolutionConfigurationInSolution currentSolutionConfiguration = SelectSolutionConfiguration(solution, solutionEntryPoint.GlobalProperties);
+            SolutionConfigurationInSolution currentSolutionConfiguration = SelectSolutionConfiguration(Solution, solutionEntryPoint.GlobalProperties);
             solutionGlobalPropertiesBuilder["Configuration"] = currentSolutionConfiguration.ConfigurationName;
             solutionGlobalPropertiesBuilder["Platform"] = currentSolutionConfiguration.PlatformName;
 
-            string solutionConfigurationXml = SolutionProjectGenerator.GetSolutionConfiguration(solution, currentSolutionConfiguration);
+            string solutionConfigurationXml = SolutionProjectGenerator.GetSolutionConfiguration(Solution, currentSolutionConfiguration);
             solutionGlobalPropertiesBuilder["CurrentSolutionConfigurationContents"] = solutionConfigurationXml;
             solutionGlobalPropertiesBuilder["BuildingSolutionFile"] = "true";
 
-            string solutionDirectoryName = solution.SolutionFileDirectory;
+            string solutionDirectoryName = Solution.SolutionFileDirectory;
             if (!solutionDirectoryName.EndsWith(Path.DirectorySeparatorChar.ToString(), StringComparison.Ordinal))
             {
                 solutionDirectoryName += Path.DirectorySeparatorChar;
             }
 
             solutionGlobalPropertiesBuilder["SolutionDir"] = EscapingUtilities.Escape(solutionDirectoryName);
-            solutionGlobalPropertiesBuilder["SolutionExt"] = EscapingUtilities.Escape(Path.GetExtension(solution.FullPath));
-            solutionGlobalPropertiesBuilder["SolutionFileName"] = EscapingUtilities.Escape(Path.GetFileName(solution.FullPath));
-            solutionGlobalPropertiesBuilder["SolutionName"] = EscapingUtilities.Escape(Path.GetFileNameWithoutExtension(solution.FullPath));
-            solutionGlobalPropertiesBuilder[SolutionProjectGenerator.SolutionPathPropertyName] = EscapingUtilities.Escape(Path.Combine(solution.SolutionFileDirectory, Path.GetFileName(solution.FullPath)));
+            solutionGlobalPropertiesBuilder["SolutionExt"] = EscapingUtilities.Escape(Path.GetExtension(Solution.FullPath));
+            solutionGlobalPropertiesBuilder["SolutionFileName"] = EscapingUtilities.Escape(Path.GetFileName(Solution.FullPath));
+            solutionGlobalPropertiesBuilder["SolutionName"] = EscapingUtilities.Escape(Path.GetFileNameWithoutExtension(Solution.FullPath));
+            solutionGlobalPropertiesBuilder[SolutionProjectGenerator.SolutionPathPropertyName] = EscapingUtilities.Escape(Path.Combine(Solution.SolutionFileDirectory, Path.GetFileName(Solution.FullPath)));
 
             // Project configurations are reused heavily, so cache the global properties for each
             Dictionary<string, ImmutableDictionary<string, string>> globalPropertiesForProjectConfiguration = new(StringComparer.OrdinalIgnoreCase);
 
-            IReadOnlyList<ProjectInSolution> projectsInSolution = solution.ProjectsInOrder;
+            IReadOnlyList<ProjectInSolution> projectsInSolution = Solution.ProjectsInOrder;
             List<ProjectGraphEntryPoint> newEntryPoints = new(projectsInSolution.Count);
             Dictionary<string, IReadOnlyCollection<string>> solutionDependencies = new();
 
@@ -318,7 +320,7 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
 
                 ProjectConfigurationInSolution projectConfiguration = SelectProjectConfiguration(currentSolutionConfiguration, project.ProjectConfigurations);
 
-                if (!SolutionProjectGenerator.WouldProjectBuild(solution, currentSolutionConfiguration.FullName, project, projectConfiguration))
+                if (!SolutionProjectGenerator.WouldProjectBuild(Solution, currentSolutionConfiguration.FullName, project, projectConfiguration))
                 {
                     continue;
                 }
@@ -341,11 +343,11 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
                     List<string> solutionDependenciesForProject = new(project.Dependencies.Count);
                     foreach (string dependencyProjectGuid in project.Dependencies)
                     {
-                        if (!solution.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out ProjectInSolution dependencyProject))
+                        if (!Solution.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out ProjectInSolution dependencyProject))
                         {
                             ProjectFileErrorUtilities.ThrowInvalidProjectFile(
                                 "SubCategoryForSolutionParsingErrors",
-                                new BuildEventFileInfo(solution.FullPath),
+                                new BuildEventFileInfo(Solution.FullPath),
                                 "SolutionParseProjectDepNotFoundError",
                                 project.ProjectGuid,
                                 dependencyProjectGuid);
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index c9b55477667..8bbf4e453c4 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -10,6 +10,8 @@
 using System.Linq;
 using System.Text;
 using System.Threading;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
@@ -60,6 +62,8 @@ public delegate ProjectInstance ProjectInstanceFactoryFunc(
 
         internal GraphBuilder.GraphEdges TestOnly_Edges => Edges;
 
+        internal SolutionFile Solution { get; }
+
         public GraphConstructionMetrics ConstructionMetrics { get; private set; }
 
         /// <summary>
@@ -433,6 +437,7 @@ public ProjectGraph(
             GraphRoots = graphBuilder.RootNodes;
             ProjectNodes = graphBuilder.ProjectNodes;
             Edges = graphBuilder.Edges;
+            Solution = graphBuilder.Solution;
 
             _projectNodesTopologicallySorted = new Lazy<IReadOnlyCollection<ProjectGraphNode>>(() => TopologicalSort(GraphRoots, ProjectNodes));
 
@@ -604,14 +609,92 @@ public IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> GetTargetLis
             var encounteredEdges = new HashSet<ProjectGraphBuildRequest>();
             var edgesToVisit = new Queue<ProjectGraphBuildRequest>();
 
-            foreach (ProjectGraphNode entryPointNode in EntryPointNodes)
+            if (entryProjectTargets == null || entryProjectTargets.Count == 0)
+            {
+                // If no targets were specified, use every project's default targets.
+                foreach (ProjectGraphNode entryPointNode in EntryPointNodes)
+                {
+                    var entryTargets = ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets);
+                    var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);
+                    encounteredEdges.Add(entryEdge);
+                    edgesToVisit.Enqueue(entryEdge);
+                }
+            }
+            else
             {
-                var entryTargets = entryProjectTargets == null || entryProjectTargets.Count == 0
-                    ? ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets)
-                    : ImmutableList.CreateRange(entryProjectTargets);
-                var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);
-                encounteredEdges.Add(entryEdge);
-                edgesToVisit.Enqueue(entryEdge);
+                foreach (string targetName in entryProjectTargets)
+                {
+                    // Special-case the "Build" target. The solution's metaproj invokes each project's default targets
+                    if (targetName.Equals("Build", StringComparison.OrdinalIgnoreCase))
+                    {
+                        foreach (ProjectGraphNode entryPointNode in EntryPointNodes)
+                        {
+                            var entryTargets = ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets);
+                            var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);
+                            encounteredEdges.Add(entryEdge);
+                            edgesToVisit.Enqueue(entryEdge);
+                        }
+
+                        continue;
+                    }
+
+                    bool isSolutionTraversalTarget = false;
+                    if (Solution != null)
+                    {
+                        foreach (ProjectInSolution project in Solution.ProjectsInOrder)
+                        {
+                            if (!SolutionFile.IsBuildableProject(project))
+                            {
+                                continue;
+                            }
+
+                            string baseProjectName = ProjectInSolution.DisambiguateProjectTargetName(project.GetUniqueProjectName());
+
+                            // Solutions generate target names to build individual projects. Map these to "real" targets on the relevant projects.
+                            // This logic should match SolutionProjectGenerator's behavior, particularly EvaluateAndAddProjects's calls to AddTraversalTargetForProject.
+                            if (MSBuildNameIgnoreCaseComparer.Default.Equals(targetName, baseProjectName))
+                            {
+                                // Build a specific project with its default targets.
+                                ProjectGraphNode node = GetNodeForProject(project);
+                                ProjectGraphBuildRequest entryEdge = new(node, ImmutableList.CreateRange(node.ProjectInstance.DefaultTargets));
+                                encounteredEdges.Add(entryEdge);
+                                edgesToVisit.Enqueue(entryEdge);
+                                isSolutionTraversalTarget = true;
+                            }
+                            else if (targetName.StartsWith($"{baseProjectName}:", StringComparison.OrdinalIgnoreCase))
+                            {
+                                // Build a specific project with the specified target
+                                string projectTargetName = targetName.Substring(baseProjectName.Length + 1);
+
+                                // Special-case "Project:" and "Project:Build". SolutionProjectGenerator does not generate a target for those, so should error with MSB4057
+                                ProjectErrorUtilities.VerifyThrowInvalidProject(
+                                    projectTargetName.Length > 0 && !projectTargetName.Equals("Build", StringComparison.OrdinalIgnoreCase),
+                                    ElementLocation.Create(Solution.FullPath),
+                                    "TargetDoesNotExist",
+                                    targetName);
+
+                                ProjectGraphNode node = GetNodeForProject(project);
+                                ProjectGraphBuildRequest entryEdge = new(node,[projectTargetName]);
+                                encounteredEdges.Add(entryEdge);
+                                edgesToVisit.Enqueue(entryEdge);
+                                isSolutionTraversalTarget = true;
+                            }
+
+                            // For solutions, there should only be exactly one entry node per project file
+                            ProjectGraphNode GetNodeForProject(ProjectInSolution project) => EntryPointNodes.First(node => string.Equals(node.ProjectInstance.FullPath, project.AbsolutePath));
+                        }
+                    }
+
+                    if (!isSolutionTraversalTarget)
+                    {
+                        foreach (ProjectGraphNode entryPointNode in EntryPointNodes)
+                        {
+                            ProjectGraphBuildRequest entryEdge = new(entryPointNode,[targetName]);
+                            encounteredEdges.Add(entryEdge);
+                            edgesToVisit.Enqueue(entryEdge);
+                        }
+                    }
+                }
             }
 
             // Traverse the entire graph, visiting each edge once.
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index fe63676c1d2..572e73b2c86 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -185,6 +185,12 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         private bool _translateEntireState;
         private int _evaluationId = BuildEventContext.InvalidEvaluationId;
 
+        /// <summary>
+        /// The property and item filter used when creating this instance, or null if this is not a filtered copy
+        /// of another ProjectInstance. <seealso cref="ProjectInstance(ProjectInstance, bool, RequestedProjectState)"/>
+        /// </summary>
+        private RequestedProjectState _requestedProjectStateFilter;
+
         /// <summary>
         /// Creates a ProjectInstance directly.
         /// No intermediate Project object is created.
@@ -679,6 +685,7 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
             _isImmutable = isImmutable;
             _evaluationId = that.EvaluationId;
             _translateEntireState = that._translateEntireState;
+            _requestedProjectStateFilter = filter?.DeepClone();
 
             if (filter == null)
             {
@@ -1115,6 +1122,12 @@ public bool IsImmutable
             get { return _isImmutable; }
         }
 
+        /// <summary>
+        /// The property and item filter used when creating this instance, or null if this is not a filtered copy
+        /// of another ProjectInstance. <seealso cref="ProjectInstance(ProjectInstance, bool, RequestedProjectState)"/>
+        /// </summary>
+        internal RequestedProjectState RequestedProjectStateFilter => _requestedProjectStateFilter;
+
         /// <summary>
         /// Task classes and locations known to this project.
         /// This is the project-specific task registry, which is consulted before
@@ -2228,6 +2241,7 @@ internal void TranslateMinimalState(ITranslator translator)
         {
             translator.TranslateDictionary(ref _globalProperties, ProjectPropertyInstance.FactoryForDeserialization);
             translator.TranslateDictionary(ref _properties, ProjectPropertyInstance.FactoryForDeserialization);
+            translator.Translate(ref _requestedProjectStateFilter);
             translator.Translate(ref _isImmutable);
             TranslateItems(translator);
         }
@@ -2768,14 +2782,26 @@ private static ProjectInstance[] GenerateSolutionWrapperUsingOldOM(
                 }
             }
 
-            XmlReaderSettings xrs = new XmlReaderSettings();
-            xrs.DtdProcessing = DtdProcessing.Ignore;
+            XmlReaderSettings xrs = new XmlReaderSettings
+            {
+                DtdProcessing = DtdProcessing.Ignore
+            };
+
+            StringReader sr = new StringReader(wrapperProjectXml);
+            using (XmlReader xmlReader = XmlReader.Create(sr, xrs))
+            {
+                ProjectRootElement projectRootElement = new(
+                    xmlReader,
+                    projectRootElementCache,
+                    isExplicitlyLoaded,
+                    preserveFormatting: false)
+                {
+                    DirectoryPath = Path.GetDirectoryName(projectFile)
+                };
+                ProjectInstance instance = new(projectRootElement, globalProperties, toolsVersion, buildParameters, loggingService, projectBuildEventContext, sdkResolverService, submissionId);
 
-            ProjectRootElement projectRootElement = new ProjectRootElement(XmlReader.Create(new StringReader(wrapperProjectXml), xrs), projectRootElementCache, isExplicitlyLoaded,
-                preserveFormatting: false);
-            projectRootElement.DirectoryPath = Path.GetDirectoryName(projectFile);
-            ProjectInstance instance = new ProjectInstance(projectRootElement, globalProperties, toolsVersion, buildParameters, loggingService, projectBuildEventContext, sdkResolverService, submissionId);
-            return new ProjectInstance[] { instance };
+                return new[] { instance };
+            }
         }
 
         /// <summary>
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 54de65d1d05..8be89caf254 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -69,6 +69,8 @@ public sealed class BinaryLogger : ILogger
         //   - Adding serialized events lengths - to support forward compatible reading
         // version 19:
         //   - GeneratedFileUsedEventArgs exposed for brief period of time (so let's continue with 20)
+        // version 20:
+        //   - TaskStartedEventArgs: Added TaskAssemblyLocation property
 
         // This should be never changed.
         // The minimum version of the binary log reader that can read log of above version.
@@ -76,7 +78,7 @@ public sealed class BinaryLogger : ILogger
 
         // The current version of the binary log representation.
         // Changes with each update of the binary log format.
-        internal const int FileFormatVersion = 18;
+        internal const int FileFormatVersion = 20;
 
         // The minimum version of the binary log reader that can read log of above version.
         // This should be changed only when the binary log format is changed in a way that would prevent it from being
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 2c49c17c8a7..03ce7bed76c 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -20,7 +20,7 @@
 namespace Microsoft.Build.Logging
 {
     /// <summary>
-    /// Deserializes and returns BuildEventArgs-derived objects from a BinaryReader
+    /// Deserializes and returns BuildEventArgs-derived objects from a BinaryReader.
     /// </summary>
     public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposable
     {
@@ -186,7 +186,6 @@ internal RawRecord ReadRaw()
             Stream stream = _binaryReader.BaseStream.Slice(serializedEventLength);
 
             _lastSubStream = stream as SubStream;
-
             _recordNumber += 1;
 
             return new(recordKind, stream);
@@ -806,6 +805,7 @@ private BuildEventArgs ReadTaskStartedEventArgs()
             var taskName = ReadOptionalString();
             var projectFile = ReadOptionalString();
             var taskFile = ReadOptionalString();
+            var taskAssemblyLocation = _fileFormatVersion > 19 ? ReadOptionalString() : null;
 
             var e = new TaskStartedEventArgs(
                 fields.Message,
@@ -813,7 +813,8 @@ private BuildEventArgs ReadTaskStartedEventArgs()
                 projectFile,
                 taskFile,
                 taskName,
-                fields.Timestamp);
+                fields.Timestamp,
+                taskAssemblyLocation);
             e.LineNumber = fields.LineNumber;
             e.ColumnNumber = fields.ColumnNumber;
             SetCommonFields(e, fields);
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index a3ce5efa3c5..0c5c82846b3 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -408,6 +408,7 @@ private BinaryLogRecordKind Write(TaskStartedEventArgs e)
             WriteDeduplicatedString(e.TaskName);
             WriteDeduplicatedString(e.ProjectFile);
             WriteDeduplicatedString(e.TaskFile);
+            WriteDeduplicatedString(e.TaskAssemblyLocation);
 
             return BinaryLogRecordKind.TaskStarted;
         }
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
index 2993b3953c1..d8eca6c3848 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
@@ -5,6 +5,7 @@
 using System.Buffers;
 using System.Diagnostics;
 using System.IO;
+using System.Text;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
@@ -60,7 +61,8 @@ public static byte[] ReadToEnd(this Stream stream)
         {
             if (stream.TryGetLength(out long length))
             {
-                BinaryReader reader = new(stream);
+                using BinaryReader reader = new(stream, Encoding.UTF8, leaveOpen: true);
+
                 return reader.ReadBytes((int)length);
             }
 
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index bceb0f4266b..496f9cf6e7c 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -394,7 +394,6 @@
     <Compile Include="BackEnd\Components\Scheduler\ScheduleResponse.cs" />
     <Compile Include="BackEnd\Node\INode.cs" />
     <!-- ########################## -->
-    <Compile Include="BackEnd\TaskExecutionHost\AddInParts\ITaskExecutionHost.cs" />
     <Compile Include="BackEnd\TaskExecutionHost\TaskExecutionHost.cs" />
     <!-- #### COLLECTIONS ### -->
     <Compile Include="..\Shared\CollectionHelpers.cs" />
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index a037905be7e..7453fff8c5e 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -2000,7 +2000,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION: {0} is a file path. {1} is a comma-separated list of target names
     </comment>
   </data>
-   <data name="DefaultSDKResolverError" xml:space="preserve">
+  <data name="DefaultSDKResolverError" xml:space="preserve">
     <value>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</value>
   </data>
   <data name="SDKResolverReturnedNull" xml:space="preserve">
@@ -2095,6 +2095,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
     </comment>
   </data>
+  <data name="TaskAssemblyLocationMismatch" xml:space="preserve">
+    <value>Task assembly was loaded from '{0}' while the desired location was '{1}'.</value>
+  </data>
   <!--
         The Build message bucket is: MSB4000 - MSB4999
 
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 83d03235b23..ad7c2ad80e5 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -596,6 +596,11 @@ Chyby: {3}</target>
         <target state="translated">SestavenÃ­ naÄteno bÄhem {0}{1}: {2} (umÃ­stÄnÃ­: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Ãloha {0} uvolnila tento poÄet jader: {1}. TeÄ pouÅ¾Ã­vÃ¡ celkem tento poÄet jader: {2}</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 3001fd096d9..c34c232203f 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -596,6 +596,11 @@ Fehler: {3}</target>
         <target state="translated">Assembly wÃ¤hrend {0}{1} geladen: {2} (Speicherort: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Die Aufgabe "{0}" hat {1} Kerne freigegeben und belegt jetzt insgesamt {2} Kerne.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index f5f6b78041f..236863c1570 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -596,6 +596,11 @@ Errores: {3}</target>
         <target state="translated">Ensamblado cargado durante {0}{1}: {2}(ubicaciÃ³n: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">La tarea "{0}" liberÃ³ {1}Â nÃºcleos y ahora retiene un total de {2}Â nÃºcleos.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 28c5c4c14b9..0225ed0f126 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -596,6 +596,11 @@ ErreursÂ : {3}</target>
         <target state="translated">Assembly chargÃ© pendant {0}{1}Â : {2} (emplacement : {3}, MVID : {4}, AssemblyLoadContext : {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">La tÃ¢che "{0}" a libÃ©rÃ© {1} cÅur. Elle dÃ©tient dÃ©sormais {2} cÅurs au total.</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index db3bb216291..f74935daff9 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -596,6 +596,11 @@ Errori: {3}</target>
         <target state="translated">Assembly caricato durante {0}{1}: {2} (percorso: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">L'attivitÃ  "{0}" ha rilasciato {1} core e ora contiene {2} core in totale.</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 82ddae9c55f..8f56bc5320a 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -596,6 +596,11 @@ Errors: {3}</source>
         <target state="translated">{0}{1} ä¸­ã«ã¢ã»ã³ããªãèª­ã¿è¾¼ã¾ãã¾ãã: {2} (å ´æ: {3}ãMVID: {4}ãAssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">ã¿ã¹ã¯ "{0}" ã§ã¯ã{1} åã®ã³ã¢ãè§£æ¾ãããããç¾å¨åè¨ {2} åã®ã³ã¢ãä¿æãã¦ãã¾ãã</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 4b5c0ff47ac..f08f1c8e3a4 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -596,6 +596,11 @@ Errors: {3}</source>
         <target state="translated">{0}{1} ëì ë¡ëë ì´ìë¸ë¦¬: {2}(ìì¹: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">"{0}" ìììì ì½ì´ {1}ê°ë¥¼ í´ì íê³  ì§ê¸ ì´ {2}ê°ì ì½ì´ë¥¼ ë³´ì íê³  ììµëë¤.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index b253894f759..61bf754b653 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -596,6 +596,11 @@ BÅÄdy: {3}</target>
         <target state="translated">ZaÅadowano zestaw podczas {0}{1}: {2} (lokalizacja: {3}, MVID: {4}, kontekst Åadowania zestawu: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Zadanie â{0}â zwolniÅo rdzenie ({1}) i teraz jego ÅÄczna liczba rdzeni to {2}.</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 7e767a652cb..b211fd7d955 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -596,6 +596,11 @@ Erros: {3}</target>
         <target state="translated">Assembly carregado durante {0}{1}: {2} (local: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">A tarefa "{0}" liberou {1} nÃºcleos e agora contÃ©m {2} nÃºcleos no total.</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index bf90a1bb435..234b5338a3f 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -596,6 +596,11 @@ Errors: {3}</source>
         <target state="translated">Ð¡Ð±Ð¾ÑÐºÐ° Ð·Ð°Ð³ÑÑÐ¶ÐµÐ½Ð° Ð²Ð¾ Ð²ÑÐµÐ¼Ñ {0}{1}: {2} (ÑÐ°ÑÐ¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">ÐÐ°Ð´Ð°ÑÐ° "{0}" Ð¾ÑÐ²Ð¾Ð±Ð¾Ð´Ð¸Ð»Ð° ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ðµ ÑÐ¸ÑÐ»Ð¾ ÑÐ´ÐµÑ ({1}). Ð¢ÐµÐ¿ÐµÑÑ Ð¾Ð±ÑÐµÐµ ÑÐ¸ÑÐ»Ð¾ ÑÐ´ÐµÑ, ÐºÐ¾ÑÐ¾ÑÑÐ¼Ð¸ ÑÐ°ÑÐ¿Ð¾Ð»Ð°Ð³Ð°ÐµÑ Ð·Ð°Ð´Ð°ÑÐ°, ÑÐ°Ð²Ð½Ð¾ {2}.</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index ec82a4c4384..3e4431b5272 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -596,6 +596,11 @@ Hatalar: {3}</target>
         <target state="translated">Derleme {0}{1} sÄ±rasÄ±nda yÃ¼klendi: {2} (konum: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">"{0}" gÃ¶revi {1} Ã§ekirdeÄi serbest bÄ±raktÄ±. Åu anda toplam {2} Ã§ekirdek tutuyor.</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index d148cff64c7..f0709af4138 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -285,7 +285,7 @@
       </trans-unit>
       <trans-unit id="IsolatedContextDoesNotSupportFileSystem">
         <source>EvaluationContext objects created with SharingPolicy.Isolated or SharingPolicy.SharedSDKCache do not support being passed an MSBuildFileSystemBase file system.</source>
-        <target state="translated">ä½¿ç¨ SharingPolicy.Isolated åå»ºç EvaluationContext å¯¹è±¡ãSharingPolicy.SharedSDKCache ä¸æ¯æè¢«ä¼ é MSBuildFileSystemBase æä»¶ç³»ç»ã</target>
+        <target state="translated">ä½¿ç¨ SharingPolicy.Isolated æ SharingPolicy.SharedSDKCache åå»ºç EvaluationContext å¯¹è±¡ä¸æ¯æè¢«ä¼ é MSBuildFileSystemBase æä»¶ç³»ç»ã</target>
         <note />
       </trans-unit>
       <trans-unit id="ItemReferencingSelfInTarget">
@@ -596,6 +596,11 @@ Errors: {3}</source>
         <target state="translated">å¨ {0}{1} æé´å è½½çç¨åºé: {2} (ä½ç½®: {3}ï¼MVID: {4}ï¼AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">ä»»å¡â{0}âåå¸äº {1} ä¸ªæ ¸å¿ï¼ç°æ»å±åå« {2} ä¸ªæ ¸å¿ã</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index ef485bd062f..db646b99ac9 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -596,6 +596,11 @@ Errors: {3}</source>
         <target state="translated">çµä»¶å¨ {0}{1} æéè¼å¥: {2} (ä½ç½®: {3}ï¼MVID: {4}ï¼AssemblyLoadContext: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLocationMismatch">
+        <source>Task assembly was loaded from '{0}' while the desired location was '{1}'.</source>
+        <target state="new">Task assembly was loaded from '{0}' while the desired location was '{1}'.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">å·¥ä½ "{0}" å·²ç¼è¡ {1} åæ ¸å¿ï¼ç¾å¨å±ä¿ç {2} åæ ¸å¿ã</target>
diff --git a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
index e38ed53576e..53bb173c271 100644
--- a/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
+++ b/src/Deprecated/Engine/Engine/IntrinsicFunctions.cs
@@ -197,6 +197,7 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
                     // of that error.
                     RegistryView view = (RegistryView)Enum.Parse(typeof(RegistryView), viewAsString, true);
 
+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed as a false positive.
                     using (RegistryKey key = GetBaseKeyFromKeyName(keyName, view, out subKeyName))
                     {
                         if (key != null)
@@ -217,6 +218,7 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
                             }
                         }
                     }
+#pragma warning restore CA2000 // Dispose objects before losing scope
                 }
             }
 
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNode.cs b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
index 73869190849..ebf9109bf72 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNode.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
@@ -9,9 +9,9 @@
 using System.Collections;
 using System.Diagnostics;
 using System.IO;
+using System.Security.AccessControl;
 using System.Threading;
 using Microsoft.Build.BuildEngine.Shared;
-using System.Security.AccessControl;
 
 namespace Microsoft.Build.BuildEngine
 {
@@ -217,6 +217,7 @@ private static bool CreateGlobalEvents(int nodeNumber)
         /// This function starts local node when process is launched and shuts it down on time out
         /// Called by msbuild.exe.
         /// </summary>
+        [System.Diagnostics.CodeAnalysis.SuppressMessage("Reliability", "CA2000:Dispose objects before losing scope", Justification = "Agreed not to touch entries from Deprecated folder")]
         public static void StartLocalNodeServer(int nodeNumber)
         {
             // Create global events necessary for handshaking with the parent
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index fc6affaa7d2..f686521e233 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -13,6 +13,7 @@
     <AssemblyOriginatorKeyFile>$(MSBuildThisFileDirectory)Test.snk</AssemblyOriginatorKeyFile>
     <PublicKey>002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4</PublicKey>
     <PublicKeyToken>9d77cc7ad39b68eb</PublicKeyToken>
+    <NoWarn>$(NoWarn);CA2000</NoWarn>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(IsUnitTestProject)' == 'true'">
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index b543973746e..747a065590e 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -1201,14 +1201,13 @@ internal static void KillTree(int processIdToKill)
 
             // Grab the process handle.  We want to keep this open for the duration of the function so that
             // it cannot be reused while we are running.
-            SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processIdToKill);
-            if (hProcess.IsInvalid)
+            using (SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processIdToKill))
             {
-                return;
-            }
+                if (hProcess.IsInvalid)
+                {
+                    return;
+                }
 
-            try
-            {
                 try
                 {
                     // Kill this process, so that no further children can be created.
@@ -1239,11 +1238,6 @@ internal static void KillTree(int processIdToKill)
                     }
                 }
             }
-            finally
-            {
-                // Release the handle.  After this point no more children of this process exist and this process has also exited.
-                hProcess.Dispose();
-            }
         }
         finally
         {
@@ -1296,11 +1290,9 @@ internal static int GetParentProcessId(int processId)
         else
 #endif
         {
-            SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processId);
-
-            if (!hProcess.IsInvalid)
+            using SafeProcessHandle hProcess = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, processId);
             {
-                try
+                if (!hProcess.IsInvalid)
                 {
                     // UNDONE: NtQueryInformationProcess will fail if we are not elevated and other process is. Advice is to change to use ToolHelp32 API's
                     // For now just return zero and worst case we will not kill some children.
@@ -1312,10 +1304,6 @@ internal static int GetParentProcessId(int processId)
                         ParentID = (int)pbi.InheritedFromUniqueProcessId;
                     }
                 }
-                finally
-                {
-                    hProcess.Dispose();
-                }
             }
         }
 
@@ -1337,34 +1325,38 @@ internal static List<KeyValuePair<int, SafeProcessHandle>> GetChildProcessIds(in
             {
                 // Hold the child process handle open so that children cannot die and restart with a different parent after we've started looking at it.
                 // This way, any handle we pass back is guaranteed to be one of our actual children.
+#pragma warning disable CA2000 // Dispose objects before losing scope - caller must dispose returned handles
                 SafeProcessHandle childHandle = OpenProcess(eDesiredAccess.PROCESS_QUERY_INFORMATION, false, possibleChildProcess.Id);
-                if (childHandle.IsInvalid)
+#pragma warning restore CA2000 // Dispose objects before losing scope
                 {
-                    continue;
-                }
+                    if (childHandle.IsInvalid)
+                    {
+                        continue;
+                    }
 
-                bool keepHandle = false;
-                try
-                {
-                    if (possibleChildProcess.StartTime > parentStartTime)
+                    bool keepHandle = false;
+                    try
                     {
-                        int childParentProcessId = GetParentProcessId(possibleChildProcess.Id);
-                        if (childParentProcessId != 0)
+                        if (possibleChildProcess.StartTime > parentStartTime)
                         {
-                            if (parentProcessId == childParentProcessId)
+                            int childParentProcessId = GetParentProcessId(possibleChildProcess.Id);
+                            if (childParentProcessId != 0)
                             {
-                                // Add this one
-                                myChildren.Add(new KeyValuePair<int, SafeProcessHandle>(possibleChildProcess.Id, childHandle));
-                                keepHandle = true;
+                                if (parentProcessId == childParentProcessId)
+                                {
+                                    // Add this one
+                                    myChildren.Add(new KeyValuePair<int, SafeProcessHandle>(possibleChildProcess.Id, childHandle));
+                                    keepHandle = true;
+                                }
                             }
                         }
                     }
-                }
-                finally
-                {
-                    if (!keepHandle)
+                    finally
                     {
-                        childHandle.Dispose();
+                        if (!keepHandle)
+                        {
+                            childHandle.Dispose();
+                        }
                     }
                 }
             }
diff --git a/src/Framework/TaskStartedEventArgs.cs b/src/Framework/TaskStartedEventArgs.cs
index bdf19fa080a..288a0193524 100644
--- a/src/Framework/TaskStartedEventArgs.cs
+++ b/src/Framework/TaskStartedEventArgs.cs
@@ -49,6 +49,27 @@ public TaskStartedEventArgs(
         {
         }
 
+        /// <summary>
+        /// This constructor allows event data to be initialized.
+        /// Sender is assumed to be "MSBuild".
+        /// </summary>
+        /// <param name="message">text message</param>
+        /// <param name="helpKeyword">help keyword </param>
+        /// <param name="projectFile">project file</param>
+        /// <param name="taskFile">file in which the task is defined</param>
+        /// <param name="taskName">task name</param>
+        /// <param name="taskAssemblyLocation">The location of the assembly containing the implementation of the task.</param>
+        public TaskStartedEventArgs(
+            string message,
+            string helpKeyword,
+            string projectFile,
+            string taskFile,
+            string taskName,
+            string taskAssemblyLocation)
+            : this(message, helpKeyword, projectFile, taskFile, taskName, DateTime.UtcNow, taskAssemblyLocation)
+        {
+        }
+
         /// <summary>
         /// This constructor allows event data to be initialized.
         /// Sender is assumed to be "MSBuild".
@@ -73,6 +94,33 @@ public TaskStartedEventArgs(
             this.taskFile = taskFile;
         }
 
+        /// <summary>
+        /// This constructor allows event data to be initialized.
+        /// Sender is assumed to be "MSBuild".
+        /// </summary>
+        /// <param name="message">text message</param>
+        /// <param name="helpKeyword">help keyword </param>
+        /// <param name="projectFile">project file</param>
+        /// <param name="taskFile">file in which the task is defined</param>
+        /// <param name="taskName">task name</param>
+        /// <param name="eventTimestamp">Timestamp when event was created</param>
+        /// <param name="taskAssemblyLocation">The location of the assembly containing the implementation of the task.</param>
+        public TaskStartedEventArgs(
+            string message,
+            string helpKeyword,
+            string projectFile,
+            string taskFile,
+            string taskName,
+            DateTime eventTimestamp,
+            string taskAssemblyLocation)
+            : base(message, helpKeyword, "MSBuild", eventTimestamp)
+        {
+            this.taskName = taskName;
+            this.projectFile = projectFile;
+            this.taskFile = taskFile;
+            TaskAssemblyLocation = taskAssemblyLocation;
+        }
+        
         private string taskName;
         private string projectFile;
         private string taskFile;
@@ -91,6 +139,7 @@ internal override void WriteToStream(BinaryWriter writer)
             writer.WriteOptionalString(taskFile);
             writer.Write7BitEncodedInt(LineNumber);
             writer.Write7BitEncodedInt(ColumnNumber);
+            writer.WriteOptionalString(TaskAssemblyLocation);
         }
 
         /// <summary>
@@ -102,11 +151,12 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         {
             base.CreateFromStream(reader, version);
 
-            taskName = reader.ReadByte() == 0 ? null : reader.ReadString();
-            projectFile = reader.ReadByte() == 0 ? null : reader.ReadString();
-            taskFile = reader.ReadByte() == 0 ? null : reader.ReadString();
+            taskName = reader.ReadOptionalString();
+            projectFile = reader.ReadOptionalString();
+            taskFile = reader.ReadOptionalString();
             LineNumber = reader.Read7BitEncodedInt();
             ColumnNumber = reader.Read7BitEncodedInt();
+            TaskAssemblyLocation = reader.ReadOptionalString();
         }
         #endregion
 
@@ -135,6 +185,11 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         /// </summary>
         public int ColumnNumber { get; internal set; }
 
+        /// <summary>
+        /// The location of the assembly containing the implementation of the task
+        /// </summary>
+        public string TaskAssemblyLocation { get; private set; }
+
         public override string Message
         {
             get
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Linux.verified.txt
index 2a011fd87a4..94ea05fb0d6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Linux.verified.txt
@@ -1,9 +1,14 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.OSX.verified.txt
index 94c8f8666eb..56e94ae3408 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.OSX.verified.txt
@@ -1,8 +1,13 @@
 ï»¿The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Windows.verified.txt
index 2a011fd87a4..94ea05fb0d6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Windows.verified.txt
@@ -1,9 +1,14 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Linux.verified.txt
index 2a011fd87a4..94ea05fb0d6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Linux.verified.txt
@@ -1,9 +1,14 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.OSX.verified.txt
index 94c8f8666eb..56e94ae3408 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.OSX.verified.txt
@@ -1,8 +1,13 @@
 ï»¿The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Windows.verified.txt
index 2a011fd87a4..94ea05fb0d6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Windows.verified.txt
@@ -1,9 +1,14 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Linux.verified.txt
index c0b5f816a67..0b4eb677187 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Linux.verified.txt
@@ -1,8 +1,13 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.OSX.verified.txt
index f2c3daca5c7..0ac0ba155c8 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.OSX.verified.txt
@@ -1,7 +1,12 @@
 ï»¿The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Windows.verified.txt
index c0b5f816a67..0b4eb677187 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Windows.verified.txt
@@ -1,8 +1,13 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Linux.verified.txt
index c0b5f816a67..0b4eb677187 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Linux.verified.txt
@@ -1,8 +1,13 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.OSX.verified.txt
index f2c3daca5c7..0ac0ba155c8 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.OSX.verified.txt
@@ -1,7 +1,12 @@
 ï»¿The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Windows.verified.txt
index c0b5f816a67..0b4eb677187 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Windows.verified.txt
@@ -1,8 +1,13 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Linux.verified.txt
index ed7d3ade9de..6e417bd1a11 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Linux.verified.txt
@@ -1,3 +1,8 @@
 ï»¿]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+  A
+  Multi
+  Line
+  Warning!
 directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.OSX.verified.txt
index b52d4bf957f..63b3c74b0c3 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.OSX.verified.txt
@@ -1,2 +1,7 @@
 ï»¿directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+  A
+  Multi
+  Line
+  Warning!
 directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Windows.verified.txt
index ed7d3ade9de..6e417bd1a11 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Windows.verified.txt
@@ -1,3 +1,8 @@
 ï»¿]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+  A
+  Multi
+  Line
+  Warning!
 directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Linux.verified.txt
index 2a011fd87a4..94ea05fb0d6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Linux.verified.txt
@@ -1,9 +1,14 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.OSX.verified.txt
index 94c8f8666eb..56e94ae3408 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.OSX.verified.txt
@@ -1,8 +1,13 @@
 ï»¿The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Windows.verified.txt
index 2a011fd87a4..94ea05fb0d6 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Windows.verified.txt
@@ -1,9 +1,14 @@
 ï»¿]9;4;3;\The plugin credential provider could not acquire credentials.Authentication may require manual action. Consider re-running the command with --interactive for `dotnet`, /p:NuGetInteractive="true" for MSBuild or removing the -NonInteractive switch for `NuGet`
-  project [31;1mfailed with 1 error(s) and 1 warning(s)[m (0.2s)
+  project [31;1mfailed with 1 error(s) and 2 warning(s)[m (0.2s)
     High importance message!
     directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
     directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
 [?25l[1F
 [?25h
-Build [31;1mfailed with 1 error(s) and 1 warning(s)[m in 5.0s
+Build [31;1mfailed with 1 error(s) and 2 warning(s)[m in 5.0s
 ]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
index 955610abad2..7f89f347c25 100644
--- a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
+++ b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
@@ -436,6 +436,7 @@ private void CallAllTypesOfMessagesWarningAndError()
             MessageRaised?.Invoke(_eventSender, MakeMessageEventArgs("Normal importance message!", MessageImportance.Normal));
             MessageRaised?.Invoke(_eventSender, MakeMessageEventArgs("Low importance message!", MessageImportance.Low));
             WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("Warning!"));
+            WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("A\nMulti\r\nLine\nWarning!"));
             ErrorRaised?.Invoke(_eventSender, MakeErrorEventArgs("Error!"));
         }
 
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 375cbf871fa..73b4b3e282b 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -1989,9 +1989,7 @@ public void TestProcessFileLoggerSwitch1()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             distributedLoggerRecords.Count.ShouldBe(0); // "Expected no distributed loggers to be attached"
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
         }
@@ -2010,9 +2008,7 @@ public void TestProcessFileLoggerSwitch2()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected one distributed loggers to be attached"
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
         }
@@ -2031,9 +2027,7 @@ public void TestProcessFileLoggerSwitch3()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             distributedLoggerRecords.Count.ShouldBe(0); // "Expected no distributed loggers to be attached"
             loggers.Count.ShouldBe(0); // "Expected a central loggers to be attached"
 
@@ -2045,9 +2039,7 @@ public void TestProcessFileLoggerSwitch3()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             distributedLoggerRecords.Count.ShouldBe(0); // "Expected no distributed loggers to be attached"
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
 
@@ -2058,9 +2050,7 @@ public void TestProcessFileLoggerSwitch3()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             distributedLoggerRecords.Count.ShouldBe(0); // "Expected no distributed loggers to be attached"
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
         }
@@ -2079,9 +2069,7 @@ public void TestProcessFileLoggerSwitch4()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe($"logFile={Path.Combine(Directory.GetCurrentDirectory(), "MSBuild.log")}", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
@@ -2094,9 +2082,7 @@ public void TestProcessFileLoggerSwitch4()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe($"{fileLoggerParameters[0]};logFile={Path.Combine(Directory.GetCurrentDirectory(), "MSBuild.log")}", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
@@ -2109,9 +2095,7 @@ public void TestProcessFileLoggerSwitch4()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe($"{fileLoggerParameters[0]};logFile={Path.Combine(Directory.GetCurrentDirectory(), "MSBuild.log")}", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
@@ -2124,9 +2108,7 @@ public void TestProcessFileLoggerSwitch4()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe($";Parameter1;logFile={Path.Combine(Directory.GetCurrentDirectory(), "MSBuild.log")}", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
@@ -2139,9 +2121,7 @@ public void TestProcessFileLoggerSwitch4()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe(fileLoggerParameters[0] + ";" + fileLoggerParameters[1], StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
@@ -2152,9 +2132,7 @@ public void TestProcessFileLoggerSwitch4()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
             distributedLoggerRecords.Count.ShouldBe(1); // "Expected a distributed logger to be attached"
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe($"Parameter1;verbosity=Normal;logFile={Path.Combine(Directory.GetCurrentDirectory(), "..", "cat.log")};Parameter1", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
@@ -2165,9 +2143,7 @@ public void TestProcessFileLoggerSwitch4()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           2);
+                           distributedLoggerRecords);
             distributedLoggerRecords[0].ForwardingLoggerDescription.LoggerSwitchParameters.ShouldBe($"Parameter1;Parameter;;;Parameter;Parameter;logFile={Path.Combine(Directory.GetCurrentDirectory(), "msbuild.log")}", StringCompareShould.IgnoreCase); // "Expected parameter in logger to match parameter passed in"
         }
 
@@ -2185,9 +2161,7 @@ public void TestProcessFileLoggerSwitch5()
             MSBuildApp.ProcessDistributedFileLogger(
                            distributedFileLogger,
                            fileLoggerParameters,
-                           distributedLoggerRecords,
-                           loggers,
-                           1);
+                           distributedLoggerRecords);
             distributedLoggerRecords.Count.ShouldBe(0); // "Expected no distributed loggers to be attached"
             loggers.Count.ShouldBe(0); // "Expected no central loggers to be attached"
         }
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 7372c383379..f417ee15051 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -1704,27 +1704,27 @@ KdyÅ¾ se nastavÃ­ na MessageUponIsolationViolation (nebo jeho krÃ¡tkÃ½
       </trans-unit>
       <trans-unit id="TestSummary_BannerAndTotal">
         <source>Test summary: total: {0}</source>
-        <target state="new">Test summary: total: {0}</target>
+        <target state="translated">Souhrn testu: celkem: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Duration">
         <source>duration: {0}s</source>
-        <target state="new">duration: {0}s</target>
+        <target state="translated">doba trvÃ¡nÃ­: {0} s</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Failed">
         <source>failed: {0}</source>
-        <target state="new">failed: {0}</target>
+        <target state="translated">selhalo: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Skipped">
         <source>skipped: {0}</source>
-        <target state="new">skipped: {0}</target>
+        <target state="translated">pÅeskoÄeno: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Succeeded">
         <source>succeeded: {0}</source>
-        <target state="new">succeeded: {0}</target>
+        <target state="translated">ÃºspÄÅ¡nÃ©: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 8514e6959d2..50706b404dc 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -1692,27 +1692,27 @@ Dieses Protokollierungsformat ist standardmÃ¤Ãig aktiviert.
       </trans-unit>
       <trans-unit id="TestSummary_BannerAndTotal">
         <source>Test summary: total: {0}</source>
-        <target state="new">Test summary: total: {0}</target>
+        <target state="translated">Testzusammenfassung: insgesamt: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Duration">
         <source>duration: {0}s</source>
-        <target state="new">duration: {0}s</target>
+        <target state="translated">Dauer: {0} Sek.</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Failed">
         <source>failed: {0}</source>
-        <target state="new">failed: {0}</target>
+        <target state="translated">fehlgeschlagen: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Skipped">
         <source>skipped: {0}</source>
-        <target state="new">skipped: {0}</target>
+        <target state="translated">Ã¼bersprungen: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Succeeded">
         <source>succeeded: {0}</source>
-        <target state="new">succeeded: {0}</target>
+        <target state="translated">erfolgreich: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index c676c505e7a..e8e133d96d3 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -1698,27 +1698,27 @@ Esta marca es experimental y puede que no funcione segÃºn lo previsto.
       </trans-unit>
       <trans-unit id="TestSummary_BannerAndTotal">
         <source>Test summary: total: {0}</source>
-        <target state="new">Test summary: total: {0}</target>
+        <target state="translated">Resumen de pruebas: total: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Duration">
         <source>duration: {0}s</source>
-        <target state="new">duration: {0}s</target>
+        <target state="translated">duraciÃ³n: {0}Â s</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Failed">
         <source>failed: {0}</source>
-        <target state="new">failed: {0}</target>
+        <target state="translated">con errores: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Skipped">
         <source>skipped: {0}</source>
-        <target state="new">skipped: {0}</target>
+        <target state="translated">omitido: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Succeeded">
         <source>succeeded: {0}</source>
-        <target state="new">succeeded: {0}</target>
+        <target state="translated">correcto: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index f8a69c82bd7..bf502af7f50 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -1691,27 +1691,27 @@ Remarque : verbositÃ© des enregistreurs dâÃ©vÃ©nements de fichiers
       </trans-unit>
       <trans-unit id="TestSummary_BannerAndTotal">
         <source>Test summary: total: {0}</source>
-        <target state="new">Test summary: total: {0}</target>
+        <target state="translated">RÃ©capitulatif du testÂ : totalÂ : {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Duration">
         <source>duration: {0}s</source>
-        <target state="new">duration: {0}s</target>
+        <target state="translated">durÃ©eÂ : {0}s</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Failed">
         <source>failed: {0}</source>
-        <target state="new">failed: {0}</target>
+        <target state="translated">Ã©checÂ : {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Skipped">
         <source>skipped: {0}</source>
-        <target state="new">skipped: {0}</target>
+        <target state="translated">ignorÃ©Â : {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Succeeded">
         <source>succeeded: {0}</source>
-        <target state="new">succeeded: {0}</target>
+        <target state="translated">rÃ©ussiÂ : {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 3047992c2d9..9963ca29c49 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -1702,27 +1702,27 @@ Nota: livello di dettaglio dei logger di file
       </trans-unit>
       <trans-unit id="TestSummary_BannerAndTotal">
         <source>Test summary: total: {0}</source>
-        <target state="new">Test summary: total: {0}</target>
+        <target state="translated">Riepilogo test: totale: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Duration">
         <source>duration: {0}s</source>
-        <target state="new">duration: {0}s</target>
+        <target state="translated">durata: {0}s</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Failed">
         <source>failed: {0}</source>
-        <target state="new">failed: {0}</target>
+        <target state="translated">non riuscito: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Skipped">
         <source>skipped: {0}</source>
-        <target state="new">skipped: {0}</target>
+        <target state="translated">ignorato: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Succeeded">
         <source>succeeded: {0}</source>
-        <target state="new">succeeded: {0}</target>
+        <target state="translated">riuscito: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 1cf1e7ea303..e7954c3f91c 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -1691,27 +1691,27 @@
       </trans-unit>
       <trans-unit id="TestSummary_BannerAndTotal">
         <source>Test summary: total: {0}</source>
-        <target state="new">Test summary: total: {0}</target>
+        <target state="translated">ãã¹ãæ¦è¦: åè¨: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Duration">
         <source>duration: {0}s</source>
-        <target state="new">duration: {0}s</target>
+        <target state="translated">æé: {0} ç§</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Failed">
         <source>failed: {0}</source>
-        <target state="new">failed: {0}</target>
+        <target state="translated">å¤±ææ°: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Skipped">
         <source>skipped: {0}</source>
-        <target state="new">skipped: {0}</target>
+        <target state="translated">ã¹ã­ããæ¸ã¿æ°: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Succeeded">
         <source>succeeded: {0}</source>
-        <target state="new">succeeded: {0}</target>
+        <target state="translated">æåæ°: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 046f55d8df9..f995ca421bc 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -1691,27 +1691,27 @@
       </trans-unit>
       <trans-unit id="TestSummary_BannerAndTotal">
         <source>Test summary: total: {0}</source>
-        <target state="new">Test summary: total: {0}</target>
+        <target state="translated">íì¤í¸ ìì½: í©ê³: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Duration">
         <source>duration: {0}s</source>
-        <target state="new">duration: {0}s</target>
+        <target state="translated">ê¸°ê°: {0}ì´</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Failed">
         <source>failed: {0}</source>
-        <target state="new">failed: {0}</target>
+        <target state="translated">ì¤í¨: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Skipped">
         <source>skipped: {0}</source>
-        <target state="new">skipped: {0}</target>
+        <target state="translated">ê±´ëë: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Succeeded">
         <source>succeeded: {0}</source>
-        <target state="new">succeeded: {0}</target>
+        <target state="translated">ì±ê³µ: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index b537f9674ef..6d1956125cd 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -1702,27 +1702,27 @@ Ta flaga jest eksperymentalna i moÅ¼e nie dziaÅaÄ zgodnie z oczekiwaniami.
       </trans-unit>
       <trans-unit id="TestSummary_BannerAndTotal">
         <source>Test summary: total: {0}</source>
-        <target state="new">Test summary: total: {0}</target>
+        <target state="translated">Podsumowanie testu: ÅÄcznie: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Duration">
         <source>duration: {0}s</source>
-        <target state="new">duration: {0}s</target>
+        <target state="translated">czas trwania: {0}s</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Failed">
         <source>failed: {0}</source>
-        <target state="new">failed: {0}</target>
+        <target state="translated">niepowodzenie: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Skipped">
         <source>skipped: {0}</source>
-        <target state="new">skipped: {0}</target>
+        <target state="translated">pominiÄto: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Succeeded">
         <source>succeeded: {0}</source>
-        <target state="new">succeeded: {0}</target>
+        <target state="translated">zakoÅczone powodzeniem: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index bc8d315f35d..4e3266b9533 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -1692,27 +1692,27 @@ arquivo de resposta.
       </trans-unit>
       <trans-unit id="TestSummary_BannerAndTotal">
         <source>Test summary: total: {0}</source>
-        <target state="new">Test summary: total: {0}</target>
+        <target state="translated">ResumoÂ do teste: total: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Duration">
         <source>duration: {0}s</source>
-        <target state="new">duration: {0}s</target>
+        <target state="translated">duraÃ§Ã£o: {0}s</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Failed">
         <source>failed: {0}</source>
-        <target state="new">failed: {0}</target>
+        <target state="translated">falhou: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Skipped">
         <source>skipped: {0}</source>
-        <target state="new">skipped: {0}</target>
+        <target state="translated">ignorado: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Succeeded">
         <source>succeeded: {0}</source>
-        <target state="new">succeeded: {0}</target>
+        <target state="translated">bem-sucedido: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 932577e7171..2c27bb72d73 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -1690,27 +1690,27 @@
       </trans-unit>
       <trans-unit id="TestSummary_BannerAndTotal">
         <source>Test summary: total: {0}</source>
-        <target state="new">Test summary: total: {0}</target>
+        <target state="translated">Ð¡Ð²Ð¾Ð´ÐºÐ° ÑÐµÑÑÐ°: Ð²ÑÐµÐ³Ð¾: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Duration">
         <source>duration: {0}s</source>
-        <target state="new">duration: {0}s</target>
+        <target state="translated">Ð´Ð»Ð¸ÑÐµÐ»ÑÐ½Ð¾ÑÑÑ: {0}Â Ñ</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Failed">
         <source>failed: {0}</source>
-        <target state="new">failed: {0}</target>
+        <target state="translated">ÑÐ±Ð¾Ð¹: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Skipped">
         <source>skipped: {0}</source>
-        <target state="new">skipped: {0}</target>
+        <target state="translated">Ð¿ÑÐ¾Ð¿ÑÑÐµÐ½Ð¾: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Succeeded">
         <source>succeeded: {0}</source>
-        <target state="new">succeeded: {0}</target>
+        <target state="translated">ÑÑÐ¿ÐµÑÐ½Ð¾: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index bb6eff23b2a..86fc2093ac5 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -1695,27 +1695,27 @@
       </trans-unit>
       <trans-unit id="TestSummary_BannerAndTotal">
         <source>Test summary: total: {0}</source>
-        <target state="new">Test summary: total: {0}</target>
+        <target state="translated">Test Ã¶zeti: toplam: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Duration">
         <source>duration: {0}s</source>
-        <target state="new">duration: {0}s</target>
+        <target state="translated">sÃ¼re: {0}s</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Failed">
         <source>failed: {0}</source>
-        <target state="new">failed: {0}</target>
+        <target state="translated">baÅarÄ±sÄ±z: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Skipped">
         <source>skipped: {0}</source>
-        <target state="new">skipped: {0}</target>
+        <target state="translated">atlandÄ±: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Succeeded">
         <source>succeeded: {0}</source>
-        <target state="new">succeeded: {0}</target>
+        <target state="translated">baÅarÄ±lÄ±: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index e9ec6e93f0e..78c661b0857 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -1691,27 +1691,27 @@
       </trans-unit>
       <trans-unit id="TestSummary_BannerAndTotal">
         <source>Test summary: total: {0}</source>
-        <target state="new">Test summary: total: {0}</target>
+        <target state="translated">æµè¯æè¦: æ»è®¡: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Duration">
         <source>duration: {0}s</source>
-        <target state="new">duration: {0}s</target>
+        <target state="translated">æç»­æ¶é´: {0} ç§</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Failed">
         <source>failed: {0}</source>
-        <target state="new">failed: {0}</target>
+        <target state="translated">å¤±è´¥: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Skipped">
         <source>skipped: {0}</source>
-        <target state="new">skipped: {0}</target>
+        <target state="translated">å·²è·³è¿: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Succeeded">
         <source>succeeded: {0}</source>
-        <target state="new">succeeded: {0}</target>
+        <target state="translated">æå: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 26882d5ab4b..29c76948500 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -1691,27 +1691,27 @@
       </trans-unit>
       <trans-unit id="TestSummary_BannerAndTotal">
         <source>Test summary: total: {0}</source>
-        <target state="new">Test summary: total: {0}</target>
+        <target state="translated">æ¸¬è©¦æè¦: ç¸½è¨: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Duration">
         <source>duration: {0}s</source>
-        <target state="new">duration: {0}s</target>
+        <target state="translated">æçºæé: {0} ç§</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Failed">
         <source>failed: {0}</source>
-        <target state="new">failed: {0}</target>
+        <target state="translated">å¤±æ: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Skipped">
         <source>skipped: {0}</source>
-        <target state="new">skipped: {0}</target>
+        <target state="translated">å·²è·³é: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="TestSummary_Succeeded">
         <source>succeeded: {0}</source>
-        <target state="new">succeeded: {0}</target>
+        <target state="translated">æå: {0}</target>
         <note>{0} whole number</note>
       </trans-unit>
       <trans-unit id="UnexpectedParametersError">
diff --git a/src/MSBuild/TerminalLogger/TerminalLogger.cs b/src/MSBuild/TerminalLogger/TerminalLogger.cs
index 9dfb90a1750..71749e72717 100644
--- a/src/MSBuild/TerminalLogger/TerminalLogger.cs
+++ b/src/MSBuild/TerminalLogger/TerminalLogger.cs
@@ -62,6 +62,10 @@ public ProjectContext(BuildEventContext context)
     /// </summary>
     internal const string Indentation = "  ";
 
+    internal const string DoubleIndentation = $"{Indentation}{Indentation}";
+
+    internal const string TripleIndentation = $"{Indentation}{Indentation}{Indentation}";
+
     internal const TerminalColor TargetFrameworkColor = TerminalColor.Cyan;
 
     internal Func<StopwatchAbstraction>? CreateStopwatch = null;
@@ -646,7 +650,7 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
                     {
                         foreach (BuildMessage buildMessage in project.BuildMessages)
                         {
-                            Terminal.WriteLine($"{Indentation}{Indentation}{buildMessage.Message}");
+                            Terminal.WriteLine($"{DoubleIndentation}{buildMessage.Message}");
                         }
                     }
 
@@ -860,32 +864,22 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)
     private void WarningRaised(object sender, BuildWarningEventArgs e)
     {
         BuildEventContext? buildEventContext = e.BuildEventContext;
-        string message = FormatEventMessage(
-                category: AnsiCodes.Colorize("warning", TerminalColor.Yellow),
-                subcategory: e.Subcategory,
-                message: e.Message,
-                code: AnsiCodes.Colorize(e.Code, TerminalColor.Yellow),
-                file: HighlightFileName(e.File),
-                lineNumber: e.LineNumber,
-                endLineNumber: e.EndLineNumber,
-                columnNumber: e.ColumnNumber,
-                endColumnNumber: e.EndColumnNumber);
 
         if (buildEventContext is not null
             && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project)
             && Verbosity > LoggerVerbosity.Quiet)
         {
-            if (IsImmediateMessage(message))
+            if (!String.IsNullOrEmpty(e.Message) && IsImmediateMessage(e.Message!))
             {
-                RenderImmediateMessage(message);
+                RenderImmediateMessage(FormatWarningMessage(e, Indentation));
             }
 
-            project.AddBuildMessage(MessageSeverity.Warning, message);
+            project.AddBuildMessage(MessageSeverity.Warning, FormatWarningMessage(e, TripleIndentation));
         }
         else
         {
             // It is necessary to display warning messages reported by MSBuild, even if it's not tracked in _projects collection or the verbosity is Quiet.
-            RenderImmediateMessage(message);
+            RenderImmediateMessage(FormatWarningMessage(e, Indentation));
             _buildWarningsCount++;
         }
     }
@@ -908,27 +902,17 @@ private bool IsImmediateMessage(string message) =>
     private void ErrorRaised(object sender, BuildErrorEventArgs e)
     {
         BuildEventContext? buildEventContext = e.BuildEventContext;
-        string message = FormatEventMessage(
-                category: AnsiCodes.Colorize("error", TerminalColor.Red),
-                subcategory: e.Subcategory,
-                message: e.Message,
-                code: AnsiCodes.Colorize(e.Code, TerminalColor.Red),
-                file: HighlightFileName(e.File),
-                lineNumber: e.LineNumber,
-                endLineNumber: e.EndLineNumber,
-                columnNumber: e.ColumnNumber,
-                endColumnNumber: e.EndColumnNumber);
-
+        
         if (buildEventContext is not null
             && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project)
             && Verbosity > LoggerVerbosity.Quiet)
         {
-            project.AddBuildMessage(MessageSeverity.Error, message);
+            project.AddBuildMessage(MessageSeverity.Error, FormatErrorMessage(e, TripleIndentation));
         }
         else
         {
             // It is necessary to display error messages reported by MSBuild, even if it's not tracked in _projects collection or the verbosity is Quiet.
-            RenderImmediateMessage(message);
+            RenderImmediateMessage(FormatErrorMessage(e, Indentation));
             _buildErrorsCount++;
         }
     }
@@ -1072,6 +1056,36 @@ private int NodeIndexForContext(BuildEventContext context)
             : path;
     }
 
+    private string FormatWarningMessage(BuildWarningEventArgs e, string indent)
+    {
+        return FormatEventMessage(
+                category: AnsiCodes.Colorize("warning", TerminalColor.Yellow),
+                subcategory: e.Subcategory,
+                message: e.Message,
+                code: AnsiCodes.Colorize(e.Code, TerminalColor.Yellow),
+                file: HighlightFileName(e.File),
+                lineNumber: e.LineNumber,
+                endLineNumber: e.EndLineNumber,
+                columnNumber: e.ColumnNumber,
+                endColumnNumber: e.EndColumnNumber,
+                indent);
+    }
+
+    private string FormatErrorMessage(BuildErrorEventArgs e, string indent)
+    {
+        return FormatEventMessage(
+                category: AnsiCodes.Colorize("error", TerminalColor.Red),
+                subcategory: e.Subcategory,
+                message: e.Message,
+                code: AnsiCodes.Colorize(e.Code, TerminalColor.Red),
+                file: HighlightFileName(e.File),
+                lineNumber: e.LineNumber,
+                endLineNumber: e.EndLineNumber,
+                columnNumber: e.ColumnNumber,
+                endColumnNumber: e.EndColumnNumber,
+                indent);
+    }
+
     private string FormatEventMessage(
             string category,
             string subcategory,
@@ -1081,7 +1095,8 @@ private string FormatEventMessage(
             int lineNumber,
             int endLineNumber,
             int columnNumber,
-            int endColumnNumber)
+            int endColumnNumber,
+            string indent)
     {
         message ??= string.Empty;
         StringBuilder builder = new(128);
@@ -1135,7 +1150,7 @@ private string FormatEventMessage(
         // render multi-line message in a special way
         if (message.IndexOf('\n') >= 0)
         {
-            const string indent = $"{Indentation}{Indentation}{Indentation}";
+            // Place the multiline message under the project in case of minimal and higher verbosity.
             string[] lines = message.Split(newLineStrings, StringSplitOptions.None);
 
             foreach (string line in lines)
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 3b993859747..9fa6956ae03 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -34,8 +34,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
-using static Microsoft.Build.CommandLine.MSBuildApp;
 using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
 using ConsoleLogger = Microsoft.Build.Logging.ConsoleLogger;
 using FileLogger = Microsoft.Build.Logging.FileLogger;
@@ -662,6 +660,9 @@ public static ExitType Execute(
             ExitType exitType = ExitType.Success;
 
             ConsoleCancelEventHandler cancelHandler = Console_CancelKeyPress;
+
+            TextWriter preprocessWriter = null;
+            TextWriter targetsWriter = null;
             try
             {
 #if FEATURE_GET_COMMANDLINE
@@ -701,8 +702,6 @@ public static ExitType Execute(
 #else
                 bool enableNodeReuse = false;
 #endif
-                TextWriter preprocessWriter = null;
-                TextWriter targetsWriter = null;
                 bool detailedSummary = false;
                 ISet<string> warningsAsErrors = null;
                 ISet<string> warningsNotAsErrors = null;
@@ -826,8 +825,18 @@ public static ExitType Execute(
                             using (ProjectCollection collection = new(globalProperties, loggers, ToolsetDefinitionLocations.Default))
                             {
                                 Project project = collection.LoadProject(projectFile, globalProperties, toolsVersion);
-                                TextWriter output = getResultOutputFile.Length > 0 ? new StreamWriter(getResultOutputFile) : Console.Out;
-                                exitType = OutputPropertiesAfterEvaluation(getProperty, getItem, project, output);
+
+                                if (getResultOutputFile.Length == 0)
+                                {
+                                    exitType = OutputPropertiesAfterEvaluation(getProperty, getItem, project, Console.Out);
+                                }
+                                else
+                                {
+                                    using (var streamWriter = new StreamWriter(getResultOutputFile))
+                                    {
+                                        exitType = OutputPropertiesAfterEvaluation(getProperty, getItem, project, streamWriter);
+                                    }
+                                }
                                 collection.LogBuildFinishedEvent(exitType == ExitType.Success);
                             }
                         }
@@ -890,8 +899,17 @@ public static ExitType Execute(
 
                     if (outputPropertiesItemsOrTargetResults && targets?.Length > 0 && result is not null)
                     {
-                        TextWriter outputStream = getResultOutputFile.Length > 0 ? new StreamWriter(getResultOutputFile) : Console.Out;
-                        exitType = OutputBuildInformationInJson(result, getProperty, getItem, getTargetResult, loggers, exitType, outputStream);
+                        if (getResultOutputFile.Length == 0)
+                        {
+                            exitType = OutputBuildInformationInJson(result, getProperty, getItem, getTargetResult, loggers, exitType, Console.Out);
+                        }
+                        else
+                        {
+                            using (var streamWriter = new StreamWriter(getResultOutputFile))
+                            {
+                                exitType = OutputBuildInformationInJson(result, getProperty, getItem, getTargetResult, loggers, exitType, streamWriter);
+                            }
+                        }
                     }
 
                     if (!string.IsNullOrEmpty(timerOutputFilename))
@@ -1035,6 +1053,9 @@ public static ExitType Execute(
 
                 NativeMethodsShared.RestoreConsoleMode(s_originalConsoleMode);
 
+                preprocessWriter?.Dispose();
+                targetsWriter?.Dispose();
+
 #if FEATURE_GET_COMMANDLINE
                 MSBuildEventSource.Log.MSBuildExeStop(commandLine);
 #else
@@ -3780,9 +3801,9 @@ private static ILogger[] ProcessLoggingSwitches(
                 ProcessConsoleLoggerSwitch(noConsoleLogger, consoleLoggerParameters, distributedLoggerRecords, verbosity, cpuCount, loggers);
             }
 
-            ProcessDistributedFileLogger(distributedFileLogger, fileLoggerParameters, distributedLoggerRecords, loggers, cpuCount);
+            ProcessDistributedFileLogger(distributedFileLogger, fileLoggerParameters, distributedLoggerRecords);
 
-            ProcessFileLoggers(groupedFileLoggerParameters, distributedLoggerRecords, verbosity, cpuCount, loggers);
+            ProcessFileLoggers(groupedFileLoggerParameters, distributedLoggerRecords, cpuCount, loggers);
 
             verbosity = outVerbosity;
 
@@ -3824,7 +3845,7 @@ internal static string AggregateParameters(string anyPrefixingParameter, string[
         /// Add a file logger with the appropriate parameters to the loggers list for each
         /// non-empty set of file logger parameters provided.
         /// </summary>
-        private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, List<DistributedLoggerRecord> distributedLoggerRecords, LoggerVerbosity verbosity, int cpuCount, List<ILogger> loggers)
+        private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, List<DistributedLoggerRecord> distributedLoggerRecords, int cpuCount, List<ILogger> loggers)
         {
             for (int i = 0; i < groupedFileLoggerParameters.Length; i++)
             {
@@ -4017,9 +4038,7 @@ private static DistributedLoggerRecord CreateForwardingLoggerRecord(ILogger logg
         internal static void ProcessDistributedFileLogger(
             bool distributedFileLogger,
             string[] fileLoggerParameters,
-            List<DistributedLoggerRecord> distributedLoggerRecords,
-            List<ILogger> loggers,
-            int cpuCount)
+            List<DistributedLoggerRecord> distributedLoggerRecords)
         {
             if (distributedFileLogger)
             {
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 6c12448b1ad..8783318b2e5 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Diagnostics.CodeAnalysis;
 #if CLR2COMPATIBILITY
 using Microsoft.Build.Shared.Concurrent;
 #else
@@ -14,6 +15,7 @@
 using Microsoft.Build.Shared;
 #if FEATURE_SECURITY_PERMISSIONS || FEATURE_PIPE_SECURITY
 using System.Security.AccessControl;
+
 #endif
 #if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
 using System.Security.Principal;
@@ -29,6 +31,7 @@ namespace Microsoft.Build.BackEnd
     /// <summary>
     /// This is an implementation of INodeEndpoint for the out-of-proc nodes.  It acts only as a client.
     /// </summary>
+    [SuppressMessage("Microsoft.Reliability", "CA2000:Dispose objects before losing scope", Justification = "It is expected to keep the stream open for the process lifetime")]
     internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
     {
         #region Private Data
diff --git a/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
index acea1b5a025..b63fa1e4e9e 100644
--- a/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
+++ b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
@@ -1,4 +1,4 @@
-ï»¿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
        a .props file that prevents building the project from doing much of anything. -->
@@ -14,6 +14,7 @@
     <IsTestProject>true</IsTestProject>
     <IsLibraryTestProject>true</IsLibraryTestProject>
     <DefineConstants>$(DefineConstants);NET35_UNITTEST</DefineConstants>
+    <NoWarn>$(NoWarn);CA2000</NoWarn>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/Tasks/AppConfig/AppConfig.cs b/src/Tasks/AppConfig/AppConfig.cs
index 7f50e75cc29..0e746a573e7 100644
--- a/src/Tasks/AppConfig/AppConfig.cs
+++ b/src/Tasks/AppConfig/AppConfig.cs
@@ -34,7 +34,9 @@ internal void Load(string appConfigFilePath)
                 // Need a filestream as the XmlReader doesn't support nonstandard unicode characters in path.
                 // No need to dispose - as 'CloseInput' was passed to XmlReaderSettings
                 FileStream fs = File.OpenRead(appConfigFilePath);
+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because the reader is disposed in the finally block
                 reader = XmlReader.Create(fs, readerSettings);
+#pragma warning restore CA2000 // Dispose objects before losing scope
                 Read(reader);
             }
             catch (XmlException e)
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index 0b296e958ca..76e17988b08 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -225,7 +225,8 @@ public BuildResults Build(BuildSettings settings)
                     var fi = new FileInfo(de.Value);
                     using (FileStream fs = fi.OpenRead())
                     {
-                        data = new StreamReader(fs).ReadToEnd();
+                        using var sr = new StreamReader(fs);
+                        data = sr.ReadToEnd();
                     }
 
                     resourceUpdater.AddStringResource(44, de.Key, data);
@@ -835,7 +836,7 @@ private XmlDocument LoadAndValidateXmlDocument(string filePath, bool validateFil
                     if (validate)
                     {
 #pragma warning disable 618 // Using XmlValidatingReader. TODO: We need to switch to using XmlReader.Create() with validation.
-                        var validatingReader = new XmlValidatingReader(xmlReader);
+                        using var validatingReader = new XmlValidatingReader(xmlReader);
 #pragma warning restore 618
                         var xrSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = true };
                         FileStream fs = File.OpenRead(schemaPath);
@@ -1657,7 +1658,7 @@ private static string GetFileHash(string filePath)
             // pre-signed anwyay; this is a fallback in case we ever encounter a bootstrapper that is
             // not signed.
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-            System.Security.Cryptography.SHA256 sha = System.Security.Cryptography.SHA256.Create(
+            using System.Security.Cryptography.SHA256 sha = System.Security.Cryptography.SHA256.Create(
 #if FEATURE_CRYPTOGRAPHIC_FACTORY_ALGORITHM_NAMES
                 "System.Security.Cryptography.SHA256CryptoServiceProvider"
 #endif
@@ -2033,7 +2034,8 @@ private static void DumpXmlToFile(XmlNode node, string fileName)
                     {
                         xmlwriter.Formatting = Formatting.Indented;
                         xmlwriter.Indentation = 4;
-                        xmlwriter.WriteNode(new XmlNodeReader(node), true);
+                        using var xmlReader = new XmlNodeReader(node);
+                        xmlwriter.WriteNode(xmlReader, true);
                     }
                 }
                 catch (IOException)
@@ -2194,7 +2196,7 @@ private static string GetPublicKeyOfFile(string fileSource)
             {
                 try
                 {
-                    var cert = new X509Certificate(fileSource);
+                    using var cert = new X509Certificate(fileSource);
                     string publicKey = cert.GetPublicKeyString();
                     return publicKey;
                 }
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index f863c969cbf..e1923c87f9d 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -738,7 +738,7 @@ private Assembly CompileInMemoryAssembly()
 
                 // Horrible code dom / compilation declarations
                 var codeBuilder = new StringBuilder();
-                var writer = new StringWriter(codeBuilder, CultureInfo.CurrentCulture);
+                using var writer = new StringWriter(codeBuilder, CultureInfo.CurrentCulture);
                 var codeGeneratorOptions = new CodeGeneratorOptions
                 {
                     BlankLinesBetweenMembers = true,
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index efe54f514ca..71dc72e4c91 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -146,6 +146,7 @@ private async Task<bool> ExecuteAsync()
         private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
         {
             // The main reason to use HttpClient vs WebClient is because we can pass a message handler for unit tests to mock
+#pragma warning disable CA2000 // Dispose objects before losing scope because HttpClientHandler is disposed by HTTPClient.Dispose()
             using (var client = new HttpClient(HttpMessageHandler ?? new HttpClientHandler(), disposeHandler: true) { Timeout = TimeSpan.FromMilliseconds(Timeout) })
             {
                 // Only get the response without downloading the file so we can determine if the file is already up-to-date
@@ -226,6 +227,7 @@ private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
                     }
                 }
             }
+#pragma warning restore CA2000 // Dispose objects before losing scope
         }
 
         /// <summary>
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 572a19ea3bb..af988ec51d3 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -974,8 +974,8 @@ private bool IsDangerous(String filename)
                 // XML files are only dangerous if there are unrecognized objects in them
                 dangerous = false;
 
-                FileStream stream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read);
-                XmlTextReader reader = new XmlTextReader(stream);
+                using FileStream stream = new FileStream(filename, FileMode.Open, FileAccess.Read, FileShare.Read);
+                using XmlTextReader reader = new XmlTextReader(stream);
                 reader.DtdProcessing = DtdProcessing.Ignore;
                 reader.XmlResolver = null;
                 try
@@ -1622,14 +1622,13 @@ private bool NeedToRebuildSourceFile(string sourceFilePath, DateTime sourceTime,
         private void GetStronglyTypedResourceToProcess(ref List<ITaskItem> inputsToProcess, ref List<ITaskItem> outputsToProcess)
         {
             bool needToRebuildSTR = false;
+            CodeDomProvider provider = null;
 
             // The resource file isn't out of date. So check whether the STR class file is.
             try
             {
                 if (StronglyTypedFileName == null)
                 {
-                    CodeDomProvider provider = null;
-
                     if (ProcessResourceFiles.TryCreateCodeDomProvider(Log, StronglyTypedLanguage, out provider))
                     {
                         StronglyTypedFileName = ProcessResourceFiles.GenerateDefaultStronglyTypedFilename(provider, OutputResources[0].ItemSpec);
@@ -1645,6 +1644,10 @@ private void GetStronglyTypedResourceToProcess(ref List<ITaskItem> inputsToProce
                 _stronglyTypedResourceSuccessfullyCreated = false;
                 return;
             }
+            finally
+            {
+                provider?.Dispose();
+            }
 
             // Now we have the filename, check if it's up to date
             DateTime sourceTime = NativeMethodsShared.GetLastWriteFileUtcTime(Sources[0].ItemSpec);
@@ -2153,11 +2156,18 @@ private void RecordFilesWritten()
             {
                 if (StronglyTypedFileName == null)
                 {
-                    CodeDomProvider provider;
-                    if (ProcessResourceFiles.TryCreateCodeDomProvider(Log, StronglyTypedLanguage, out provider))
+                    CodeDomProvider provider = null;
+                    try
                     {
-                        StronglyTypedFileName = ProcessResourceFiles.GenerateDefaultStronglyTypedFilename(
-                            provider, OutputResources[0].ItemSpec);
+                        if (ProcessResourceFiles.TryCreateCodeDomProvider(Log, StronglyTypedLanguage, out provider))
+                        {
+                            StronglyTypedFileName = ProcessResourceFiles.GenerateDefaultStronglyTypedFilename(
+                                provider, OutputResources[0].ItemSpec);
+                        }
+                    }
+                    finally
+                    {
+                        provider?.Dispose();
                     }
                 }
 
@@ -3412,61 +3422,69 @@ private bool HaveSystemResourcesExtensionsReference
         /// <param name="sourceFile">The generated strongly typed filename</param>
         private void CreateStronglyTypedResources(ReaderInfo reader, String outFile, String inputFileName, out String sourceFile)
         {
-            CodeDomProvider provider;
-            if (!TryCreateCodeDomProvider(_logger, _stronglyTypedLanguage, out provider))
-            {
-                sourceFile = null;
-                return;
-            }
-
-            // Default the class name if we need to
-            if (_stronglyTypedClassName == null)
-            {
-                _stronglyTypedClassName = Path.GetFileNameWithoutExtension(outFile);
-            }
-
-            // Default the filename if we need to
-            if (_stronglyTypedFilename == null)
+            CodeDomProvider provider = null;
+            try
             {
-                _stronglyTypedFilename = GenerateDefaultStronglyTypedFilename(provider, outFile);
-            }
-            sourceFile = this.StronglyTypedFilename;
+                if (!TryCreateCodeDomProvider(_logger, _stronglyTypedLanguage, out provider))
+                {
+                    sourceFile = null;
+                    return;
+                }
 
-            _logger.LogMessageFromResources("GenerateResource.CreatingSTR", _stronglyTypedFilename);
 
-            // Generate the STR class
-            String[] errors;
-            bool generateInternalClass = !_stronglyTypedClassIsPublic;
-            // StronglyTypedResourcesNamespace can be null and this is ok.
-            // If it is null then the default namespace (=stronglyTypedNamespace) is used.
-            CodeCompileUnit ccu = StronglyTypedResourceBuilder.Create(
-                    reader.resourcesHashTable,
-                    _stronglyTypedClassName,
-                    _stronglyTypedNamespace,
-                    _stronglyTypedResourcesNamespace,
-                    provider,
-                    generateInternalClass,
-                    out errors);
+                // Default the class name if we need to
+                if (_stronglyTypedClassName == null)
+                {
+                    _stronglyTypedClassName = Path.GetFileNameWithoutExtension(outFile);
+                }
 
-            CodeGeneratorOptions codeGenOptions = new CodeGeneratorOptions();
-            using (TextWriter output = new StreamWriter(_stronglyTypedFilename))
-            {
-                provider.GenerateCodeFromCompileUnit(ccu, output, codeGenOptions);
-            }
+                // Default the filename if we need to
+                if (_stronglyTypedFilename == null)
+                {
+                    _stronglyTypedFilename = GenerateDefaultStronglyTypedFilename(provider, outFile);
+                }
+                sourceFile = this.StronglyTypedFilename;
+
+                _logger.LogMessageFromResources("GenerateResource.CreatingSTR", _stronglyTypedFilename);
+
+                // Generate the STR class
+                String[] errors;
+                bool generateInternalClass = !_stronglyTypedClassIsPublic;
+                // StronglyTypedResourcesNamespace can be null and this is ok.
+                // If it is null then the default namespace (=stronglyTypedNamespace) is used.
+                CodeCompileUnit ccu = StronglyTypedResourceBuilder.Create(
+                        reader.resourcesHashTable,
+                        _stronglyTypedClassName,
+                        _stronglyTypedNamespace,
+                        _stronglyTypedResourcesNamespace,
+                        provider,
+                        generateInternalClass,
+                        out errors);
+
+                CodeGeneratorOptions codeGenOptions = new CodeGeneratorOptions();
+                using (TextWriter output = new StreamWriter(_stronglyTypedFilename))
+                {
+                    provider.GenerateCodeFromCompileUnit(ccu, output, codeGenOptions);
+                }
 
-            if (errors.Length > 0)
-            {
-                _logger.LogErrorWithCodeFromResources("GenerateResource.ErrorFromCodeDom", inputFileName);
-                foreach (String error in errors)
+                if (errors.Length > 0)
+                {
+                    _logger.LogErrorWithCodeFromResources("GenerateResource.ErrorFromCodeDom", inputFileName);
+                    foreach (String error in errors)
+                    {
+                        _logger.LogErrorWithCodeFromResources("GenerateResource.CodeDomError", error);
+                    }
+                }
+                else
                 {
-                    _logger.LogErrorWithCodeFromResources("GenerateResource.CodeDomError", error);
+                    // No errors, and no exceptions - we presumably did create the STR class file
+                    // and it should get added to FilesWritten. So set a flag to indicate this.
+                    _stronglyTypedResourceSuccessfullyCreated = true;
                 }
             }
-            else
+            finally
             {
-                // No errors, and no exceptions - we presumably did create the STR class file
-                // and it should get added to FilesWritten. So set a flag to indicate this.
-                _stronglyTypedResourceSuccessfullyCreated = true;
+                provider?.Dispose();
             }
         }
 
@@ -3542,15 +3560,16 @@ private void ReadResources(ReaderInfo readerInfo, IResourceReader reader, String
 #endif // FEATURE_RESXREADER_LIVEDESERIALIZATION
 
         /// <summary>
-        /// Read resources from a text format file
+        /// Read resources from a text format file.
         /// </summary>
-        /// <param name="reader">Reader info</param>
-        /// <param name="fileName">Input resources filename</param>
+        /// <param name="reader">Reader info.</param>
+        /// <param name="fileName">Input resources filename.</param>
         private void ReadTextResources(ReaderInfo reader, String fileName)
         {
             // Check for byte order marks in the beginning of the input file, but
             // default to UTF-8.
-            using (LineNumberStreamReader sr = new LineNumberStreamReader(fileName, new UTF8Encoding(true), true))
+            using var fs = File.Open(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
+            using (LineNumberStreamReader sr = new LineNumberStreamReader(fs, new UTF8Encoding(true), true))
             {
                 StringBuilder name = new StringBuilder(255);
                 StringBuilder value = new StringBuilder(2048);
@@ -3876,8 +3895,8 @@ internal sealed class LineNumberStreamReader : StreamReader
             private int _lineNumber;
             private int _col;
 
-            internal LineNumberStreamReader(String fileName, Encoding encoding, bool detectEncoding)
-                : base(File.Open(fileName, FileMode.Open, FileAccess.Read, FileShare.Read), encoding, detectEncoding)
+            internal LineNumberStreamReader(Stream fileStream, Encoding encoding, bool detectEncoding)
+                : base(fileStream, encoding, detectEncoding)
             {
                 _lineNumber = 1;
                 _col = 0;
diff --git a/src/Tasks/GetInstalledSDKLocations.cs b/src/Tasks/GetInstalledSDKLocations.cs
index 011ce919725..e1d4bb966e7 100644
--- a/src/Tasks/GetInstalledSDKLocations.cs
+++ b/src/Tasks/GetInstalledSDKLocations.cs
@@ -194,7 +194,9 @@ public override bool Execute()
                 object staticCacheDisposer = buildEngine4.GetRegisteredTaskObject(StaticSDKCacheKey, RegisteredTaskObjectLifetime.Build);
                 if (staticCacheDisposer == null)
                 {
+#pragma warning disable CA2000 // Dispose objects before losing scope is suppressed because the object is registered with the engine and disposed of at the end of the build.
                     BuildCacheDisposeWrapper staticDisposer = new BuildCacheDisposeWrapper(ToolLocationHelper.ClearSDKStaticCache);
+#pragma warning restore CA2000 // Dispose objects before losing scope
                     buildEngine4.RegisterTaskObject(StaticSDKCacheKey, staticDisposer, RegisteredTaskObjectLifetime.Build, allowEarlyCollection: false);
                 }
             }
diff --git a/src/Tasks/ManifestUtil/ManifestFormatter.cs b/src/Tasks/ManifestUtil/ManifestFormatter.cs
index a4295b3da34..7171fff8e71 100644
--- a/src/Tasks/ManifestUtil/ManifestFormatter.cs
+++ b/src/Tasks/ManifestUtil/ManifestFormatter.cs
@@ -17,7 +17,7 @@ public static Stream Format(Stream input)
         {
             int t1 = Environment.TickCount;
 
-            var r = new XmlTextReader(input)
+            using var r = new XmlTextReader(input)
             {
                 DtdProcessing = DtdProcessing.Ignore,
                 WhitespaceHandling = WhitespaceHandling.None
@@ -25,7 +25,7 @@ public static Stream Format(Stream input)
             XmlNamespaceManager nsmgr = XmlNamespaces.GetNamespaceManager(r.NameTable);
 
             var m = new MemoryStream();
-            var w = new XmlTextWriter(m, Encoding.UTF8)
+            using var w = new XmlTextWriter(m, Encoding.UTF8)
             {
                 Formatting = Formatting.Indented,
                 Indentation = 2
diff --git a/src/Tasks/ManifestUtil/ManifestReader.cs b/src/Tasks/ManifestUtil/ManifestReader.cs
index fc4afee3919..013388c22d7 100644
--- a/src/Tasks/ManifestUtil/ManifestReader.cs
+++ b/src/Tasks/ManifestUtil/ManifestReader.cs
@@ -224,8 +224,8 @@ public static Manifest ReadManifest(string manifestType, Stream input, bool pres
         private static Manifest Deserialize(Stream s)
         {
             s.Position = 0;
-            var r = new XmlTextReader(s) { DtdProcessing = DtdProcessing.Ignore };
-
+            var settings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore, CloseInput = false };
+            using XmlReader r = XmlReader.Create(s, settings);
             do
             {
                 r.Read();
diff --git a/src/Tasks/ManifestUtil/ManifestWriter.cs b/src/Tasks/ManifestUtil/ManifestWriter.cs
index 562cc1f1c0f..8da08fbacde 100644
--- a/src/Tasks/ManifestUtil/ManifestWriter.cs
+++ b/src/Tasks/ManifestUtil/ManifestWriter.cs
@@ -24,7 +24,7 @@ private static Stream Serialize(Manifest manifest)
             manifest.OnBeforeSave();
             var m = new MemoryStream();
             var s = new XmlSerializer(manifest.GetType());
-            var w = new StreamWriter(m);
+            using var w = new StreamWriter(m, System.Text.Encoding.UTF8, bufferSize: 1024, leaveOpen: true);
 
             int t1 = Environment.TickCount;
             s.Serialize(w, manifest);
@@ -32,6 +32,7 @@ private static Stream Serialize(Manifest manifest)
 
             w.Flush();
             m.Position = 0;
+
             return m;
         }
 
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 9951399b793..b49395de0d6 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -205,7 +205,7 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkName fn)
                         {
                             try
                             {
-                                var sr = new StreamReader(fs);
+                                using var sr = new StreamReader(fs, Encoding.UTF8, detectEncodingFromByteOrderMarks: true, 1024, leaveOpen: true);
                                 string data = sr.ReadToEnd();
                                 if (!string.IsNullOrEmpty(data))
                                 {
@@ -610,7 +610,7 @@ public static void SignFile(string certThumbprint,
         [SupportedOSPlatform("windows")]
         public static void SignFile(string certPath, SecureString certPassword, Uri timestampUrl, string path)
         {
-            X509Certificate2 cert = new X509Certificate2(certPath, certPassword, X509KeyStorageFlags.PersistKeySet);
+            using X509Certificate2 cert = new X509Certificate2(certPath, certPassword, X509KeyStorageFlags.PersistKeySet);
             SignFile(cert, timestampUrl, path);
         }
 
@@ -705,8 +705,9 @@ private static void SignFileInternal(X509Certificate2 cert,
                         CmiManifestSigner2 signer;
                         if (useSha256 && rsa is RSACryptoServiceProvider rsacsp)
                         {
-                            RSACryptoServiceProvider csp = SignedCmiManifest2.GetFixedRSACryptoServiceProvider(rsacsp, useSha256);
-                            signer = new CmiManifestSigner2(csp, cert, useSha256);
+#pragma warning disable CA2000 // Dispose objects before losing scope because CmiManifestSigner2 will dispose the RSACryptoServiceProvider
+                            signer = new CmiManifestSigner2(SignedCmiManifest2.GetFixedRSACryptoServiceProvider(rsacsp, useSha256), cert, useSha256);
+#pragma warning restore CA2000 // Dispose objects before losing scope
                         }
                         else
                         {
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index ecc02c975a7..8776175eddc 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -534,7 +534,8 @@ public override string ToString()
             var m = new MemoryStream();
             Write(m);
             m.Position = 0;
-            var r = new StreamReader(m);
+            using var r = new StreamReader(m);
+
             return r.ReadToEnd();
         }
 
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index 4d6b6ca09ea..f8bd53d1a44 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -209,7 +209,7 @@ public static Version GetTargetFrameworkVersion(string targetFramework)
         public static string GetEmbeddedResourceString(string name)
         {
             Stream s = GetEmbeddedResourceStream(name);
-            StreamReader r = new StreamReader(s);
+            using StreamReader r = new StreamReader(s);
             return r.ReadToEnd();
         }
 
@@ -238,10 +238,10 @@ private static void GetFileInfoImpl(string path, string targetFrameWorkVersion,
             length = fi.Length;
 
             Stream s = null;
+            HashAlgorithm hashAlg = null;
             try
             {
                 s = fi.OpenRead();
-                HashAlgorithm hashAlg;
 
                 if (string.IsNullOrEmpty(targetFrameWorkVersion) || CompareFrameworkVersions(targetFrameWorkVersion, Constants.TargetFrameworkVersion40) <= 0)
                 {
@@ -269,6 +269,7 @@ private static void GetFileInfoImpl(string path, string targetFrameWorkVersion,
             finally
             {
                 s?.Close();
+                hashAlg?.Dispose();
             }
         }
 
@@ -473,7 +474,7 @@ public static void WriteFile(string path, string s)
 
         public static void WriteFile(string path, Stream s)
         {
-            StreamReader r = new StreamReader(s);
+            using StreamReader r = new StreamReader(s);
             WriteFile(path, r.ReadToEnd());
         }
 
@@ -520,7 +521,7 @@ public static void WriteLogFile(string filename, Stream s)
             }
 
             string path = Path.Combine(logPath, filename);
-            StreamReader r = new StreamReader(s);
+            using var r = new StreamReader(s, Encoding.UTF8, detectEncodingFromByteOrderMarks: true, 1024, leaveOpen: true);
             string text = r.ReadToEnd();
             try
             {
@@ -538,6 +539,7 @@ public static void WriteLogFile(string filename, Stream s)
             catch (SecurityException)
             {
             }
+
             s.Position = 0;
         }
 
diff --git a/src/Tasks/ManifestUtil/XmlUtil.cs b/src/Tasks/ManifestUtil/XmlUtil.cs
index ca35d8090a0..709aaa1e9e3 100644
--- a/src/Tasks/ManifestUtil/XmlUtil.cs
+++ b/src/Tasks/ManifestUtil/XmlUtil.cs
@@ -114,8 +114,8 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
                     }
                 }
 
-                var m = new MemoryStream();
-                var w = new XmlTextWriter(m, Encoding.UTF8);
+                using var m = new MemoryStream();
+                using var w = new XmlTextWriter(m, Encoding.UTF8);
                 w.WriteStartDocument();
 
                 int t5 = Environment.TickCount;
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index dfc7d8e46c2..1e98ca0ec72 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -511,7 +511,8 @@ private static void ReplacePublicKeyToken(XmlDocument manifestDom, AsymmetricAlg
 
             if (snKey is RSACryptoServiceProvider rsacsp)
             {
-                cspPublicKeyBlob = (GetFixedRSACryptoServiceProvider(rsacsp, useSha256)).ExportCspBlob(false);
+                using var cryptoProvider = GetFixedRSACryptoServiceProvider(rsacsp, useSha256);
+                cspPublicKeyBlob = cryptoProvider.ExportCspBlob(false);
                 if (cspPublicKeyBlob == null || cspPublicKeyBlob.Length == 0)
                 {
                     throw new CryptographicException(Win32.NTE_BAD_KEY);
diff --git a/src/Tasks/ResGen.cs b/src/Tasks/ResGen.cs
index 5bce63d6e60..614ed571685 100644
--- a/src/Tasks/ResGen.cs
+++ b/src/Tasks/ResGen.cs
@@ -289,10 +289,11 @@ public override bool Execute()
                     // Default the filename if we need to - regardless of whether the STR was successfully generated
                     if (StronglyTypedFileName == null)
                     {
-                        CodeDomProvider provider;
+                        CodeDomProvider provider = null;
                         try
                         {
                             provider = CodeDomProvider.CreateProvider(StronglyTypedLanguage);
+                            StronglyTypedFileName = ProcessResourceFiles.GenerateDefaultStronglyTypedFilename(provider, outputFile.ItemSpec);
                         }
                         catch (System.Configuration.ConfigurationException)
                         {
@@ -306,8 +307,10 @@ public override bool Execute()
                             // logged an appropriate error.
                             return false;
                         }
-
-                        StronglyTypedFileName = ProcessResourceFiles.GenerateDefaultStronglyTypedFilename(provider, outputFile.ItemSpec);
+                        finally
+                        {
+                            provider?.Dispose();
+                        }
                     }
                 }
 
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index deade89479b..2fcfbe94245 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -216,7 +216,7 @@ private bool ResolveManifestKey()
                     {
                         bool imported = false;
                         // first try it with no password
-                        var cert = new X509Certificate2();
+                        using var cert = new X509Certificate2();
                         var personalStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
                         try
                         {
diff --git a/src/Tasks/ResourceHandling/FileStreamResource.cs b/src/Tasks/ResourceHandling/FileStreamResource.cs
index ea29bf5b772..39117f25e70 100644
--- a/src/Tasks/ResourceHandling/FileStreamResource.cs
+++ b/src/Tasks/ResourceHandling/FileStreamResource.cs
@@ -12,8 +12,11 @@ namespace Microsoft.Build.Tasks.ResourceHandling
     internal class FileStreamResource : IResource
     {
         public string Name { get; }
+
         public string TypeAssemblyQualifiedName { get; }
+
         public string OriginatingFile { get; }
+
         public string FileName { get; }
 
         public string TypeFullName => NameUtilities.FullNameFromAssemblyQualifiedName(TypeAssemblyQualifiedName);
@@ -37,7 +40,9 @@ public void AddTo(IResourceWriter writer)
         {
             if (writer is PreserializedResourceWriter preserializedResourceWriter)
             {
+#pragma warning disable CA2000 // Dispose objects before losing scope the stream is expected to be disposed by the PreserializedResourceWriter.ResourceDataRecord
                 FileStream fileStream = new FileStream(FileName, FileMode.Open, FileAccess.Read, FileShare.Read);
+#pragma warning restore CA2000 // Dispose objects before losing scope
 
                 preserializedResourceWriter.AddActivatorResource(Name, fileStream, TypeAssemblyQualifiedName, closeAfterWrite: true);
             }
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index 53ad3198125..6590a161c43 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -116,6 +116,7 @@ public override bool Execute()
                         {
                             using (FileStream stream = new FileStream(sourceFile.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: 0x1000, useAsync: false))
                             {
+#pragma warning disable CA2000 // Dispose objects before losing scope because ZipArchive will dispose the stream when it is disposed.
                                 using (ZipArchive zipArchive = new ZipArchive(stream, ZipArchiveMode.Read, leaveOpen: false))
                                 {
                                     try
@@ -129,6 +130,7 @@ public override bool Execute()
                                         return false;
                                     }
                                 }
+#pragma warning restore CA2000 // Dispose objects before losing scope
                             }
                         }
                         catch (OperationCanceledException)
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index 77128537b7a..81b2c4d9497 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -140,145 +140,151 @@ private string GenerateCode(out string extension)
             extension = null;
             bool haveGeneratedContent = false;
 
-            CodeDomProvider provider;
-
+            CodeDomProvider provider = null;
             try
             {
-                provider = CodeDomProvider.CreateProvider(Language);
-            }
-            catch (SystemException e) when
+                try
+                {
+                    provider = CodeDomProvider.CreateProvider(Language);
+                }
+                catch (SystemException e) when
 #if FEATURE_SYSTEM_CONFIGURATION
-            (e is ConfigurationException || e is SecurityException)
+                (e is ConfigurationException || e is SecurityException)
 #else
             (e.GetType().Name == "ConfigurationErrorsException") // TODO: catch specific exception type once it is public https://github.com/dotnet/corefx/issues/40456
 #endif
-            {
-                Log.LogErrorWithCodeFromResources("WriteCodeFragment.CouldNotCreateProvider", Language, e.Message);
-                return null;
-            }
-
-            extension = provider.FileExtension;
+                {
+                    Log.LogErrorWithCodeFromResources("WriteCodeFragment.CouldNotCreateProvider", Language, e.Message);
+                    return null;
+                }
 
-            var unit = new CodeCompileUnit();
+                extension = provider.FileExtension;
 
-            var globalNamespace = new CodeNamespace();
-            unit.Namespaces.Add(globalNamespace);
+                var unit = new CodeCompileUnit();
 
-            // Declare authorship. Unfortunately CodeDOM puts this comment after the attributes.
-            string comment = ResourceUtilities.GetResourceString("WriteCodeFragment.Comment");
-            globalNamespace.Comments.Add(new CodeCommentStatement(comment));
+                var globalNamespace = new CodeNamespace();
+                unit.Namespaces.Add(globalNamespace);
 
-            if (AssemblyAttributes == null)
-            {
-                return String.Empty;
-            }
+                // Declare authorship. Unfortunately CodeDOM puts this comment after the attributes.
+                string comment = ResourceUtilities.GetResourceString("WriteCodeFragment.Comment");
+                globalNamespace.Comments.Add(new CodeCommentStatement(comment));
 
-            // For convenience, bring in the namespaces, where many assembly attributes lie
-            foreach (string name in NamespaceImports)
-            {
-                globalNamespace.Imports.Add(new CodeNamespaceImport(name));
-            }
+                if (AssemblyAttributes == null)
+                {
+                    return String.Empty;
+                }
 
-            foreach (ITaskItem attributeItem in AssemblyAttributes)
-            {
-                // Some attributes only allow positional constructor arguments, or the user may just prefer them.
-                // To set those, use metadata names like "_Parameter1", "_Parameter2" etc.
-                // If a parameter index is skipped, it's an error.
-                IDictionary customMetadata = attributeItem.CloneCustomMetadata();
+                // For convenience, bring in the namespaces, where many assembly attributes lie
+                foreach (string name in NamespaceImports)
+                {
+                    globalNamespace.Imports.Add(new CodeNamespaceImport(name));
+                }
 
-                // Some metadata may indicate the types of parameters. Use that metadata to determine
-                // the parameter types. Those metadata items will be removed from the dictionary.
-                IReadOnlyDictionary<string, ParameterType> parameterTypes = ExtractParameterTypes(customMetadata);
+                foreach (ITaskItem attributeItem in AssemblyAttributes)
+                {
+                    // Some attributes only allow positional constructor arguments, or the user may just prefer them.
+                    // To set those, use metadata names like "_Parameter1", "_Parameter2" etc.
+                    // If a parameter index is skipped, it's an error.
+                    IDictionary customMetadata = attributeItem.CloneCustomMetadata();
 
-                var orderedParameters = new List<AttributeParameter?>(new AttributeParameter?[customMetadata.Count + 1] /* max possible slots needed */);
-                var namedParameters = new List<AttributeParameter>();
+                    // Some metadata may indicate the types of parameters. Use that metadata to determine
+                    // the parameter types. Those metadata items will be removed from the dictionary.
+                    IReadOnlyDictionary<string, ParameterType> parameterTypes = ExtractParameterTypes(customMetadata);
 
-                foreach (DictionaryEntry entry in customMetadata)
-                {
-                    string name = (string)entry.Key;
-                    string value = (string)entry.Value;
+                    var orderedParameters = new List<AttributeParameter?>(new AttributeParameter?[customMetadata.Count + 1] /* max possible slots needed */);
+                    var namedParameters = new List<AttributeParameter>();
 
-                    // Get the declared type information for this parameter.
-                    // If a type is not declared, then we infer the type.
-                    if (!parameterTypes.TryGetValue(name, out ParameterType type))
+                    foreach (DictionaryEntry entry in customMetadata)
                     {
-                        type = new ParameterType { Kind = ParameterTypeKind.Inferred };
+                        string name = (string)entry.Key;
+                        string value = (string)entry.Value;
+
+                        // Get the declared type information for this parameter.
+                        // If a type is not declared, then we infer the type.
+                        if (!parameterTypes.TryGetValue(name, out ParameterType type))
+                        {
+                            type = new ParameterType { Kind = ParameterTypeKind.Inferred };
+                        }
+
+                        if (name.StartsWith("_Parameter", StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (!Int32.TryParse(name.Substring("_Parameter".Length), out int index))
+                            {
+                                Log.LogErrorWithCodeFromResources("General.InvalidValue", name, "WriteCodeFragment");
+                                return null;
+                            }
+
+                            if (index > orderedParameters.Count || index < 1)
+                            {
+                                Log.LogErrorWithCodeFromResources("WriteCodeFragment.SkippedNumberedParameter", index);
+                                return null;
+                            }
+
+                            // "_Parameter01" and "_Parameter1" would overwrite each other
+                            orderedParameters[index - 1] = new AttributeParameter { Type = type, Value = value };
+                        }
+                        else
+                        {
+                            namedParameters.Add(new AttributeParameter { Name = name, Type = type, Value = value });
+                        }
                     }
 
-                    if (name.StartsWith("_Parameter", StringComparison.OrdinalIgnoreCase))
+                    bool encounteredNull = false;
+                    List<AttributeParameter> providedOrderedParameters = new();
+                    for (int i = 0; i < orderedParameters.Count; i++)
                     {
-                        if (!Int32.TryParse(name.Substring("_Parameter".Length), out int index))
+                        if (!orderedParameters[i].HasValue)
                         {
-                            Log.LogErrorWithCodeFromResources("General.InvalidValue", name, "WriteCodeFragment");
-                            return null;
+                            // All subsequent args should be null, else a slot was missed
+                            encounteredNull = true;
+                            continue;
                         }
 
-                        if (index > orderedParameters.Count || index < 1)
+                        if (encounteredNull)
                         {
-                            Log.LogErrorWithCodeFromResources("WriteCodeFragment.SkippedNumberedParameter", index);
+                            Log.LogErrorWithCodeFromResources("WriteCodeFragment.SkippedNumberedParameter", i + 1 /* back to 1 based */);
                             return null;
                         }
 
-                        // "_Parameter01" and "_Parameter1" would overwrite each other
-                        orderedParameters[index - 1] = new AttributeParameter { Type = type, Value = value };
-                    }
-                    else
-                    {
-                        namedParameters.Add(new AttributeParameter { Name = name, Type = type, Value = value });
+                        providedOrderedParameters.Add(orderedParameters[i].Value);
                     }
-                }
 
-                bool encounteredNull = false;
-                List<AttributeParameter> providedOrderedParameters = new();
-                for (int i = 0; i < orderedParameters.Count; i++)
-                {
-                    if (!orderedParameters[i].HasValue)
-                    {
-                        // All subsequent args should be null, else a slot was missed
-                        encounteredNull = true;
-                        continue;
-                    }
+                    var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));
+
+                    // We might need the type of the attribute if we need to infer the
+                    // types of the parameters. Search for it by the given type name,
+                    // as well as within the namespaces that we automatically import.
+                    Lazy<Type> attributeType = new(
+                        () => Type.GetType(attribute.Name, throwOnError: false) ?? NamespaceImports.Select(x => Type.GetType($"{x}.{attribute.Name}", throwOnError: false)).FirstOrDefault(),
+                        System.Threading.LazyThreadSafetyMode.None);
 
-                    if (encounteredNull)
+                    if (
+                        !AddArguments(attribute, attributeType, providedOrderedParameters, isPositional: true)
+                        || !AddArguments(attribute, attributeType, namedParameters, isPositional: false))
                     {
-                        Log.LogErrorWithCodeFromResources("WriteCodeFragment.SkippedNumberedParameter", i + 1 /* back to 1 based */);
                         return null;
                     }
 
-                    providedOrderedParameters.Add(orderedParameters[i].Value);
+                    unit.AssemblyCustomAttributes.Add(attribute);
+                    haveGeneratedContent = true;
                 }
 
-                var attribute = new CodeAttributeDeclaration(new CodeTypeReference(attributeItem.ItemSpec));
-
-                // We might need the type of the attribute if we need to infer the
-                // types of the parameters. Search for it by the given type name,
-                // as well as within the namespaces that we automatically import.
-                Lazy<Type> attributeType = new(
-                    () => Type.GetType(attribute.Name, throwOnError: false) ?? NamespaceImports.Select(x => Type.GetType($"{x}.{attribute.Name}", throwOnError: false)).FirstOrDefault(),
-                    System.Threading.LazyThreadSafetyMode.None);
-
-                if (
-                    !AddArguments(attribute, attributeType, providedOrderedParameters, isPositional: true)
-                    || !AddArguments(attribute, attributeType, namedParameters, isPositional: false))
+                var generatedCode = new StringBuilder();
+                using (var writer = new StringWriter(generatedCode, CultureInfo.CurrentCulture))
                 {
-                    return null;
+                    provider.GenerateCodeFromCompileUnit(unit, writer, new CodeGeneratorOptions());
                 }
 
-                unit.AssemblyCustomAttributes.Add(attribute);
-                haveGeneratedContent = true;
-            }
+                string code = generatedCode.ToString();
 
-            var generatedCode = new StringBuilder();
-            using (var writer = new StringWriter(generatedCode, CultureInfo.CurrentCulture))
+                // If we just generated infrastructure, don't bother returning anything
+                // as there's no point writing the file
+                return haveGeneratedContent ? code : String.Empty;
+            }
+            finally
             {
-                provider.GenerateCodeFromCompileUnit(unit, writer, new CodeGeneratorOptions());
+                provider?.Dispose();
             }
-
-            string code = generatedCode.ToString();
-
-            // If we just generated infrastructure, don't bother returning anything
-            // as there's no point writing the file
-            return haveGeneratedContent ? code : String.Empty;
         }
 
         /// <summary>
diff --git a/src/Tasks/XamlTaskFactory/TaskParser.cs b/src/Tasks/XamlTaskFactory/TaskParser.cs
index bd9f1aa2185..626a1a92587 100644
--- a/src/Tasks/XamlTaskFactory/TaskParser.cs
+++ b/src/Tasks/XamlTaskFactory/TaskParser.cs
@@ -144,7 +144,9 @@ private bool ParseAsContentOrFile(string contentOrFile, string desiredRule)
                     throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Xaml.RuleFileNotFound", contentOrFile));
                 }
 
-                return ParseXamlDocument(new StreamReader(contentOrFile), desiredRule);
+                using var sr = new StreamReader(contentOrFile);
+
+                return ParseXamlDocument(sr, desiredRule);
             }
 
             // On Windows, xml content string is not a valid path, so, maybeFullPath == null
@@ -158,7 +160,9 @@ private bool ParseAsContentOrFile(string contentOrFile, string desiredRule)
             if (FileSystems.Default.FileExists(maybeFullPath))
             {
                 // file found, parse as a file
-                return ParseXamlDocument(new StreamReader(maybeFullPath), desiredRule);
+                using var sr = new StreamReader(maybeFullPath);
+
+                return ParseXamlDocument(sr, desiredRule);
             }
 
             // @maybeFullPath is either:
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index 4094d25b62e..342fb1f30b2 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -131,7 +131,7 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
             };
 
             // create the code provider
-            var codegenerator = CodeDomProvider.CreateProvider("cs");
+            using var codegenerator = CodeDomProvider.CreateProvider("cs");
             CompilerResults results;
             bool debugXamlTask = Environment.GetEnvironmentVariable("MSBUILDWRITEXAMLTASK") == "1";
             if (debugXamlTask)
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index 2f255f143cc..f55532b9546 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -451,8 +451,12 @@ public XslCompiledTransform LoadXslt(bool useTrustedSettings)
                 switch (_xslMode)
                 {
                     case XslModes.Xslt:
-                        xslct.Load(XmlReader.Create(new StringReader(_data)), settings, new XmlUrlResolver());
-                        break;
+                        {
+                            using var sr = new StringReader(_data);
+                            using var xmlReader = XmlReader.Create(sr);
+                            xslct.Load(xmlReader, settings, new XmlUrlResolver());
+                            break;
+                        }         
                     case XslModes.XsltFile:
                         if (useTrustedSettings)
                         {
diff --git a/src/UnitTests.Shared/ObjectModelHelpers.cs b/src/UnitTests.Shared/ObjectModelHelpers.cs
index ce51be22785..e5cf81e5fe3 100644
--- a/src/UnitTests.Shared/ObjectModelHelpers.cs
+++ b/src/UnitTests.Shared/ObjectModelHelpers.cs
@@ -1971,7 +1971,8 @@ public static void VerifyAssertLineByLine(string expected, string actual, bool i
         /// </summary>
         public static void ClearDirtyFlag(ProjectRootElement project)
         {
-            project.Save(new StringWriter());
+            using var sw = new StringWriter();
+            project.Save(sw);
             Assert.False(project.HasUnsavedChanges);
         }
 
