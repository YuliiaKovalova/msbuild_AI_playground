diff --git a/src/Build/BuildCheck/API/BuildCheckResult.cs b/src/Build/BuildCheck/API/BuildCheckResult.cs
index 040c7ec3d25..10d76f519be 100644
--- a/src/Build/BuildCheck/API/BuildCheckResult.cs
+++ b/src/Build/BuildCheck/API/BuildCheckResult.cs
@@ -16,28 +16,28 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// </summary>
 public sealed class BuildCheckResult : IBuildCheckResult
 {
-    public static BuildCheckResult Create(BuildExecutionCheckRule rule, ElementLocation location, params string[] messageArgs)
+    public static BuildCheckResult Create(CheckRule rule, ElementLocation location, params string[] messageArgs)
     {
         return new BuildCheckResult(rule, location, messageArgs);
     }
 
-    public BuildCheckResult(BuildExecutionCheckRule buildExecutionCheckRule, ElementLocation location, string[] messageArgs)
+    public BuildCheckResult(CheckRule buildExecutionCheckRule, ElementLocation location, string[] messageArgs)
     {
-        BuildExecutionCheckRule = buildExecutionCheckRule;
+        CheckRule = buildExecutionCheckRule;
         Location = location;
         MessageArgs = messageArgs;
     }
 
-    internal BuildEventArgs ToEventArgs(BuildExecutionCheckResultSeverity severity)
+    internal BuildEventArgs ToEventArgs(CheckResultSeverity severity)
         => severity switch
         {
-            BuildExecutionCheckResultSeverity.Suggestion => new BuildCheckResultMessage(this),
-            BuildExecutionCheckResultSeverity.Warning => new BuildCheckResultWarning(this, BuildExecutionCheckRule.Id),
-            BuildExecutionCheckResultSeverity.Error => new BuildCheckResultError(this, BuildExecutionCheckRule.Id),
+            CheckResultSeverity.Suggestion => new BuildCheckResultMessage(this),
+            CheckResultSeverity.Warning => new BuildCheckResultWarning(this, CheckRule.Id),
+            CheckResultSeverity.Error => new BuildCheckResultError(this, CheckRule.Id),
             _ => throw new ArgumentOutOfRangeException(nameof(severity), severity, null),
         };
 
-    public BuildExecutionCheckRule BuildExecutionCheckRule { get; }
+    public CheckRule CheckRule { get; }
 
     /// <summary>
     /// Optional location of the finding (in near future we might need to support multiple locations).
@@ -47,11 +47,11 @@ internal BuildEventArgs ToEventArgs(BuildExecutionCheckResultSeverity severity)
     public string LocationString => Location.LocationString;
 
     public string[] MessageArgs { get; }
-    public string MessageFormat => BuildExecutionCheckRule.MessageFormat;
+    public string MessageFormat => CheckRule.MessageFormat;
 
     // Here we will provide different link for built-in rules and custom rules - once we have the base classes differentiated.
     public string FormatMessage() =>
-        _message ??= $"{(Equals(Location ?? ElementLocation.EmptyLocation, ElementLocation.EmptyLocation) ? string.Empty : (Location!.LocationString + ": "))}https://aka.ms/buildcheck/codes#{BuildExecutionCheckRule.Id} - {string.Format(BuildExecutionCheckRule.MessageFormat, MessageArgs)}";
+        _message ??= $"{(Equals(Location ?? ElementLocation.EmptyLocation, ElementLocation.EmptyLocation) ? string.Empty : (Location!.LocationString + ": "))}https://aka.ms/buildcheck/codes#{CheckRule.Id} - {string.Format(CheckRule.MessageFormat, MessageArgs)}";
 
     private string? _message;
 }
diff --git a/src/Build/BuildCheck/API/BuildExecutionCheck.cs b/src/Build/BuildCheck/API/BuildExecutionCheck.cs
index b8046a40150..4eeeb8599f1 100644
--- a/src/Build/BuildCheck/API/BuildExecutionCheck.cs
+++ b/src/Build/BuildCheck/API/BuildExecutionCheck.cs
@@ -11,9 +11,9 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// Base class for build checks.
 /// Same base will be used for custom and built-in checks.
-/// <see cref="BuildExecutionCheck"/> is a unit of build checks execution, but it can contain multiple rules - each representing a distinct violation.
+/// <see cref="Check"/> is a unit of build checks execution, but it can contain multiple rules - each representing a distinct violation.
 /// </summary>
-public abstract class BuildExecutionCheck : IDisposable
+public abstract class Check : IDisposable
 {
     /// <summary>
     /// Friendly name of the check.
@@ -24,7 +24,7 @@ public abstract class BuildExecutionCheck : IDisposable
     /// <summary>
     /// Single or multiple rules supported by the check.
     /// </summary>
-    public abstract IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; }
+    public abstract IReadOnlyList<CheckRule> SupportedRules { get; }
 
     /// <summary>
     /// Optional initialization of the check.
diff --git a/src/Build/BuildCheck/API/BuildExecutionCheckConfiguration.cs b/src/Build/BuildCheck/API/BuildExecutionCheckConfiguration.cs
index 1f3956dd4fd..9c4ac89749f 100644
--- a/src/Build/BuildCheck/API/BuildExecutionCheckConfiguration.cs
+++ b/src/Build/BuildCheck/API/BuildExecutionCheckConfiguration.cs
@@ -15,17 +15,17 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// Each rule can have its own configuration, which can differ per each project.
 /// The <see cref="EvaluationCheckScope"/> setting must be same for all rules in the same check (but can differ between projects)
 /// </summary>
-public class BuildExecutionCheckConfiguration
+public class CheckConfiguration
 {
     // Defaults to be used if any configuration property is not specified neither as default
     //  nor in the editorconfig configuration file.
-    public static BuildExecutionCheckConfiguration Default { get; } = new()
+    public static CheckConfiguration Default { get; } = new()
     {
         EvaluationCheckScope = BuildCheck.EvaluationCheckScope.ProjectFileOnly,
-        Severity = BuildExecutionCheckResultSeverity.None
+        Severity = CheckResultSeverity.None
     };
 
-    public static BuildExecutionCheckConfiguration Null { get; } = new();
+    public static CheckConfiguration Null { get; } = new();
 
     public string? RuleId { get; internal set; }
 
@@ -40,7 +40,7 @@ public class BuildExecutionCheckConfiguration
     /// <summary>
     /// The severity of the result for the rule.
     /// </summary>
-    public BuildExecutionCheckResultSeverity? Severity { get; internal init; }
+    public CheckResultSeverity? Severity { get; internal init; }
 
     /// <summary>
     /// Whether the check rule is enabled.
@@ -51,9 +51,9 @@ public bool? IsEnabled {
         get
         {
             // Do not consider Default as enabled, because the default severity of the rule could be set to None
-            if (Severity.HasValue && Severity.Value != BuildExecutionCheckResultSeverity.Default)
+            if (Severity.HasValue && Severity.Value != CheckResultSeverity.Default)
             {
-                return !Severity.Value.Equals(BuildExecutionCheckResultSeverity.None);
+                return !Severity.Value.Equals(CheckResultSeverity.None);
             }
 
             return null;
@@ -61,13 +61,13 @@ public bool? IsEnabled {
     }
 
     /// <summary>
-    /// Creates a <see cref="BuildExecutionCheckConfiguration"/> object based on the provided configuration dictionary.
+    /// Creates a <see cref="CheckConfiguration"/> object based on the provided configuration dictionary.
     /// If the BuildCheckConfiguration's property name presented in the dictionary, the value of this key-value pair is parsed and assigned to the instance's field.
     /// If parsing failed the value will be equal to null.
     /// </summary>
     /// <param name="configDictionary">The configuration dictionary containing the settings for the build check. The configuration's keys are expected to be in lower case or the EqualityComparer to ignore case.</param>
-    /// <returns>A new instance of <see cref="BuildExecutionCheckConfiguration"/> with the specified settings.</returns>
-    internal static BuildExecutionCheckConfiguration Create(Dictionary<string, string>? configDictionary) => new()
+    /// <returns>A new instance of <see cref="CheckConfiguration"/> with the specified settings.</returns>
+    internal static CheckConfiguration Create(Dictionary<string, string>? configDictionary) => new()
     {
         EvaluationCheckScope = TryExtractEvaluationCheckScope(configDictionary),
         Severity = TryExtractSeverity(configDictionary),
@@ -99,7 +99,7 @@ public bool? IsEnabled {
         return null;
     }
 
-    private static BuildExecutionCheckResultSeverity? TryExtractSeverity(Dictionary<string, string>? config)
+    private static CheckResultSeverity? TryExtractSeverity(Dictionary<string, string>? config)
     {
         if (!TryExtractValue(BuildCheckConstants.severityConfigurationKey, config, out string? stringValue) || stringValue is null)
         {
@@ -109,15 +109,15 @@ public bool? IsEnabled {
         switch (stringValue)
         {
             case "none":
-                return BuildExecutionCheckResultSeverity.None;
+                return CheckResultSeverity.None;
             case "default":
-                return BuildExecutionCheckResultSeverity.Default;
+                return CheckResultSeverity.Default;
             case "suggestion":
-                return BuildExecutionCheckResultSeverity.Suggestion;
+                return CheckResultSeverity.Suggestion;
             case "warning":
-                return BuildExecutionCheckResultSeverity.Warning;
+                return CheckResultSeverity.Warning;
             case "error":
-                return BuildExecutionCheckResultSeverity.Error;
+                return CheckResultSeverity.Error;
             default:
                 ThrowIncorrectValueException(BuildCheckConstants.severityConfigurationKey, stringValue);
                 break;
diff --git a/src/Build/BuildCheck/API/BuildExecutionCheckResultSeverity.cs b/src/Build/BuildCheck/API/BuildExecutionCheckResultSeverity.cs
index db758641143..dc26b9d4532 100644
--- a/src/Build/BuildCheck/API/BuildExecutionCheckResultSeverity.cs
+++ b/src/Build/BuildCheck/API/BuildExecutionCheckResultSeverity.cs
@@ -6,7 +6,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// The severity of reported result (or preconfigured or user configured severity for a rule).
 /// </summary>
-public enum BuildExecutionCheckResultSeverity
+public enum CheckResultSeverity
 {
     /// <summary>
     /// When set, the default value of the BuildCheck rule will be used.
diff --git a/src/Build/BuildCheck/API/BuildExecutionCheckRule.cs b/src/Build/BuildCheck/API/BuildExecutionCheckRule.cs
index f06cb580c27..2fd505bf1f1 100644
--- a/src/Build/BuildCheck/API/BuildExecutionCheckRule.cs
+++ b/src/Build/BuildCheck/API/BuildExecutionCheckRule.cs
@@ -5,17 +5,17 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
 /// Represents a rule that is a unit of a build check.
-/// <see cref="BuildExecutionCheck"/> is a unit of executing the check, but it can be discovering multiple distinct violation types,
-///  for this reason a single <see cref="BuildExecutionCheck"/> can expose multiple <see cref="BuildExecutionCheckRule"/>s.
+/// <see cref="Check"/> is a unit of executing the check, but it can be discovering multiple distinct violation types,
+///  for this reason a single <see cref="Check"/> can expose multiple <see cref="CheckRule"/>s.
 /// </summary>
-public class BuildExecutionCheckRule
+public class CheckRule
 {
-    public BuildExecutionCheckRule(
+    public CheckRule(
         string id, 
         string title, 
         string description, 
         string messageFormat,
-        BuildExecutionCheckConfiguration defaultConfiguration)
+        CheckConfiguration defaultConfiguration)
     {
         Id = id;
         Title = title;
@@ -55,5 +55,5 @@ public BuildExecutionCheckRule(
     /// The default configuration - overridable by the user via .editorconfig.
     /// If no user specified configuration is provided, this default will be used.
     /// </summary>
-    public BuildExecutionCheckConfiguration DefaultConfiguration { get; }
+    public CheckConfiguration DefaultConfiguration { get; }
 }
diff --git a/src/Build/BuildCheck/API/ConfigurationContext.cs b/src/Build/BuildCheck/API/ConfigurationContext.cs
index f6dc6105f9d..ef9742630cf 100644
--- a/src/Build/BuildCheck/API/ConfigurationContext.cs
+++ b/src/Build/BuildCheck/API/ConfigurationContext.cs
@@ -13,13 +13,13 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// </summary>
 public class ConfigurationContext
 {
-    private ConfigurationContext(CustomConfigurationData[] customConfigurationData, BuildExecutionCheckConfigurationEffective[] buildExecutionCheckConfig)
+    private ConfigurationContext(CustomConfigurationData[] customConfigurationData, CheckConfigurationEffective[] buildExecutionCheckConfig)
     {
         CustomConfigurationData = customConfigurationData;
-        BuildExecutionCheckConfig = buildExecutionCheckConfig;
+        CheckConfig = buildExecutionCheckConfig;
     }
 
-    internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData[] customConfigurationData, BuildExecutionCheckConfigurationEffective[] buildExecutionCheckConfig)
+    internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData[] customConfigurationData, CheckConfigurationEffective[] buildExecutionCheckConfig)
     {
         return new ConfigurationContext(customConfigurationData, buildExecutionCheckConfig);
     }
@@ -32,5 +32,5 @@ internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData
     /// <summary>
     /// Infrastructure configuration data
     /// </summary>
-    public IReadOnlyList<BuildExecutionCheckConfigurationEffective> BuildExecutionCheckConfig { get; init; }
+    public IReadOnlyList<CheckConfigurationEffective> CheckConfig { get; init; }
 }
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index 641758faf4b..b0899f22134 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -23,11 +23,11 @@ internal class BuildCheckAcquisitionModule : IBuildCheckAcquisitionModule
     /// <summary>
     /// Creates a list of factory delegates for building check rules instances from a given assembly path.
     /// </summary>
-    public List<BuildExecutionCheckFactory> CreateBuildExecutionCheckFactories(
+    public List<CheckFactory> CreateCheckFactories(
         CheckAcquisitionData checkAcquisitionData,
         ICheckContext checkContext)
     {
-        var checksFactories = new List<BuildExecutionCheckFactory>();
+        var checksFactories = new List<CheckFactory>();
 
         try
         {
@@ -39,11 +39,11 @@ public List<BuildExecutionCheckFactory> CreateBuildExecutionCheckFactories(
 #endif
 
             IList<Type> availableTypes = assembly.GetExportedTypes();
-            IList<Type> checkTypes = availableTypes.Where(t => typeof(BuildExecutionCheck).IsAssignableFrom(t)).ToArray();
+            IList<Type> checkTypes = availableTypes.Where(t => typeof(Check).IsAssignableFrom(t)).ToArray();
 
             foreach (Type checkCandidate in checkTypes)
             {
-                checksFactories.Add(() => (BuildExecutionCheck)Activator.CreateInstance(checkCandidate)!);
+                checksFactories.Add(() => (Check)Activator.CreateInstance(checkCandidate)!);
                 checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckRegistered", checkCandidate.Name, checkCandidate.Assembly);
             }
 
diff --git a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
index 68ea3314298..245736ca67a 100644
--- a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
@@ -12,5 +12,5 @@ internal interface IBuildCheckAcquisitionModule
     /// <summary>
     /// Creates a list of factory delegates for building check rules instances from a given assembly path.
     /// </summary>
-    List<BuildExecutionCheckFactory> CreateBuildExecutionCheckFactories(CheckAcquisitionData checkAcquisitionData, ICheckContext checkContext);
+    List<CheckFactory> CreateCheckFactories(CheckAcquisitionData checkAcquisitionData, ICheckContext checkContext);
 }
diff --git a/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
index a2e2f51210c..df2cbd61145 100644
--- a/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
+++ b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
@@ -18,18 +18,18 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck.Checks;
 
-internal sealed class DoubleWritesCheck : BuildExecutionCheck
+internal sealed class DoubleWritesCheck : Check
 {
-    public static BuildExecutionCheckRule SupportedRule = new BuildExecutionCheckRule(
+    public static CheckRule SupportedRule = new CheckRule(
         "BC0102",
         "DoubleWrites",
         "Two tasks should not write the same file",
         "Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.",
-        new BuildExecutionCheckConfiguration() { Severity = BuildExecutionCheckResultSeverity.Warning });
+        new CheckConfiguration() { Severity = CheckResultSeverity.Warning });
 
     public override string FriendlyName => "MSBuild.DoubleWritesCheck";
 
-    public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = [SupportedRule];
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
diff --git a/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
index ef72f421b19..62f6b5df9bc 100644
--- a/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
+++ b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
@@ -7,14 +7,14 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck.Checks;
 
-internal sealed class NoEnvironmentVariablePropertyCheck : BuildExecutionCheck
+internal sealed class NoEnvironmentVariablePropertyCheck : Check
 {
-    public static BuildExecutionCheckRule SupportedRule = new BuildExecutionCheckRule(
+    public static CheckRule SupportedRule = new CheckRule(
                 "BC0103",
                 "NoEnvironmentVariablePropertyCheck",
                 "No implicit property derived from an environment variable should be used during the build",
                 "Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.",
-                new BuildExecutionCheckConfiguration() { Severity = BuildExecutionCheckResultSeverity.Suggestion });
+                new CheckConfiguration() { Severity = CheckResultSeverity.Suggestion });
 
     private const string RuleId = "BC0103";
 
@@ -29,7 +29,7 @@ internal sealed class NoEnvironmentVariablePropertyCheck : BuildExecutionCheck
 
     public override string FriendlyName => "MSBuild.NoEnvironmentVariablePropertyCheck";
 
-    public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = [SupportedRule];
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
diff --git a/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
index aa668e5fb6c..1ec84093e3a 100644
--- a/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
+++ b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
@@ -13,17 +13,17 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck.Checks;
 
-internal sealed class SharedOutputPathCheck : BuildExecutionCheck
+internal sealed class SharedOutputPathCheck : Check
 {
     private const string RuleId = "BC0101";
-    public static BuildExecutionCheckRule SupportedRule = new BuildExecutionCheckRule(RuleId, "ConflictingOutputPath",
+    public static CheckRule SupportedRule = new CheckRule(RuleId, "ConflictingOutputPath",
         "Two projects should not share their OutputPath nor IntermediateOutputPath locations",
         "Projects {0} and {1} have conflicting output paths: {2}.",
-        new BuildExecutionCheckConfiguration() { RuleId = RuleId, Severity = BuildExecutionCheckResultSeverity.Warning });
+        new CheckConfiguration() { RuleId = RuleId, Severity = CheckResultSeverity.Warning });
 
     public override string FriendlyName => "MSBuild.SharedOutputPathCheck";
 
-    public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = [SupportedRule];
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index a72bc47521d..fd72d1a6e8e 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -22,16 +22,16 @@ internal BuildCheckCentralContext(IConfigurationProvider configurationProvider)
         => _configurationProvider = configurationProvider;
 
     private record CallbackRegistry(
-        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>>)> EvaluatedPropertiesActions,
-        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<ParsedItemsCheckData>>)> ParsedItemsActions,
-        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<TaskInvocationCheckData>>)> TaskInvocationActions,
-        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<PropertyReadData>>)> PropertyReadActions,
-        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<PropertyWriteData>>)> PropertyWriteActions,
-        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<ProjectProcessingDoneData>>)> ProjectProcessingDoneActions)
+        List<(CheckWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>>)> EvaluatedPropertiesActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<ParsedItemsCheckData>>)> ParsedItemsActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<TaskInvocationCheckData>>)> TaskInvocationActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<PropertyReadData>>)> PropertyReadActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<PropertyWriteData>>)> PropertyWriteActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<ProjectProcessingDoneData>>)> ProjectProcessingDoneActions)
     {
         public CallbackRegistry() : this([], [], [], [], [], []) { }
 
-        internal void DeregisterCheck(BuildExecutionCheckWrapper check)
+        internal void DeregisterCheck(CheckWrapper check)
         {
             EvaluatedPropertiesActions.RemoveAll(a => a.Item1 == check);
             ParsedItemsActions.RemoveAll(a => a.Item1 == check);
@@ -54,30 +54,30 @@ internal void DeregisterCheck(BuildExecutionCheckWrapper check)
     internal bool HasPropertyReadActions => _globalCallbacks.PropertyReadActions.Count > 0;
     internal bool HasPropertyWriteActions => _globalCallbacks.PropertyWriteActions.Count > 0;
 
-    internal void RegisterEvaluatedPropertiesAction(BuildExecutionCheckWrapper check, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction)
+    internal void RegisterEvaluatedPropertiesAction(CheckWrapper check, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction)
         // Here we might want to communicate to node that props need to be sent.
         //  (it was being communicated via MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION)
         => RegisterAction(check, evaluatedPropertiesAction, _globalCallbacks.EvaluatedPropertiesActions);
 
-    internal void RegisterParsedItemsAction(BuildExecutionCheckWrapper check, Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction)
+    internal void RegisterParsedItemsAction(CheckWrapper check, Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction)
         => RegisterAction(check, parsedItemsAction, _globalCallbacks.ParsedItemsActions);
 
-    internal void RegisterTaskInvocationAction(BuildExecutionCheckWrapper check, Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction)
+    internal void RegisterTaskInvocationAction(CheckWrapper check, Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction)
         => RegisterAction(check, taskInvocationAction, _globalCallbacks.TaskInvocationActions);
 
-    internal void RegisterPropertyReadAction(BuildExecutionCheckWrapper check, Action<BuildCheckDataContext<PropertyReadData>> propertyReadAction)
+    internal void RegisterPropertyReadAction(CheckWrapper check, Action<BuildCheckDataContext<PropertyReadData>> propertyReadAction)
         => RegisterAction(check, propertyReadAction, _globalCallbacks.PropertyReadActions);
 
-    internal void RegisterPropertyWriteAction(BuildExecutionCheckWrapper check, Action<BuildCheckDataContext<PropertyWriteData>> propertyWriteAction)
+    internal void RegisterPropertyWriteAction(CheckWrapper check, Action<BuildCheckDataContext<PropertyWriteData>> propertyWriteAction)
         => RegisterAction(check, propertyWriteAction, _globalCallbacks.PropertyWriteActions);
 
-    internal void RegisterProjectProcessingDoneAction(BuildExecutionCheckWrapper check, Action<BuildCheckDataContext<ProjectProcessingDoneData>> projectDoneAction)
+    internal void RegisterProjectProcessingDoneAction(CheckWrapper check, Action<BuildCheckDataContext<ProjectProcessingDoneData>> projectDoneAction)
         => RegisterAction(check, projectDoneAction, _globalCallbacks.ProjectProcessingDoneActions);
 
     private void RegisterAction<T>(
-        BuildExecutionCheckWrapper wrappedCheck,
+        CheckWrapper wrappedCheck,
         Action<BuildCheckDataContext<T>> handler,
-        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<T>>)> handlersRegistry)
+        List<(CheckWrapper, Action<BuildCheckDataContext<T>>)> handlersRegistry)
         where T : CheckData
     {
         void WrappedHandler(BuildCheckDataContext<T> context)
@@ -92,7 +92,7 @@ void WrappedHandler(BuildCheckDataContext<T> context)
         }
     }
 
-    internal void DeregisterCheck(BuildExecutionCheckWrapper check)
+    internal void DeregisterCheck(CheckWrapper check)
     {
         _globalCallbacks.DeregisterCheck(check);
     }
@@ -100,7 +100,7 @@ internal void DeregisterCheck(BuildExecutionCheckWrapper check)
     internal void RunEvaluatedPropertiesActions(
         EvaluatedPropertiesCheckData evaluatedPropertiesCheckData,
         ICheckContext checkContext,
-        Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult>
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.EvaluatedPropertiesActions, evaluatedPropertiesCheckData,
             checkContext, resultHandler);
@@ -108,7 +108,7 @@ internal void RunEvaluatedPropertiesActions(
     internal void RunParsedItemsActions(
         ParsedItemsCheckData parsedItemsCheckData,
         ICheckContext checkContext,
-        Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult>
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.ParsedItemsActions, parsedItemsCheckData,
             checkContext, resultHandler);
@@ -116,7 +116,7 @@ internal void RunParsedItemsActions(
     internal void RunTaskInvocationActions(
         TaskInvocationCheckData taskInvocationCheckData,
         ICheckContext checkContext,
-        Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult>
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.TaskInvocationActions, taskInvocationCheckData,
             checkContext, resultHandler);
@@ -124,7 +124,7 @@ internal void RunTaskInvocationActions(
     internal void RunPropertyReadActions(
         PropertyReadData propertyReadDataData,
         CheckLoggingContext checkContext,
-        Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult>
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.PropertyReadActions, propertyReadDataData,
             checkContext, resultHandler);
@@ -132,7 +132,7 @@ internal void RunPropertyReadActions(
     internal void RunPropertyWriteActions(
         PropertyWriteData propertyWriteData,
         CheckLoggingContext checkContext,
-        Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult>
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.PropertyWriteActions, propertyWriteData,
             checkContext, resultHandler);
@@ -140,16 +140,16 @@ internal void RunPropertyWriteActions(
     internal void RunProjectProcessingDoneActions(
         ProjectProcessingDoneData projectProcessingDoneData,
         ICheckContext checkContext,
-        Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult>
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.ProjectProcessingDoneActions, projectProcessingDoneData,
             checkContext, resultHandler);
 
     private void RunRegisteredActions<T>(
-        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
+        List<(CheckWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
         T checkData,
         ICheckContext checkContext,
-        Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult> resultHandler)
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult> resultHandler)
     where T : CheckData
     {
         string projectFullPath = checkData.ProjectFilePath;
@@ -159,8 +159,8 @@ private void RunRegisteredActions<T>(
             // Tracing - https://github.com/dotnet/msbuild/issues/9629 - we might want to account this entire block
             //  to the relevant check (with BuildCheckConfigurationEffectively the currently accounted part as being the 'core-execution' subspan)
 
-            BuildExecutionCheckConfigurationEffective? commonConfig = checkCallback.Item1.CommonConfig;
-            BuildExecutionCheckConfigurationEffective[] configPerRule;
+            CheckConfigurationEffective? commonConfig = checkCallback.Item1.CommonConfig;
+            CheckConfigurationEffective[] configPerRule;
 
             if (commonConfig != null)
             {
@@ -175,7 +175,7 @@ private void RunRegisteredActions<T>(
             {
                 configPerRule =
                     _configurationProvider.GetMergedConfigurations(projectFullPath,
-                        checkCallback.Item1.BuildExecutionCheck);
+                        checkCallback.Item1.Check);
                 if (configPerRule.All(c => !c.IsEnabled))
                 {
                     return;
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
index 365785b319e..c3910395ad2 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
@@ -5,7 +5,7 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-internal sealed class BuildCheckRegistrationContext(BuildExecutionCheckWrapper checkWrapper, BuildCheckCentralContext buildCheckCentralContext) : IBuildCheckRegistrationContext
+internal sealed class BuildCheckRegistrationContext(CheckWrapper checkWrapper, BuildCheckCentralContext buildCheckCentralContext) : IBuildCheckRegistrationContext
 {
     public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction)
     {
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 135ecf00c49..ce45e5ab6df 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -19,8 +19,8 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-internal delegate BuildExecutionCheck BuildExecutionCheckFactory();
-internal delegate BuildExecutionCheckWrapper BuildExecutionCheckWrapperFactory(ConfigurationContext configurationContext);
+internal delegate Check CheckFactory();
+internal delegate CheckWrapper CheckWrapperFactory(ConfigurationContext configurationContext);
 
 /// <summary>
 /// The central manager for the BuildCheck - this is the integration point with MSBuild infrastructure.
@@ -72,14 +72,14 @@ internal sealed class BuildCheckManager : IBuildCheckManager, IBuildEngineDataRo
         private readonly TracingReporter _tracingReporter = new TracingReporter();
         private readonly IConfigurationProvider _configurationProvider = new ConfigurationProvider();
         private readonly BuildCheckCentralContext _buildCheckCentralContext;
-        private readonly List<BuildExecutionCheckFactoryContext> _checkRegistry;
+        private readonly List<CheckFactoryContext> _checkRegistry;
         private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
         private readonly BuildEventsProcessor _buildEventsProcessor;
         private readonly IBuildCheckAcquisitionModule _acquisitionModule;
 
         internal BuildCheckManager()
         {
-            _checkRegistry = new List<BuildExecutionCheckFactoryContext>();
+            _checkRegistry = new List<CheckFactoryContext>();
             _acquisitionModule = new BuildCheckAcquisitionModule();
             _buildCheckCentralContext = new(_configurationProvider);
             _buildEventsProcessor = new(_buildCheckCentralContext);
@@ -112,7 +112,7 @@ public void ProcessCheckAcquisition(
             Stopwatch stopwatch = Stopwatch.StartNew();
             if (IsInProcNode)
             {
-                var checksFactories = _acquisitionModule.CreateBuildExecutionCheckFactories(acquisitionData, checkContext);
+                var checksFactories = _acquisitionModule.CreateCheckFactories(acquisitionData, checkContext);
                 if (checksFactories.Count != 0)
                 {
                     RegisterCustomCheck(acquisitionData.ProjectPath, BuildCheckDataSource.EventArgs, checksFactories, checkContext);
@@ -136,7 +136,7 @@ public void ProcessCheckAcquisition(
 
         private static T Construct<T>() where T : new() => new();
 
-        private static readonly (string[] ruleIds, bool defaultEnablement, BuildExecutionCheckFactory factory)[][] s_builtInFactoriesPerDataSource =
+        private static readonly (string[] ruleIds, bool defaultEnablement, CheckFactory factory)[][] s_builtInFactoriesPerDataSource =
         [
 
             // BuildCheckDataSource.EventArgs
@@ -153,19 +153,19 @@ private static readonly (string[] ruleIds, bool defaultEnablement, BuildExecutio
         /// <summary>
         /// For tests only. TODO: Remove when check acquisition is done.
         /// </summary>
-        internal static (string[] ruleIds, bool defaultEnablement, BuildExecutionCheckFactory factory)[][]? s_testFactoriesPerDataSource;
+        internal static (string[] ruleIds, bool defaultEnablement, CheckFactory factory)[][]? s_testFactoriesPerDataSource;
 
         private void RegisterBuiltInChecks(BuildCheckDataSource buildCheckDataSource)
         {
             _checkRegistry.AddRange(
                 s_builtInFactoriesPerDataSource[(int)buildCheckDataSource]
-                    .Select(v => new BuildExecutionCheckFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
+                    .Select(v => new CheckFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
 
             if (s_testFactoriesPerDataSource is not null)
             {
                 _checkRegistry.AddRange(
                     s_testFactoriesPerDataSource[(int)buildCheckDataSource]
-                        .Select(v => new BuildExecutionCheckFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
+                        .Select(v => new CheckFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
             }
         }
 
@@ -180,7 +180,7 @@ private void RegisterBuiltInChecks(BuildCheckDataSource buildCheckDataSource)
         internal void RegisterCustomCheck(
             string projectPath,
             BuildCheckDataSource buildCheckDataSource,
-            IEnumerable<BuildExecutionCheckFactory> factories,
+            IEnumerable<CheckFactory> factories,
             ICheckContext checkContext)
         {
             if (_enabledDataSources[(int)buildCheckDataSource])
@@ -188,7 +188,7 @@ internal void RegisterCustomCheck(
                 foreach (var factory in factories)
                 {
                     var instance = factory();
-                    var checkFactoryContext = new BuildExecutionCheckFactoryContext(
+                    var checkFactoryContext = new CheckFactoryContext(
                         factory,
                         instance.SupportedRules.Select(r => r.Id).ToArray(),
                         instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true));
@@ -203,17 +203,17 @@ internal void RegisterCustomCheck(
             }
         }
 
-        private void SetupSingleCheck(BuildExecutionCheckFactoryContext checkFactoryContext, string projectFullPath)
+        private void SetupSingleCheck(CheckFactoryContext checkFactoryContext, string projectFullPath)
         {
             // For custom checks - it should run only on projects where referenced
             // (otherwise error out - https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57849480)
             // on others it should work similarly as disabling them.
             // Disabled check should not only post-filter results - it shouldn't even see the data 
-            BuildExecutionCheckWrapper wrapper;
-            BuildExecutionCheckConfigurationEffective[] configurations;
+            CheckWrapper wrapper;
+            CheckConfigurationEffective[] configurations;
             if (checkFactoryContext.MaterializedCheck == null)
             {
-                BuildExecutionCheckConfiguration[] userConfigs =
+                CheckConfiguration[] userConfigs =
                     _configurationProvider.GetUserConfigurations(projectFullPath, checkFactoryContext.RuleIds);
 
                 if (userConfigs.All(c => !(c.IsEnabled ?? checkFactoryContext.IsEnabledByDefault)))
@@ -225,14 +225,14 @@ private void SetupSingleCheck(BuildExecutionCheckFactoryContext checkFactoryCont
                 CustomConfigurationData[] customConfigData =
                     _configurationProvider.GetCustomConfigurations(projectFullPath, checkFactoryContext.RuleIds);
 
-                BuildExecutionCheck uninitializedCheck = checkFactoryContext.Factory();
+                Check uninitializedCheck = checkFactoryContext.Factory();
                 configurations = _configurationProvider.GetMergedConfigurations(userConfigs, uninitializedCheck);
 
                 ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData, configurations);
 
                 wrapper = checkFactoryContext.Initialize(uninitializedCheck, configurationContext);
                 checkFactoryContext.MaterializedCheck = wrapper;
-                BuildExecutionCheck check = wrapper.BuildExecutionCheck;
+                Check check = wrapper.Check;
 
                 // This is to facilitate possible perf improvement for custom checks - as we might want to
                 //  avoid loading the assembly and type just to check if it's supported.
@@ -263,7 +263,7 @@ private void SetupSingleCheck(BuildExecutionCheckFactoryContext checkFactoryCont
             {
                 wrapper = checkFactoryContext.MaterializedCheck;
 
-                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildExecutionCheck);
+                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.Check);
 
                 _configurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
                     checkFactoryContext.RuleIds[0]);
@@ -288,8 +288,8 @@ private void SetupChecksForNewProject(string projectFullPath, ICheckContext chec
 
             // If it's already constructed - just control the custom settings do not differ
             Stopwatch stopwatch = Stopwatch.StartNew();
-            List<BuildExecutionCheckFactoryContext> checksToRemove = new();
-            foreach (BuildExecutionCheckFactoryContext checkFactoryContext in _checkRegistry)
+            List<CheckFactoryContext> checksToRemove = new();
+            foreach (CheckFactoryContext checkFactoryContext in _checkRegistry)
             {
                 try
                 {
@@ -315,8 +315,8 @@ private void SetupChecksForNewProject(string projectFullPath, ICheckContext chec
             foreach (var checkToRemove in checksToRemove.Select(a => a.MaterializedCheck).Where(a => a != null))
             {
                 _buildCheckCentralContext.DeregisterCheck(checkToRemove!);
-                _tracingReporter.AddCheckStats(checkToRemove!.BuildExecutionCheck.FriendlyName, checkToRemove.Elapsed);
-                checkToRemove.BuildExecutionCheck.Dispose();
+                _tracingReporter.AddCheckStats(checkToRemove!.Check.FriendlyName, checkToRemove.Elapsed);
+                checkToRemove.Check.Dispose();
             }
 
             stopwatch.Stop();
@@ -378,7 +378,7 @@ public void ProcessTaskParameterEventArgs(
 
         public Dictionary<string, TimeSpan> CreateCheckTracingStats()
         {
-            foreach (BuildExecutionCheckFactoryContext checkFactoryContext in _checkRegistry)
+            foreach (CheckFactoryContext checkFactoryContext in _checkRegistry)
             {
                 if (checkFactoryContext.MaterializedCheck != null)
                 {
@@ -507,30 +507,30 @@ public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggi
         public void Shutdown()
         { /* Too late here for any communication to the main node or for logging anything */ }
 
-        private class BuildExecutionCheckFactoryContext(
-            BuildExecutionCheckFactory factory,
+        private class CheckFactoryContext(
+            CheckFactory factory,
             string[] ruleIds,
             bool isEnabledByDefault)
         {
-            public BuildExecutionCheck Factory()
+            public Check Factory()
             {
-                BuildExecutionCheck ba = factory();
+                Check ba = factory();
                 return ba;
             }
 
-            public BuildExecutionCheckWrapper Initialize(BuildExecutionCheck ba, ConfigurationContext configContext)
+            public CheckWrapper Initialize(Check ba, ConfigurationContext configContext)
             {
                 ba.Initialize(configContext);
-                return new BuildExecutionCheckWrapper(ba);
+                return new CheckWrapper(ba);
             }
 
-            public BuildExecutionCheckWrapper? MaterializedCheck { get; set; }
+            public CheckWrapper? MaterializedCheck { get; set; }
 
             public string[] RuleIds { get; init; } = ruleIds;
 
             public bool IsEnabledByDefault { get; init; } = isEnabledByDefault;
 
-            public string FriendlyName => MaterializedCheck?.BuildExecutionCheck.FriendlyName ?? factory().FriendlyName;
+            public string FriendlyName => MaterializedCheck?.Check.FriendlyName ?? factory().FriendlyName;
         }
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
index ee29ab0484f..4091327deac 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -211,23 +211,23 @@ public void ProcessProjectDone(ICheckContext checkContext, string projectFullPat
                 ReportResult);
 
     private static void ReportResult(
-        BuildExecutionCheckWrapper checkWrapper,
+        CheckWrapper checkWrapper,
         ICheckContext checkContext,
-        BuildExecutionCheckConfigurationEffective[] configPerRule,
+        CheckConfigurationEffective[] configPerRule,
         BuildCheckResult result)
     {
-        if (!checkWrapper.BuildExecutionCheck.SupportedRules.Contains(result.BuildExecutionCheckRule))
+        if (!checkWrapper.Check.SupportedRules.Contains(result.CheckRule))
         {
             checkContext.DispatchAsErrorFromText(null, null, null,
                 BuildEventFileInfo.Empty,
-                $"The check '{checkWrapper.BuildExecutionCheck.FriendlyName}' reported a result for a rule '{result.BuildExecutionCheckRule.Id}' that it does not support.");
+                $"The check '{checkWrapper.Check.FriendlyName}' reported a result for a rule '{result.CheckRule.Id}' that it does not support.");
             return;
         }
 
-        BuildExecutionCheckConfigurationEffective config = configPerRule.Length == 1
+        CheckConfigurationEffective config = configPerRule.Length == 1
             ? configPerRule[0]
             : configPerRule.First(r =>
-                r.RuleId.Equals(result.BuildExecutionCheckRule.Id, StringComparison.CurrentCultureIgnoreCase));
+                r.RuleId.Equals(result.CheckRule.Id, StringComparison.CurrentCultureIgnoreCase));
 
         if (!config.IsEnabled)
         {
diff --git a/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckConfigurationEffective.cs b/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckConfigurationEffective.cs
index cc2b5d329ac..3ab5a72de72 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckConfigurationEffective.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckConfigurationEffective.cs
@@ -9,11 +9,11 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 /// <summary>
 /// Counterpart type for BuildCheckConfiguration - with all properties non-nullable
 /// </summary>
-public sealed class BuildExecutionCheckConfigurationEffective
+public sealed class CheckConfigurationEffective
 {
-    public BuildExecutionCheckConfigurationEffective(string ruleId, EvaluationCheckScope evaluationCheckScope, BuildExecutionCheckResultSeverity severity)
+    public CheckConfigurationEffective(string ruleId, EvaluationCheckScope evaluationCheckScope, CheckResultSeverity severity)
     {
-        if (severity == BuildExecutionCheckResultSeverity.Default)
+        if (severity == CheckResultSeverity.Default)
         {
             throw new ArgumentOutOfRangeException(nameof(severity), severity, "Severity 'Default' is not recognized by the BuildCheck reports infrastructure");
         }
@@ -27,14 +27,14 @@ public BuildExecutionCheckConfigurationEffective(string ruleId, EvaluationCheckS
 
     public EvaluationCheckScope EvaluationCheckScope { get; }
 
-    public BuildExecutionCheckResultSeverity Severity { get; }
+    public CheckResultSeverity Severity { get; }
 
-    public bool IsEnabled => Severity >= BuildExecutionCheckResultSeverity.Suggestion;
+    public bool IsEnabled => Severity >= CheckResultSeverity.Suggestion;
 
     // Intentionally not checking the RuleId
     //  as for checks with multiple rules, we can squash config to a single one,
     //  if the ruleId is the only thing differing.
-    public bool IsSameConfigurationAs(BuildExecutionCheckConfigurationEffective? other) =>
+    public bool IsSameConfigurationAs(CheckConfigurationEffective? other) =>
         other != null &&
         Severity == other.Severity &&
         EvaluationCheckScope == other.EvaluationCheckScope;
diff --git a/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckWrapper.cs b/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckWrapper.cs
index bb2e16171e2..68710c5be06 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckWrapper.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckWrapper.cs
@@ -13,26 +13,26 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 /// <summary>
 /// A wrapping, enriching class for BuildCheck - so that we have additional data and functionality.
 /// </summary>
-internal sealed class BuildExecutionCheckWrapper
+internal sealed class CheckWrapper
 {
     private readonly Stopwatch _stopwatch = new Stopwatch();
 
-    public BuildExecutionCheckWrapper(BuildExecutionCheck buildExecutionCheck)
+    public CheckWrapper(Check buildExecutionCheck)
     {
-        BuildExecutionCheck = buildExecutionCheck;
+        Check = buildExecutionCheck;
     }
 
-    internal BuildExecutionCheck BuildExecutionCheck { get; }
+    internal Check Check { get; }
     private bool _isInitialized = false;
 
     // Let's optimize for the scenario where users have a single .editorconfig file that applies to the whole solution.
     // In such case - configuration will be same for all projects. So we do not need to store it per project in a collection.
-    internal BuildExecutionCheckConfigurationEffective? CommonConfig { get; private set; }
+    internal CheckConfigurationEffective? CommonConfig { get; private set; }
 
     // start new project
     internal void StartNewProject(
         string fullProjectPath,
-        IReadOnlyList<BuildExecutionCheckConfigurationEffective> userConfigs)
+        IReadOnlyList<CheckConfigurationEffective> userConfigs)
     {
         if (!_isInitialized)
         {
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
index 206e1501bef..792331ef4d2 100644
--- a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -21,7 +21,7 @@ internal sealed class ConfigurationProvider : IConfigurationProvider
     /// <summary>
     /// The dictionary used for storing the BuildCheckConfiguration per projectfile and rule id. The key is equal to {projectFullPath}-{ruleId}.
     /// </summary>
-    private readonly ConcurrentDictionary<string, BuildExecutionCheckConfiguration> _buildExecutionCheckConfiguration = new ConcurrentDictionary<string, BuildExecutionCheckConfiguration>(StringComparer.InvariantCultureIgnoreCase);
+    private readonly ConcurrentDictionary<string, CheckConfiguration> _buildExecutionCheckConfiguration = new ConcurrentDictionary<string, CheckConfiguration>(StringComparer.InvariantCultureIgnoreCase);
 
     /// <summary>
     /// The dictionary used for storing the key-value pairs retrieved from the .editorconfigs for specific projectfile. The key is equal to projectFullPath.
@@ -102,12 +102,12 @@ internal void VerifyCustomConfigurationEquality(string ruleId, CustomConfigurati
         }
     }
 
-    public BuildExecutionCheckConfigurationEffective[] GetMergedConfigurations(
+    public CheckConfigurationEffective[] GetMergedConfigurations(
         string projectFullPath,
-        BuildExecutionCheck check)
+        Check check)
         => FillConfiguration(projectFullPath, check.SupportedRules, GetMergedConfiguration);
 
-    public BuildExecutionCheckConfiguration[] GetUserConfigurations(
+    public CheckConfiguration[] GetUserConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetUserConfiguration);
@@ -123,11 +123,11 @@ public CustomConfigurationData[] GetCustomConfigurations(
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetCustomConfiguration);
 
-    public BuildExecutionCheckConfigurationEffective[] GetMergedConfigurations(
-        BuildExecutionCheckConfiguration[] userConfigs,
-        BuildExecutionCheck check)
+    public CheckConfigurationEffective[] GetMergedConfigurations(
+        CheckConfiguration[] userConfigs,
+        Check check)
     {
-        var configurations = new BuildExecutionCheckConfigurationEffective[userConfigs.Length];
+        var configurations = new CheckConfigurationEffective[userConfigs.Length];
 
         for (int idx = 0; idx < userConfigs.Length; idx++)
         {
@@ -227,19 +227,19 @@ internal Dictionary<string, string> GetConfiguration(string projectFullPath, str
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <returns></returns>
-    internal BuildExecutionCheckConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
+    internal CheckConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
     {
         var cacheKey = $"{ruleId}-{projectFullPath}";
 
         var editorConfigValue = _buildExecutionCheckConfiguration.GetOrAdd(cacheKey, (key) =>
         {
-            BuildExecutionCheckConfiguration? editorConfig = BuildExecutionCheckConfiguration.Null;
+            CheckConfiguration? editorConfig = CheckConfiguration.Null;
             editorConfig.RuleId = ruleId;
             var config = GetConfiguration(projectFullPath, ruleId);
 
             if (config.Any())
             {
-                editorConfig = BuildExecutionCheckConfiguration.Create(config);
+                editorConfig = CheckConfiguration.Create(config);
             }
 
             return editorConfig;
@@ -255,44 +255,44 @@ internal BuildExecutionCheckConfiguration GetUserConfiguration(string projectFul
     /// <param name="projectFullPath"></param>
     /// <param name="checkRule"></param>
     /// <returns></returns>
-    internal BuildExecutionCheckConfigurationEffective GetMergedConfiguration(string projectFullPath, BuildExecutionCheckRule checkRule)
+    internal CheckConfigurationEffective GetMergedConfiguration(string projectFullPath, CheckRule checkRule)
         => GetMergedConfiguration(projectFullPath, checkRule.Id, checkRule.DefaultConfiguration);
 
-    internal BuildExecutionCheckConfigurationEffective MergeConfiguration(
+    internal CheckConfigurationEffective MergeConfiguration(
         string ruleId,
-        BuildExecutionCheckConfiguration defaultConfig,
-        BuildExecutionCheckConfiguration editorConfig)
-        => new BuildExecutionCheckConfigurationEffective(
+        CheckConfiguration defaultConfig,
+        CheckConfiguration editorConfig)
+        => new CheckConfigurationEffective(
             ruleId: ruleId,
             evaluationCheckScope: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.EvaluationCheckScope),
             severity: GetSeverityValue(editorConfig, defaultConfig));
 
-    private BuildExecutionCheckConfigurationEffective GetMergedConfiguration(
+    private CheckConfigurationEffective GetMergedConfiguration(
         string projectFullPath,
         string ruleId,
-        BuildExecutionCheckConfiguration defaultConfig)
+        CheckConfiguration defaultConfig)
         => MergeConfiguration(ruleId, defaultConfig, GetUserConfiguration(projectFullPath, ruleId));
 
     private T GetConfigValue<T>(
-        BuildExecutionCheckConfiguration editorConfigValue,
-        BuildExecutionCheckConfiguration defaultValue,
-        Func<BuildExecutionCheckConfiguration, T?> propertyGetter) where T : struct
+        CheckConfiguration editorConfigValue,
+        CheckConfiguration defaultValue,
+        Func<CheckConfiguration, T?> propertyGetter) where T : struct
         => propertyGetter(editorConfigValue) ??
            propertyGetter(defaultValue) ??
-           EnsureNonNull(propertyGetter(BuildExecutionCheckConfiguration.Default));
+           EnsureNonNull(propertyGetter(CheckConfiguration.Default));
 
-    private BuildExecutionCheckResultSeverity GetSeverityValue(BuildExecutionCheckConfiguration editorConfigValue, BuildExecutionCheckConfiguration defaultValue)
+    private CheckResultSeverity GetSeverityValue(CheckConfiguration editorConfigValue, CheckConfiguration defaultValue)
     {
-        BuildExecutionCheckResultSeverity? resultSeverity = null;
+        CheckResultSeverity? resultSeverity = null;
 
         // Consider Default as null, so the severity from the default value could be selected.
         // Default severity is not recognized by the infrastructure and serves for configuration purpuses only. 
-        if (editorConfigValue.Severity != null && editorConfigValue.Severity != BuildExecutionCheckResultSeverity.Default)
+        if (editorConfigValue.Severity != null && editorConfigValue.Severity != CheckResultSeverity.Default)
         {
             resultSeverity = editorConfigValue.Severity;
         }
 
-        resultSeverity ??= defaultValue.Severity ?? EnsureNonNull(BuildExecutionCheckConfiguration.Default.Severity);
+        resultSeverity ??= defaultValue.Severity ?? EnsureNonNull(CheckConfiguration.Default.Severity);
 
         return resultSeverity.Value;
     }
diff --git a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
index 04ffb953f05..ac8d8012e01 100644
--- a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
+++ b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
@@ -13,7 +13,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// Holder for the key-value pairs of unstructured data from .editorconfig file,
 ///  that were attribute to a particular rule, but were not recognized by the infrastructure.
-/// The configuration data that is recognized by the infrastructure is passed as <see cref="BuildExecutionCheckConfiguration"/>.
+/// The configuration data that is recognized by the infrastructure is passed as <see cref="CheckConfiguration"/>.
 /// </summary>
 public sealed class CustomConfigurationData
 {
diff --git a/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs
index ad85a8d90bc..e51903fb06e 100644
--- a/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs
@@ -8,17 +8,17 @@
 namespace Microsoft.Build.BuildCheck.Infrastructure;
 internal interface IConfigurationProvider
 {
-    BuildExecutionCheckConfiguration[] GetUserConfigurations(
+    CheckConfiguration[] GetUserConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds);
 
-    BuildExecutionCheckConfigurationEffective[] GetMergedConfigurations(
+    CheckConfigurationEffective[] GetMergedConfigurations(
         string projectFullPath,
-        BuildExecutionCheck check);
+        Check check);
 
-    BuildExecutionCheckConfigurationEffective[] GetMergedConfigurations(
-        BuildExecutionCheckConfiguration[] userConfigs,
-        BuildExecutionCheck check);
+    CheckConfigurationEffective[] GetMergedConfigurations(
+        CheckConfiguration[] userConfigs,
+        Check check);
 
     CustomConfigurationData[] GetCustomConfigurations(
         string projectFullPath,
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
index 12bf78f3d6c..fd33666fbd9 100644
--- a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -62,16 +62,16 @@ public abstract class CheckData(string projectFilePath, int? projectConfiguratio
 /// <typeparam name="T">The type of the actual data for checking.</typeparam>
 public class BuildCheckDataContext<T> where T : CheckData
 {
-    private readonly BuildExecutionCheckWrapper _executionCheckWrapper;
+    private readonly CheckWrapper _executionCheckWrapper;
     private readonly ICheckContext _checkContext;
-    private readonly BuildExecutionCheckConfigurationEffective[] _configPerRule;
-    private readonly Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult> _resultHandler;
+    private readonly CheckConfigurationEffective[] _configPerRule;
+    private readonly Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult> _resultHandler;
 
     internal BuildCheckDataContext(
-        BuildExecutionCheckWrapper checkWrapper,
+        CheckWrapper checkWrapper,
         ICheckContext loggingContext,
-        BuildExecutionCheckConfigurationEffective[] configPerRule,
-        Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult> resultHandler,
+        CheckConfigurationEffective[] configPerRule,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult> resultHandler,
         T data)
     {
         _executionCheckWrapper = checkWrapper;
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 8a5522f4d44..53df24ba2d9 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -2124,7 +2124,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <comment>The message is emitted when the custom check assembly can not be found.</comment>
   </data>
   <data name="CustomCheckBaseTypeNotAssignable" xml:space="preserve">
-    <value>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</value>
+    <value>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</value>
     <comment>The message is emitted when the custom check assembly can not be successfully registered.</comment>
   </data>
   <data name="TaskAssemblyLocationMismatch" xml:space="preserve">
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index a22b21d4017..c59ba7f91b5 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -223,8 +223,8 @@
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
-        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomCheckFailedAcquisition">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 3a2e4e99ea5..1da92bd2dc3 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -223,8 +223,8 @@
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
-        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomCheckFailedAcquisition">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index ec18fa79b62..df05725c5e4 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -223,8 +223,8 @@
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
-        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomCheckFailedAcquisition">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 125ea4f7bc5..4fb21225130 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -223,8 +223,8 @@
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
-        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomCheckFailedAcquisition">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 485cd119d8b..b2d59875e50 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -223,8 +223,8 @@
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
-        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomCheckFailedAcquisition">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index c4c60f53e06..b8d4ba74700 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -223,8 +223,8 @@
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
-        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomCheckFailedAcquisition">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index bf2b6f70923..82287483bf4 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -223,8 +223,8 @@
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
-        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomCheckFailedAcquisition">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 49c9b96373a..63ace7582fc 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -223,8 +223,8 @@
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
-        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomCheckFailedAcquisition">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 6f759738da8..f857b1890f2 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -223,8 +223,8 @@
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
-        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomCheckFailedAcquisition">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 28efa73db99..b5107f73d35 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -223,8 +223,8 @@
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
-        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomCheckFailedAcquisition">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 6e786ec9e08..21edf0d75d2 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -223,8 +223,8 @@
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
-        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomCheckFailedAcquisition">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 7f5f2d04230..350c89b3d35 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -223,8 +223,8 @@
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
-        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomCheckFailedAcquisition">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 2c6651e0933..4d3f605a97d 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -223,8 +223,8 @@
         <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
       <trans-unit id="CustomCheckBaseTypeNotAssignable">
-        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildExecutionCheck base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
         <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
       <trans-unit id="CustomCheckFailedAcquisition">
diff --git a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
index 719032158b2..d33261fc6d9 100644
--- a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
+++ b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
@@ -70,11 +70,11 @@ public void CheckCustomConfigurationDataValidity(string projectFullPath, string
 
     public CustomConfigurationData[] GetCustomConfigurations(string projectFullPath, IReadOnlyList<string> ruleIds) => [];
 
-    public BuildExecutionCheckConfigurationEffective[] GetMergedConfigurations(string projectFullPath, BuildExecutionCheck check) => [];
+    public CheckConfigurationEffective[] GetMergedConfigurations(string projectFullPath, Check check) => [];
 
-    public BuildExecutionCheckConfigurationEffective[] GetMergedConfigurations(BuildExecutionCheckConfiguration[] userConfigs, BuildExecutionCheck check) => [];
+    public CheckConfigurationEffective[] GetMergedConfigurations(CheckConfiguration[] userConfigs, Check check) => [];
 
-    public BuildExecutionCheckConfiguration[] GetUserConfigurations(string projectFullPath, IReadOnlyList<string> ruleIds) => [];
+    public CheckConfiguration[] GetUserConfigurations(string projectFullPath, IReadOnlyList<string> ruleIds) => [];
 }
 
 internal sealed class BuildCheckAcquisitionModuleMock : IBuildCheckAcquisitionModule
@@ -83,29 +83,29 @@ internal sealed class BuildCheckAcquisitionModuleMock : IBuildCheckAcquisitionMo
 
     internal BuildCheckAcquisitionModuleMock(bool isCheckRuleExistForTest) => _isCheckRuleExistForTest = isCheckRuleExistForTest;
 
-    public List<BuildExecutionCheckFactory> CreateBuildExecutionCheckFactories(CheckAcquisitionData checkAcquisitionData, ICheckContext checkContext)
+    public List<CheckFactory> CreateCheckFactories(CheckAcquisitionData checkAcquisitionData, ICheckContext checkContext)
         => _isCheckRuleExistForTest
-        ? new List<BuildExecutionCheckFactory>() { () => new BuildExecutionCheckRuleMock("Rule1"), () => new BuildExecutionCheckRuleMock("Rule2") }
-        : new List<BuildExecutionCheckFactory>();
+        ? new List<CheckFactory>() { () => new CheckRuleMock("Rule1"), () => new CheckRuleMock("Rule2") }
+        : new List<CheckFactory>();
 }
 
-internal sealed class BuildExecutionCheckRuleMock : BuildExecutionCheck
+internal sealed class CheckRuleMock : Check
 {
-    public static BuildExecutionCheckRule SupportedRule = new BuildExecutionCheckRule(
+    public static CheckRule SupportedRule = new CheckRule(
         "X01234",
         "Title",
         "Description",
         "Message format: {0}",
-        new BuildExecutionCheckConfiguration());
+        new CheckConfiguration());
 
-    internal BuildExecutionCheckRuleMock(string friendlyName)
+    internal CheckRuleMock(string friendlyName)
     {
         FriendlyName = friendlyName;
     }
 
     public override string FriendlyName { get; }
 
-    public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = new List<BuildExecutionCheckRule>() { SupportedRule };
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
diff --git a/src/BuildCheck.UnitTests/BuildExecutionCheckConfigurationEffectiveTests.cs b/src/BuildCheck.UnitTests/BuildExecutionCheckConfigurationEffectiveTests.cs
index db3a28f597e..12920740700 100644
--- a/src/BuildCheck.UnitTests/BuildExecutionCheckConfigurationEffectiveTests.cs
+++ b/src/BuildCheck.UnitTests/BuildExecutionCheckConfigurationEffectiveTests.cs
@@ -9,24 +9,24 @@
 
 namespace Microsoft.Build.BuildCheck.UnitTests;
 
-public class BuildExecutionCheckConfigurationEffectiveTests
+public class CheckConfigurationEffectiveTests
 {
     [Theory]
-    [InlineData("ruleId", EvaluationCheckScope.ProjectFileOnly, BuildExecutionCheckResultSeverity.Warning,  true)]
-    [InlineData("ruleId2", EvaluationCheckScope.ProjectFileOnly, BuildExecutionCheckResultSeverity.Warning,  true)]
-    [InlineData("ruleId", EvaluationCheckScope.ProjectFileOnly, BuildExecutionCheckResultSeverity.Error, false)]
+    [InlineData("ruleId", EvaluationCheckScope.ProjectFileOnly, CheckResultSeverity.Warning,  true)]
+    [InlineData("ruleId2", EvaluationCheckScope.ProjectFileOnly, CheckResultSeverity.Warning,  true)]
+    [InlineData("ruleId", EvaluationCheckScope.ProjectFileOnly, CheckResultSeverity.Error, false)]
     public void IsSameConfigurationAsTest(
         string secondRuleId,
         EvaluationCheckScope secondScope,
-        BuildExecutionCheckResultSeverity secondSeverity,
+        CheckResultSeverity secondSeverity,
         bool isExpectedToBeSame)
     {
-        BuildExecutionCheckConfigurationEffective configuration1 = new BuildExecutionCheckConfigurationEffective(
+        CheckConfigurationEffective configuration1 = new CheckConfigurationEffective(
                        ruleId: "ruleId",
                        evaluationCheckScope: EvaluationCheckScope.ProjectFileOnly,
-                       severity: BuildExecutionCheckResultSeverity.Warning);
+                       severity: CheckResultSeverity.Warning);
 
-        BuildExecutionCheckConfigurationEffective configuration2 = new BuildExecutionCheckConfigurationEffective(
+        CheckConfigurationEffective configuration2 = new CheckConfigurationEffective(
             ruleId: secondRuleId,
             evaluationCheckScope: secondScope,
             severity: secondSeverity);
@@ -35,13 +35,13 @@ public void IsSameConfigurationAsTest(
     }
 
     [Theory]
-    [InlineData( BuildExecutionCheckResultSeverity.Warning, true)]
-    [InlineData(BuildExecutionCheckResultSeverity.Suggestion, true)]
-    [InlineData(BuildExecutionCheckResultSeverity.Error, true)]
-    [InlineData(BuildExecutionCheckResultSeverity.None, false)]
-    public void BuildExecutionCheckConfigurationInternal_Constructor_SeverityConfig(BuildExecutionCheckResultSeverity severity, bool isEnabledExpected)
+    [InlineData( CheckResultSeverity.Warning, true)]
+    [InlineData(CheckResultSeverity.Suggestion, true)]
+    [InlineData(CheckResultSeverity.Error, true)]
+    [InlineData(CheckResultSeverity.None, false)]
+    public void CheckConfigurationInternal_Constructor_SeverityConfig(CheckResultSeverity severity, bool isEnabledExpected)
     {
-        BuildExecutionCheckConfigurationEffective configuration = new BuildExecutionCheckConfigurationEffective(
+        CheckConfigurationEffective configuration = new CheckConfigurationEffective(
                        ruleId: "ruleId",
                        evaluationCheckScope: EvaluationCheckScope.ProjectFileOnly,
                        severity: severity);
@@ -50,14 +50,14 @@ public void BuildExecutionCheckConfigurationInternal_Constructor_SeverityConfig(
     }
 
     [Fact]
-    public void BuildExecutionCheckConfigurationInternal_Constructor_SeverityConfig_Fails()
+    public void CheckConfigurationInternal_Constructor_SeverityConfig_Fails()
     {
         Should.Throw<ArgumentOutOfRangeException>(() =>
         {
-            new BuildExecutionCheckConfigurationEffective(
+            new CheckConfigurationEffective(
                         ruleId: "ruleId",
                         evaluationCheckScope: EvaluationCheckScope.ProjectFileOnly,
-                        severity: BuildExecutionCheckResultSeverity.Default);
+                        severity: CheckResultSeverity.Default);
         });
     }
 }
diff --git a/src/BuildCheck.UnitTests/BuildExecutionCheckConfiguration_Test.cs b/src/BuildCheck.UnitTests/BuildExecutionCheckConfiguration_Test.cs
index 2d01cdbc54e..3fd22bd8a46 100644
--- a/src/BuildCheck.UnitTests/BuildExecutionCheckConfiguration_Test.cs
+++ b/src/BuildCheck.UnitTests/BuildExecutionCheckConfiguration_Test.cs
@@ -9,12 +9,12 @@
 
 namespace Microsoft.Build.BuildCheck.UnitTests;
 
-public class BuildExecutionCheckConfiguration_Test
+public class CheckConfiguration_Test
 {
     [Fact]
     public void CreateWithNull_ReturnsObjectWithNullValues()
     {
-        var buildConfig = BuildExecutionCheckConfiguration.Create(null);
+        var buildConfig = CheckConfiguration.Create(null);
         buildConfig.ShouldNotBeNull();
         buildConfig.Severity.ShouldBeNull();
         buildConfig.IsEnabled.ShouldBeNull();
@@ -24,7 +24,7 @@ public void CreateWithNull_ReturnsObjectWithNullValues()
     [Fact]
     public void CreateWithEmpty_ReturnsObjectWithNullValues()
     {
-        var buildConfig = BuildExecutionCheckConfiguration.Create(new Dictionary<string, string>());
+        var buildConfig = CheckConfiguration.Create(new Dictionary<string, string>());
         buildConfig.ShouldNotBeNull();
         buildConfig.Severity.ShouldBeNull();
         buildConfig.IsEnabled.ShouldBeNull();
@@ -32,24 +32,24 @@ public void CreateWithEmpty_ReturnsObjectWithNullValues()
     }
 
     [Theory]
-    [InlineData("error", BuildExecutionCheckResultSeverity.Error)]
-    [InlineData("ERROR", BuildExecutionCheckResultSeverity.Error)]
-    [InlineData("suggestion", BuildExecutionCheckResultSeverity.Suggestion)]
-    [InlineData("SUGGESTION", BuildExecutionCheckResultSeverity.Suggestion)]
-    [InlineData("warning", BuildExecutionCheckResultSeverity.Warning)]
-    [InlineData("WARNING", BuildExecutionCheckResultSeverity.Warning)]
-    [InlineData("NONE", BuildExecutionCheckResultSeverity.None)]
-    [InlineData("none", BuildExecutionCheckResultSeverity.None)]
-    [InlineData("default", BuildExecutionCheckResultSeverity.Default)]
-    [InlineData("DEFAULT", BuildExecutionCheckResultSeverity.Default)]
-    public void CreateBuildExecutionCheckConfiguration_Severity(string parameter, BuildExecutionCheckResultSeverity? expected)
+    [InlineData("error", CheckResultSeverity.Error)]
+    [InlineData("ERROR", CheckResultSeverity.Error)]
+    [InlineData("suggestion", CheckResultSeverity.Suggestion)]
+    [InlineData("SUGGESTION", CheckResultSeverity.Suggestion)]
+    [InlineData("warning", CheckResultSeverity.Warning)]
+    [InlineData("WARNING", CheckResultSeverity.Warning)]
+    [InlineData("NONE", CheckResultSeverity.None)]
+    [InlineData("none", CheckResultSeverity.None)]
+    [InlineData("default", CheckResultSeverity.Default)]
+    [InlineData("DEFAULT", CheckResultSeverity.Default)]
+    public void CreateCheckConfiguration_Severity(string parameter, CheckResultSeverity? expected)
     {
         var config = new Dictionary<string, string>()
         {
             { "severity" , parameter },
         };
 
-        var buildConfig = BuildExecutionCheckConfiguration.Create(config);
+        var buildConfig = CheckConfiguration.Create(config);
 
         buildConfig.ShouldNotBeNull();
         buildConfig.Severity.ShouldBe(expected);
@@ -62,14 +62,14 @@ public void CreateBuildExecutionCheckConfiguration_Severity(string parameter, Bu
     [InlineData("suggestion", true)]
     [InlineData("none", false)]
     [InlineData("default", null)]
-    public void CreateBuildExecutionCheckConfiguration_SeverityAndEnabledOrder(string parameter, bool? expected)
+    public void CreateCheckConfiguration_SeverityAndEnabledOrder(string parameter, bool? expected)
     {
         var config = new Dictionary<string, string>()
         {
             { "severity", parameter },
         };
         
-        var buildConfig = BuildExecutionCheckConfiguration.Create(config);
+        var buildConfig = CheckConfiguration.Create(config);
 
         buildConfig.IsEnabled.ShouldBe(expected);
     }
@@ -82,14 +82,14 @@ public void CreateBuildExecutionCheckConfiguration_SeverityAndEnabledOrder(strin
     [InlineData("WORK_TREE_IMPORTS", EvaluationCheckScope.WorkTreeImports)]
     [InlineData("all", EvaluationCheckScope.All)]
     [InlineData("ALL", EvaluationCheckScope.All)]
-    public void CreateBuildExecutionCheckConfiguration_EvaluationCheckScope(string parameter, EvaluationCheckScope? expected)
+    public void CreateCheckConfiguration_EvaluationCheckScope(string parameter, EvaluationCheckScope? expected)
     {
         var config = new Dictionary<string, string>()
         {
             { "scope" , parameter },
         };
 
-        var buildConfig = BuildExecutionCheckConfiguration.Create(config);
+        var buildConfig = CheckConfiguration.Create(config);
 
         buildConfig.ShouldNotBeNull();
         buildConfig.EvaluationCheckScope.ShouldBe(expected);
@@ -101,7 +101,7 @@ public void CreateBuildExecutionCheckConfiguration_EvaluationCheckScope(string p
     [Theory]
     [InlineData("scope", "incorrec-value")]
     [InlineData("severity", "incorrec-value")]
-    public void CreateBuildExecutionCheckConfiguration_ExceptionOnInvalidInputValue(string key, string value)
+    public void CreateCheckConfiguration_ExceptionOnInvalidInputValue(string key, string value)
     {
         var config = new Dictionary<string, string>()
         {
@@ -110,7 +110,7 @@ public void CreateBuildExecutionCheckConfiguration_ExceptionOnInvalidInputValue(
 
         var exception = Should.Throw<BuildCheckConfigurationException>(() =>
         {
-            BuildExecutionCheckConfiguration.Create(config);
+            CheckConfiguration.Create(config);
         });
         exception.Message.ShouldContain($"Incorrect value provided in config for key {key}");
     }
diff --git a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
index be79a12a9e7..3871bc2e961 100644
--- a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
+++ b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
@@ -117,7 +117,7 @@ public void GetRuleIdConfiguration_ReturnsBuildRuleConfiguration()
         buildConfig.ShouldNotBeNull();
 
         buildConfig.IsEnabled.ShouldBe(true);
-        buildConfig.Severity.ShouldBe(BuildExecutionCheckResultSeverity.Error);
+        buildConfig.Severity.ShouldBe(CheckResultSeverity.Error);
         buildConfig.EvaluationCheckScope.ShouldBe(EvaluationCheckScope.ProjectFileOnly);
     }
 
@@ -216,27 +216,27 @@ public void GetRuleIdConfiguration_CustomConfigurationValidity_Valid()
     }
 
     [Theory]
-    [InlineData(BuildExecutionCheckResultSeverity.Warning, BuildExecutionCheckResultSeverity.Warning, true)]
-    [InlineData(BuildExecutionCheckResultSeverity.Error, BuildExecutionCheckResultSeverity.Error, true)]
-    [InlineData(BuildExecutionCheckResultSeverity.Default, BuildExecutionCheckResultSeverity.Warning, true)]
-    [InlineData(BuildExecutionCheckResultSeverity.Suggestion, BuildExecutionCheckResultSeverity.Suggestion, true)]
-    [InlineData(BuildExecutionCheckResultSeverity.None, BuildExecutionCheckResultSeverity.None, false)]
-    [InlineData(null, BuildExecutionCheckResultSeverity.Warning, true)]
-    public void GetConfigurationProvider_MergesSeverity_Correctly(BuildExecutionCheckResultSeverity? buildExecutionCheckResultSeverity, BuildExecutionCheckResultSeverity expectedSeverity, bool expectedEnablment)
+    [InlineData(CheckResultSeverity.Warning, CheckResultSeverity.Warning, true)]
+    [InlineData(CheckResultSeverity.Error, CheckResultSeverity.Error, true)]
+    [InlineData(CheckResultSeverity.Default, CheckResultSeverity.Warning, true)]
+    [InlineData(CheckResultSeverity.Suggestion, CheckResultSeverity.Suggestion, true)]
+    [InlineData(CheckResultSeverity.None, CheckResultSeverity.None, false)]
+    [InlineData(null, CheckResultSeverity.Warning, true)]
+    public void GetConfigurationProvider_MergesSeverity_Correctly(CheckResultSeverity? buildExecutionCheckResultSeverity, CheckResultSeverity expectedSeverity, bool expectedEnablment)
     {
         var configurationProvider = new ConfigurationProvider();
-        BuildExecutionCheckConfiguration buildExecutionCheckConfiguration = new BuildExecutionCheckConfiguration()
+        CheckConfiguration buildExecutionCheckConfiguration = new CheckConfiguration()
         {
             Severity = buildExecutionCheckResultSeverity
         };
 
-        BuildExecutionCheckConfiguration defaultValue = new BuildExecutionCheckConfiguration()
+        CheckConfiguration defaultValue = new CheckConfiguration()
         {
-            Severity = BuildExecutionCheckResultSeverity.Warning
+            Severity = CheckResultSeverity.Warning
         };
 
-        var internalBuildExecutionCheck = configurationProvider.MergeConfiguration("ruleId", defaultValue, buildExecutionCheckConfiguration);
-        internalBuildExecutionCheck.Severity.ShouldBe(expectedSeverity);
-        internalBuildExecutionCheck.IsEnabled.ShouldBe(expectedEnablment);
+        var internalCheck = configurationProvider.MergeConfiguration("ruleId", defaultValue, buildExecutionCheckConfiguration);
+        internalCheck.Severity.ShouldBe(expectedSeverity);
+        internalCheck.IsEnabled.ShouldBe(expectedEnablment);
     }
 }
diff --git a/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs b/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
index 9ba383dec85..c773fefbc11 100644
--- a/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
+++ b/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
@@ -53,7 +53,7 @@ public void TestCopyTask()
                 }));
 
             _registrationContext.Results.Count.ShouldBe(1);
-            _registrationContext.Results[0].BuildExecutionCheckRule.Id.ShouldBe("BC0102");
+            _registrationContext.Results[0].CheckRule.Id.ShouldBe("BC0102");
         }
 
         [Theory]
@@ -74,7 +74,7 @@ public void TestCompilerTask(string taskName)
             }
 
             _registrationContext.Results.Count.ShouldBe(4);
-            _registrationContext.Results.ForEach(result => result.BuildExecutionCheckRule.Id.ShouldBe("BC0102"));
+            _registrationContext.Results.ForEach(result => result.CheckRule.Id.ShouldBe("BC0102"));
         }
     }
 }
diff --git a/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs b/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs
index 38f2a985dd5..5ead0d0369f 100644
--- a/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs
+++ b/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs
@@ -49,7 +49,7 @@ public void TriggerEvaluatedPropertiesAction(EvaluatedPropertiesCheckData data)
             }
         }
 
-        private void ResultHandler(BuildExecutionCheckWrapper wrapper, ICheckContext context, BuildExecutionCheckConfigurationEffective[] configs, BuildCheckResult result)
+        private void ResultHandler(CheckWrapper wrapper, ICheckContext context, CheckConfigurationEffective[] configs, BuildCheckResult result)
             => Results.Add(result);
     }
 }
diff --git a/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs b/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs
index 7a66648c75f..629775901a4 100644
--- a/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs
+++ b/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs
@@ -86,8 +86,8 @@ public void TestProjectsWithDifferentPathsSeparators()
 
             // 2 reports for bin and obj folders.
             _registrationContext.Results.Count.ShouldBe(2);
-            _registrationContext.Results[0].BuildExecutionCheckRule.Id.ShouldBe("BC0101");
-            _registrationContext.Results[1].BuildExecutionCheckRule.Id.ShouldBe("BC0101");
+            _registrationContext.Results[0].CheckRule.Id.ShouldBe("BC0101");
+            _registrationContext.Results[1].CheckRule.Id.ShouldBe("BC0101");
 
             // Check that paths are formed with correct paths separators
             string wrongPathSeparator = NativeMethodsShared.IsWindows ? "/" : "\\";
@@ -131,7 +131,7 @@ public void TestThreeProjectsWithSameOutputPath()
             _registrationContext.Results.Count.ShouldBe(4); // 4 reports for two pairs of project: (1, 2) and (1, 3).
             foreach (var result in _registrationContext.Results)
             {
-                result.BuildExecutionCheckRule.Id.ShouldBe("BC0101");
+                result.CheckRule.Id.ShouldBe("BC0101");
             }
         }
     }
diff --git a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
index edd60254fa9..7d109f7da15 100644
--- a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
+++ b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
@@ -19,16 +19,16 @@ namespace Microsoft.Build.BuildCheck.UnitTests
 {
     public class TaskInvocationCheckDataTests : IDisposable
     {
-        internal sealed class TestCheck : BuildExecutionCheck
+        internal sealed class TestCheck : Check
         {
-            #region BuildExecutionCheck initialization
+            #region Check initialization
 
-            public static BuildExecutionCheckRule SupportedRule = new BuildExecutionCheckRule("BC0000", "TestRule", "TestDescription", "TestMessage",
-                new BuildExecutionCheckConfiguration() { Severity = BuildExecutionCheckResultSeverity.Warning });
+            public static CheckRule SupportedRule = new CheckRule("BC0000", "TestRule", "TestDescription", "TestMessage",
+                new CheckConfiguration() { Severity = CheckResultSeverity.Warning });
 
             public override string FriendlyName => "MSBuild.TestCheck";
 
-            public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = [SupportedRule];
+            public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
 
             public override void Initialize(ConfigurationContext configurationContext)
             { }
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check1.cs b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check1.cs
index b7f1ac7ab2b..940791d3705 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check1.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check1.cs
@@ -4,18 +4,18 @@
 
 namespace CustomCheck
 {
-    public sealed class Check1 : BuildExecutionCheck
+    public sealed class Check1 : Check
     {
-        public static BuildExecutionCheckRule SupportedRule = new BuildExecutionCheckRule(
+        public static CheckRule SupportedRule = new CheckRule(
             "X01234",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildExecutionCheckConfiguration());
+            new CheckConfiguration());
 
         public override string FriendlyName => "CustomRule1";
 
-        public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = new List<BuildExecutionCheckRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check2.cs b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check2.cs
index 58fdc998478..4517f8eeee6 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check2.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check2.cs
@@ -4,18 +4,18 @@
 
 namespace CustomCheck
 {
-    public sealed class Check2 : BuildExecutionCheck
+    public sealed class Check2 : Check
     {
-        public static BuildExecutionCheckRule SupportedRule = new BuildExecutionCheckRule(
+        public static CheckRule SupportedRule = new CheckRule(
             "X01235",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildExecutionCheckConfiguration());
+            new CheckConfiguration());
 
         public override string FriendlyName => "CustomRule2";
 
-        public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = new List<BuildExecutionCheckRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/Check3.cs b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/Check3.cs
index 76cd522b1f5..528b29e224a 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/Check3.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/Check3.cs
@@ -4,18 +4,18 @@
 
 namespace CustomCheck2
 {
-    public sealed class Check3 : BuildExecutionCheck
+    public sealed class Check3 : Check
     {
-        public static BuildExecutionCheckRule SupportedRule = new BuildExecutionCheckRule(
+        public static CheckRule SupportedRule = new CheckRule(
             "X01235",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildExecutionCheckConfiguration());
+            new CheckConfiguration());
 
         public override string FriendlyName => "CustomRule3";
 
-        public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = new List<BuildExecutionCheckRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
diff --git a/template_feed/content/Microsoft.CheckTemplate/Check1.cs b/template_feed/content/Microsoft.CheckTemplate/Check1.cs
index 135a014fc55..2a44afef40c 100644
--- a/template_feed/content/Microsoft.CheckTemplate/Check1.cs
+++ b/template_feed/content/Microsoft.CheckTemplate/Check1.cs
@@ -4,9 +4,9 @@
 
 namespace Company.CheckTemplate
 {
-    public sealed class Check1 : BuildExecutionCheck
+    public sealed class Check1 : Check
     {
-        public static BuildCheckRule SupportedRule = new BuildExecutionCheckRule(
+        public static BuildCheckRule SupportedRule = new CheckRule(
             "X01234",
             "Title",
             "Description",
@@ -15,7 +15,7 @@ public sealed class Check1 : BuildExecutionCheck
 
         public override string FriendlyName => "Company.Check1";
 
-        public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = new List<BuildExecutionCheckRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
