diff --git a/.config/1espt/PipelineAutobaseliningConfig.yml b/.config/1espt/PipelineAutobaseliningConfig.yml
index 4b30629dd08..55a0bde69cd 100644
--- a/.config/1espt/PipelineAutobaseliningConfig.yml
+++ b/.config/1espt/PipelineAutobaseliningConfig.yml
@@ -1,26 +1,26 @@
-## DO NOT MODIFY THIS FILE MANUALLY. This is part of auto-baselining from 1ES Pipeline Templates. Go to [https://aka.ms/1espt-autobaselining] for more details.
-
-pipelines:
-  9434:
-    retail:
-      source:
-        credscan:
-          lastModifiedDate: 2024-03-14
-        eslint:
-          lastModifiedDate: 2024-03-14
-        psscriptanalyzer:
-          lastModifiedDate: 2024-03-14
-        armory:
-          lastModifiedDate: 2024-03-14
+## DO NOT MODIFY THIS FILE MANUALLY. This is part of auto-baselining from 1ES Pipeline Templates. Go to [https://aka.ms/1espt-autobaselining] for more details.
+
+pipelines:
+  9434:
+    retail:
+      source:
+        credscan:
+          lastModifiedDate: 2024-03-14
+        eslint:
+          lastModifiedDate: 2024-03-14
+        psscriptanalyzer:
+          lastModifiedDate: 2024-03-14
+        armory:
+          lastModifiedDate: 2024-03-14
         policheck:
           lastModifiedDate: 2024-10-09
-      binary:
-        credscan:
-          lastModifiedDate: 2024-03-14
-        binskim:
+      binary:
+        credscan:
+          lastModifiedDate: 2024-03-14
+        binskim:
           lastModifiedDate: 2024-11-27
         spotbugs:
-          lastModifiedDate: 2024-03-14
+          lastModifiedDate: 2024-03-14
   24295:
     retail:
       source:
@@ -37,5 +37,23 @@ pipelines:
           lastModifiedDate: 2024-11-06
         binskim:
           lastModifiedDate: 2024-11-21
-        spotbugs:
+        spotbugs:
           lastModifiedDate: 2024-11-06
+  24263:
+    retail:
+      source:
+        credscan:
+          lastModifiedDate: 2024-12-19
+        eslint:
+          lastModifiedDate: 2024-12-19
+        psscriptanalyzer:
+          lastModifiedDate: 2024-12-19
+        armory:
+          lastModifiedDate: 2024-12-19
+      binary:
+        credscan:
+          lastModifiedDate: 2024-12-19
+        binskim:
+          lastModifiedDate: 2024-12-19
+        spotbugs:
+          lastModifiedDate: 2024-12-19
diff --git a/.config/git-merge-flow-config.jsonc b/.config/git-merge-flow-config.jsonc
index 6650f6299ff..0f5474173b2 100644
--- a/.config/git-merge-flow-config.jsonc
+++ b/.config/git-merge-flow-config.jsonc
@@ -10,15 +10,11 @@
         "vs17.0": {
             "MergeToBranch": "vs17.3"
         },
-        // Automate opening PRs to merge msbuild's vs17.3 (SDK 6.0.4xx) into vs17.6 (VS until 1/2025)
+        // Automate opening PRs to merge msbuild's vs17.3 (SDK 6.0.4xx) into vs17.8 (SDK 8.0.1xx, VS until 7/2025)
         "vs17.3": {
-            "MergeToBranch": "vs17.6"
-        },
-        // Automate opening PRs to merge msbuild's vs17.6 into vs17.8 (VS until 7/2025)
-        "vs17.6": {
             "MergeToBranch": "vs17.8"
         },
-        // Automate opening PRs to merge msbuild's vs17.8 (SDK 8.0.1xx) into vs17.10 (SDK 8.0.3xx)
+        // Automate opening PRs to merge msbuild's vs17.8 (SDK 8.0.1xx) into vs17.10 (SDK 8.0.3xx, VS until 1/2026)
         "vs17.8": {
             "MergeToBranch": "vs17.10"
         },
@@ -26,7 +22,7 @@
         "vs17.10": {
             "MergeToBranch": "vs17.11"
         },
-        // Automate opening PRs to merge msbuild's vs17.11 (SDK 8.0.4xx) into vs17.12 (SDK 9.0.1xx)
+        // Automate opening PRs to merge msbuild's vs17.11 (SDK 8.0.4xx) into vs17.12 (SDK 9.0.1xx, VS until 7/2026)
         "vs17.11": {
             "MergeToBranch": "vs17.12"
         },
@@ -34,8 +30,12 @@
         "vs17.12": {
             "MergeToBranch": "vs17.13"
         },
-        // MSBuild latest release to main
+        // Automate opening PRs to merge msbuild's vs17.13 (SDK 9.0.2xx) into vs17.14 (SDK 9.0.3xx)
         "vs17.13": {
+            "MergeToBranch": "vs17.14"
+        },
+        // MSBuild latest release to main
+        "vs17.14": {
             "MergeToBranch": "main"
         }
     }
diff --git a/.config/guardian/.gdnbaselines b/.config/guardian/.gdnbaselines
index c021f9636e6..fb075241ccb 100644
--- a/.config/guardian/.gdnbaselines
+++ b/.config/guardian/.gdnbaselines
@@ -60,9 +60,9 @@
       ],
       "tool": "credscan",
       "ruleId": "CSCAN-GENERAL0020",
-      "createdDate": "2024-11-06 10:51:54Z",
-      "expirationDate": "2025-04-25 11:21:52Z",
-      "justification": "This error is baselined with an expiration date of 180 days from 2024-11-06 11:21:52Z"
+      "createdDate": "2024-12-19 06:42:54Z",
+      "expirationDate": "2025-06-07 07:02:56Z",
+      "justification": "This error is baselined with an expiration date of 180 days from 2024-12-19 07:02:56Z"
     }
   }
 }
\ No newline at end of file
diff --git a/.exp-insertions.yml b/.exp-insertions.yml
index 40aa1dda370..dac0bddd22a 100644
--- a/.exp-insertions.yml
+++ b/.exp-insertions.yml
@@ -152,7 +152,7 @@ jobs:
       command: restore
       feedsToUse: config
       restoreSolution: '$(Build.SourcesDirectory)\eng\common\internal\Tools.csproj'
-      nugetConfigPath: '$(Build.SourcesDirectory)\NuGet.config'
+      nugetConfigPath: '$(Build.SourcesDirectory)\eng\common\internal\NuGet.config'
       restoreDirectory: '$(Build.SourcesDirectory)\.packages'
 
   # https://eng.ms/docs/cloud-ai-platform/devdiv/one-engineering-system-1es/1es-docs/1es-security-configuration/configuration-guides/pat-burndown-guidance#authentication-from-pipelines
diff --git a/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml b/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml
index c97de85decf..24498a60544 100644
--- a/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml
+++ b/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml
@@ -6,6 +6,10 @@ on:
     paths:
       - 'eng/Versions.props'
 
+permissions:
+  contents: write
+  pull-requests: write
+
 jobs:
   Sync-version:
     runs-on: ubuntu-latest
diff --git a/.opt-prof.yml b/.opt-prof.yml
index ee9d1649fee..38796eed3b8 100644
--- a/.opt-prof.yml
+++ b/.opt-prof.yml
@@ -57,7 +57,6 @@ stages:
     cloudBuildResourceName: ComponentBuildUnderTest
     testLabPoolName: VS-Platform # The test lab pool to run your tests in
     testMachineCleanUpStrategy: ${{parameters.testMachineCleanUpStrategy}}
-    testMachineImageName: Windows-11-Enterprise-23H2
     visualStudioSigning: Test
     variables:
     - name: branchName # The branch in the VS repo the bootstrapper was based on
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 60a757b7803..624666c9360 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -3,6 +3,16 @@ trigger:
 - exp/*
 - vs*
 
+variables:
+- ${{ if eq(variables['System.TeamProject'], 'DevDiv') }}:
+  - group: AzureDevOps-Artifact-Feeds-Pats
+- name: cfsNugetWarnLevel
+  value: warn
+- name: nugetMultiFeedWarnLevel
+  value: none
+- name: NugetSecurityAnalysisWarningLevel
+  value: none
+
 jobs:
 - job: CheckVersionBumpOnReleaseBranches
   displayName: "Check Version Bump On Release Branches"
@@ -65,6 +75,14 @@ jobs:
   pool:
     vmImage: 'windows-2022'
   steps:
+  - ${{ if eq(variables['System.TeamProject'], 'DevDiv') }}:
+    - task: PowerShell@2
+      displayName: Setup Private Feeds Credentials
+      inputs:
+        filePath: $(Build.SourcesDirectory)/eng/common/SetupNugetSources.ps1
+        arguments: -ConfigFile $(Build.SourcesDirectory)/NuGet.config -Password $Env:Token
+      env:
+        Token: $(dn-bot-dnceng-artifact-feeds-rw)
   - task: BatchScript@1
     displayName: cibuild_bootstrapped_msbuild.cmd
     inputs:
@@ -136,11 +154,21 @@ jobs:
   pool:
     vmImage: 'windows-2022'
   steps:
+  - ${{ if eq(variables['System.TeamProject'], 'DevDiv') }}:
+    - task: PowerShell@2
+      displayName: Setup Private Feeds Credentials
+      inputs:
+        filePath: $(Build.SourcesDirectory)/eng/common/SetupNugetSources.ps1
+        arguments: -ConfigFile $(Build.SourcesDirectory)/NuGet.config -Password $Env:Token
+      env:
+        Token: $(dn-bot-dnceng-artifact-feeds-rw)
   - task: BatchScript@1
     displayName: cibuild_bootstrapped_msbuild.cmd
     inputs:
       filename: 'eng/cibuild_bootstrapped_msbuild.cmd'
       arguments: '-msbuildEngine dotnet -onlyDocChanged $(onlyDocChanged)'
+    env:
+      MSBUILDUSESERVER: "1"
   - task: PublishTestResults@2
     displayName: Publish .NET Framework Test Results
     inputs:
@@ -191,6 +219,14 @@ jobs:
       name: VSEngSS-MicroBuild2022-1ES
       demands: agent.os -equals Windows_NT
   steps:
+  - ${{ if eq(variables['System.TeamProject'], 'DevDiv') }}:
+    - task: PowerShell@2
+      displayName: Setup Private Feeds Credentials
+      inputs:
+        filePath: $(Build.SourcesDirectory)/eng/common/SetupNugetSources.ps1
+        arguments: -ConfigFile $(Build.SourcesDirectory)/NuGet.config -Password $Env:Token
+      env:
+        Token: $(dn-bot-dnceng-artifact-feeds-rw)
   - task: BatchScript@1
     displayName: cibuild.cmd
     inputs:
@@ -265,8 +301,18 @@ jobs:
   pool:
     vmImage: 'ubuntu-latest'
   steps:
+  - ${{ if eq(variables['System.TeamProject'], 'DevDiv') }}:
+    - task: Bash@3
+      displayName: Setup Private Feeds Credentials
+      inputs:
+        filePath: $(Build.SourcesDirectory)/eng/common/SetupNugetSources.sh
+        arguments: $(Build.SourcesDirectory)/NuGet.config $Token
+      env:
+        Token: $(dn-bot-dnceng-artifact-feeds-rw)
   - bash: . 'eng/cibuild_bootstrapped_msbuild.sh' --onlyDocChanged $(onlyDocChanged)
     displayName: CI Build
+    env: 
+        MSBUILDUSESERVER: "1"
   - task: PublishTestResults@2
     displayName: Publish .NET Test Results
     inputs:
@@ -322,8 +368,18 @@ jobs:
   pool:
     vmImage: 'macOS-latest'
   steps:
+  - ${{ if eq(variables['System.TeamProject'], 'DevDiv') }}:
+    - task: Bash@3
+      displayName: Setup Private Feeds Credentials
+      inputs:
+        filePath: $(Build.SourcesDirectory)/eng/common/SetupNugetSources.sh
+        arguments: $(Build.SourcesDirectory)/NuGet.config $Token
+      env:
+        Token: $(dn-bot-dnceng-artifact-feeds-rw)
   - bash: . 'eng/cibuild_bootstrapped_msbuild.sh' --onlyDocChanged $(onlyDocChanged)
     displayName: CI Build
+    env: 
+        MSBUILDUSESERVER: "1"
   - task: PublishTestResults@2
     displayName: Publish .NET Test Results
     inputs:
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index bf994785873..d1b60b226d6 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -37,6 +37,13 @@ variables:
     value: true # Enable loc for vs17.14
   - name: Codeql.Enabled
     value: true
+  - group: AzureDevOps-Artifact-Feeds-Pats
+  - name: cfsNugetWarnLevel
+    value: warn
+  - name: nugetMultiFeedWarnLevel
+    value: none
+  - name: NugetSecurityAnalysisWarningLevel
+    value: none
 
 resources:
   repositories:
@@ -119,6 +126,17 @@ extends:
         steps:
         - task: NuGetToolInstaller@1
           displayName: 'Install NuGet.exe'
+        - pwsh: Get-MpComputerStatus
+
+        - pwsh: Set-MpPreference -DisableRealtimeMonitoring $true
+
+        - task: PowerShell@2
+          displayName: Setup Private Feeds Credentials
+          inputs:
+            filePath: $(Build.SourcesDirectory)/eng/common/SetupNugetSources.ps1
+            arguments: -ConfigFile $(Build.SourcesDirectory)/NuGet.config -Password $Env:Token
+          env:
+            Token: $(dn-bot-dnceng-artifact-feeds-rw)
 
         - task: NuGetCommand@2
           displayName: Restore internal tools
@@ -126,7 +144,7 @@ extends:
             command: restore
             feedsToUse: config
             restoreSolution: 'eng\common\internal\Tools.csproj'
-            nugetConfigPath: 'NuGet.config'
+            nugetConfigPath: 'eng\common\internal\NuGet.config'
             restoreDirectory: '$(Build.SourcesDirectory)\.packages'
 
         - task: ms-vseng.MicroBuildTasks.30666190-6959-11e5-9f96-f56098202fef.MicroBuildSigningPlugin@1
diff --git a/NuGet.config b/NuGet.config
index 107cd4542dc..a11137a9563 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -13,6 +13,14 @@
     <add key="dotnet8" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json" />
     <add key="dotnet8-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json" />
     <add key="dotnet9" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet9/nuget/v3/index.json" />
+    <add key="dotnet9-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet9-transport/nuget/v3/index.json" />
+    <add key="vs-impl" value="https://pkgs.dev.azure.com/azure-public/vside/_packaging/vs-impl/nuget/v3/index.json" />
+    <!-- We don't want other than VS OpenTelemetry libraries from vs-impl -->
+    <packageSourceMapping>
+      <packageSource key="vs-impl">
+        <package pattern="Microsoft.VisualStudio.OpenTelemetry*" />
+      </packageSource>
+    </packageSourceMapping>
   </packageSources>
   <disabledPackageSources>
     <!--Begin: Package sources managed by Dependency Flow automation. Do not edit the sources below.-->
diff --git a/THIRDPARTYNOTICES.txt b/THIRDPARTYNOTICES.txt
index 28661c086ad..49e551d4279 100644
--- a/THIRDPARTYNOTICES.txt
+++ b/THIRDPARTYNOTICES.txt
@@ -1,7 +1,7 @@
-MSBuild uses third-party material as listed below. The attached notices are 
-provided for informational purposes only. 
+MSBuild uses third-party material as listed below. The attached notices are
+provided for informational purposes only.
 
-Notice for LockCheck 
+Notice for LockCheck
 -------------------------------
 The MIT License (MIT)
 
@@ -27,20 +27,49 @@ SOFTWARE.
 
 -------------------------------
 
-Notice for Samples for xUnit.net 
+Notice for Samples for xUnit.net
 -------------------------------
 
-Copyright (c) .NET Foundation and Contributors 
+Copyright (c) .NET Foundation and Contributors
 
-All Rights Reserved 
+All Rights Reserved
 
 Licensed under the Apache License, Version 2.0 (the "License"); you may not use
-this file except in compliance with the License. 
+this file except in compliance with the License.
 
-You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 
+You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing, software distributed
 under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 language governing permissions and limitations under the License.
+
+-------------------------------
+
+Notice for OpenTelemetry .NET
+-------------------------------
+MSBuild.exe is distributed with OpenTelemetry .NET binaries.
+
+Copyright (c) OpenTelemetry Authors
+Source:       https://github.com/open-telemetry/opentelemetry-dotnet
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software distributed
+under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
+CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
+language governing permissions and limitations under the License.
+
+-------------------------------
+
+Notice for Microsoft.VisualStudio.OpenTelemetry.*
 -------------------------------
+MSBuild.exe is distributed with Microsoft.VisualStudio.OpenTelemetry.* binaries.
+
+Project:      Microsoft.VisualStudio.OpenTelemetry
+Copyright:    (c) Microsoft Corporation
+License:      https://visualstudio.microsoft.com/license-terms/mt736442/
\ No newline at end of file
diff --git a/azure-pipelines/vs-insertion.yml b/azure-pipelines/vs-insertion.yml
index 01178c98a5e..2f8d8732f04 100644
--- a/azure-pipelines/vs-insertion.yml
+++ b/azure-pipelines/vs-insertion.yml
@@ -2,9 +2,9 @@
 # To achieve insertion automation, this pipeline definition yml has to be on servicing branches and main.
 
 
-# Runs in 3 modes: 
+# Runs in 3 modes:
 # 1. daily main insertion from latest main CI.
-#   - can be disabled in the UI by adding a custom schedule for any branch. 
+#   - can be disabled in the UI by adding a custom schedule for any branch.
 # 2. trigger insert as a followup to a servicing CI run.
 #   - can be disabled in the UI by adding a custom CI trigger.
 # 3. manual insertion - select manually the TargetBranch and inserted CI run.
@@ -44,6 +44,7 @@ parameters:
     values:
       - auto
       - main
+      - rel/d17.14
       - rel/d17.13
       - rel/d17.12
       - rel/d17.11
@@ -56,11 +57,17 @@ parameters:
     default: 183
     type: number
     displayName: 'Drop Retention Days (do not set to < 90)'
+  - name: SkipUploadingPackages
+    default: false
+    type: boolean
+    displayName: 'Skip uploading packages (set to true if inserting the same version multiple times)'
 
 variables:
   # `auto` should work every time and selecting a branch in parameters is likely to fail due to incompatible versions in MSBuild and VS
   - name: AutoInsertTargetBranch
-    ${{ if eq(variables['Build.SourceBranchName'], 'vs17.13') }}:
+    ${{ if eq(variables['Build.SourceBranchName'], 'vs17.14') }}:
+      value: 'rel/d17.14'
+    ${{ elseif eq(variables['Build.SourceBranchName'], 'vs17.13') }}:
       value: 'rel/d17.13'
     ${{ elseif eq(variables['Build.SourceBranchName'], 'vs17.12') }}:
       value: 'rel/d17.12'
@@ -95,8 +102,8 @@ variables:
     value: $(resources.pipeline.MSBuild.sourceCommit)
   - name: ArtifactPackagesPath
     value: $(Build.ArtifactStagingDirectory)/PackageArtifacts
-  
-  - name: MSBuildPackagePattern 
+
+  - name: MSBuildPackagePattern
     value: '$(ArtifactPackagesPath)/Microsoft.Build.*.nupkg'
   - name: StringToolsPackagePattern
     value: '$(ArtifactPackagesPath)/Microsoft.NET.StringTools*.nupkg'
@@ -200,7 +207,6 @@ extends:
               $MicrosoftNETStringToolsPackageVersion = $packageFile.BaseName.TrimStart("Microsoft.NET.StringTools")
               Write-Host "Setting MicrosoftNETStringToolsPackageVersion to '$MicrosoftNETStringToolsPackageVersion'"
               Write-Host "##vso[task.setvariable variable=MicrosoftNETStringToolsPackageVersion]$($MicrosoftNETStringToolsPackageVersion)"
-              
               $props = @(
                       "VS.ExternalAPIs.MSBuild=$MSBuild_ExtApisPackageVersion",
                       "Microsoft.Build=$MicrosoftNETStringToolsPackageVersion",
@@ -221,26 +227,38 @@ extends:
               $propsValue = $props -join ";"
               Write-Host "Setting InsertPackagePropsValues to '$propsValue'"
               Write-Host "##vso[task.setvariable variable=InsertPackagePropsValues]$($propsValue)"
+              
+              # autocomplete main
+              $autocomplete = "false"
+              if ("$(InsertTargetBranch)" -eq "main")
+              {
+                  $autocomplete = "true"
+              }
+              Write-Host "Setting AutoCompleteEnabled to '$autocomplete'"
+              Write-Host "##vso[task.setvariable variable=AutoCompleteEnabled]$($autocomplete)"
+
         - task: 1ES.PublishNuGet@1
           displayName: 'Push MSBuild CoreXT packages'
+          condition: ${{ eq(parameters.SkipUploadingPackages, false) }}
           inputs:
             packageParentPath: '$(Build.ArtifactStagingDirectory)'
             packagesToPush: $(MSBuildPackagePattern);$(StringToolsPackagePattern);$(ExternalAPIsPackagePattern)
             nuGetFeedType: internal
             publishVstsFeed: VS
-            allowPackageConflicts: true
+            allowPackageConflicts: false
         - template: /azure-pipelines/WIFtoPATauth.yml@self
           parameters:
             wifServiceConnectionName: azure-public/vside package push
             deadPATServiceConnectionId: 42175e93-c771-4a4f-a132-3cca78f44b3b
         - task: 1ES.PublishNuGet@1
+          condition: ${{ eq(parameters.SkipUploadingPackages, false) }}
           displayName: 'Push MSBuild packages to VSSDK'
           inputs:
             packageParentPath: '$(Build.ArtifactStagingDirectory)'
             packagesToPush: $(MSBuildPackagePattern);$(StringToolsPackagePattern)
             nuGetFeedType: external
             publishFeedCredentials: azure-public/vssdk
-            allowPackageConflicts: true
+            allowPackageConflicts: false
         - task: PowerShell@2
           name: PrintTargetBranch
           inputs:
@@ -262,6 +280,6 @@ extends:
             DefaultConfigValues: $(InsertConfigValues)
             InsertionReviewers: MSBuild,VS ProTools
             CustomScriptExecutionCommand: $(InsertCustomScriptExecutionCommand)
-            AutoCompletePR: true
+            AutoCompletePR: $(AutoCompleteEnabled)
             AutoCompleteMergeStrategy: Squash
-            InsertionBuildPolicy: Request Perf DDRITs
\ No newline at end of file
+            InsertionBuildPolicy: Request Perf DDRITs
diff --git a/documentation/Property-tracking-capabilities.md b/documentation/Property-tracking-capabilities.md
new file mode 100644
index 00000000000..a2cef4e2543
--- /dev/null
+++ b/documentation/Property-tracking-capabilities.md
@@ -0,0 +1,49 @@
+# MSBuild's property tracking capabilities
+
+MSBuild Property Tracking is a built-in diagnostic feature that tracks property value changes during the build process.
+By default, this feature is opted out due to performance considerations.
+
+## Property Tracking Coverage
+
+The implementation tracks properties in the following scenarios:
+
+1. Properties set via command-line arguments (e.g. using `/p:` switches)
+
+2. Properties defined based on environment variables and used by MSBuild
+
+3. Properties set as target outputs
+   - Tracks changes when properties are modified by target execution
+
+4. Properties set as task outputs
+   - Monitors property modifications resulting from task execution
+
+5. Properties defined in XML during evaluation
+   - Provides exact location information for properties defined in project files
+   - Includes line and column information from the source XML
+   - Reports on property modifications
+
+## Event Types and Message Formatting
+
+The feature implements specialized event handling for three scenarios:
+
+1. `PropertyReassignmentEventArgs`
+   - Triggered when a property value is changed
+   `set MsBuildLogPropertyTracking=1`
+
+2. `PropertyInitialValueSetEventArgs`
+   - Triggered when a property is first initialized
+   `set MsBuildLogPropertyTracking=2`
+
+3. `EnvironmentVariableRead`
+   - Tracks when environment variables are read
+   `set MsBuildLogPropertyTracking=4`
+
+4. `UninitializedPropertyReadEventArgs`
+   - Triggered when attempting to read a property that hasn't been initialized
+   `set MsBuildLogPropertyTracking=8`
+
+5. None
+   - Disables all property tracking
+   `set MsBuildLogPropertyTracking=0`
+
+If you want to enable all these events reporting, enable it by `set MsBuildLogPropertyTracking=15`.
\ No newline at end of file
diff --git a/documentation/release-checklist.md b/documentation/release-checklist.md
index e68725deee1..7e077ebfa42 100644
--- a/documentation/release-checklist.md
+++ b/documentation/release-checklist.md
@@ -36,7 +36,8 @@ _(This is for the case where we create the branch too early and want it to be ba
   - In the file `eng/Versions.props` Update the `VersionPrefix` to `{{NEXT_VERSION}}` and `PackageValidationBaselineVersion` set to a latest internally available {{THIS_RELEASE_VERSION}} preview version in the [internal dnceng dotnet-tools feed](https://dev.azure.com/dnceng/internal/_artifacts/feed/dotnet-tools-internal). It might be needed to update `CompatibilitySuppressions.xml` files. See [this documentation](https://learn.microsoft.com/en-us/dotnet/fundamentals/apicompat/overview) for more details. You can update `CompatibilitySuppressions.xml` files by running
 `dotnet pack MSBuild.Dev.slnf /p:ApiCompatGenerateSuppressionFile=true`.
   - [ ]  When VS main snaps to {{THIS_RELEASE_VERSION}} and updates its version to {{NEXT_VERSION}}, modify the [MSBuild VS Insertion pipeline](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=24295) YAML so that it flows from MSBuild main to VS main.
-    - [ ]  Update AutoTargetBranch selection in the [YAML](../azure-pipelines/vs-insertion.yml) (add to parameters and make new AutoTargetBranch rule by copying it from existing ones) of the [MSBuild VS Insertion pipeline](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=24295) to insert MSBuild `vs{{THIS_RELEASE_VERSION}}` to the corresponding VS branch `rel/d{{THIS_RELEASE_VERSION}}`.
+    - [ ] Update AutoTargetBranch selection in the [YAML](../azure-pipelines/vs-insertion.yml) (add to parameters and make new AutoTargetBranch rule by copying it from existing ones) of the [MSBuild VS Insertion pipeline](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=24295) to insert MSBuild `vs{{THIS_RELEASE_VERSION}}` to the corresponding VS branch `rel/d{{THIS_RELEASE_VERSION}}`.
+      - [ ] Add a selection rule for `vs{{NEXT_VERSION}}` -> `rel/d{{NEXT_VERSION}}` (preparation if we need to branch early and backport to previews)
     - [ ] Add `rel/d{{THIS_RELEASE_VERSION}}` case to TargetBranch parameter in [Experimental insertion](../azure-pipelines/vs-insertion-experimental.yml)
     - [ ] Set scheduled insertion for main and remove exclusion of `vs{{THIS_RELEASE_VERSION}}` triggering on each commit if added earlier.
 - [ ] Merge {{NEXT_VERSION}} branding PR
@@ -96,6 +97,7 @@ if it is not, `darc add-default-channel  --channel "VS {{THIS_RELEASE_VERSION}}"
     - [ ] Respond to the 'VS xyz package stabilization' email - with the merged insertion PR (as nowVS is on stable version).
 - [ ] Update the PackageValidationBaselineVersion to the latest released version ({{THIS_RELEASE_VERSION}}.0) - this might require temporary addition of the [build artifacts feed](https://github.com/dotnet/msbuild/blob/29397b577e3ec0fe0c7650c3ab0400909655dc88/NuGet.config#L9) as the new version is not yet added to the official feeds (this is post release). This can trigger a high severity CG error (https://eng.ms/docs/cloud-ai-platform/devdiv/one-engineering-system-1es/1es-docs/secure-supply-chain/how-to-securely-configure-package-source-files) - however it should be fine to keep this temporary feed untill the release.
 - [ ] Update the requested SDK version for bootstrap folder (the `BootstrapSdkVersion` property in [Versions.props](https://github.com/dotnet/msbuild/blob/main/eng/Versions.props)) if a fresh sdk was released (released runtimes and associated sdk versions can be checked here - https://dotnet.microsoft.com/download/visual-studio-sdks - make sure to always check the details of the appropriate targeted version of .NET for the matching latest version of SDK).
+- [ ] Update `VisualStudio.ChannelName` (and `VisualStudio.MajorVersion` if applicable) of `Windows_NT` build step for our build pipeline in a newly created branch - it should point to the matching VS release branch and make sure the change is not automatically mergable with the interbranch flow (example: #11246): {{URL_OF_PR}}
 
 ## ASAP On/After GA:
 
@@ -128,3 +130,9 @@ Timing based on the [(Microsoft-internal) release schedule](https://dev.azure.co
   git push upstream v{{THIS_RELEASE_VERSION}}.3
   ```
   - [ ]  Create Release in Github with `Create Release from Tag` GH option (https://github.com/dotnet/msbuild/releases/new?tag=v17.9.3) - the release notes can be prepopulated (`Generate Release Notes`)
+
+## After release
+
+If v{{NEXT_VERSION}} is a new major version
+
+- [ ] do Major version extra update steps from [release.md](./release.md)
diff --git a/documentation/release.md b/documentation/release.md
index 7ef016408f5..febe2cc1317 100644
--- a/documentation/release.md
+++ b/documentation/release.md
@@ -17,3 +17,11 @@ As of [#7018](https://github.com/dotnet/msbuild/pull/7018), MSBuild uses a Rosly
 3. At release time, we must manually promote the `Unshipped` public API to `Shipped`.
 
 That is a new step in our release process for each formal release (including patch releases if they change API surface).
+
+## Major version extra update steps
+
+Update major version of VS in
+
+- [BuildEnvironmentHelper.cs](../src/Shared/BuildEnvironmentHelper.cs)
+- [Constants.cs](../src/Shared/Constants.cs)
+- [TelemetryConstants.cs](../src/Framework/Telemetry/TelemetryConstants.cs)
diff --git a/documentation/specs/BuildCheck/Codes.md b/documentation/specs/BuildCheck/Codes.md
index 9845c431061..3557170f825 100644
--- a/documentation/specs/BuildCheck/Codes.md
+++ b/documentation/specs/BuildCheck/Codes.md
@@ -11,9 +11,11 @@ Report codes are chosen to conform to suggested guidelines. Those guidelines are
 | [BC0105](#bc0105---embeddedresource-should-specify-culture-metadata) | Warning | N/A | 9.0.200 | Culture specific EmbeddedResource should specify Culture metadata. |
 | [BC0106](#bc0106---copytooutputdirectoryalways-should-be-avoided) | Warning | N/A | 9.0.200 | CopyToOutputDirectory='Always' should be avoided. |
 | [BC0107](#bc0107---targetframework-and-targetframeworks-specified-together) | Warning | N/A | 9.0.200 | TargetFramework and TargetFrameworks specified together. |
+| [BC0108](#bc0108---targetframework-or-targetframeworks-specified-in-non-sdk-style-project) | Warning | N/A | 9.0.300 | TargetFramework or TargetFrameworks specified in non-SDK style project. |
 | [BC0201](#bc0201---usage-of-undefined-property) | Warning | Project | 9.0.100 | Usage of undefined property. |
 | [BC0202](#bc0202---property-first-declared-after-it-was-used) | Warning | Project | 9.0.100 | Property first declared after it was used. |
 | [BC0203](#bc0203----property-declared-but-never-used) | None | Project | 9.0.100 | Property declared but never used. |
+| [BC0301](#bc0301---building-from-downloads-folder) | None | Project | 9.0.300 | Building from Downloads folder. |
 
 
 Notes: 
@@ -126,6 +128,16 @@ If you specify `TargetFramework` you are instructing the build to produce a sing
 dotnet build my-multi-target.csproj /p:TargetFramework=net9.0
 ```
 
+<a name="BC0108"></a>
+## BC0108 - TargetFramework or TargetFrameworks specified in SDK-less project.
+
+"'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects not using .NET SDK."
+
+'TargetFramework' or 'TargetFrameworks' control the project output targets in modern .NET SDK projects. The older SDK-less projects interprets different properties for similar mechanism (like 'TargetFrameworkVersion') and the 'TargetFramework' or 'TargetFrameworks' are silently ignored.
+
+Make sure the Target Framework is specified appropriately for your project.
+
+
 <a name="BC0201"></a>
 ## BC0201 - Usage of undefined property.
 
@@ -176,6 +188,15 @@ Common cases of false positives:
  * Property accessing is tracked for each project build request. There might be multiple distinct build requests for a project in a single build. Specific case of this is a call to the [MSBuild task](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) or [CallTarget task](https://learn.microsoft.com/en-us/visualstudio/msbuild/calltarget-task) that can request a result from a project build, while passing additional or different global properties and/or calling specific target. This happens often as part of common targets - e.g. for [multi-targeted project build parallelization](../../High-level-overview.md#parallelism)
  * Incremental build might skip execution of some targets, that might have been accessing properties of interest.
 
+<a name="BC0301"></a>
+## BC0301 - Building from Downloads folder.
+
+"Downloads folder is untrusted for projects building."
+
+Placing project files into Downloads folder (or any other folder that cannot be fully trusted including all parent folders up to a root drive) is not recomended, as unintended injection of unrelated MSBuild logic can occur.
+
+Place your projects into trusted locations - including cases when you intend to only open the project in IDE.
+
 <BR/>
 <BR/>
 <BR/>
diff --git a/documentation/specs/event-source.md b/documentation/specs/event-source.md
index 4eef03f279b..198791bb356 100644
--- a/documentation/specs/event-source.md
+++ b/documentation/specs/event-source.md
@@ -45,7 +45,7 @@ EventSource is primarily used to profile code. For MSBuild specifically, a major
 
 One can run MSBuild with eventing using the following command:
 
-`PerfView /OnlyProviders=*Microsoft-Build run MSBuild.exe <project to build>`
+`PerfView /Providers=*Microsoft-Build run MSBuild.exe <project to build>`
 
 For example, if PerfView is one level up from my current directory (which has MSBuild.exe), and I want to build MSBuild.sln on Windows, I would use the following command:
 
diff --git a/documentation/specs/proposed/BuildCheck-net10-polishing.md b/documentation/specs/proposed/BuildCheck-net10-polishing.md
new file mode 100644
index 00000000000..55dc5366f08
--- /dev/null
+++ b/documentation/specs/proposed/BuildCheck-net10-polishing.md
@@ -0,0 +1,69 @@
+# BuildCheck Net10 polishing 
+
+In net 9.0 we delivered initial preview of BuildCheck feature. 
+ * Spec: https://github.com/dotnet/msbuild/blob/main/documentation/specs/BuildCheck/BuildCheck.md
+ * Work track:  https://github.com/orgs/dotnet/projects/373
+
+In addition to that we have an item tracking possible improvements and extensions of the feature: https://github.com/dotnet/msbuild/issues/10548
+
+This doc focuses on a minimal investment path that would allow driving adoption of the BuildChecks feature and collecting feedback from real life usage.
+
+## Goals and Motivation 
+
+* Making sure the feature can be used in the real life scenarios.
+* Driving adoption.
+
+## Impact 
+
+* MSBuild team has a venue to evangelise best practices for the build.
+* Customers have a tool to formalize and distribute their view of best practices.
+* MSBuild team can improving end-user build perf and security with high leverage by providing new Checks notifying about problems.
+
+
+## Stakeholders 
+- PM (@baronfel) - as a customer advocate
+- Selected internal partner repo owners (details https://github.com/dotnet/msbuild/issues/10726)
+
+### Successful handover
+- Internal partner teams' ideas around BuildChecks collected and considered.
+- Selected internal partner teams are using BuildChecks in their build pipelines.
+- BuildChecks being evangelized externaly, adoption numbers grow up.
+
+## Risks 
+- Performance degradation is unacceptable on real scale project.
+- There are multiple hard to investigate and/or hard to fix bugs identified during initial adoptions.
+- Unsatisfactory specificity and/or sensitivity - leading to diminishing the perceived value of Checks and endangering the motivation to adopt them.
+- Low perceived value of best practices enforced by the checks.
+- Confusing diagnostics/documentation leading to lowering the educational value.
+
+
+## Scope
+
+### Goals
+* MSBuild team runs buildchecks on selected partner repos (via private runs), identifying and fixing issues
+* MSBuild team helps selected partner teams to enable buildchecks on their repos (in official runs), and providing initial support
+
+### Non-Goals
+
+* Measuring and defining the perf impact, detecting the sources of it
+  This doc doesn't cover the perf measurement and analysis - see [the PerfStar one page for this topic](https://github.com/dotnet/msbuild/pull/11045/files#diff-dcbd46135c1492f7b8f0c1221118a6ec7c241b86e6493d5a93f2c2f83b50b7bfR21)
+* Providing additional helpful low-hanging-fruit checks
+
+### Out of scope
+
+* OM/API enriching
+* Configuration and other features improvements
+* VS, VS-Code integrations
+
+## Cost 
+
+The below plan is expected with 0.25 Dev / Month investment (except for Month #2, that will realistically need ~0.5-2 Dev / Month)
+
+## Suggested plan 
+* Month #1 - Running build checks on selected partner repos and identifying issues
+* Month #2 - Resolve identified adoption blockers
+* Month #2 optional - run perf tests and define perf profile for build with Checks.
+* Month #3 - Enabling buildchecks on partner repos, providing initial support
+* Month #4 - Evangelization and driving the adoption in external community
+
+ 
\ No newline at end of file
diff --git a/documentation/specs/proposed/General_perf_onepager.md b/documentation/specs/proposed/General_perf_onepager.md
new file mode 100644
index 00000000000..347b5fb0de2
--- /dev/null
+++ b/documentation/specs/proposed/General_perf_onepager.md
@@ -0,0 +1,41 @@
+# General performance improvements
+MSBuild is the main tool used for building various types of projects. It is used by Visual Studio, the .NET CLI, and other build tools. The performance of MSBuild is critical to the productivity of developers. This document outlines our goals to improve overall performance of MSBuild.
+
+## Goals and Motivation
+
+We are aiming for:
+ - Searching for opportunities to improve evaluation and build times. We can utilize the data collected by ETW traces, the VS perf lab, and previously identified performance issues.
+ - Reducing MSBuild overhead in the Visual Studio IDE.
+ - Collecting data to understand the current performance bottlenecks.
+
+This document does not cover specific performance improvements, but rather outlines the general goals and motivation for the performance improvements.
+
+## Impact
+    
+ - Opening project/solution, branch switching and other operations using MSBuild code in VS should be less impacted by the MSBuild.
+ - Overall build times should be reduced. 
+ - Even a small improvement can save a lot of time and computing resources across all builds done daily worldwide.
+
+## Stakeholders
+
+    - Chet Husk (PM) - as a customer advocate
+    - David Kean - as a VS performance expert
+
+## Risks
+
+ - Performance improvements might not be as significant as expected.
+ - We can break existing functionality while making changes.
+ - Some ideas and performance measurement findings might need to be skipped due to technical limitations or complexity/improvements ratio.
+
+## Cost
+
+Performance improvements are a long-term investment. We need to balance the cost of the improvements with the expected benefits.
+We will need to invest time in collecting data, analyzing the data, and implementing improvements.
+
+Our goal in this scope is to find small and medium size opprotunities (Achievable within a single sprint with 1-2 dev investment). Bigger functionalities such as evaluation caching and RAR caching are described in separate documents.
+
+## Plan
+    
+ - Collect data on the current performance bottlenecks.
+ - Identify opportunities for improvements.
+ - Implement improvements in time-boxed iterations.
diff --git a/documentation/specs/proposed/decoupling-vs-sdk.md b/documentation/specs/proposed/decoupling-vs-sdk.md
new file mode 100644
index 00000000000..58b5fe7c321
--- /dev/null
+++ b/documentation/specs/proposed/decoupling-vs-sdk.md
@@ -0,0 +1,43 @@
+# Decoupling VS builds of .NET SDK projects
+The experience of building a .NET SDK project can differ significantly depending if the project was built using Visual Studio / MSBuild or `dotnet build`. The build can produce different diagnostics, use different language rules, etc. This is because building a .NET SDK project from Visual Studio mixes components from Visual Studio and the .NET SDK. This means core tooling, like the compiler, can be substantially different between the two types of build. This leads to customer confusion and hard-to-diagnose problems. To solve this want to ensure that when building a .NET SDK project we use more components from the .NET SDK to do so.
+
+## Goals and Motivation
+
+We are aiming for:
+ - More consistent end-user experience for build between .NET CLI and Visual Studio.
+ - Decoupling the .NET SDK experience from Visual Studio 
+
+There are a few reasons that makes us persue this effort.
+The first, we want a better experience when using or writting Roslyn analyzers and MSBuild Tasks. Currently tooling authors need to target NetStandard2.0 for their projects to be recognized by VS, and doing so blocks out newer features available. 
+
+Second, tasks will not need to be multitargeted to cover both VS and .NET SDK. Right now, a lot of tasks need different versions to cover both of these scenarios, but with the changes in this features, authors will be able to use the same version for both situations.
+
+
+## Impact
+There are a few area of impact:
+ - .NET SDK style project builds will be more stable between VS and CLI builds, as the tooling will not be devided between different versions.
+ - Reduced cost of development for external and internal teams that author Roslyn Analyzers, source generators, or MSBuild Tasks.
+ - End-user will not experience mismatch between analyzer versions, and gain higher confidence that their .NET SDK project builds will behave the same way in VS and in the command line.
+
+## Stakeholders
+Other teams will need to work to fully complete the VS and .NET SDK decoupling feature after our base work is done. There are two handovers in this project:
+
+1. After providing enough information to do so through MSBuild and the SDK, Roslyn will need to use it to invoke their .NET compiler in VS.
+2. After MSBuild enables tasks to target .NET even for VS use, task-owning teams like the .NET SDK will need to migrate their targets to use .NET Core instead of keeping them targeting .NET Framework.
+
+The handovers should allow other teams to proceed with their work smoothly and no unexpected change in build behavior should be present within MSBuild.
+
+## Risks
+A few risks associated with this feature:
+ - If .NET Core tasks is discovered to have too large of a performance impact (due to IPC overhead to a .NET process), core partner teams may choose to keep multitargeting their tasks for improved user perf.
+ - There is a hard deadline for this feature, VS17.14. As a consequence of how we support versions we would need to get all the work of this feature completed before that release. If we do not reach the deadline for this feature we would need to change policies on SDK level to be able to continue support.
+
+
+## Plan
+ 1. Ensure that MSBuild.exe provides the same execution state as the dotnet command line invocation.
+    -  This is should take around 1 dev week to complete, and will be handed over to Roslyn team.
+ 2. Implement .NET Core task host, tasks can be executed on the .NET Core vresion instead of .NET framework.
+    - This should take 1 to 2 dev months to complete, including extensive testing. This would be handed over to internal teams that have custom tasks so they can be updated and tested.
+ 3. Load common targets from the .NET SDK and not from .NET NetFramework on VS. This work depends on other team's finilizing their part of the feature and might not be in scope for .NET 10.
+    - This should take a dev week for code changes. For everything else, analysis, testing, etc... the time is very dependent on what happens after the code change, which we can't fully predict at this moment.
+
diff --git a/documentation/specs/proposed/evaluation-perf.md b/documentation/specs/proposed/evaluation-perf.md
new file mode 100644
index 00000000000..22ea253c93d
--- /dev/null
+++ b/documentation/specs/proposed/evaluation-perf.md
@@ -0,0 +1,20 @@
+# Evaluation performance investigations
+In the current effort to improve performance of MSBuild, we identified evaluation as one of the focus areas of this effort. Evaluation is the first step when loading or building, and it determines references, how projects are connected and what needs to be build. Because of this it runs in every MSBuild scenario, from solution load and design-time builds in Visual Studio, to up-to-date builds or full builds in VS or on the command line.
+
+## Description
+Current performance state of evaluation is mostly unkown, we have a few measures but no easy way of accessing and assessing them. As such, we are unsure which specific areas can be improve. 
+
+## Goals and Motivation
+We are trying to make evaluation phase of the build more performant, since it is almost always executed any performance gain becomes noticeable. A performant evaluation phase would decrease build times in general, in CI cases it frees up resources, and in individual cases it can increase dev-loop performance by making up-to-date and incremental builds go faster.
+
+In this moment we are still in investigation phase, the objective is to make the markers we have in code more accessible to the team, so we can idetentify low hanging fixes, and improvement areas when testing builds within PerfStar.
+
+Constraint - needs to work as it does today, but faster. We may be able to break some edge cases.
+
+## Risks
+One of the big risks is accidentally changing the current behaviour of evaluation. One of the constraints of improvement is that evaluation has the same behavior, with the exception of edge cases where we can sometimes change it.
+
+## Plan
+The plan for evaluation at the moment is to add more code markers during execution so we can use PerfStar to have a detailed view of how long each part of evaluation phase takes.
+
+Larger changes to the evaluation are possible and under consideration for future iterations, like trying to cache the evaluation result in MSBuild. However we are focusing on investigation and performance gains with less work at the moment.
\ No newline at end of file
diff --git a/documentation/specs/proposed/perfStar.md b/documentation/specs/proposed/perfStar.md
new file mode 100644
index 00000000000..dffb0343aee
--- /dev/null
+++ b/documentation/specs/proposed/perfStar.md
@@ -0,0 +1,40 @@
+# PerfStar
+PerfStar is a performance tracking and investigation tool for MSBuild. PerfStar infrastructure captures performance measurements of the `main` MSBuild branch on a schedule and allows us to request experimental runs and collect performance data for proposed changes. The first version of this project is being finalized, with some fixes necessary to run it automatically and according to prerequisites.
+
+## Goals and Motivation
+MSBuild currently does not have a lot of performance data outside of Visual Studio performance tracking, which has a lot of variables that are beyond the team's control. PerfStar enables us to measure our performance with less interference of elements that the team does not own. As such, we can measure the performance of in-development features and how it will impact build times, as well as have concrete numbers when working on performance improvement tasks.
+
+## Impact
+Perfstar's impact is focused on the team. We will be able to track performance with concrete numbers. Because of that the team will be able to take more informed decisions about performance improvement work, as well as implementation of new features. In turn, those decisions will accrue value to users via higher build performance.
+
+## Risks
+The risks associated with our dependencies is about Crank, which is owned by the ASP.NET team and we use it to help us with machine setup to run the performance tests.
+
+PerfStar also runs as a service. One that the mostly the team uses, but it is a service and carry the same risks as any other service product. Including possible downtime, maintanance, and some security areas.
+
+## Plan
+Investiment for .NET 10:
+ 1. Making PerfStar execute automatically the way the design doc indicates
+    - Around 1 dev week.
+2. The PowerBI reporting is working and updating the new information
+   - Around 2 dev weeks.
+3. New performance tests for new features, and writing docs on how to write those tests. Next feature planned for tests: BuildCheck.
+   - Around 3 dev days per feature.
+4. Analyze stability of performance tests, and fix any noise found. This will be done through multiple iterations of the same test in the same machine, as well as updating the PowerBI report to handle the new data.
+   - Around 2 dev weeks.
+5. Add more tests using `msbuild.exe` for build in addition to `dotnet build`.
+   - Around 1 dev week.
+6. Timeboxed collection of feedback from our team, as well as performance investigations that can derive from those.
+   - 1 - 2 dev month depending on feedback and requests for improvement from the team.
+7. Add more test cases. For example, build time with different verbosity levels.
+   - Around 1 dev week.
+
+There are more improvements form PerfStar, but these are not planned for .NET 10 as they depend on the team's feedback to PerfStar.
+1. Add more measurements, like dotnet counter tool.
+   - Around 3 dev weeks.
+2. Trace collection when specific features are turned on for the test.
+   - Around 2 - 3 dev weeks.
+3. Report improvements:
+   - Compare performance numbers between two different iterations that are not from `main` branch. Around 2 dev weeks.
+   - Automatic detection of performance issues, so we don't need to check the reports to see regressions. Around 1 dev month.
+   - Run MSBuild API tests, so we can check performance of calls relating to Visual Studio builds. Around 1 dev month.
\ No newline at end of file
diff --git a/documentation/wiki/Binary-Log.md b/documentation/wiki/Binary-Log.md
index 100f45c363a..95d48fa7718 100644
--- a/documentation/wiki/Binary-Log.md
+++ b/documentation/wiki/Binary-Log.md
@@ -90,6 +90,21 @@ The [`BuildEventArgs`](https://github.com/dotnet/msbuild/blob/main/src/Framework
 * `ProjectContextId` - This indicates unique build request (so request for result from project + target(s) combination). There can be multiple build requests using the same evaluation - so a single `ProjectInstanceId` (and `EvaluationId`) often maps to multiple `ProjectContextId`s
 * `NodeId` - indicates the node where the event was generated ('0' for the SchedulerNode with possible in-proc execution node, positive ids for the out-of-proc execution nodes). The whole evaluation happens on a single node - so all evaluation time events with single `EvaluationId` have same `NodeId`. Execution is attempted to be performed on a node which evaluated ('evaluation affinity') - so usually all events with corresponding `EvaluationId` and `InstanceId` have the same `NodeId`. But evaluation results are transferable between nodes (it's `Translatable`) so evaluation events and build events `NodeId` doesn't have to match. Single build execution happens on the same node - so all events with same `ProjectContextId` have same `NodeId`. Though multiple build executions can be interleaved on a same node (due to 'Yielding' - either voluntarily explicitly called by the Task, or implicitly enforced by `RequestBuilder`).
 
+```
+# Project.csproj
+└── EvaluationId: ABC                   # Single evaluation of the project
+   └── ProjectInstanceId: XYZ           # Single instance created from evaluation
+       ├── ProjectContextId: 123        # Build request for Compile target  
+       └── ProjectContextId: 456        # Build request for Pack target
+```
+In this example:
+
+* The project is evaluated once, generating `EvaluationId`: ABC
+* This evaluation creates one project instance with `ProjectInstanceId`: XYZ
+* Two separate build requests are made:
+    - One to build the Compile target (`ProjectContextId`: 123)
+    - One to build the Pack target (`ProjectContextId`: 456)
+
 It's also good to note that those Ids can have negative values - indicating uninitialized value (this can be expected in many cases - e.g. evaluation time events cannot have `ProjectContextId` as they are not tied to single result request; or `ProjectInstanceId` are not ever populated on evaluation time events).
 
 ## Incrementing the file format
@@ -198,4 +213,4 @@ logReader.RecoverableReadError += errorEventArgs =>
 
 When authoring changes to the specific BuildEventArg types - it is always strongly recommended to **prefer append-only changes**. 
 
-This prevents the possibility of collision where some fields are removed in one version and then different fields with same binary size are added in future version. Such a sequence of format changes might not be caught by the decoder and might lead to unnoticed corrupt interpretation of data. For this reason the author of specific OM changes should always check whether there is a possibility of unrecognizable format collision (same binary size, different representation) within binlog versions of a same [minimum reader version support](#forward-compatibility-reading). If this is possible, the [minimum reader version support](#forward-compatibility-reading) should be incremented.
\ No newline at end of file
+This prevents the possibility of collision where some fields are removed in one version and then different fields with same binary size are added in future version. Such a sequence of format changes might not be caught by the decoder and might lead to unnoticed corrupt interpretation of data. For this reason the author of specific OM changes should always check whether there is a possibility of unrecognizable format collision (same binary size, different representation) within binlog versions of a same [minimum reader version support](#forward-compatibility-reading). If this is possible, the [minimum reader version support](#forward-compatibility-reading) should be incremented.
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 1dfe8a21f13..6b88ed66097 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -25,8 +25,9 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 ## Current Rotation of Change Waves
 
 ### 17.14
-- [.SLNX support - use the new parser for .sln and .slnx](https://github.com/dotnet/msbuild/pull/10836)
+- ~[.SLNX support - use the new parser for .sln and .slnx](https://github.com/dotnet/msbuild/pull/10836)~ reverted after compat problems discovered
 - [Support custom culture in RAR](https://github.com/dotnet/msbuild/pull/11000)
+- [VS Telemetry](https://github.com/dotnet/msbuild/pull/11255)
 
 ### 17.12
 - [Log TaskParameterEvent for scalar parameters](https://github.com/dotnet/msbuild/pull/9908)
diff --git a/documentation/wiki/Providing-Binary-Logs.md b/documentation/wiki/Providing-Binary-Logs.md
index 37e541136d8..4d9e7b2706d 100644
--- a/documentation/wiki/Providing-Binary-Logs.md
+++ b/documentation/wiki/Providing-Binary-Logs.md
@@ -54,3 +54,12 @@ Further reading:
 ### Capturing specific logs for chosen build invocations
 
 See [this guide](https://github.com/dotnet/project-system-tools) in the Project System Tools repo for capturing binlogs through Visual Studio.
+
+> [!TIP]
+> You can share your logs with us anonymously [via MS developer community](https://developercommunity.microsoft.com/dotnet/report).
+![share_binlog](share_binlog.png)
+
+
+> [!CAUTION]
+> Only attach sensitive information in the comments after the initial post to ensure anonymity.
+
diff --git a/documentation/wiki/share_binlog.png b/documentation/wiki/share_binlog.png
new file mode 100644
index 00000000000..b3cce3bdd75
Binary files /dev/null and b/documentation/wiki/share_binlog.png differ
diff --git a/eng/Packages.props b/eng/Packages.props
index 2dc90d508fb..456f037819e 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -19,20 +19,33 @@
     <PackageVersion Include="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
     <PackageVersion Include="System.Collections.Immutable" Version="$(SystemCollectionsImmutableVersion)" />
     <PackageVersion Include="System.Configuration.ConfigurationManager" Version="$(SystemConfigurationConfigurationManagerVersion)" />
+    <PackageVersion Include="System.Diagnostics.DiagnosticSource" Version="$(SystemDiagnosticsDiagnosticSourceVersion)" />
+    <PackageVersion Include="System.Diagnostics.EventLog" Version="$(SystemDiagnosticsEventLogVersion)" />
     <PackageVersion Include="System.Formats.Asn1" Version="$(SystemFormatsAsn1Version)" />
+    <PackageVersion Include="System.Formats.Nrbf" Version="$(SystemFormatsNrbfVersion)" />
     <PackageVersion Include="System.Memory" Version="$(SystemMemoryVersion)" />
-    <PackageVersion Include="System.Net.Http" Version="$(SystemNetHttpVersion)" />
     <PackageVersion Include="System.Reflection.Metadata" Version="$(SystemReflectionMetadataVersion)" />
     <PackageVersion Include="System.Reflection.MetadataLoadContext" Version="$(SystemReflectionMetadataLoadContextVersion)" />
     <PackageVersion Include="System.Resources.Extensions" Version="$(SystemResourcesExtensionsVersion)" />
     <PackageVersion Include="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
+    <PackageVersion Include="System.Security.Cryptography.ProtectedData" Version="$(SystemSecurityCryptographyProtectedDataVersion)" />
     <PackageVersion Include="System.Security.Principal.Windows" Version="$(SystemSecurityPrincipalWindowsVersion)" />
     <PackageVersion Include="System.Text.Encoding.CodePages" Version="$(SystemTextEncodingCodePagesVersion)" />
     <PackageVersion Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
-    <PackageVersion Include="System.Text.RegularExpressions" Version="$(SystemTextRegularExpressionsVersion)" />
     <PackageVersion Include="System.Threading.Channels" Version="$(SystemThreadingChannelsVersion)" />
     <PackageVersion Include="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
     <PackageVersion Include="System.Threading.Tasks.Extensions" Version="$(SystemThreadingTasksExtensionsVersion)" />
     <PackageVersion Include="xunit.console" Version="$(XUnitVersion)" />
+    <PackageVersion Include="Microsoft.VisualStudio.OpenTelemetry.Collector" Version="$(MicrosoftVisualStudioOpenTelemetryVersion)" />
+    <PackageVersion Include="Microsoft.VisualStudio.OpenTelemetry.ClientExtensions" Version="$(MicrosoftVisualStudioOpenTelemetryVersion)" />
+
+    <!-- maintained in eng/dependabot/Packages.props -->
+    <!--
+      System.CodeDom
+      System.Security.Cryptography.Pkcs
+      System.Security.Cryptography.Xml
+      Microsoft.Bcl.Cryptography
+      Microsoft.VisualStudio.SolutionPersistence
+    -->
   </ItemGroup>
 </Project>
diff --git a/eng/Signing.props b/eng/Signing.props
index b3d45b6fcf3..6b21c5d2ef4 100644
--- a/eng/Signing.props
+++ b/eng/Signing.props
@@ -7,6 +7,12 @@
     <ItemsToSign Include="$(ArtifactsDir)\xsd\Update-MSBuildXsds.ps1" />
 
     <FileSignInfo Include="RuntimeContracts.dll" CertificateName="3PartySHA2" />
+
+    <!-- For Telemetry in VS.-->
+    <FileSignInfo Include="OpenTelemetry.dll" CertificateName="3PartySHA2" />
+    <FileSignInfo Include="OpenTelemetry.Api.dll" CertificateName="3PartySHA2" />
+    <FileSignInfo Include="OpenTelemetry.Api.ProviderBuilderExtensions.dll" CertificateName="3PartySHA2" />
+    <FileSignInfo Include="Newtonsoft.Json.dll" CertificateName="3PartySHA2" />
   </ItemGroup>
 
   <PropertyGroup>
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index 1421f999956..6bf7dfcbf3a 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -3,22 +3,29 @@
 
 <UsageData>
   <IgnorePatterns>
-    <!-- 8.0 packages are not allowed in the 8.0 build, because they're not "current", so baseline them. -->
-    <UsagePattern IdentityGlob="System.CodeDom/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Collections.Immutable/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Formats.Asn1/*8.0.1*" />
-    <UsagePattern IdentityGlob="System.Reflection.Metadata/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Resources.Extensions/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Text.Json/*8.0.5*" />
-    <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Formats.Asn1/*8.0.1*" />
-    <UsagePattern IdentityGlob="Microsoft.VisualStudio.SolutionPersistence/*1.0.*" />
+    <!-- 9.0 packages are not allowed in the 9.0 build, because they're not "current", so baseline them. -->
+    <UsagePattern IdentityGlob="System.CodeDom/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Collections.Immutable/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Diagnostics.DiagnosticSource/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Formats.Asn1/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.Metadata/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Resources.Extensions/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Encoding.CodePages/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Json/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Threading.Channels/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*9.0.0*" />
+
+    <!-- dependency of System.Configuration.ConfigurationManager -->
+    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*9.0.0*" />
+    <!-- dependency of System.Resources.Extensions -->
+    <UsagePattern IdentityGlob="System.Formats.Nrbf/*9.0.0*" />
+    <!-- dependency of System.Security.Cryptography.Pkcs -->
+    <UsagePattern IdentityGlob="Microsoft.Bcl.Cryptography/*9.0.0*" />
   </IgnorePatterns>
   <Usages>
   </Usages>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index bfbbe6c3c9c..880d31d553e 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -2,105 +2,139 @@
 <Dependencies>
   <ProductDependencies>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="9.0.0-alpha.1.24619.1">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="9.0.0-alpha.1.25081.6">
       <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>e2b1d16fd66540b3a5813ec0ac1fd166688c3e0a</Sha>
+      <Sha>1cec3b4a8fb07138136a1ca1e04763bfcf7841db</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
+    <!-- Intermediate is necessary for source build. -->
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-externals" Version="9.0.0-alpha.1.25160.2">
+      <Uri>https://github.com/dotnet/source-build-externals</Uri>
+      <Sha>e2c3c1329ea432b36e4570d977271454e8abb0a0</Sha>
+      <SourceBuild RepoName="source-build-externals" ManagedOnly="true" />
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="Microsoft.Bcl.Cryptography" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
+    </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.CodeDom" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <Dependency Name="System.CodeDom" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
     </Dependency>
-    <!-- Necessary for source-build due to being a transitive dependency of System.Reflection.MetadataLoadContext.
-      This allows the package to be retrieved from previously-source-built artifacts and flow in as dependencies
-      of the packages produced by msbuild. -->
-    <Dependency Name="System.Collections.Immutable" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Collections.Immutable" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
     </Dependency>
-    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
-      and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Configuration.ConfigurationManager" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Configuration.ConfigurationManager" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
     </Dependency>
-    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
-      and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Reflection.Metadata" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Diagnostics.DiagnosticSource" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
     </Dependency>
-    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
-      and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Reflection.MetadataLoadContext" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Diagnostics.EventLog" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.Resources.Extensions" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <Dependency Name="System.Formats.Asn1" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
     </Dependency>
-    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
-      and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Security.Cryptography.Pkcs" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Formats.Nrbf" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.Security.Cryptography.Xml" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <Dependency Name="System.Reflection.Metadata" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
     </Dependency>
-    <Dependency Name="System.Text.Json" Version="8.0.5">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>81cabf2857a01351e5ab578947c7403a5b128ad1</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Reflection.MetadataLoadContext" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
     </Dependency>
-    <Dependency Name="System.Threading.Tasks.Dataflow" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Resources.Extensions" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
     </Dependency>
-    <Dependency Name="System.Threading.Channels" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Security.Cryptography.ProtectedData" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
     </Dependency>
-    <Dependency Name="System.Formats.Asn1" Version="8.0.1">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>2aade6beb02ea367fd97c4070a4198802fe61c03</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Security.Cryptography.Pkcs" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Security.Cryptography.Xml" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Text.Encoding.CodePages" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Text.Json" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Threading.Channels" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Threading.Tasks.Dataflow" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha></Sha>
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.24623.3">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.25111.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e0e05154656254a735ebf19ffa5a37a8b915039b</Sha>
+      <Sha>5da211e1c42254cb35e7ef3d5a8428fb24853169</Sha>
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.24623.3">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.25111.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e0e05154656254a735ebf19ffa5a37a8b915039b</Sha>
+      <Sha>5da211e1c42254cb35e7ef3d5a8428fb24853169</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.24623.3">
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.25111.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e0e05154656254a735ebf19ffa5a37a8b915039b</Sha>
+      <Sha>5da211e1c42254cb35e7ef3d5a8428fb24853169</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.13.0-rc.108">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.14.0-preview.1.53">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>89781a27ff255553766e4b9403ea7947072b4335</Sha>
+      <Sha>9202ddad5fabd4d7737fa0c717524fbe2455c972</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.13.0-3.25057.3">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.14.0-2.25111.1">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>911cf5f462960bdd01df1ea3c0d0c217b3c3838b</Sha>
+      <Sha>19c9b9eb00ae9afa7bedb10bd6be06bb41a880f6</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.13.0-3.25057.3">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.14.0-2.25111.1">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>911cf5f462960bdd01df1ea3c0d0c217b3c3838b</Sha>
+      <Sha>19c9b9eb00ae9afa7bedb10bd6be06bb41a880f6</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.24623.3">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25111.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>e0e05154656254a735ebf19ffa5a37a8b915039b</Sha>
+      <Sha>5da211e1c42254cb35e7ef3d5a8428fb24853169</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 6a92724529b..2f7ab4e790c 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -35,22 +35,38 @@
     <SystemThreadingTasksExtensionsVersion>4.6.0</SystemThreadingTasksExtensionsVersion>
   </PropertyGroup>
   <PropertyGroup>
+    <!-- manually maintained versions -->
     <MicrosoftIORedistVersion>6.1.0</MicrosoftIORedistVersion>
-    <MicrosoftVisualStudioSolutionPersistenceVersion>1.0.28</MicrosoftVisualStudioSolutionPersistenceVersion>
-    <SystemCollectionsImmutableVersion>8.0.0</SystemCollectionsImmutableVersion>
-    <SystemConfigurationConfigurationManagerVersion>8.0.0</SystemConfigurationConfigurationManagerVersion>
-    <SystemFormatsAsn1Version>8.0.1</SystemFormatsAsn1Version>
-    <SystemNetHttpVersion>4.3.4</SystemNetHttpVersion>
-    <SystemReflectionMetadataLoadContextVersion>8.0.0</SystemReflectionMetadataLoadContextVersion>
-    <SystemReflectionMetadataVersion>8.0.0</SystemReflectionMetadataVersion>
-    <SystemResourcesExtensionsVersion>8.0.0</SystemResourcesExtensionsVersion>
+    <MicrosoftVisualStudioOpenTelemetryVersion>0.2.104-beta</MicrosoftVisualStudioOpenTelemetryVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.1.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
-    <SystemTextEncodingCodePagesVersion>7.0.0</SystemTextEncodingCodePagesVersion>
-    <SystemTextRegularExpressionsVersion>4.3.1</SystemTextRegularExpressionsVersion>
-    <SystemTextJsonVersion>8.0.5</SystemTextJsonVersion>
-    <SystemThreadingChannelsVersion>8.0.0</SystemThreadingChannelsVersion>
-    <SystemThreadingTasksDataflowVersion>8.0.0</SystemThreadingTasksDataflowVersion>
+  </PropertyGroup>
+  <PropertyGroup>
+    <!-- dotnet/runtime packages -->
+    <SystemCollectionsImmutableVersion>9.0.0</SystemCollectionsImmutableVersion>
+    <SystemConfigurationConfigurationManagerVersion>9.0.0</SystemConfigurationConfigurationManagerVersion>
+    <SystemDiagnosticsDiagnosticSourceVersion>9.0.0</SystemDiagnosticsDiagnosticSourceVersion>
+    <SystemDiagnosticsEventLogVersion>9.0.0</SystemDiagnosticsEventLogVersion>
+    <SystemFormatsAsn1Version>9.0.0</SystemFormatsAsn1Version>
+    <SystemFormatsNrbfVersion>9.0.0</SystemFormatsNrbfVersion>
+    <SystemReflectionMetadataVersion>9.0.0</SystemReflectionMetadataVersion>
+    <SystemReflectionMetadataLoadContextVersion>9.0.0</SystemReflectionMetadataLoadContextVersion>
+    <SystemResourcesExtensionsVersion>9.0.0</SystemResourcesExtensionsVersion>
+    <SystemSecurityCryptographyProtectedDataVersion>9.0.0</SystemSecurityCryptographyProtectedDataVersion>
+    <SystemTextEncodingCodePagesVersion>9.0.0</SystemTextEncodingCodePagesVersion>
+    <SystemTextJsonVersion>9.0.0</SystemTextJsonVersion>
+    <SystemThreadingChannelsVersion>9.0.0</SystemThreadingChannelsVersion>
+    <SystemThreadingTasksDataflowVersion>9.0.0</SystemThreadingTasksDataflowVersion>
+  </PropertyGroup>
+  <PropertyGroup>
+    <!-- maintained in eng/dependabot/Packages.props -->
+    <!--
+    <SystemCodeDomVersion></SystemCodeDomVersion>
+    <SystemSecurityCryptographyPkcsVersion></SystemSecurityCryptographyPkcsVersion>
+    <SystemSecurityCryptographyXmlVersion></SystemSecurityCryptographyXmlVersion>
+    <MicrosoftBclCryptographyVersion></MicrosoftBclCryptographyVersion>
+    <MicrosoftVisualStudioSolutionPersistenceVersion></MicrosoftVisualStudioSolutionPersistenceVersion>
+    -->
   </PropertyGroup>
   <!-- Toolset Dependencies -->
   <PropertyGroup>
@@ -58,9 +74,9 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.24623.3</MicrosoftDotNetXUnitExtensionsVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.13.0-3.25057.3</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.13.0-rc.108</NuGetBuildTasksVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25111.5</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.14.0-2.25111.1</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.14.0-preview.1.53</NuGetBuildTasksVersion>
   </PropertyGroup>
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
     <BootstrapSdkVersion>9.0.200-preview.0.24603.3</BootstrapSdkVersion>
diff --git a/eng/build.ps1 b/eng/build.ps1
index eaf7cc577d8..d71fa299fd8 100644
--- a/eng/build.ps1
+++ b/eng/build.ps1
@@ -150,7 +150,7 @@ function Set-OptProfVariables() {
 
 function Check-EditedFiles() {
   # Log VSTS errors for changed lines
-  git --no-pager diff HEAD --unified=0 --no-color --exit-code | ForEach-Object { "##vso[task.logissue type=error] $_" }
+  git --no-pager diff HEAD --unified=0 --no-color --exit-code -- src/ | ForEach-Object { "##vso[task.logissue type=error] $_" }
   if ($LASTEXITCODE -ne 0) {
     throw "##vso[task.logissue type=error] After building, there are changed files.  Please build locally and include these changes in your pull request."
   }
diff --git a/eng/common/internal/Tools.csproj b/eng/common/internal/Tools.csproj
index 32f79dfb340..feaa6d20812 100644
--- a/eng/common/internal/Tools.csproj
+++ b/eng/common/internal/Tools.csproj
@@ -15,16 +15,6 @@
     <PackageReference Include="Microsoft.DotNet.IBCMerge" Version="$(MicrosoftDotNetIBCMergeVersion)" Condition="'$(UsingToolIbcOptimization)' == 'true'" />
     <PackageReference Include="Drop.App" Version="$(DropAppVersion)" ExcludeAssets="all" Condition="'$(UsingToolVisualStudioIbcTraining)' == 'true'"/>
   </ItemGroup>
-  <PropertyGroup>
-    <RestoreSources></RestoreSources>
-    <RestoreSources Condition="'$(UsingToolIbcOptimization)' == 'true'">
-      https://devdiv.pkgs.visualstudio.com/_packaging/dotnet-core-internal-tooling/nuget/v3/index.json;
-    </RestoreSources>
-    <RestoreSources Condition="'$(UsingToolVisualStudioIbcTraining)' == 'true'">
-      $(RestoreSources);
-      https://devdiv.pkgs.visualstudio.com/_packaging/VS/nuget/v3/index.json;
-    </RestoreSources>
-  </PropertyGroup>
 
   <!-- Repository extensibility point -->
   <Import Project="$(RepositoryEngineeringDir)InternalTools.props" Condition="Exists('$(RepositoryEngineeringDir)InternalTools.props')" />
diff --git a/eng/common/template-guidance.md b/eng/common/template-guidance.md
index 5ef6c30ba92..98bbc1ded0b 100644
--- a/eng/common/template-guidance.md
+++ b/eng/common/template-guidance.md
@@ -57,7 +57,7 @@ extends:
 
 Note: Multiple outputs are ONLY applicable to 1ES PT publishing (only usable when referencing `templates-official`).
 
-# Development notes
+## Development notes
 
 **Folder / file structure**
 
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 7393d570b66..f5c2c790f82 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -40,33 +40,30 @@
     <PackageVersion Include="FakeItEasy" Version="8.1.0" />
     <PackageVersion Update="FakeItEasy" Condition="'$(FakeItEasyVersion)' != ''" Version="$(FakeItEasyVersion)" />
 
-    <PackageVersion Include="System.CodeDom" Version="8.0.0" />
+    <PackageVersion Include="System.CodeDom" Version="9.0.0" />
     <PackageVersion Update="System.CodeDom" Condition="'$(SystemCodeDomVersion)' != ''" Version="$(SystemCodeDomVersion)" />
 
-    <PackageVersion Include="System.Private.Uri" Version="4.3.2" />
-    <PackageVersion Update="System.Private.Uri" Condition="'$(SystemPrivateUriVersion)' != ''" Version="$(SystemPrivateUriVersion)" />
-
-    <PackageVersion Include="System.Runtime" Version="4.3.1" />
-    <PackageVersion Update="System.Runtime" Condition="'$(SystemRuntimeVersion)' != ''" Version="$(SystemRuntimeVersion)" />
-
-    <PackageVersion Include="System.Security.Cryptography.Pkcs" Version="8.0.0" />
+    <PackageVersion Include="System.Security.Cryptography.Pkcs" Version="9.0.0" />
     <PackageVersion Update="System.Security.Cryptography.Pkcs" Condition="'$(SystemSecurityCryptographyPkcsVersion)' != ''" Version="$(SystemSecurityCryptographyPkcsVersion)" />
 
-    <PackageVersion Include="System.Security.Cryptography.Xml" Version="8.0.0" />
+    <PackageVersion Include="System.Security.Cryptography.Xml" Version="9.0.0" />
     <PackageVersion Update="System.Security.Cryptography.Xml" Condition="'$(SystemSecurityCryptographyXmlVersion)' != ''" Version="$(SystemSecurityCryptographyXmlVersion)" />
 
-    <PackageVersion Include="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
-    <PackageVersion Update="System.Security.Cryptography.X509Certificates" Condition="'$(SystemSecurityCryptographyX509CertificatesVersion)' != ''" Version="$(SystemSecurityCryptographyX509CertificatesVersion)" />
+    <PackageVersion Include="Microsoft.Bcl.Cryptography.Xml" Version="9.0.0" />
+    <PackageVersion Update="Microsoft.Bcl.Cryptography.Xml" Condition="'$(MicrosoftBclCryptographyVersion)' != ''" Version="$(MicrosoftBclCryptographyVersion)" />
+
+    <!-- when this is bumped the submodule in https://github.com/dotnet/source-build-externals needs to be bumped in sync -->
+    <PackageVersion Include="Microsoft.VisualStudio.SolutionPersistence" Version="1.0.52" />
+    <PackageVersion Update="Microsoft.VisualStudio.SolutionPersistence" Condition="'$(MicrosoftVisualStudioSolutionPersistenceVersion)' != ''" Version="$(MicrosoftVisualStudioSolutionPersistenceVersion)" />
 
     <PackageVersion Include="Verify.Xunit" Version="19.14.1" />
     <PackageVersion Update="Verify.XUnit" Condition="'$(VerifyXUnitVersion)' != ''" Version="$(VerifyXUnitVersion)" />
-	
-	<PackageVersion Include="Microsoft.VisualStudio.SolutionPersistence" Version="$(MicrosoftVisualStudioSolutionPersistenceVersion)" />
+
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildSourceOnly)' != 'true' AND $(ProjectIsDeprecated) != 'true'">
     <GlobalPackageReference Include="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="3.3.4" />
-    <GlobalPackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.507" PrivateAssets="all"/>
+    <GlobalPackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.556" PrivateAssets="all"/>
     <GlobalPackageReference Include="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.36" PrivateAssets="All" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
diff --git a/global.json b/global.json
index 8d2ec6f0928..ee7246df20f 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "9.0.100",
+    "dotnet": "9.0.103",
     "vs": {
       "version": "17.12.0"
     },
     "xcopy-msbuild": "17.12.0"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.24623.3"
+    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.25111.5"
   }
 }
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index fcf15461cc3..cfd643aea0e 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -29,8 +29,10 @@ public class SolutionFile_Tests
         /// <summary>
         /// Test that a project with the C++ project guid and an extension of vcproj is seen as invalid.
         /// </summary>
-        [Fact]
-        public void ParseSolution_VC()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseSolution_VC(bool isOptInSlnParsingWithNewParser)
         {
             string solutionFileContents =
             """
@@ -57,18 +59,20 @@ public void ParseSolution_VC()
 
             Assert.Throws<InvalidProjectFileException>(() =>
             {
-                ParseSolutionHelper(solutionFileContents);
+                ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser);
                 Assert.Fail("Should not get here");
             });
         }
+
         /// <summary>
         /// Test that a project with the C++ project guid and an arbitrary extension is seen as valid --
         /// we assume that all C++ projects except .vcproj are MSBuild format.
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void ParseSolution_VC2(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void ParseSolution_VC2(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -93,11 +97,11 @@ public void ParseSolution_VC2(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             string expectedProjectName = convertToSlnx ? "Project name" : "Project name.myvctype";
             Assert.Equal(expectedProjectName, solution.ProjectsInOrder[0].ProjectName);
-            Assert.Equal(ConvertToUnixPathIfNeeded("Relative path\\to\\Project name.myvctype"), solution.ProjectsInOrder[0].RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("Relative path\\to\\Project name.myvctype", convertToSlnx || isOptInSlnParsingWithNewParser), solution.ProjectsInOrder[0].RelativePath);
             if (!convertToSlnx)
             {
                 // When converting to SLNX, the project GUID is not preserved.
@@ -106,11 +110,14 @@ public void ParseSolution_VC2(bool convertToSlnx)
         }
 
         /// <summary>
-        /// Solution with an empty project name.  This is somewhat malformed, but we should
-        /// still behave reasonably instead of crashing.
+        /// Solution with an empty project name.  
+        // This is somewhat malformed, but with old parser we should still behave reasonably instead of crashing.
+        // The new parser throws an exception.
         /// </summary>
-        [Fact]
-        public void ParseSolution_EmptyProjectName()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseSolution_EmptyProjectName(bool isOptInSlnParsingWithNewParser)
         {
             string solutionFileContents =
             """
@@ -135,19 +142,30 @@ public void ParseSolution_EmptyProjectName()
             EndGlobal
             """;
 
-            Assert.Throws<InvalidProjectFileException>(() =>
+            if (isOptInSlnParsingWithNewParser)
             {
-                SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-            });
+                Assert.Throws<InvalidProjectFileException>(() =>
+                {
+                    SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser);
+                });
+            }
+            else
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser);
+                Assert.StartsWith("EmptyProjectName", solution.ProjectsInOrder[0].ProjectName);
+                Assert.Equal("src\\.proj", solution.ProjectsInOrder[0].RelativePath);
+                Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
+            }
         }
 
         /// <summary>
         /// Tests the parsing of a very basic .SLN file with three independent projects.
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void BasicSolution(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void BasicSolution(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -184,23 +202,24 @@ public void BasicSolution(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             Assert.Equal(3, solution.ProjectsInOrder.Count);
 
             // When converting to slnx, the order of the projects is not preserved.
+            bool usesNewParser = convertToSlnx || isOptInSlnParsingWithNewParser;
             ProjectInSolution consoleApplication1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ConsoleApplication1");
-            Assert.Equal(ConvertToUnixPathIfNeeded("ConsoleApplication1\\ConsoleApplication1.vbproj"), consoleApplication1.RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ConsoleApplication1\\ConsoleApplication1.vbproj", usesNewParser), consoleApplication1.RelativePath);
             Assert.Empty(consoleApplication1.Dependencies);
             Assert.Null(consoleApplication1.ParentProjectGuid);
 
             ProjectInSolution vbClassLibrary = solution.ProjectsInOrder.First(p => p.ProjectName == "vbClassLibrary");
-            Assert.Equal(ConvertToUnixPathIfNeeded("vbClassLibrary\\vbClassLibrary.vbproj"), vbClassLibrary.RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("vbClassLibrary\\vbClassLibrary.vbproj", usesNewParser), vbClassLibrary.RelativePath);
             Assert.Empty(vbClassLibrary.Dependencies);
             Assert.Null(vbClassLibrary.ParentProjectGuid);
 
             ProjectInSolution classLibrary1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj"), classLibrary1.RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", usesNewParser), classLibrary1.RelativePath);
             Assert.Empty(classLibrary1.Dependencies);
             Assert.Null(classLibrary1.ParentProjectGuid);
 
@@ -216,6 +235,7 @@ public void BasicSolution(bool convertToSlnx)
         /// Exercises solution folders, and makes sure that samely named projects in different
         /// solution folders will get correctly uniquified.
         /// For the new parser, solution folders are not included to ProjectsInOrder or ProjectsByGuid.
+        /// See the test with the same name in SolutionFile_Tests_OldParser.
         /// </summary>
         [Theory]
         [InlineData(false)]
@@ -266,23 +286,25 @@ public void SolutionFolders(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            bool isOptInSlnParsingWithNewParser = !convertToSlnx;
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             Assert.Equal(3, solution.ProjectsInOrder.Count);
 
+            bool usesNewParser = convertToSlnx || isOptInSlnParsingWithNewParser;
             var classLibrary1 = solution.ProjectsInOrder
-                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj"));
+                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", usesNewParser));
             Assert.NotNull(classLibrary1);
             Assert.Empty(classLibrary1.Dependencies);
             Assert.Null(classLibrary1.ParentProjectGuid);
 
             var myPhysicalFolderClassLibrary1 = solution.ProjectsInOrder
-                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("MyPhysicalFolder\\ClassLibrary1\\ClassLibrary1.csproj"));
+                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("MyPhysicalFolder\\ClassLibrary1\\ClassLibrary1.csproj", usesNewParser));
             Assert.NotNull(myPhysicalFolderClassLibrary1);
             Assert.Empty(myPhysicalFolderClassLibrary1.Dependencies);
 
             var classLibrary2 = solution.ProjectsInOrder
-                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj"));
+                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", usesNewParser));
             Assert.NotNull(classLibrary2);
             Assert.Empty(classLibrary2.Dependencies);
 
@@ -305,9 +327,10 @@ public void SolutionFolders(bool convertToSlnx)
         /// are correctly recognized by the solution parser.
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void SolutionDependencies(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void SolutionDependencies(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -351,7 +374,7 @@ public void SolutionDependencies(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             Assert.Equal(3, solution.ProjectsInOrder.Count);
 
@@ -359,19 +382,20 @@ public void SolutionDependencies(bool convertToSlnx)
             var classLibrary2 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary2");
             var classLibrary3 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary3");
 
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj"), classLibrary1.RelativePath);
+            bool usesNewParser = convertToSlnx || isOptInSlnParsingWithNewParser;
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", usesNewParser), classLibrary1.RelativePath);
             Assert.Single(classLibrary1.Dependencies);
             Assert.Equal(classLibrary3.ProjectGuid, classLibrary1.Dependencies[0]);
             Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
 
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj"), classLibrary2.RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", usesNewParser), classLibrary2.RelativePath);
             Assert.Equal(2, classLibrary2.Dependencies.Count);
             // When converting to SLNX, the projects dependencies order is not preserved.
             Assert.Contains(classLibrary3.ProjectGuid, classLibrary2.Dependencies);
             Assert.Contains(classLibrary1.ProjectGuid, classLibrary2.Dependencies);
             Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
 
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary3\\ClassLibrary3.csproj"), solution.ProjectsInOrder[2].RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary3\\ClassLibrary3.csproj", usesNewParser), solution.ProjectsInOrder[2].RelativePath);
             Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
             Assert.Null(solution.ProjectsInOrder[2].ParentProjectGuid);
         }
@@ -380,9 +404,10 @@ public void SolutionDependencies(bool convertToSlnx)
         /// Make sure the solution configurations get parsed correctly for a simple mixed C#/VC solution
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void ParseSolutionConfigurations(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void ParseSolutionConfigurations(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -432,7 +457,7 @@ public void ParseSolutionConfigurations(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             Assert.Equal(7, solution.SolutionConfigurations.Count);
 
@@ -457,9 +482,10 @@ public void ParseSolutionConfigurations(bool convertToSlnx)
         /// Make sure the solution configurations get parsed correctly for a simple C# application
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void ParseSolutionConfigurationsNoMixedPlatform(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void ParseSolutionConfigurationsNoMixedPlatform(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -494,7 +520,7 @@ public void ParseSolutionConfigurationsNoMixedPlatform(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             Assert.Equal(6, solution.SolutionConfigurations.Count);
 
@@ -520,9 +546,10 @@ public void ParseSolutionConfigurationsNoMixedPlatform(bool convertToSlnx)
         /// for a simple mixed C#/VC solution
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void ParseProjectConfigurationsInSolutionConfigurations1(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void ParseProjectConfigurationsInSolutionConfigurations1(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -569,7 +596,7 @@ public void ParseProjectConfigurationsInSolutionConfigurations1(bool convertToSl
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             ProjectInSolution csharpProject = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
             ProjectInSolution vcProject = solution.ProjectsInOrder.First(p => p.ProjectName == "MainApp");
@@ -616,9 +643,10 @@ public void ParseProjectConfigurationsInSolutionConfigurations1(bool convertToSl
         }
 
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void ParseProjectConfigurationsInSolutionConfigurations2(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void ParseProjectConfigurationsInSolutionConfigurations2(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -626,9 +654,9 @@ public void ParseProjectConfigurationsInSolutionConfigurations2(bool convertToSl
                 # Visual Studio Version 17
                 VisualStudioVersion = 17.11.35111.106
                 MinimumVisualStudioVersion = 10.0.40219.1
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""WinFormsApp1"", ""WinFormsApp1\WinFormsApp1.csproj"", ""{3B592A6A-6215-4675-9237-7FEB36BDB4F1}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "WinFormsApp1", "WinFormsApp1\WinFormsApp1.csproj", "{3B592A6A-6215-4675-9237-7FEB36BDB4F1}"
                 EndProject
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""ClassLibrary1"", ""ClassLibrary1\ClassLibrary1.csproj"", ""{C25056E0-405C-4476-9B22-839264A8530C}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ClassLibrary1", "ClassLibrary1\ClassLibrary1.csproj", "{C25056E0-405C-4476-9B22-839264A8530C}"
                 EndProject
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -654,7 +682,7 @@ public void ParseProjectConfigurationsInSolutionConfigurations2(bool convertToSl
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             ProjectInSolution winFormsApp1 = solution.ProjectsInOrder.First(p => p.ProjectName == "WinFormsApp1");
             ProjectInSolution classLibrary1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
@@ -680,16 +708,17 @@ public void ParseProjectConfigurationsInSolutionConfigurations2(bool convertToSl
         /// Helper method to create a SolutionFile object, and call it to parse the SLN file
         /// represented by the string contents passed in. Optionally can convert the SLN to SLNX and then parse the solution.
         /// </summary>
-        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool convertToSlnx = false)
+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool isOptInSlnParsingWithNewParser, bool convertToSlnx = false)
         {
             solutionFileContents = solutionFileContents.Replace('\'', '"');
-
             using (TestEnvironment testEnvironment = TestEnvironment.Create())
             {
+                if (isOptInSlnParsingWithNewParser)
+                {
+                    testEnvironment.SetEnvironmentVariable("MSBUILD_PARSE_SLN_WITH_SOLUTIONPERSISTENCE", "1");
+                }
                 TransientTestFile sln = testEnvironment.CreateFile(FileUtilities.GetTemporaryFileName(".sln"), solutionFileContents);
-
                 string solutionPath = convertToSlnx ? ConvertToSlnx(sln.Path) : sln.Path;
-
                 return SolutionFile.Parse(solutionPath);
             }
         }
@@ -703,10 +732,10 @@ private static string ConvertToSlnx(string slnPath)
             return slnxPath;
         }
 
-        private static string ConvertToUnixPathIfNeeded(string path)
+        private static string ConvertToUnixPathIfNeeded(string path, bool usesNewParser)
         {
             // In the new parser, ProjectModel.FilePath is converted to Unix-style.
-            return !NativeMethodsShared.IsWindows ? path.Replace('\\', '/') : path;
+            return usesNewParser && !NativeMethodsShared.IsWindows ? path.Replace('\\', '/') : path;
         }
     }
 }
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index df1c15ea5e6..dc35f5d7d0b 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -20,10 +20,11 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
 
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
+
     <PackageDownload Include="NuGet.CommandLine" Version="[$(NuGetCommandLinePackageVersion)]" />
   </ItemGroup>
 
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
index 72f2b212e3f..99f6603f61c 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
@@ -78,28 +78,19 @@ public BuildManager_Logging_Tests(ITestOutputHelper output)
             _env = TestEnvironment.Create(output);
         }
 
-        [DotNetOnlyTheory]
-        [InlineData("1", true)]
-        // [InlineData("0", true)] <-- explicitly opting out on core will lead to node crash (as documented)
-        [InlineData(null, true)]
-        public void Build_WithCustomBuildArgs_NetCore(string envVariableValue, bool isWarningExpected)
-            => TestCustomEventWarning<BuildErrorEventArgs>(envVariableValue, isWarningExpected);
-
-        [WindowsFullFrameworkOnlyTheory]
-        [InlineData("1", true)]
-        [InlineData("0", false)]
-        [InlineData(null, true)]
-        public void Build_WithCustomBuildArgs_Framework(string envVariableValue, bool isWarningExpected) =>
-            TestCustomEventWarning<BuildWarningEventArgs>(envVariableValue, isWarningExpected);
-
-        private void TestCustomEventWarning<T>(string envVariableValue, bool isWarningExpected) where T : LazyFormattedBuildEventArgs
+        [DotNetOnlyFact]
+        public void Build_WithCustomBuildArgs_ShouldEmitErrorOnNetCore() => Build_WithCustomBuildArgs_ShouldEmitEvent<BuildErrorEventArgs>();
+
+        [WindowsFullFrameworkOnlyFact]
+        public void Build_WithCustomBuildArgs_ShouldEmitWarningOnFramework() => Build_WithCustomBuildArgs_ShouldEmitEvent<BuildWarningEventArgs>();
+
+        private void Build_WithCustomBuildArgs_ShouldEmitEvent<T>() where T : LazyFormattedBuildEventArgs
         {
-            var testFiles = _env.CreateTestProjectWithFiles(string.Empty, new[] { "main", "child1" }, string.Empty);
+            var testFiles = _env.CreateTestProjectWithFiles(string.Empty, ["main", "child1"], string.Empty);
 
             ILoggingService service = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(_logger);
 
-            _env.SetEnvironmentVariable("MSBUILDCUSTOMBUILDEVENTWARNING", envVariableValue);
             _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
 
             _buildManager.BeginBuild(BuildParameters);
@@ -118,24 +109,17 @@ private void TestCustomEventWarning<T>(string envVariableValue, bool isWarningEx
                    mainProjectPath,
                    new Dictionary<string, string>(),
                    MSBuildConstants.CurrentToolsVersion,
-                   new[] { "MainTarget" },
+                   ["MainTarget"],
                    null);
 
                 var submission = _buildManager.PendBuildRequest(buildRequestData);
                 var result = submission.Execute();
                 var allEvents = _logger.AllBuildEvents;
 
-                if (isWarningExpected)
-                {
-                    allEvents.OfType<T>().ShouldHaveSingleItem();
-                    allEvents.First(x => x is T).Message.ShouldContain(
-                        string.Format(ResourceUtilities.GetResourceString("DeprecatedEventSerialization"),
-                        "MyCustomBuildEventArgs"));
-                }
-                else
-                {
-                    allEvents.OfType<T>().ShouldBeEmpty();
-                }
+                allEvents.OfType<T>().ShouldHaveSingleItem();
+                allEvents.First(x => x is T).Message.ShouldContain(
+                    string.Format(ResourceUtilities.GetResourceString("DeprecatedEventSerialization"),
+                    "MyCustomBuildEventArgs"));
             }
             finally
             {
diff --git a/src/Build.UnitTests/BackEnd/KnownTelemetry_Tests.cs b/src/Build.UnitTests/BackEnd/KnownTelemetry_Tests.cs
index cfbf63deebd..5f25dc3a248 100644
--- a/src/Build.UnitTests/BackEnd/KnownTelemetry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/KnownTelemetry_Tests.cs
@@ -35,19 +35,19 @@ public void BuildTelemetryConstructedHasNoProperties()
     {
         BuildTelemetry buildTelemetry = new BuildTelemetry();
 
-        buildTelemetry.DisplayVersion.ShouldBeNull();
+        buildTelemetry.BuildEngineDisplayVersion.ShouldBeNull();
         buildTelemetry.EventName.ShouldBe("build");
         buildTelemetry.FinishedAt.ShouldBeNull();
-        buildTelemetry.FrameworkName.ShouldBeNull();
-        buildTelemetry.Host.ShouldBeNull();
-        buildTelemetry.InitialServerState.ShouldBeNull();
+        buildTelemetry.BuildEngineFrameworkName.ShouldBeNull();
+        buildTelemetry.BuildEngineHost.ShouldBeNull();
+        buildTelemetry.InitialMSBuildServerState.ShouldBeNull();
         buildTelemetry.InnerStartAt.ShouldBeNull();
-        buildTelemetry.Project.ShouldBeNull();
+        buildTelemetry.ProjectPath.ShouldBeNull();
         buildTelemetry.ServerFallbackReason.ShouldBeNull();
         buildTelemetry.StartAt.ShouldBeNull();
-        buildTelemetry.Success.ShouldBeNull();
-        buildTelemetry.Target.ShouldBeNull();
-        buildTelemetry.Version.ShouldBeNull();
+        buildTelemetry.BuildSuccess.ShouldBeNull();
+        buildTelemetry.BuildTarget.ShouldBeNull();
+        buildTelemetry.BuildEngineVersion.ShouldBeNull();
 
         buildTelemetry.GetProperties().ShouldBeEmpty();
     }
@@ -61,18 +61,18 @@ public void BuildTelemetryCreateProperProperties()
         DateTime innerStartAt = new DateTime(2023, 01, 02, 10, 20, 30);
         DateTime finishedAt = new DateTime(2023, 12, 13, 14, 15, 16);
 
-        buildTelemetry.DisplayVersion = "Some Display Version";
+        buildTelemetry.BuildEngineDisplayVersion = "Some Display Version";
         buildTelemetry.FinishedAt = finishedAt;
-        buildTelemetry.FrameworkName = "new .NET";
-        buildTelemetry.Host = "Host description";
-        buildTelemetry.InitialServerState = "hot";
+        buildTelemetry.BuildEngineFrameworkName = "new .NET";
+        buildTelemetry.BuildEngineHost = "Host description";
+        buildTelemetry.InitialMSBuildServerState = "hot";
         buildTelemetry.InnerStartAt = innerStartAt;
-        buildTelemetry.Project = @"C:\\dev\\theProject";
+        buildTelemetry.ProjectPath = @"C:\\dev\\theProject";
         buildTelemetry.ServerFallbackReason = "busy";
         buildTelemetry.StartAt = startAt;
-        buildTelemetry.Success = true;
-        buildTelemetry.Target = "clean";
-        buildTelemetry.Version = new Version(1, 2, 3, 4);
+        buildTelemetry.BuildSuccess = true;
+        buildTelemetry.BuildTarget = "clean";
+        buildTelemetry.BuildEngineVersion = new Version(1, 2, 3, 4);
 
         var properties = buildTelemetry.GetProperties();
 
diff --git a/src/Build.UnitTests/BackEnd/MockHost.cs b/src/Build.UnitTests/BackEnd/MockHost.cs
index 44fc3ad9ff0..1f08b92bf79 100644
--- a/src/Build.UnitTests/BackEnd/MockHost.cs
+++ b/src/Build.UnitTests/BackEnd/MockHost.cs
@@ -9,6 +9,7 @@
 using Microsoft.Build.Engine.UnitTests.BackEnd;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
+using Microsoft.Build.TelemetryInfra;
 using LegacyThreadingData = Microsoft.Build.Execution.LegacyThreadingData;
 
 #nullable disable
@@ -64,6 +65,8 @@ internal sealed class MockHost : MockLoggingService, IBuildComponentHost, IBuild
 
         private IBuildCheckManagerProvider _buildCheckManagerProvider;
 
+        private TelemetryForwarderProvider _telemetryForwarder;
+
         #region SystemParameterFields
 
         #endregion;
@@ -132,6 +135,9 @@ public MockHost(BuildParameters buildParameters, ConfigCache overrideConfigCache
 
             _buildCheckManagerProvider = new NullBuildCheckManagerProvider();
             ((IBuildComponent)_buildCheckManagerProvider).InitializeComponent(this);
+
+            _telemetryForwarder = new TelemetryForwarderProvider();
+            ((IBuildComponent)_telemetryForwarder).InitializeComponent(this);
         }
 
         /// <summary>
@@ -201,6 +207,7 @@ public IBuildComponent GetComponent(BuildComponentType type)
                 BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
                 BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
                 BuildComponentType.BuildCheckManagerProvider => (IBuildComponent)_buildCheckManagerProvider,
+                BuildComponentType.TelemetryForwarder => (IBuildComponent)_telemetryForwarder,
                 _ => throw new ArgumentException("Unexpected type " + type),
             };
         }
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index d98332159c9..3da36a531ab 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -80,6 +80,7 @@ public void VerifyEventType()
             BuildSubmissionStartedEventArgs buildSubmissionStarted = new(new Dictionary<string, string> { { "Value1", "Value2" } }, ["Path1"], ["TargetName"], BuildRequestDataFlags.ReplaceExistingProjectInstance, 123);
             BuildCheckTracingEventArgs buildCheckTracing = new();
             BuildCanceledEventArgs buildCanceled = new("message", DateTime.UtcNow);
+            WorkerNodeTelemetryEventArgs workerNodeTelemetry = new();
 
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
             VerifyLoggingPacket(buildStarted, LoggingEventType.BuildStartedEvent);
@@ -116,6 +117,7 @@ public void VerifyEventType()
             VerifyLoggingPacket(buildSubmissionStarted, LoggingEventType.BuildSubmissionStartedEvent);
             VerifyLoggingPacket(buildCheckTracing, LoggingEventType.BuildCheckTracingEvent);
             VerifyLoggingPacket(buildCanceled, LoggingEventType.BuildCanceledEvent);
+            VerifyLoggingPacket(workerNodeTelemetry, LoggingEventType.WorkerNodeTelemetryEvent);
         }
 
         private static BuildEventContext CreateBuildEventContext()
diff --git a/src/Build.UnitTests/BackEnd/OpenTelemetryActivities_Tests.cs b/src/Build.UnitTests/BackEnd/OpenTelemetryActivities_Tests.cs
new file mode 100644
index 00000000000..cd041632de2
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/OpenTelemetryActivities_Tests.cs
@@ -0,0 +1,196 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using System.Text;
+using Xunit;
+using Shouldly;
+
+namespace Microsoft.Build.Framework.Telemetry.Tests
+{
+    public class ActivityExtensionsTests
+    {
+        [Fact]
+        public void WithTag_ShouldSetUnhashedValue()
+        {
+            var activity = new Activity("TestActivity");
+            activity.Start(); 
+
+            var telemetryItem = new TelemetryItem(
+                Name: "TestItem",
+                Value: "TestValue",
+                NeedsHashing: false);
+
+            activity.WithTag(telemetryItem);
+
+            var tagValue = activity.GetTagItem("VS.MSBuild.TestItem");
+            tagValue.ShouldNotBeNull();
+            tagValue.ShouldBe("TestValue");
+
+            activity.Dispose();
+        }
+
+        [Fact]
+        public void WithTag_ShouldSetHashedValue()
+        {
+            var activity = new Activity("TestActivity");
+            var telemetryItem = new TelemetryItem(
+                Name: "TestItem",
+                Value: "SensitiveValue",
+                NeedsHashing: true);
+
+            activity.WithTag(telemetryItem);
+
+            var tagValue = activity.GetTagItem("VS.MSBuild.TestItem");
+            tagValue.ShouldNotBeNull();
+            tagValue.ShouldNotBe("SensitiveValue"); // Ensure it’s not the plain text
+            activity.Dispose();
+        }
+
+        [Fact]
+        public void WithTags_ShouldSetMultipleTags()
+        {
+            var activity = new Activity("TestActivity");
+            var tags = new List<TelemetryItem>
+            {
+                new("Item1", "Value1", false),
+                new("Item2", "Value2", true)  // hashed
+            };
+
+            activity.WithTags(tags);
+
+            var tagValue1 = activity.GetTagItem("VS.MSBuild.Item1");
+            var tagValue2 = activity.GetTagItem("VS.MSBuild.Item2");
+
+            tagValue1.ShouldNotBeNull();
+            tagValue1.ShouldBe("Value1");
+
+            tagValue2.ShouldNotBeNull();
+            tagValue2.ShouldNotBe("Value2"); // hashed
+
+            activity.Dispose();
+        }
+
+        [Fact]
+        public void WithTags_DataHolderShouldSetMultipleTags()
+        {
+            var activity = new Activity("TestActivity");
+            var dataHolder = new MockTelemetryDataHolder(); // see below
+
+            activity.WithTags(dataHolder);
+
+            var tagValueA = activity.GetTagItem("VS.MSBuild.TagA");
+            var tagValueB = activity.GetTagItem("VS.MSBuild.TagB");
+
+            tagValueA.ShouldNotBeNull();
+            tagValueA.ShouldBe("ValueA");
+
+            tagValueB.ShouldNotBeNull();
+            tagValueB.ShouldNotBe("ValueB"); // should be hashed
+            activity.Dispose();
+        }
+
+        [Fact]
+        public void WithStartTime_ShouldSetActivityStartTime()
+        {
+            var activity = new Activity("TestActivity");
+            var now = DateTime.UtcNow;
+
+            activity.WithStartTime(now);
+
+            activity.StartTimeUtc.ShouldBe(now);
+            activity.Dispose();
+        }
+
+        [Fact]
+        public void WithStartTime_NullDateTime_ShouldNotSetStartTime()
+        {
+            var activity = new Activity("TestActivity");
+            var originalStartTime = activity.StartTimeUtc; // should be default (min) if not started
+
+            activity.WithStartTime(null);
+
+            activity.StartTimeUtc.ShouldBe(originalStartTime);
+
+            activity.Dispose();
+        }
+    }
+
+    /// <summary>
+    /// A simple mock for testing IActivityTelemetryDataHolder. 
+    /// Returns two items: one hashed, one not hashed.
+    /// </summary>
+    internal sealed class MockTelemetryDataHolder : IActivityTelemetryDataHolder
+    {
+        public IList<TelemetryItem> GetActivityProperties()
+        {
+            return new List<TelemetryItem>
+            {
+                new("TagA", "ValueA", false),
+                new("TagB", "ValueB", true),
+            };
+        }
+    }
+
+
+    public class MSBuildActivitySourceTests
+    {
+        [Fact]
+        public void StartActivity_ShouldPrefixNameCorrectly_WhenNoRemoteParent()
+        {
+            var source = new MSBuildActivitySource(TelemetryConstants.DefaultActivitySourceNamespace, 1.0);
+            using var listener = new ActivityListener
+            {
+                ShouldListenTo = activitySource => activitySource.Name == TelemetryConstants.DefaultActivitySourceNamespace,
+                Sample = (ref ActivityCreationOptions<ActivityContext> options) => ActivitySamplingResult.AllData,
+            };
+            ActivitySource.AddActivityListener(listener);
+
+
+            var activity = source.StartActivity("Build");
+
+            activity.ShouldNotBeNull();
+            activity?.DisplayName.ShouldBe("VS/MSBuild/Build");
+
+            activity?.Dispose();
+        }
+
+        [Fact]
+        public void StartActivity_ShouldUseParentId_WhenRemoteParentExists()
+        {
+            // Arrange
+            var parentActivity = new Activity("ParentActivity");
+            parentActivity.SetParentId("|12345.abcde.");  // Simulate some parent trace ID
+            parentActivity.AddTag("sampleTag", "sampleVal");
+            parentActivity.Start();
+
+            var source = new MSBuildActivitySource(TelemetryConstants.DefaultActivitySourceNamespace, 1.0);
+            using var listener = new ActivityListener
+            {
+                ShouldListenTo = activitySource => activitySource.Name == TelemetryConstants.DefaultActivitySourceNamespace,
+                Sample = (ref ActivityCreationOptions<ActivityContext> options) => ActivitySamplingResult.AllData,
+            };
+            ActivitySource.AddActivityListener(listener);
+
+            // Act
+            var childActivity = source.StartActivity("ChildBuild");
+
+            // Assert
+            childActivity.ShouldNotBeNull();
+            // If HasRemoteParent is true, the code uses `parentId: Activity.Current.ParentId`.
+            // However, by default .NET Activity doesn't automatically set HasRemoteParent = true
+            // unless you explicitly set it. If you have logic that sets it, you can test it here.
+            // For demonstration, we assume the ParentId is carried over if HasRemoteParent == true.
+            if (Activity.Current?.HasRemoteParent == true)
+            {
+                childActivity?.ParentId.ShouldBe("|12345.abcde.");
+            }
+
+            parentActivity.Dispose();
+            childActivity?.Dispose();
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/OpenTelemetryManager_Tests.cs b/src/Build.UnitTests/BackEnd/OpenTelemetryManager_Tests.cs
new file mode 100644
index 00000000000..a2ec5161797
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/OpenTelemetryManager_Tests.cs
@@ -0,0 +1,152 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Reflection;
+using Xunit;
+using Shouldly;
+using Xunit.Abstractions;
+using Microsoft.Build.UnitTests.Shared;
+using Microsoft.Build.UnitTests;
+
+namespace Microsoft.Build.Framework.Telemetry.Tests
+{
+    /// <summary>
+    /// Ensures tests run serially so environment variables and the singleton do not interfere with parallel test runs.
+    /// </summary>
+    [Collection("OpenTelemetryManagerTests")]
+    public class OpenTelemetryManagerTests : IDisposable
+    {
+
+        private const string TelemetryFxOptoutEnvVarName = "MSBUILD_TELEMETRY_OPTOUT";
+        private const string DotnetOptOut = "DOTNET_CLI_TELEMETRY_OPTOUT";
+        private const string TelemetrySampleRateOverrideEnvVarName = "MSBUILD_TELEMETRY_SAMPLE_RATE";
+        private const string VS1714TelemetryOptInEnvVarName = "MSBUILD_TELEMETRY_OPTIN";
+
+        private string? preTestFxOptout;
+        private string? preTestDotnetOptout;
+        private string? preTestSampleRate;
+        private string? preTestVS1714TelemetryOptIn;
+
+        public OpenTelemetryManagerTests()
+        {
+            // control environment state before each test
+            SaveEnvVars();
+            ResetManagerState();
+            ResetEnvVars();
+        }
+
+        private void SaveEnvVars()
+        {
+            preTestFxOptout = Environment.GetEnvironmentVariable(TelemetryFxOptoutEnvVarName);
+            preTestDotnetOptout = Environment.GetEnvironmentVariable(DotnetOptOut);
+            preTestSampleRate = Environment.GetEnvironmentVariable(TelemetrySampleRateOverrideEnvVarName);
+            preTestVS1714TelemetryOptIn = Environment.GetEnvironmentVariable(VS1714TelemetryOptInEnvVarName);
+        }
+
+        private void RestoreEnvVars()
+        {
+            Environment.SetEnvironmentVariable(TelemetryFxOptoutEnvVarName, preTestFxOptout);
+            Environment.SetEnvironmentVariable(DotnetOptOut, preTestDotnetOptout);
+            Environment.SetEnvironmentVariable(TelemetrySampleRateOverrideEnvVarName, preTestSampleRate);
+            Environment.SetEnvironmentVariable(VS1714TelemetryOptInEnvVarName, preTestVS1714TelemetryOptIn);
+        }
+
+        private void ResetEnvVars()
+        {
+            Environment.SetEnvironmentVariable(DotnetOptOut, null);
+            Environment.SetEnvironmentVariable(TelemetryFxOptoutEnvVarName, null);
+            Environment.SetEnvironmentVariable(TelemetrySampleRateOverrideEnvVarName, null);
+            Environment.SetEnvironmentVariable(VS1714TelemetryOptInEnvVarName, null);
+        }
+
+        public void Dispose()
+        {
+            RestoreEnvVars();
+        }
+
+        [Theory]
+        [InlineData(DotnetOptOut, "true")]
+        [InlineData(TelemetryFxOptoutEnvVarName, "true")]
+        [InlineData(DotnetOptOut, "1")]
+        [InlineData(TelemetryFxOptoutEnvVarName, "1")]
+        public void Initialize_ShouldSetStateToOptOut_WhenOptOutEnvVarIsTrue(string optoutVar, string value)
+        {
+            // Arrange
+            Environment.SetEnvironmentVariable(optoutVar, value);
+
+            // Act
+            OpenTelemetryManager.Instance.Initialize(isStandalone: false);
+
+            // Assert
+            OpenTelemetryManager.Instance.IsActive().ShouldBeFalse();
+        }
+
+#if NET
+        [Fact]
+        public void Initialize_ShouldSetStateToUnsampled_WhenNoOverrideOnNetCore()
+        {
+            Environment.SetEnvironmentVariable(TelemetrySampleRateOverrideEnvVarName, null);
+
+            OpenTelemetryManager.Instance.Initialize(isStandalone: false);
+
+            // If no override on .NET, we expect no Active ActivitySource
+            OpenTelemetryManager.Instance.DefaultActivitySource.ShouldBeNull();
+        }
+#endif
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void Initialize_ShouldSetSampleRateOverride_AndCreateActivitySource_WhenRandomBelowOverride(bool standalone)
+        {
+            // Arrange
+            Environment.SetEnvironmentVariable(VS1714TelemetryOptInEnvVarName, "1");
+            Environment.SetEnvironmentVariable(TelemetrySampleRateOverrideEnvVarName, "1.0");
+
+            // Act
+            OpenTelemetryManager.Instance.Initialize(isStandalone: standalone);
+
+            // Assert
+            OpenTelemetryManager.Instance.IsActive().ShouldBeTrue();
+            OpenTelemetryManager.Instance.DefaultActivitySource.ShouldNotBeNull();
+        }
+
+        [Fact]
+        public void Initialize_ShouldNoOp_WhenCalledMultipleTimes()
+        {
+            Environment.SetEnvironmentVariable(DotnetOptOut, "true");
+            OpenTelemetryManager.Instance.Initialize(isStandalone: true);
+            var state1 = OpenTelemetryManager.Instance.IsActive();
+
+            Environment.SetEnvironmentVariable(DotnetOptOut, null);
+            OpenTelemetryManager.Instance.Initialize(isStandalone: true);
+            var state2 = OpenTelemetryManager.Instance.IsActive();
+
+            // Because the manager is already initialized, second call is a no-op
+            state1.ShouldBe(false);
+            state2.ShouldBe(false);
+        }
+
+        /* Helper methods */
+
+        /// <summary>
+        /// Resets the singleton manager to a known uninitialized state so each test is isolated.
+        /// </summary>
+        private void ResetManagerState()
+        {
+            var instance = OpenTelemetryManager.Instance;
+
+            // 1. Reset the private _telemetryState field
+            var telemetryStateField = typeof(OpenTelemetryManager)
+                .GetField("_telemetryState", BindingFlags.NonPublic | BindingFlags.Instance);
+            telemetryStateField?.SetValue(instance, OpenTelemetryManager.TelemetryState.Uninitialized);
+
+            // 2. Null out the DefaultActivitySource property
+            var defaultSourceProp = typeof(OpenTelemetryManager)
+                .GetProperty(nameof(OpenTelemetryManager.DefaultActivitySource),
+                    BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
+            defaultSourceProp?.SetValue(instance, null);
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 707587dd7b8..2eef5fde018 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -881,8 +881,11 @@ public void RoundTripPropertyReassignmentEventArgs()
                 propertyName: "a",
                 previousValue: "b",
                 newValue: "c",
-                location: "d",
-                message: "Property reassignment: $(a)=\"c\" (previous value: \"b\") at d",
+                location: null,
+                file: "file.cs",
+                line: 10,
+                column: 20,
+                message: "Property reassignment: $(a)=\"c\" (previous value: \"b\") at file.cs (10,20)",
                 helpKeyword: "e",
                 senderName: "f");
 
@@ -900,8 +903,8 @@ public void RoundTripPropertyReassignmentEventArgs()
         public void UninitializedPropertyReadEventArgs()
         {
             var args = new UninitializedPropertyReadEventArgs(
-                propertyName: Guid.NewGuid().ToString(),
-                message: Guid.NewGuid().ToString(),
+                propertyName: "a",
+                message: "Read uninitialized property \"a\"",
                 helpKeyword: Guid.NewGuid().ToString(),
                 senderName: Guid.NewGuid().ToString());
 
@@ -916,17 +919,22 @@ public void UninitializedPropertyReadEventArgs()
         public void PropertyInitialValueEventArgs()
         {
             var args = new PropertyInitialValueSetEventArgs(
-                propertyName: Guid.NewGuid().ToString(),
-                propertyValue: Guid.NewGuid().ToString(),
-                propertySource: Guid.NewGuid().ToString(),
-                message: Guid.NewGuid().ToString(),
+                propertyName: "a",
+                propertyValue: "b",
+                propertySource: null,
+                file: "file.cs",
+                line: 10,
+                column: 20,
+                message: "Property initial value: $(a)=\"b\" Source: file.cs (10,20)",
                 helpKeyword: Guid.NewGuid().ToString(),
                 senderName: Guid.NewGuid().ToString());
 
             Roundtrip(args,
                 e => e.PropertyName,
                 e => e.PropertyValue,
-                e => e.PropertySource,
+                e => e.File,
+                e => e.LineNumber.ToString(),
+                e => e.ColumnNumber.ToString(),
                 e => e.Message,
                 e => e.HelpKeyword,
                 e => e.SenderName);
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index c1fdc67f6a5..67cce196758 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -18,7 +18,6 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
 #nullable disable
@@ -134,7 +133,6 @@ public ConsoleLoggerTest(ITestOutputHelper output)
             _output = output;
         }
 
-
         /// <summary>
         /// Verify when the project has not been named that we correctly get the same placeholder
         /// project name for project started event and the target started event.
diff --git a/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs
index 7b98b820a4f..13ab48079a4 100644
--- a/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -5,6 +5,7 @@
 using System;
 using System.Text;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
 using Xunit;
 
 #nullable disable
@@ -116,5 +117,16 @@ public void ProjectLoadedStrippingCommentsAndWhiteSpaceIsReadOnly()
                 Assert.Equal(string.Empty, children[0].ChildNodes[1].Value);
             }
         }
+
+        [Fact]
+        public void CreateEphemeralCannotBeDirtied()
+        {
+            var projectRootElement = ProjectRootElement.CreateEphemeral(ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            var versionBeforeMarkDirty = projectRootElement.Version;
+
+            projectRootElement.MarkDirty("test", "test");
+
+            Assert.Equal(projectRootElement.Version, versionBeforeMarkDirty);
+        }
     }
 }
diff --git a/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs
index 7f56b600dca..014b8521524 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs
@@ -129,23 +129,22 @@ public void ProjectWithWebsiteProperties(bool convertToSlnx)
         /// Helper method to create a SolutionFile object, and call it to parse the SLN file
         /// represented by the string contents passed in. Optionally can convert the SLN to SLNX and then parse the solution.
         /// </summary>
-        internal static SolutionFile ParseSolutionHelper(string solutionFileContents, bool convertToSlnx = false)
+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool convertToSlnx = false)
         {
             solutionFileContents = solutionFileContents.Replace('\'', '"');
-
             using (TestEnvironment testEnvironment = TestEnvironment.Create())
             {
+                solutionFileContents = solutionFileContents.Replace('\'', '"');
+                testEnvironment.SetEnvironmentVariable("MSBUILD_PARSE_SLN_WITH_SOLUTIONPERSISTENCE", "1");
                 TransientTestFile sln = testEnvironment.CreateFile(FileUtilities.GetTemporaryFileName(".sln"), solutionFileContents);
-
                 string solutionPath = convertToSlnx ? ConvertToSlnx(sln.Path) : sln.Path;
-
                 SolutionFile solutionFile = new SolutionFile { FullPath = solutionPath };
                 solutionFile.ParseUsingNewParser();
                 return solutionFile;
             }
         }
 
-        private static string ConvertToSlnx(string slnPath)
+        internal static string ConvertToSlnx(string slnPath)
         {
             string slnxPath = slnPath + "x";
             ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(slnPath).ShouldNotBeNull();
diff --git a/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
index 6d2a8f9ad1a..71a769aed3b 100644
--- a/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
@@ -284,6 +284,56 @@ public void ParseSolutionFilter(bool convertToSlnx)
             }
         }
 
+        [Fact]
+        public void SolutionFilterWithSpecialSymbolInThePath()
+        {
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+            // Create folder with special symbols in the name
+            folder = testEnvironment.CreateFolder(Path.Combine(folder.Path, $"test@folder%special$symbols"), createFolder: true);
+            // Create simple solution and simple solution filter
+            TransientTestFile sln = testEnvironment.CreateFile(folder, "SimpleSolution.sln",
+            """
+            Microsoft Visual Studio Solution File, Format Version 12.00
+            # Visual Studio Version 17
+            VisualStudioVersion = 17.0.31903.59
+            MinimumVisualStudioVersion = 10.0.40219.1
+            Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "SolutionTest", "SolutionTest.csproj", "{767AA460-C33F-41C3-A8B6-4DA283263A51}"
+            EndProject
+            Global
+                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                    Debug|Any CPU = Debug|Any CPU
+                    Release|Any CPU = Release|Any CPU
+                EndGlobalSection
+                GlobalSection(SolutionProperties) = preSolution
+                    HideSolutionNode = FALSE
+                EndGlobalSection
+                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                    {767AA460-C33F-41C3-A8B6-4DA283263A51}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                    {767AA460-C33F-41C3-A8B6-4DA283263A51}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                    {767AA460-C33F-41C3-A8B6-4DA283263A51}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                    {767AA460-C33F-41C3-A8B6-4DA283263A51}.Release|Any CPU.Build.0 = Release|Any CPU
+                EndGlobalSection
+            EndGlobal
+            """);
+            TransientTestFile slnf = testEnvironment.CreateFile(folder, "SimpleSolution.slnf",
+            """
+            {
+                "solution": {
+                    "path": "SimpleSolution.sln",
+                    "projects": [
+                        "SolutionTest.csproj"
+                    ]
+                }
+            }
+            """);
+
+            SolutionFile sp = SolutionFile.Parse(slnf.Path);
+
+            // just assert that no error is thrown
+            Assert.True(sp.ProjectShouldBuild("SolutionTest.csproj"));
+        }
+
         private static string ConvertToSlnx(string slnPath)
         {
             string slnxPath = slnPath + "x";
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index cd359a54c8b..11179b170c6 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -83,6 +83,36 @@ public void SolutionProjectIgnoresDuplicateDefaultTargets(string name)
             }
         }
 
+        /// <summary>
+        /// Test that targets in before.{sln}.targets and after.{sln}.targets files are included in the project.
+        /// </summary>
+        [Theory]
+        [InlineData("before.MySln.sln.targets", false)]
+        [InlineData("before.MySln.sln.targets", true)]
+        [InlineData("after.MySln.sln.targets", false)]
+        [InlineData("after.MySln.sln.targets", true)]
+        public void SolutionProjectIncludesBeforeAndAfterTargets(string name, bool convertToSlnx)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                string solutionFileContents = "Microsoft Visual Studio Solution File, Format Version 12.00";
+                TransientTestFile sln = testEnvironment.CreateFile(folder, "MySln.sln", solutionFileContents);
+                string solutionPath = convertToSlnx ? SolutionFile_NewParser_Tests.ConvertToSlnx(sln.Path) : sln.Path;
+                testEnvironment.CreateFile(folder, name,
+                      """
+                      <Project>
+                          <Target Name="TestTarget" />
+                      </Project>
+                      """);
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(SolutionFile.Parse(solutionPath), null, null, _buildEventContext, CreateMockLoggingService());
+                instances.ShouldHaveSingleItem();
+                instances[0].Targets.ShouldContainKey("TestTarget");
+                MockLogger logger = new MockLogger(output);
+                instances[0].Build(targets: null, new List<ILogger> { logger }).ShouldBeTrue();
+            }
+        }
+
         [Fact]
         public void BuildProjectAsTarget()
         {
@@ -200,7 +230,6 @@ public void BuildProjectWithMultipleTargets()
             }
         }
 
-
         /// <summary>
         /// Build Solution with Multiple Targets (ex. Clean;Build;Custom).
         /// </summary>
@@ -367,11 +396,15 @@ public void EmitToolsVersionAttributeToInMemoryProject9(bool useNewParser)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, "3.5", _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, "3.5", _buildEventContext, CreateMockLoggingService());
 
-            Assert.Equal("3.5", instances[0].ToolsVersion);
+                Assert.Equal("3.5", instances[0].ToolsVersion);
+            }
         }
 
         /// <summary>
@@ -404,11 +437,15 @@ public void EmitToolsVersionAttributeToInMemoryProject10(bool useNewParser)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, "3.5", _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, "3.5", _buildEventContext, CreateMockLoggingService());
 
-            Assert.Equal("3.5", instances[0].ToolsVersion);
+                Assert.Equal("3.5", instances[0].ToolsVersion);
+            }
         }
 
         /// <summary>
@@ -477,17 +514,21 @@ public void SubToolsetSetBySolutionVersion(bool useNewParser)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, CreateMockLoggingService());
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, instances[0].ToolsVersion);
+                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, instances[0].ToolsVersion);
 
-            // being cautious -- we can't expect the sub-toolset to be picked if it doesn't exist in the first place
-            if (instances[0].Toolset.SubToolsets.ContainsKey("11.0"))
-            {
-                Assert.Equal("11.0", instances[0].SubToolsetVersion);
-                Assert.Equal("11.0", instances[0].GetPropertyValue("VisualStudioVersion"));
+                // being cautious -- we can't expect the sub-toolset to be picked if it doesn't exist in the first place
+                if (instances[0].Toolset.SubToolsets.ContainsKey("11.0"))
+                {
+                    Assert.Equal("11.0", instances[0].SubToolsetVersion);
+                    Assert.Equal("11.0", instances[0].GetPropertyValue("VisualStudioVersion"));
+                }
             }
         }
 
@@ -514,13 +555,17 @@ public void SolutionBasedSubToolsetVersionOverriddenByEnvironment(bool useNewPar
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, CreateMockLoggingService());
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, instances[0].ToolsVersion);
-            Assert.Equal("ABC", instances[0].SubToolsetVersion);
-            Assert.Equal("ABC", instances[0].GetPropertyValue("VisualStudioVersion"));
+                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, instances[0].ToolsVersion);
+                Assert.Equal("ABC", instances[0].SubToolsetVersion);
+                Assert.Equal("ABC", instances[0].GetPropertyValue("VisualStudioVersion"));
+            }
         }
 
         /// <summary>
@@ -1268,37 +1313,41 @@ public void Regress751742_SkipNonexistentProjects(bool useNewParser)
                 EndGlobal
                 """;
 
-            // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            var instance = SolutionProjectGenerator.Generate(solution, null, ObjectModelHelpers.MSBuildDefaultToolsVersion, _buildEventContext, CreateMockLoggingService())[0];
+                var instance = SolutionProjectGenerator.Generate(solution, null, ObjectModelHelpers.MSBuildDefaultToolsVersion, _buildEventContext, CreateMockLoggingService())[0];
 
-            foreach (ITaskItem item in instance.Items)
-            {
-                string skipNonexistentProjects = item.GetMetadata("SkipNonexistentProjects");
-                if (item.ItemSpec.EndsWith("ClassLibrary1.csproj"))
+                foreach (ITaskItem item in instance.Items)
                 {
-                    Assert.Equal("False", skipNonexistentProjects);
-                }
-                else if (item.ItemSpec.EndsWith("MainApp.metaproj"))
-                {
-                    Assert.Equal("Build", skipNonexistentProjects);
-                }
-                else if (item.ItemSpec == "Debug|Mixed Platforms")
-                {
-                    Assert.Equal("Debug", item.GetMetadata("Configuration"));
-                    Assert.Equal("Mixed Platforms", item.GetMetadata("Platform"));
-                    Assert.Contains("<SolutionConfiguration>", item.GetMetadata("Content"));
-                }
-                else if (item.ItemSpec == "Release|Any CPU")
-                {
-                    Assert.Equal("Release", item.GetMetadata("Configuration"));
-                    Assert.Equal("Any CPU", item.GetMetadata("Platform"));
-                    Assert.Contains("<SolutionConfiguration>", item.GetMetadata("Content"));
-                }
-                else
-                {
-                    Assert.Fail("Unexpected project seen:" + item.ItemSpec);
+                    string skipNonexistentProjects = item.GetMetadata("SkipNonexistentProjects");
+                    if (item.ItemSpec.EndsWith("ClassLibrary1.csproj"))
+                    {
+                        Assert.Equal("False", skipNonexistentProjects);
+                    }
+                    else if (item.ItemSpec.EndsWith("MainApp.metaproj"))
+                    {
+                        Assert.Equal("Build", skipNonexistentProjects);
+                    }
+                    else if (item.ItemSpec == "Debug|Mixed Platforms")
+                    {
+                        Assert.Equal("Debug", item.GetMetadata("Configuration"));
+                        Assert.Equal("Mixed Platforms", item.GetMetadata("Platform"));
+                        Assert.Contains("<SolutionConfiguration>", item.GetMetadata("Content"));
+                    }
+                    else if (item.ItemSpec == "Release|Any CPU")
+                    {
+                        Assert.Equal("Release", item.GetMetadata("Configuration"));
+                        Assert.Equal("Any CPU", item.GetMetadata("Platform"));
+                        Assert.Contains("<SolutionConfiguration>", item.GetMetadata("Content"));
+                    }
+                    else
+                    {
+                        Assert.Fail("Unexpected project seen:" + item.ItemSpec);
+                    }
                 }
             }
         }
@@ -1336,39 +1385,43 @@ public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations(bool u
                 EndGlobal
                 """;
 
-            // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, ObjectModelHelpers.MSBuildDefaultToolsVersion, _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, ObjectModelHelpers.MSBuildDefaultToolsVersion, _buildEventContext, CreateMockLoggingService());
 
-            int i = 0;
-            foreach (ProjectInstance instance in instances)
-            {
-                if (i == 0)
+                int i = 0;
+                foreach (ProjectInstance instance in instances)
                 {
-                    continue;
-                }
+                    if (i == 0)
+                    {
+                        continue;
+                    }
 
-                foreach (ProjectTargetInstance target in instance.Targets.Values)
-                {
-                    foreach (ProjectTaskInstance childNode in target.Tasks)
+                    foreach (ProjectTargetInstance target in instance.Targets.Values)
                     {
-                        if (String.Equals(childNode.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                        foreach (ProjectTaskInstance childNode in target.Tasks)
                         {
-                            string projectsParameter = childNode.GetParameter("Projects");
-                            if (projectsParameter != "@(ProjectReference)")
+                            if (String.Equals(childNode.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
                             {
-                                // we found an MSBuild task invocation, now let's verify that it has the correct
-                                // ToolsVersion parameter set
-                                string toolsVersionParameter = childNode.GetParameter("ToolsVersion");
-
-                                Assert.Equal(toolsVersionParameter, instances[0].GetPropertyValue("ProjectToolsVersion"));
+                                string projectsParameter = childNode.GetParameter("Projects");
+                                if (projectsParameter != "@(ProjectReference)")
+                                {
+                                    // we found an MSBuild task invocation, now let's verify that it has the correct
+                                    // ToolsVersion parameter set
+                                    string toolsVersionParameter = childNode.GetParameter("ToolsVersion");
+
+                                    Assert.Equal(toolsVersionParameter, instances[0].GetPropertyValue("ProjectToolsVersion"));
+                                }
                             }
                         }
                     }
-                }
 
-                i++;
+                    i++;
+                }
             }
         }
 
@@ -1412,34 +1465,38 @@ public void SolutionWithDependenciesHasCorrectToolsVersionInMetaprojs(bool useNe
                 EndGlobal
                 """;
 
-            // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            string[] solutionToolsVersions = { "4.0", ObjectModelHelpers.MSBuildDefaultToolsVersion };
+                string[] solutionToolsVersions = { "4.0", ObjectModelHelpers.MSBuildDefaultToolsVersion };
 
-            foreach (string solutionToolsVersion in solutionToolsVersions)
-            {
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, solutionToolsVersion, _buildEventContext, CreateMockLoggingService());
+                foreach (string solutionToolsVersion in solutionToolsVersions)
+                {
+                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, solutionToolsVersion, _buildEventContext, CreateMockLoggingService());
 
-                Assert.Equal(2, instances.Length);
+                    Assert.Equal(2, instances.Length);
 
-                // Solution metaproj
-                Assert.Equal(solutionToolsVersion, instances[0].ToolsVersion);
+                    // Solution metaproj
+                    Assert.Equal(solutionToolsVersion, instances[0].ToolsVersion);
 
-                ICollection<ProjectItemInstance> projectReferences = instances[0].GetItems("ProjectReference");
+                    ICollection<ProjectItemInstance> projectReferences = instances[0].GetItems("ProjectReference");
 
-                foreach (ProjectItemInstance projectReference in projectReferences)
-                {
-                    // If this is the reference to the metaproj, its ToolsVersion metadata needs to match
-                    // the solution ToolsVersion -- that's how the build knows which ToolsVersion to use.
-                    if (projectReference.EvaluatedInclude.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase))
+                    foreach (ProjectItemInstance projectReference in projectReferences)
                     {
-                        Assert.Equal(solutionToolsVersion, projectReference.GetMetadataValue("ToolsVersion"));
+                        // If this is the reference to the metaproj, its ToolsVersion metadata needs to match
+                        // the solution ToolsVersion -- that's how the build knows which ToolsVersion to use.
+                        if (projectReference.EvaluatedInclude.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase))
+                        {
+                            Assert.Equal(solutionToolsVersion, projectReference.GetMetadataValue("ToolsVersion"));
+                        }
                     }
-                }
 
-                // Project metaproj for project with dependencies
-                Assert.Equal(solutionToolsVersion, instances[1].ToolsVersion);
+                    // Project metaproj for project with dependencies
+                    Assert.Equal(solutionToolsVersion, instances[1].ToolsVersion);
+                }
             }
         }
 #endif
@@ -1474,6 +1531,8 @@ public void ToolsVersionOverrideCausesToolsetRedirect(bool useNewParser)
                     EndGlobalSection
                 EndGlobal
                 """;
+
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
             SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
             bool caughtException = false;
 
@@ -1522,53 +1581,57 @@ public void TestDisambiguateProjectTargetName(bool useNewParser)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
-
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
-
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)));
-
-            ProjectTargetInstance buildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)).First().Value;
-            ProjectTargetInstance cleanTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)).First().Value;
-            ProjectTargetInstance rebuildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)).First().Value;
-            ProjectTargetInstance publishTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)).First().Value;
-
-            // Check that the appropriate target is being passed to the child projects
-            Assert.Null(buildTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Targets"));
-
-            Assert.Equal("Clean", cleanTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Targets"));
-
-            Assert.Equal("Rebuild", rebuildTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Targets"));
-
-            Assert.Equal("Publish", publishTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Targets"));
-
-            // Check that the child projects in question are the members of the "ProjectReference" item group
-            Assert.Equal("@(ProjectReference)", buildTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Projects"));
-
-            Assert.Equal("@(ProjectReference->Reverse())", cleanTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Projects"));
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            Assert.Equal("@(ProjectReference)", rebuildTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Projects"));
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
 
-            Assert.Equal("@(ProjectReference)", publishTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Projects"));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)));
+
+                ProjectTargetInstance buildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)).First().Value;
+                ProjectTargetInstance cleanTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)).First().Value;
+                ProjectTargetInstance rebuildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)).First().Value;
+                ProjectTargetInstance publishTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)).First().Value;
+
+                // Check that the appropriate target is being passed to the child projects
+                Assert.Null(buildTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Targets"));
+
+                Assert.Equal("Clean", cleanTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Targets"));
+
+                Assert.Equal("Rebuild", rebuildTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Targets"));
+
+                Assert.Equal("Publish", publishTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Targets"));
+
+                // Check that the child projects in question are the members of the "ProjectReference" item group
+                Assert.Equal("@(ProjectReference)", buildTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Projects"));
+
+                Assert.Equal("@(ProjectReference->Reverse())", cleanTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Projects"));
+
+                Assert.Equal("@(ProjectReference)", rebuildTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Projects"));
+
+                Assert.Equal("@(ProjectReference)", publishTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Projects"));
+            }
 
             // We should have only the four standard targets plus the two validation targets (ValidateSolutionConfiguration and ValidateToolsVersions).
         }
@@ -1892,18 +1955,22 @@ public void SolutionGeneratorEscapingProjectFilePaths(bool useNewParser)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            // Creating a ProjectRootElement shouldn't affect the ProjectCollection at all
-            Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
+                // Creating a ProjectRootElement shouldn't affect the ProjectCollection at all
+                Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
 
-            Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
+                Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
 
-            // Ensure that the value has been correctly stored in the ProjectReference item list
-            // Since there is only one project in the solution, there will be only one project reference
-            Assert.Contains("%abtest", instances[0].GetItems("ProjectReference").ElementAt(0).EvaluatedInclude);
+                // Ensure that the value has been correctly stored in the ProjectReference item list
+                // Since there is only one project in the solution, there will be only one project reference
+                Assert.Contains("%abtest", instances[0].GetItems("ProjectReference").ElementAt(0).EvaluatedInclude);
+            }
         }
 
         /// <summary>
@@ -1949,12 +2016,16 @@ public void SolutionGeneratorCanEmitSolutions(bool useNewParser)
             {
                 Environment.SetEnvironmentVariable("MSBuildEmitSolution", "1");
 
-                solution = ParseSolutionHelper(solutionFileContents, useNewParser);
+                // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+                using (TestEnvironment testEnvironment = TestEnvironment.Create())
+                {
+                    solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-                // Creating a ProjectRootElement shouldn't affect the ProjectCollection at all
-                Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
+                    // Creating a ProjectRootElement shouldn't affect the ProjectCollection at all
+                    Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
 
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
+                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
+                }
 
                 // Instantiating the
                 Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
@@ -2034,12 +2105,16 @@ public void TestSkipInvalidConfigurationsCase(bool useNewParser)
                 globalProperties["Configuration"] = "Nonexistent";
                 globalProperties["SkipInvalidConfigurations"] = "true";
 
-                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService());
-                ProjectInstance msbuildProject = instances[0];
+                // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+                using (TestEnvironment testEnvironment = TestEnvironment.Create())
+                {
+                    SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
+                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService());
+                    ProjectInstance msbuildProject = instances[0];
 
-                // Build should complete successfully even with an invalid solution config if SkipInvalidConfigurations is true
-                Assert.True(msbuildProject.Build(new ILogger[] { logger }));
+                    // Build should complete successfully even with an invalid solution config if SkipInvalidConfigurations is true
+                    Assert.True(msbuildProject.Build(new ILogger[] { logger }));
+                }
 
                 // We should get the invalid solution configuration warning
                 Assert.Single(logger.Warnings);
@@ -2293,20 +2368,22 @@ public void TestTargetFrameworkVersionGreaterThan4(bool useNewParser)
                 globalProperties["Configuration"] = "Release";
                 globalProperties["SkipInvalidConfigurations"] = "true";
 
+                // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+                using (TestEnvironment testEnvironment = TestEnvironment.Create())
+                {
+                    SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
-
-                using ProjectCollection collection = new ProjectCollection();
-                collection.RegisterLogger(logger);
+                    using ProjectCollection collection = new ProjectCollection();
+                    collection.RegisterLogger(logger);
 
 #pragma warning disable format
 #if !FEATURE_ASPNET_COMPILER
-                Assert.Throws<InvalidProjectFileException>(() =>
-                {
+                    Assert.Throws<InvalidProjectFileException>(() =>
+                    {
 #endif
-                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, collection.LoggingService);
+                        ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, collection.LoggingService);
 #if !FEATURE_ASPNET_COMPILER
-                });
+                    });
 #endif
 #pragma warning restore format
 
@@ -2315,6 +2392,7 @@ public void TestTargetFrameworkVersionGreaterThan4(bool useNewParser)
                 string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("AspNetCompiler.TargetingHigherFrameworksDefaultsTo40", solution.ProjectsInOrder[0].ProjectName, ver.ToString());
                 logger.AssertLogContains(message);
 #endif
+                }
             }
             finally
             {
@@ -2348,30 +2426,34 @@ public void CustomTargetNamesAreInInMetaproj(bool useNewParser)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
-
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "One" });
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "One", StringComparison.OrdinalIgnoreCase)));
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "One" });
 
-            instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Two", "Three", "Four" });
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "One", StringComparison.OrdinalIgnoreCase)));
 
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Two", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Three", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Four", StringComparison.OrdinalIgnoreCase)));
+                instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Two", "Three", "Four" });
 
-            instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Build" });
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Two", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Three", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Four", StringComparison.OrdinalIgnoreCase)));
 
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
+                instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Build" });
 
-            instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Five", "Rebuild" });
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
 
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Five", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
+                instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Five", "Rebuild" });
 
-            instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "My_Project:Six" });
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Five", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
 
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Six", StringComparison.OrdinalIgnoreCase)));
+                instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "My_Project:Six" });
+        
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Six", StringComparison.OrdinalIgnoreCase)));
+            }
         }
 
         /// <summary>
@@ -2403,21 +2485,25 @@ public void DisambiguatedTargetNamesAreInMetaproj(bool useNewParser)
                     EndGlobal
                     """;
 
-                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
+                // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+                using (TestEnvironment testEnvironment = TestEnvironment.Create())
+                {
+                    SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), null);
+                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), null);
 
-                foreach (string targetName in ProjectInSolution.projectNamesToDisambiguate)
-                {
-                    // The entry point still exists normally.
-                    Assert.True(instances[0].Targets.ContainsKey(targetName));
-
-                    // The traversal target should be disambiguated with a "Solution:" prefix.
-                    // Note: The default targets are used instead of "Build".
-                    string traversalTargetName = targetName.Equals("Build", StringComparison.OrdinalIgnoreCase)
-                        ? $"Solution:{projectName}"
-                        : $"Solution:{projectName}:{targetName}";
-                    Assert.True(instances[0].Targets.ContainsKey(traversalTargetName));
+                    foreach (string targetName in ProjectInSolution.projectNamesToDisambiguate)
+                    {
+                        // The entry point still exists normally.
+                        Assert.True(instances[0].Targets.ContainsKey(targetName));
+
+                        // The traversal target should be disambiguated with a "Solution:" prefix.
+                        // Note: The default targets are used instead of "Build".
+                        string traversalTargetName = targetName.Equals("Build", StringComparison.OrdinalIgnoreCase)
+                            ? $"Solution:{projectName}"
+                            : $"Solution:{projectName}:{targetName}";
+                        Assert.True(instances[0].Targets.ContainsKey(traversalTargetName));
+                    }
                 }
             }
         }
@@ -2452,51 +2538,55 @@ public void IllegalUserTargetNamesDoNotThrow(bool forceCaseDifference, bool useN
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
-
-            ProjectInstance[] instances;
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            // Avoid any unexpected targets getting pulled in
-            var globalProperties = new Dictionary<string, string> { { "ImportByWildcardBeforeSolution", "false" } };
+                ProjectInstance[] instances;
 
-            foreach (string builtInTargetName in new[]
-            {
-                null,
-                "Build",
-                "Rebuild",
-                "Clean",
-                "Publish",
-                "ClassLibrary1",
-                "ClassLibrary1:Clean",
-                "ClassLibrary1:Rebuild",
-                "GetSolutionConfigurationContents",
-                "ValidateProjects",
-            })
-            {
-                string[] targetNames;
+                // Avoid any unexpected targets getting pulled in
+                var globalProperties = new Dictionary<string, string> { { "ImportByWildcardBeforeSolution", "false" } };
 
-                if (builtInTargetName == null)
+                foreach (string builtInTargetName in new[]
                 {
-                    targetNames = null;
-                }
-                else
+                    null,
+                    "Build",
+                    "Rebuild",
+                    "Clean",
+                    "Publish",
+                    "ClassLibrary1",
+                    "ClassLibrary1:Clean",
+                    "ClassLibrary1:Rebuild",
+                    "GetSolutionConfigurationContents",
+                    "ValidateProjects",
+                })
                 {
-                    string targetName = forceCaseDifference ? builtInTargetName.ToUpperInvariant() : builtInTargetName;
-                    targetNames = new[] { targetName };
-                }
+                    string[] targetNames;
 
-                instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService(), targetNames);
+                    if (builtInTargetName == null)
+                    {
+                        targetNames = null;
+                    }
+                    else
+                    {
+                        string targetName = forceCaseDifference ? builtInTargetName.ToUpperInvariant() : builtInTargetName;
+                        targetNames = new[] { targetName };
+                    }
 
-                Assert.Single(instances);
+                    instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService(), targetNames);
 
-                Assert.Equal(12, instances[0].TargetsCount);
-            }
+                    Assert.Single(instances);
+
+                    Assert.Equal(12, instances[0].TargetsCount);
+                }
 
-            instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService(), new[] { "Foo" });
+                instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService(), new[] { "Foo" });
 
-            Assert.Single(instances);
+                Assert.Single(instances);
 
-            Assert.Equal(14, instances[0].TargetsCount);
+                Assert.Equal(14, instances[0].TargetsCount);
+            }
         }
 
         /// <summary>
@@ -2826,12 +2916,16 @@ private ProjectInstance CreateVenusSolutionProject(IDictionary<string, string> g
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, toolsVersion, BuildEventContext.Invalid, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, toolsVersion, BuildEventContext.Invalid, CreateMockLoggingService());
 
-            // Index 0 is the traversal project, which will reference the sole Venus project.
-            return instances[1];
+                // Index 0 is the traversal project, which will reference the sole Venus project.
+                return instances[1];
+            }
         }
 
         private ILoggingService CreateMockLoggingService()
@@ -2873,10 +2967,23 @@ private void AssertProjectItemNameCount(ProjectInstance msbuildProject, string i
             Assert.Equal(count, itemGroup.Count());
         }
 
-        private SolutionFile ParseSolutionHelper(string solutionFileContents, bool useNewParser)
+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool isOptInSlnParsingWithNewParser)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                return ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, testEnvironment);
+            }
+        }
+
+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool isOptInSlnParsingWithNewParser, TestEnvironment testEnvironment)
         {
-            return useNewParser ? SolutionFile_NewParser_Tests.ParseSolutionHelper(solutionFileContents) :
-                SolutionFile_OldParser_Tests.ParseSolutionHelper(solutionFileContents);
+            solutionFileContents = solutionFileContents.Replace('\'', '"');
+            if (isOptInSlnParsingWithNewParser)
+            {
+                testEnvironment.SetEnvironmentVariable("MSBUILD_PARSE_SLN_WITH_SOLUTIONPERSISTENCE", "1");
+            }
+            TransientTestFile sln = testEnvironment.CreateFile(FileUtilities.GetTemporaryFileName(".sln"), solutionFileContents);
+            return SolutionFile.Parse(sln.Path);
         }
 
         #endregion // Helper Functions
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 4f9b2b14f92..a456097ddbc 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -96,6 +96,41 @@ public void VerifyLoadingImportScenarios(string importParameter, bool shouldSucc
             }
         }
 
+        [Theory]
+        [InlineData("(test")]
+        [InlineData("@@@test")]
+        [InlineData(@")(!!test")]
+        public void VerifyItemsUpdateIsHandledForAnyProjectPath(string projectPathCandidate)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFolder projDirectory = env.CreateFolder(Path.Combine(env.CreateNewTempPath().TempPath, projectPathCandidate), createFolder: true);
+                TransientTestFile projectFile = env.CreateFile(projDirectory, "project.proj", @"
+<Project>
+
+  <ItemGroup>
+    <ItemCheck Include=""Test"" />
+  </ItemGroup>
+
+  <ItemGroup>
+     <ItemCheck Update=""Test""
+             NewTestLabels=""Dummy"" />
+  </ItemGroup>
+
+ <Target Name=""MyTarget"">
+    <Message Text=""ItemCheck updated metadata value: @(ItemCheck->Metadata('NewTestLabels'))"" />
+  </Target>
+</Project>
+");
+                Project project = new(projectFile.Path);
+                MockLogger logger = new();
+                var result = project.Build(logger);
+
+                result.ShouldBeTrue();
+                project.AllEvaluatedItems.Where(ei => ei.ItemType == "ItemCheck" && ei.Metadata.Any(m => m.EvaluatedValue == "Dummy")).ShouldNotBeEmpty();
+            }
+        }
+
         // Some of these are also tested elsewhere, but this consolidates related tests in one spot.
         public static IEnumerable<object[]> ImportLoadingScenarioTestData
         {
@@ -4708,7 +4743,7 @@ public void VerifyPropertyTrackingLoggingDefault()
             // Having just environment variables defined should default to nothing being logged except one environment variable read.
             VerifyPropertyTrackingLoggingScenario(
                 null,
-                logger =>
+                 (logger, _) =>
                 {
                     logger
                         .AllBuildEvents
@@ -4740,7 +4775,7 @@ public void VerifyPropertyTrackingLoggingPropertyReassignment()
         {
             VerifyPropertyTrackingLoggingScenario(
                 "1",
-                logger =>
+                (logger, _) =>
                 {
                     logger
                         .AllBuildEvents
@@ -4771,7 +4806,7 @@ public void VerifyPropertyTrackingLoggingNone()
         {
             this.VerifyPropertyTrackingLoggingScenario(
                 "0",
-                logger =>
+                 (logger, _) =>
                 {
                     logger
                         .AllBuildEvents
@@ -4803,7 +4838,7 @@ public void VerifyPropertyTrackingLoggingPropertyInitialValue()
         {
             this.VerifyPropertyTrackingLoggingScenario(
                 "2",
-                logger =>
+                (logger, projectPath) =>
                 {
                     logger
                         .AllBuildEvents
@@ -4829,11 +4864,11 @@ public void VerifyPropertyTrackingLoggingPropertyInitialValue()
 
                     // Verify logging of property initial values.
                     propertyInitialValueMap.ShouldContainKey("Prop");
-                    propertyInitialValueMap["Prop"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["Prop"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["Prop"].PropertyValue.ShouldBe(string.Empty);
 
                     propertyInitialValueMap.ShouldContainKey("EnvVar");
-                    propertyInitialValueMap["EnvVar"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["EnvVar"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["EnvVar"].PropertyValue.ShouldBe("It's also Defined!");
 
                     propertyInitialValueMap.ShouldContainKey("DEFINED_ENVIRONMENT_VARIABLE");
@@ -4841,11 +4876,11 @@ public void VerifyPropertyTrackingLoggingPropertyInitialValue()
                     propertyInitialValueMap["DEFINED_ENVIRONMENT_VARIABLE"].PropertyValue.ShouldBe("It's Defined!");
 
                     propertyInitialValueMap.ShouldContainKey("NotEnvVarRead");
-                    propertyInitialValueMap["NotEnvVarRead"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["NotEnvVarRead"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["NotEnvVarRead"].PropertyValue.ShouldBe("Overwritten!");
 
                     propertyInitialValueMap.ShouldContainKey("Prop2");
-                    propertyInitialValueMap["Prop2"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["Prop2"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["Prop2"].PropertyValue.ShouldBe("Value1");
                 });
         }
@@ -4855,7 +4890,7 @@ public void VerifyPropertyTrackingLoggingEnvironmentVariableRead()
         {
             this.VerifyPropertyTrackingLoggingScenario(
                 "4",
-                logger =>
+                (logger, _) =>
                 {
                     logger
                         .AllBuildEvents
@@ -4889,7 +4924,7 @@ public void VerifyPropertyTrackingLoggingUninitializedPropertyRead()
         {
             this.VerifyPropertyTrackingLoggingScenario(
                 "8",
-                logger =>
+                (logger, _) =>
                 {
                     logger
                         .AllBuildEvents
@@ -4920,7 +4955,7 @@ public void VerifyPropertyTrackingLoggingAll()
         {
             this.VerifyPropertyTrackingLoggingScenario(
                 "15",
-                logger =>
+                (logger, projectPath) =>
                 {
                     logger
                         .AllBuildEvents
@@ -4949,11 +4984,11 @@ public void VerifyPropertyTrackingLoggingAll()
 
                     // Verify logging of property initial values.
                     propertyInitialValueMap.ShouldContainKey("Prop");
-                    propertyInitialValueMap["Prop"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["Prop"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["Prop"].PropertyValue.ShouldBe(string.Empty);
 
                     propertyInitialValueMap.ShouldContainKey("EnvVar");
-                    propertyInitialValueMap["EnvVar"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["EnvVar"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["EnvVar"].PropertyValue.ShouldBe("It's also Defined!");
 
                     propertyInitialValueMap.ShouldContainKey("DEFINED_ENVIRONMENT_VARIABLE");
@@ -4961,11 +4996,11 @@ public void VerifyPropertyTrackingLoggingAll()
                     propertyInitialValueMap["DEFINED_ENVIRONMENT_VARIABLE"].PropertyValue.ShouldBe("It's Defined!");
 
                     propertyInitialValueMap.ShouldContainKey("NotEnvVarRead");
-                    propertyInitialValueMap["NotEnvVarRead"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["NotEnvVarRead"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["NotEnvVarRead"].PropertyValue.ShouldBe("Overwritten!");
 
                     propertyInitialValueMap.ShouldContainKey("Prop2");
-                    propertyInitialValueMap["Prop2"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["Prop2"].File.ShouldBe(projectPath);
                     propertyInitialValueMap["Prop2"].PropertyValue.ShouldBe("Value1");
                 });
         }
@@ -4987,7 +5022,7 @@ public void VerifyGetTypeEvaluationBlocked()
                 new Project(XmlReader.Create(new StringReader(projectContents)), null, "Fake", fakeProjectCollection));
         }
 
-        private void VerifyPropertyTrackingLoggingScenario(string envVarValue, Action<MockLogger> loggerEvaluatorAction)
+        private void VerifyPropertyTrackingLoggingScenario(string envVarValue, Action<MockLogger, string> loggerEvaluatorAction)
         {
             // The default is that only reassignments are logged.
 
@@ -5026,7 +5061,7 @@ private void VerifyPropertyTrackingLoggingScenario(string envVarValue, Action<Mo
 
                 project.Build().ShouldBeTrue();
 
-                loggerEvaluatorAction?.Invoke(logger);
+                loggerEvaluatorAction?.Invoke(logger, tempPath.Path);
             }
         }
 
diff --git a/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs b/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
index 829eae89400..5cc7e4309cc 100644
--- a/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Globalization;
@@ -11,6 +11,7 @@
 
 using Xunit;
 using Xunit.Abstractions;
+using ParseArgs = Microsoft.Build.Evaluation.Expander.ArgumentParser;
 
 namespace Microsoft.Build.Engine.UnitTests.Evaluation
 {
@@ -25,7 +26,7 @@ public class ExpanderFunction_Tests
         [Fact]
         public void TryConvertToIntGivenNull()
         {
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(null, out int actual).ShouldBeFalse();
+            ParseArgs.TryConvertToInt(null, out int actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -33,7 +34,7 @@ public void TryConvertToIntGivenNull()
         public void TryConvertToIntGivenDouble()
         {
             const double value = 10.0;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -41,7 +42,7 @@ public void TryConvertToIntGivenDouble()
         public void TryConvertToIntGivenLong()
         {
             const long value = 10;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -49,7 +50,7 @@ public void TryConvertToIntGivenLong()
         public void TryConvertToIntGivenInt()
         {
             const int value = 10;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -57,7 +58,7 @@ public void TryConvertToIntGivenInt()
         public void TryConvertToIntGivenString()
         {
             const string value = "10";
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -66,7 +67,7 @@ public void TryConvertToIntGivenDoubleWithIntMinValue()
         {
             const int expected = int.MinValue;
             const double value = expected;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeTrue();
             actual.ShouldBe(expected);
         }
 
@@ -75,7 +76,7 @@ public void TryConvertToIntGivenDoubleWithIntMaxValue()
         {
             const int expected = int.MaxValue;
             const double value = expected;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeTrue();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeTrue();
             actual.ShouldBe(expected);
         }
 
@@ -83,7 +84,7 @@ public void TryConvertToIntGivenDoubleWithIntMaxValue()
         public void TryConvertToIntGivenDoubleWithLessThanIntMinValue()
         {
             const double value = int.MinValue - 1.0;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeFalse();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -91,7 +92,7 @@ public void TryConvertToIntGivenDoubleWithLessThanIntMinValue()
         public void TryConvertToIntGivenDoubleWithGreaterThanIntMaxValue()
         {
             const double value = int.MaxValue + 1.0;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeFalse();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -99,7 +100,7 @@ public void TryConvertToIntGivenDoubleWithGreaterThanIntMaxValue()
         public void TryConvertToIntGivenLongWithGreaterThanIntMaxValue()
         {
             const long value = int.MaxValue + 1L;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToInt(value, out int actual).ShouldBeFalse();
+            ParseArgs.TryConvertToInt(value, out int actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -108,7 +109,7 @@ public void TryConvertToIntGivenLongWithGreaterThanIntMaxValue()
         [Fact]
         public void TryConvertToLongGivenNull()
         {
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(null, out long actual).ShouldBeFalse();
+            ParseArgs.TryConvertToLong(null, out long actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -116,7 +117,7 @@ public void TryConvertToLongGivenNull()
         public void TryConvertToLongGivenDouble()
         {
             const double value = 10.0;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -124,7 +125,7 @@ public void TryConvertToLongGivenDouble()
         public void TryConvertToLongGivenLong()
         {
             const long value = 10;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -132,7 +133,7 @@ public void TryConvertToLongGivenLong()
         public void TryConvertToLongGivenInt()
         {
             const int value = 10;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -140,7 +141,7 @@ public void TryConvertToLongGivenInt()
         public void TryConvertToLongGivenString()
         {
             const string value = "10";
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeTrue();
             actual.ShouldBe(10);
         }
 
@@ -149,7 +150,7 @@ public void TryConvertToLongGivenDoubleWithLongMinValue()
         {
             const long expected = long.MinValue;
             const double value = expected;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeTrue();
             actual.ShouldBe(expected);
         }
 
@@ -159,14 +160,14 @@ public void TryConvertToLongGivenDoubleWithLongMaxValueShouldNotThrow()
             // An OverflowException should not be thrown from TryConvertToLong().
             // Convert.ToInt64(double) has a defect and will throw an OverflowException
             // for values >= (long.MaxValue - 511) and <= long.MaxValue.
-            _ = Should.NotThrow(() => Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong((double)long.MaxValue, out _));
+            _ = Should.NotThrow(() => ParseArgs.TryConvertToLong((double)long.MaxValue, out _));
         }
 
         [WindowsFullFrameworkOnlyFact]
         public void TryConvertToLongGivenDoubleWithLongMaxValueFramework()
         {
             const long longMaxValue = long.MaxValue;
-            bool result = Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong((double)longMaxValue, out long actual);
+            bool result = ParseArgs.TryConvertToLong((double)longMaxValue, out long actual);
 
             // Because of loss of precision, long.MaxValue will not 'round trip' from long to double to long.
             result.ShouldBeFalse();
@@ -177,7 +178,7 @@ public void TryConvertToLongGivenDoubleWithLongMaxValueFramework()
         public void TryConvertToLongGivenDoubleWithLongMaxValueDotNet()
         {
             const long longMaxValue = long.MaxValue;
-            bool result = Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong((double)longMaxValue, out long actual);
+            bool result = ParseArgs.TryConvertToLong((double)longMaxValue, out long actual);
 
             // Testing on macOS 12 on Apple Silicon M1 Pro produces different result.
             result.ShouldBeTrue();
@@ -192,7 +193,7 @@ public void TryConvertToLongGivenDoubleWithVeryLargeLongValue()
             const long veryLargeLong = long.MaxValue - 512;
             const double value = veryLargeLong;
             const long expected = 9223372036854774784L;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeTrue();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeTrue();
             actual.ShouldBe(expected);
         }
 
@@ -200,7 +201,7 @@ public void TryConvertToLongGivenDoubleWithVeryLargeLongValue()
         public void TryConvertToLongGivenDoubleWithLessThanLongMinValue()
         {
             const double value = -92233720368547758081D;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeFalse();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -208,7 +209,7 @@ public void TryConvertToLongGivenDoubleWithLessThanLongMinValue()
         public void TryConvertToLongGivenDoubleWithGreaterThanLongMaxValue()
         {
             const double value = (double)long.MaxValue + long.MaxValue;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToLong(value, out long actual).ShouldBeFalse();
+            ParseArgs.TryConvertToLong(value, out long actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -217,7 +218,7 @@ public void TryConvertToLongGivenDoubleWithGreaterThanLongMaxValue()
         [Fact]
         public void TryConvertToDoubleGivenNull()
         {
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(null, out double actual).ShouldBeFalse();
+            ParseArgs.TryConvertToDouble(null, out double actual).ShouldBeFalse();
             actual.ShouldBe(0);
         }
 
@@ -225,7 +226,7 @@ public void TryConvertToDoubleGivenNull()
         public void TryConvertToDoubleGivenDouble()
         {
             const double value = 10.0;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(value, out double actual).ShouldBeTrue();
+            ParseArgs.TryConvertToDouble(value, out double actual).ShouldBeTrue();
             actual.ShouldBe(10.0);
         }
 
@@ -233,7 +234,7 @@ public void TryConvertToDoubleGivenDouble()
         public void TryConvertToDoubleGivenLong()
         {
             const long value = 10;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(value, out double actual).ShouldBeTrue();
+            ParseArgs.TryConvertToDouble(value, out double actual).ShouldBeTrue();
             actual.ShouldBe(10.0);
         }
 
@@ -241,7 +242,7 @@ public void TryConvertToDoubleGivenLong()
         public void TryConvertToDoubleGivenInt()
         {
             const int value = 10;
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(value, out double actual).ShouldBeTrue();
+            ParseArgs.TryConvertToDouble(value, out double actual).ShouldBeTrue();
             actual.ShouldBe(10.0);
         }
 
@@ -249,7 +250,7 @@ public void TryConvertToDoubleGivenInt()
         public void TryConvertToDoubleGivenString()
         {
             const string value = "10";
-            Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(value, out double actual).ShouldBeTrue();
+            ParseArgs.TryConvertToDouble(value, out double actual).ShouldBeTrue();
             actual.ShouldBe(10.0);
         }
 
@@ -267,7 +268,7 @@ public void TryConvertToDoubleGivenStringAndLocale()
                 // The invariant culture should be used and "1,2" should be 12.0 not 1.2.
                 var cultureEnglishSouthAfrica = CultureInfo.CreateSpecificCulture("en-ZA");
                 currentThread.CurrentCulture = cultureEnglishSouthAfrica;
-                Expander<IProperty, IItem>.Function<IProperty>.TryConvertToDouble(value, out double actual).ShouldBeTrue();
+                ParseArgs.TryConvertToDouble(value, out double actual).ShouldBeTrue();
                 actual.ShouldBe(12.0);
             }
             finally
diff --git a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
index da04dae2a84..b6b49388ec7 100644
--- a/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Preprocessor_Tests.cs
@@ -933,6 +933,7 @@ This import was added implicitly because the Project element's Sdk attribute spe
         }
 
         [Fact]
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/11498")]
         public void SdkResolverItemsAndPropertiesAreInPreprocessedOutput()
         {
             using (TestEnvironment env = TestEnvironment.Create())
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index a5f9ba12a47..e1c81f71814 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -16,16 +16,21 @@
 
   <ItemGroup>
     <Reference Include="System.IO.Compression" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+
     <PackageReference Include="FluentAssertions" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="FakeItEasy" />
-    <PackageReference Include="System.Net.Http" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
+    <PackageReference Include="Verify.Xunit" />
     <PackageReference Include="NuGet.Frameworks">
       <PrivateAssets>all</PrivateAssets>
     </PackageReference>
 
+    <PackageReference Include="Microsoft.VisualStudio.OpenTelemetry.ClientExtensions" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+    <PackageReference Include="Microsoft.VisualStudio.OpenTelemetry.Collector" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+    
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\MSBuild\MSBuild.csproj" />
@@ -34,7 +39,7 @@
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
     <ProjectReference Include="..\UnitTests.Shared\Microsoft.Build.UnitTests.Shared.csproj" />
-
+    
     <ProjectReference Include="..\Samples\TaskWithDependency\TaskWithDependency.csproj" Private="false" ReferenceOutputAssembly="false" OutputItemType="TaskWithDependencyResolvedProjectReferencePath">
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=$(LatestDotNetCoreForMSBuild)</SetTargetFramework>
@@ -45,7 +50,7 @@
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=$(LatestDotNetCoreForMSBuild)</SetTargetFramework>
     </ProjectReference>
-
+    
     <Reference Include="System.IO.Compression" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' " />
   </ItemGroup>
 
diff --git a/src/MSBuild.UnitTests/MockStopwatch.cs b/src/Build.UnitTests/MockStopwatch.cs
similarity index 93%
rename from src/MSBuild.UnitTests/MockStopwatch.cs
rename to src/Build.UnitTests/MockStopwatch.cs
index 8c65821140f..7be35cfe520 100644
--- a/src/MSBuild.UnitTests/MockStopwatch.cs
+++ b/src/Build.UnitTests/MockStopwatch.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Microsoft.Build.Logging.TerminalLogger;
+using Microsoft.Build.Logging;
 
 namespace Microsoft.Build.CommandLine.UnitTests;
 
diff --git a/src/MSBuild.UnitTests/NodeStatus_SizeChange_Tests.cs b/src/Build.UnitTests/NodeStatus_SizeChange_Tests.cs
similarity index 75%
rename from src/MSBuild.UnitTests/NodeStatus_SizeChange_Tests.cs
rename to src/Build.UnitTests/NodeStatus_SizeChange_Tests.cs
index cdb004687af..458eb4edb27 100644
--- a/src/MSBuild.UnitTests/NodeStatus_SizeChange_Tests.cs
+++ b/src/Build.UnitTests/NodeStatus_SizeChange_Tests.cs
@@ -8,7 +8,7 @@
 using System.Text;
 using System.Threading.Tasks;
 
-using Microsoft.Build.Logging.TerminalLogger;
+using Microsoft.Build.Logging;
 
 using VerifyTests;
 using VerifyXunit;
@@ -22,7 +22,7 @@ namespace Microsoft.Build.CommandLine.UnitTests;
 [UsesVerify]
 public class NodeStatus_SizeChange_Tests : IDisposable
 {
-    private readonly NodeStatus _status = new("Namespace.Project", "TargetFramework", "Target", new MockStopwatch());
+    private readonly TerminalNodeStatus _status = new("Namespace.Project", "TargetFramework", "Target", new MockStopwatch());
     private CultureInfo _currentCulture;
 
     public NodeStatus_SizeChange_Tests()
@@ -36,7 +36,7 @@ public NodeStatus_SizeChange_Tests()
     [Fact]
     public async Task EverythingFits()
     {
-        NodesFrame frame = new([_status], width: 80, height: 5);
+        TerminalNodesFrame frame = new([_status], width: 80, height: 5);
 
         await Verify(frame.RenderNodeStatus(0).ToString());
     }
@@ -44,7 +44,7 @@ public async Task EverythingFits()
     [Fact]
     public async Task TargetIsTruncatedFirst()
     {
-        NodesFrame frame = new([_status], width: 45, height: 5);
+        TerminalNodesFrame frame = new([_status], width: 45, height: 5);
 
         await Verify(frame.RenderNodeStatus(0).ToString());
     }
@@ -52,7 +52,7 @@ public async Task TargetIsTruncatedFirst()
     [Fact]
     public async Task NamespaceIsTruncatedNext()
     {
-        NodesFrame frame = new([_status], width: 40, height: 5);
+        TerminalNodesFrame frame = new([_status], width: 40, height: 5);
 
         await Verify(frame.RenderNodeStatus(0).ToString());
     }
@@ -60,7 +60,7 @@ public async Task NamespaceIsTruncatedNext()
     [Fact]
     public async Task GoesToProject()
     {
-        NodesFrame frame = new([_status], width: 10, height: 5);
+        TerminalNodesFrame frame = new([_status], width: 10, height: 5);
 
         await Verify(frame.RenderNodeStatus(0).ToString());
     }
diff --git a/src/MSBuild.UnitTests/NodeStatus_Transition_Tests.cs b/src/Build.UnitTests/NodeStatus_Transition_Tests.cs
similarity index 87%
rename from src/MSBuild.UnitTests/NodeStatus_Transition_Tests.cs
rename to src/Build.UnitTests/NodeStatus_Transition_Tests.cs
index 1d1dacae7f0..d811c2e4988 100644
--- a/src/MSBuild.UnitTests/NodeStatus_Transition_Tests.cs
+++ b/src/Build.UnitTests/NodeStatus_Transition_Tests.cs
@@ -8,8 +8,8 @@
 using System.Text;
 using System.Text.RegularExpressions;
 using System.Threading.Tasks;
-
-using Microsoft.Build.Logging.TerminalLogger;
+using Microsoft.Build.Framework.Logging;
+using Microsoft.Build.Logging;
 using Shouldly;
 using VerifyTests;
 using VerifyXunit;
@@ -33,7 +33,7 @@ public void NodeStatusTargetThrowsForInputWithAnsi()
     {
 #if DEBUG
         // This is testing a Debug.Assert, which won't throw in Release mode.
-        Func<NodeStatus> newNodeStatus = () => new NodeStatus("project", "tfm", AnsiCodes.Colorize("colorized target", TerminalColor.Green), new MockStopwatch());
+        Func<TerminalNodeStatus> newNodeStatus = () => new TerminalNodeStatus("project", "tfm", AnsiCodes.Colorize("colorized target", TerminalColor.Green), new MockStopwatch());
         newNodeStatus.ShouldThrow<ArgumentException>().Message.ShouldContain("Target should not contain any escape codes, if you want to colorize target use the other constructor.");
 #endif
     }
@@ -58,7 +58,7 @@ public async Task NodeTargetUpdatesTime()
         // This test look like there is no change between the frames, but we ask the stopwatch for time they will increase the number.
         // We need this because animations check that NodeStatus reference is the same.
         // And we cannot use MockStopwatch because we don't know when to call Tick on them, and if we do it right away, the time will update in "both" nodes.
-        NodeStatus node = new("Namespace.Project", "TargetFramework", "Build", new TickingStopwatch());
+        TerminalNodeStatus node = new("Namespace.Project", "TargetFramework", "Build", new TickingStopwatch());
         var rendered = Animate(
             [
                 node,
@@ -90,7 +90,7 @@ public async Task NodeWithColoredTargetUpdatesTime()
         // This test look like there is no change between the frames, but we ask the stopwatch for time they will increase the number.
         // We need this because animations check that NodeStatus reference is the same.
         // And we cannot use MockStopwatch because we don't know when to call Tick on them, and if we do it right away, the time will update in "both" nodes.
-        NodeStatus node = new("Namespace.Project", "TargetFramework", TerminalColor.Green, "passed", "MyTestName1", new TickingStopwatch());
+        TerminalNodeStatus node = new("Namespace.Project", "TargetFramework", TerminalColor.Green, "passed", "MyTestName1", new TickingStopwatch());
         var rendered = Animate(
             [
                 node,
@@ -107,16 +107,16 @@ public async Task NodeWithColoredTargetUpdatesTime()
     /// </summary>
     /// <param name="nodeStatusesUpdates">Takes array of arrays. The inner array is collection of nodes that are currently running. The outer array is how they update over time.</param>
     /// <returns></returns>
-    private string Animate(params NodeStatus[][] nodeStatusesUpdates)
+    private string Animate(params TerminalNodeStatus[][] nodeStatusesUpdates)
     {
         var width = 80;
         var height = 1;
 
-        NodesFrame previousFrame = new(Array.Empty<NodeStatus>(), 0, 0);
+        TerminalNodesFrame previousFrame = new(Array.Empty<TerminalNodeStatus>(), 0, 0);
         StringBuilder result = new StringBuilder();
         foreach (var nodeStatuses in nodeStatusesUpdates)
         {
-            NodesFrame currentFrame = new NodesFrame(nodeStatuses, width, height);
+            TerminalNodesFrame currentFrame = new TerminalNodesFrame(nodeStatuses, width, height);
             result.Append(currentFrame.Render(previousFrame));
             previousFrame = currentFrame;
         }
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 022ed16ed2c..449bdf1401d 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -10,6 +10,7 @@
 using System.Text.RegularExpressions;
 using System.Threading;
 using System.Threading.Tasks;
+using Microsoft.Build.CommandLine;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Experimental.ProjectCache;
@@ -18,10 +19,12 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Unittest;
 using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.Sdk;
 using Task = System.Threading.Tasks.Task;
 
 namespace Microsoft.Build.Engine.UnitTests.ProjectCache
@@ -1656,5 +1659,73 @@ private void SetEnvironmentForErrorLocations(ErrorLocations errorLocations, Erro
                 }
             }
         }
+
+        [DotNetOnlyFact("The netfx bootstrap layout created with 'dotnet build' is incomplete")]
+        /// <summary>
+        /// https://github.com/dotnet/msbuild/issues/5334
+        /// </summary>
+        public void EmbeddedResourcesFileCompileCache()
+        {
+            var directory = _env.CreateFolder();
+            string content = ObjectModelHelpers.CleanupFileContents(
+            """
+            <Project Sdk="Microsoft.NET.Sdk">
+                <PropertyGroup>
+                    <TargetFramework>net8.0</TargetFramework>
+                    <OutputType>Exe</OutputType>
+                    <OutputPath>bin/</OutputPath>
+                </PropertyGroup>
+                <ItemGroup>
+                    <EmbeddedResource Include="*.txt"/>
+                </ItemGroup>
+            </Project>
+            """);
+            var projectPath = directory.CreateFile("app.csproj", content).Path;
+            directory.CreateFile("Program.cs",
+            """
+            using System;
+            using System.IO;
+            using System.Reflection;
+
+            class Program
+            {
+                static void Main()
+                {
+                    var assembly = Assembly.GetExecutingAssembly();
+                    var resourceNames = assembly.GetManifestResourceNames();
+
+                    foreach (var resourceName in resourceNames)
+                    {
+                        using (var stream = assembly.GetManifestResourceStream(resourceName))
+                        using (var reader = new StreamReader(stream))
+                        {
+                            var content = reader.ReadToEnd();
+                            Console.WriteLine($"Content of {resourceName}:");
+                            Console.WriteLine(content);
+                        }
+                    }
+                }
+            }
+            """);
+
+            // Create EmbeddedResources file
+            var file1 = directory.CreateFile("File1.txt", "A=1");
+            var file2 = directory.CreateFile("File2.txt", "B=1");
+
+            // Build and run the project
+            string output = RunnerUtilities.ExecBootstrapedMSBuild($"{projectPath} -restore", out bool success);
+            success.ShouldBeTrue(output);
+            output = RunnerUtilities.RunProcessAndGetOutput(Path.Combine(directory.Path, "bin/net8.0/app"), "", out success, false, _output);
+            output.ShouldContain("A=1");
+            output.ShouldContain("B=1");
+
+            // Delete a file and build
+            FileUtilities.DeleteNoThrow(file1.Path);
+            output = RunnerUtilities.ExecBootstrapedMSBuild($"{projectPath}", out success);
+            success.ShouldBeTrue(output);
+            output = RunnerUtilities.RunProcessAndGetOutput(Path.Combine(directory.Path, "bin/net8.0/app"), "", out success, false, _output);
+            output.ShouldNotContain("A=1");
+            output.ShouldContain("B=1");
+        }
     }
 }
diff --git a/src/MSBuild.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.EverythingFits.verified.txt b/src/Build.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.EverythingFits.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.EverythingFits.verified.txt
rename to src/Build.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.EverythingFits.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.GoesToProject.verified.txt b/src/Build.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.GoesToProject.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.GoesToProject.verified.txt
rename to src/Build.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.GoesToProject.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.NamespaceIsTruncatedNext.verified.txt b/src/Build.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.NamespaceIsTruncatedNext.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.NamespaceIsTruncatedNext.verified.txt
rename to src/Build.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.NamespaceIsTruncatedNext.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.TargetIsTruncatedFirst.verified.txt b/src/Build.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.TargetIsTruncatedFirst.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.TargetIsTruncatedFirst.verified.txt
rename to src/Build.UnitTests/Snapshots/NodeStatus_SizeChange_Tests.TargetIsTruncatedFirst.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeTargetChanges.verified.txt b/src/Build.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeTargetChanges.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeTargetChanges.verified.txt
rename to src/Build.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeTargetChanges.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeTargetChangesToColoredTarget.verified.txt b/src/Build.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeTargetChangesToColoredTarget.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeTargetChangesToColoredTarget.verified.txt
rename to src/Build.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeTargetChangesToColoredTarget.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeTargetUpdatesTime.verified.txt b/src/Build.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeTargetUpdatesTime.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeTargetUpdatesTime.verified.txt
rename to src/Build.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeTargetUpdatesTime.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeWithColoredTargetUpdatesTime.verified.txt b/src/Build.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeWithColoredTargetUpdatesTime.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeWithColoredTargetUpdatesTime.verified.txt
rename to src/Build.UnitTests/Snapshots/NodeStatus_Transition_Tests.NodeWithColoredTargetUpdatesTime.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesTime.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesOverwritesWithNewTargetFramework.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.DisplayNodesShowsCurrent.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDetailedVerbosity_FailedWithErrors.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryDiagnosticVerbosity_FailedWithErrors.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryMinimalVerbosity_FailedWithErrors.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryNormalVerbosity_FailedWithErrors.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.OSX.verified.txt
similarity index 63%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.OSX.verified.txt
index 6e417bd1a11..63b3c74b0c3 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Linux.verified.txt
+++ b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.OSX.verified.txt
@@ -1,8 +1,7 @@
-﻿]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+﻿directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
 directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
   A
   Multi
   Line
   Warning!
 directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
-]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Windows.verified.txt
similarity index 63%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Windows.verified.txt
index 6e417bd1a11..63b3c74b0c3 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Windows.verified.txt
+++ b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummaryQuietVerbosity_FailedWithErrors.Windows.verified.txt
@@ -1,8 +1,7 @@
-﻿]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+﻿directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
 directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
   A
   Multi
   Line
   Warning!
 directory/[1mfile[m(1,2,3,4): [31;1merror[m [31;1mAA0000[m: Error!
-]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_2Projects_FailedWithErrorsAndWarnings.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_2Projects_FailedWithErrorsAndWarnings.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_2Projects_FailedWithErrorsAndWarnings.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_2Projects_FailedWithErrorsAndWarnings.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_2Projects_FailedWithErrorsAndWarnings.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_2Projects_FailedWithErrorsAndWarnings.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_2Projects_FailedWithErrorsAndWarnings.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_2Projects_FailedWithErrorsAndWarnings.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_2Projects_FailedWithErrorsAndWarnings.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_2Projects_FailedWithErrorsAndWarnings.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_2Projects_FailedWithErrorsAndWarnings.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_2Projects_FailedWithErrorsAndWarnings.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_Failed.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrors.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrorsAndWarnings.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrorsAndWarnings.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrorsAndWarnings.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrorsAndWarnings.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrorsAndWarnings.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrorsAndWarnings.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrorsAndWarnings.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrorsAndWarnings.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrorsAndWarnings.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrorsAndWarnings.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrorsAndWarnings.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_FailedWithErrorsAndWarnings.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintDetailedBuildSummary_FailedWithErrorAndWarning.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintDetailedBuildSummary_FailedWithErrorAndWarning.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintDetailedBuildSummary_FailedWithErrorAndWarning.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintDetailedBuildSummary_FailedWithErrorAndWarning.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintDetailedBuildSummary_FailedWithErrorAndWarning.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintDetailedBuildSummary_FailedWithErrorAndWarning.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintDetailedBuildSummary_FailedWithErrorAndWarning.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintDetailedBuildSummary_FailedWithErrorAndWarning.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintDetailedBuildSummary_FailedWithErrorAndWarning.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintDetailedBuildSummary_FailedWithErrorAndWarning.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintDetailedBuildSummary_FailedWithErrorAndWarning.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintDetailedBuildSummary_FailedWithErrorAndWarning.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Skipped.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateMessage_Success.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintImmediateWarningMessage_Succeeded.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_Failed.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintRestore_SuccessWithWarnings.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithOverwrittenVerbosity_FailedWithErrors.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithTaskCommandLineEventArgs_Succeeded.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithTaskCommandLineEventArgs_Succeeded.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithTaskCommandLineEventArgs_Succeeded.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithTaskCommandLineEventArgs_Succeeded.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithTaskCommandLineEventArgs_Succeeded.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithTaskCommandLineEventArgs_Succeeded.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithTaskCommandLineEventArgs_Succeeded.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithTaskCommandLineEventArgs_Succeeded.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithTaskCommandLineEventArgs_Succeeded.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithTaskCommandLineEventArgs_Succeeded.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithTaskCommandLineEventArgs_Succeeded.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithTaskCommandLineEventArgs_Succeeded.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithoutTaskCommandLineEventArgs_Succeeded.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithoutTaskCommandLineEventArgs_Succeeded.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithoutTaskCommandLineEventArgs_Succeeded.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithoutTaskCommandLineEventArgs_Succeeded.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithoutTaskCommandLineEventArgs_Succeeded.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithoutTaskCommandLineEventArgs_Succeeded.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithoutTaskCommandLineEventArgs_Succeeded.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithoutTaskCommandLineEventArgs_Succeeded.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithoutTaskCommandLineEventArgs_Succeeded.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithoutTaskCommandLineEventArgs_Succeeded.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithoutTaskCommandLineEventArgs_Succeeded.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintSummaryWithoutTaskCommandLineEventArgs_Succeeded.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryNormalVerbosity_Succeeded.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.Linux.verified.txt
diff --git a/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.OSX.verified.txt
new file mode 100644
index 00000000000..c1b8d743e34
--- /dev/null
+++ b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.OSX.verified.txt
@@ -0,0 +1 @@
+﻿emptyString
\ No newline at end of file
diff --git a/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.Windows.verified.txt
new file mode 100644
index 00000000000..c1b8d743e34
--- /dev/null
+++ b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.Windows.verified.txt
@@ -0,0 +1 @@
+﻿emptyString
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Linux.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.OSX.verified.txt
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt b/src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt
similarity index 100%
rename from src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt
rename to src/Build.UnitTests/Snapshots/TerminalLogger_Tests.PrintsBuildSummary_Succeeded.Windows.verified.txt
diff --git a/src/MSBuild.UnitTests/StaticStopwatch.cs b/src/Build.UnitTests/StaticStopwatch.cs
similarity index 93%
rename from src/MSBuild.UnitTests/StaticStopwatch.cs
rename to src/Build.UnitTests/StaticStopwatch.cs
index c1afad3179c..63d1bf7bcbd 100644
--- a/src/MSBuild.UnitTests/StaticStopwatch.cs
+++ b/src/Build.UnitTests/StaticStopwatch.cs
@@ -2,7 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Net.Http.Headers;
-using Microsoft.Build.Logging.TerminalLogger;
+using Microsoft.Build.Logging;
 
 namespace Microsoft.Build.CommandLine.UnitTests;
 
diff --git a/src/Build.UnitTests/TelemetryTests.cs b/src/Build.UnitTests/TelemetryTests.cs
new file mode 100644
index 00000000000..d04353d7321
--- /dev/null
+++ b/src/Build.UnitTests/TelemetryTests.cs
@@ -0,0 +1,197 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text.Json;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
+using Microsoft.Build.TelemetryInfra;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.Engine.UnitTests
+{
+    public class TelemetryTests
+    {
+        private readonly ITestOutputHelper _output;
+
+        public TelemetryTests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        private sealed class ProjectFinishedCapturingLogger : ILogger
+        {
+            private readonly List<ProjectFinishedEventArgs> _projectFinishedEventArgs = [];
+            public LoggerVerbosity Verbosity { get; set; }
+            public string? Parameters { get; set; }
+
+            public IReadOnlyList<ProjectFinishedEventArgs> ProjectFinishedEventArgsReceived =>
+                _projectFinishedEventArgs;
+
+            public void Initialize(IEventSource eventSource)
+            {
+                eventSource.ProjectFinished += EventSource_ProjectFinished;
+            }
+
+            private void EventSource_ProjectFinished(object sender, ProjectFinishedEventArgs e)
+            {
+                _projectFinishedEventArgs.Add(e);
+            }
+
+            public void Shutdown()
+            { }
+        }
+
+        [Fact]
+        public void WorkerNodeTelemetryCollection_BasicTarget()
+        {
+            WorkerNodeTelemetryData? workerNodeTelemetryData = null;
+            InternalTelemetryConsumingLogger.TestOnly_InternalTelemetryAggregted += dt => workerNodeTelemetryData = dt;
+
+            var testProject = """
+                                      <Project>
+                                          <Target Name="Build">
+                                              <Message Text="Hello World"/>
+                                              <CreateItem Include="foo.bar">
+                                                  <Output TaskParameter="Include" ItemName="I" />
+                                              </CreateItem>
+                                              <Message Text="Bye World"/>
+                                          </Target>
+                                      </Project>
+                              """;
+
+            MockLogger logger = new MockLogger(_output);
+            Helpers.BuildProjectContentUsingBuildManager(testProject, logger,
+                new BuildParameters() { IsTelemetryEnabled = true }).OverallResult.ShouldBe(BuildResultCode.Success);
+
+            workerNodeTelemetryData!.ShouldNotBeNull();
+            var buildTargetKey = new TaskOrTargetTelemetryKey("Build", true, false);
+            workerNodeTelemetryData.TargetsExecutionData.ShouldContainKey(buildTargetKey);
+            workerNodeTelemetryData.TargetsExecutionData[buildTargetKey].ShouldBeTrue();
+            workerNodeTelemetryData.TargetsExecutionData.Keys.Count.ShouldBe(1);
+
+            workerNodeTelemetryData.TasksExecutionData.Keys.Count.ShouldBeGreaterThan(2);
+            ((int)workerNodeTelemetryData.TasksExecutionData[(TaskOrTargetTelemetryKey)"Microsoft.Build.Tasks.Message"].ExecutionsCount).ShouldBe(2);
+            workerNodeTelemetryData.TasksExecutionData[(TaskOrTargetTelemetryKey)"Microsoft.Build.Tasks.Message"].CumulativeExecutionTime.ShouldBeGreaterThan(TimeSpan.Zero);
+            ((int)workerNodeTelemetryData.TasksExecutionData[(TaskOrTargetTelemetryKey)"Microsoft.Build.Tasks.CreateItem"].ExecutionsCount).ShouldBe(1);
+            workerNodeTelemetryData.TasksExecutionData[(TaskOrTargetTelemetryKey)"Microsoft.Build.Tasks.CreateItem"].CumulativeExecutionTime.ShouldBeGreaterThan(TimeSpan.Zero);
+
+            workerNodeTelemetryData.TasksExecutionData.Keys.ShouldAllBe(k => !k.IsCustom && !k.IsFromNugetCache);
+            workerNodeTelemetryData.TasksExecutionData.Values
+                .Count(v => v.CumulativeExecutionTime > TimeSpan.Zero || v.ExecutionsCount > 0).ShouldBe(2);
+        }
+
+        [Fact]
+        public void WorkerNodeTelemetryCollection_CustomTargetsAndTasks()
+        {
+            WorkerNodeTelemetryData? workerNodeTelemetryData = null;
+            InternalTelemetryConsumingLogger.TestOnly_InternalTelemetryAggregted += dt => workerNodeTelemetryData = dt;
+
+            var testProject = """
+                                      <Project>
+                                      <UsingTask
+                                          TaskName="Task01"
+                                          TaskFactory="RoslynCodeTaskFactory"
+                                          AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll" >
+                                          <ParameterGroup />
+                                          <Task>
+                                            <Code Type="Fragment" Language="cs">
+                                              Log.LogMessage(MessageImportance.Low, "Hello, world!");
+                                            </Code>
+                                          </Task>
+                                       </UsingTask>
+                                       
+                                       <UsingTask
+                                         TaskName="Task02"
+                                         TaskFactory="RoslynCodeTaskFactory"
+                                         AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll" >
+                                         <ParameterGroup />
+                                         <Task>
+                                           <Code Type="Fragment" Language="cs">
+                                             Log.LogMessage(MessageImportance.High, "Hello, world!");
+                                           </Code>
+                                         </Task>
+                                      </UsingTask>
+                                      
+                                          <Target Name="Build" DependsOnTargets="BeforeBuild">
+                                              <Message Text="Hello World"/>
+                                              <CreateItem Include="foo.bar">
+                                                  <Output TaskParameter="Include" ItemName="I" />
+                                              </CreateItem>
+                                              <Task01 />
+                                              <Message Text="Bye World"/>
+                                          </Target>
+                                          
+                                          <Target Name="BeforeBuild">
+                                              <Message Text="Hello World"/>
+                                              <Task01 />
+                                          </Target>
+                                          
+                                          <Target Name="NotExecuted">
+                                              <Message Text="Hello World"/>
+                                          </Target>
+                                      </Project>
+                              """;
+            MockLogger logger = new MockLogger(_output);
+            Helpers.BuildProjectContentUsingBuildManager(testProject, logger,
+                new BuildParameters() { IsTelemetryEnabled = true }).OverallResult.ShouldBe(BuildResultCode.Success);
+
+            workerNodeTelemetryData!.ShouldNotBeNull();
+            workerNodeTelemetryData.TargetsExecutionData.ShouldContainKey(new TaskOrTargetTelemetryKey("Build", true, false));
+            workerNodeTelemetryData.TargetsExecutionData[new TaskOrTargetTelemetryKey("Build", true, false)].ShouldBeTrue();
+            workerNodeTelemetryData.TargetsExecutionData.ShouldContainKey(new TaskOrTargetTelemetryKey("BeforeBuild", true, false));
+            workerNodeTelemetryData.TargetsExecutionData[new TaskOrTargetTelemetryKey("BeforeBuild", true, false)].ShouldBeTrue();
+            workerNodeTelemetryData.TargetsExecutionData.ShouldContainKey(new TaskOrTargetTelemetryKey("NotExecuted", true, false));
+            workerNodeTelemetryData.TargetsExecutionData[new TaskOrTargetTelemetryKey("NotExecuted", true, false)].ShouldBeFalse();
+            workerNodeTelemetryData.TargetsExecutionData.Keys.Count.ShouldBe(3);
+
+            workerNodeTelemetryData.TasksExecutionData.Keys.Count.ShouldBeGreaterThan(2);
+            ((int)workerNodeTelemetryData.TasksExecutionData[(TaskOrTargetTelemetryKey)"Microsoft.Build.Tasks.Message"].ExecutionsCount).ShouldBe(3);
+            workerNodeTelemetryData.TasksExecutionData[(TaskOrTargetTelemetryKey)"Microsoft.Build.Tasks.Message"].CumulativeExecutionTime.ShouldBeGreaterThan(TimeSpan.Zero);
+            ((int)workerNodeTelemetryData.TasksExecutionData[(TaskOrTargetTelemetryKey)"Microsoft.Build.Tasks.CreateItem"].ExecutionsCount).ShouldBe(1);
+            workerNodeTelemetryData.TasksExecutionData[(TaskOrTargetTelemetryKey)"Microsoft.Build.Tasks.CreateItem"].CumulativeExecutionTime.ShouldBeGreaterThan(TimeSpan.Zero);
+
+            ((int)workerNodeTelemetryData.TasksExecutionData[new TaskOrTargetTelemetryKey("Task01", true, false)].ExecutionsCount).ShouldBe(2);
+            workerNodeTelemetryData.TasksExecutionData[new TaskOrTargetTelemetryKey("Task01", true, false)].CumulativeExecutionTime.ShouldBeGreaterThan(TimeSpan.Zero);
+
+            ((int)workerNodeTelemetryData.TasksExecutionData[new TaskOrTargetTelemetryKey("Task02", true, false)].ExecutionsCount).ShouldBe(0);
+            workerNodeTelemetryData.TasksExecutionData[new TaskOrTargetTelemetryKey("Task02", true, false)].CumulativeExecutionTime.ShouldBe(TimeSpan.Zero);
+
+            workerNodeTelemetryData.TasksExecutionData.Values
+                .Count(v => v.CumulativeExecutionTime > TimeSpan.Zero || v.ExecutionsCount > 0).ShouldBe(3);
+
+            workerNodeTelemetryData.TasksExecutionData.Keys.ShouldAllBe(k => !k.IsFromNugetCache);
+        }
+
+        [Fact]
+        public void Foo()
+        {
+            WorkerNodeTelemetryData wd = new WorkerNodeTelemetryData(
+                new Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>()
+                {
+                    {
+                        new TaskOrTargetTelemetryKey("TaskA", false, true),
+                        new TaskExecutionStats(TimeSpan.FromSeconds(2.1554548), 5, 545)
+                    },
+                    {
+                        new TaskOrTargetTelemetryKey("TaskA", true, false),
+                        new TaskExecutionStats(TimeSpan.FromSeconds(254548), 6, 54545451)
+                    },
+                },
+                new Dictionary<TaskOrTargetTelemetryKey, bool>()
+                {
+                    { new TaskOrTargetTelemetryKey("TargetA", false, true, false), false },
+                    { new TaskOrTargetTelemetryKey("TargetA", true, true, false), false },
+                    { new TaskOrTargetTelemetryKey("TargetB", false, false, true), false }
+                });
+
+            var holder = TelemetryDataUtils.AsActivityDataHolder(wd, true, true);
+        }
+    }
+}
diff --git a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs b/src/Build.UnitTests/TerminalLogger_Tests.cs
similarity index 94%
rename from src/MSBuild.UnitTests/TerminalLogger_Tests.cs
rename to src/Build.UnitTests/TerminalLogger_Tests.cs
index a97f2c683cc..2c04241a604 100644
--- a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
+++ b/src/Build.UnitTests/TerminalLogger_Tests.cs
@@ -15,7 +15,6 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
-using Microsoft.Build.Logging.TerminalLogger;
 using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using VerifyTests;
@@ -70,6 +69,42 @@ public TerminalLogger_Tests()
             Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
         }
 
+        [Theory]
+        [InlineData(null, false, false, "", typeof(ConsoleLogger))]
+        [InlineData(null, true, false, "", typeof(ConsoleLogger))]
+        [InlineData(null, false, true, "", typeof(ConsoleLogger))]
+        [InlineData(null, true, true, "off", typeof(ConsoleLogger))]
+        [InlineData(null, true, true, "false", typeof(ConsoleLogger))]
+        [InlineData("--tl:off", true, true, "", typeof(ConsoleLogger))]
+        [InlineData(null, true, true, "", typeof(TerminalLogger))]
+        [InlineData("-tl:on", true, true, "off", typeof(TerminalLogger))]
+        public void CreateTerminalOrConsoleLogger_CreatesCorrectLoggerInstance(string? argsString, bool supportsAnsi, bool outputIsScreen, string evnVariableValue, Type expectedType)
+        {
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            testEnvironment.SetEnvironmentVariable("MSBUILDTERMINALLOGGER", evnVariableValue);
+
+            string[]? args = argsString?.Split(' ');
+            ILogger logger = TerminalLogger.CreateTerminalOrConsoleLogger(args, supportsAnsi, outputIsScreen, default);
+
+            logger.ShouldNotBeNull();
+            logger.GetType().ShouldBe(expectedType);
+        }
+
+        [Theory]
+        [InlineData("-v:q", LoggerVerbosity.Quiet)]
+        [InlineData("-verbosity:minimal", LoggerVerbosity.Minimal)]
+        [InlineData("--v:d", LoggerVerbosity.Detailed)]
+        [InlineData("/verbosity:diag", LoggerVerbosity.Diagnostic)]
+        [InlineData(null, LoggerVerbosity.Normal)]
+        public void CreateTerminalOrConsoleLogger_ParsesVerbosity(string? argsString, LoggerVerbosity expectedVerbosity)
+        {
+            string[]? args = argsString?.Split(' ');
+            ILogger logger = TerminalLogger.CreateTerminalOrConsoleLogger(args, true, true, default);
+
+            logger.ShouldNotBeNull();
+            logger.Verbosity.ShouldBe(expectedVerbosity);
+        }
+
         #region IEventSource implementation
 
 #pragma warning disable CS0067
diff --git a/src/MSBuild.UnitTests/TickingStopwatch.cs b/src/Build.UnitTests/TickingStopwatch.cs
similarity index 95%
rename from src/MSBuild.UnitTests/TickingStopwatch.cs
rename to src/Build.UnitTests/TickingStopwatch.cs
index e0cd213ebeb..8342a7ec005 100644
--- a/src/MSBuild.UnitTests/TickingStopwatch.cs
+++ b/src/Build.UnitTests/TickingStopwatch.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Microsoft.Build.Logging.TerminalLogger;
+using Microsoft.Build.Logging;
 
 namespace Microsoft.Build.CommandLine.UnitTests;
 
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index db2d9eab3ad..5f05b945e94 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -527,5 +527,33 @@ public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_False()
                 logger.AssertLogContains("MSB4181");
             }
         }
+
+        /// <summary>
+        /// MSBuildWarningsAsMessages should allow comma separation.
+        /// </summary>
+        [Fact]
+        public void MSBuildWarningsAsMessagesWithCommaSeparation()
+        {
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                var content = """
+                <Project>
+                    <PropertyGroup>
+                       <MSBuildWarningsAsMessages>NAT011,NAT012</MSBuildWarningsAsMessages>
+                    </PropertyGroup>
+
+                    <Target Name='Build'>
+                        <Warning Code="NAT011" Text="You fail" />
+                        <Warning Code="NAT012" Text="Other Fail" />
+                    </Target>
+                </Project>
+                """;
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles(content);
+
+                MockLogger logger = proj.BuildProjectExpectSuccess();
+                logger.WarningCount.ShouldBe(0);
+                logger.ErrorCount.ShouldBe(0);
+            }
+        }
     }
 }
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 10cf3577bf1..4dbf79918ac 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -36,6 +36,7 @@
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
+using Microsoft.Build.TelemetryInfra;
 using Microsoft.NET.StringTools;
 using ExceptionHandling = Microsoft.Build.Shared.ExceptionHandling;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
@@ -257,6 +258,11 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// </summary>
         private BuildTelemetry? _buildTelemetry;
 
+        /// <summary>
+        /// Logger, that if instantiated - will receive and expose telemetry data from worker nodes.
+        /// </summary>
+        private InternalTelemetryConsumingLogger? _telemetryConsumingLogger;
+
         private ProjectCacheService? _projectCacheService;
 
         private bool _hasProjectCacheServiceInitializedVsScenario;
@@ -453,6 +459,7 @@ private void UpdatePriority(Process p, ProcessPriorityClass priority)
         /// <exception cref="InvalidOperationException">Thrown if a build is already in progress.</exception>
         public void BeginBuild(BuildParameters parameters)
         {
+            OpenTelemetryManager.Instance.Initialize(isStandalone: false);
             if (_previousLowPriority != null)
             {
                 if (parameters.LowPriority != _previousLowPriority)
@@ -562,6 +569,7 @@ public void BeginBuild(BuildParameters parameters)
                 // Initialize components.
                 _nodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.NodeManager) as INodeManager;
 
+                _buildParameters.IsTelemetryEnabled |= OpenTelemetryManager.Instance.IsActive();
                 var loggingService = InitializeLoggingService();
 
                 // Log deferred messages and response files
@@ -759,8 +767,8 @@ private static void AttachDebugger()
 #endif
                 case "2":
                     // Sometimes easier to attach rather than deal with JIT prompt
-                    Process currentProcess = Process.GetCurrentProcess();
-                    Console.WriteLine($"Waiting for debugger to attach ({currentProcess.MainModule!.FileName} PID {currentProcess.Id}).  Press enter to continue...");
+                    Console.WriteLine($"Waiting for debugger to attach ({EnvironmentUtilities.ProcessPath} PID {EnvironmentUtilities.CurrentProcessId}).  Press enter to continue...");
+
                     Console.ReadLine();
                     break;
             }
@@ -910,8 +918,8 @@ private BuildSubmissionBase<TRequestData, TResultData> PendBuildRequest<TRequest
                 {
                     // Project graph can have multiple entry points, for purposes of identifying event for same build project,
                     // we believe that including only one entry point will provide enough precision.
-                    _buildTelemetry.Project ??= requestData.EntryProjectsFullPath.FirstOrDefault();
-                    _buildTelemetry.Target ??= string.Join(",", requestData.TargetNames);
+                    _buildTelemetry.ProjectPath ??= requestData.EntryProjectsFullPath.FirstOrDefault();
+                    _buildTelemetry.BuildTarget ??= string.Join(",", requestData.TargetNames);
                 }
 
                 _buildSubmissions.Add(newSubmission.SubmissionId, newSubmission);
@@ -1055,10 +1063,10 @@ public void EndBuild()
                         if (_buildTelemetry != null)
                         {
                             _buildTelemetry.FinishedAt = DateTime.UtcNow;
-                            _buildTelemetry.Success = _overallBuildSuccess;
-                            _buildTelemetry.Version = ProjectCollection.Version;
-                            _buildTelemetry.DisplayVersion = ProjectCollection.DisplayVersion;
-                            _buildTelemetry.FrameworkName = NativeMethodsShared.FrameworkName;
+                            _buildTelemetry.BuildSuccess = _overallBuildSuccess;
+                            _buildTelemetry.BuildEngineVersion = ProjectCollection.Version;
+                            _buildTelemetry.BuildEngineDisplayVersion = ProjectCollection.DisplayVersion;
+                            _buildTelemetry.BuildEngineFrameworkName = NativeMethodsShared.FrameworkName;
 
                             string? host = null;
                             if (BuildEnvironmentState.s_runningInVisualStudio)
@@ -1073,7 +1081,7 @@ public void EndBuild()
                             {
                                 host = "VSCode";
                             }
-                            _buildTelemetry.Host = host;
+                            _buildTelemetry.BuildEngineHost = host;
 
                             _buildTelemetry.BuildCheckEnabled = _buildParameters!.IsBuildCheckEnabled;
                             var sacState = NativeMethodsShared.GetSACState();
@@ -1081,6 +1089,11 @@ public void EndBuild()
                             _buildTelemetry.SACEnabled = sacState == NativeMethodsShared.SAC_State.Evaluation || sacState == NativeMethodsShared.SAC_State.Enforcement;
 
                             loggingService.LogTelemetry(buildEventContext: null, _buildTelemetry.EventName, _buildTelemetry.GetProperties());
+                            if (OpenTelemetryManager.Instance.IsActive())
+                            {
+                                EndBuildTelemetry();
+                            }
+
                             // Clean telemetry to make it ready for next build submission.
                             _buildTelemetry = null;
                         }
@@ -1123,6 +1136,20 @@ void SerializeCaches()
             }
         }
 
+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads of System.Diagnostics.DiagnosticSource, TODO: when this is agreed to perf-wise enable instrumenting using activities anywhere...
+        private void EndBuildTelemetry()
+        {
+            OpenTelemetryManager.Instance.DefaultActivitySource?
+                .StartActivity("Build")?
+                .WithTags(_buildTelemetry)
+                .WithTags(_telemetryConsumingLogger?.WorkerNodeTelemetryData.AsActivityDataHolder(
+                    includeTasksDetails: !Traits.Instance.ExcludeTasksDetailsFromTelemetry,
+                    includeTargetDetails: false))
+                .WithStartTime(_buildTelemetry!.InnerStartAt)
+                .Dispose();
+            OpenTelemetryManager.Instance.ForceFlush();
+        }
+
         /// <summary>
         /// Convenience method.  Submits a lone build request and blocks until results are available.
         /// </summary>
@@ -2940,7 +2967,7 @@ private ILoggingService CreateLoggingService(
                     ((IBuildComponentHost)this).GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider;
                 buildCheckManagerProvider!.Instance.SetDataSource(BuildCheckDataSource.EventArgs);
 
-                // We do want to dictate our own forwarding logger (otherwise CentralForwardingLogger with minimum transferred importance MessageImportnace.Low is used)
+                // We do want to dictate our own forwarding logger (otherwise CentralForwardingLogger with minimum transferred importance MessageImportance.Low is used)
                 // In the future we might optimize for single, in-node build scenario - where forwarding logger is not needed (but it's just quick pass-through)
                 LoggerDescription forwardingLoggerDescription = new LoggerDescription(
                     loggerClassName: typeof(BuildCheckForwardingLogger).FullName,
@@ -2958,6 +2985,25 @@ private ILoggingService CreateLoggingService(
                 forwardingLoggers = forwardingLoggers?.Concat(forwardingLogger) ?? forwardingLogger;
             }
 
+            if (_buildParameters.IsTelemetryEnabled)
+            {
+                // We do want to dictate our own forwarding logger (otherwise CentralForwardingLogger with minimum transferred importance MessageImportance.Low is used)
+                // In the future we might optimize for single, in-node build scenario - where forwarding logger is not needed (but it's just quick pass-through)
+                LoggerDescription forwardingLoggerDescription = new LoggerDescription(
+                    loggerClassName: typeof(InternalTelemeteryForwardingLogger).FullName,
+                    loggerAssemblyName: typeof(InternalTelemeteryForwardingLogger).GetTypeInfo().Assembly.GetName().FullName,
+                    loggerAssemblyFile: null,
+                    loggerSwitchParameters: null,
+                    verbosity: LoggerVerbosity.Quiet);
+
+                _telemetryConsumingLogger =
+                    new InternalTelemetryConsumingLogger();
+
+                ForwardingLoggerRecord[] forwardingLogger = { new ForwardingLoggerRecord(_telemetryConsumingLogger, forwardingLoggerDescription) };
+
+                forwardingLoggers = forwardingLoggers?.Concat(forwardingLogger) ?? forwardingLogger;
+            }
+
             try
             {
                 if (loggers != null)
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index a8d528d4fb4..38eca66834b 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -146,6 +146,11 @@ public class BuildParameters : ITranslatable
         /// </summary>
         private PropertyDictionary<ProjectPropertyInstance> _globalProperties = new PropertyDictionary<ProjectPropertyInstance>();
 
+        /// <summary>
+        /// Properties passed from the command line (e.g. by using /p:).
+        /// </summary>
+        private ICollection<string> _propertiesFromCommandLine;
+
         /// <summary>
         /// The loggers.
         /// </summary>
@@ -211,6 +216,8 @@ public class BuildParameters : ITranslatable
 
         private bool _isBuildCheckEnabled;
 
+        private bool _isTelemetryEnabled;
+
         /// <summary>
         /// The settings used to load the project under build
         /// </summary>
@@ -250,6 +257,7 @@ public BuildParameters(ProjectCollection projectCollection)
             _defaultToolsVersion = projectCollection.DefaultToolsVersion;
 
             _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(projectCollection.GlobalPropertiesCollection);
+            _propertiesFromCommandLine = projectCollection.PropertiesFromCommandLine;
         }
 
         /// <summary>
@@ -279,6 +287,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             _environmentProperties = other._environmentProperties != null ? new PropertyDictionary<ProjectPropertyInstance>(other._environmentProperties) : null;
             _forwardingLoggers = other._forwardingLoggers != null ? new List<ForwardingLoggerRecord>(other._forwardingLoggers) : null;
             _globalProperties = other._globalProperties != null ? new PropertyDictionary<ProjectPropertyInstance>(other._globalProperties) : null;
+            _propertiesFromCommandLine = other._propertiesFromCommandLine != null ? new HashSet<string>(other._propertiesFromCommandLine, StringComparer.OrdinalIgnoreCase) : null;
             HostServices = other.HostServices;
             _loggers = other._loggers != null ? new List<ILogger>(other._loggers) : null;
             _maxNodeCount = other._maxNodeCount;
@@ -314,6 +323,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             LowPriority = other.LowPriority;
             Question = other.Question;
             IsBuildCheckEnabled = other.IsBuildCheckEnabled;
+            IsTelemetryEnabled = other.IsTelemetryEnabled;
             ProjectCacheDescriptor = other.ProjectCacheDescriptor;
         }
 
@@ -332,6 +342,10 @@ public bool UseSynchronousLogging
             set => _useSynchronousLogging = value;
         }
 
+        /// <summary>
+        /// Properties passed from the command line (e.g. by using /p:).
+        /// </summary>
+        public ICollection<string> PropertiesFromCommandLine => _propertiesFromCommandLine;
 
         /// <summary>
         /// Indicates whether to emit a default error if a task returns false without logging an error.
@@ -848,6 +862,17 @@ public bool IsBuildCheckEnabled
             set => _isBuildCheckEnabled = value;
         }
 
+        /// <summary>
+        /// Gets or sets an indication if telemetry is enabled.
+        /// This is reserved for future usage - we will likely add a whole dictionary of enablement per telemetry namespace
+        ///  as we plan to have variable sampling rate per various sources.
+        /// </summary>
+        internal bool IsTelemetryEnabled
+        {
+            get => _isTelemetryEnabled;
+            set => _isTelemetryEnabled = value;
+        }
+
         /// <summary>
         /// Gets or sets the project cache description to use for all <see cref="BuildSubmission"/> or <see cref="GraphBuildSubmission"/>
         /// in addition to any potential project caches described in each project.
@@ -913,6 +938,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _interactive);
             translator.Translate(ref _question);
             translator.Translate(ref _isBuildCheckEnabled);
+            translator.Translate(ref _isTelemetryEnabled);
             translator.TranslateEnum(ref _projectIsolationMode, (int)_projectIsolationMode);
             translator.Translate(ref _reportFileAccesses);
 
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index c23b5134407..0abf86a2aa2 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -176,7 +176,7 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
                 bool serverIsAlreadyRunning = ServerIsRunning();
                 if (KnownTelemetry.PartialBuildTelemetry != null)
                 {
-                    KnownTelemetry.PartialBuildTelemetry.InitialServerState = serverIsAlreadyRunning ? "hot" : "cold";
+                    KnownTelemetry.PartialBuildTelemetry.InitialMSBuildServerState = serverIsAlreadyRunning ? "hot" : "cold";
                 }
                 if (!serverIsAlreadyRunning)
                 {
@@ -474,7 +474,7 @@ private bool TryLaunchServer()
                 ];
                 NodeLauncher nodeLauncher = new NodeLauncher();
                 CommunicationsUtilities.Trace("Starting Server...");
-                Process msbuildProcess = nodeLauncher.Start(_msbuildLocation, string.Join(" ", msBuildServerOptions), nodeId: 0);
+                using Process msbuildProcess = nodeLauncher.Start(_msbuildLocation, string.Join(" ", msBuildServerOptions), nodeId: 0);
                 CommunicationsUtilities.Trace("Server started with PID: {0}", msbuildProcess?.Id);
             }
             catch (Exception ex)
@@ -521,7 +521,7 @@ private ServerNodeBuildCommand GetServerNodeBuildCommand()
                 ? null
                 : new PartialBuildTelemetry(
                     startedAt: KnownTelemetry.PartialBuildTelemetry.StartAt.GetValueOrDefault(),
-                    initialServerState: KnownTelemetry.PartialBuildTelemetry.InitialServerState,
+                    initialServerState: KnownTelemetry.PartialBuildTelemetry.InitialMSBuildServerState,
                     serverFallbackReason: KnownTelemetry.PartialBuildTelemetry.ServerFallbackReason);
 
             return new ServerNodeBuildCommand(
diff --git a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
index 7262bb0d329..c48b89ef797 100644
--- a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
+++ b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Shared;
+using Microsoft.Build.TelemetryInfra;
 
 #nullable disable
 
@@ -77,8 +78,9 @@ public void RegisterDefaultFactories()
             // NodeEndpoint,
             _componentEntriesByType[BuildComponentType.LoggingService] = new BuildComponentEntry(BuildComponentType.LoggingService, null);
             _componentEntriesByType[BuildComponentType.RequestBuilder] = new BuildComponentEntry(BuildComponentType.RequestBuilder, RequestBuilder.CreateComponent, CreationPattern.CreateAlways);
-            // This conditionally registers real or no-op implementation based on BuildParameters
+            // Following two conditionally registers real or no-op implementation based on BuildParameters
             _componentEntriesByType[BuildComponentType.BuildCheckManagerProvider] = new BuildComponentEntry(BuildComponentType.BuildCheckManagerProvider, BuildCheckManagerProvider.CreateComponent, CreationPattern.Singleton);
+            _componentEntriesByType[BuildComponentType.TelemetryForwarder] = new BuildComponentEntry(BuildComponentType.TelemetryForwarder, TelemetryForwarderProvider.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.TargetBuilder] = new BuildComponentEntry(BuildComponentType.TargetBuilder, TargetBuilder.CreateComponent, CreationPattern.CreateAlways);
             _componentEntriesByType[BuildComponentType.TaskBuilder] = new BuildComponentEntry(BuildComponentType.TaskBuilder, TaskBuilder.CreateComponent, CreationPattern.CreateAlways);
             _componentEntriesByType[BuildComponentType.RegisteredTaskObjectCache] = new BuildComponentEntry(BuildComponentType.RegisteredTaskObjectCache, RegisteredTaskObjectCache.CreateComponent, CreationPattern.Singleton);
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 9c633d14b8c..e3b0a6d069e 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -15,6 +15,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
+using Microsoft.Build.TelemetryInfra;
 using BuildAbortedException = Microsoft.Build.Exceptions.BuildAbortedException;
 
 #nullable disable
@@ -286,6 +287,9 @@ public void CleanupForBuild()
                     IBuildCheckManagerProvider buildCheckProvider = (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider);
                     var buildCheckManager = buildCheckProvider!.Instance;
                     buildCheckManager.FinalizeProcessing(_nodeLoggingContext);
+                    // Flush and send the final telemetry data if they are being collected
+                    ITelemetryForwarder telemetryForwarder = (_componentHost.GetComponent(BuildComponentType.TelemetryForwarder) as TelemetryForwarderProvider)!.Instance;
+                    telemetryForwarder.FinalizeProcessing(_nodeLoggingContext);
                     // Clears the instance so that next call (on node reuse) to 'GetComponent' leads to reinitialization.
                     buildCheckProvider.ShutdownComponent();
                 },
@@ -1426,7 +1430,7 @@ private void TraceEngine(string format, params object[] stuff)
                 {
                     FileUtilities.EnsureDirectoryExists(_debugDumpPath);
 
-                    using (StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, @"EngineTrace_{0}.txt"), Process.GetCurrentProcess().Id), append: true))
+                    using (StreamWriter file = FileUtilities.OpenWrite(string.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, @"EngineTrace_{0}.txt"), EnvironmentUtilities.CurrentProcessId), append: true))
                     {
                         string message = String.Format(CultureInfo.CurrentCulture, format, stuff);
                         file.WriteLine("{0}({1})-{2}: {3}", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, DateTime.UtcNow.Ticks, message);
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index dec22e8c017..60b8a0dc12c 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -178,7 +178,7 @@ public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> co
                     if (buildDataFlagsSatisfied)
                     {
                         // Check for targets explicitly specified.
-                        bool explicitTargetsSatisfied = CheckResults(allResults, request.Targets, response.ExplicitTargetsToBuild, skippedResultsDoNotCauseCacheMiss);
+                        bool explicitTargetsSatisfied = CheckResults(allResults, request.Targets, checkTargetsMissingResults: true, skippedResultsDoNotCauseCacheMiss);
 
                         if (explicitTargetsSatisfied)
                         {
@@ -186,7 +186,7 @@ public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> co
                             response.Type = ResultsCacheResponseType.Satisfied;
 
                             // Check for the initial targets.  If we don't know what the initial targets are, we assume they are not satisfied.
-                            if (configInitialTargets == null || !CheckResults(allResults, configInitialTargets, null, skippedResultsDoNotCauseCacheMiss))
+                            if (configInitialTargets == null || !CheckResults(allResults, configInitialTargets, checkTargetsMissingResults: false, skippedResultsDoNotCauseCacheMiss))
                             {
                                 response.Type = ResultsCacheResponseType.NotSatisfied;
                             }
@@ -196,7 +196,7 @@ public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> co
                             {
                                 // Check for the default target, if necessary.  If we don't know what the default targets are, we
                                 // assume they are not satisfied.
-                                if (configDefaultTargets == null || !CheckResults(allResults, configDefaultTargets, null, skippedResultsDoNotCauseCacheMiss))
+                                if (configDefaultTargets == null || !CheckResults(allResults, configDefaultTargets, checkTargetsMissingResults: false, skippedResultsDoNotCauseCacheMiss))
                                 {
                                     response.Type = ResultsCacheResponseType.NotSatisfied;
                                 }
@@ -308,20 +308,21 @@ internal static IBuildComponent CreateComponent(BuildComponentType componentType
         /// </summary>
         /// <param name="result">The result to examine</param>
         /// <param name="targets">The targets to search for</param>
-        /// <param name="targetsMissingResults">An optional list to be populated with missing targets</param>
+        /// <param name="checkTargetsMissingResults">If missing targets will be checked for.</param>
         /// <param name="skippedResultsAreOK">If true, a status of "skipped" counts as having valid results
         /// for that target.  Otherwise, a skipped target is treated as equivalent to a missing target.</param>
         /// <returns>False if there were missing results, true otherwise.</returns>
-        private static bool CheckResults(BuildResult result, List<string> targets, HashSet<string> targetsMissingResults, bool skippedResultsAreOK)
+        private static bool CheckResults(BuildResult result, List<string> targets, bool checkTargetsMissingResults, bool skippedResultsAreOK)
         {
             bool returnValue = true;
+            bool missingTargetFound = false;
             foreach (string target in targets)
             {
-                if (!result.HasResultsForTarget(target) || (result[target].ResultCode == TargetResultCode.Skipped && !skippedResultsAreOK))
+                if (!result.TryGetResultsForTarget(target, out TargetResult targetResult) || (targetResult.ResultCode == TargetResultCode.Skipped && !skippedResultsAreOK))
                 {
-                    if (targetsMissingResults != null)
+                    if (checkTargetsMissingResults)
                     {
-                        targetsMissingResults.Add(target);
+                        missingTargetFound = true;
                         returnValue = false;
                     }
                     else
@@ -333,7 +334,7 @@ private static bool CheckResults(BuildResult result, List<string> targets, HashS
                 {
                     // If the result was a failure and we have not seen any skipped targets up to this point, then we conclude we do
                     // have results for this request, and they indicate failure.
-                    if (result[target].ResultCode == TargetResultCode.Failure && (targetsMissingResults == null || targetsMissingResults.Count == 0))
+                    if (targetResult.ResultCode == TargetResultCode.Failure && (!checkTargetsMissingResults || !missingTargetFound))
                     {
                         return true;
                     }
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs b/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs
index 0b9971a8b99..03e123f9141 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs
@@ -41,11 +41,6 @@ internal struct ResultsCacheResponse
         /// </summary>
         public BuildResult Results;
 
-        /// <summary>
-        /// The subset of explicit targets which must be built because there are no results for them in the cache.
-        /// </summary>
-        public HashSet<string> ExplicitTargetsToBuild;
-
         /// <summary>
         /// Constructor.
         /// </summary>
@@ -54,7 +49,6 @@ public ResultsCacheResponse(ResultsCacheResponseType type)
         {
             Type = type;
             Results = null;
-            ExplicitTargetsToBuild = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/CurrentHost.cs b/src/Build/BackEnd/Components/Communications/CurrentHost.cs
index 37bc10fc28e..a9c8336b837 100644
--- a/src/Build/BackEnd/Components/Communications/CurrentHost.cs
+++ b/src/Build/BackEnd/Components/Communications/CurrentHost.cs
@@ -35,10 +35,7 @@ public static string GetCurrentHost()
                 }
                 else
                 {
-                    using (Process currentProcess = Process.GetCurrentProcess())
-                    {
-                        s_currentHost = currentProcess.MainModule.FileName;
-                    }
+                    s_currentHost = EnvironmentUtilities.ProcessPath;
                 }
             }
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 87602148672..c506179bcd6 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -10,6 +10,7 @@
 using System.IO.Pipes;
 using System.Diagnostics;
 using System.Linq;
+using System.Threading;
 using System.Threading.Tasks;
 #if FEATURE_PIPE_SECURITY
 using System.Security.Principal;
@@ -17,8 +18,6 @@
 
 #if FEATURE_APM
 using Microsoft.Build.Eventing;
-#else
-using System.Threading;
 #endif
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -56,6 +55,9 @@ internal abstract class NodeProviderOutOfProcBase
         /// </summary>
         private const int TimeoutForWaitForExit = 30000;
 
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+        private static readonly WindowsIdentity s_currentWindowsIdentity = WindowsIdentity.GetCurrent();
+#endif
         /// <summary>
         /// The build component host.
         /// </summary>
@@ -237,11 +239,12 @@ protected IList<NodeContext> GetNodes(string msbuildLocation,
 #endif
             ConcurrentQueue<NodeContext> nodeContexts = new();
             ConcurrentQueue<Exception> exceptions = new();
+            int currentProcessId = EnvironmentUtilities.CurrentProcessId;
             Parallel.For(nextNodeId, nextNodeId + numberOfNodesToCreate, (nodeId) =>
             {
                 try
                 {
-                    if (!TryReuseAnyFromPossibleRunningNodes(nodeId) && !StartNewNode(nodeId))
+                    if (!TryReuseAnyFromPossibleRunningNodes(currentProcessId, nodeId) && !StartNewNode(nodeId))
                     {
                         // We were unable to reuse or launch a node.
                         CommunicationsUtilities.Trace("FAILED TO CONNECT TO A CHILD NODE");
@@ -260,12 +263,12 @@ protected IList<NodeContext> GetNodes(string msbuildLocation,
 
             return nodeContexts.ToList();
 
-            bool TryReuseAnyFromPossibleRunningNodes(int nodeId)
+            bool TryReuseAnyFromPossibleRunningNodes(int currentProcessId, int nodeId)
             {
                 while (possibleRunningNodes != null && possibleRunningNodes.TryDequeue(out var nodeToReuse))
                 {
                     CommunicationsUtilities.Trace("Trying to connect to existing process {2} with id {1} to establish node {0}...", nodeId, nodeToReuse.Id, nodeToReuse.ProcessName);
-                    if (nodeToReuse.Id == Process.GetCurrentProcess().Id)
+                    if (nodeToReuse.Id == currentProcessId)
                     {
                         continue;
                     }
@@ -421,7 +424,7 @@ private string GetProcessesToIgnoreKey(Handshake hostHandshake, int nodeProcessI
         //  on non-Windows operating systems
         private static void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStream)
         {
-            SecurityIdentifier identifier = WindowsIdentity.GetCurrent().Owner;
+            SecurityIdentifier identifier = s_currentWindowsIdentity.Owner;
 #if FEATURE_PIPE_SECURITY
             PipeSecurity remoteSecurity = nodeStream.GetAccessControl();
 #else
@@ -576,7 +579,7 @@ private enum ExitPacketState
             /// <summary>
             /// A queue used for enqueuing packets to write to the stream asynchronously.
             /// </summary>
-            private BlockingCollection<INodePacket> _packetWriteQueue = new BlockingCollection<INodePacket>();
+            private ConcurrentQueue<INodePacket> _packetWriteQueue = new ConcurrentQueue<INodePacket>();
 
             /// <summary>
             /// A task representing the last packet write, so we can chain packet writes one after another.
@@ -711,7 +714,7 @@ public void SendData(INodePacket packet)
                 {
                     _exitPacketState = ExitPacketState.ExitPacketQueued;
                 }
-                _packetWriteQueue.Add(packet);
+                _packetWriteQueue.Enqueue(packet);
                 DrainPacketQueue();
             }
 
@@ -733,65 +736,63 @@ private void DrainPacketQueue()
                 {
                     // average latency between the moment this runs and when the delegate starts
                     // running is about 100-200 microseconds (unless there's thread pool saturation)
-                    _packetWriteDrainTask = _packetWriteDrainTask.ContinueWith(_ =>
+                    _packetWriteDrainTask = _packetWriteDrainTask.ContinueWith(
+                        SendDataCoreAsync,
+                        this,
+                        TaskScheduler.Default).Unwrap();
+
+                    static async Task SendDataCoreAsync(Task _, object state)
                     {
-                        while (_packetWriteQueue.TryTake(out var packet))
+                        NodeContext context = (NodeContext)state;
+                        while (context._packetWriteQueue.TryDequeue(out var packet))
                         {
-                            SendDataCore(packet);
-                        }
-                    }, TaskScheduler.Default);
-                }
-            }
+                            MemoryStream writeStream = context._writeBufferMemoryStream;
 
-            /// <summary>
-            /// Actually writes and sends the packet. This can't be called in parallel
-            /// because it reuses the _writeBufferMemoryStream, and this is why we use
-            /// the _packetWriteDrainTask to serially chain invocations one after another.
-            /// </summary>
-            /// <param name="packet">The packet to send.</param>
-            private void SendDataCore(INodePacket packet)
-            {
-                MemoryStream writeStream = _writeBufferMemoryStream;
+                            // clear the buffer but keep the underlying capacity to avoid reallocations
+                            writeStream.SetLength(0);
 
-                // clear the buffer but keep the underlying capacity to avoid reallocations
-                writeStream.SetLength(0);
+                            ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(writeStream);
+                            try
+                            {
+                                writeStream.WriteByte((byte)packet.Type);
 
-                ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(writeStream);
-                try
-                {
-                    writeStream.WriteByte((byte)packet.Type);
+                                // Pad for the packet length
+                                WriteInt32(writeStream, 0);
+                                packet.Translate(writeTranslator);
 
-                    // Pad for the packet length
-                    WriteInt32(writeStream, 0);
-                    packet.Translate(writeTranslator);
+                                int writeStreamLength = (int)writeStream.Position;
 
-                    int writeStreamLength = (int)writeStream.Position;
+                                // Now plug in the real packet length
+                                writeStream.Position = 1;
+                                WriteInt32(writeStream, writeStreamLength - 5);
 
-                    // Now plug in the real packet length
-                    writeStream.Position = 1;
-                    WriteInt32(writeStream, writeStreamLength - 5);
+                                byte[] writeStreamBuffer = writeStream.GetBuffer();
 
-                    byte[] writeStreamBuffer = writeStream.GetBuffer();
+                                for (int i = 0; i < writeStreamLength; i += MaxPacketWriteSize)
+                                {
+                                    int lengthToWrite = Math.Min(writeStreamLength - i, MaxPacketWriteSize);
+#pragma warning disable CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+                                    await context._serverToClientStream.WriteAsync(writeStreamBuffer, i, lengthToWrite, CancellationToken.None);
+#pragma warning restore CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+                                }
 
-                    for (int i = 0; i < writeStreamLength; i += MaxPacketWriteSize)
-                    {
-                        int lengthToWrite = Math.Min(writeStreamLength - i, MaxPacketWriteSize);
-                        _serverToClientStream.Write(writeStreamBuffer, i, lengthToWrite);
-                    }
-                    if (IsExitPacket(packet))
-                    {
-                        _exitPacketState = ExitPacketState.ExitPacketSent;
+                                if (IsExitPacket(packet))
+                                {
+                                    context._exitPacketState = ExitPacketState.ExitPacketSent;
+                                }
+                            }
+                            catch (IOException e)
+                            {
+                                // Do nothing here because any exception will be caught by the async read handler
+                                CommunicationsUtilities.Trace(context._nodeId, "EXCEPTION in SendData: {0}", e);
+                            }
+                            catch (ObjectDisposedException) // This happens if a child dies unexpectedly
+                            {
+                                // Do nothing here because any exception will be caught by the async read handler
+                            }
+                        }
                     }
                 }
-                catch (IOException e)
-                {
-                    // Do nothing here because any exception will be caught by the async read handler
-                    CommunicationsUtilities.Trace(_nodeId, "EXCEPTION in SendData: {0}", e);
-                }
-                catch (ObjectDisposedException) // This happens if a child dies unexpectedly
-                {
-                    // Do nothing here because any exception will be caught by the async read handler
-                }
             }
 
             private static bool IsExitPacket(INodePacket packet)
@@ -802,7 +803,7 @@ private static bool IsExitPacket(INodePacket packet)
             /// <summary>
             /// Avoid having a BinaryWriter just to write a 4-byte int
             /// </summary>
-            private void WriteInt32(MemoryStream stream, int value)
+            private static void WriteInt32(MemoryStream stream, int value)
             {
                 stream.WriteByte((byte)value);
                 stream.WriteByte((byte)(value >> 8));
diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index a3fc16da831..5c46a8ef807 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -147,6 +147,11 @@ internal enum BuildComponentType
         /// The Build Check Manager.
         /// </summary>
         BuildCheckManagerProvider,
+
+        /// <summary>
+        /// The component which collects telemetry data in worker node and forwards it to the main node.
+        /// </summary>
+        TelemetryForwarder,
     }
 
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs b/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
index 17d2e672250..a0658f28aa0 100644
--- a/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
+++ b/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
@@ -87,6 +87,12 @@ public void Initialize(IEventSource eventSource)
                 // Telemetry events aren't part of "all" so they need to be forwarded separately
                 eventSource2.TelemetryLogged += EventSource_AnyEventRaised;
             }
+
+            if (eventSource is IEventSource5 eventSource5)
+            {
+                // Internal telemetry events aren't part of "all" so they need to be forwarded separately
+                eventSource5.WorkerNodeTelemetryLogged += EventSource_AnyEventRaised;
+            }
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 0640c2082f0..e61db2b91b2 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -18,7 +18,7 @@ internal sealed class EventSourceSink :
 #if FEATURE_APPDOMAIN
         MarshalByRefObject,
 #endif
-        IEventSource4, IBuildEventSink
+        IEventSource5, IBuildEventSink
     {
         #region Events
 
@@ -103,6 +103,11 @@ internal sealed class EventSourceSink :
         /// This event is raised to log BuildCheck events.
         /// </summary>
         internal event BuildCheckEventHandler? BuildCheckEventRaised;
+
+        /// <summary>
+        /// this event is raised to log internal telemetry data from worker nodes.
+        /// </summary>
+        public event WorkerNodeTelemetryEventHandler? WorkerNodeTelemetryLogged;
         #endregion
 
         #region Properties
@@ -263,7 +268,6 @@ public void Consume(BuildEventArgs buildEvent)
                     RaiseEvent(buildFinishedEvent, args => BuildFinished?.Invoke(null, args), BuildFinishedFollowUp);
                     break;
                 case BuildCanceledEventArgs buildCanceledEvent:
-
                     RaiseEvent(buildCanceledEvent, args => StatusEventRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
                 case CustomBuildEventArgs customBuildEvent:
@@ -284,6 +288,9 @@ public void Consume(BuildEventArgs buildEvent)
                 case BuildCheckEventArgs buildCheckEvent:
                     RaiseEvent(buildCheckEvent, args => BuildCheckEventRaised?.Invoke(null, args), RaiseAnyEvent);
                     break;
+                case WorkerNodeTelemetryEventArgs workerNodeTelemetryEvent:
+                    RaiseEvent(workerNodeTelemetryEvent, args => WorkerNodeTelemetryLogged?.Invoke(null, args), null);
+                    break;
 
                 default:
                     ErrorUtilities.ThrowInternalError("Unknown event args type.");
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index cfc289ad30e..c08622d49eb 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -10,12 +10,12 @@
 using System.Threading;
 using Microsoft.Build.BackEnd.Components.RequestBuilder;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
-using Microsoft.Build.Experimental.BuildCheck;
 
 #nullable disable
 
@@ -62,7 +62,7 @@ internal enum LoggingServiceState
         ShuttingDown,
 
         /// <summary>
-        /// The logging service completly shutdown
+        /// The logging service completely shutdown.
         /// </summary>
         Shutdown
     }
@@ -72,6 +72,11 @@ internal enum LoggingServiceState
     /// </summary>
     internal partial class LoggingService : ILoggingService, INodePacketHandler
     {
+        /// <summary>
+        /// Gets or sets a value if BuildCheck is enabled. The presence of this flag influences the logging logic.
+        /// </summary>
+        private bool _buildCheckEnabled;
+
         /// <summary>
         /// The default maximum size for the logging event queue.
         /// </summary>
@@ -248,12 +253,14 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler
         /// Event set when message is consumed from queue.
         /// </summary>
         private AutoResetEvent _dequeueEvent;
+
         /// <summary>
-        /// Event set when queue become empty.
+        /// Event set when queue become empty. 
         /// </summary>
         private ManualResetEvent _emptyQueueEvent;
+
         /// <summary>
-        /// Even set when message is added into queue.
+        /// Event set when message is added into queue.
         /// </summary>
         private AutoResetEvent _enqueueEvent;
 
@@ -871,6 +878,8 @@ public void InitializeComponent(IBuildComponentHost buildComponentHost)
                 _serviceState = LoggingServiceState.Initialized;
 
                 _buildEngineDataRouter = (buildComponentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)?.BuildEngineDataRouter;
+
+                _buildCheckEnabled = buildComponentHost.BuildParameters.IsBuildCheckEnabled;
             }
         }
 
@@ -971,58 +980,11 @@ public void PacketReceived(int node, INodePacket packet)
             LogMessagePacket loggingPacket = (LogMessagePacket)packet;
             InjectNonSerializedData(loggingPacket);
 
-            WarnOnDeprecatedCustomArgsSerialization(loggingPacket);
+            ErrorUtilities.VerifyThrow(loggingPacket.EventType != LoggingEventType.CustomEvent, "Custom event types are no longer supported. Does the sending node have a different version?");
 
             ProcessLoggingEvent(loggingPacket.NodeBuildEvent);
         }
 
-        /// <summary>
-        /// Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet.
-        /// Since BinaryFormatter is going to be deprecated, log warning so users can use new Extended*EventArgs instead of custom
-        /// EventArgs derived from existing EventArgs.
-        /// </summary>
-        private void WarnOnDeprecatedCustomArgsSerialization(LogMessagePacket loggingPacket)
-        {
-            if (loggingPacket.EventType == LoggingEventType.CustomEvent
-                && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
-            {
-                BuildEventArgs buildEvent = loggingPacket.NodeBuildEvent.Value.Value;
-                BuildEventContext buildEventContext = buildEvent?.BuildEventContext ?? BuildEventContext.Invalid;
-
-                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(
-                    out string warningCode,
-                    out string helpKeyword,
-                    "DeprecatedEventSerialization",
-                    buildEvent?.GetType().Name ?? string.Empty);
-
-                BuildWarningEventArgs warning = new(
-                    null,
-                    warningCode,
-                    BuildEventFileInfo.Empty.File,
-                    BuildEventFileInfo.Empty.Line,
-                    BuildEventFileInfo.Empty.Column,
-                    BuildEventFileInfo.Empty.EndLine,
-                    BuildEventFileInfo.Empty.EndColumn,
-                    message,
-                    helpKeyword,
-                    "MSBuild");
-
-                warning.BuildEventContext = buildEventContext;
-                if (warning.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
-                {
-                    warning.ProjectFile = buildEvent switch
-                    {
-                        BuildMessageEventArgs buildMessageEvent => buildMessageEvent.ProjectFile,
-                        BuildErrorEventArgs buildErrorEvent => buildErrorEvent.ProjectFile,
-                        BuildWarningEventArgs buildWarningEvent => buildWarningEvent.ProjectFile,
-                        _ => null,
-                    };
-                }
-
-                ProcessLoggingEvent(warning);
-            }
-        }
-
         /// <summary>
         /// Register an instantiated logger which implements the ILogger interface. This logger will be registered to a specific event
         /// source (the central logger event source) which will receive all logging messages for a given build.
@@ -1252,15 +1214,18 @@ public void LogBuildEvent(BuildEventArgs buildEvent)
 
             if ((warningEvent = buildEvent as BuildWarningEventArgs) != null && warningEvent.BuildEventContext != null && warningEvent.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
             {
-                warningEvent.ProjectFile = GetAndVerifyProjectFileFromContext(warningEvent.BuildEventContext);
+                warningEvent.ProjectFile = GetAndVerifyProjectFileFromContext(warningEvent, false);
             }
             else if ((errorEvent = buildEvent as BuildErrorEventArgs) != null && errorEvent.BuildEventContext != null && errorEvent.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
             {
-                errorEvent.ProjectFile = GetAndVerifyProjectFileFromContext(errorEvent.BuildEventContext);
+                errorEvent.ProjectFile = GetAndVerifyProjectFileFromContext(errorEvent, false);
             }
             else if ((messageEvent = buildEvent as BuildMessageEventArgs) != null && messageEvent.BuildEventContext != null && messageEvent.BuildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
             {
-                messageEvent.ProjectFile = GetAndVerifyProjectFileFromContext(messageEvent.BuildEventContext);
+                // The AssemblyLoadBuildEventArgs are logged asynchronously, and build doesn't wait for those,
+                //  so it can happen that ProjectFinishedEventArgs occured first - removing the id->file mapping from map,
+                //  but AssemblyLoadsTracker still uses the BuildEventContext for that project
+                messageEvent.ProjectFile = GetAndVerifyProjectFileFromContext(messageEvent, buildEvent is AssemblyLoadBuildEventArgs);
             }
 
             if (OnlyLogCriticalEvents)
@@ -1398,34 +1363,47 @@ private void StartLoggingEventProcessing()
             void LoggingEventProc()
             {
                 var completeAdding = _loggingEventProcessingCancellation.Token;
-                WaitHandle[] waitHandlesForNextEvent = { completeAdding.WaitHandle, _enqueueEvent };
+                WaitHandle[] waitHandlesForNextEvent = [completeAdding.WaitHandle, _enqueueEvent];
 
-                do
+                try
                 {
-                    if (_eventQueue.TryDequeue(out object ev))
-                    {
-                        LoggingEventProcessor(ev);
-                        _dequeueEvent.Set();
-                    }
-                    else
-                    {
-                        _emptyQueueEvent.Set();
+                    // Store field references locally to prevent race with cleanup
+                    var eventQueue = _eventQueue;
+                    var dequeueEvent = _dequeueEvent;
+                    var emptyQueueEvent = _emptyQueueEvent;
+                    var enqueueEvent = _enqueueEvent;
 
-                        // Wait for next event, or finish.
-                        if (!completeAdding.IsCancellationRequested && _eventQueue.IsEmpty)
+                    do
+                    {
+                        if (eventQueue.TryDequeue(out object ev))
                         {
-                            WaitHandle.WaitAny(waitHandlesForNextEvent);
+                            LoggingEventProcessor(ev);
+                            dequeueEvent?.Set();
                         }
+                        else
+                        {
+                            emptyQueueEvent?.Set();
 
-                        _emptyQueueEvent.Reset();
-                    }
-                } while (!_eventQueue.IsEmpty || !completeAdding.IsCancellationRequested);
+                            // Wait for next event, or finish.
+                            if (!completeAdding.IsCancellationRequested && eventQueue.IsEmpty)
+                            {
+                                WaitHandle.WaitAny(waitHandlesForNextEvent);
+                            }
 
-                _emptyQueueEvent.Set();
+                            emptyQueueEvent.Reset();
+                        }
+                    } while (!eventQueue.IsEmpty || !completeAdding.IsCancellationRequested);
+
+                    emptyQueueEvent.Set();
+                }
+                catch (ObjectDisposedException)
+                {
+                    // Events/queue were disposed during shutdown, exit processing
+                    return;
+                }
             }
         }
 
-
         /// <summary>
         /// Clean resources used for logging event processing queue.
         /// </summary>
@@ -1438,9 +1416,11 @@ private void CleanLoggingEventProcessing()
             _loggingEventProcessingCancellation?.Dispose();
 
             _eventQueue = null;
+
             _dequeueEvent = null;
             _enqueueEvent = null;
             _emptyQueueEvent = null;
+
             _loggingEventProcessingCancellation = null;
             _loggingEventProcessingThread = null;
         }
@@ -1927,14 +1907,17 @@ private void TryRaiseProjectFinishedEvent(BuildEventArgs args)
         /// <summary>
         /// Get the project name from a context ID. Throw an exception if it's not found.
         /// </summary>
-        private string GetAndVerifyProjectFileFromContext(BuildEventContext context)
+        private string GetAndVerifyProjectFileFromContext(BuildEventArgs eventArgs, bool allowCacheMiss)
         {
+            BuildEventContext context = eventArgs.BuildEventContext!;
             _projectFileMap.TryGetValue(context.ProjectContextId, out string projectFile);
 
             // PERF: Not using VerifyThrow to avoid boxing an int in the non-error case.
-            if (projectFile == null)
+            if (projectFile == null && !allowCacheMiss)
             {
-                ErrorUtilities.ThrowInternalError("ContextID {0} should have been in the ID-to-project file mapping but wasn't!", context.ProjectContextId);
+                ErrorUtilities.ThrowInternalError(
+                    "ContextID {0} should have been in the ID-to-project file mapping but wasn't! Encountered during logging message: '{1}'",
+                    context.ProjectContextId, eventArgs.Message);
             }
 
             return projectFile;
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index bbfd82c4fe3..31c9f55eeb0 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -615,10 +615,15 @@ public void LogProjectFinished(BuildEventContext projectBuildEventContext, strin
             buildEvent.BuildEventContext = projectBuildEventContext;
             ProcessLoggingEvent(buildEvent);
 
-            // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
-            if (!_projectFileMap.TryRemove(projectBuildEventContext.ProjectContextId, out _))
+            // BuildCheck can still emit some LogBuildEvent(s) after ProjectFinishedEventArgs was reported.
+            // Due to GetAndVerifyProjectFileFromContext validation, these checks break the build.
+            if (!_buildCheckEnabled)
             {
-                ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should be in the ID-to-file mapping!", projectBuildEventContext.ProjectContextId, projectFile);
+                // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
+                if (!_projectFileMap.TryRemove(projectBuildEventContext.ProjectContextId, out _))
+                {
+                    ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should be in the ID-to-file mapping!", projectBuildEventContext.ProjectContextId, projectFile);
+                }
             }
         }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
index 02ca6a1dab8..5bd3a49c331 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
@@ -25,6 +25,8 @@ internal class PropertyGroupIntrinsicTask : IntrinsicTask
         /// </summary>
         private ProjectPropertyGroupTaskInstance _taskInstance;
 
+        private readonly PropertyTrackingSetting _propertyTrackingSettings;
+
         /// <summary>
         /// Create a new PropertyGroup task.
         /// </summary>
@@ -36,6 +38,7 @@ public PropertyGroupIntrinsicTask(ProjectPropertyGroupTaskInstance taskInstance,
             : base(loggingContext, projectInstance, logTaskInputs)
         {
             _taskInstance = taskInstance;
+            _propertyTrackingSettings = (PropertyTrackingSetting)Traits.Instance.LogPropertyTracking;
         }
 
         /// <summary>
@@ -85,6 +88,14 @@ internal override void ExecuteTask(Lookup lookup)
                             string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(property.Value, ExpanderOptions.ExpandAll, property.Location);
                             bucket.Expander.PropertiesUseTracker.CheckPreexistingUndefinedUsage(property, evaluatedValue, LoggingContext);
 
+                            PropertyTrackingUtils.LogPropertyAssignment(
+                                _propertyTrackingSettings,
+                                property.Name,
+                                evaluatedValue,
+                                property.Location,
+                                Project.GetProperty(property.Name)?.EvaluatedValue ?? null,
+                                LoggingContext);
+
                             if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents)
                             {
                                 LoggingContext.LogComment(MessageImportance.Low, "PropertyGroupLogMessage", property.Name, evaluatedValue);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index b1c05600fae..e53b39a032f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -21,6 +21,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
+using Microsoft.Build.TelemetryInfra;
 using NodeLoggingContext = Microsoft.Build.BackEnd.Logging.NodeLoggingContext;
 using ProjectLoggingContext = Microsoft.Build.BackEnd.Logging.ProjectLoggingContext;
 
@@ -1208,6 +1209,8 @@ private async Task<BuildResult> BuildProject()
                 BuildResult result = await _targetBuilder.BuildTargets(_projectLoggingContext, _requestEntry, this,
                     allTargets, _requestEntry.RequestConfiguration.BaseLookup, _cancellationTokenSource.Token);
 
+                UpdateStatisticsPostBuild();
+
                 result = _requestEntry.Request.ProxyTargets == null
                     ? result
                     : CopyTargetResultsFromProxyTargetsToRealTargets(result);
@@ -1257,6 +1260,86 @@ BuildResult CopyTargetResultsFromProxyTargetsToRealTargets(BuildResult resultFro
             }
         }
 
+        private void UpdateStatisticsPostBuild()
+        {
+            ITelemetryForwarder telemetryForwarder =
+                ((TelemetryForwarderProvider)_componentHost.GetComponent(BuildComponentType.TelemetryForwarder))
+                .Instance;
+
+            if (!telemetryForwarder.IsTelemetryCollected)
+            {
+                return;
+            }
+
+            IResultsCache resultsCache = (IResultsCache)_componentHost.GetComponent(BuildComponentType.ResultsCache);
+            // The TargetBuilder filters out results for targets not explicitly requested before returning the result.
+            // Hence we need to fetch the original result from the cache - to get the data for all executed targets.
+            BuildResult unfilteredResult = resultsCache.GetResultsForConfiguration(_requestEntry.Request.ConfigurationId);
+
+            foreach (var projectTargetInstance in _requestEntry.RequestConfiguration.Project.Targets)
+            {
+                bool wasExecuted =
+                    unfilteredResult.ResultsByTarget.TryGetValue(projectTargetInstance.Key, out TargetResult targetResult) &&
+                    // We need to match on location of target as well - as multiple targets with same name can be defined.
+                    // E.g. _SourceLinkHasSingleProvider can be brought explicitly via nuget (Microsoft.SourceLink.GitHub) as well as sdk
+                    projectTargetInstance.Value.Location.Equals(targetResult.TargetLocation);
+
+                bool isFromNuget, isMetaprojTarget, isCustom;
+
+                if (IsMetaprojTargetPath(projectTargetInstance.Value.FullPath))
+                {
+                    isMetaprojTarget = true;
+                    isFromNuget = false;
+                    isCustom = false;
+                }
+                else
+                {
+                    isMetaprojTarget = false;
+                    isFromNuget = FileClassifier.Shared.IsInNugetCache(projectTargetInstance.Value.FullPath);
+                    isCustom = !FileClassifier.Shared.IsBuiltInLogic(projectTargetInstance.Value.FullPath) ||
+                               // add the isFromNuget to condition - to prevent double checking of nonnuget package
+                               (isFromNuget && FileClassifier.Shared.IsMicrosoftPackageInNugetCache(projectTargetInstance.Value.FullPath));
+                }
+
+                telemetryForwarder.AddTarget(
+                    projectTargetInstance.Key,
+                    // would we want to distinguish targets that were executed only during this execution - we'd need
+                    //  to remember target names from ResultsByTarget from before execution
+                    wasExecuted,
+                    isCustom,
+                    isMetaprojTarget,
+                    isFromNuget);
+            }
+
+            TaskRegistry taskReg = _requestEntry.RequestConfiguration.Project.TaskRegistry;
+            CollectTasksStats(taskReg);
+
+            void CollectTasksStats(TaskRegistry taskRegistry)
+            {
+                if (taskRegistry == null)
+                {
+                    return;
+                }
+
+                foreach (TaskRegistry.RegisteredTaskRecord registeredTaskRecord in taskRegistry.TaskRegistrations.Values.SelectMany(record => record))
+                {
+                    telemetryForwarder.AddTask(registeredTaskRecord.TaskIdentity.Name,
+                        registeredTaskRecord.Statistics.ExecutedTime,
+                        registeredTaskRecord.Statistics.ExecutedCount,
+                        registeredTaskRecord.Statistics.TotalMemoryConsumption,
+                        registeredTaskRecord.ComputeIfCustom(),
+                        registeredTaskRecord.IsFromNugetCache);
+
+                    registeredTaskRecord.Statistics.Reset();
+                }
+
+                taskRegistry.Toolset?.InspectInternalTaskRegistry(CollectTasksStats);
+            }
+        }
+
+        private static bool IsMetaprojTargetPath(string targetPath)
+            => targetPath.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase);
+
         /// <summary>
         /// Saves the current operating environment.
         /// </summary>
@@ -1437,7 +1520,9 @@ private static ISet<string> ParseWarningCodes(string warnings)
                 return null;
             }
 
-            return new HashSet<string>(ExpressionShredder.SplitSemiColonSeparatedList(warnings), StringComparer.OrdinalIgnoreCase);
+            return new HashSet<string>(ExpressionShredder.SplitSemiColonSeparatedList(warnings)
+            .SelectMany(w => w.Split([','], StringSplitOptions.RemoveEmptyEntries))
+            .Select(w => w.Trim()), StringComparer.OrdinalIgnoreCase);
         }
 
         private sealed class DedicatedThreadsTaskScheduler : TaskScheduler
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index 7cd08affeb2..aab4fb6d344 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -90,6 +90,11 @@ internal class TargetBuilder : ITargetBuilder, ITargetBuilderCallback, IBuildCom
         /// </summary>
         private bool _legacyCallTargetContinueOnError;
 
+        /// <summary>
+        /// Flag indicating whether telemetry is requested.
+        /// </summary>
+        private bool _isTelemetryRequested;
+
         /// <summary>
         /// Builds the specified targets.
         /// </summary>
@@ -214,6 +219,7 @@ public void InitializeComponent(IBuildComponentHost host)
         {
             ErrorUtilities.VerifyThrowArgumentNull(host);
             _componentHost = host;
+            _isTelemetryRequested = host.BuildParameters.IsTelemetryEnabled;
         }
 
         /// <summary>
@@ -518,6 +524,11 @@ await PushTargets(errorTargets, currentTargetEntry, currentTargetEntry.Lookup, t
                         // CallTarget, make sure we don't contribute this failure to the overall success of the build.
                         targetResult.TargetFailureDoesntCauseBuildFailure = _legacyCallTargetContinueOnError;
 
+                        if (_isTelemetryRequested)
+                        {
+                            targetResult.TargetLocation = currentTargetEntry.Target.Location;
+                        }
+
                         // This target is no longer actively building.
                         _requestEntry.RequestConfiguration.ActivelyBuildingTargets.Remove(currentTargetEntry.Name);
 
@@ -546,9 +557,8 @@ await PushTargets(errorTargets, currentTargetEntry, currentTargetEntry.Lookup, t
         /// <returns>True to skip the target, false otherwise.</returns>
         private bool CheckSkipTarget(ref bool stopProcessingStack, TargetEntry currentTargetEntry)
         {
-            if (_buildResult.HasResultsForTarget(currentTargetEntry.Name))
+            if (_buildResult.TryGetResultsForTarget(currentTargetEntry.Name, out TargetResult targetResult))
             {
-                TargetResult targetResult = _buildResult[currentTargetEntry.Name] as TargetResult;
                 ErrorUtilities.VerifyThrowInternalNull(targetResult, "targetResult");
 
                 if (targetResult.ResultCode != TargetResultCode.Skipped)
@@ -665,12 +675,9 @@ private async Task<bool> PushTargets(IList<TargetSpecification> targets, TargetE
                 {
                     // Don't build any Before or After targets for which we already have results.  Unlike other targets,
                     // we don't explicitly log a skipped-with-results message because it is not interesting.
-                    if (_buildResult.HasResultsForTarget(targetSpecification.TargetName))
+                    if (_buildResult.TryGetResultsForTarget(targetSpecification.TargetName, out TargetResult targetResult) && targetResult.ResultCode != TargetResultCode.Skipped)
                     {
-                        if (_buildResult[targetSpecification.TargetName].ResultCode != TargetResultCode.Skipped)
-                        {
-                            continue;
-                        }
+                        continue;
                     }
                 }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index c45130602a1..3a406115fce 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -428,6 +428,9 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                     {
                         TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance, taskAssemblyLocation);
                         MSBuildEventSource.Log.ExecuteTaskStart(_taskNode?.Name, taskLoggingContext.BuildEventContext.TaskId);
+                        // Can be condition with _componentHost.BuildParameters.IsTelemetryEnabled) - but it's a cheap call
+                        taskFactoryWrapper?.Statistics?.ExecutionStarted();
+
                         _buildRequestEntry.Request.CurrentTaskContext = taskLoggingContext.BuildEventContext;
 
                         try
@@ -476,6 +479,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
 
                             // Flag the completion of the task.
                             taskLoggingContext.LogTaskBatchFinished(_projectFullPath, taskResult.ResultCode == WorkUnitResultCode.Success || taskResult.ResultCode == WorkUnitResultCode.Skipped);
+                            taskFactoryWrapper?.Statistics?.ExecutionStopped();
 
                             if (taskResult.ResultCode == WorkUnitResultCode.Failed && _continueOnError == ContinueOnError.WarnAndContinue)
                             {
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 74adf85158f..0e8b74863be 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -1019,11 +1019,8 @@ private bool IsTraversalRequest(BuildRequest request)
         private void AssignUnscheduledRequestsWithConfigurationCountLevelling(List<ScheduleResponse> responses, HashSet<int> idleNodes)
         {
             // Assign requests but try to keep the same number of configurations on each node
-            List<int> nodesByConfigurationCountAscending = new List<int>(_availableNodes.Keys);
-            nodesByConfigurationCountAscending.Sort(delegate (int left, int right)
-            {
-                return Comparer<int>.Default.Compare(_schedulingData.GetConfigurationsCountByNode(left, true /* excludeTraversals */, _configCache), _schedulingData.GetConfigurationsCountByNode(right, true /* excludeTraversals */, _configCache));
-            });
+            // Use OrderBy to sort since it will cache the lookup in configCache which. This reduces the number of times we have to acquire the lock.
+            IEnumerable<int> nodesByConfigurationCountAscending = _availableNodes.Keys.OrderBy(x => _schedulingData.GetConfigurationsCountByNode(x, excludeTraversals: true, _configCache));
 
             // Assign projects to nodes, preferring to assign work to nodes with the fewest configurations first.
             foreach (int nodeId in nodesByConfigurationCountAscending)
@@ -2569,7 +2566,7 @@ private void TraceScheduler(string format, params object[] stuff)
                 {
                     FileUtilities.EnsureDirectoryExists(_debugDumpPath);
 
-                    using StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerTrace_{0}.txt"), Process.GetCurrentProcess().Id), append: true);
+                    using StreamWriter file = FileUtilities.OpenWrite(string.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerTrace_{0}.txt"), EnvironmentUtilities.CurrentProcessId), append: true);
                     file.Write("{0}({1})-{2}: ", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, _schedulingData.EventTime.Ticks);
                     file.WriteLine(format, stuff);
                     file.Flush();
@@ -2593,7 +2590,7 @@ private void DumpSchedulerState()
                     try
                     {
                         FileUtilities.EnsureDirectoryExists(_debugDumpPath);
-                        using StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerState_{0}.txt"), Process.GetCurrentProcess().Id), append: true);
+                        using StreamWriter file = FileUtilities.OpenWrite(string.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerState_{0}.txt"), EnvironmentUtilities.CurrentProcessId), append: true);
 
                         file.WriteLine("Scheduler state at timestamp {0}:", _schedulingData.EventTime.Ticks);
                         file.WriteLine("------------------------------------------------");
@@ -2707,7 +2704,7 @@ private void DumpConfigurations()
                 {
                     try
                     {
-                        using StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerState_{0}.txt"), Process.GetCurrentProcess().Id), append: true);
+                        using StreamWriter file = FileUtilities.OpenWrite(string.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerState_{0}.txt"), EnvironmentUtilities.CurrentProcessId), append: true);
 
                         file.WriteLine("Configurations used during this build");
                         file.WriteLine("-------------------------------------");
@@ -2747,7 +2744,7 @@ private void DumpRequests()
                 {
                     try
                     {
-                        using StreamWriter file = FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerState_{0}.txt"), Process.GetCurrentProcess().Id), append: true);
+                        using StreamWriter file = FileUtilities.OpenWrite(string.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerState_{0}.txt"), EnvironmentUtilities.CurrentProcessId), append: true);
 
                         file.WriteLine("Requests used during the build:");
                         file.WriteLine("-------------------------------");
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 5148f89be9f..f092add506b 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -583,27 +583,27 @@ private void SendPacket(INodePacket packet)
         {
             if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
             {
-#if RUNTIME_TYPE_NETCORE
                 if (packet is LogMessagePacketBase logMessage
-                    && logMessage.EventType == LoggingEventType.CustomEvent
-                    && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
+                    && logMessage.EventType == LoggingEventType.CustomEvent)
                 {
                     BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;
 
                     // Serializing unknown CustomEvent which has to use unsecure BinaryFormatter by TranslateDotNet<T>
                     // Since BinaryFormatter is deprecated in dotnet 8+, log error so users discover root cause easier
                     // then by reading CommTrace where it would be otherwise logged as critical infra error.
-                    _loggingService.LogError(_loggingContext?.BuildEventContext ?? BuildEventContext.Invalid, null, BuildEventFileInfo.Empty,
-                            "DeprecatedEventSerialization",
-                            buildEvent?.GetType().Name ?? string.Empty);
+#if RUNTIME_TYPE_NETCORE
+                    _loggingService.LogError(
+#else
+                    _loggingService.LogWarning(
+#endif
+                        _loggingContext?.BuildEventContext ?? BuildEventContext.Invalid, null, BuildEventFileInfo.Empty,
+                        "DeprecatedEventSerialization",
+                        buildEvent?.GetType().Name ?? string.Empty);
                 }
                 else
                 {
                     _nodeEndpoint.SendData(packet);
                 }
-#else
-                _nodeEndpoint.SendData(packet);
-#endif
             }
         }
 
@@ -847,7 +847,8 @@ private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)
             _shutdownReason = buildComplete.PrepareForReuse ? NodeEngineShutdownReason.BuildCompleteReuse : NodeEngineShutdownReason.BuildComplete;
             if (_shutdownReason == NodeEngineShutdownReason.BuildCompleteReuse)
             {
-                ProcessPriorityClass priorityClass = Process.GetCurrentProcess().PriorityClass;
+                using Process currentProcess = Process.GetCurrentProcess();
+                ProcessPriorityClass priorityClass = currentProcess.PriorityClass;
                 if (priorityClass != ProcessPriorityClass.Normal && priorityClass != ProcessPriorityClass.BelowNormal)
                 {
                     // This isn't a priority class known by MSBuild. We should avoid connecting to this node.
@@ -860,7 +861,7 @@ private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)
                     {
                         if (!lowPriority || NativeMethodsShared.IsWindows)
                         {
-                            Process.GetCurrentProcess().PriorityClass = lowPriority ? ProcessPriorityClass.Normal : ProcessPriorityClass.BelowNormal;
+                            currentProcess.PriorityClass = lowPriority ? ProcessPriorityClass.Normal : ProcessPriorityClass.BelowNormal;
                         }
                         else
                         {
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index ab17e3b7ce1..bda79d588cd 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -381,7 +381,7 @@ private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)
                 BuildTelemetry buildTelemetry = KnownTelemetry.PartialBuildTelemetry ??= new BuildTelemetry();
 
                 buildTelemetry.StartAt = command.PartialBuildTelemetry.StartedAt;
-                buildTelemetry.InitialServerState = command.PartialBuildTelemetry.InitialServerState;
+                buildTelemetry.InitialMSBuildServerState = command.PartialBuildTelemetry.InitialServerState;
                 buildTelemetry.ServerFallbackReason = command.PartialBuildTelemetry.ServerFallbackReason;
             }
 
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 7108a74cca6..f90f99d14d3 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -299,7 +299,11 @@ public bool IsTraversal
             {
                 if (!_isTraversalProject.HasValue)
                 {
-                    if (String.Equals(Path.GetFileName(ProjectFullPath), "dirs.proj", StringComparison.OrdinalIgnoreCase))
+#if NET471_OR_GREATER
+                    if (MemoryExtensions.Equals(Microsoft.IO.Path.GetFileName(ProjectFullPath.AsSpan()), "dirs.proj".AsSpan(), StringComparison.OrdinalIgnoreCase))
+#else
+                    if (MemoryExtensions.Equals(Path.GetFileName(ProjectFullPath.AsSpan()), "dirs.proj", StringComparison.OrdinalIgnoreCase))
+#endif
                     {
                         // dirs.proj are assumed to be traversals
                         _isTraversalProject = true;
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index fd780f44a6d..f433ffc25ad 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Framework;
+using System.Diagnostics.CodeAnalysis;
 
 namespace Microsoft.Build.Execution
 {
@@ -601,6 +602,16 @@ public bool HasResultsForTarget(string target)
             return _resultsByTarget?.ContainsKey(target) ?? false;
         }
 
+        public bool TryGetResultsForTarget(string target, [NotNullWhen(true)] out TargetResult? value)
+        {
+            if (_resultsByTarget is null)
+            {
+                value = default;
+                return false;
+            }
+
+            return _resultsByTarget.TryGetValue(target, out value);
+        }
         #region INodePacket Members
 
         /// <summary>
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index 17b187d1d3a..0a05628bff6 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -190,6 +190,13 @@ internal bool AfterTargetsHaveFailed
             set => _afterTargetsHaveFailed = value;
         }
 
+        /// <summary>
+        /// The defining location of the target for which this is a result.
+        /// This is not intended to be remoted via node-2-node remoting - it's intended only for in-node telemetry.
+        /// Warning!: This data is not guaranteed to be populated when Telemetry is not being collected (e.g. this is "sampled out")
+        /// </summary>
+        internal IElementLocation TargetLocation { get; set; }
+
         #region INodePacketTranslatable Members
 
         /// <summary>
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 0e4c160336f..2f5a26be1fc 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -156,6 +156,8 @@ internal class TaskExecutionHost : IDisposable
         /// </summary>
         private readonly Dictionary<string, TaskFactoryWrapper> _intrinsicTasks = new Dictionary<string, TaskFactoryWrapper>(StringComparer.OrdinalIgnoreCase);
 
+        private readonly PropertyTrackingSetting _propertyTrackingSettings;
+
         /// <summary>
         /// Constructor
         /// </summary>
@@ -172,6 +174,8 @@ internal TaskExecutionHost(IBuildComponentHost host)
             {
                 LogTaskInputs = Traits.Instance.EscapeHatches.LogTaskInputs;
             }
+
+            _propertyTrackingSettings = (PropertyTrackingSetting)Traits.Instance.LogPropertyTracking;
         }
 
         /// <summary>
@@ -1223,15 +1227,18 @@ private void EnsureParameterInitialized(TaskPropertyInfo parameter, Lookup looku
 
             string taskAndParameterName = _taskName + "_" + parameter.Name;
             string key = "DisableLogTaskParameter_" + taskAndParameterName;
-            string metadataKey = "DisableLogTaskParameterItemMetadata_" + taskAndParameterName;
 
             if (string.Equals(lookup.GetProperty(key)?.EvaluatedValue, "true", StringComparison.OrdinalIgnoreCase))
             {
                 parameter.Log = false;
             }
-            else if (string.Equals(lookup.GetProperty(metadataKey)?.EvaluatedValue, "true", StringComparison.OrdinalIgnoreCase))
+            else
             {
-                parameter.LogItemMetadata = false;
+                string metadataKey = "DisableLogTaskParameterItemMetadata_" + taskAndParameterName;
+                if (string.Equals(lookup.GetProperty(metadataKey)?.EvaluatedValue, "true", StringComparison.OrdinalIgnoreCase))
+                {
+                    parameter.LogItemMetadata = false;
+                }
             }
         }
 
@@ -1582,6 +1589,14 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                             }
                         }
 
+                        PropertyTrackingUtils.LogPropertyAssignment(
+                            _propertyTrackingSettings,
+                            outputTargetName,
+                            outputString,
+                            parameterLocation,
+                            _projectInstance.GetProperty(outputTargetName)?.EvaluatedValue ?? null,
+                            _taskLoggingContext);
+
                         _batchBucket.Lookup.SetProperty(ProjectPropertyInstance.Create(outputTargetName, outputString, parameterLocation, _projectInstance.IsImmutable));
                     }
                 }
diff --git a/src/Build/BuildCheck/Checks/TargetFrameworkConfusionCheck.cs b/src/Build/BuildCheck/Checks/TargetFrameworkConfusionCheck.cs
index 11918a93c95..2c3db3512ad 100644
--- a/src/Build/BuildCheck/Checks/TargetFrameworkConfusionCheck.cs
+++ b/src/Build/BuildCheck/Checks/TargetFrameworkConfusionCheck.cs
@@ -52,7 +52,7 @@ private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedProperties
             // {0} specifies 'TargetFrameworks' property '{1}' and 'TargetFramework' property '{2}'
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
-                // Populating precise location tracked via https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=58661732
+                // Populating precise location tracked via https://github.com/dotnet/msbuild/issues/10383
                 ElementLocation.EmptyLocation,
                 Path.GetFileName(context.Data.ProjectFilePath),
                 frameworks,
diff --git a/src/Build/BuildCheck/Checks/TargetFrameworkUnexpectedCheck.cs b/src/Build/BuildCheck/Checks/TargetFrameworkUnexpectedCheck.cs
new file mode 100644
index 00000000000..2636b151d54
--- /dev/null
+++ b/src/Build/BuildCheck/Checks/TargetFrameworkUnexpectedCheck.cs
@@ -0,0 +1,105 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
+internal class TargetFrameworkUnexpectedCheck : Check
+{
+    private const string RuleId = "BC0108";
+    public static CheckRule SupportedRule = new CheckRule(RuleId, "TargetFrameworkUnexpected",
+        ResourceUtilities.GetResourceString("BuildCheck_BC0108_Title")!,
+        ResourceUtilities.GetResourceString("BuildCheck_BC0108_MessageFmt")!,
+        new CheckConfiguration() { RuleId = RuleId, Severity = CheckResultSeverity.Warning });
+
+    public override string FriendlyName => "MSBuild.TargetFrameworkUnexpected";
+
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
+
+    public override void Initialize(ConfigurationContext configurationContext)
+    {
+        /* This is it - no custom configuration */
+    }
+
+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+    {
+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+        registrationContext.RegisterEvaluatedItemsAction(EvaluatedItemsAction);
+    }
+
+    internal override bool IsBuiltIn => true;
+
+    private readonly HashSet<string> _projectsSeen = new(MSBuildNameIgnoreCaseComparer.Default);
+    private string? _tfm;
+
+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
+    {
+        // Resetting state for the next project.
+        _tfm = null;
+
+        // See CopyAlwaysCheck.EvaluatedPropertiesAction for explanation. 
+        if (_projectsSeen.Contains(context.Data.ProjectFilePath))
+        {
+            return;
+        }
+
+        string? frameworks = null;
+        string? framework = null;
+        // TargetFramework(s) is specified
+        if ((context.Data.EvaluatedProperties.TryGetValue(PropertyNames.TargetFrameworks, out frameworks) ||
+             context.Data.EvaluatedProperties.TryGetValue(PropertyNames.TargetFramework, out framework)) &&
+            !string.IsNullOrEmpty(framework ?? frameworks)
+            &&
+            !IsSdkStyleProject(context.Data.EvaluatedProperties) && !IsCppCliProject(context.Data.EvaluatedProperties)
+            )
+        {
+            // Indicating that to the EvaluatedItemsAction, that if this project is recognized as manged - we should emit diagnostics.
+            _tfm = framework ?? frameworks;
+        }
+
+        bool IsSdkStyleProject(IReadOnlyDictionary<string, string> evaluatedProperties)
+            => evaluatedProperties.TryGetValue(PropertyNames.UsingMicrosoftNETSdk, out string? usingSdkStr) &&
+               usingSdkStr.IsMSBuildTrueString();
+
+        bool IsCppCliProject(IReadOnlyDictionary<string, string> evaluatedProperties)
+            => evaluatedProperties.TryGetValue("CLRSupport", out string? clrSupportStr) &&
+               MSBuildNameIgnoreCaseComparer.Default.Equals(clrSupportStr, "NetCore");
+    }
+
+    private void EvaluatedItemsAction(BuildCheckDataContext<EvaluatedItemsCheckData> context)
+    {
+        // Neither TargetFrameworks nor TargetFramework is specified, or the project is not Sdk-style nor C++/CLI project.
+        if (_tfm == null)
+        {
+            return;
+        }
+
+        // We want to avoid repeated checking of a same project (as it might be evaluated multiple times)
+        //  for this reason we use a hashset with already seen projects.
+        if (!_projectsSeen.Add(context.Data.ProjectFilePath))
+        {
+            return;
+        }
+
+        foreach (ItemData itemData in context.Data.EnumerateItemsOfType(ItemNames.ProjectCapability))
+        {
+            if (MSBuildNameIgnoreCaseComparer.Default.Equals(itemData.EvaluatedInclude, ItemMetadataNames.managed))
+            {
+                // {0} specifies 'TargetFramework(s)' property value
+                context.ReportResult(BuildCheckResult.Create(
+                    SupportedRule,
+                    // Populating precise location tracked via https://github.com/dotnet/msbuild/issues/10383
+                    ElementLocation.EmptyLocation,
+                    Path.GetFileName(context.Data.ProjectFilePath),
+                    _tfm));
+
+                break;
+            }
+        }
+    }
+}
diff --git a/src/Build/BuildCheck/Checks/UntrustedLocationCheck.cs b/src/Build/BuildCheck/Checks/UntrustedLocationCheck.cs
new file mode 100644
index 00000000000..5dcf2c75ea9
--- /dev/null
+++ b/src/Build/BuildCheck/Checks/UntrustedLocationCheck.cs
@@ -0,0 +1,97 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Runtime.InteropServices;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
+internal sealed class UntrustedLocationCheck : Check
+{
+    public static CheckRule SupportedRule = new CheckRule(
+        "BC0301",
+        "UntrustedLocation",
+        ResourceUtilities.GetResourceString("BuildCheck_BC0301_Title")!,
+        ResourceUtilities.GetResourceString("BuildCheck_BC0301_MessageFmt")!,
+        new CheckConfiguration() { Severity = CheckResultSeverity.Error });
+
+    public override string FriendlyName => "DotUtils.UntrustedLocationCheck";
+
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
+
+    public override void Initialize(ConfigurationContext configurationContext)
+    {
+        checkedProjects.Clear();
+    }
+
+    internal override bool IsBuiltIn => true;
+
+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+    {
+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+    }
+
+    private HashSet<string> checkedProjects = new HashSet<string>();
+
+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
+    {
+        if (checkedProjects.Add(context.Data.ProjectFilePath) &&
+            context.Data.ProjectFileDirectory.StartsWith(PathsHelper.Downloads, Shared.FileUtilities.PathComparison))
+        {
+            context.ReportResult(BuildCheckResult.Create(
+                SupportedRule,
+                ElementLocation.EmptyLocation,
+                context.Data.ProjectFileDirectory,
+                context.Data.ProjectFilePath.Substring(context.Data.ProjectFileDirectory.Length + 1)));
+        }
+    }
+
+    private static class PathsHelper
+    {
+        public static readonly string Downloads = GetDownloadsPath();
+
+        /// <summary>
+        /// Returns the current Downloads location. Makes sure the path doesn't end with directory separator
+        ///   (to prevent false negatives during matching)
+        /// </summary>
+        private static string GetDownloadsPath()
+        {
+            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            {
+                // Unsupported on pre-vista
+                if (Environment.OSVersion.Version.Major >= 6)
+                {
+                    try
+                    {
+                        // based on doc (https://learn.microsoft.com/en-us/windows/win32/api/shlobj_core/nf-shlobj_core-shgetknownfolderpath)
+                        //  - a final slash is not added
+                        return SHGetKnownFolderPath(new Guid("374DE290-123F-4565-9164-39C4925E467B"), 0, IntPtr.Zero);
+                    }
+                    catch
+                    {
+                        // ignored
+                    }
+                }
+            }
+            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
+            {
+                string? locationFromEnv = Environment.GetEnvironmentVariable("XDG_DOWNLOAD_DIR");
+                if (locationFromEnv != null && Directory.Exists(locationFromEnv))
+                {
+                    return locationFromEnv.TrimEnd(['\\','/']);
+                }
+            }
+
+            return Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), "Downloads");
+        }
+
+        [DllImport("shell32",
+            CharSet = CharSet.Unicode, ExactSpelling = true, PreserveSig = false)]
+        private static extern string SHGetKnownFolderPath(
+            [MarshalAs(UnmanagedType.LPStruct)] Guid rfid, uint dwFlags,
+            IntPtr hToken);
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index cc9ee125ac1..7100095f1b4 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -65,14 +65,14 @@ internal sealed class BuildCheckManager : IBuildCheckManager, IBuildEngineDataRo
         private readonly TracingReporter _tracingReporter = new TracingReporter();
         private readonly IConfigurationProvider _configurationProvider = new ConfigurationProvider();
         private readonly BuildCheckCentralContext _buildCheckCentralContext;
-        private readonly List<CheckFactoryContext> _checkRegistry;
+        private readonly ConcurrentBag<CheckFactoryContext> _checkRegistry;
         private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
         private readonly BuildEventsProcessor _buildEventsProcessor;
         private readonly IBuildCheckAcquisitionModule _acquisitionModule;
 
         internal BuildCheckManager()
         {
-            _checkRegistry = new List<CheckFactoryContext>();
+            _checkRegistry = new ConcurrentBag<CheckFactoryContext>();
             _acquisitionModule = new BuildCheckAcquisitionModule();
             _buildCheckCentralContext = new(_configurationProvider, RemoveChecksAfterExecutedActions);
             _buildEventsProcessor = new(_buildCheckCentralContext);
@@ -152,6 +152,8 @@ internal readonly record struct BuiltInCheckFactory(
                 new BuiltInCheckFactory([NoEnvironmentVariablePropertyCheck.SupportedRule.Id], NoEnvironmentVariablePropertyCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<NoEnvironmentVariablePropertyCheck>),
                 new BuiltInCheckFactory([EmbeddedResourceCheck.SupportedRule.Id], EmbeddedResourceCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<EmbeddedResourceCheck>),
                 new BuiltInCheckFactory([TargetFrameworkConfusionCheck.SupportedRule.Id], TargetFrameworkConfusionCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<TargetFrameworkConfusionCheck>),
+                new BuiltInCheckFactory([TargetFrameworkUnexpectedCheck.SupportedRule.Id], TargetFrameworkUnexpectedCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<TargetFrameworkUnexpectedCheck>),
+                new BuiltInCheckFactory([UntrustedLocationCheck.SupportedRule.Id], UntrustedLocationCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<UntrustedLocationCheck>),
             ],
 
             // BuildCheckDataSource.Execution
@@ -169,15 +171,23 @@ internal readonly record struct BuiltInCheckFactory(
 
         private void RegisterBuiltInChecks(BuildCheckDataSource buildCheckDataSource)
         {
-            _checkRegistry.AddRange(
-                s_builtInFactoriesPerDataSource[(int)buildCheckDataSource]
-                    .Select(v => new CheckFactoryContext(v.Factory, v.RuleIds, v.DefaultEnablement)));
+            foreach (BuiltInCheckFactory item in s_builtInFactoriesPerDataSource[(int)buildCheckDataSource])
+            {
+                _checkRegistry.Add(new CheckFactoryContext(
+                    item.Factory,
+                    item.RuleIds,
+                    item.DefaultEnablement));
+            }
 
             if (s_testFactoriesPerDataSource is not null)
             {
-                _checkRegistry.AddRange(
-                    s_testFactoriesPerDataSource[(int)buildCheckDataSource]
-                        .Select(v => new CheckFactoryContext(v.Factory, v.RuleIds, v.DefaultEnablement)));
+                foreach (BuiltInCheckFactory item in s_testFactoriesPerDataSource[(int)buildCheckDataSource])
+                {
+                    _checkRegistry.Add(new CheckFactoryContext(
+                        item.Factory,
+                        item.RuleIds,
+                        item.DefaultEnablement));
+                }
             }
         }
 
@@ -360,7 +370,8 @@ public void RemoveChecksAfterExecutedActions(List<CheckWrapper>? checksToRemove,
             {
                 foreach (CheckWrapper check in checksToRemove)
                 {
-                    var checkFactory = _checkRegistry.Find(c => c.MaterializedCheck == check);
+                    var checkFactory = _checkRegistry.FirstOrDefault(c => c.MaterializedCheck == check);
+
                     if (checkFactory is not null)
                     {
                         checkContext.DispatchAsCommentFromText(MessageImportance.High, $"Dismounting check '{check.Check.FriendlyName}'. The check has thrown an unhandled exception while executing registered actions.");
@@ -369,7 +380,9 @@ public void RemoveChecksAfterExecutedActions(List<CheckWrapper>? checksToRemove,
                 }
             }
 
-            foreach (var throttledCheck in _checkRegistry.FindAll(c => c.MaterializedCheck?.IsThrottled ?? false))
+            var throttledChecks = _checkRegistry.Where(c => c.MaterializedCheck?.IsThrottled ?? false).ToList();
+
+            foreach (var throttledCheck in throttledChecks)
             {
                 checkContext.DispatchAsCommentFromText(MessageImportance.Normal, $"Dismounting check '{throttledCheck.FriendlyName}'. The check has exceeded the maximum number of results allowed. Any additional results will not be displayed.");
                 RemoveCheck(throttledCheck);
@@ -378,13 +391,33 @@ public void RemoveChecksAfterExecutedActions(List<CheckWrapper>? checksToRemove,
 
         private void RemoveCheck(CheckFactoryContext checkToRemove)
         {
-            _checkRegistry.Remove(checkToRemove);
+            var tempColl = new ConcurrentBag<CheckFactoryContext>();
+            
+            // Take items one by one and only keep those we don't want to remove
+            while (_checkRegistry.TryTake(out var item))
+            {
+                if (item != checkToRemove)
+                {
+                    tempColl.Add(item);
+                }
+                else if (item.MaterializedCheck is not null)
+                {
+                    _buildCheckCentralContext.DeregisterCheck(item.MaterializedCheck);
+                    
+                    var telemetryData = item.MaterializedCheck.GetRuleTelemetryData();
+                    foreach (var data in telemetryData)
+                    {
+                        _ruleTelemetryData.Add(data);
+                    }
+                    
+                    item.MaterializedCheck.Check.Dispose();
+                }
+            }
 
-            if (checkToRemove.MaterializedCheck is not null)
+            // Add back all preserved items
+            foreach (var item in tempColl)
             {
-                _buildCheckCentralContext.DeregisterCheck(checkToRemove.MaterializedCheck);
-                _ruleTelemetryData.AddRange(checkToRemove.MaterializedCheck.GetRuleTelemetryData());
-                checkToRemove.MaterializedCheck.Check.Dispose();
+                _checkRegistry.Add(item);
             }
         }
 
@@ -471,7 +504,7 @@ public void ProcessTaskParameterEventArgs(
             => _buildEventsProcessor
                 .ProcessTaskParameterEventArgs(checkContext, taskParameterEventArgs);
 
-        private readonly List<BuildCheckRuleTelemetryData> _ruleTelemetryData = [];
+        private readonly ConcurrentBag<BuildCheckRuleTelemetryData> _ruleTelemetryData = [];
 
         public BuildCheckTracingData CreateCheckTracingStats()
         {
@@ -479,11 +512,15 @@ public BuildCheckTracingData CreateCheckTracingStats()
             {
                 if (checkFactoryContext.MaterializedCheck != null)
                 {
-                    _ruleTelemetryData.AddRange(checkFactoryContext.MaterializedCheck.GetRuleTelemetryData());
+                    var telemetryData = checkFactoryContext.MaterializedCheck.GetRuleTelemetryData();
+                    foreach (var data in telemetryData)
+                    {
+                        _ruleTelemetryData.Add(data);
+                    }
                 }
             }
 
-            return new BuildCheckTracingData(_ruleTelemetryData, _tracingReporter.GetInfrastructureTracingStats());
+            return new BuildCheckTracingData(_ruleTelemetryData.ToList(), _tracingReporter.GetInfrastructureTracingStats());
         }
 
         public void FinalizeProcessing(LoggingContext loggingContext)
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index cc416e5d409..eee48e9f667 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -176,6 +176,14 @@ internal ProjectRootElement(XmlReader xmlReader, ProjectRootElementCacheBase pro
             ProjectParser.Parse(document, this);
         }
 
+        private readonly bool _isEphemeral = false;
+
+        private ProjectRootElement(ProjectRootElementCacheBase projectRootElementCache, NewProjectFileOptions projectFileOptions, bool isEphemeral)
+            : this(projectRootElementCache, projectFileOptions)
+        {
+            _isEphemeral = isEphemeral;
+        }
+
         /// <summary>
         /// Initialize an in-memory, empty ProjectRootElement instance that can be saved later.
         /// Leaves the project dirty, indicating there are unsaved changes.
@@ -321,6 +329,8 @@ public override string Condition
         /// </summary>
         public ICollection<ProjectImportElement> Imports => new ReadOnlyCollection<ProjectImportElement>(GetAllChildrenOfType<ProjectImportElement>());
 
+        internal bool IsEphemeral => _isEphemeral;
+
         /// <summary>
         /// Get a read-only collection of the child property groups, if any.
         /// Does not include any that may not be at the root, i.e. inside Choose elements.
@@ -712,6 +722,18 @@ internal ProjectExtensionsElement ProjectExtensions
         internal string LastDirtyReason
             => _dirtyReason == null ? null : String.Format(CultureInfo.InvariantCulture, _dirtyReason, _dirtyParameter);
 
+        /// <summary>
+        /// Initialize an in-memory empty ProjectRootElement instance that CANNOT be saved later.
+        /// The ProjectRootElement will not be marked dirty.
+        /// Uses the global project collection.
+        /// </summary>
+        internal static ProjectRootElement CreateEphemeral(ProjectRootElementCacheBase projectRootElementCache)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(projectRootElementCache);
+
+            return new ProjectRootElement(projectRootElementCache, Project.DefaultNewProjectTemplateOptions, isEphemeral: true);
+        }
+
         /// <summary>
         /// Initialize an in-memory, empty ProjectRootElement instance that can be saved later.
         /// Uses the global project collection.
@@ -1817,6 +1839,11 @@ internal override void VerifyThrowInvalidOperationAcceptableLocation(ProjectElem
         /// </remarks>
         internal sealed override void MarkDirty(string reason, string param)
         {
+            if (_isEphemeral)
+            {
+                return;
+            }
+
             if (Link != null)
             {
                 RootLink.MarkDirty(reason, param);
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 63ce5b9dcee..3a7a0ce42a7 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -193,7 +193,7 @@ internal int VisualStudioVersion
 
         internal bool UseNewParser => ShouldUseNewParser(_solutionFile);
 
-        internal static bool ShouldUseNewParser(string solutionFile) => ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_14) || FileUtilities.IsSolutionXFilename(solutionFile);
+        internal static bool ShouldUseNewParser(string solutionFile) => Traits.Instance.SlnParsingWithSolutionPersistenceOptIn || FileUtilities.IsSolutionXFilename(solutionFile);
 
         /// <summary>
         /// All projects in this solution, in the order they appeared in the solution file
@@ -658,7 +658,8 @@ internal static string ParseSolutionFromSolutionFilter(string solutionFilterFile
                 JsonDocumentOptions options = new JsonDocumentOptions() { AllowTrailingCommas = true, CommentHandling = JsonCommentHandling.Skip };
                 JsonDocument text = JsonDocument.Parse(File.ReadAllText(solutionFilterFile), options);
                 solution = text.RootElement.GetProperty("solution");
-                return FileUtilities.GetFullPath(solution.GetProperty("path").GetString(), Path.GetDirectoryName(solutionFilterFile));
+                // We do NOT want to escape in order to preserve symbols like @, %, $ etc.
+                return FileUtilities.GetFullPath(solution.GetProperty("path").GetString(), Path.GetDirectoryName(solutionFilterFile), escape: false);
             }
             catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
             {
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 760fcb390f3..d535d1c73c0 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -948,15 +948,7 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             // Add our local extensibility points to the project representing the solution
             // Imported at the top: before.mysolution.sln.targets
             // Imported at the bottom: after.mysolution.sln.targets
-            string escapedSolutionFile = EscapingUtilities.Escape(Path.GetFileName(_solutionFile.FullPath));
-            string escapedSolutionDirectory = EscapingUtilities.Escape(_solutionFile.SolutionFileDirectory);
-            string localFile = Path.Combine(escapedSolutionDirectory, "before." + escapedSolutionFile + ".targets");
-            ProjectImportElement importBeforeLocal = traversalProject.CreateImportElement(localFile);
-            importBeforeLocal.Condition = @"exists('" + localFile + "')";
-
-            localFile = Path.Combine(escapedSolutionDirectory, "after." + escapedSolutionFile + ".targets");
-            ProjectImportElement importAfterLocal = traversalProject.CreateImportElement(localFile);
-            importAfterLocal.Condition = @"exists('" + localFile + "')";
+            (ProjectImportElement importBeforeLocal, ProjectImportElement importAfterLocal) = CreateBeforeAndAfterSolutionImports(traversalProject);
 
             // Put locals second so they can override globals if they want
             traversalProject.PrependChild(importBeforeLocal);
@@ -1025,6 +1017,27 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             return traversalInstance;
         }
 
+        private (ProjectImportElement ImportBeforeSln, ProjectImportElement ImportAfterSln) CreateBeforeAndAfterSolutionImports(ProjectRootElement traversalProject)
+        {
+            string escapedSolutionFileName = EscapingUtilities.Escape(Path.GetFileName(_solutionFile.FullPath));
+            if (escapedSolutionFileName.EndsWith(".slnx"))
+            {
+                // We want to load only after.{solutionFileName}.sln.targets for solution files with .slnx extension
+                escapedSolutionFileName = escapedSolutionFileName.Substring(0, escapedSolutionFileName.Length - 1);
+            }
+
+            string escapedSolutionDirectory = EscapingUtilities.Escape(_solutionFile.SolutionFileDirectory);
+            string localFile = Path.Combine(escapedSolutionDirectory, $"before.{escapedSolutionFileName}.targets");
+            ProjectImportElement importBeforeLocal = traversalProject.CreateImportElement(localFile);
+            importBeforeLocal.Condition = $"exists('{localFile}')";
+
+            localFile = Path.Combine(escapedSolutionDirectory, $"after.{escapedSolutionFileName}.targets");
+            ProjectImportElement importAfterLocal = traversalProject.CreateImportElement(localFile);
+            importAfterLocal.Condition = $"exists('{localFile}')";
+
+            return (importBeforeLocal, importAfterLocal);
+        }
+
         private void EmitMetaproject(ProjectRootElement metaproject, string path)
         {
             if (Traits.Instance.EmitSolutionMetaproj)
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 4a868767aea..2401d4935a1 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -2257,7 +2257,7 @@ public override IList<ResolvedImport> Imports
 
                     foreach (ResolvedImport import in _data.ImportClosure)
                     {
-                        if (import.ImportingElement != null) // Exclude outer project itself
+                        if (import.ImportingElement != null && !import.ImportedProject.IsEphemeral) // Exclude outer project itself and SDK-resolver synthesized imports
                         {
                             imports.Add(import);
                         }
@@ -2280,7 +2280,7 @@ public override IList<ResolvedImport> ImportsIncludingDuplicates
 
                     foreach (var import in _data.ImportClosureWithDuplicates)
                     {
-                        if (import.ImportingElement != null) // Exclude outer project itself
+                        if (import.ImportingElement != null && !import.ImportedProject.IsEphemeral) // Exclude outer project itself and SDK-resolver synthesized imports
                         {
                             imports.Add(import);
                         }
@@ -3721,6 +3721,7 @@ private void Reevaluate(
                     loadSettings,
                     ProjectCollection.MaxNodeCount,
                     ProjectCollection.EnvironmentProperties,
+                    ProjectCollection.PropertiesFromCommandLine,
                     loggingServiceForEvaluation,
                     new ProjectItemFactory(Owner),
                     ProjectCollection,
@@ -4437,7 +4438,7 @@ public IItemDefinition<ProjectMetadata> GetItemDefinition(string itemType)
             /// <summary>
             /// Sets a property which is not derived from Xml.
             /// </summary>
-            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable = false)
+            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable = false, bool isCommandLineProperty = false)
             {
                 ProjectProperty property = ProjectProperty.Create(Project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext);
                 Properties.Set(property);
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 031e31f1e2e..9973e5d3d80 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -497,6 +497,11 @@ public static string DisplayVersion
             }
         }
 
+        /// <summary>
+        /// Properties passed from the command line (e.g. by using /p:).
+        /// </summary>
+        public ICollection<string> PropertiesFromCommandLine { get; set; }
+
         /// <summary>
         /// The default tools version of this project collection. Projects use this tools version if they
         /// aren't otherwise told what tools version to use.
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index 3d19d6766af..bd84fed6708 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -365,6 +365,15 @@ private Toolset(ITranslator translator)
             ((ITranslatable)this).Translate(translator);
         }
 
+        /// <summary>
+        /// Helper for inspecting internal task registries that might or might not be initialized at this point.
+        /// </summary>
+        internal void InspectInternalTaskRegistry(Action<TaskRegistry> visitor)
+        {
+            visitor(_defaultTaskRegistry);
+            visitor(_overrideTaskRegistry);
+        }
+
         /// <summary>
         /// Returns a ProjectImportPathMatch struct for the first property found in the expression for which
         /// project import search paths is enabled.
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index daf8d0ea71b..cba4152a3fc 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -12,7 +12,6 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Components.Logging;
 using Microsoft.Build.BackEnd.Components.RequestBuilder;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -158,6 +157,11 @@ internal class Evaluator<P, I, M, D>
         /// </summary>
         private readonly PropertyDictionary<ProjectPropertyInstance> _environmentProperties;
 
+        /// <summary>
+        /// Properties passed from the command line (e.g. by using /p:).
+        /// </summary>
+        private readonly ICollection<string> _propertiesFromCommandLine;
+
         /// <summary>
         /// The cache to consult for any imports that need loading.
         /// </summary>
@@ -201,6 +205,7 @@ private Evaluator(
             ProjectLoadSettings loadSettings,
             int maxNodeCount,
             PropertyDictionary<ProjectPropertyInstance> environmentProperties,
+            ICollection<string> propertiesFromCommandLine,
             IItemFactory<I, I> itemFactory,
             IToolsetProvider toolsetProvider,
             IDirectoryCacheFactory directoryCacheFactory,
@@ -253,6 +258,7 @@ private Evaluator(
             _loadSettings = loadSettings;
             _maxNodeCount = maxNodeCount;
             _environmentProperties = environmentProperties;
+            _propertiesFromCommandLine = propertiesFromCommandLine ?? [];
             _itemFactory = itemFactory;
             _projectRootElementCache = projectRootElementCache;
             _sdkResolverService = sdkResolverService;
@@ -301,6 +307,7 @@ internal static void Evaluate(
             ProjectLoadSettings loadSettings,
             int maxNodeCount,
             PropertyDictionary<ProjectPropertyInstance> environmentProperties,
+            ICollection<string> propertiesFromCommandLine,
             ILoggingService loggingService,
             IItemFactory<I, I> itemFactory,
             IToolsetProvider toolsetProvider,
@@ -321,6 +328,7 @@ internal static void Evaluate(
                 loadSettings,
                 maxNodeCount,
                 environmentProperties,
+                propertiesFromCommandLine,
                 itemFactory,
                 toolsetProvider,
                 directoryCacheFactory,
@@ -1240,7 +1248,7 @@ private void AddToolsetProperties()
         }
 
         /// <summary>
-        /// Put all the global properties into our property bag
+        /// Put all the global properties into our property bag.
         /// </summary>
         private int AddGlobalProperties()
         {
@@ -1251,7 +1259,13 @@ private int AddGlobalProperties()
 
             foreach (ProjectPropertyInstance globalProperty in _data.GlobalPropertiesDictionary)
             {
-                _data.SetProperty(globalProperty.Name, ((IProperty)globalProperty).EvaluatedValueEscaped, true /* IS global property */, false /* may NOT be a reserved name */, loggingContext: _evaluationLoggingContext);
+                _ = _data.SetProperty(
+                    globalProperty.Name,
+                    ((IProperty)globalProperty).EvaluatedValueEscaped,
+                    isGlobalProperty: true /* it is a global property, but it comes from command line and is tracked separately */,
+                    mayBeReserved: false /* may NOT be a reserved name */,
+                    loggingContext: _evaluationLoggingContext,
+                    isCommandLineProperty: _propertiesFromCommandLine.Contains(globalProperty.Name) /* IS coming from command line argument */);
             }
 
             return _data.GlobalPropertiesDictionary.Count;
@@ -1917,7 +1931,7 @@ private ProjectRootElement CreateProjectForSdkResult(SdkResult sdkResult)
 
             ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
             {
-                ProjectRootElement project = ProjectRootElement.Create();
+                ProjectRootElement project = ProjectRootElement.CreateEphemeral(_projectRootElementCache);
                 project.FullPath = projectPath;
 
                 if (sdkResult.PropertiesToAdd?.Any() == true)
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 05ad3902a6f..84b34d5c67a 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -15,6 +15,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation.Context;
+using Microsoft.Build.Evaluation.Expander;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
@@ -24,6 +25,7 @@
 using Microsoft.Win32;
 using AvailableStaticMethods = Microsoft.Build.Internal.AvailableStaticMethods;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
+using ParseArgs = Microsoft.Build.Evaluation.Expander.ArgumentParser;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using TaskItemFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory;
 
@@ -3496,7 +3498,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
 
                         // For our intrinsic function we need to support calling of internal methods
                         // since we don't want them to be public
-                        if (_receiverType == typeof(Microsoft.Build.Evaluation.IntrinsicFunctions))
+                        if (_receiverType == typeof(IntrinsicFunctions))
                         {
                             _bindingFlags |= BindingFlags.NonPublic;
                         }
@@ -3538,8 +3540,8 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                         {
                             // Unescape the value since we're about to send it out of the engine and into
                             // the function being called. If a file or a directory function, fix the path
-                            if (_receiverType == typeof(System.IO.File) || _receiverType == typeof(System.IO.Directory)
-                                || _receiverType == typeof(System.IO.Path))
+                            if (_receiverType == typeof(File) || _receiverType == typeof(Directory)
+                                || _receiverType == typeof(Path))
                             {
                                 argumentValue = FileUtilities.FixFilePath(argumentValue);
                             }
@@ -3561,7 +3563,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                     if (objectInstance != null && args.Length == 1 && (String.Equals("Equals", _methodMethodName, StringComparison.OrdinalIgnoreCase) || String.Equals("CompareTo", _methodMethodName, StringComparison.OrdinalIgnoreCase)))
                     {
                         // Support comparison when the lhs is an integer
-                        if (IsFloatingPointRepresentation(args[0]))
+                        if (ParseArgs.IsFloatingPointRepresentation(args[0]))
                         {
                             if (double.TryParse(objectInstance.ToString(), NumberStyles.Number | NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out double result))
                             {
@@ -3592,7 +3594,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                     // need to locate an appropriate constructor and invoke it
                     if (String.Equals("new", _methodMethodName, StringComparison.OrdinalIgnoreCase))
                     {
-                        if (!TryExecuteWellKnownConstructorNoThrow(out functionResult, args))
+                        if (!WellKnownFunctions.TryExecuteWellKnownConstructorNoThrow(_receiverType, out functionResult, args))
                         {
                             functionResult = LateBindExecute(null /* no previous exception */, BindingFlags.Public | BindingFlags.Instance, null /* no instance for a constructor */, args, true /* is constructor */);
                         }
@@ -3605,12 +3607,12 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                         {
                             // First attempt to recognize some well-known functions to avoid binding
                             // and potential first-chance MissingMethodExceptions.
-                            wellKnownFunctionSuccess = TryExecuteWellKnownFunction(out functionResult, objectInstance, args);
+                            wellKnownFunctionSuccess = WellKnownFunctions.TryExecuteWellKnownFunction(_methodMethodName, _receiverType, _fileSystem, out functionResult, objectInstance, args);
 
                             if (!wellKnownFunctionSuccess)
                             {
                                 // Some well-known functions need evaluated value from properties.
-                                wellKnownFunctionSuccess = TryExecuteWellKnownFunctionWithPropertiesParam(properties, out functionResult, objectInstance, args);
+                                wellKnownFunctionSuccess = WellKnownFunctions.TryExecuteWellKnownFunctionWithPropertiesParam(_methodMethodName, _receiverType, _loggingContext, properties, out functionResult, objectInstance, args);
                             }
                         }
                         // we need to preserve the same behavior on exceptions as the actual binder
@@ -3717,1342 +3719,46 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                 }
             }
 
-            private bool TryExecuteWellKnownFunctionWithPropertiesParam(IPropertyProvider<T> properties, out object returnVal, object objectInstance, object[] args)
-            {
-                returnVal = null;
-
-                if (_receiverType == typeof(IntrinsicFunctions))
-                {
-                    if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RegisterBuildCheck), StringComparison.OrdinalIgnoreCase))
-                    {
-                        string projectPath = properties.GetProperty("MSBuildProjectFullPath")?.EvaluatedValue ?? string.Empty;
-                        ErrorUtilities.VerifyThrow(_loggingContext != null, $"The logging context is missed. {nameof(IntrinsicFunctions.RegisterBuildCheck)} can not be invoked.");
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = IntrinsicFunctions.RegisterBuildCheck(projectPath, arg0, _loggingContext);
-                            return true;
-                        }
-                    }
-                }
-
-                return false;
-            }
-
-            private object GetMethodResult(object objectInstance, IEnumerable<MethodInfo> methods, object[] args, int index)
-            {
-                for (int i = index; i < args.Length; i++)
-                {
-                    if (args[i].Equals("out _"))
-                    {
-                        object toReturn = null;
-                        foreach (MethodInfo method in methods)
-                        {
-                            Type t = method.GetParameters()[i].ParameterType;
-                            args[i] = t.IsValueType ? Activator.CreateInstance(t) : null;
-                            object currentReturnValue = GetMethodResult(objectInstance, methods, args, i + 1);
-                            if (currentReturnValue is not null)
-                            {
-                                if (toReturn is null)
-                                {
-                                    toReturn = currentReturnValue;
-                                }
-                                else if (!toReturn.Equals(currentReturnValue))
-                                {
-                                    // There were multiple methods that seemed viable and gave different results. We can't differentiate between them so throw.
-                                    ErrorUtilities.ThrowArgument("CouldNotDifferentiateBetweenCompatibleMethods", _methodMethodName, args.Length);
-                                    return null;
-                                }
-                            }
-                        }
-
-                        return toReturn;
-                    }
-                }
-
-                try
-                {
-                    return _receiverType.InvokeMember(_methodMethodName, _bindingFlags, Type.DefaultBinder, objectInstance, args, CultureInfo.InvariantCulture) ?? "null";
-                }
-                catch (Exception)
-                {
-                    // This isn't a viable option, but perhaps another set of parameters will work.
-                    return null;
-                }
-            }
-
-            /// <summary>
-            /// Shortcut to avoid calling into binding if we recognize some most common functions.
-            /// Binding is expensive and throws first-chance MissingMethodExceptions, which is
-            /// bad for debugging experience and has a performance cost.
-            /// A typical binding operation with exception can take ~1.500 ms; this call is ~0.050 ms
-            /// (rough numbers just for comparison).
-            /// See https://github.com/dotnet/msbuild/issues/2217.
-            /// </summary>
-            /// <param name="returnVal">The value returned from the function call.</param>
-            /// <param name="objectInstance">Object that the function is called on.</param>
-            /// <param name="args">arguments.</param>
-            /// <returns>True if the well known function call binding was successful.</returns>
-            private bool TryExecuteWellKnownFunction(out object returnVal, object objectInstance, object[] args)
-            {
-                returnVal = null;
-
-                if (objectInstance is string text)
-                {
-                    if (string.Equals(_methodMethodName, nameof(string.StartsWith), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = text.StartsWith(arg0);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.Replace), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArgs(args, out string arg0, out string arg1))
-                        {
-                            returnVal = text.Replace(arg0, arg1);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.Contains), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = text.Contains(arg0);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.ToUpperInvariant), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (args.Length == 0)
-                        {
-                            returnVal = text.ToUpperInvariant();
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.ToLowerInvariant), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (args.Length == 0)
-                        {
-                            returnVal = text.ToLowerInvariant();
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.EndsWith), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = text.EndsWith(arg0);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.ToLower), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (args.Length == 0)
-                        {
-                            returnVal = text.ToLower();
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.IndexOf), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArgs(args, out string arg0, out StringComparison arg1))
-                        {
-                            returnVal = text.IndexOf(arg0, arg1);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.IndexOfAny), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = text.IndexOfAny(arg0.ToCharArray());
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.LastIndexOf), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = text.LastIndexOf(arg0);
-                            return true;
-                        }
-                        else if (TryGetArgs(args, out arg0, out int startIndex))
-                        {
-                            returnVal = text.LastIndexOf(arg0, startIndex);
-                            return true;
-                        }
-                        else if (TryGetArgs(args, out arg0, out StringComparison arg1))
-                        {
-                            returnVal = text.LastIndexOf(arg0, arg1);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.LastIndexOfAny), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = text.LastIndexOfAny(arg0.ToCharArray());
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.Length), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (args.Length == 0)
-                        {
-                            returnVal = text.Length;
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.Substring), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out int startIndex))
-                        {
-                            returnVal = text.Substring(startIndex);
-                            return true;
-                        }
-                        else if (TryGetArgs(args, out startIndex, out int length))
-                        {
-                            returnVal = text.Substring(startIndex, length);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.Split), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string separator) && separator.Length == 1)
-                        {
-                            returnVal = text.Split(separator[0]);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.PadLeft), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out int totalWidth))
-                        {
-                            returnVal = text.PadLeft(totalWidth);
-                            return true;
-                        }
-                        else if (TryGetArgs(args, out totalWidth, out string paddingChar) && paddingChar.Length == 1)
-                        {
-                            returnVal = text.PadLeft(totalWidth, paddingChar[0]);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.PadRight), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out int totalWidth))
-                        {
-                            returnVal = text.PadRight(totalWidth);
-                            return true;
-                        }
-                        else if (TryGetArgs(args, out totalWidth, out string paddingChar) && paddingChar.Length == 1)
-                        {
-                            returnVal = text.PadRight(totalWidth, paddingChar[0]);
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.TrimStart), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string trimChars) && trimChars.Length > 0)
-                        {
-                            returnVal = text.TrimStart(trimChars.ToCharArray());
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.TrimEnd), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string trimChars) && trimChars.Length > 0)
-                        {
-                            returnVal = text.TrimEnd(trimChars.ToCharArray());
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, "get_Chars", StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out int index))
-                        {
-                            returnVal = text[index];
-                            return true;
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(string.Equals), StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out string arg0))
-                        {
-                            returnVal = text.Equals(arg0);
-                            return true;
-                        }
-                    }
-                }
-                else if (objectInstance is string[] stringArray)
-                {
-                    if (string.Equals(_methodMethodName, "GetValue", StringComparison.OrdinalIgnoreCase))
-                    {
-                        if (TryGetArg(args, out int index))
-                        {
-                            returnVal = stringArray[index];
-                            return true;
-                        }
-                    }
-                }
-                else if (objectInstance == null) // Calling a well-known static function
-                {
-                    if (_receiverType == typeof(string))
-                    {
-                        if (string.Equals(_methodMethodName, nameof(string.IsNullOrWhiteSpace), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = string.IsNullOrWhiteSpace(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(string.IsNullOrEmpty), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = string.IsNullOrEmpty(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(string.Copy), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = arg0;
-                                return true;
-                            }
-                        }
-                    }
-                    else if (_receiverType == typeof(Math))
-                    {
-                        if (string.Equals(_methodMethodName, nameof(Math.Max), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out var arg0, out double arg1))
-                            {
-                                returnVal = Math.Max(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Math.Min), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out double arg0, out var arg1))
-                            {
-                                returnVal = Math.Min(arg0, arg1);
-                                return true;
-                            }
-                        }
-                    }
-                    else if (_receiverType == typeof(IntrinsicFunctions))
-                    {
-                        if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.EnsureTrailingSlash), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.EnsureTrailingSlash(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.ValueOrDefault), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.ValueOrDefault(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.NormalizePath), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (ElementsOfType(args, typeof(string)))
-                            {
-                                returnVal = IntrinsicFunctions.NormalizePath(Array.ConvertAll(args, o => (string)o));
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetDirectoryNameOfFileAbove), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.GetDirectoryNameOfFileAbove(arg0, arg1, _fileSystem);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetRegistryValueFromView), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length >= 4 &&
-                                TryGetArgs(args, out string arg0, out string arg1, enforceLength: false))
-                            {
-                                returnVal = IntrinsicFunctions.GetRegistryValueFromView(arg0, arg1, args[2], new ArraySegment<object>(args, 3, args.Length - 3));
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.IsRunningFromVisualStudio), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.IsRunningFromVisualStudio();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Escape), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.Escape(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Unescape), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.Unescape(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetPathOfFileAbove), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.GetPathOfFileAbove(arg0, arg1, _fileSystem);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Add), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryExecuteArithmeticOverload(args, IntrinsicFunctions.Add, IntrinsicFunctions.Add, out returnVal))
-                            {
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Subtract), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryExecuteArithmeticOverload(args, IntrinsicFunctions.Subtract, IntrinsicFunctions.Subtract, out returnVal))
-                            {
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Multiply), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryExecuteArithmeticOverload(args, IntrinsicFunctions.Multiply, IntrinsicFunctions.Multiply, out returnVal))
-                            {
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Divide), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryExecuteArithmeticOverload(args, IntrinsicFunctions.Divide, IntrinsicFunctions.Divide, out returnVal))
-                            {
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.Modulo), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryExecuteArithmeticOverload(args, IntrinsicFunctions.Modulo, IntrinsicFunctions.Modulo, out returnVal))
-                            {
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetCurrentToolsDirectory), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.GetCurrentToolsDirectory();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetToolsDirectory32), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.GetToolsDirectory32();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetToolsDirectory64), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.GetToolsDirectory64();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetMSBuildSDKsPath), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.GetMSBuildSDKsPath();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetVsInstallRoot), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.GetVsInstallRoot();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetMSBuildExtensionsPath), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.GetMSBuildExtensionsPath();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetProgramFiles32), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = IntrinsicFunctions.GetProgramFiles32();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.VersionEquals), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.VersionEquals(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.VersionNotEquals), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.VersionNotEquals(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.VersionGreaterThan), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.VersionGreaterThan(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.VersionGreaterThanOrEquals), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.VersionGreaterThanOrEquals(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.VersionLessThan), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.VersionLessThan(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.VersionLessThanOrEquals), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.VersionLessThanOrEquals(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetFrameworkIdentifier), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.GetTargetFrameworkIdentifier(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetFrameworkVersion), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.GetTargetFrameworkVersion(arg0);
-                                return true;
-                            }
-                            if (TryGetArgs(args, out string arg1, out int arg2))
-                            {
-                                returnVal = IntrinsicFunctions.GetTargetFrameworkVersion(arg1, arg2);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.IsTargetFrameworkCompatible), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out string arg1))
-                            {
-                                returnVal = IntrinsicFunctions.IsTargetFrameworkCompatible(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetPlatformIdentifier), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.GetTargetPlatformIdentifier(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetPlatformVersion), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.GetTargetPlatformVersion(arg0);
-                                return true;
-                            }
-                            if (TryGetArgs(args, out string arg1, out int arg2))
-                            {
-                                returnVal = IntrinsicFunctions.GetTargetPlatformVersion(arg1, arg2);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.ConvertToBase64), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.ConvertToBase64(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.ConvertFromBase64), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.ConvertFromBase64(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.StableStringHash), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                // Prevent loading methods refs from StringTools if ChangeWave opted out.
-                                returnVal = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)
-                                    ? IntrinsicFunctions.StableStringHash(arg0)
-                                    : IntrinsicFunctions.StableStringHashLegacy(arg0);
-                                return true;
-                            }
-                            else if (TryGetArgs(args, out string arg1, out string arg2) && Enum.TryParse<IntrinsicFunctions.StringHashingAlgorithm>(arg2, true, out var hashAlgorithm))
-                            {
-                                returnVal = IntrinsicFunctions.StableStringHash(arg1, hashAlgorithm);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.AreFeaturesEnabled), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out Version arg0))
-                            {
-                                returnVal = IntrinsicFunctions.AreFeaturesEnabled(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.SubstringByAsciiChars), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out string arg0, out int arg1, out int arg2))
-                            {
-                                returnVal = IntrinsicFunctions.SubstringByAsciiChars(arg0, arg1, arg2);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.CheckFeatureAvailability), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.CheckFeatureAvailability(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseOr), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out int arg0, out int arg1))
-                            {
-                                returnVal = IntrinsicFunctions.BitwiseOr(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseAnd), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out int arg0, out int arg1))
-                            {
-                                returnVal = IntrinsicFunctions.BitwiseAnd(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseXor), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out int arg0, out int arg1))
-                            {
-                                returnVal = IntrinsicFunctions.BitwiseXor(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.BitwiseNot), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out int arg0))
-                            {
-                                returnVal = IntrinsicFunctions.BitwiseNot(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.LeftShift), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out int arg0, out int arg1))
-                            {
-                                returnVal = IntrinsicFunctions.LeftShift(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RightShift), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out int arg0, out int arg1))
-                            {
-                                returnVal = IntrinsicFunctions.RightShift(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RightShiftUnsigned), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArgs(args, out int arg0, out int arg1))
-                            {
-                                returnVal = IntrinsicFunctions.RightShiftUnsigned(arg0, arg1);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.NormalizeDirectory), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.NormalizeDirectory(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.IsOSPlatform), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.IsOSPlatform(arg0);
-                                return true;
-                            }
-                        }
-                    }
-                    else if (_receiverType == typeof(Path))
-                    {
-                        if (string.Equals(_methodMethodName, nameof(Path.Combine), StringComparison.OrdinalIgnoreCase))
-                        {
-                            string arg0, arg1, arg2, arg3;
-
-                            // Combine has fast implementations for up to 4 parameters: https://github.com/dotnet/corefx/blob/2c55db90d622fa6279184e6243f0470a3755d13c/src/Common/src/CoreLib/System/IO/Path.cs#L293-L317
-                            switch (args.Length)
-                            {
-                                case 0:
-                                    return false;
-                                case 1:
-                                    if (TryGetArg(args, out arg0))
-                                    {
-                                        returnVal = Path.Combine(arg0);
-                                        return true;
-                                    }
-                                    break;
-                                case 2:
-                                    if (TryGetArgs(args, out arg0, out arg1))
-                                    {
-                                        returnVal = Path.Combine(arg0, arg1);
-                                        return true;
-                                    }
-                                    break;
-                                case 3:
-                                    if (TryGetArgs(args, out arg0, out arg1, out arg2))
-                                    {
-                                        returnVal = Path.Combine(arg0, arg1, arg2);
-                                        return true;
-                                    }
-                                    break;
-                                case 4:
-                                    if (TryGetArgs(args, out arg0, out arg1, out arg2, out arg3))
-                                    {
-                                        returnVal = Path.Combine(arg0, arg1, arg2, arg3);
-                                        return true;
-                                    }
-                                    break;
-                                default:
-                                    if (ElementsOfType(args, typeof(string)))
-                                    {
-                                        returnVal = Path.Combine(Array.ConvertAll(args, o => (string)o));
-                                        return true;
-                                    }
-                                    break;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Path.DirectorySeparatorChar), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = Path.DirectorySeparatorChar;
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Path.GetFullPath), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = Path.GetFullPath(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Path.IsPathRooted), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = Path.IsPathRooted(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Path.GetTempPath), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = Path.GetTempPath();
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Path.GetFileName), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = Path.GetFileName(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Path.GetDirectoryName), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = Path.GetDirectoryName(arg0);
-                                return true;
-                            }
-                        }
-                        else if (string.Equals(_methodMethodName, nameof(Path.GetFileNameWithoutExtension), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = Path.GetFileNameWithoutExtension(arg0);
-                                return true;
-                            }
-                        }
-                    }
-                    else if (_receiverType == typeof(Version))
-                    {
-                        if (string.Equals(_methodMethodName, nameof(Version.Parse), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = Version.Parse(arg0);
-                                return true;
-                            }
-                        }
-                    }
-                    else if (_receiverType == typeof(Guid))
-                    {
-                        if (string.Equals(_methodMethodName, nameof(Guid.NewGuid), StringComparison.OrdinalIgnoreCase))
-                        {
-                            if (args.Length == 0)
-                            {
-                                returnVal = Guid.NewGuid();
-                                return true;
-                            }
-                        }
-                    }
-                    else if (string.Equals(_methodMethodName, nameof(Regex.Replace), StringComparison.OrdinalIgnoreCase) && args.Length == 3)
-                    {
-                        if (TryGetArg([args[0]], out string arg1) && TryGetArg([args[1]], out string arg2) && TryGetArg([args[2]], out string arg3))
-                        {
-                            returnVal = Regex.Replace(arg1, arg2, arg3);
-                            return true;
-                        }
-                    }
-                }
-                else if (string.Equals(_methodMethodName, nameof(Version.ToString), StringComparison.OrdinalIgnoreCase) && objectInstance is Version v)
-                {
-                    if (TryGetArg(args, out int arg0))
-                    {
-                        returnVal = v.ToString(arg0);
-                        return true;
-                    }
-                }
-                else if (string.Equals(_methodMethodName, nameof(Int32.ToString), StringComparison.OrdinalIgnoreCase) && objectInstance is int i)
-                {
-                    if (TryGetArg(args, out string arg0))
-                    {
-                        returnVal = i.ToString(arg0);
-                        return true;
-                    }
-                }
-                if (Traits.Instance.LogPropertyFunctionsRequiringReflection)
-                {
-                    LogFunctionCall("PropertyFunctionsRequiringReflection", objectInstance, args);
-                }
-
-                return false;
-            }
-
-            /// <summary>
-            /// Shortcut to avoid calling into binding if we recognize some most common constructors.
-            /// Analogous to TryExecuteWellKnownFunction but guaranteed to not throw.
-            /// </summary>
-            /// <param name="returnVal">The instance as created by the constructor call.</param>
-            /// <param name="args">Arguments.</param>
-            /// <returns>True if the well known constructor call binding was successful.</returns>
-            private bool TryExecuteWellKnownConstructorNoThrow(out object returnVal, object[] args)
-            {
-                returnVal = null;
-
-                if (_receiverType == typeof(string))
-                {
-                    if (args.Length == 0)
-                    {
-                        returnVal = String.Empty;
-                        return true;
-                    }
-                    if (TryGetArg(args, out string arg0))
-                    {
-                        returnVal = arg0;
-                        return true;
-                    }
-                }
-                return false;
-            }
-
-            private bool ElementsOfType(object[] args, Type type)
+            private object GetMethodResult(object objectInstance, IEnumerable<MethodInfo> methods, object[] args, int index)
             {
-                for (var i = 0; i < args.Length; i++)
+                for (int i = index; i < args.Length; i++)
                 {
-                    if (args[i].GetType() != type)
+                    if (args[i].Equals("out _"))
                     {
-                        return false;
-                    }
-                }
-
-                return true;
-            }
-
-            private static bool TryGetArgs(object[] args, out string arg0, out string arg1, bool enforceLength = true)
-            {
-                arg0 = null;
-                arg1 = null;
-
-                if (enforceLength && args.Length != 2)
-                {
-                    return false;
-                }
-
-                if (args[0] is string value0 &&
-                    args[1] is string value1)
-                {
-                    arg0 = value0;
-                    arg1 = value1;
-
-                    return true;
-                }
-
-                return false;
-            }
-
-            private bool TryGetArgs(object[] args, out string arg0, out string arg1, out string arg2)
-            {
-                arg0 = null;
-                arg1 = null;
-                arg2 = null;
-
-                if (args.Length != 3)
-                {
-                    return false;
-                }
-
-                if (args[0] is string value0 &&
-                    args[1] is string value1 &&
-                    args[2] is string value2)
-                {
-                    arg0 = value0;
-                    arg1 = value1;
-                    arg2 = value2;
-
-                    return true;
-                }
-
-                return false;
-            }
-
-            private bool TryGetArgs(object[] args, out string arg0, out string arg1, out string arg2, out string arg3)
-            {
-                arg0 = null;
-                arg1 = null;
-                arg2 = null;
-                arg3 = null;
-
-                if (args.Length != 4)
-                {
-                    return false;
-                }
-
-                if (args[0] is string value0 &&
-                    args[1] is string value1 &&
-                    args[2] is string value2 &&
-                    args[3] is string value3)
-                {
-                    arg0 = value0;
-                    arg1 = value1;
-                    arg2 = value2;
-                    arg3 = value3;
-
-                    return true;
-                }
-
-                return false;
-            }
-
-            private bool TryGetArgs(object[] args, out string arg0, out string arg1)
-            {
-                arg0 = null;
-                arg1 = null;
-
-                if (args.Length != 2)
-                {
-                    return false;
-                }
-
-                if (args[0] is string value0 &&
-                    args[1] is string value1)
-                {
-                    arg0 = value0;
-                    arg1 = value1;
-
-                    return true;
-                }
-
-                return false;
-            }
-
-            private static bool TryGetArgs(object[] args, out string arg0, out int arg1, out int arg2)
-            {
-                arg0 = null;
-                arg1 = 0;
-                arg2 = 0;
-
-                if (args.Length != 3)
-                {
-                    return false;
-                }
-
-                var value1 = args[1] as string;
-                var value2 = args[2] as string;
-                arg0 = args[0] as string;
-                if (value1 != null &&
-                    value2 != null &&
-                    arg0 != null &&
-                    int.TryParse(value1, out arg1) &&
-                    int.TryParse(value2, out arg2))
-                {
-                    return true;
-                }
-
-                return false;
-            }
-
-            private static bool TryGetArg(object[] args, out int arg0)
-            {
-                if (args.Length != 1)
-                {
-                    arg0 = 0;
-                    return false;
-                }
-
-                return TryConvertToInt(args[0], out arg0);
-            }
-
-            private static bool TryGetArg(object[] args, out Version arg0)
-            {
-                if (args.Length != 1)
-                {
-                    arg0 = default;
-                    return false;
-                }
-
-                return TryConvertToVersion(args[0], out arg0);
-            }
-
-            private static bool TryConvertToVersion(object value, out Version arg0)
-            {
-                string val = value as string;
-
-                if (string.IsNullOrEmpty(val) || !Version.TryParse(val, out arg0))
-                {
-                    arg0 = default;
-                    return false;
-                }
-
-                return true;
-            }
-
-            /// <summary>
-            /// Try to convert value to int.
-            /// </summary>
-            internal static bool TryConvertToInt(object value, out int arg)
-            {
-                switch (value)
-                {
-                    case double d:
-                        if (d >= int.MinValue && d <= int.MaxValue)
-                        {
-                            arg = Convert.ToInt32(d);
-                            if (Math.Abs(arg - d) == 0)
-                            {
-                                return true;
-                            }
-                        }
-
-                        break;
-                    case long l:
-                        if (l >= int.MinValue && l <= int.MaxValue)
-                        {
-                            arg = Convert.ToInt32(l);
-                            return true;
-                        }
-
-                        break;
-                    case int i:
-                        arg = i;
-                        return true;
-                    case string s when int.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture.NumberFormat, out arg):
-                        return true;
-                }
-
-                arg = 0;
-                return false;
-            }
-
-            /// <summary>
-            /// Try to convert value to long.
-            /// </summary>
-            internal static bool TryConvertToLong(object value, out long arg)
-            {
-                switch (value)
-                {
-                    case double d:
-                        if (d >= long.MinValue && d <= long.MaxValue)
+                        object toReturn = null;
+                        foreach (MethodInfo method in methods)
                         {
-                            arg = (long)d;
-                            if (Math.Abs(arg - d) == 0)
+                            Type t = method.GetParameters()[i].ParameterType;
+                            args[i] = t.IsValueType ? Activator.CreateInstance(t) : null;
+                            object currentReturnValue = GetMethodResult(objectInstance, methods, args, i + 1);
+                            if (currentReturnValue is not null)
                             {
-                                return true;
+                                if (toReturn is null)
+                                {
+                                    toReturn = currentReturnValue;
+                                }
+                                else if (!toReturn.Equals(currentReturnValue))
+                                {
+                                    // There were multiple methods that seemed viable and gave different results. We can't differentiate between them so throw.
+                                    ErrorUtilities.ThrowArgument("CouldNotDifferentiateBetweenCompatibleMethods", _methodMethodName, args.Length);
+                                    return null;
+                                }
                             }
                         }
 
-                        break;
-                    case long l:
-                        arg = l;
-                        return true;
-                    case int i:
-                        arg = i;
-                        return true;
-                    case string s when long.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture.NumberFormat, out arg):
-                        return true;
-                }
-
-                arg = 0;
-                return false;
-            }
-
-            /// <summary>
-            /// Try to convert value to double.
-            /// </summary>
-            internal static bool TryConvertToDouble(object value, out double arg)
-            {
-                switch (value)
-                {
-                    case double unboxed:
-                        arg = unboxed;
-                        return true;
-                    case long l:
-                        arg = l;
-                        return true;
-                    case int i:
-                        arg = i;
-                        return true;
-                    case string str when double.TryParse(str, NumberStyles.Number | NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out arg):
-                        return true;
-                    default:
-                        arg = 0;
-                        return false;
-                }
-            }
-
-            private static bool TryGetArg(object[] args, out string arg0)
-            {
-                if (args.Length != 1)
-                {
-                    arg0 = null;
-                    return false;
-                }
-
-                arg0 = args[0] as string;
-                return arg0 != null;
-            }
-
-            private static bool TryGetArgs(object[] args, out string arg0, out StringComparison arg1)
-            {
-                if (args.Length != 2)
-                {
-                    arg0 = null;
-                    arg1 = default;
-
-                    return false;
-                }
-
-                arg0 = args[0] as string;
-
-                // reject enums as ints. In C# this would require a cast, which is not supported in msbuild expressions
-                if (arg0 == null || !(args[1] is string comparisonTypeName) || int.TryParse(comparisonTypeName, out _))
-                {
-                    arg1 = default;
-                    return false;
-                }
-
-                // Allow fully-qualified enum, e.g. "System.StringComparison.OrdinalIgnoreCase"
-                if (comparisonTypeName.Contains('.'))
-                {
-                    comparisonTypeName = comparisonTypeName.Replace("System.StringComparison.", "").Replace("StringComparison.", "");
-                }
-
-                return Enum.TryParse(comparisonTypeName, out arg1);
-            }
-
-            private static bool TryGetArgs(object[] args, out int arg0)
-            {
-                arg0 = 0;
-
-                if (args.Length != 1)
-                {
-                    return false;
-                }
-
-                return TryConvertToInt(args[0], out arg0);
-            }
-
-            private static bool TryGetArgs(object[] args, out int arg0, out int arg1)
-            {
-                arg0 = 0;
-                arg1 = 0;
-
-                if (args.Length != 2)
-                {
-                    return false;
-                }
-
-                return TryConvertToInt(args[0], out arg0) &&
-                       TryConvertToInt(args[1], out arg1);
-            }
-
-            private static bool TryGetArgs(object[] args, out double arg0, out double arg1)
-            {
-                arg0 = 0;
-                arg1 = 0;
-
-                if (args.Length != 2)
-                {
-                    return false;
-                }
-
-                return TryConvertToDouble(args[0], out arg0) &&
-                       TryConvertToDouble(args[1], out arg1);
-            }
-
-            private static bool TryGetArgs(object[] args, out int arg0, out string arg1)
-            {
-                arg0 = 0;
-                arg1 = null;
-
-                if (args.Length != 2)
-                {
-                    return false;
-                }
-
-                arg1 = args[1] as string;
-                if (arg1 == null && args[1] is char ch)
-                {
-                    arg1 = ch.ToString();
-                }
-
-                if (TryConvertToInt(args[0], out arg0) &&
-                    arg1 != null)
-                {
-                    return true;
-                }
-
-                return false;
-            }
-
-            private static bool TryGetArgs(object[] args, out string arg0, out int arg1)
-            {
-                arg0 = null;
-                arg1 = 0;
-
-                if (args.Length != 2)
-                {
-                    return false;
-                }
-
-                var value1 = args[1] as string;
-                arg0 = args[0] as string;
-                if (value1 != null &&
-                    arg0 != null &&
-                    int.TryParse(value1, out arg1))
-                {
-                    return true;
-                }
-
-                return false;
-            }
-
-            private static bool IsFloatingPointRepresentation(object value)
-            {
-                return value is double || (value is string str && double.TryParse(str, NumberStyles.Number | NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out double _));
-            }
-
-            private static bool TryExecuteArithmeticOverload(object[] args, Func<long, long, long> integerOperation, Func<double, double, double> realOperation, out object resultValue)
-            {
-                resultValue = null;
-
-                if (args.Length != 2)
-                {
-                    return false;
+                        return toReturn;
+                    }
                 }
 
-                if (TryConvertToLong(args[0], out long argLong0) && TryConvertToLong(args[1], out long argLong1))
+                try
                 {
-                    resultValue = integerOperation(argLong0, argLong1);
-                    return true;
+                    return _receiverType.InvokeMember(_methodMethodName, _bindingFlags, Type.DefaultBinder, objectInstance, args, CultureInfo.InvariantCulture) ?? "null";
                 }
-
-                if (TryConvertToDouble(args[0], out double argDouble0) && TryConvertToDouble(args[1], out double argDouble1))
+                catch (Exception)
                 {
-                    resultValue = realOperation(argDouble0, argDouble1);
-                    return true;
+                    // This isn't a viable option, but perhaps another set of parameters will work.
+                    return null;
                 }
-
-                return false;
-            }
-
-            [MethodImpl(MethodImplOptions.AggressiveInlining)]
-            private void LogFunctionCall(string fileName, object objectInstance, object[] args)
-            {
-                var logFile = Path.Combine(Directory.GetCurrentDirectory(), fileName);
-
-                var argSignature = args != null
-                    ? string.Join(", ", args.Select(a => a?.GetType().Name ?? "null"))
-                    : string.Empty;
-
-                File.AppendAllText(logFile, $"ReceiverType={_receiverType?.FullName}; ObjectInstanceType={objectInstance?.GetType().FullName}; MethodName={_methodMethodName}({argSignature})\n");
             }
 
             /// <summary>
@@ -5405,7 +4111,7 @@ private static object[] CoerceArguments(object[] args, ParameterInfo[] parameter
                         {
                             coercedArguments[n] = args[n].ToString().ToCharArray();
                         }
-                        else if (parameters[n].ParameterType.GetTypeInfo().IsEnum && args[n] is string && ((string)args[n]).Contains("."))
+                        else if (parameters[n].ParameterType.GetTypeInfo().IsEnum && args[n] is string v && v.Contains("."))
                         {
                             Type enumType = parameters[n].ParameterType;
                             string typeLeafName = enumType.Name + ".";
@@ -5488,7 +4194,7 @@ private string GenerateStringOfMethodExecuted(string expression, object objectIn
 
                     // We don't want to expose the real type name of our intrinsics
                     // so we'll replace it with "MSBuild"
-                    if (_receiverType == typeof(Microsoft.Build.Evaluation.IntrinsicFunctions))
+                    if (_receiverType == typeof(IntrinsicFunctions))
                     {
                         typeName = "MSBuild";
                     }
@@ -5521,7 +4227,7 @@ private string GenerateStringOfMethodExecuted(string expression, object objectIn
             /// </summary>
             private static bool IsStaticMethodAvailable(Type receiverType, string methodName)
             {
-                if (receiverType == typeof(Microsoft.Build.Evaluation.IntrinsicFunctions))
+                if (receiverType == typeof(IntrinsicFunctions))
                 {
                     // These are our intrinsic functions, so we're OK with those
                     return true;
diff --git a/src/Build/Evaluation/Expander/ArgumentParser.cs b/src/Build/Evaluation/Expander/ArgumentParser.cs
new file mode 100644
index 00000000000..ca4039aae5d
--- /dev/null
+++ b/src/Build/Evaluation/Expander/ArgumentParser.cs
@@ -0,0 +1,422 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Evaluation.Expander
+{
+    internal class ArgumentParser
+    {
+        internal static bool TryGetArgs(object[] args, out string? arg0, out string? arg1, bool enforceLength = true)
+        {
+            arg0 = null;
+            arg1 = null;
+
+            if (enforceLength && args.Length != 2)
+            {
+                return false;
+            }
+
+            if (args[0] is string value0 &&
+                args[1] is string value1)
+            {
+                arg0 = value0;
+                arg1 = value1;
+
+                return true;
+            }
+
+            return false;
+        }
+
+        internal static bool TryGetArgs(object[] args, out string? arg0, out string? arg1, out string? arg2)
+        {
+            arg0 = null;
+            arg1 = null;
+            arg2 = null;
+
+            if (args.Length != 3)
+            {
+                return false;
+            }
+
+            if (args[0] is string value0 &&
+                args[1] is string value1 &&
+                args[2] is string value2)
+            {
+                arg0 = value0;
+                arg1 = value1;
+                arg2 = value2;
+
+                return true;
+            }
+
+            return false;
+        }
+
+        internal static bool TryGetArgs(object[] args, out string? arg0, out string? arg1, out string? arg2, out string? arg3)
+        {
+            arg0 = null;
+            arg1 = null;
+            arg2 = null;
+            arg3 = null;
+
+            if (args.Length != 4)
+            {
+                return false;
+            }
+
+            if (args[0] is string value0 &&
+                args[1] is string value1 &&
+                args[2] is string value2 &&
+                args[3] is string value3)
+            {
+                arg0 = value0;
+                arg1 = value1;
+                arg2 = value2;
+                arg3 = value3;
+
+                return true;
+            }
+
+            return false;
+        }
+
+        internal static bool TryGetArgs(object[] args, out string? arg0, out string? arg1)
+        {
+            arg0 = null;
+            arg1 = null;
+
+            if (args.Length != 2)
+            {
+                return false;
+            }
+
+            if (args[0] is string value0 &&
+                args[1] is string value1)
+            {
+                arg0 = value0;
+                arg1 = value1;
+
+                return true;
+            }
+
+            return false;
+        }
+
+        internal static bool TryGetArgs(object[] args, out string? arg0, out int arg1, out int arg2)
+        {
+            arg0 = null;
+            arg1 = 0;
+            arg2 = 0;
+
+            if (args.Length != 3)
+            {
+                return false;
+            }
+
+            var value1 = args[1] as string;
+            var value2 = args[2] as string;
+            arg0 = args[0] as string;
+            if (value1 != null &&
+                value2 != null &&
+                arg0 != null &&
+                int.TryParse(value1, out arg1) &&
+                int.TryParse(value2, out arg2))
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+        internal static bool TryGetArg(object[] args, out int arg0)
+        {
+            if (args.Length != 1)
+            {
+                arg0 = 0;
+                return false;
+            }
+
+            return TryConvertToInt(args[0], out arg0);
+        }
+
+        internal static bool TryGetArg(object[] args, out Version? arg0)
+        {
+            if (args.Length != 1)
+            {
+                arg0 = default;
+                return false;
+            }
+
+            return TryConvertToVersion(args[0], out arg0);
+        }
+
+        internal static bool TryConvertToVersion(object value, out Version? arg0)
+        {
+            string? val = value as string;
+
+            if (string.IsNullOrEmpty(val) || !Version.TryParse(val, out arg0))
+            {
+                arg0 = default;
+                return false;
+            }
+
+            return true;
+        }
+
+        /// <summary>
+        /// Try to convert value to int.
+        /// </summary>
+        internal static bool TryConvertToInt(object? value, out int arg)
+        {
+            switch (value)
+            {
+                case double d:
+                    if (d >= int.MinValue && d <= int.MaxValue)
+                    {
+                        arg = Convert.ToInt32(d);
+                        if (Math.Abs(arg - d) == 0)
+                        {
+                            return true;
+                        }
+                    }
+
+                    break;
+                case long l:
+                    if (l >= int.MinValue && l <= int.MaxValue)
+                    {
+                        arg = Convert.ToInt32(l);
+                        return true;
+                    }
+
+                    break;
+                case int i:
+                    arg = i;
+                    return true;
+                case string s when int.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture.NumberFormat, out arg):
+                    return true;
+            }
+
+            arg = 0;
+            return false;
+        }
+
+        /// <summary>
+        /// Try to convert value to long.
+        /// </summary>
+        internal static bool TryConvertToLong(object? value, out long arg)
+        {
+            switch (value)
+            {
+                case double d:
+                    if (d >= long.MinValue && d <= long.MaxValue)
+                    {
+                        arg = (long)d;
+                        if (Math.Abs(arg - d) == 0)
+                        {
+                            return true;
+                        }
+                    }
+
+                    break;
+                case long l:
+                    arg = l;
+                    return true;
+                case int i:
+                    arg = i;
+                    return true;
+                case string s when long.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture.NumberFormat, out arg):
+                    return true;
+            }
+
+            arg = 0;
+            return false;
+        }
+
+        /// <summary>
+        /// Try to convert value to double.
+        /// </summary>
+        internal static bool TryConvertToDouble(object? value, out double arg)
+        {
+            switch (value)
+            {
+                case double unboxed:
+                    arg = unboxed;
+                    return true;
+                case long l:
+                    arg = l;
+                    return true;
+                case int i:
+                    arg = i;
+                    return true;
+                case string str when double.TryParse(str, NumberStyles.Number | NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out arg):
+                    return true;
+                default:
+                    arg = 0;
+                    return false;
+            }
+        }
+
+        internal static bool TryGetArg(object[] args, out string? arg0)
+        {
+            if (args.Length != 1)
+            {
+                arg0 = null;
+                return false;
+            }
+
+            arg0 = args[0] as string;
+            return arg0 != null;
+        }
+
+        internal static bool TryGetArgs(object[] args, out string? arg0, out StringComparison arg1)
+        {
+            if (args.Length != 2)
+            {
+                arg0 = null;
+                arg1 = default;
+
+                return false;
+            }
+
+            arg0 = args[0] as string;
+
+            // reject enums as ints. In C# this would require a cast, which is not supported in msbuild expressions
+            if (arg0 == null || !(args[1] is string comparisonTypeName) || int.TryParse(comparisonTypeName, out _))
+            {
+                arg1 = default;
+                return false;
+            }
+
+            // Allow fully-qualified enum, e.g. "System.StringComparison.OrdinalIgnoreCase"
+            if (comparisonTypeName.Contains('.'))
+            {
+                comparisonTypeName = comparisonTypeName.Replace("System.StringComparison.", "").Replace("StringComparison.", "");
+            }
+
+            return Enum.TryParse(comparisonTypeName, out arg1);
+        }
+
+        internal static bool TryGetArgs(object[] args, out int arg0)
+        {
+            arg0 = 0;
+
+            if (args.Length != 1)
+            {
+                return false;
+            }
+
+            return TryConvertToInt(args[0], out arg0);
+        }
+
+        internal static bool TryGetArgs(object[] args, out int arg0, out int arg1)
+        {
+            arg0 = 0;
+            arg1 = 0;
+
+            if (args.Length != 2)
+            {
+                return false;
+            }
+
+            return TryConvertToInt(args[0], out arg0) &&
+                   TryConvertToInt(args[1], out arg1);
+        }
+
+        internal static bool TryGetArgs(object[] args, out double arg0, out double arg1)
+        {
+            arg0 = 0;
+            arg1 = 0;
+
+            if (args.Length != 2)
+            {
+                return false;
+            }
+
+            return TryConvertToDouble(args[0], out arg0) &&
+                   TryConvertToDouble(args[1], out arg1);
+        }
+
+        internal static bool TryGetArgs(object[] args, out int arg0, out string? arg1)
+        {
+            arg0 = 0;
+            arg1 = null;
+
+            if (args.Length != 2)
+            {
+                return false;
+            }
+
+            arg1 = args[1] as string;
+            if (arg1 == null && args[1] is char ch)
+            {
+                arg1 = ch.ToString();
+            }
+
+            if (TryConvertToInt(args[0], out arg0) &&
+                arg1 != null)
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+        internal static bool TryGetArgs(object[] args, out string? arg0, out int arg1)
+        {
+            arg0 = null;
+            arg1 = 0;
+
+            if (args.Length != 2)
+            {
+                return false;
+            }
+
+            var value1 = args[1] as string;
+            arg0 = args[0] as string;
+            if (value1 != null &&
+                arg0 != null &&
+                int.TryParse(value1, out arg1))
+            {
+                return true;
+            }
+
+            return false;
+        }
+
+        internal static bool IsFloatingPointRepresentation(object value)
+        {
+            return value is double || (value is string str && double.TryParse(str, NumberStyles.Number | NumberStyles.Float, CultureInfo.InvariantCulture.NumberFormat, out double _));
+        }
+
+        internal static bool TryExecuteArithmeticOverload(object[] args, Func<long, long, long> integerOperation, Func<double, double, double> realOperation, out object? resultValue)
+        {
+            resultValue = null;
+
+            if (args.Length != 2)
+            {
+                return false;
+            }
+
+            if (TryConvertToLong(args[0], out long argLong0) && TryConvertToLong(args[1], out long argLong1))
+            {
+                resultValue = integerOperation(argLong0, argLong1);
+                return true;
+            }
+
+            if (TryConvertToDouble(args[0], out double argDouble0) && TryConvertToDouble(args[1], out double argDouble1))
+            {
+                resultValue = realOperation(argDouble0, argDouble1);
+                return true;
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/src/Build/Evaluation/Expander/WellKnownFunctions.cs b/src/Build/Evaluation/Expander/WellKnownFunctions.cs
new file mode 100644
index 00000000000..72f8b247933
--- /dev/null
+++ b/src/Build/Evaluation/Expander/WellKnownFunctions.cs
@@ -0,0 +1,951 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+
+using ParseArgs = Microsoft.Build.Evaluation.Expander.ArgumentParser;
+
+
+namespace Microsoft.Build.Evaluation.Expander
+{
+    internal class WellKnownFunctions
+    {
+
+        internal static bool ElementsOfType(object[] args, Type type)
+        {
+            for (var i = 0; i < args.Length; i++)
+            {
+                if (args[i].GetType() != type)
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        internal static void LogFunctionCall(Type receiverType, string methodName, string fileName, object? objectInstance, object[] args)
+        {
+            var logFile = Path.Combine(Directory.GetCurrentDirectory(), fileName);
+
+            var argSignature = args != null
+                ? string.Join(", ", args.Select(a => a?.GetType().Name ?? "null"))
+                : string.Empty;
+
+            File.AppendAllText(logFile, $"ReceiverType={receiverType?.FullName}; ObjectInstanceType={objectInstance?.GetType().FullName}; MethodName={methodName}({argSignature})\n");
+        }
+
+        internal static bool TryExecutePathFunction(string methodName, out object? returnVal, object[] args)
+        {
+            returnVal = default;
+            if (string.Equals(methodName, nameof(Path.Combine), StringComparison.OrdinalIgnoreCase))
+            {
+                string? arg0, arg1, arg2, arg3;
+
+                // Combine has fast implementations for up to 4 parameters: https://github.com/dotnet/corefx/blob/2c55db90d622fa6279184e6243f0470a3755d13c/src/Common/src/CoreLib/System/IO/Path.cs#L293-L317
+                switch (args.Length)
+                {
+                    case 0:
+                        return false;
+                    case 1:
+                        if (ParseArgs.TryGetArg(args, out arg0) && arg0 != null)
+                        {
+                            returnVal = Path.Combine(arg0);
+                            return true;
+                        }
+                        break;
+                    case 2:
+                        if (ParseArgs.TryGetArgs(args, out arg0, out arg1) && arg0 != null && arg1 != null)
+                        {
+                            returnVal = Path.Combine(arg0, arg1);
+                            return true;
+                        }
+                        break;
+                    case 3:
+                        if (ParseArgs.TryGetArgs(args, out arg0, out arg1, out arg2) && arg0 != null && arg1 != null && arg2 != null)
+                        {
+                            returnVal = Path.Combine(arg0, arg1, arg2);
+                            return true;
+                        }
+                        break;
+                    case 4:
+                        if (ParseArgs.TryGetArgs(args, out arg0, out arg1, out arg2, out arg3) && arg0 != null && arg1 != null && arg2 != null && arg3 != null)
+                        {
+                            returnVal = Path.Combine(arg0, arg1, arg2, arg3);
+                            return true;
+                        }
+                        break;
+                    default:
+                        if (ElementsOfType(args, typeof(string)))
+                        {
+                            returnVal = Path.Combine(Array.ConvertAll(args, o => (string)o));
+                            return true;
+                        }
+                        break;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Path.DirectorySeparatorChar), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = Path.DirectorySeparatorChar;
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Path.GetFullPath), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = Path.GetFullPath(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Path.IsPathRooted), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = Path.IsPathRooted(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Path.GetTempPath), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = Path.GetTempPath();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Path.GetFileName), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = Path.GetFileName(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Path.GetDirectoryName), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = Path.GetDirectoryName(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Path.GetFileNameWithoutExtension), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = Path.GetFileNameWithoutExtension(arg0);
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        /// <summary>
+        /// Handler for executing well known string functions
+        /// </summary>
+        /// <param name="methodName"></param>
+        /// <param name="returnVal"></param>
+        /// <param name="text"></param>
+        /// <param name="args"></param>
+        /// <returns></returns>
+        internal static bool TryExecuteStringFunction(string methodName, out object? returnVal, string text, object[] args)
+        {
+            returnVal = null;
+            if (string.Equals(methodName, nameof(string.StartsWith), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = text.StartsWith(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.Replace), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1) && arg0 != null)
+                {
+                    returnVal = text.Replace(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.Contains), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = text.Contains(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.ToUpperInvariant), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = text.ToUpperInvariant();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.ToLowerInvariant), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = text.ToLowerInvariant();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.EndsWith), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = text.EndsWith(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.ToLower), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = text.ToLower();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.IndexOf), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out StringComparison arg1) && arg0 != null)
+                {
+                    returnVal = text.IndexOf(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.IndexOfAny), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = text.IndexOfAny(arg0.ToCharArray());
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.LastIndexOf), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = text.LastIndexOf(arg0);
+                    return true;
+                }
+                else if (ParseArgs.TryGetArgs(args, out arg0, out int startIndex) && arg0 != null)
+                {
+                    returnVal = text.LastIndexOf(arg0, startIndex);
+                    return true;
+                }
+                else if (ParseArgs.TryGetArgs(args, out arg0, out StringComparison arg1) && arg0 != null)
+                {
+                    returnVal = text.LastIndexOf(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.LastIndexOfAny), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = text.LastIndexOfAny(arg0.ToCharArray());
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.Length), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = text.Length;
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.Substring), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out int startIndex))
+                {
+                    returnVal = text.Substring(startIndex);
+                    return true;
+                }
+                else if (ParseArgs.TryGetArgs(args, out startIndex, out int length))
+                {
+                    returnVal = text.Substring(startIndex, length);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.Split), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? separator) && separator?.Length == 1)
+                {
+                    returnVal = text.Split(separator[0]);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.PadLeft), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out int totalWidth))
+                {
+                    returnVal = text.PadLeft(totalWidth);
+                    return true;
+                }
+                else if (ParseArgs.TryGetArgs(args, out totalWidth, out string? paddingChar) && paddingChar?.Length == 1)
+                {
+                    returnVal = text.PadLeft(totalWidth, paddingChar[0]);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.PadRight), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out int totalWidth))
+                {
+                    returnVal = text.PadRight(totalWidth);
+                    return true;
+                }
+                else if (ParseArgs.TryGetArgs(args, out totalWidth, out string? paddingChar) && paddingChar?.Length == 1)
+                {
+                    returnVal = text.PadRight(totalWidth, paddingChar[0]);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.TrimStart), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? trimChars) && trimChars?.Length > 0)
+                {
+                    returnVal = text.TrimStart(trimChars.ToCharArray());
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.TrimEnd), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? trimChars) && trimChars?.Length > 0)
+                {
+                    returnVal = text.TrimEnd(trimChars.ToCharArray());
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, "get_Chars", StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out int index))
+                {
+                    returnVal = text[index];
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(string.Equals), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = text.Equals(arg0);
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        internal static bool TryExecuteIntrinsicFunction(string methodName, out object? returnVal, IFileSystem fileSystem, object[] args)
+        {
+            returnVal = default;
+            if (string.Equals(methodName, nameof(IntrinsicFunctions.EnsureTrailingSlash), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.EnsureTrailingSlash(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.ValueOrDefault), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.ValueOrDefault(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.NormalizePath), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ElementsOfType(args, typeof(string)))
+                {
+                    returnVal = IntrinsicFunctions.NormalizePath(Array.ConvertAll(args, o => (string)o));
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetDirectoryNameOfFileAbove), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.GetDirectoryNameOfFileAbove(arg0, arg1, fileSystem);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetRegistryValueFromView), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length >= 4 &&
+                    ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.GetRegistryValueFromView(arg0, arg1, args[2], new ArraySegment<object>(args, 3, args.Length - 3));
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.IsRunningFromVisualStudio), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.IsRunningFromVisualStudio();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.Escape), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.Escape(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.Unescape), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.Unescape(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetPathOfFileAbove), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.GetPathOfFileAbove(arg0, arg1, fileSystem);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.Add), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryExecuteArithmeticOverload(args, IntrinsicFunctions.Add, IntrinsicFunctions.Add, out returnVal))
+                {
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.Subtract), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryExecuteArithmeticOverload(args, IntrinsicFunctions.Subtract, IntrinsicFunctions.Subtract, out returnVal))
+                {
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.Multiply), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryExecuteArithmeticOverload(args, IntrinsicFunctions.Multiply, IntrinsicFunctions.Multiply, out returnVal))
+                {
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.Divide), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryExecuteArithmeticOverload(args, IntrinsicFunctions.Divide, IntrinsicFunctions.Divide, out returnVal))
+                {
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.Modulo), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryExecuteArithmeticOverload(args, IntrinsicFunctions.Modulo, IntrinsicFunctions.Modulo, out returnVal))
+                {
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetCurrentToolsDirectory), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.GetCurrentToolsDirectory();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetToolsDirectory32), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.GetToolsDirectory32();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetToolsDirectory64), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.GetToolsDirectory64();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetMSBuildSDKsPath), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.GetMSBuildSDKsPath();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetVsInstallRoot), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.GetVsInstallRoot();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetMSBuildExtensionsPath), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.GetMSBuildExtensionsPath();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetProgramFiles32), StringComparison.OrdinalIgnoreCase))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = IntrinsicFunctions.GetProgramFiles32();
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.VersionEquals), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.VersionEquals(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.VersionNotEquals), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.VersionNotEquals(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.VersionGreaterThan), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.VersionGreaterThan(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.VersionGreaterThanOrEquals), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.VersionGreaterThanOrEquals(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.VersionLessThan), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.VersionLessThan(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.VersionLessThanOrEquals), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.VersionLessThanOrEquals(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetTargetFrameworkIdentifier), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.GetTargetFrameworkIdentifier(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetTargetFrameworkVersion), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.GetTargetFrameworkVersion(arg0);
+                    return true;
+                }
+                if (ParseArgs.TryGetArgs(args, out string? arg1, out int arg2))
+                {
+                    returnVal = IntrinsicFunctions.GetTargetFrameworkVersion(arg1, arg2);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.IsTargetFrameworkCompatible), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out string? arg1))
+                {
+                    returnVal = IntrinsicFunctions.IsTargetFrameworkCompatible(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetTargetPlatformIdentifier), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.GetTargetPlatformIdentifier(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.GetTargetPlatformVersion), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.GetTargetPlatformVersion(arg0);
+                    return true;
+                }
+                if (ParseArgs.TryGetArgs(args, out string? arg1, out int arg2))
+                {
+                    returnVal = IntrinsicFunctions.GetTargetPlatformVersion(arg1, arg2);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.ConvertToBase64), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.ConvertToBase64(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.ConvertFromBase64), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.ConvertFromBase64(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.StableStringHash), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    // Prevent loading methods refs from StringTools if ChangeWave opted out.
+                    returnVal = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)
+                        ? IntrinsicFunctions.StableStringHash(arg0)
+                        : IntrinsicFunctions.StableStringHashLegacy(arg0);
+                    return true;
+                }
+                else if (ParseArgs.TryGetArgs(args, out string? arg1, out string? arg2) && Enum.TryParse<IntrinsicFunctions.StringHashingAlgorithm>(arg2, true, out var hashAlgorithm) && arg1 != null && arg2 != null)
+                {
+                    returnVal = IntrinsicFunctions.StableStringHash(arg1, hashAlgorithm);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.AreFeaturesEnabled), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out Version? arg0) && arg0 != null)
+                {
+                    returnVal = IntrinsicFunctions.AreFeaturesEnabled(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.SubstringByAsciiChars), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out string? arg0, out int arg1, out int arg2) && arg0 != null)
+                {
+                    returnVal = IntrinsicFunctions.SubstringByAsciiChars(arg0, arg1, arg2);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.CheckFeatureAvailability), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = IntrinsicFunctions.CheckFeatureAvailability(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.BitwiseOr), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out int arg0, out int arg1))
+                {
+                    returnVal = IntrinsicFunctions.BitwiseOr(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.BitwiseAnd), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out int arg0, out int arg1))
+                {
+                    returnVal = IntrinsicFunctions.BitwiseAnd(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.BitwiseXor), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out int arg0, out int arg1))
+                {
+                    returnVal = IntrinsicFunctions.BitwiseXor(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.BitwiseNot), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out int arg0))
+                {
+                    returnVal = IntrinsicFunctions.BitwiseNot(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.LeftShift), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out int arg0, out int arg1))
+                {
+                    returnVal = IntrinsicFunctions.LeftShift(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.RightShift), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out int arg0, out int arg1))
+                {
+                    returnVal = IntrinsicFunctions.RightShift(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.RightShiftUnsigned), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArgs(args, out int arg0, out int arg1))
+                {
+                    returnVal = IntrinsicFunctions.RightShiftUnsigned(arg0, arg1);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.NormalizeDirectory), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = IntrinsicFunctions.NormalizeDirectory(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.IsOSPlatform), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = IntrinsicFunctions.IsOSPlatform(arg0);
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        /// <summary>
+        /// Shortcut to avoid calling into binding if we recognize some most common functions.
+        /// Binding is expensive and throws first-chance MissingMethodExceptions, which is
+        /// bad for debugging experience and has a performance cost.
+        /// A typical binding operation with exception can take ~1.500 ms; this call is ~0.050 ms
+        /// (rough numbers just for comparison).
+        /// See https://github.com/dotnet/msbuild/issues/2217.
+        /// </summary>
+        /// <param name="methodName"> </param>
+        /// <param name="receiverType"> </param>
+        /// <param name="fileSystem"> </param>
+        /// <param name="returnVal">The value returned from the function call.</param>
+        /// <param name="objectInstance">Object that the function is called on.</param>
+        /// <param name="args">arguments.</param>
+        /// <returns>True if the well known function call binding was successful.</returns>
+        internal static bool TryExecuteWellKnownFunction(string methodName, Type receiverType, IFileSystem fileSystem, out object? returnVal, object objectInstance, object[] args)
+        {
+            returnVal = null;
+
+            if (objectInstance is string text)
+            {
+                return TryExecuteStringFunction(methodName, out returnVal, text, args);
+            }
+            else if (objectInstance is string[] stringArray)
+            {
+                if (string.Equals(methodName, "GetValue", StringComparison.OrdinalIgnoreCase))
+                {
+                    if (ParseArgs.TryGetArg(args, out int index))
+                    {
+                        returnVal = stringArray[index];
+                        return true;
+                    }
+                }
+            }
+            else if (objectInstance == null) // Calling a well-known static function
+            {
+                if (receiverType == typeof(string))
+                {
+                    if (string.Equals(methodName, nameof(string.IsNullOrWhiteSpace), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (ParseArgs.TryGetArg(args, out string? arg0))
+                        {
+                            returnVal = string.IsNullOrWhiteSpace(arg0);
+                            return true;
+                        }
+                    }
+                    else if (string.Equals(methodName, nameof(string.IsNullOrEmpty), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (ParseArgs.TryGetArg(args, out string? arg0))
+                        {
+                            returnVal = string.IsNullOrEmpty(arg0);
+                            return true;
+                        }
+                    }
+                    else if (string.Equals(methodName, nameof(string.Copy), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (ParseArgs.TryGetArg(args, out string? arg0))
+                        {
+                            returnVal = arg0;
+                            return true;
+                        }
+                    }
+                }
+                else if (receiverType == typeof(Math))
+                {
+                    if (string.Equals(methodName, nameof(Math.Max), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (ParseArgs.TryGetArgs(args, out double arg0, out double arg1))
+                        {
+                            returnVal = Math.Max(arg0, arg1);
+                            return true;
+                        }
+                    }
+                    else if (string.Equals(methodName, nameof(Math.Min), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (ParseArgs.TryGetArgs(args, out double arg0, out double arg1))
+                        {
+                            returnVal = Math.Min(arg0, arg1);
+                            return true;
+                        }
+                    }
+                }
+                else if (receiverType == typeof(IntrinsicFunctions))
+                {
+                    return TryExecuteIntrinsicFunction(methodName, out returnVal, fileSystem, args);
+                }
+                else if (receiverType == typeof(Path))
+                {
+                    return TryExecutePathFunction(methodName, out returnVal, args);
+                }
+                else if (receiverType == typeof(Version))
+                {
+                    if (string.Equals(methodName, nameof(Version.Parse), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                        {
+                            returnVal = Version.Parse(arg0);
+                            return true;
+                        }
+                    }
+                }
+                else if (receiverType == typeof(Guid))
+                {
+                    if (string.Equals(methodName, nameof(Guid.NewGuid), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (args.Length == 0)
+                        {
+                            returnVal = Guid.NewGuid();
+                            return true;
+                        }
+                    }
+                }
+                else if (string.Equals(methodName, nameof(Regex.Replace), StringComparison.OrdinalIgnoreCase) && args.Length == 3)
+                {
+                    if (ParseArgs.TryGetArgs(args, out string? arg1, out string? arg2, out string? arg3) && arg1 != null && arg2 != null && arg3 != null)
+                    {
+                        returnVal = Regex.Replace(arg1, arg2, arg3);
+                        return true;
+                    }
+                }
+            }
+            else if (string.Equals(methodName, nameof(Version.ToString), StringComparison.OrdinalIgnoreCase) && objectInstance is Version v)
+            {
+                if (ParseArgs.TryGetArg(args, out int arg0))
+                {
+                    returnVal = v.ToString(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(Int32.ToString), StringComparison.OrdinalIgnoreCase) && objectInstance is int i)
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = i.ToString(arg0);
+                    return true;
+                }
+            }
+            if (Traits.Instance.LogPropertyFunctionsRequiringReflection)
+            {
+                LogFunctionCall(receiverType, methodName, "PropertyFunctionsRequiringReflection", objectInstance, args);
+            }
+
+            return false;
+        }
+
+        internal static bool TryExecuteWellKnownFunctionWithPropertiesParam<T>(string methodName, Type receiverType, LoggingContext loggingContext,
+                                                                            IPropertyProvider<T> properties, out object? returnVal, object objectInstance, object[] args)
+            where T : class, IProperty
+        {
+            returnVal = null;
+
+            if (receiverType == typeof(IntrinsicFunctions))
+            {
+                if (string.Equals(methodName, nameof(IntrinsicFunctions.RegisterBuildCheck), StringComparison.OrdinalIgnoreCase))
+                {
+                    string projectPath = properties.GetProperty("MSBuildProjectFullPath")?.EvaluatedValue ?? string.Empty;
+                    ErrorUtilities.VerifyThrow(loggingContext != null, $"The logging context is missed. {nameof(IntrinsicFunctions.RegisterBuildCheck)} can not be invoked.");
+                    if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                    {
+                        returnVal = IntrinsicFunctions.RegisterBuildCheck(projectPath, arg0, loggingContext);
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+
+        /// <summary>
+        /// Shortcut to avoid calling into binding if we recognize some most common constructors.
+        /// Analogous to TryExecuteWellKnownFunction but guaranteed to not throw.
+        /// </summary>
+        /// <param name="receiverType"> Receiver type for the constructor. </param>
+        /// <param name="returnVal">The instance as created by the constructor call.</param>
+        /// <param name="args">Arguments.</param>
+        /// <returns>True if the well known constructor call binding was successful.</returns>
+        internal static bool TryExecuteWellKnownConstructorNoThrow(Type? receiverType, out object? returnVal, object[] args)
+        {
+            returnVal = null;
+
+            if (receiverType == typeof(string))
+            {
+                if (args.Length == 0)
+                {
+                    returnVal = String.Empty;
+                    return true;
+                }
+                if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
+                {
+                    returnVal = arg0;
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+}
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index 212f446d70f..82ad36d6650 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -268,7 +268,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, BackEnd.Logging.LoggingContext loggingContext, bool isEnvironmentVariable = false);
+        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, BackEnd.Logging.LoggingContext loggingContext, bool isEnvironmentVariable = false, bool isCommandLineProperty = false);
 
         /// <summary>
         /// Sets a property which comes from the Xml.
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index da988bfdeaf..032f95a251c 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -31,13 +31,33 @@ namespace Microsoft.Build.Evaluation
     /// The Intrinsic class provides static methods that can be accessed from MSBuild's
     /// property functions using $([MSBuild]::Function(x,y)).
     /// </summary>
-    internal static class IntrinsicFunctions
+    internal static partial class IntrinsicFunctions
     {
+        // lang=regex
+        private const string RegistrySdkSpecification = @"^HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Microsoft SDKs\\Windows\\v(\d+\.\d+)$";
+
 #pragma warning disable CA1416 // Platform compatibility: we'll only use this on Windows
         private static readonly object[] DefaultRegistryViews = [RegistryView.Default];
 #pragma warning restore CA1416
 
-        private static readonly Lazy<Regex> RegistrySdkRegex = new Lazy<Regex>(() => new Regex(@"^HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Microsoft SDKs\\Windows\\v(\d+\.\d+)$", RegexOptions.IgnoreCase));
+#if NET7_0_OR_GREATER
+        [GeneratedRegex(RegistrySdkSpecification, RegexOptions.IgnoreCase)]
+        private static partial Regex RegistrySdkPattern();
+#else
+        private static readonly Lazy<Regex> RegistrySdkPattern = new Lazy<Regex>(() => new Regex(RegistrySdkSpecification, RegexOptions.IgnoreCase));
+#endif
+
+        private static Regex RegistrySdkRegex
+        {
+            get
+            {
+#if NET7_0_OR_GREATER
+                return RegistrySdkPattern();
+#else
+                return RegistrySdkPattern.Value;
+#endif
+            }
+        }
 
         private static readonly Lazy<NuGetFrameworkWrapper> NuGetFramework = new Lazy<NuGetFrameworkWrapper>(() => NuGetFrameworkWrapper.CreateInstance());
 
@@ -279,7 +299,7 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
                         // Fake common requests to HKLM that we can resolve
 
                         // See if this asks for a specific SDK
-                        var m = RegistrySdkRegex.Value.Match(keyName);
+                        var m = RegistrySdkRegex.Match(keyName);
 
                         if (m.Success && m.Groups.Count >= 1 && valueName.Equals("InstallRoot", StringComparison.OrdinalIgnoreCase))
                         {
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 5d749befd8d..b4685fa40d4 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -311,9 +311,9 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
                 return _wrappedData.SetProperty(propertyElement, evaluatedValueEscaped, loggingContext);
             }
 
-            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable = false)
+            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable = false, bool isCommandLineProperty = false)
             {
-                return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext: loggingContext);
+                return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext: loggingContext, isCommandLineProperty);
             }
         }
     }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 16e9586a71b..d56d20dddde 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -384,7 +384,7 @@ private static OrderedItemDataCollection.Builder ComputeItems(LazyItemList lazyI
                                 break;
                             }
 
-                            string fullPath = FileUtilities.GetFullPath(frag.TextFragment, frag.ProjectDirectory);
+                            string fullPath = FileUtilities.NormalizePathForComparisonNoThrow(frag.TextFragment, frag.ProjectDirectory);
                             if (itemsWithNoWildcards.ContainsKey(fullPath))
                             {
                                 // Another update will already happen on this path. Make that happen before evaluating this one.
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index e086298a380..d70e5648f3e 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -674,7 +674,7 @@ private void DebugTraceCache(string message, string param1)
             if (s_debugLogCacheActivity)
             {
                 string prefix = OutOfProcNode.IsOutOfProcNode ? "C" : "P";
-                Trace.WriteLine(prefix + " " + Process.GetCurrentProcess().Id + " | " + message + param1);
+                Trace.WriteLine(prefix + " " + EnvironmentUtilities.CurrentProcessId + " | " + message + param1);
             }
         }
     }
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 1e9861f742b..c7b8ae0d6ad 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -87,16 +87,23 @@ public P GetProperty(string name, int startIndex, int endIndex)
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable = false)
+        public P SetProperty(
+            string name,
+            string evaluatedValueEscaped,
+            bool isGlobalProperty,
+            bool mayBeReserved,
+            LoggingContext loggingContext,
+            bool isEnvironmentVariable = false,
+            bool isCommandLineProperty = false)
         {
             P? originalProperty = _wrapped.GetProperty(name);
-            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, _evaluationLoggingContext, isEnvironmentVariable);
+            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, _evaluationLoggingContext, isEnvironmentVariable, isCommandLineProperty);
 
             this.TrackPropertyWrite(
                 originalProperty,
                 newProperty,
                 null,
-                this.DeterminePropertySource(isGlobalProperty, mayBeReserved, isEnvironmentVariable),
+                this.DeterminePropertySource(isGlobalProperty, mayBeReserved, isEnvironmentVariable, isCommandLineProperty),
                 loggingContext);
 
             return newProperty;
@@ -168,13 +175,10 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
         #region Private Methods...
 
         private bool IsPropertyReadTrackingRequested
-            => IsEnvironmentVariableReadTrackingRequested ||
-               (_settings & PropertyTrackingSetting.UninitializedPropertyRead) ==
-               PropertyTrackingSetting.UninitializedPropertyRead;
+            => IsEnvironmentVariableReadTrackingRequested
+            || PropertyTrackingUtils.IsPropertyTrackingEnabled(_settings, PropertyTrackingSetting.UninitializedPropertyRead);
 
-        private bool IsEnvironmentVariableReadTrackingRequested
-            => (_settings & PropertyTrackingSetting.EnvironmentVariableRead) ==
-               PropertyTrackingSetting.EnvironmentVariableRead;
+        private bool IsEnvironmentVariableReadTrackingRequested => PropertyTrackingUtils.IsPropertyTrackingEnabled(_settings, PropertyTrackingSetting.EnvironmentVariableRead);
 
         /// <summary>
         /// Logic containing what to do when a property is read.
@@ -209,7 +213,7 @@ private void TrackPropertyRead(string name, P property)
         /// <param name="name">The name of the environment variable read.</param>
         private void TrackEnvironmentVariableRead(string name)
         {
-            if ((_settings & PropertyTrackingSetting.EnvironmentVariableRead) != PropertyTrackingSetting.EnvironmentVariableRead)
+            if (!IsEnvironmentVariableReadTrackingRequested)
             {
                 return;
             }
@@ -231,15 +235,15 @@ private void TrackEnvironmentVariableRead(string name)
         /// <param name="name">The name of the uninitialized property read.</param>
         private void TrackUninitializedPropertyRead(string name)
         {
-            if ((_settings & PropertyTrackingSetting.UninitializedPropertyRead) != PropertyTrackingSetting.UninitializedPropertyRead)
+            if (!PropertyTrackingUtils.IsPropertyTrackingEnabled(_settings, PropertyTrackingSetting.UninitializedPropertyRead))
             {
                 return;
             }
 
-            var args = new UninitializedPropertyReadEventArgs(
-                name,
-                ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("UninitializedPropertyRead", name));
-            args.BuildEventContext = _evaluationLoggingContext.BuildEventContext;
+            var args = new UninitializedPropertyReadEventArgs(name, message: null)
+            {
+                BuildEventContext = _evaluationLoggingContext.BuildEventContext,
+            };
 
             _evaluationLoggingContext.LogBuildEvent(args);
         }
@@ -258,12 +262,12 @@ private void TrackPropertyWrite(
             if (predecessor == null)
             {
                 // If this property had no previous value, then track an initial value.
-                TrackPropertyInitialValueSet(property, source);
+                TrackPropertyInitialValueSet(property, source, location);
             }
             else
             {
                 // There was a previous value, and it might have been changed. Track that.
-                TrackPropertyReassignment(predecessor, property, location?.LocationString);
+                TrackPropertyReassignment(predecessor, property, location);
             }
 
             // If this property was an environment variable but no longer is, track it.
@@ -278,19 +282,25 @@ private void TrackPropertyWrite(
         /// </summary>
         /// <param name="property">The property being set.</param>
         /// <param name="source">The source of the property.</param>
-        private void TrackPropertyInitialValueSet(P property, PropertySource source)
+        /// <param name="location">The exact location of the property. Can be null if comes not form xml.</param>
+        private void TrackPropertyInitialValueSet(P property, PropertySource source, IElementLocation? location)
         {
-            if ((_settings & PropertyTrackingSetting.PropertyInitialValueSet) != PropertyTrackingSetting.PropertyInitialValueSet)
+            if (!PropertyTrackingUtils.IsPropertyTrackingEnabled(_settings, PropertyTrackingSetting.PropertyInitialValueSet))
             {
                 return;
             }
 
             var args = new PropertyInitialValueSetEventArgs(
-                    property.Name,
-                    property.EvaluatedValue,
-                    source.ToString(),
-                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("PropertyAssignment", property.Name, property.EvaluatedValue, source));
-            args.BuildEventContext = _evaluationLoggingContext.BuildEventContext;
+                property.Name,
+                property.EvaluatedValue,
+
+                // If the property is from XML, we don't need property source since a full location is available.
+                location == null ? GetPropertySourceName(source) : string.Empty,
+                location?.File,
+                location?.Line ?? 0,
+                location?.Column ?? 0,
+                message: null)
+            { BuildEventContext = _evaluationLoggingContext.BuildEventContext, };
 
             _evaluationLoggingContext.LogBuildEvent(args);
         }
@@ -301,7 +311,7 @@ private void TrackPropertyInitialValueSet(P property, PropertySource source)
         /// <param name="predecessor">The property's preceding state. Null if none.</param>
         /// <param name="property">The property's current state.</param>
         /// <param name="location">The location of this property's reassignment.</param>
-        private void TrackPropertyReassignment(P? predecessor, P property, string? location)
+        private void TrackPropertyReassignment(P? predecessor, P property, IElementLocation? location)
         {
             if (MSBuildNameIgnoreCaseComparer.Default.Equals(property.Name, "MSBuildAllProjects"))
             {
@@ -317,17 +327,17 @@ private void TrackPropertyReassignment(P? predecessor, P property, string? locat
                 return;
             }
 
-            // Either we want to specifically track property reassignments
-            // or we do not want to track nothing - in which case the prop reassignment is enabled by default.
-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) == PropertyTrackingSetting.PropertyReassignment ||
-                (_settings == 0 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)))
+            if (PropertyTrackingUtils.IsPropertyReassignmentEnabled(_settings))
             {
                 var args = new PropertyReassignmentEventArgs(
-                        property.Name,
-                        oldValue,
-                        newValue,
-                        location,
-                        message: null)
+                    property.Name,
+                    oldValue,
+                    newValue,
+                    location: null,
+                    location?.File,
+                    location?.Line ?? 0,
+                    location?.Column ?? 0,
+                    message: null)
                 { BuildEventContext = _evaluationLoggingContext.BuildEventContext, };
 
                 _evaluationLoggingContext.LogBuildEvent(args);
@@ -347,7 +357,7 @@ private void TrackPropertyReassignment(P? predecessor, P property, string? locat
         /// <summary>
         /// Determines the source of a property given the variables SetProperty arguments provided. This logic follows what's in <see cref="Evaluator{P,I,M,D}"/>.
         /// </summary>
-        private PropertySource DeterminePropertySource(bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable)
+        private PropertySource DeterminePropertySource(bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable, bool isCommandLineProperty)
         {
             if (isEnvironmentVariable)
             {
@@ -356,7 +366,7 @@ private PropertySource DeterminePropertySource(bool isGlobalProperty, bool mayBe
 
             if (isGlobalProperty)
             {
-                return PropertySource.Global;
+                return isCommandLineProperty ? PropertySource.CommandLine : PropertySource.Global;
             }
 
             return mayBeReserved ? PropertySource.BuiltIn : PropertySource.Toolset;
@@ -373,20 +383,107 @@ private enum PropertySource
             BuiltIn,
             Global,
             Toolset,
-            EnvironmentVariable
+            EnvironmentVariable,
+            CommandLine,
         }
 
-        [Flags]
-        private enum PropertyTrackingSetting
+        private static string GetPropertySourceName(PropertySource source) => source switch
         {
-            None = 0,
+            PropertySource.Xml => "Xml",
+            PropertySource.BuiltIn => "BuiltIn",
+            PropertySource.Global => "Global",
+            PropertySource.Toolset => "Toolset",
+            PropertySource.EnvironmentVariable => "EnvironmentVariable",
+            PropertySource.CommandLine => "CommandLine",
+            _ => throw new ArgumentOutOfRangeException(nameof(source), source, null)
+        };
+    }
+
+    [Flags]
+    internal enum PropertyTrackingSetting
+    {
+        None = 0,
+
+        PropertyReassignment = 1,
+        PropertyInitialValueSet = 1 << 1,
+        EnvironmentVariableRead = 1 << 2,
+        UninitializedPropertyRead = 1 << 3,
+
+        All = PropertyReassignment | PropertyInitialValueSet | EnvironmentVariableRead | UninitializedPropertyRead
+    }
 
-            PropertyReassignment = 1,
-            PropertyInitialValueSet = 1 << 1,
-            EnvironmentVariableRead = 1 << 2,
-            UninitializedPropertyRead = 1 << 3,
+    internal class PropertyTrackingUtils
+    {
+        /// <summary>
+        /// Determines if a specific property tracking setting is enabled within the provided settings configuration.
+        /// </summary>
+        /// <param name="settings">The combined property tracking settings value to check against.</param>
+        /// <param name="currentTrackingSetting">The specific tracking setting to verify.</param>
+        /// <returns>true if the specified tracking setting is enabled in the settings configuration.</returns>
+        internal static bool IsPropertyTrackingEnabled(PropertyTrackingSetting settings, PropertyTrackingSetting currentTrackingSetting) => (settings & currentTrackingSetting) == currentTrackingSetting;
 
-            All = PropertyReassignment | PropertyInitialValueSet | EnvironmentVariableRead | UninitializedPropertyRead
+        // Either we want to specifically track property reassignments
+        // or we do not want to track nothing - in which case the prop reassignment is enabled by default.
+        internal static bool IsPropertyReassignmentEnabled(PropertyTrackingSetting currentTrackingSetting) => IsPropertyTrackingEnabled(currentTrackingSetting, PropertyTrackingSetting.PropertyReassignment)
+                || (currentTrackingSetting == PropertyTrackingSetting.None && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10));
+
+        /// <summary>
+        /// Logs property assignment information during execution, providing detailed tracking of property value changes.
+        /// This internal method handles two scenarios:
+        /// 1. Initial property value assignment (when previousPropertyValue is null)
+        /// 2. Property value reassignment (when previousPropertyValue has a value)
+        /// If property tracking is disabled (PropertyTrackingSetting.None), no logging occurs.
+        /// </summary>
+        /// <param name="settings">Controls what types of property assignments should be tracked.</param>
+        /// <param name="propertyName">Name of the property being modified.</param>
+        /// <param name="propertyValue">New value being assigned to the property.</param>
+        /// <param name="location">Source location information (file, line, column).</param>
+        /// <param name="previousPropertyValue">Previous value of the property, null if this is initial assignment.</param>
+        /// <param name="loggingContext">Context for logging build events.</param>
+        internal static void LogPropertyAssignment(
+            PropertyTrackingSetting settings,
+            string propertyName,
+            string propertyValue,
+            IElementLocation location,
+            string? previousPropertyValue,
+            LoggingContext loggingContext)
+        {
+            if (previousPropertyValue == null)
+            {
+                if (IsPropertyTrackingEnabled(settings, PropertyTrackingSetting.PropertyInitialValueSet))
+                {
+                    var args = new PropertyInitialValueSetEventArgs(
+                        propertyName,
+                        propertyValue,
+                        propertySource: string.Empty,
+                        location.File,
+                        location.Line,
+                        location.Column,
+                        message: null) { BuildEventContext = loggingContext.BuildEventContext };
+
+                    loggingContext.LogBuildEvent(args);
+                }
+            }
+            else
+            {
+                if (IsPropertyReassignmentEnabled(settings))
+                {
+                    if (propertyValue != previousPropertyValue)
+                    {
+                        var args = new PropertyReassignmentEventArgs(
+                            propertyName,
+                            previousPropertyValue,
+                            propertyValue,
+                            location: null,
+                            location.File,
+                            location.Line,
+                            location.Column,
+                            message: null) { BuildEventContext = loggingContext.BuildEventContext, };
+
+                        loggingContext.LogBuildEvent(args);
+                    }
+                }
+            }
         }
     }
 }
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index 40531c06c2e..d927eaa7e8c 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -556,7 +556,7 @@ public bool RequiresTransitiveProjectReferences(ProjectGraphNode projectGraphNod
             // special case for Quickbuild which updates msbuild binaries independent of props/targets. Remove this when all QB repos will have
             // migrated to new enough Visual Studio versions whose Microsoft.Managed.After.Targets enable transitive references.
             if (string.IsNullOrWhiteSpace(projectInstance.GetEngineRequiredPropertyValue(AddTransitiveProjectReferencesInStaticGraphPropertyName)) &&
-                MSBuildStringIsTrue(projectInstance.GetEngineRequiredPropertyValue("UsingMicrosoftNETSdk")) &&
+                MSBuildStringIsTrue(projectInstance.GetEngineRequiredPropertyValue(PropertyNames.UsingMicrosoftNETSdk)) &&
                 MSBuildStringIsFalse(projectInstance.GetEngineRequiredPropertyValue("DisableTransitiveProjectReferences")))
             {
                 return true;
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index e5eba2b291e..938fcc5cba9 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -1791,7 +1791,7 @@ IItemDefinition<ProjectMetadataInstance> IEvaluatorData<ProjectPropertyInstance,
         /// immutable if we are immutable.
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
-        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable)
+        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable, bool isCommandLineProperty)
         {
             // Mutability not verified as this is being populated during evaluation
             ProjectPropertyInstance property = ProjectPropertyInstance.Create(name, evaluatedValueEscaped, mayBeReserved, _isImmutable, isEnvironmentVariable, loggingContext);
@@ -3175,6 +3175,7 @@ private void Initialize(
                 projectLoadSettings ?? buildParameters.ProjectLoadSettings, /* Use override ProjectLoadSettings if specified */
                 buildParameters.MaxNodeCount,
                 buildParameters.EnvironmentPropertiesInternal,
+                buildParameters.PropertiesFromCommandLine,
                 loggingService,
                 new ProjectItemInstanceFactory(this),
                 buildParameters.ToolsetProvider,
diff --git a/src/Build/Instance/TaskFactoryWrapper.cs b/src/Build/Instance/TaskFactoryWrapper.cs
index d9bfe7d56b9..63719b5b6ba 100644
--- a/src/Build/Instance/TaskFactoryWrapper.cs
+++ b/src/Build/Instance/TaskFactoryWrapper.cs
@@ -73,6 +73,11 @@ public PropertyData(
         /// </summary>
         private IDictionary<string, string> _factoryIdentityParameters;
 
+        /// <summary>
+        /// An execution statistics holder.
+        /// </summary>
+        internal TaskRegistry.RegisteredTaskRecord.Stats? Statistics { get; private init; }
+
         #endregion
 
         #region Constructors
@@ -80,7 +85,12 @@ public PropertyData(
         /// <summary>
         /// Creates an instance of this class for the given type.
         /// </summary>
-        internal TaskFactoryWrapper(ITaskFactory taskFactory, LoadedType taskFactoryLoadInfo, string taskName, IDictionary<string, string> factoryIdentityParameters)
+        internal TaskFactoryWrapper(
+            ITaskFactory taskFactory,
+            LoadedType taskFactoryLoadInfo,
+            string taskName,
+            IDictionary<string, string> factoryIdentityParameters,
+            TaskRegistry.RegisteredTaskRecord.Stats? statistics = null)
         {
             ErrorUtilities.VerifyThrowArgumentNull(taskFactory);
             ErrorUtilities.VerifyThrowArgumentLength(taskName);
@@ -89,6 +99,7 @@ internal TaskFactoryWrapper(ITaskFactory taskFactory, LoadedType taskFactoryLoad
             TaskFactoryLoadedType = taskFactoryLoadInfo;
             _factoryIdentityParameters = factoryIdentityParameters;
             _propertyData = new Lazy<PropertyData>(PopulatePropertyInfo);
+            Statistics = statistics;
         }
 
         #endregion
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index c15332a79e8..a71dad69e15 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -11,6 +11,7 @@
 using System.Reflection;
 using System.Threading;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Components.RequestBuilder;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -441,7 +442,15 @@ private static void RegisterTasksFromUsingTaskElement
                 taskFactoryParameters.Add(XMakeAttributes.architecture, architecture == String.Empty ? XMakeAttributes.MSBuildArchitectureValues.any : architecture);
             }
 
-            taskRegistry.RegisterTask(taskName, AssemblyLoadInfo.Create(assemblyName, assemblyFile), taskFactory, taskFactoryParameters, parameterGroupAndTaskElementRecord, loggingContext, projectUsingTaskXml, ConversionUtilities.ValidBooleanTrue(overrideUsingTask));
+            taskRegistry.RegisterTask(
+                taskName,
+                AssemblyLoadInfo.Create(assemblyName, assemblyFile),
+                taskFactory,
+                taskFactoryParameters,
+                parameterGroupAndTaskElementRecord,
+                loggingContext,
+                projectUsingTaskXml,
+                ConversionUtilities.ValidBooleanTrue(overrideUsingTask));
         }
 
         private static Dictionary<string, string> CreateTaskFactoryParametersDictionary(int? initialCount = null)
@@ -686,7 +695,7 @@ private void RegisterTask(
             RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord,
             LoggingContext loggingContext,
             ProjectUsingTaskElement projectUsingTaskInXml,
-            bool overrideTask = false)
+            bool overrideTask)
         {
             ErrorUtilities.VerifyThrowInternalLength(taskName, nameof(taskName));
             ErrorUtilities.VerifyThrowInternalNull(assemblyLoadInfo);
@@ -713,7 +722,8 @@ private void RegisterTask(
                 taskFactory,
                 taskFactoryParameters,
                 inlineTaskRecord,
-                Interlocked.Increment(ref _nextRegistrationOrderId));
+                Interlocked.Increment(ref _nextRegistrationOrderId),
+                projectUsingTaskInXml.ContainingProject.FullPath);
 
             if (overrideTask)
             {
@@ -1158,10 +1168,58 @@ internal class RegisteredTaskRecord : ITranslatable
             /// </summary>
             private int _registrationOrderId;
 
+            /// <summary>
+            /// Full path to the file that contains definition of this task.
+            /// </summary>
+            private string _definingFileFullPath;
+
+            /// <summary>
+            /// Execution statistics for the tasks.
+            /// Not translatable - the statistics are anyway expected to be reset after each project request.
+            /// </summary>
+            internal Stats Statistics { get; private init; } = new Stats();
+
+            internal class Stats()
+            {
+                public short ExecutedCount { get; private set; } = 0;
+                public long TotalMemoryConsumption { get; private set; } = 0;
+                private readonly Stopwatch _executedSw  = new Stopwatch();
+                private long _memoryConsumptionOnStart;
+
+                public TimeSpan ExecutedTime => _executedSw.Elapsed;
+
+                public void ExecutionStarted()
+                {
+                    _memoryConsumptionOnStart = GC.GetTotalMemory(false);
+                    _executedSw.Start();
+                    ExecutedCount++;
+                }
+
+                public void ExecutionStopped()
+                {
+                    _executedSw.Stop();
+                    TotalMemoryConsumption += GC.GetTotalMemory(false) - _memoryConsumptionOnStart;
+                }
+
+                public void Reset()
+                {
+                    ExecutedCount = 0;
+                    _executedSw.Reset();
+                    TotalMemoryConsumption = 0;
+                }
+            }
+
             /// <summary>
             /// Constructor
             /// </summary>
-            internal RegisteredTaskRecord(string registeredName, AssemblyLoadInfo assemblyLoadInfo, string taskFactory, Dictionary<string, string> taskFactoryParameters, ParameterGroupAndTaskElementRecord inlineTask, int registrationOrderId)
+            internal RegisteredTaskRecord(
+                string registeredName,
+                AssemblyLoadInfo assemblyLoadInfo,
+                string taskFactory,
+                Dictionary<string, string> taskFactoryParameters,
+                ParameterGroupAndTaskElementRecord inlineTask,
+                int registrationOrderId,
+                string containingFileFullPath)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(assemblyLoadInfo, "AssemblyLoadInfo");
                 _registeredName = registeredName;
@@ -1189,12 +1247,40 @@ internal RegisteredTaskRecord(string registeredName, AssemblyLoadInfo assemblyLo
                 {
                     _parameterGroupAndTaskBody = new ParameterGroupAndTaskElementRecord();
                 }
+
+                _definingFileFullPath = containingFileFullPath;
             }
 
             private RegisteredTaskRecord()
             {
             }
 
+            /// <summary>
+            /// Evaluates whether the current task is assumed to be defined within the user code - as opposed
+            ///  to being a built-in task, or task authored by Microsoft brought to build via sdk, common targets or nuget.
+            /// </summary>
+            public bool ComputeIfCustom()
+            {
+                return
+                    (
+                        // There are occurrences of inline tasks within common targets (Microsoft.CodeAnalysis.Targets - SetEnvironmentVariable),
+                        //  so we need to check file as well (the very last condition).
+                        !string.IsNullOrEmpty(_parameterGroupAndTaskBody?.InlineTaskXmlBody) ||
+                        (!string.IsNullOrEmpty(_taskFactoryAssemblyLoadInfo.AssemblyName) &&
+                         !FileClassifier.IsMicrosoftAssembly(_taskFactoryAssemblyLoadInfo.AssemblyName)) ||
+                        (!string.IsNullOrEmpty(_taskFactoryAssemblyLoadInfo.AssemblyFile) &&
+                         // This condition will as well capture Microsoft tasks pulled from NuGet cache - since we decide based on assembly name.
+                         // Hence we do not have to add the 'IsMicrosoftPackageInNugetCache' call anywhere here 
+                         !FileClassifier.IsMicrosoftAssembly(Path.GetFileName(_taskFactoryAssemblyLoadInfo.AssemblyFile)) &&
+                         !FileClassifier.Shared.IsBuiltInLogic(_taskFactoryAssemblyLoadInfo.AssemblyFile)))
+                    // and let's consider all tasks imported by common targets as non custom logic.
+                    && !FileClassifier.Shared.IsBuiltInLogic(_definingFileFullPath);
+            }
+
+            public bool IsFromNugetCache
+                => FileClassifier.Shared.IsInNugetCache(_taskFactoryAssemblyLoadInfo.AssemblyFile) ||
+                   FileClassifier.Shared.IsInNugetCache(_definingFileFullPath);
+
             /// <summary>
             /// Gets the task name this record was registered with.
             /// </summary>
@@ -1546,7 +1632,7 @@ private bool GetTaskFactory(TargetLoggingContext targetLoggingContext, ElementLo
                         }
                     }
 
-                    _taskFactoryWrapperInstance = new TaskFactoryWrapper(factory, loadedType, RegisteredName, TaskFactoryParameters);
+                    _taskFactoryWrapperInstance = new TaskFactoryWrapper(factory, loadedType, RegisteredName, TaskFactoryParameters, Statistics);
                 }
 
                 return true;
@@ -1815,6 +1901,7 @@ public void Translate(ITranslator translator)
                 translator.Translate(ref _taskFactory);
                 translator.Translate(ref _parameterGroupAndTaskBody);
                 translator.Translate(ref _registrationOrderId);
+                translator.Translate(ref _definingFileFullPath);
 
                 IDictionary<string, string> localParameters = _taskFactoryParameters;
                 translator.TranslateDictionary(ref localParameters, count => CreateTaskFactoryParametersDictionary(count));
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index be4eaa2288d..9c3fda8fec3 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -80,6 +80,8 @@ public sealed class BinaryLogger : ILogger
         //    BuildCheckTracingEvent, BuildCheckAcquisitionEvent, BuildSubmissionStartedEvent
         // version 24:
         //    - new record kind: BuildCanceledEventArgs
+        // version 25:
+        //    - add extra information to PropertyInitialValueSetEventArgs and PropertyReassignmentEventArgs and change message formatting logic.
 
         // MAKE SURE YOU KEEP BuildEventArgsWriter AND StructuredLogViewer.BuildEventArgsWriter IN SYNC WITH THE CHANGES ABOVE.
         // Both components must stay in sync to avoid issues with logging or event handling in the products.
@@ -90,7 +92,7 @@ public sealed class BinaryLogger : ILogger
 
         // The current version of the binary log representation.
         // Changes with each update of the binary log format.
-        internal const int FileFormatVersion = 24;
+        internal const int FileFormatVersion = 25;
 
         // The minimum version of the binary log reader that can read log of above version.
         // This should be changed only when the binary log format is changed in a way that would prevent it from being
@@ -502,13 +504,6 @@ private string GetUniqueStamp()
             => (PathParameterExpander ?? ExpandPathParameter)(string.Empty);
 
         private static string ExpandPathParameter(string parameters)
-            => $"{DateTime.UtcNow.ToString("yyyyMMdd-HHmmss")}--{ProcessId}--{StringUtils.GenerateRandomString(6)}";
-
-        private static int ProcessId
-#if NET
-            => Environment.ProcessId;
-#else
-            => System.Diagnostics.Process.GetCurrentProcess().Id;
-#endif
+            => $"{DateTime.UtcNow.ToString("yyyyMMdd-HHmmss")}--{EnvironmentUtilities.CurrentProcessId}--{StringUtils.GenerateRandomString(6)}";
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 0b97024c472..4b48d9a8592 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -1177,6 +1177,9 @@ private BuildEventArgs ReadPropertyReassignmentEventArgs()
                 previousValue,
                 newValue,
                 location,
+                fields.File,
+                fields.LineNumber,
+                fields.ColumnNumber,
                 fields.Message,
                 fields.HelpKeyword,
                 fields.SenderName,
@@ -1193,7 +1196,7 @@ private BuildEventArgs ReadUninitializedPropertyReadEventArgs()
 
             var e = new UninitializedPropertyReadEventArgs(
                 propertyName,
-                fields.Message,
+                message: null,
                 fields.HelpKeyword,
                 fields.SenderName,
                 fields.Importance);
@@ -1214,10 +1217,14 @@ private BuildEventArgs ReadPropertyInitialValueSetEventArgs()
                 propertyName,
                 propertyValue,
                 propertySource,
+                fields.File,
+                fields.LineNumber,
+                fields.ColumnNumber,
                 fields.Message,
                 fields.HelpKeyword,
                 fields.SenderName,
                 fields.Importance);
+
             SetCommonFields(e, fields);
 
             return e;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index dba52023339..fc44128aba0 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -572,19 +572,21 @@ private BinaryLogRecordKind Write(PropertyReassignmentEventArgs e)
             WriteDeduplicatedString(e.PreviousValue);
             WriteDeduplicatedString(e.NewValue);
             WriteDeduplicatedString(e.Location);
+
             return BinaryLogRecordKind.PropertyReassignment;
         }
 
         private BinaryLogRecordKind Write(UninitializedPropertyReadEventArgs e)
         {
-            WriteMessageFields(e, writeImportance: true);
+            WriteMessageFields(e, writeMessage: false, writeImportance: true);
             WriteDeduplicatedString(e.PropertyName);
+
             return BinaryLogRecordKind.UninitializedPropertyRead;
         }
 
         private BinaryLogRecordKind Write(PropertyInitialValueSetEventArgs e)
         {
-            WriteMessageFields(e, writeImportance: true);
+            WriteMessageFields(e, writeMessage: false, writeImportance: true);
             WriteDeduplicatedString(e.PropertyName);
             WriteDeduplicatedString(e.PropertyValue);
             WriteDeduplicatedString(e.PropertySource);
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index 41bfaf94f50..dc365d45387 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -2,6 +2,10 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Diagnostics.CodeAnalysis;
+using System.Linq;
+using System.Reflection;
+using System.Runtime.CompilerServices;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Logging;
diff --git a/src/Build/Logging/SimpleErrorLogger.cs b/src/Build/Logging/SimpleErrorLogger.cs
index 02d14829a9d..5b248afd5e7 100644
--- a/src/Build/Logging/SimpleErrorLogger.cs
+++ b/src/Build/Logging/SimpleErrorLogger.cs
@@ -3,7 +3,8 @@
 
 using System;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Logging.TerminalLogger;
+using Microsoft.Build.Framework.Logging;
+using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging.SimpleErrorLogger
diff --git a/src/MSBuild/TerminalLogger/ITerminal.cs b/src/Build/Logging/TerminalLogger/ITerminal.cs
similarity index 96%
rename from src/MSBuild/TerminalLogger/ITerminal.cs
rename to src/Build/Logging/TerminalLogger/ITerminal.cs
index 04a6dd8039f..bfb9cf0990f 100644
--- a/src/MSBuild/TerminalLogger/ITerminal.cs
+++ b/src/Build/Logging/TerminalLogger/ITerminal.cs
@@ -2,8 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using Microsoft.Build.Framework.Logging;
 
-namespace Microsoft.Build.Logging.TerminalLogger;
+namespace Microsoft.Build.Logging;
 
 /// <summary>
 /// An abstraction of a terminal, built specifically to fit the <see cref="TerminalLogger"/> needs.
diff --git a/src/MSBuild/TerminalLogger/StopwatchAbstraction.cs b/src/Build/Logging/TerminalLogger/StopwatchAbstraction.cs
similarity index 86%
rename from src/MSBuild/TerminalLogger/StopwatchAbstraction.cs
rename to src/Build/Logging/TerminalLogger/StopwatchAbstraction.cs
index 8b365517a6a..c4f72f630de 100644
--- a/src/MSBuild/TerminalLogger/StopwatchAbstraction.cs
+++ b/src/Build/Logging/TerminalLogger/StopwatchAbstraction.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-namespace Microsoft.Build.Logging.TerminalLogger;
+namespace Microsoft.Build.Logging;
 
 internal abstract class StopwatchAbstraction
 {
diff --git a/src/MSBuild/TerminalLogger/SystemStopwatch.cs b/src/Build/Logging/TerminalLogger/SystemStopwatch.cs
similarity index 92%
rename from src/MSBuild/TerminalLogger/SystemStopwatch.cs
rename to src/Build/Logging/TerminalLogger/SystemStopwatch.cs
index f554e53ede6..90532b31e3f 100644
--- a/src/MSBuild/TerminalLogger/SystemStopwatch.cs
+++ b/src/Build/Logging/TerminalLogger/SystemStopwatch.cs
@@ -3,7 +3,7 @@
 
 using System.Diagnostics;
 
-namespace Microsoft.Build.Logging.TerminalLogger;
+namespace Microsoft.Build.Logging;
 
 internal sealed class SystemStopwatch : StopwatchAbstraction
 {
diff --git a/src/MSBuild/TerminalLogger/Terminal.cs b/src/Build/Logging/TerminalLogger/Terminal.cs
similarity index 98%
rename from src/MSBuild/TerminalLogger/Terminal.cs
rename to src/Build/Logging/TerminalLogger/Terminal.cs
index 16651d85fb9..01a3065cd93 100644
--- a/src/MSBuild/TerminalLogger/Terminal.cs
+++ b/src/Build/Logging/TerminalLogger/Terminal.cs
@@ -5,11 +5,12 @@
 using System.IO;
 using System.Runtime.InteropServices;
 using System.Text;
+using Microsoft.Build.Framework.Logging;
 #if NETFRAMEWORK
 using Microsoft.Build.Shared;
 #endif
 
-namespace Microsoft.Build.Logging.TerminalLogger;
+namespace Microsoft.Build.Logging;
 
 /// <summary>
 /// An <see cref="ITerminal"/> implementation for ANSI/VT100 terminals.
diff --git a/src/MSBuild/TerminalLogger/BuildMessage.cs b/src/Build/Logging/TerminalLogger/TerminalBuildMessage.cs
similarity index 65%
rename from src/MSBuild/TerminalLogger/BuildMessage.cs
rename to src/Build/Logging/TerminalLogger/TerminalBuildMessage.cs
index a204690d041..8e90b6f85e2 100644
--- a/src/MSBuild/TerminalLogger/BuildMessage.cs
+++ b/src/Build/Logging/TerminalLogger/TerminalBuildMessage.cs
@@ -1,10 +1,10 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-namespace Microsoft.Build.Logging.TerminalLogger;
+namespace Microsoft.Build.Logging;
 
 /// <summary>
 /// Represents a piece of diagnostic output (message/warning/error).
 /// </summary>
-internal record struct BuildMessage(MessageSeverity Severity, string Message)
+internal record struct TerminalBuildMessage(TerminalMessageSeverity Severity, string Message)
 { }
diff --git a/src/MSBuild/TerminalLogger/TerminalLogger.cs b/src/Build/Logging/TerminalLogger/TerminalLogger.cs
similarity index 88%
rename from src/MSBuild/TerminalLogger/TerminalLogger.cs
rename to src/Build/Logging/TerminalLogger/TerminalLogger.cs
index d4dc4346cf9..33696ada520 100644
--- a/src/MSBuild/TerminalLogger/TerminalLogger.cs
+++ b/src/Build/Logging/TerminalLogger/TerminalLogger.cs
@@ -3,26 +3,26 @@
 
 using System;
 using System.Collections.Generic;
+using System.Globalization;
 using System.Linq;
 using System.Text;
+using System.Text.RegularExpressions;
 using System.Threading;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using System.Text.RegularExpressions;
-using System.Diagnostics;
 using Microsoft.Build.Framework.Logging;
-using System.Globalization;
+using Microsoft.Build.Shared;
 
 #if NET7_0_OR_GREATER
 using System.Diagnostics.CodeAnalysis;
 #endif
+
 #if NETFRAMEWORK
 using Microsoft.IO;
 #else
 using System.IO;
 #endif
 
-namespace Microsoft.Build.Logging.TerminalLogger;
+namespace Microsoft.Build.Logging;
 
 /// <summary>
 /// A logger which updates the console output "live" during the build.
@@ -30,7 +30,7 @@ namespace Microsoft.Build.Logging.TerminalLogger;
 /// <remarks>
 /// Uses ANSI/VT100 control codes to erase and overwrite lines as the build is progressing.
 /// </remarks>
-internal sealed partial class TerminalLogger : INodeLogger
+public sealed partial class TerminalLogger : INodeLogger
 {
     private const string FilePathPattern = " -> ";
 
@@ -57,6 +57,8 @@ public ProjectContext(BuildEventContext context)
         { }
     }
 
+    private readonly record struct TestSummary(int Total, int Passed, int Skipped, int Failed);
+
     /// <summary>
     /// The indentation to use for all build output.
     /// </summary>
@@ -91,7 +93,7 @@ public ProjectContext(BuildEventContext context)
     /// <remarks>
     /// Keyed by an ID that gets passed to logger callbacks, this allows us to quickly look up the corresponding project.
     /// </remarks>
-    private readonly Dictionary<ProjectContext, Project> _projects = new();
+    private readonly Dictionary<ProjectContext, TerminalProjectInfo> _projects = new();
 
     /// <summary>
     /// Tracks the work currently being done by build nodes. Null means the node is not doing any work worth reporting.
@@ -100,7 +102,7 @@ public ProjectContext(BuildEventContext context)
     /// There is no locking around access to this data structure despite it being accessed concurrently by multiple threads.
     /// However, reads and writes to locations in an array is atomic, so locking is not required.
     /// </remarks>
-    private NodeStatus?[] _nodes = Array.Empty<NodeStatus>();
+    private TerminalNodeStatus?[] _nodes = Array.Empty<TerminalNodeStatus>();
 
     /// <summary>
     /// The timestamp of the <see cref="IEventSource.BuildStarted"/> event.
@@ -146,7 +148,7 @@ public ProjectContext(BuildEventContext context)
     /// <summary>
     /// What is currently displaying in Nodes section as strings representing per-node console output.
     /// </summary>
-    private NodesFrame _currentFrame = new(Array.Empty<NodeStatus>(), 0, 0);
+    private TerminalNodesFrame _currentFrame = new(Array.Empty<TerminalNodeStatus>(), 0, 0);
 
     /// <summary>
     /// The <see cref="Terminal"/> to write console output to.
@@ -163,29 +165,6 @@ public ProjectContext(BuildEventContext context)
     /// </summary>
     private bool _loggedPreviewMessage;
 
-    /// <summary>
-    /// List of events the logger needs as parameters to the <see cref="ConfigurableForwardingLogger"/>.
-    /// </summary>
-    /// <remarks>
-    /// If TerminalLogger runs as a distributed logger, MSBuild out-of-proc nodes might filter the events that will go to the main
-    /// node using an instance of <see cref="ConfigurableForwardingLogger"/> with the following parameters.
-    /// Important: Note that TerminalLogger is special-cased in <see cref="BackEnd.Logging.LoggingService.UpdateMinimumMessageImportance"/>
-    /// so changing this list may impact the minimum message importance logging optimization.
-    /// </remarks>
-    public static readonly string[] ConfigurableForwardingLoggerParameters =
-    {
-            "BUILDSTARTEDEVENT",
-            "BUILDFINISHEDEVENT",
-            "PROJECTSTARTEDEVENT",
-            "PROJECTFINISHEDEVENT",
-            "TARGETSTARTEDEVENT",
-            "TARGETFINISHEDEVENT",
-            "TASKSTARTEDEVENT",
-            "HIGHMESSAGEEVENT",
-            "WARNINGEVENT",
-            "ERROREVENT"
-    };
-
     /// <summary>
     /// The two directory separator characters to be passed to methods like <see cref="String.IndexOfAny(char[])"/>.
     /// </summary>
@@ -231,12 +210,12 @@ public ProjectContext(BuildEventContext context)
     /// <summary>
     /// Default constructor, used by the MSBuild logger infra.
     /// </summary>
-    public TerminalLogger()
+    internal TerminalLogger()
     {
         Terminal = new Terminal();
     }
 
-    public TerminalLogger(LoggerVerbosity verbosity) : this()
+    internal TerminalLogger(LoggerVerbosity verbosity) : this()
     {
         Verbosity = verbosity;
     }
@@ -250,6 +229,73 @@ internal TerminalLogger(ITerminal terminal)
         _manualRefresh = true;
     }
 
+    /// <summary>
+    /// Private constructor invoked by static factory.
+    /// </summary>
+    internal TerminalLogger(LoggerVerbosity verbosity, uint? originalConsoleMode) : this()
+    {
+        Verbosity = verbosity;
+        _originalConsoleMode = originalConsoleMode;
+    }
+
+    /// <summary>
+    /// Creates a Terminal logger if possible, or a Console logger.
+    /// </summary>
+    /// <param name="args">Command line arguments for the logger configuration. Currently, only 'tl|terminallogger' and 'v|verbosity' are supported right now.</param>
+    public static ILogger CreateTerminalOrConsoleLogger(string[]? args = null)
+    {
+        (bool supportsAnsi, bool outputIsScreen, uint? originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
+
+        return CreateTerminalOrConsoleLogger(args, supportsAnsi, outputIsScreen, originalConsoleMode);
+    }
+
+    internal static ILogger CreateTerminalOrConsoleLogger(string[]? args, bool supportsAnsi, bool outputIsScreen, uint? originalConsoleMode)
+    {
+        LoggerVerbosity verbosity = LoggerVerbosity.Normal;
+        string tlEnvVariable = Environment.GetEnvironmentVariable("MSBUILDTERMINALLOGGER") ?? string.Empty;
+        string tlArg = string.Empty;
+        string? verbosityArg = string.Empty;
+
+        if (args != null)
+        {
+            string argsString = string.Join(" ", args);
+
+            MatchCollection tlMatches = Regex.Matches(argsString, @"(?:/|-|--)(?:tl|terminallogger):(?'value'on|off)", RegexOptions.IgnoreCase);
+            tlArg = tlMatches.OfType<Match>().LastOrDefault()?.Groups["value"].Value ?? string.Empty;
+
+            MatchCollection verbosityMatches = Regex.Matches(argsString, @"(?:/|-|--)(?:v|verbosity):(?'value'\w+)", RegexOptions.IgnoreCase);
+            verbosityArg = verbosityMatches.OfType<Match>().LastOrDefault()?.Groups["value"].Value;
+        }
+
+        verbosityArg = verbosityArg?.ToLowerInvariant() switch
+        {
+            "q" => "quiet",
+            "m" => "minimal",
+            "n" => "normal",
+            "d" => "detailed",
+            "diag" => "diagnostic",
+            _ => verbosityArg,
+        };
+
+        if (Enum.TryParse(verbosityArg, true, out LoggerVerbosity parsedVerbosity))
+        {
+            verbosity = parsedVerbosity;
+        }
+
+        bool isDisabled =
+            tlArg.Equals("on", StringComparison.InvariantCultureIgnoreCase) ? false :
+            tlArg.Equals("off", StringComparison.InvariantCultureIgnoreCase) ? true :
+            tlEnvVariable.Equals("off", StringComparison.InvariantCultureIgnoreCase) || tlEnvVariable.Equals(bool.FalseString, StringComparison.InvariantCultureIgnoreCase);
+
+        if (isDisabled || !supportsAnsi || !outputIsScreen)
+        {
+            NativeMethodsShared.RestoreConsoleMode(originalConsoleMode);
+            return new ConsoleLogger(verbosity);
+        }
+
+        return new TerminalLogger(verbosity, originalConsoleMode);
+    }
+
     #region INodeLogger implementation
 
     /// <inheritdoc/>
@@ -262,7 +308,7 @@ internal TerminalLogger(ITerminal terminal)
     public void Initialize(IEventSource eventSource, int nodeCount)
     {
         // When MSBUILDNOINPROCNODE enabled, NodeId's reported by build start with 2. We need to reserve an extra spot for this case.
-        _nodes = new NodeStatus[nodeCount + 1];
+        _nodes = new TerminalNodeStatus[nodeCount + 1];
 
         Initialize(eventSource);
     }
@@ -270,8 +316,6 @@ public void Initialize(IEventSource eventSource, int nodeCount)
     /// <inheritdoc/>
     public void Initialize(IEventSource eventSource)
     {
-        (_, _, _originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
-
         ParseParameters();
 
         eventSource.BuildStarted += BuildStarted;
@@ -396,7 +440,7 @@ private void BuildStarted(object sender, BuildStartedEventArgs e)
 
         _buildStartTime = e.Timestamp;
 
-        if (Terminal.SupportsProgressReporting)
+        if (Terminal.SupportsProgressReporting && Verbosity != LoggerVerbosity.Quiet)
         {
             Terminal.Write(AnsiCodes.SetProgressIndeterminate);
         }
@@ -465,7 +509,7 @@ private void BuildFinished(object sender, BuildFinishedEventArgs e)
         }
         finally
         {
-            if (Terminal.SupportsProgressReporting)
+            if (Terminal.SupportsProgressReporting && Verbosity != LoggerVerbosity.Quiet)
             {
                 Terminal.Write(AnsiCodes.RemoveProgress);
             }
@@ -492,7 +536,7 @@ private void RenderBuildSummary()
 
         Terminal.WriteLine(ResourceUtilities.GetResourceString("BuildSummary"));
 
-        foreach (Project project in _projects.Values.Where(p => p.HasErrorsOrWarnings))
+        foreach (TerminalProjectInfo project in _projects.Values.Where(p => p.HasErrorsOrWarnings))
         {
             string duration = project.Stopwatch.ElapsedSeconds.ToString("F1");
             string buildResult = GetBuildResultString(project.Succeeded, project.ErrorCount, project.WarningCount);
@@ -500,7 +544,7 @@ private void RenderBuildSummary()
 
             Terminal.WriteLine(projectHeader);
 
-            foreach (BuildMessage buildMessage in project.GetBuildErrorAndWarningMessages())
+            foreach (TerminalBuildMessage buildMessage in project.GetBuildErrorAndWarningMessages())
             {
                 Terminal.WriteLine($"{DoubleIndentation}{buildMessage.Message}");
             }
@@ -543,7 +587,7 @@ private void ProjectStarted(object sender, ProjectStartedEventArgs e)
             {
                 _restoreContext = c;
                 int nodeIndex = NodeIndexForContext(buildEventContext);
-                _nodes[nodeIndex] = new NodeStatus(e.ProjectFile!, null, "Restore", _projects[c].Stopwatch);
+                _nodes[nodeIndex] = new TerminalNodeStatus(e.ProjectFile!, null, "Restore", _projects[c].Stopwatch);
             }
         }
     }
@@ -573,7 +617,7 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
 
         ProjectContext c = new(buildEventContext);
 
-        if (_projects.TryGetValue(c, out Project? project))
+        if (_projects.TryGetValue(c, out TerminalProjectInfo? project))
         {
             project.Succeeded = e.Succeeded;
             project.Stopwatch.Stop();
@@ -673,7 +717,7 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
                     // Print diagnostic output under the Project -> Output line.
                     if (project.BuildMessages is not null)
                     {
-                        foreach (BuildMessage buildMessage in project.BuildMessages)
+                        foreach (TerminalBuildMessage buildMessage in project.BuildMessages)
                         {
                             Terminal.WriteLine($"{DoubleIndentation}{buildMessage.Message}");
                         }
@@ -692,7 +736,7 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
         }
     }
 
-    private static string GetProjectFinishedHeader(Project project, string buildResult, string duration)
+    private static string GetProjectFinishedHeader(TerminalProjectInfo project, string buildResult, string duration)
     {
         string projectFile = project.File is not null ?
             Path.GetFileNameWithoutExtension(project.File) :
@@ -727,7 +771,7 @@ private static string GetProjectFinishedHeader(Project project, string buildResu
     private void TargetStarted(object sender, TargetStartedEventArgs e)
     {
         var buildEventContext = e.BuildEventContext;
-        if (_restoreContext is null && buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+        if (_restoreContext is null && buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out TerminalProjectInfo? project))
         {
             project.Stopwatch.Start();
 
@@ -753,12 +797,12 @@ private void TargetStarted(object sender, TargetStartedEventArgs e)
                 project.IsTestProject = true;
             }
 
-            NodeStatus nodeStatus = new(projectFile, project.TargetFramework, targetName, project.Stopwatch);
+            TerminalNodeStatus nodeStatus = new(projectFile, project.TargetFramework, targetName, project.Stopwatch);
             UpdateNodeStatus(buildEventContext, nodeStatus);
         }
     }
 
-    private void UpdateNodeStatus(BuildEventContext buildEventContext, NodeStatus? nodeStatus)
+    private void UpdateNodeStatus(BuildEventContext buildEventContext, TerminalNodeStatus? nodeStatus)
     {
         int nodeIndex = NodeIndexForContext(buildEventContext);
         _nodes[nodeIndex] = nodeStatus;
@@ -776,7 +820,7 @@ private void TargetFinished(object sender, TargetFinishedEventArgs e)
             && buildEventContext is not null
             && _hasUsedCache
             && e.TargetName == "GetTargetPath"
-            && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+            && _projects.TryGetValue(new ProjectContext(buildEventContext), out TerminalProjectInfo? project))
         {
             if (project.IsCachePluginProject)
             {
@@ -800,7 +844,7 @@ private void TaskStarted(object sender, TaskStartedEventArgs e)
             // This will yield the node, so preemptively mark it idle
             UpdateNodeStatus(buildEventContext, null);
 
-            if (_projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
+            if (_projects.TryGetValue(new ProjectContext(buildEventContext), out TerminalProjectInfo? project))
             {
                 project.Stopwatch.Stop();
             }
@@ -821,7 +865,7 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)
         string? message = e.Message;
         if (message is not null && e.Importance == MessageImportance.High)
         {
-            var hasProject = _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project);
+            var hasProject = _projects.TryGetValue(new ProjectContext(buildEventContext), out TerminalProjectInfo? project);
 
             // Detect project output path by matching high-importance messages against the "$(MSBuildProjectName) -> ..."
             // pattern used by the CopyFilesToOutputDirectory target.
@@ -872,7 +916,7 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)
                                 var indicator = extendedMessage.ExtendedMetadata!["localizedResult"]!;
                                 var displayName = extendedMessage.ExtendedMetadata!["displayName"]!;
 
-                                var status = new NodeStatus(node.Project, node.TargetFramework, TerminalColor.Green, indicator, displayName, project.Stopwatch);
+                                var status = new TerminalNodeStatus(node.Project, node.TargetFramework, TerminalColor.Green, indicator, displayName, project.Stopwatch);
                                 UpdateNodeStatus(buildEventContext, status);
                                 break;
                             }
@@ -882,7 +926,7 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)
                                 var indicator = extendedMessage.ExtendedMetadata!["localizedResult"]!;
                                 var displayName = extendedMessage.ExtendedMetadata!["displayName"]!;
 
-                                var status = new NodeStatus(node.Project, node.TargetFramework, TerminalColor.Yellow, indicator, displayName, project.Stopwatch);
+                                var status = new TerminalNodeStatus(node.Project, node.TargetFramework, TerminalColor.Yellow, indicator, displayName, project.Stopwatch);
                                 UpdateNodeStatus(buildEventContext, status);
                                 break;
                             }
@@ -930,7 +974,7 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)
 
                 if (hasProject)
                 {
-                    project!.AddBuildMessage(MessageSeverity.Message, message);
+                    project!.AddBuildMessage(TerminalMessageSeverity.Message, message);
                 }
                 else
                 {
@@ -949,7 +993,7 @@ private void WarningRaised(object sender, BuildWarningEventArgs e)
         BuildEventContext? buildEventContext = e.BuildEventContext;
 
         if (buildEventContext is not null
-            && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project)
+            && _projects.TryGetValue(new ProjectContext(buildEventContext), out TerminalProjectInfo? project)
             && Verbosity > LoggerVerbosity.Quiet)
         {
             if ((!String.IsNullOrEmpty(e.Message) && IsImmediateMessage(e.Message!)) ||
@@ -958,7 +1002,7 @@ private void WarningRaised(object sender, BuildWarningEventArgs e)
                 RenderImmediateMessage(FormatWarningMessage(e, Indentation));
             }
 
-            project.AddBuildMessage(MessageSeverity.Warning, FormatWarningMessage(e, TripleIndentation));
+            project.AddBuildMessage(TerminalMessageSeverity.Warning, FormatWarningMessage(e, TripleIndentation));
         }
         else
         {
@@ -991,10 +1035,10 @@ private void ErrorRaised(object sender, BuildErrorEventArgs e)
         BuildEventContext? buildEventContext = e.BuildEventContext;
 
         if (buildEventContext is not null
-            && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project)
+            && _projects.TryGetValue(new ProjectContext(buildEventContext), out TerminalProjectInfo? project)
             && Verbosity > LoggerVerbosity.Quiet)
         {
-            project.AddBuildMessage(MessageSeverity.Error, FormatErrorMessage(e, TripleIndentation));
+            project.AddBuildMessage(TerminalMessageSeverity.Error, FormatErrorMessage(e, TripleIndentation));
         }
         else
         {
@@ -1031,7 +1075,7 @@ private void ThreadProc()
     /// </summary>
     internal void DisplayNodes()
     {
-        NodesFrame newFrame = new NodesFrame(_nodes, width: Terminal.Width, height: Terminal.Height);
+        TerminalNodesFrame newFrame = new TerminalNodesFrame(_nodes, width: Terminal.Width, height: Terminal.Height);
 
         // Do not render delta but clear everything if Terminal width or height have changed.
         if (newFrame.Width != _currentFrame.Width || newFrame.Height != _currentFrame.Height)
@@ -1077,8 +1121,9 @@ private void EraseNodes()
     /// Construct a build result summary string.
     /// </summary>
     /// <param name="succeeded">True if the build completed with success.</param>
-    /// <param name="hasError">True if the build has logged at least one error.</param>
-    /// <param name="hasWarning">True if the build has logged at least one warning.</param>
+    /// <param name="countErrors">The number of errors encountered during the build.</param>
+    /// <param name="countWarnings">The number of warnings encountered during the build.</param>
+    /// <returns>A string representing the build result summary.</returns>
     private static string GetBuildResultString(bool succeeded, int countErrors, int countWarnings)
     {
         if (!succeeded)
diff --git a/src/MSBuild/TerminalLogger/MessageSeverity.cs b/src/Build/Logging/TerminalLogger/TerminalMessageSeverity.cs
similarity index 67%
rename from src/MSBuild/TerminalLogger/MessageSeverity.cs
rename to src/Build/Logging/TerminalLogger/TerminalMessageSeverity.cs
index 9f374e292dd..40fafcea1c6 100644
--- a/src/MSBuild/TerminalLogger/MessageSeverity.cs
+++ b/src/Build/Logging/TerminalLogger/TerminalMessageSeverity.cs
@@ -1,9 +1,9 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-namespace Microsoft.Build.Logging.TerminalLogger;
+namespace Microsoft.Build.Logging;
 
 /// <summary>
 /// Enumerates the supported message severities.
 /// </summary>
-internal enum MessageSeverity { Message, Warning, Error }
+internal enum TerminalMessageSeverity { Message, Warning, Error }
diff --git a/src/MSBuild/TerminalLogger/NodeStatus.cs b/src/Build/Logging/TerminalLogger/TerminalNodeStatus.cs
similarity index 88%
rename from src/MSBuild/TerminalLogger/NodeStatus.cs
rename to src/Build/Logging/TerminalLogger/TerminalNodeStatus.cs
index 3b3de635dee..4634040bdf7 100644
--- a/src/MSBuild/TerminalLogger/NodeStatus.cs
+++ b/src/Build/Logging/TerminalLogger/TerminalNodeStatus.cs
@@ -3,14 +3,15 @@
 
 using System;
 using System.Diagnostics;
+using Microsoft.Build.Framework.Logging;
 using Microsoft.Build.Shared;
 
-namespace Microsoft.Build.Logging.TerminalLogger;
+namespace Microsoft.Build.Logging;
 
 /// <summary>
 /// Encapsulates the per-node data shown in live node output.
 /// </summary>
-internal class NodeStatus
+internal class TerminalNodeStatus
 {
     public string Project { get; }
     public string? TargetFramework { get; }
@@ -26,7 +27,7 @@ internal class NodeStatus
     /// <param name="targetFramework">Target framework that is colorized and written on left side after project.</param>
     /// <param name="target">The currently running work, usually the currently running target. Written on right.</param>
     /// <param name="stopwatch">Duration of the current step. Written on right after target.</param>
-    public NodeStatus(string project, string? targetFramework, string target, StopwatchAbstraction stopwatch)
+    public TerminalNodeStatus(string project, string? targetFramework, string target, StopwatchAbstraction stopwatch)
     {
 #if DEBUG
         if (target.Contains("\x1B"))
@@ -49,7 +50,7 @@ public NodeStatus(string project, string? targetFramework, string target, Stopwa
     /// <param name="targetPrefix">Colorized status for the currently running work, written on right, before target, and separated by 1 space from it.</param>
     /// <param name="target">The currently running work, usually the currently runnig target. Written on right.</param>
     /// <param name="stopwatch">Duration of the current step. Written on right after target.</param>
-    public NodeStatus(string project, string? targetFramework, TerminalColor targetPrefixColor, string targetPrefix, string target, StopwatchAbstraction stopwatch)
+    public TerminalNodeStatus(string project, string? targetFramework, TerminalColor targetPrefixColor, string targetPrefix, string target, StopwatchAbstraction stopwatch)
         : this(project, targetFramework, target, stopwatch)
     {
         TargetPrefixColor = targetPrefixColor;
@@ -60,7 +61,7 @@ public NodeStatus(string project, string? targetFramework, TerminalColor targetP
     /// Equality is based on the project, target framework, and target, but NOT the elapsed time.
     /// </summary>
     public override bool Equals(object? obj) =>
-        obj is NodeStatus status &&
+        obj is TerminalNodeStatus status &&
         Project == status.Project &&
         TargetFramework == status.TargetFramework &&
         Target == status.Target &&
diff --git a/src/MSBuild/TerminalLogger/NodesFrame.cs b/src/Build/Logging/TerminalLogger/TerminalNodesFrame.cs
similarity index 90%
rename from src/MSBuild/TerminalLogger/NodesFrame.cs
rename to src/Build/Logging/TerminalLogger/TerminalNodesFrame.cs
index 38c82c36f93..93f4f2dee9b 100644
--- a/src/MSBuild/TerminalLogger/NodesFrame.cs
+++ b/src/Build/Logging/TerminalLogger/TerminalNodesFrame.cs
@@ -2,21 +2,20 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
-
 using System.Text;
+using Microsoft.Build.Framework.Logging;
 using Microsoft.Build.Shared;
 
-namespace Microsoft.Build.Logging.TerminalLogger;
+namespace Microsoft.Build.Logging;
 
 /// <summary>
 /// Capture states on nodes to be rendered on display.
 /// </summary>
-internal sealed class NodesFrame
+internal sealed class TerminalNodesFrame
 {
     private const int MaxColumn = 120;
 
-    private readonly (NodeStatus nodeStatus, int durationLength)[] _nodes;
+    private readonly (TerminalNodeStatus nodeStatus, int durationLength)[] _nodes;
 
     private readonly StringBuilder _renderBuilder = new();
 
@@ -24,14 +23,14 @@ internal sealed class NodesFrame
     public int Height { get; }
     public int NodesCount { get; private set; }
 
-    public NodesFrame(NodeStatus?[] nodes, int width, int height)
+    public TerminalNodesFrame(TerminalNodeStatus?[] nodes, int width, int height)
     {
         Width = Math.Min(width, MaxColumn);
         Height = height;
 
-        _nodes = new (NodeStatus, int)[nodes.Length];
+        _nodes = new (TerminalNodeStatus, int)[nodes.Length];
 
-        foreach (NodeStatus? status in nodes)
+        foreach (TerminalNodeStatus? status in nodes)
         {
             if (status is not null)
             {
@@ -42,7 +41,7 @@ public NodesFrame(NodeStatus?[] nodes, int width, int height)
 
     internal ReadOnlySpan<char> RenderNodeStatus(int i)
     {
-        NodeStatus status = _nodes[i].nodeStatus;
+        TerminalNodeStatus status = _nodes[i].nodeStatus;
 
         string durationString = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
             "DurationDisplay",
@@ -96,7 +95,7 @@ static int Length(string durationString, string project, string? targetFramework
     /// <summary>
     /// Render VT100 string to update from current to next frame.
     /// </summary>
-    public string Render(NodesFrame previousFrame)
+    public string Render(TerminalNodesFrame previousFrame)
     {
         StringBuilder sb = _renderBuilder;
         sb.Clear();
diff --git a/src/MSBuild/TerminalLogger/Project.cs b/src/Build/Logging/TerminalLogger/TerminalProjectInfo.cs
similarity index 70%
rename from src/MSBuild/TerminalLogger/Project.cs
rename to src/Build/Logging/TerminalLogger/TerminalProjectInfo.cs
index e32d3686dc7..8e4f98fe688 100644
--- a/src/MSBuild/TerminalLogger/Project.cs
+++ b/src/Build/Logging/TerminalLogger/TerminalProjectInfo.cs
@@ -6,20 +6,22 @@
 using System.Diagnostics;
 using System.Linq;
 
-namespace Microsoft.Build.Logging.TerminalLogger;
+namespace Microsoft.Build.Logging;
 
 /// <summary>
 /// Represents a project being built.
 /// </summary>
-internal sealed class Project
+internal sealed class TerminalProjectInfo
 {
-    private List<BuildMessage>? _buildMessages;
+    private List<TerminalBuildMessage>? _buildMessages;
 
     /// <summary>
-    /// Initialized a new <see cref="Project"/> with the given <paramref name="targetFramework"/>.
+    /// Initialized a new <see cref="TerminalProjectInfo"/> with the given <paramref name="targetFramework"/>.
     /// </summary>
+    /// <param name="projectFile">The full path to the project file.</param>
     /// <param name="targetFramework">The target framework of the project or null if not multi-targeting.</param>
-    public Project(string projectFile, string? targetFramework, StopwatchAbstraction? stopwatch)
+    /// <param name="stopwatch">A stopwatch to time the build of the project.</param>
+    public TerminalProjectInfo(string projectFile, string? targetFramework, StopwatchAbstraction? stopwatch)
     {
         File = projectFile;
         TargetFramework = targetFramework;
@@ -58,7 +60,7 @@ public Project(string projectFile, string? targetFramework, StopwatchAbstraction
     public bool IsTestProject { get; set; }
 
     /// <summary>
-    /// True when the project has run target with name "_CachePluginRunStart" defined in <see cref="TerminalLogger._cachePluginStartTarget"/>.
+    /// True when the project has run target with name "_CachePluginRunStart".
     /// </summary>
     public bool IsCachePluginProject { get; set; }
 
@@ -85,21 +87,21 @@ public Project(string projectFile, string? targetFramework, StopwatchAbstraction
     /// <summary>
     /// A lazily initialized list of build messages/warnings/errors raised during the build.
     /// </summary>
-    public IReadOnlyList<BuildMessage>? BuildMessages => _buildMessages;
+    public IReadOnlyList<TerminalBuildMessage>? BuildMessages => _buildMessages;
 
     /// <summary>
     /// Adds a build message of the given severity to <see cref="BuildMessages"/>.
     /// </summary>
-    public void AddBuildMessage(MessageSeverity severity, string message)
+    public void AddBuildMessage(TerminalMessageSeverity severity, string message)
     {
-        _buildMessages ??= new List<BuildMessage>();
-        _buildMessages.Add(new BuildMessage(severity, message));
+        _buildMessages ??= new List<TerminalBuildMessage>();
+        _buildMessages.Add(new TerminalBuildMessage(severity, message));
 
-        if (severity == MessageSeverity.Error)
+        if (severity == TerminalMessageSeverity.Error)
         {
             ErrorCount++;
         }
-        else if (severity == MessageSeverity.Warning)
+        else if (severity == TerminalMessageSeverity.Warning)
         {
             WarningCount++;
         }
@@ -109,12 +111,12 @@ public void AddBuildMessage(MessageSeverity severity, string message)
     /// Filters the build messages to only include errors and warnings.
     /// </summary>
     /// <returns>A sequence of error and warning build messages.</returns>
-    public IEnumerable<BuildMessage> GetBuildErrorAndWarningMessages()
+    public IEnumerable<TerminalBuildMessage> GetBuildErrorAndWarningMessages()
     {
         return BuildMessages is null ?
-            Enumerable.Empty<BuildMessage>() :
+            Enumerable.Empty<TerminalBuildMessage>() :
             BuildMessages.Where(message =>
-                message.Severity == MessageSeverity.Error ||
-                message.Severity == MessageSeverity.Warning);
+                message.Severity == TerminalMessageSeverity.Error ||
+                message.Severity == TerminalMessageSeverity.Warning);
     }
 }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index d3faea7600a..e6fc5f4cccd 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -39,6 +39,9 @@
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
 
     <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
+    <!-- Remove the direct NETStandard.Library dependency when Microsoft.BuildXL.Processes stops bringing in netstandard1.x dependencies
+         or when a .NET 10 SDK is used (NuGet Package Pruning eliminates netstandard1.x dependencies). -->
+    <PackageReference Include="NETStandard.Library" VersionOverride="2.0.3" PrivateAssets="all" Condition="'$(FeatureReportFileAccesses)' == 'true'" />
   </ItemGroup>
   
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildSourceOnly)' != 'true'">
@@ -59,9 +62,6 @@
   </ItemGroup>
 
   <ItemGroup>
-    <Compile Include="..\Shared\EnvironmentUtilities.cs">
-      <Link>SharedUtilities\EnvironmentUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>SharedUtilities\BuildEnvironmentHelper.cs</Link>
     </Compile>
@@ -176,6 +176,11 @@
     <Compile Include="FileAccess\RequestedAccess.cs" />
     <Compile Include="Instance\IPropertyElementWithLocation.cs" />
     <Compile Include="Logging\BuildEventArgsExtensions.cs" />
+    <Compile Include="Logging\TerminalLogger\**\*.cs" />
+    <Compile Include="TelemetryInfra\InternalTelemetryConsumingLogger.cs" />
+    <Compile Include="TelemetryInfra\ITelemetryForwarder.cs" />
+    <Compile Include="TelemetryInfra\TelemetryDataUtils.cs" />
+    <Compile Include="TelemetryInfra\TelemetryForwarderProvider.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
@@ -499,6 +504,8 @@
     <Compile Include="Evaluation\Evaluator.cs" />
     <Compile Include="Evaluation\Expander.cs" />
     <Compile Include="Evaluation\ToolsetProvider.cs" />
+    <Compile Include="Evaluation\Expander\ArgumentParser.cs" />
+    <Compile Include="Evaluation\Expander\WellKnownFunctions.cs" />
     <Compile Include="Globbing\CompositeGlob.cs" />
     <Compile Include="Globbing\Extensions\MSBuildGlobExtensions.cs" />
     <Compile Include="Globbing\Visitor\GlobVisitor.cs" />
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index afa2052daca..128cf7283c0 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -2198,6 +2198,14 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>Project {0} specifies 'TargetFrameworks' property '{1}' and 'TargetFramework' property '{2}' at the same time. This will lead to 'TargetFrameworks' being ignored and build will behave as single-targeted.</value>
     <comment>Terms in quotes are not to be translated.</comment>
   </data>
+  <data name="BuildCheck_BC0108_Title" xml:space="preserve">
+    <value>'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects that do not use the .NET SDK.</value>
+    <comment>Terms in quotes are not to be translated.</comment>
+  </data>
+  <data name="BuildCheck_BC0108_MessageFmt" xml:space="preserve">
+    <value>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</value>
+    <comment>Terms in quotes are not to be translated.</comment>
+  </data>
   <data name="BuildCheck_BC0201_Title" xml:space="preserve">
     <value>A property that is accessed should be declared first.</value>
   </data>
@@ -2216,12 +2224,168 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="BuildCheck_BC0203_MessageFmt" xml:space="preserve">
     <value>Property: '{0}' was declared/initialized, but it was never used.</value>
   </data>
+  <data name="BuildCheck_BC0301_Title" xml:space="preserve">
+    <value>Downloads folder is untrusted for projects building.</value>
+  </data>
+  <data name="BuildCheck_BC0301_MessageFmt" xml:space="preserve">
+    <value>Location: '{0}' cannot be fully trusted, place your projects outside of that folder (Project: {1}).</value>
+  </data>
   <data name="GlobExpansionFailed" xml:space="preserve">
     <value>An exception occurred while expanding a fileSpec with globs: fileSpec: "{0}", assuming it is a file name. Exception: {1}</value>
   </data>
   <data name="UnknownLoggingType" xml:space="preserve">
     <value>Logging type {0} is not understood by {1}.</value>
   </data>
+  <data name="DurationDisplay" xml:space="preserve">
+    <value>({0:F1}s)</value>
+    <comment>
+        {0}: duration in seconds with 1 decimal point
+        's' should reflect the localized abbreviation for seconds
+      </comment>
+  </data>
+  <data name="RestoreComplete" xml:space="preserve">
+    <value>Restore complete ({0}s)</value>
+    <comment>
+      {0}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </comment>
+  </data>
+  <data name="RestoreCompleteWithMessage" xml:space="preserve">
+    <value>Restore {0} in {1}s</value>
+    <comment>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </comment>
+  </data>
+  <data name="BuildFinished" xml:space="preserve">
+    <value>Build {0} in {1}s</value>
+    <comment>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </comment>
+  </data>
+  <data name="ProjectFinished_NoTF" xml:space="preserve">
+    <value>{0}{1} {2} ({3}s)</value>
+    <comment>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </comment>
+  </data>
+  <data name="ProjectFinished_WithTF" xml:space="preserve">
+    <value>{0}{1} {2} {3} ({4}s)</value>
+    <comment>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </comment>
+  </data>
+  <data name="BuildResult_FailedWithErrors" xml:space="preserve">
+    <value>failed with {0} error(s)</value>
+    <comment>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_FailedWithErrorsAndWarnings" xml:space="preserve">
+    <value>failed with {0} error(s) and {1} warning(s)</value>
+    <comment>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_FailedWithWarnings" xml:space="preserve">
+    <value>failed with {0} warning(s)</value>
+    <comment>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_Failed" xml:space="preserve">
+    <value>failed</value>
+    <comment>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_Succeeded" xml:space="preserve">
+    <value>succeeded</value>
+    <comment>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="BuildResult_SucceededWithWarnings" xml:space="preserve">
+    <value>succeeded with {0} warning(s)</value>
+    <comment>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </comment>
+  </data>
+  <data name="TestProjectFinished_NoTF" xml:space="preserve">
+    <value>{0}{1} test {2} ({3}s)</value>
+    <comment>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </comment>
+  </data>
+  <data name="TestProjectFinished_WithTF" xml:space="preserve">
+    <value>{0}{1} test {2} {3} ({4}s)</value>
+    <comment>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </comment>
+  </data>
+  <data name="ProjectFinished_OutputPath" xml:space="preserve">
+    <value> → {0}</value>
+    <comment>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </comment>
+  </data>
+  <data name="BuildSummary" xml:space="preserve">
+    <value>Build summary:</value>
+    <comment>
+      A header used by Terminal Logger to introduce the build summary.
+    </comment>
+  </data>
+  <data name="TestSummary_BannerAndTotal" xml:space="preserve">
+    <value>Test summary: total: {0}</value>
+    <comment>{0} whole number</comment>
+  </data>
+  <data name="TestSummary_Duration" xml:space="preserve">
+    <value>duration: {0}s</value>
+    <comment>
+      {0} whole number
+      's' should reflect the localized abbreviation for seconds
+    </comment>
+  </data>
+  <data name="TestSummary_Failed" xml:space="preserve">
+    <value>failed: {0}</value>
+    <comment>{0} whole number</comment>
+  </data>
+  <data name="TestSummary_Skipped" xml:space="preserve">
+    <value>skipped: {0}</value>
+    <comment>{0} whole number</comment>
+  </data>
+  <data name="TestSummary_Succeeded" xml:space="preserve">
+    <value>succeeded: {0}</value>
+    <comment>{0} whole number</comment>
+  </data>
   <!--
         The Build message bucket is: MSB4000 - MSB4999
 
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index de10f0f34a9..5d95d9b15e5 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -211,6 +211,16 @@
         <target state="translated">Nezadávejte always pro CopyToOutputDirectory, protože to může způsobit nepotřebné operace kopírování během sestavování. Pokud chcete používat efektivnější kopírování, použijte hodnotu metadat PreserveNeexport nebo IfDifferent, nebo nastavte vlastnost SkipUnchangedFilesOnCopyAlways na true.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_MessageFmt">
+        <source>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</source>
+        <target state="translated">Project {0} určuje vlastnost TargetFramework(s) '{1}', která nepoužívá sadu .NET SDK. Tyto vlastnosti nejsou srozumitelné pro projekty, které přímo importují cíle jazyka C#.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_Title">
+        <source>'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects that do not use the .NET SDK.</source>
+        <target state="translated">Vlastnosti TargetFramework a TargetFrameworks se nedodržují a neměly by se zadává v projektech, které nepoužívají sadu .NET SDK.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">K vlastnosti: {0} bylo přistupováno, ale nebyla nikdy inicializována.</target>
@@ -241,6 +251,26 @@
         <target state="translated">Vlastnost, která se nepoužívá, by se neměla deklarovat.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_MessageFmt">
+        <source>Location: '{0}' cannot be fully trusted, place your projects outside of that folder (Project: {1}).</source>
+        <target state="translated">Umístění: '{0}' nelze plně považovat za důvěryhodné, umístěte projekty mimo danou složku (Projekt: {1}).</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_Title">
+        <source>Downloads folder is untrusted for projects building.</source>
+        <target state="translated">Složka Stažené soubory není důvěryhodná pro sestavování projektů.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Sestavení {0} za {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Vytvoření otázky SELHALO. Vytváření bylo předčasně ukončeno, protože se při něm narazilo na cíl nebo úlohu, které nebyly aktuální.</target>
@@ -256,6 +286,55 @@
         <target state="translated">Operaci nebylo možno dokončit, protože sestavení již probíhá.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">neúspěšné</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with {0} error(s)</source>
+        <target state="translated">selhalo s {0} chybou/chybami.</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
+        <source>failed with {0} error(s) and {1} warning(s)</source>
+        <target state="translated">selhalo s chybami (celkem {0}) a upozorněními (celkem {1})</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with {0} warning(s)</source>
+        <target state="translated">selhalo s {0} upozorněním(i).</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">úspěšné</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with {0} warning(s)</source>
+        <target state="translated">uspělo s {0} upozorněním(i).</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildSummary">
+        <source>Build summary:</source>
+        <target state="translated">Souhrn sestavení:</target>
+        <note>
+      A header used by Terminal Logger to introduce the build summary.
+    </note>
+      </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
         <source>MSB4252: Project "{0}" with global properties
     ({1})
@@ -367,6 +446,14 @@
         <target state="translated">MSB4275: Došlo k pokusu o vytvoření více přepsání stejné úlohy: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1} s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+        's' should reflect the localized abbreviation for seconds
+      </note>
+      </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
         <source>MSB4257: The specified output result cache file is empty.</source>
         <target state="translated">MSB4257: Zadaný výstupní soubor mezipaměti pro výsledky je prázdný.</target>
@@ -636,6 +723,39 @@
         <target state="translated">MSB4268: Mezipaměť projektu se nepovedlo správně vypnout.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph nepodporuje položky ProjectReference s nastavenými metadaty ToolsVersion. V souboru {1} byla nalezena položka ProjectReference {0} s metadaty ToolsVersion.</target>
@@ -674,6 +794,24 @@
         <target state="translated">Přístupy k souborům sestav se v současné době podporují jenom pomocí varianty x64 nástroje MSBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Obnovení dokončeno ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Obnoví se {0} za {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverAttempt">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
@@ -793,6 +931,59 @@ Chyby: {3}</target>
         <target state="translated">MSB4181: Úloha {0} vrátila false, ale do protokolu se nezaznamenala chyba.</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
+      <trans-unit id="TestProjectFinished_NoTF">
+        <source>{0}{1} test {2} ({3}s)</source>
+        <target state="translated">{0}{1} – test {2} ({3} s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestProjectFinished_WithTF">
+        <source>{0}{1} test {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} – test {2} {3} ({4} s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Souhrn testu: celkem: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">doba trvání: {0} s</target>
+        <note>
+      {0} whole number
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">selhalo: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">přeskočeno: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">úspěšné: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: Úloha MSBuild sestavuje projekty {0}, které nejsou zadané v položce ProjectReference. V izolovaných sestaveních to pravděpodobně znamená, že tyto odkazy nejsou v {1} explicitně zadané jako položka ProjectReference.</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 7ae4ff64846..2cc67095e98 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -211,6 +211,16 @@
         <target state="translated">Vermeiden Sie die Angabe von "Always" für "CopyToOutputDirectory", da dies zu unnötigen Kopiervorgängen während des Buildvorgangs führen kann. Verwenden Sie den Metadatenwert "PreserveNewest" oder "IfDifferent", oder legen Sie die Eigenschaft "SkipUnchangedFilesOnCopyAlways" auf TRUE fest, um effektiveres Kopieren zu verwenden.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_MessageFmt">
+        <source>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</source>
+        <target state="translated">Project {0} gibt die Eigenschaft "TargetFramework(s)" '{1}' an, die nicht das .NET SDK verwendet. Diese Eigenschaften werden von Projekten, die C#-Ziele direkt importieren, nicht verstanden.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_Title">
+        <source>'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects that do not use the .NET SDK.</source>
+        <target state="translated">Die Eigenschaften "TargetFramework" und "TargetFrameworks" werden nicht berücksichtigt und sollten nicht in Projekten angegeben werden, die nicht das .NET SDK verwenden.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Auf die Eigenschaft „{0}“ wurde zugegriffen, sie wurde jedoch nie initialisiert.</target>
@@ -241,6 +251,26 @@
         <target state="translated">Eine Eigenschaft, die nicht verwendet wird, sollte nicht deklariert werden.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_MessageFmt">
+        <source>Location: '{0}' cannot be fully trusted, place your projects outside of that folder (Project: {1}).</source>
+        <target state="translated">Speicherort: '{0}' kann nicht vollständig vertrauenswürdig sein. Platzieren Sie Ihre Projekte außerhalb dieses Ordners (Projekt: {1}).</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_Title">
+        <source>Downloads folder is untrusted for projects building.</source>
+        <target state="translated">Der Ordner "Downloads" ist für die Projekterstellung nicht vertrauenswürdig.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Erstellen von {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Fehler beim Erstellen der Frage. Der Build wurde früh beendet, da ein Ziel oder eine Aufgabe gefunden wurde, die nicht aktuell war.</target>
@@ -256,6 +286,55 @@
         <target state="translated">Der Vorgang kann nicht abgeschlossen werden, da bereits ein Buildvorgang stattfindet.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">Fehlgeschlagen</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with {0} error(s)</source>
+        <target state="translated">fehlerhaft mit {0} Fehler(n)</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
+        <source>failed with {0} error(s) and {1} warning(s)</source>
+        <target state="translated">fehlerhaft mit {0} Fehler(n) und {1} Warnung(en)</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with {0} warning(s)</source>
+        <target state="translated">fehlerhaft mit {0} Warnung(en)</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">Erfolgreich</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with {0} warning(s)</source>
+        <target state="translated">erfolgreich mit {0} Warnung(en)</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildSummary">
+        <source>Build summary:</source>
+        <target state="translated">Build-Zusammenfassung:</target>
+        <note>
+      A header used by Terminal Logger to introduce the build summary.
+    </note>
+      </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
         <source>MSB4252: Project "{0}" with global properties
     ({1})
@@ -367,6 +446,14 @@
         <target state="translated">MSB4275: Es wurde versucht, mehrere Außerkraftsetzungen derselben Aufgabe zu erstellen: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+        's' should reflect the localized abbreviation for seconds
+      </note>
+      </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
         <source>MSB4257: The specified output result cache file is empty.</source>
         <target state="translated">MSB4257: Die angegebene Cachedatei für Ausgabeergebnisse ist leer.</target>
@@ -636,6 +723,39 @@
         <target state="translated">MSB4268: Der Projektcache konnte nicht ordnungsgemäß heruntergefahren werden.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph bietet keine Unterstützung für ProjectReference-Elemente mit dem ToolsVersion-Metadatensatz. In der Datei "{1}" wurde ProjectReference "{0}" mit "ToolsVersion" gefunden.</target>
@@ -674,6 +794,24 @@
         <target state="translated">Das Melden von Dateizugriffen wird derzeit nur mit der x64-Variante von MSBuild unterstützt.</target>
         <note />
       </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Wiederherstellung abgeschlossen ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Wiederherstellen von {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverAttempt">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
@@ -793,6 +931,59 @@ Fehler: {3}</target>
         <target state="translated">MSB4181: Die Aufgabe "{0}" hat FALSE zurückgegeben, jedoch keinen Fehler protokolliert.</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
+      <trans-unit id="TestProjectFinished_NoTF">
+        <source>{0}{1} test {2} ({3}s)</source>
+        <target state="translated">{0}{1} Test {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestProjectFinished_WithTF">
+        <source>{0}{1} test {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} Test {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Testzusammenfassung: insgesamt: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">Dauer: {0} Sek.</target>
+        <note>
+      {0} whole number
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">fehlgeschlagen: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">übersprungen: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">erfolgreich: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: Der MSBuild-Task erstellt die Projekte "{0}", die im ProjectReference-Element nicht angegeben sind. In isolierten Builds bedeutet dies wahrscheinlich, dass die Verweise nicht explizit als ProjectReference-Element in "{1}" angegeben werden.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index f94a047df5b..7a8f4854d66 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -211,6 +211,16 @@
         <target state="translated">Evite especificar "Always" para "CopyToOutputDirectory", ya que esto puede provocar operaciones de copia innecesarias durante la compilación. Use el valor de metadatos "PreserveNewest" o "IfDifferent", o establezca la propiedad "SkipUnchangedFilesOnCopyAlways" en true para usar una copia más eficaz.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_MessageFmt">
+        <source>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</source>
+        <target state="translated">El {0} de proyecto especifica la propiedad "TargetFramework(s)" '{1}', que no usa el SDK de .NET. Los proyectos que importan destinos de C# no entienden esas propiedades directamente.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_Title">
+        <source>'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects that do not use the .NET SDK.</source>
+        <target state="translated">Las propiedades "TargetFramework" y "TargetFrameworks" no se respetan y no deben especificarse en proyectos que no usen el SDK de .NET.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Propiedad: se obtuvo acceso a "{0}", pero nunca se inicializó.</target>
@@ -241,6 +251,26 @@
         <target state="translated">No se debe declarar una propiedad que no se use.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_MessageFmt">
+        <source>Location: '{0}' cannot be fully trusted, place your projects outside of that folder (Project: {1}).</source>
+        <target state="translated">Ubicación: '{0}' no puede ser de plena confianza, coloque los proyectos fuera de esa carpeta (proyecto: {1}).</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_Title">
+        <source>Downloads folder is untrusted for projects building.</source>
+        <target state="translated">La carpeta descargas no es de confianza para la compilación de proyectos.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Compilación {0} en {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">La creación de la pregunta ha FALLADO. La creación finalizó antes de tiempo al encontrar un objetivo o tarea que no estaba actualizado.</target>
@@ -256,6 +286,55 @@
         <target state="translated">La operación no se puede completar porque ya hay una compilación en curso.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">erróneo</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with {0} error(s)</source>
+        <target state="translated">error con {0} errores</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
+        <source>failed with {0} error(s) and {1} warning(s)</source>
+        <target state="translated">error con {0} errores y {1} advertencias</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with {0} warning(s)</source>
+        <target state="translated">error con {0} advertencias</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">realizado correctamente</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with {0} warning(s)</source>
+        <target state="translated">correcto con {0} advertencias</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildSummary">
+        <source>Build summary:</source>
+        <target state="translated">Resumen de la compilación:</target>
+        <note>
+      A header used by Terminal Logger to introduce the build summary.
+    </note>
+      </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
         <source>MSB4252: Project "{0}" with global properties
     ({1})
@@ -367,6 +446,14 @@
         <target state="translated">MSB4275: Se intentaron crear varias invalidaciones de la misma tarea: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+        's' should reflect the localized abbreviation for seconds
+      </note>
+      </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
         <source>MSB4257: The specified output result cache file is empty.</source>
         <target state="translated">MSB4257: El archivo de caché de resultados de salida especificado está vacío.</target>
@@ -636,6 +723,39 @@
         <target state="translated">MSB4268: La memoria caché de proyectos no se cerró correctamente.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph no admite elementos de ProjectReference con los metadatos de ToolsVersion establecidos. Se encontró ProjectReference "{0}" con ToolsVersion en el archivo "{1}"</target>
@@ -674,6 +794,24 @@
         <target state="translated">Los accesos a archivos de informes solo se admiten actualmente con el tipo x64 de MSBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Restauración completada ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Restaurar {0} en {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverAttempt">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
@@ -793,6 +931,59 @@ Errores: {3}</target>
         <target state="translated">MSB4181: La tarea "{0}" devolvió false, pero no registró un error.</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
+      <trans-unit id="TestProjectFinished_NoTF">
+        <source>{0}{1} test {2} ({3}s)</source>
+        <target state="translated">{0}{1} prueba{2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestProjectFinished_WithTF">
+        <source>{0}{1} test {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} prueba ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Resumen de pruebas: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">duración: {0} s</target>
+        <note>
+      {0} whole number
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">con errores: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">omitido: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">correcto: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: La tarea MSBuild está compilando proyectos "{0}" que no se especifican en el elemento ProjectReference. En compilaciones aisladas, esto significa probablemente que las referencias no se especifican explícitamente como un elemento ProjectReference en "{1}".</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 56c560c71f7..aafdf22e15f 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -211,6 +211,16 @@
         <target state="translated">Évitez de spécifier 'Always' pour 'CopyToOutputDirectory', car cela peut entraîner des opérations de copie inutiles pendant la génération. Utilisez la valeur de métadonnées 'PreserveNerid' ou 'IfDifferent', ou définissez la propriété 'SkipUnchangedFilesOnCopyAlways' sur true pour utiliser une copie plus efficace.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_MessageFmt">
+        <source>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</source>
+        <target state="translated">Project {0} spécifie la propriété « TargetFramework(s) » '{1}', qui n’utilise pas le SDK .NET. Ces propriétés ne sont pas comprises par les projets qui importent directement des cibles C#.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_Title">
+        <source>'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects that do not use the .NET SDK.</source>
+        <target state="translated">Les propriétés 'TargetFramework' et 'TargetFrameworks' ne sont pas respectées et ne doivent pas être spécifiées dans les projets qui n’utilisent pas le SDK .NET.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Propriété : « {0} » a été consultée, mais elle n'a jamais été initialisée.</target>
@@ -241,6 +251,26 @@
         <target state="translated">Une propriété qui n'est pas utilisée ne doit pas être déclarée.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_MessageFmt">
+        <source>Location: '{0}' cannot be fully trusted, place your projects outside of that folder (Project: {1}).</source>
+        <target state="translated">Emplacement : '{0}' ne peut pas être entièrement fiable. Placez vos projets en dehors de ce dossier (Projet : {1}).</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_Title">
+        <source>Downloads folder is untrusted for projects building.</source>
+        <target state="translated">Le dossier des téléchargements n’est pas approuvé pour la génération de projets.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Générer {0} dans {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">ÉCHEC de la génération de la question. La génération s’est arrêtée tôt, car elle a rencontré une cible ou une tâche qui n’était pas à jour.</target>
@@ -256,6 +286,55 @@
         <target state="translated">Impossible d'effectuer l'opération car une génération est déjà en cours.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">échec</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with {0} error(s)</source>
+        <target state="translated">a échoué avec {0} erreur(s)</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
+        <source>failed with {0} error(s) and {1} warning(s)</source>
+        <target state="translated">a échoué avec {0} erreur(s) et {1} avertissement(s)</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with {0} warning(s)</source>
+        <target state="translated">a échoué avec {0} avertissement(s)</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">a réussi</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with {0} warning(s)</source>
+        <target state="translated">a réussi avec {0} avertissement(s)</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildSummary">
+        <source>Build summary:</source>
+        <target state="translated">Résumé de la build :</target>
+        <note>
+      A header used by Terminal Logger to introduce the build summary.
+    </note>
+      </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
         <source>MSB4252: Project "{0}" with global properties
     ({1})
@@ -367,6 +446,14 @@
         <target state="translated">MSB4275: Tentative de création de plusieurs remplacements de la même tâche : {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+        's' should reflect the localized abbreviation for seconds
+      </note>
+      </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
         <source>MSB4257: The specified output result cache file is empty.</source>
         <target state="translated">MSB4257: Le fichier cache des résultats de sortie spécifié est vide.</target>
@@ -636,6 +723,39 @@
         <target state="translated">MSB4268: le cache de projet ne s'est pas arrêté correctement.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph ne prend pas en charge les éléments ProjectReference avec l'ensemble de métadonnées ToolsVersion. ProjectReference "{0}" trouvé avec ToolsVersion dans le fichier "{1}"</target>
@@ -674,6 +794,24 @@
         <target state="translated">Les accès aux fichiers de création de rapports sont uniquement pris en charge à l’aide de la saveur x64 de MSBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Restauration terminée ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Restaurer {0} en {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverAttempt">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
@@ -793,6 +931,59 @@ Erreurs : {3}</target>
         <target state="translated">MSB4181: la tâche "{0}" a retourné false mais n'a pas journalisé d'erreur.</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
+      <trans-unit id="TestProjectFinished_NoTF">
+        <source>{0}{1} test {2} ({3}s)</source>
+        <target state="translated">{0}Test de {1} : {2} ({3} s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestProjectFinished_WithTF">
+        <source>{0}{1} test {2} {3} ({4}s)</source>
+        <target state="translated">{0}Test de {1} {2} : {3} ({4} s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Récapitulatif du test : total : {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">durée : {0}s</target>
+        <note>
+      {0} whole number
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">échec : {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">ignoré : {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">réussi : {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: la tâche MSBuild génère un ou plusieurs projets "{0}" qui ne sont pas spécifiés dans l'élément ProjectReference. Dans les builds isolées, cela signifie probablement que les références ne sont pas explicitement spécifiées en tant qu'élément ProjectReference dans "{1}"</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index c70a79dbe40..5e38412a12f 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -211,6 +211,16 @@
         <target state="translated">Evitare di specificare 'Always' per 'CopyToOutputDirectory' perché ciò può causare operazioni di copia non necessarie durante la compilazione. Usare il valore dei metadati 'PreserveNewest' o 'IfDifferent' oppure impostare la proprietà 'SkipUnchangedFilesOnCopyAlways' su true per utilizzare una copia più efficace.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_MessageFmt">
+        <source>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</source>
+        <target state="translated">Project {0} specifica la proprietà 'TargetFramework(s)' '{1}', che non usa .NET SDK. Queste proprietà non sono comprese dai progetti che importano direttamente destinazioni C#.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_Title">
+        <source>'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects that do not use the .NET SDK.</source>
+        <target state="translated">Le proprietà 'TargetFramework' e 'TargetFrameworks' non vengono rispettate e non devono essere specificate nei progetti che non usano .NET SDK.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">È stato eseguito l'accesso alla proprietà '{0}', ma non è mai stata inizializzata.</target>
@@ -241,6 +251,26 @@
         <target state="translated">Una proprietà non utilizzata non deve essere dichiarata.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_MessageFmt">
+        <source>Location: '{0}' cannot be fully trusted, place your projects outside of that folder (Project: {1}).</source>
+        <target state="translated">Percorso: '{0}' non può essere considerato completamente attendibile. Inserire i progetti all'esterno di tale cartella (Progetto: {1}).</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_Title">
+        <source>Downloads folder is untrusted for projects building.</source>
+        <target state="translated">La cartella Dei download non è attendibile per la compilazione di progetti.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Compilazione {0} in {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Compilazione della domanda NON RIUSCITA. La compilazione è terminata in anticipo perché è stata rilevata una destinazione o un'attività non aggiornata.</target>
@@ -256,6 +286,55 @@
         <target state="translated">Non è possibile completare l'operazione perché è già in corso una compilazione.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">non riuscito</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with {0} error(s)</source>
+        <target state="translated">non riuscito con {0} errori</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
+        <source>failed with {0} error(s) and {1} warning(s)</source>
+        <target state="translated">non riuscito con {0} errori e {1} avvisi</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with {0} warning(s)</source>
+        <target state="translated">non riuscito con {0} avvisi</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">operazione riuscita</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with {0} warning(s)</source>
+        <target state="translated">completato con {0} avvisi</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildSummary">
+        <source>Build summary:</source>
+        <target state="translated">Riepilogo build:</target>
+        <note>
+      A header used by Terminal Logger to introduce the build summary.
+    </note>
+      </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
         <source>MSB4252: Project "{0}" with global properties
     ({1})
@@ -367,6 +446,14 @@
         <target state="translated">MSB4275: tentativo di creare più sostituzioni della stessa attività: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+        's' should reflect the localized abbreviation for seconds
+      </note>
+      </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
         <source>MSB4257: The specified output result cache file is empty.</source>
         <target state="translated">MSB4257: il file della cache dei risultati di output specificato è vuoto.</target>
@@ -636,6 +723,39 @@
         <target state="translated">MSB4268: non è stato possibile arrestare correttamente la cache del progetto.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph non supporta elementi ProjectReference con metadati ToolsVersion impostati. L'elemento ProjectReference "{0}" con ToolsVersion è stato trovato nel file "{1}"</target>
@@ -674,6 +794,24 @@
         <target state="translated">Gli accessi ai file di report sono attualmente supportati solo con la versione x64 di MSBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Ripristino completato ({0})</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Ripristinare {0} in {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverAttempt">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
@@ -793,6 +931,59 @@ Errori: {3}</target>
         <target state="translated">MSB4181: l'attività "{0}" ha restituito false, ma non è stato registrato alcun errore.</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
+      <trans-unit id="TestProjectFinished_NoTF">
+        <source>{0}{1} test {2} ({3}s)</source>
+        <target state="translated">{0}{1} test {2} {3}</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestProjectFinished_WithTF">
+        <source>{0}{1} test {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} test {2} {3} {4}</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Riepilogo test: totale: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">durata: {0}s</target>
+        <note>
+      {0} whole number
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">non riuscito: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">ignorato: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">riuscito: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: l'attività MSBuild compila progetti "{0}" che non sono specificati nell'elemento ProjectReference. Nelle compilazioni isolate questa condizione indica probabilmente che i riferimenti non sono specificati in modo esplicito come elemento ProjectReference in "{1}"</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 0981d946bbb..dda0d13a014 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -211,6 +211,16 @@
         <target state="translated">ビルド中に不要なコピー操作が発生する可能性があるため、'CopyToOutputDirectory' に 'Always' を指定しないでください。より効果的なコピーを使用するには、'PreserveNewest' または 'IfDifferent' メタデータ値を使用するか、'SkipUnchangedFilesOnCopyAlways' プロパティを true に設定してください。</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_MessageFmt">
+        <source>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</source>
+        <target state="translated">プロジェクト {0} では、.NET SDK を使用しない 'TargetFramework' プロパティ '{1}' が指定されています。これらのプロパティは、C# ターゲットを直接インポートするプロジェクトでは認識されません。</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_Title">
+        <source>'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects that do not use the .NET SDK.</source>
+        <target state="translated">'TargetFramework' プロパティと 'TargetFrameworks' プロパティは優先されないため、.NET SDK を使用しないプロジェクトでは指定しないでください。</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">プロパティ: '{0}' にアクセスしましたが、初期化されませんでした。</target>
@@ -241,6 +251,26 @@
         <target state="translated">使用されていないプロパティは宣言しないでください。</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_MessageFmt">
+        <source>Location: '{0}' cannot be fully trusted, place your projects outside of that folder (Project: {1}).</source>
+        <target state="translated">場所: '{0}' を完全に信頼することはできません。プロジェクトをそのフォルダーの外に配置してください (プロジェクト: {1})。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_Title">
+        <source>Downloads folder is untrusted for projects building.</source>
+        <target state="translated">ダウンロード フォルダーは、プロジェクトのビルドに対して信頼されていません。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">{1} 秒後に {0} をビルド</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">質問のビルドに失敗しました。ビルドは、最新ではないターゲットまたはタスクが検出されたため、早期に終了しました。</target>
@@ -256,6 +286,55 @@
         <target state="translated">ビルドは既に進行中であるため、操作を完了できません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">失敗しました</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with {0} error(s)</source>
+        <target state="translated">{0} 件のエラーで失敗しました</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
+        <source>failed with {0} error(s) and {1} warning(s)</source>
+        <target state="translated">{0} 件のエラーと {1} 件の警告で失敗しました</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with {0} warning(s)</source>
+        <target state="translated">{0} 件の警告付きで失敗しました</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">成功しました</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with {0} warning(s)</source>
+        <target state="translated">{0} 件の警告付きで成功しました</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildSummary">
+        <source>Build summary:</source>
+        <target state="translated">ビルドの概要:</target>
+        <note>
+      A header used by Terminal Logger to introduce the build summary.
+    </note>
+      </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
         <source>MSB4252: Project "{0}" with global properties
     ({1})
@@ -367,6 +446,14 @@
         <target state="translated">MSB4275: 同じタスクの複数のオーバーライドを作成しようとしました: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+        's' should reflect the localized abbreviation for seconds
+      </note>
+      </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
         <source>MSB4257: The specified output result cache file is empty.</source>
         <target state="translated">MSB4257: 指定された出力結果キャッシュ ファイルは空です。</target>
@@ -636,6 +723,39 @@
         <target state="translated">MSB4268: プロジェクト キャッシュは正常にシャットダウンできませんでした。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} 秒)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} 秒)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph では、ToolsVersion メタデータが設定された ProjectReference 項目はサポートしていません。ToolsVersion が含まれる ProjectReference "{0}" がファイル "{1}" で見つかりました</target>
@@ -674,6 +794,24 @@
         <target state="translated">ファイル アクセスのレポートは、現在、MSBuild の x64 フレーバーを使用してのみサポートされています。</target>
         <note />
       </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">復元が完了しました ({0} 秒)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">{1} 秒後に {0} を復元する</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverAttempt">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
@@ -793,6 +931,59 @@ Errors: {3}</source>
         <target state="translated">MSB4181: "{0}" タスクから false が返されましたが、エラーがログに記録されませんでした。</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
+      <trans-unit id="TestProjectFinished_NoTF">
+        <source>{0}{1} test {2} ({3}s)</source>
+        <target state="translated">{0}{1} テスト {2} ({3} 秒)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestProjectFinished_WithTF">
+        <source>{0}{1} test {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} テスト {2} {3} ({4} 秒)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">テスト概要: 合計: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">期間: {0} 秒</target>
+        <note>
+      {0} whole number
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">失敗数: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">スキップ済み数: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">成功数: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: ProjectReference 項目で指定されていないプロジェクト "{0}" が MSBuild タスクによってビルドされています。分離されたビルドでは、これは多くの場合、参照が "{1}" で ProjectReference 項目として明示的に指定されていないことを意味します</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index bc6bd7f0df2..03f95d108ff 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -211,6 +211,16 @@
         <target state="translated">빌드하는 동안 불필요한 복사 작업이 발생할 수 있으므로 'CopyToOutputDirectory'에 대해 'Always'를 지정하지 마세요. 'PreserveNewest' 또는 'IfDifferent' 메타데이터 값을 사용하거나' SkipUnchangedFilesOnCopyAlways' 속성을 true로 설정하여 보다 효과적인 복사를 사용합니다.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_MessageFmt">
+        <source>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</source>
+        <target state="translated">프로젝트 {0} .NET SDK를 사용하지 않는 'TargetFramework' 속성 '{1}' 지정합니다. 이러한 속성은 C# 대상을 직접 가져오는 프로젝트에서 이해할 수 없습니다.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_Title">
+        <source>'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects that do not use the .NET SDK.</source>
+        <target state="translated">'TargetFramework' 및 'TargetFrameworks' 속성은 사용되지 않으며 .NET SDK를 사용하지 않는 프로젝트에서 지정해서는 안 됩니다.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">속성: '{0}'에 액세스했지만 초기화되지 않았습니다.</target>
@@ -241,6 +251,26 @@
         <target state="translated">사용되지 않는 속성은 선언하면 안 됩니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_MessageFmt">
+        <source>Location: '{0}' cannot be fully trusted, place your projects outside of that folder (Project: {1}).</source>
+        <target state="translated">위치: '{0}' 완전히 신뢰할 수 없습니다. 프로젝트를 해당 폴더 외부에 배치하세요(프로젝트: {1}).</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_Title">
+        <source>Downloads folder is untrusted for projects building.</source>
+        <target state="translated">프로젝트 빌드에 대해 다운로드 폴더를 신뢰할 수 없습니다.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">{0} 빌드({1}초)</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">질문 빌드에 실패했습니다. 빌드가 최신이 아닌 대상 또는 작업을 발견하여 일찍 종료되었습니다.</target>
@@ -256,6 +286,55 @@
         <target state="translated">빌드가 이미 진행되고 있으므로 작업을 완료할 수 없습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">실패</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with {0} error(s)</source>
+        <target state="translated">{0} 오류와 함께 실패</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
+        <source>failed with {0} error(s) and {1} warning(s)</source>
+        <target state="translated">{0} 오류와 {1} 경고와 함께 실패</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with {0} warning(s)</source>
+        <target state="translated">{0} 경고와 함께 실패</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">성공</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with {0} warning(s)</source>
+        <target state="translated">{0} 경고와 함께 성공</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildSummary">
+        <source>Build summary:</source>
+        <target state="translated">빌드 요약:</target>
+        <note>
+      A header used by Terminal Logger to introduce the build summary.
+    </note>
+      </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
         <source>MSB4252: Project "{0}" with global properties
     ({1})
@@ -367,6 +446,14 @@
         <target state="translated">MSB4275: 동일한 작업의 여러 재정의를 만들려고 했습니다. {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+        's' should reflect the localized abbreviation for seconds
+      </note>
+      </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
         <source>MSB4257: The specified output result cache file is empty.</source>
         <target state="translated">MSB4257: 지정한 출력 결과 캐시 파일이 비어 있습니다.</target>
@@ -636,6 +723,39 @@
         <target state="translated">MSB4268: 프로젝트 캐시가 제대로 종료되지 않았습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}초)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}초)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph는 ToolsVersion 메타데이터가 설정된 ProjectReference 항목을 지원하지 않습니다. "{1}" 파일에 ToolsVersion이 포함된 ProjectReference "{0}"이(가) 있습니다.</target>
@@ -674,6 +794,24 @@
         <target state="translated">파일 액세스 보고는 현재 x64 버전의 MSBuild를 사용하는 경우에만 지원됩니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">복원 완료({0}초)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">{0} 복원({1}초)</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverAttempt">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
@@ -793,6 +931,59 @@ Errors: {3}</source>
         <target state="translated">MSB4181: "{0}" 작업이 false를 반환했지만 오류를 기록하지 않았습니다.</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
+      <trans-unit id="TestProjectFinished_NoTF">
+        <source>{0}{1} test {2} ({3}s)</source>
+        <target state="translated">{0}{1} 테스트 {2}({3}초)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestProjectFinished_WithTF">
+        <source>{0}{1} test {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} 테스트 {2} {3}({4}초)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">테스트 요약: 합계: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">기간: {0}초</target>
+        <note>
+      {0} whole number
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">실패: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">건너뜀: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">성공: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: MSBuild 작업에서 ProjectReference 항목에 지정되지 않은 "{0}" 프로젝트를 빌드하고 있습니다. 격리된 빌드에서 참조가 "{1}"에서 ProjectReference 항목으로 명시적으로 지정되지 않은 상태일 수 있습니다.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 197d5dd80b1..b41218bfd21 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -211,6 +211,16 @@
         <target state="translated">Unikaj określania opcji "Always" dla elementu "CopyToOutputDirectory", ponieważ może to prowadzić do niepotrzebnych operacji kopiowania podczas kompilacji. Użyj wartości metadanych "PreserveNewest" lub "IfDifferent" albo ustaw właściwość "SkipUnchangedFilesOnCopyAlways" na wartość true, aby zastosować bardziej efektywne kopiowanie.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_MessageFmt">
+        <source>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</source>
+        <target state="translated">Program Project {0} określa właściwość "TargetFramework(s)" '{1}', która nie używa zestawu .NET SDK. Te właściwości nie są rozpoznane przez projekty, które importują bezpośrednio elementy docelowe języka C#.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_Title">
+        <source>'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects that do not use the .NET SDK.</source>
+        <target state="translated">Właściwości "TargetFramework" i "TargetFrameworks" nie są respektowane i nie należy ich określać w projektach, w których nie jest używany zestaw .NET SDK.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Właściwość: uzyskano dostęp do „{0}”, ale nigdy nie dokonano inicjacji.</target>
@@ -241,6 +251,26 @@
         <target state="translated">Nie należy deklarować właściwości, która nie jest używana.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_MessageFmt">
+        <source>Location: '{0}' cannot be fully trusted, place your projects outside of that folder (Project: {1}).</source>
+        <target state="translated">Lokalizacja: '{0}' nie można w pełni zaufać. Umieść projekty poza tym folderem (projekt: {1}).</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_Title">
+        <source>Downloads folder is untrusted for projects building.</source>
+        <target state="translated">Folder Pobrane nie jest zaufany do kompilowania projektów.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Kompiluj {0} w {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">NIEPOWODZENIE kompilacji pytania. Kompilacja została zakończona wcześniej, ponieważ napotkała element docelowy lub zadanie, które nie było aktualne.</target>
@@ -256,6 +286,55 @@
         <target state="translated">Nie można zakończyć tej operacji, ponieważ trwa kompilacja.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">niepowodzenie</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with {0} error(s)</source>
+        <target state="translated">zakończono niepowodzeniem, z błędami w liczbie: {0}</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
+        <source>failed with {0} error(s) and {1} warning(s)</source>
+        <target state="translated">zakończono niepowodzeniem, z błędami w liczbie: {0} i ostrzeżeniami w liczbie: {1}</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with {0} warning(s)</source>
+        <target state="translated">zakończono niepowodzeniem, z ostrzeżeniami w liczbie: {0}</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">powodzenie</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with {0} warning(s)</source>
+        <target state="translated">zakończono powodzeniem, z ostrzeżeniami w liczbie: {0}</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildSummary">
+        <source>Build summary:</source>
+        <target state="translated">Podsumowanie kompilacji:</target>
+        <note>
+      A header used by Terminal Logger to introduce the build summary.
+    </note>
+      </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
         <source>MSB4252: Project "{0}" with global properties
     ({1})
@@ -367,6 +446,14 @@
         <target state="translated">MSB4275: Podjęto próbę utworzenia wielu zastąpień tego samego zadania: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+        's' should reflect the localized abbreviation for seconds
+      </note>
+      </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
         <source>MSB4257: The specified output result cache file is empty.</source>
         <target state="translated">MSB4257: Określony plik wyjściowej pamięci podręcznej wyników jest pusty.</target>
@@ -636,6 +723,39 @@
         <target state="translated">MSB4268: nie można poprawnie zamknąć pamięci podręcznej projektu.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: Element ProjectGraph nie obsługuje elementów ProjectReference z ustawionymi metadanymi atrybutu ToolsVersion. W pliku „{1}” odnaleziono element ProjectReference „{0}” z atrybutem ToolsVersion</target>
@@ -674,6 +794,24 @@
         <target state="translated">Raportowanie dostępu do plików jest obecnie obsługiwane tylko przy użyciu wersji x64 programu MSBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Zakończono przywracanie ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Przywróć {0} w {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverAttempt">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
@@ -793,6 +931,59 @@ Błędy: {3}</target>
         <target state="translated">MSB4181: Zadanie „{0}” zwróciło wartość false, ale nie zarejestrowało błędu.</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
+      <trans-unit id="TestProjectFinished_NoTF">
+        <source>{0}{1} test {2} ({3}s)</source>
+        <target state="translated">{0}{1} test {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestProjectFinished_WithTF">
+        <source>{0}{1} test {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} test {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Podsumowanie testu: łącznie: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">czas trwania: {0}s</target>
+        <note>
+      {0} whole number
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">niepowodzenie: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">pominięto: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">zakończone powodzeniem: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: Zadanie programu MSBuild kompiluje projekty „{0}”, które nie są określone w elemencie ProjectReference. W przypadku kompilacji izolowanych prawdopodobnie oznacza to, że odwołania nie zostały jawnie określone jako element ProjectReference w pliku „{1}”</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 2a5e78cb408..dd2bf9c6cf7 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -211,6 +211,16 @@
         <target state="translated">Evite especificar 'Always' para 'CopyToOutputDirectory', pois isso pode levar a operações de cópia desnecessárias durante o build. Use o valor de metadados 'PreserveNewest' ou 'IfDifferent' ou defina a propriedade 'SkipUnchangedFilesOnCopyAlways' como true para empregar uma cópia mais eficaz.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_MessageFmt">
+        <source>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</source>
+        <target state="translated">O {0} especifica a propriedade 'TargetFramework(s)' '{1}', que não usa o SDK do .NET. Essas propriedades não são compreendidas pelos projetos que importam diretamente os destinos C#.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_Title">
+        <source>'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects that do not use the .NET SDK.</source>
+        <target state="translated">As propriedades 'TargetFramework' e 'TargetFrameworks' não são respeitadas e não devem ser especificadas em projetos que não usam o SDK do .NET.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Propriedade: "{0}" foi acessada, mas nunca foi inicializada.</target>
@@ -241,6 +251,26 @@
         <target state="translated">Uma propriedade que não é usada não deve ser declarada.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_MessageFmt">
+        <source>Location: '{0}' cannot be fully trusted, place your projects outside of that folder (Project: {1}).</source>
+        <target state="translated">Local: '{0}' não é totalmente confiável, coloque seus projetos fora dessa pasta (Projeto: {1}).</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_Title">
+        <source>Downloads folder is untrusted for projects building.</source>
+        <target state="translated">A pasta Downloads não é confiável para a compilação de projetos.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Construir {0} em {1}s</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">FALHA na compilação da pergunta. A compilação foi encerrada antecipadamente ao se deparar com um alvo ou tarefa que não estava atualizado.</target>
@@ -256,6 +286,55 @@
         <target state="translated">A operação não pode ser concluída porque uma compilação está em andamento.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">falhou</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with {0} error(s)</source>
+        <target state="translated">falhou com {0} erro(s)</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
+        <source>failed with {0} error(s) and {1} warning(s)</source>
+        <target state="translated">falhou com{0} erros e {1} avisos</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with {0} warning(s)</source>
+        <target state="translated">falhou com {0} aviso(s)</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">êxito</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with {0} warning(s)</source>
+        <target state="translated">êxito(s) com {0} aviso(s)</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildSummary">
+        <source>Build summary:</source>
+        <target state="translated">Resumo da compilação:</target>
+        <note>
+      A header used by Terminal Logger to introduce the build summary.
+    </note>
+      </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
         <source>MSB4252: Project "{0}" with global properties
     ({1})
@@ -367,6 +446,14 @@
         <target state="translated">MSB4275: tentativa de criar várias substituições da mesma tarefa: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+        's' should reflect the localized abbreviation for seconds
+      </note>
+      </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
         <source>MSB4257: The specified output result cache file is empty.</source>
         <target state="translated">MSB4257: o arquivo de cache do resultado de saída especificado está vazio.</target>
@@ -636,6 +723,39 @@
         <target state="translated">MSB4268: falha ao desligar o cache do projeto corretamente.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: O ProjectGraph não tem suporte para os itens ProjectReference com o conjunto de metadados ToolsVersion. O ProjectReference "{0}" foi encontrado com ToolsVersion no arquivo "{1}"</target>
@@ -674,6 +794,24 @@
         <target state="translated">Atualmente, o relatório de acessos a arquivos só tem suporte usando o tipo x64 do MSBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Restauração concluída ({0}s)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Restaurar {0} em {1}s</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverAttempt">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
@@ -793,6 +931,59 @@ Erros: {3}</target>
         <target state="translated">MSB4181: A tarefa "{0}" retornou false, mas não registrou um erro.</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
+      <trans-unit id="TestProjectFinished_NoTF">
+        <source>{0}{1} test {2} ({3}s)</source>
+        <target state="translated">{0}{1} teste {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestProjectFinished_WithTF">
+        <source>{0}{1} test {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} teste {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Resumo do teste: total: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">duração: {0}s</target>
+        <note>
+      {0} whole number
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">falhou: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">ignorado: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">bem-sucedido: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: a tarefa MSBuild está criando projetos "{0}" que não estão especificados no item ProjectReference. Nos builds isolados, isso provavelmente significa que as referências não estão explicitamente especificadas como um item ProjectReference em "{1}"</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 82bb6700ee8..7d7883cf5c6 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -211,6 +211,16 @@
         <target state="translated">Не указывайте "Always" для "CopyToOutputDirectory", так как это может привести к ненужным операциям копирования во время сборки. Используйте значение метаданных PreserveNewest или IfDifferent или задайте свойству SkipUnchangedFilesOnCopyAlways значение true, чтобы использовать более эффективное копирование.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_MessageFmt">
+        <source>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</source>
+        <target state="translated">В {0} проекта указано свойство "TargetFramework(s)", '{1}', который не использует пакет SDK для .NET. Эти свойства не распознаются проектами, которые импортют целевые объекты C# напрямую.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_Title">
+        <source>'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects that do not use the .NET SDK.</source>
+        <target state="translated">Свойства TargetFramework и TargetFrameworks не учитываются и не должны указываться в проектах, не использующих пакет SDK для .NET.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Свойство: к "{0}" получен доступ, но он не инициализирован.</target>
@@ -241,6 +251,26 @@
         <target state="translated">Не следует объявлять свойство, которое не используется.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_MessageFmt">
+        <source>Location: '{0}' cannot be fully trusted, place your projects outside of that folder (Project: {1}).</source>
+        <target state="translated">Расположение: '{0}' быть полностью доверенным. Поместите проекты за пределы этой папки (проект: {1}).</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_Title">
+        <source>Downloads folder is untrusted for projects building.</source>
+        <target state="translated">Папка "Загрузки" недоверена для сборки проектов.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">Сборка {0} через {1} с</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">СБОЙ сборки вопроса. Выход из сборки выполнен раньше, так как была обнаружена цель или задача без обновления.</target>
@@ -256,6 +286,55 @@
         <target state="translated">Не удалось завершить операцию, так как уже выполняется сборка.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">сбой</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with {0} error(s)</source>
+        <target state="translated">сбой с ошибками ({0})</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
+        <source>failed with {0} error(s) and {1} warning(s)</source>
+        <target state="translated">сбой с ошибками ({0}) и предупреждениями ({1})</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with {0} warning(s)</source>
+        <target state="translated">сбой с предупреждениями ({0})</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">успешно выполнено</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with {0} warning(s)</source>
+        <target state="translated">успешно выполнено с предупреждениями ({0})</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildSummary">
+        <source>Build summary:</source>
+        <target state="translated">Сводка сборки:</target>
+        <note>
+      A header used by Terminal Logger to introduce the build summary.
+    </note>
+      </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
         <source>MSB4252: Project "{0}" with global properties
     ({1})
@@ -367,6 +446,14 @@
         <target state="translated">MSB4275: попытка создать несколько переопределений одной задачи: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+        's' should reflect the localized abbreviation for seconds
+      </note>
+      </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
         <source>MSB4257: The specified output result cache file is empty.</source>
         <target state="translated">MSB4257: указанный выходной файл кэша результатов пустой.</target>
@@ -636,6 +723,39 @@
         <target state="translated">MSB4268: не удалось правильно завершить работу кэша проектов.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} с)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} с)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph не поддерживает элементы ProjectReference с набором метаданных ToolsVersion. Обнаружен ProjectReference "{0}" с ToolsVersion в файле "{1}"</target>
@@ -674,6 +794,24 @@
         <target state="translated">Доступ к файлам отчетов сейчас поддерживается только при использовании 64-разрядного варианта приложения MSBuild.</target>
         <note />
       </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Восстановление завершено ({0} с)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">Восстановление {0} через {1} с</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverAttempt">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
@@ -793,6 +931,59 @@ Errors: {3}</source>
         <target state="translated">MSB4181: задача "{0}" возвратила значение false, но не зарегистрировала ошибку.</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
+      <trans-unit id="TestProjectFinished_NoTF">
+        <source>{0}{1} test {2} ({3}s)</source>
+        <target state="translated">{0}{1} (тест) {2} ({3} с)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestProjectFinished_WithTF">
+        <source>{0}{1} test {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} (тест) {2} {3} ({4} с)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Сводка теста: всего: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">длительность: {0} с</target>
+        <note>
+      {0} whole number
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">сбой: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">пропущено: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">успешно: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: задача MSBuild собирает проект(ы) {0}, который(ые) не указан(ы) в элементе ProjectReference. В изолированных сборках это может означать, что ссылки явно не указаны как элемент ProjectReference в "{1}".</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index a7d019b7276..8bc03e8a1bc 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -211,6 +211,16 @@
         <target state="translated">Derleme sırasında gereksiz kopyalama işlemlerine yol açacağından 'CopyToOutputDirectory' için 'Always' belirtmeyi önle. Daha etkili kopyalamayı kullanmak için 'PreserveNewest' veya 'IfDifferent' meta veri değerini kullanın veya 'SkipUnchangedFilesOnCopyAlways' özelliğini true olarak ayarlayın.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_MessageFmt">
+        <source>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</source>
+        <target state="translated">Project {0}, .NET SDK'sını '{1}' 'TargetFramework(s)' özelliğini belirtir. Bu özellikler doğrudan C# hedeflerini içeri aktaran projeler tarafından anlaşılmaz.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_Title">
+        <source>'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects that do not use the .NET SDK.</source>
+        <target state="translated">'TargetFramework' ve 'TargetFrameworks' özellikleri dikkate alınmaz ve .NET SDK kullanmayan projelerde belirtilmeli.</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">'{0}' özelliğine erişildi, ancak hiç başlatılmadı.</target>
@@ -241,6 +251,26 @@
         <target state="translated">Kullanılmamış bir özellik bildirilmemelidir.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_MessageFmt">
+        <source>Location: '{0}' cannot be fully trusted, place your projects outside of that folder (Project: {1}).</source>
+        <target state="translated">Konum: '{0}' tam olarak güvenilir olamaz, projelerinizi bu klasörün dışına yerleştirin (Proje: {1}).</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_Title">
+        <source>Downloads folder is untrusted for projects building.</source>
+        <target state="translated">İndirmeler klasörü, proje oluşturma için güvenilir değil.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">"{1}" sn'de {0} oluşturun</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Soru derleme BAŞARISIZ oldu. Güncel olmayan bir hedef veya görev ile karşılaştığından derleme işleminden erken çıkıldı.</target>
@@ -256,6 +286,55 @@
         <target state="translated">Bir oluşturma zaten devam ettiği için işlem tamamlanamıyor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">başarısız oldu</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with {0} error(s)</source>
+        <target state="translated">{0} hata ile başarısız oldu</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
+        <source>failed with {0} error(s) and {1} warning(s)</source>
+        <target state="translated">{0} hata ve {1} uyarıyla başarısız oldu</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with {0} warning(s)</source>
+        <target state="translated">{0} uyarıyla başarısız oldu</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">başarılı</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with {0} warning(s)</source>
+        <target state="translated">{0} uyarıyla başarılı oldu</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildSummary">
+        <source>Build summary:</source>
+        <target state="translated">Derleme özeti:</target>
+        <note>
+      A header used by Terminal Logger to introduce the build summary.
+    </note>
+      </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
         <source>MSB4252: Project "{0}" with global properties
     ({1})
@@ -367,6 +446,14 @@
         <target state="translated">MSB4275: Aynı {0} görevi için birden çok geçersiz kılma işlemi oluşturulmaya çalışıldı</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1}s)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+        's' should reflect the localized abbreviation for seconds
+      </note>
+      </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
         <source>MSB4257: The specified output result cache file is empty.</source>
         <target state="translated">MSB4257: Belirtilen çıkış sonucu önbellek dosyası boş.</target>
@@ -636,6 +723,39 @@
         <target state="translated">MSB4268: Proje önbelleği düzgün bir şekilde kapatılamadı.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3}sn)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3}({4}sn)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph, ToolsVersion meta veri kümesine sahip ProjectReference öğelerini desteklemez. "{1}" dosyasında ToolsVersion içeren ProjectReference "{0}" bulundu</target>
@@ -674,6 +794,24 @@
         <target state="translated">Raporlama dosyası erişimleri şu anda yalnızca MSBuild x64 varyantı kullanıldığında destekleniyor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">Geri yükleme tamamlandı ({0}sn)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">{1}sn içinde {0} geri yükle</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverAttempt">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
@@ -793,6 +931,59 @@ Hatalar: {3}</target>
         <target state="translated">MSB4181: "{0}" görevi false değerini döndürdü ancak günlüğe hata kaydetmedi.</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
+      <trans-unit id="TestProjectFinished_NoTF">
+        <source>{0}{1} test {2} ({3}s)</source>
+        <target state="translated">{0}{1} testi {2} ({3}s)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestProjectFinished_WithTF">
+        <source>{0}{1} test {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} testi {2} {3} ({4}s)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">Test özeti: toplam: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">süre: {0}s</target>
+        <note>
+      {0} whole number
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">başarısız: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">atlandı: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">başarılı: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: MSBuild task, ProjectReference öğesinde belirtilmeyen "{0}" projelerini derliyor. Yalıtılmış derlemelerde bu, genellikle başvuruların "{1}" içinde açıkça ProjectReference öğesi olarak belirtilmediği anlamına gelir</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 66127cb659d..dcc11e8f51b 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -211,6 +211,16 @@
         <target state="translated">避免为 “CopyToOutputDirectory” 指定 “Always”，因为这可能会导致生成过程中出现不必要的复制操作。使用 “PreserveNewest” 或 “IfDifferent” 元数据值，或将 “SkipUnchangedFilesOnCopyAlways” 属性设置为 true 以使用更有效的复制。</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_MessageFmt">
+        <source>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</source>
+        <target state="translated">Project {0} 指定“TargetFramework()”属性 '{1}'，该属性不使用 .NET SDK。直接导入 C# 目标的项目不理解这些属性。</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_Title">
+        <source>'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects that do not use the .NET SDK.</source>
+        <target state="translated">不考虑 “TargetFramework” 和 “TargetFrameworks” 属性，不应在不使用 .NET SDK 的项目中指定这些属性。</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">已访问属性“{0}”，但从未将其初始化过。</target>
@@ -241,6 +251,26 @@
         <target state="translated">不应声明未使用的属性。</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_MessageFmt">
+        <source>Location: '{0}' cannot be fully trusted, place your projects outside of that folder (Project: {1}).</source>
+        <target state="translated">位置： '{0}' 不能完全受信任，请将项目置于项目 (文件夹之外 {1})。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_Title">
+        <source>Downloads folder is untrusted for projects building.</source>
+        <target state="translated">生成项目不信任下载文件夹。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">在 {1} 秒内生成 {0}</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">问题生成失败。生成提前退出，因为遇到不是最新的目标或任务。</target>
@@ -248,7 +278,7 @@
       </trans-unit>
       <trans-unit id="BuildFinishedQuestionSuccess">
         <source>Question build succeeded. Up-to-date checks passed.</source>
-        <target state="translated">问题生成成功。已通过最新检查。</target>
+        <target state="translated">问题生成成功。最新检查已通过。</target>
         <note />
       </trans-unit>
       <trans-unit id="BuildInProgress">
@@ -256,6 +286,55 @@
         <target state="translated">无法完成此操作，因为已经在进行某个生成。</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">失败</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with {0} error(s)</source>
+        <target state="translated">失败，出现 {0} 错误</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
+        <source>failed with {0} error(s) and {1} warning(s)</source>
+        <target state="translated">失败，出现 {0} 错误和 {1} 警告</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with {0} warning(s)</source>
+        <target state="translated">失败，出现 {0} 警告</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">已成功</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with {0} warning(s)</source>
+        <target state="translated">成功，出现 {0} 警告</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildSummary">
+        <source>Build summary:</source>
+        <target state="translated">生成摘要:</target>
+        <note>
+      A header used by Terminal Logger to introduce the build summary.
+    </note>
+      </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
         <source>MSB4252: Project "{0}" with global properties
     ({1})
@@ -367,6 +446,14 @@
         <target state="translated">MSB4275: 已尝试创建同一任务的多个重写: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1} 秒)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+        's' should reflect the localized abbreviation for seconds
+      </note>
+      </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
         <source>MSB4257: The specified output result cache file is empty.</source>
         <target state="translated">MSB4257: 指定的输出结果缓存文件为空。</target>
@@ -636,6 +723,39 @@
         <target state="translated">MSB4268: 项目缓存未能正确关闭。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} 秒)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} 秒)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph 不支持具有 ToolsVersion 元数据集的 ProjectReference 项。在“{1}”文件中发现了带有 ToolsVersion 的 ProjectReference“{0}”</target>
@@ -674,6 +794,24 @@
         <target state="translated">当前仅支持使用 x64 风格的 MSBuild 来报告文件访问情况。</target>
         <note />
       </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">还原完成({0})</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">在 {1} 秒内还原 {0}</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverAttempt">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
@@ -793,6 +931,59 @@ Errors: {3}</source>
         <target state="translated">MSB4181: “{0}”任务返回了 false，但未记录错误。</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
+      <trans-unit id="TestProjectFinished_NoTF">
+        <source>{0}{1} test {2} ({3}s)</source>
+        <target state="translated">{0}{1} 测试 {2} ({3} 秒)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestProjectFinished_WithTF">
+        <source>{0}{1} test {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} 测试 {2} {3} ({4} 秒)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">测试摘要: 总计: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">持续时间: {0} 秒</target>
+        <note>
+      {0} whole number
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">失败: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">已跳过: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">成功: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: MSBuild task 正在生成未在 ProjectReference 项中指定的项目“{0}”。在独立生成中，这可能表示未将引用显式地指定为“{1}”中的 ProjectReference 项</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index c10b95fe378..beb75eae504 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -211,6 +211,16 @@
         <target state="translated">避免為 'CopyToOutputDirectory' 指定 'Always'，因為這可能會在建置期間導致不必要的複製作業。請使用 『PreserveNewest』 或 'IfDifferent' 元數據值，或將 'SkipUnchangedFilesOnCopyAlways' 属性設定為 true，以採用較有效的複製。</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_MessageFmt">
+        <source>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</source>
+        <target state="translated">Project {0} 指定未使用 .NET SDK 的 'TargetFramework(s)' 属性 '{1}'。直接匯入 C# 目標的項目無法瞭解這些屬性。</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0108_Title">
+        <source>'TargetFramework' and 'TargetFrameworks' properties are not respected and should not be specified in projects that do not use the .NET SDK.</source>
+        <target state="translated">未遵守 『TargetFramework』 和 『TargetFrameworks』 屬性，且不應在未使用 .NET SDK 的專案中指定。</target>
+        <note>Terms in quotes are not to be translated.</note>
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">已存取屬性: '{0}'，但從未初始化。</target>
@@ -241,6 +251,26 @@
         <target state="translated">不應宣告未使用的屬性。</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_MessageFmt">
+        <source>Location: '{0}' cannot be fully trusted, place your projects outside of that folder (Project: {1}).</source>
+        <target state="translated">位置： '{0}' 無法完全信任，請將您的專案放在該資料夾之外 (Project： {1})。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0301_Title">
+        <source>Downloads folder is untrusted for projects building.</source>
+        <target state="translated">專案建置不受信任的下載資料夾。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildFinished">
+        <source>Build {0} in {1}s</source>
+        <target state="translated">在 {1} 秒內建置 {0}</target>
+        <note>
+      Overall build summary
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">問題建立失敗。建置提早結束，因為它遇到不是最新的目標或工作。</target>
@@ -256,6 +286,55 @@
         <target state="translated">無法完成作業，因為建置已經在進行中。</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildResult_Failed">
+        <source>failed</source>
+        <target state="translated">失敗</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrors">
+        <source>failed with {0} error(s)</source>
+        <target state="translated">失敗，有 {0} 個錯誤</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
+        <source>failed with {0} error(s) and {1} warning(s)</source>
+        <target state="translated">失敗，有 {0} 個錯誤和 {1} 個警告</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_FailedWithWarnings">
+        <source>failed with {0} warning(s)</source>
+        <target state="translated">失敗，有 {0} 個警告</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_Succeeded">
+        <source>succeeded</source>
+        <target state="translated">成功</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildResult_SucceededWithWarnings">
+        <source>succeeded with {0} warning(s)</source>
+        <target state="translated">成功但有 {0} 個警告</target>
+        <note>
+      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
+    </note>
+      </trans-unit>
+      <trans-unit id="BuildSummary">
+        <source>Build summary:</source>
+        <target state="translated">組建摘要:</target>
+        <note>
+      A header used by Terminal Logger to introduce the build summary.
+    </note>
+      </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
         <source>MSB4252: Project "{0}" with global properties
     ({1})
@@ -367,6 +446,14 @@
         <target state="translated">MSB4275: 已嘗試建立相同工作的多個覆寫: {0}</target>
         <note>{StrBegin="MSB4275: "}</note>
       </trans-unit>
+      <trans-unit id="DurationDisplay">
+        <source>({0:F1}s)</source>
+        <target state="translated">({0:F1} 秒)</target>
+        <note>
+        {0}: duration in seconds with 1 decimal point
+        's' should reflect the localized abbreviation for seconds
+      </note>
+      </trans-unit>
       <trans-unit id="EmptyOutputCacheFile">
         <source>MSB4257: The specified output result cache file is empty.</source>
         <target state="translated">MSB4257: 指定的輸出結果快取檔案是空的。</target>
@@ -636,6 +723,39 @@
         <target state="translated">MSB4268: 無法正確關閉專案快取。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectFinished_NoTF">
+        <source>{0}{1} {2} ({3}s)</source>
+        <target state="translated">{0}{1} {2} ({3} 秒)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_OutputPath">
+        <source> → {0}</source>
+        <target state="translated"> → {0}</target>
+        <note>
+      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
+      {0}: VT100 coded hyperlink to project output directory
+    </note>
+      </trans-unit>
+      <trans-unit id="ProjectFinished_WithTF">
+        <source>{0}{1} {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} {2} {3} ({4} 秒)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="ProjectGraphDoesNotSupportProjectReferenceWithToolset">
         <source>MSB4250: ProjectGraph does not support ProjectReference items with the ToolsVersion metadata set. Found ProjectReference "{0}" with ToolsVersion in file "{1}"</source>
         <target state="translated">MSB4250: ProjectGraph 不支援設有 ToolsVersion 中繼資料的 ProjectReference 項目。在檔案 "{1}" 中找到具有 ToolsVersion 的 ProjectReference "{0}"</target>
@@ -674,6 +794,24 @@
         <target state="translated">目前只支援使用 MSBuild 的 x64 變體來報告檔案存取。</target>
         <note />
       </trans-unit>
+      <trans-unit id="RestoreComplete">
+        <source>Restore complete ({0}s)</source>
+        <target state="translated">還原完成 ({0} 秒)</target>
+        <note>
+      {0}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="RestoreCompleteWithMessage">
+        <source>Restore {0} in {1}s</source>
+        <target state="translated">在 {1} 秒內還原 {0}</target>
+        <note>
+      Restore summary when finished with warning or error
+      {0}: BuildResult_X (below)
+      {1}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
       <trans-unit id="SDKResolverAttempt">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}".
 Warnings: {2}
@@ -793,6 +931,59 @@ Errors: {3}</source>
         <target state="translated">MSB4181: "{0}" 工作傳回了 False，但未記錄錯誤。</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
+      <trans-unit id="TestProjectFinished_NoTF">
+        <source>{0}{1} test {2} ({3}s)</source>
+        <target state="translated">{0}{1} 測試 {2} ({3} 秒)</target>
+        <note>
+      Project finished summary.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: BuildResult_{X}
+      {3}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestProjectFinished_WithTF">
+        <source>{0}{1} test {2} {3} ({4}s)</source>
+        <target state="translated">{0}{1} 測試 {2} {3} ({4} 秒)</target>
+        <note>
+      Project finished summary including target framework information.
+      {0}: indentation - few spaces to visually indent row
+      {1}: project name
+      {2}: target framework
+      {3}: BuildResult_{X}
+      {4}: duration in seconds with 1 decimal point
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_BannerAndTotal">
+        <source>Test summary: total: {0}</source>
+        <target state="translated">測試摘要: 總計: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Duration">
+        <source>duration: {0}s</source>
+        <target state="translated">持續時間: {0} 秒</target>
+        <note>
+      {0} whole number
+      's' should reflect the localized abbreviation for seconds
+    </note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Failed">
+        <source>failed: {0}</source>
+        <target state="translated">失敗: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Skipped">
+        <source>skipped: {0}</source>
+        <target state="translated">已跳過: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
+      <trans-unit id="TestSummary_Succeeded">
+        <source>succeeded: {0}</source>
+        <target state="translated">成功: {0}</target>
+        <note>{0} whole number</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: MSBuild 工作正在建置未在 ProjectReference 項目中指定的專案 "{0}"。在隔離式組建中，這可能代表未在 "{1}" 中將該參考明確指定為 ProjectReference 項目</target>
diff --git a/src/Build/TelemetryInfra/ITelemetryForwarder.cs b/src/Build/TelemetryInfra/ITelemetryForwarder.cs
new file mode 100644
index 00000000000..15d021bfb81
--- /dev/null
+++ b/src/Build/TelemetryInfra/ITelemetryForwarder.cs
@@ -0,0 +1,31 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.BackEnd.Logging;
+
+namespace Microsoft.Build.TelemetryInfra;
+
+/// <summary>
+/// A build component responsible for accumulating telemetry data from worker node and then sending it to main node
+/// at the end of the build.
+/// </summary>
+internal interface ITelemetryForwarder
+{
+    bool IsTelemetryCollected { get; }
+
+    void AddTask(string name, TimeSpan cumulativeExecutionTime, short executionsCount, long totalMemoryConsumed, bool isCustom,
+        bool isFromNugetCache);
+
+    /// <summary>
+    /// Add info about target execution to the telemetry.
+    /// </summary>
+    /// <param name="name"></param>
+    /// <param name="wasExecuted">Means anytime, not necessarily from the last time target was added to telemetry</param>
+    /// <param name="isCustom"></param>
+    /// <param name="isMetaproj"></param>
+    /// <param name="isFromNugetCache"></param>
+    void AddTarget(string name, bool wasExecuted, bool isCustom, bool isMetaproj, bool isFromNugetCache);
+
+    void FinalizeProcessing(LoggingContext loggingContext);
+}
diff --git a/src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs b/src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs
new file mode 100644
index 00000000000..24cd5b9ed0e
--- /dev/null
+++ b/src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs
@@ -0,0 +1,103 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Linq;
+using System.Text.Json;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
+using System.IO;
+
+namespace Microsoft.Build.TelemetryInfra;
+
+internal sealed class InternalTelemetryConsumingLogger : ILogger
+{
+    public LoggerVerbosity Verbosity { get; set; }
+    public string? Parameters { get; set; }
+    internal static event Action<WorkerNodeTelemetryData>? TestOnly_InternalTelemetryAggregted; 
+
+    public void Initialize(IEventSource eventSource)
+    {
+        if (eventSource is IEventSource5 eventSource5)
+        {
+            eventSource5.WorkerNodeTelemetryLogged += EventSource5_WorkerNodeTelemetryLogged;
+            eventSource.BuildFinished += EventSourceOnBuildFinished;
+        }
+    }
+
+    private readonly WorkerNodeTelemetryData _workerNodeTelemetryData = new();
+
+    public IWorkerNodeTelemetryData WorkerNodeTelemetryData => _workerNodeTelemetryData;
+
+    private void EventSource5_WorkerNodeTelemetryLogged(object? sender, WorkerNodeTelemetryEventArgs e)
+    {
+        _workerNodeTelemetryData.Add(e.WorkerNodeTelemetryData);
+    }
+
+    private void EventSourceOnBuildFinished(object sender, BuildFinishedEventArgs e)
+    {
+        TestOnly_InternalTelemetryAggregted?.Invoke(_workerNodeTelemetryData);
+        FlushDataIntoConsoleIfRequested();
+        FlushDataIntoJsonFileIfRequested();
+    }
+
+    private void FlushDataIntoConsoleIfRequested()
+    {
+        if (!Traits.IsEnvVarOneOrTrue("MSBUILDOUTPUTNODESTELEMETRY"))
+        {
+            return;
+        }
+
+        Console.WriteLine("==========================================");
+        Console.WriteLine($"Targets ({_workerNodeTelemetryData.TargetsExecutionData.Count}):");
+        foreach (var target in _workerNodeTelemetryData.TargetsExecutionData)
+        {
+            Console.WriteLine($"{target.Key} : {target.Value}");
+        }
+        Console.WriteLine("==========================================");
+        Console.WriteLine($"Tasks: ({_workerNodeTelemetryData.TasksExecutionData.Count})");
+        Console.WriteLine("Custom tasks:");
+        foreach (var task in _workerNodeTelemetryData.TasksExecutionData.Where(t => t.Key.IsCustom))
+        {
+            Console.WriteLine($"{task.Key}");
+        }
+        Console.WriteLine("==========================================");
+        Console.WriteLine("Tasks by time:");
+        foreach (var task in _workerNodeTelemetryData.TasksExecutionData.OrderByDescending(t => t.Value.CumulativeExecutionTime).Take(20))
+        {
+            Console.WriteLine($"{task.Key} - {task.Value.CumulativeExecutionTime}");
+        }
+        Console.WriteLine("==========================================");
+        Console.WriteLine("Tasks by memory consumption:");
+        foreach (var task in _workerNodeTelemetryData.TasksExecutionData.OrderByDescending(t => t.Value.TotalMemoryConsumption).Take(20))
+        {
+            Console.WriteLine($"{task.Key} - {task.Value.TotalMemoryConsumption / 1024.0:0.00}kB");
+        }
+        Console.WriteLine("==========================================");
+        Console.WriteLine("Tasks by Executions count:");
+        foreach (var task in _workerNodeTelemetryData.TasksExecutionData.OrderByDescending(t => t.Value.ExecutionsCount))
+        {
+            Console.WriteLine($"{task.Key} - {task.Value.ExecutionsCount}");
+        }
+        Console.WriteLine("==========================================");
+    }
+
+    private void FlushDataIntoJsonFileIfRequested()
+    {
+        const string jsonFileNameVariable = "MSBUILDNODETELEMETRYFILENAME";
+        var jsonFilePath = Environment.GetEnvironmentVariable(jsonFileNameVariable);
+        if (string.IsNullOrEmpty(jsonFilePath))
+        {
+            return;
+        }
+
+        var telemetryTags = _workerNodeTelemetryData.AsActivityDataHolder(true, true)?.GetActivityProperties();
+
+        using var stream = File.OpenWrite(jsonFilePath);
+        stream.SetLength(0);
+        JsonSerializer.Serialize(stream, telemetryTags, new JsonSerializerOptions() { WriteIndented = true });
+    }
+
+    public void Shutdown()
+    { }
+}
diff --git a/src/Build/TelemetryInfra/TelemetryDataUtils.cs b/src/Build/TelemetryInfra/TelemetryDataUtils.cs
new file mode 100644
index 00000000000..ed91dcdbaa9
--- /dev/null
+++ b/src/Build/TelemetryInfra/TelemetryDataUtils.cs
@@ -0,0 +1,320 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Text.Json;
+using System.Text.Json.Serialization;
+namespace Microsoft.Build.Framework.Telemetry
+{
+    internal static class TelemetryDataUtils
+    {
+        public static IActivityTelemetryDataHolder? AsActivityDataHolder(this IWorkerNodeTelemetryData? telemetryData, bool includeTasksDetails, bool includeTargetDetails)
+        {
+            if (telemetryData == null)
+            {
+                return null;
+            }
+
+            List<TelemetryItem> telemetryItems = new(4);
+
+            if (includeTasksDetails)
+            {
+                telemetryItems.Add(new TelemetryItem("Tasks",
+                    JsonSerializer.Serialize(telemetryData.TasksExecutionData, _serializerOptions), false));
+            }
+
+            if (includeTargetDetails)
+            {
+                telemetryItems.Add(new TelemetryItem("Targets",
+                    JsonSerializer.Serialize(telemetryData.TargetsExecutionData, _serializerOptions), false));
+            }
+
+            TargetsSummary targetsSummary = new();
+            targetsSummary.Initialize(telemetryData.TargetsExecutionData);
+            telemetryItems.Add(new TelemetryItem("TargetsSummary",
+                JsonSerializer.Serialize(targetsSummary, _serializerOptions), false));
+
+            TasksSummary tasksSummary = new();
+            tasksSummary.Initialize(telemetryData.TasksExecutionData);
+            telemetryItems.Add(new TelemetryItem("TasksSummary",
+                JsonSerializer.Serialize(tasksSummary, _serializerOptions), false));
+
+            return new NodeTelemetry(telemetryItems);
+        }
+
+        private static JsonSerializerOptions _serializerOptions = CreateSerializerOptions();
+
+        private static JsonSerializerOptions CreateSerializerOptions()
+        {
+            var opt = new JsonSerializerOptions
+            {
+                // Add following if user-friendly indentation would be needed
+                // WriteIndented = true,
+                Converters =
+                {
+                    new TargetDataConverter(),
+                    new TaskDataConverter(),
+                    new TargetsSummary(),
+                    new TasksSummary(),
+                },
+            };
+
+            return opt;
+        }
+
+        private class TargetDataConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, bool>?>
+        {
+            public override Dictionary<TaskOrTargetTelemetryKey, bool>? Read(
+                ref Utf8JsonReader reader,
+                Type typeToConvert,
+                JsonSerializerOptions options)
+                =>
+                    throw new NotImplementedException("Reading is not supported");
+
+            public override void Write(
+                Utf8JsonWriter writer,
+                Dictionary<TaskOrTargetTelemetryKey, bool>? value,
+                JsonSerializerOptions options)
+            {
+                if (value == null)
+                {
+                    throw new NotSupportedException("TaskOrTargetTelemetryKey cannot be null in telemetry data");
+                }
+
+                // Following needed - as System.Text.Json doesn't support indexing dictionary by composite types
+
+                writer.WriteStartArray();
+
+                foreach (KeyValuePair<TaskOrTargetTelemetryKey, bool> valuePair in value)
+                {
+                    writer.WriteStartObject(valuePair.Key.IsCustom || valuePair.Key.IsFromMetaProject ? ActivityExtensions.GetHashed(valuePair.Key.Name) : valuePair.Key.Name);
+                    writer.WriteBoolean("WasExecuted", valuePair.Value);
+                    writer.WriteBoolean("IsCustom", valuePair.Key.IsCustom);
+                    writer.WriteBoolean("IsFromNuget", valuePair.Key.IsFromNugetCache);
+                    writer.WriteBoolean("IsMetaproj", valuePair.Key.IsFromMetaProject);
+                    writer.WriteEndObject();
+                }
+
+                writer.WriteEndArray();
+            }
+        }
+
+        private class TaskDataConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>?>
+        {
+            public override Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>? Read(
+                ref Utf8JsonReader reader,
+                Type typeToConvert,
+                JsonSerializerOptions options)
+                =>
+                    throw new NotImplementedException("Reading is not supported");
+
+            public override void Write(
+                Utf8JsonWriter writer,
+                Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>? value,
+                JsonSerializerOptions options)
+            {
+                if (value == null)
+                {
+                    throw new NotSupportedException("TaskOrTargetTelemetryKey cannot be null in telemetry data");
+                }
+
+                // Following needed - as System.Text.Json doesn't support indexing dictionary by composite types
+
+                writer.WriteStartArray();
+
+                foreach (KeyValuePair<TaskOrTargetTelemetryKey, TaskExecutionStats> valuePair in value)
+                {
+                    writer.WriteStartObject(valuePair.Key.IsCustom ? ActivityExtensions.GetHashed(valuePair.Key.Name) : valuePair.Key.Name);
+                    // We do not want decimals
+                    writer.WriteNumber("ExecTimeMs", valuePair.Value.CumulativeExecutionTime.TotalMilliseconds / 1);
+                    writer.WriteNumber("ExecCnt", valuePair.Value.ExecutionsCount);
+                    // We do not want decimals
+                    writer.WriteNumber("MemKBs", valuePair.Value.TotalMemoryConsumption / 1024);
+                    writer.WriteBoolean("IsCustom", valuePair.Key.IsCustom);
+                    writer.WriteBoolean("IsFromNuget", valuePair.Key.IsFromNugetCache);
+                    writer.WriteEndObject();
+                }
+
+                writer.WriteEndArray();
+            }
+        }
+
+        private class TargetsSummary : JsonConverter<TargetsSummary>
+        {
+            public void Initialize(Dictionary<TaskOrTargetTelemetryKey, bool> targetsExecutionData)
+            {
+                foreach (var targetInfo in targetsExecutionData)
+                {
+                    UpdateStatistics(LoadedBuiltinTargetInfo, LoadedCustomTargetInfo, targetInfo.Key);
+                    if (targetInfo.Value)
+                    {
+                        UpdateStatistics(ExecutedBuiltinTargetInfo, ExecutedCustomTargetInfo, targetInfo.Key);
+                    }
+                }
+
+                void UpdateStatistics(
+                    TargetInfo builtinTargetInfo,
+                    TargetInfo customTargetInfo,
+                    TaskOrTargetTelemetryKey key)
+                {
+                    UpdateSingleStatistics(key.IsCustom ? customTargetInfo : builtinTargetInfo, key);
+
+                    void UpdateSingleStatistics(TargetInfo targetInfo, TaskOrTargetTelemetryKey kkey)
+                    {
+                        targetInfo.Total++;
+                        if (kkey.IsFromNugetCache)
+                        {
+                            targetInfo.FromNuget++;
+                        }
+                        if (kkey.IsFromMetaProject)
+                        {
+                            targetInfo.FromMetaproj++;
+                        }
+                    }
+                }
+            }
+
+            private TargetInfo LoadedBuiltinTargetInfo { get; } = new();
+            private TargetInfo LoadedCustomTargetInfo { get; } = new();
+            private TargetInfo ExecutedBuiltinTargetInfo { get; } = new();
+            private TargetInfo ExecutedCustomTargetInfo { get; } = new();
+
+            private class TargetInfo
+            {
+                public int Total { get; internal set; }
+                public int FromNuget { get; internal set; }
+                public int FromMetaproj { get; internal set; }
+            }
+
+            public override TargetsSummary? Read(
+                ref Utf8JsonReader reader,
+                Type typeToConvert,
+                JsonSerializerOptions options) =>
+            throw new NotImplementedException("Reading is not supported");
+
+            public override void Write(
+                Utf8JsonWriter writer,
+                TargetsSummary value,
+                JsonSerializerOptions options)
+            {
+                writer.WriteStartObject();
+                writer.WriteStartObject("Loaded");
+                WriteStat(writer, value.LoadedBuiltinTargetInfo, value.LoadedCustomTargetInfo);
+                writer.WriteEndObject();
+                writer.WriteStartObject("Executed");
+                WriteStat(writer, value.ExecutedBuiltinTargetInfo, value.ExecutedCustomTargetInfo);
+                writer.WriteEndObject();
+                writer.WriteEndObject();
+
+
+                void WriteStat(Utf8JsonWriter writer, TargetInfo customTargetsInfo, TargetInfo builtinTargetsInfo)
+                {
+                    writer.WriteNumber("Total", builtinTargetsInfo.Total + customTargetsInfo.Total);
+                    WriteSingleStat(writer, builtinTargetsInfo, "Microsoft");
+                    WriteSingleStat(writer, customTargetsInfo, "Custom");
+                }
+
+                void WriteSingleStat(Utf8JsonWriter writer, TargetInfo targetInfo, string name)
+                {
+                    if (targetInfo.Total > 0)
+                    {
+                        writer.WriteStartObject(name);
+                        writer.WriteNumber("Total", targetInfo.Total);
+                        writer.WriteNumber("FromNuget", targetInfo.FromNuget);
+                        writer.WriteNumber("FromMetaproj", targetInfo.FromMetaproj);
+                        writer.WriteEndObject();
+                    }
+                }
+            }
+        }
+
+
+        private class TasksSummary : JsonConverter<TasksSummary>
+        {
+            public void Initialize(Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats> tasksExecutionData)
+            {
+                foreach (var taskInfo in tasksExecutionData)
+                {
+                    UpdateStatistics(BuiltinTasksInfo, CustomTasksInfo, taskInfo.Key, taskInfo.Value);
+                }
+
+                void UpdateStatistics(
+                    TasksInfo builtinTaskInfo,
+                    TasksInfo customTaskInfo,
+                    TaskOrTargetTelemetryKey key,
+                    TaskExecutionStats taskExecutionStats)
+                {
+                    UpdateSingleStatistics(key.IsCustom ? customTaskInfo : builtinTaskInfo, taskExecutionStats, key);
+
+                    void UpdateSingleStatistics(TasksInfo summarizedTaskInfo, TaskExecutionStats infoToAdd, TaskOrTargetTelemetryKey kkey)
+                    {
+                        summarizedTaskInfo.Total.AddAnother(infoToAdd);
+                        if (kkey.IsFromNugetCache)
+                        {
+                            summarizedTaskInfo.FromNuget.AddAnother(infoToAdd);
+                        }
+                    }
+                }
+            }
+
+            private TasksInfo BuiltinTasksInfo { get; } = new TasksInfo();
+            private TasksInfo CustomTasksInfo { get; } = new TasksInfo();
+
+            private class TasksInfo
+            {
+                public TaskExecutionStats Total { get; } = TaskExecutionStats.CreateEmpty();
+                public TaskExecutionStats FromNuget { get; } = TaskExecutionStats.CreateEmpty();
+            }
+
+            public override TasksSummary? Read(
+                ref Utf8JsonReader reader,
+                Type typeToConvert,
+                JsonSerializerOptions options) =>
+            throw new NotImplementedException("Reading is not supported");
+
+            public override void Write(
+                Utf8JsonWriter writer,
+                TasksSummary value,
+                JsonSerializerOptions options)
+            {
+                writer.WriteStartObject();
+                WriteStat(writer, value.BuiltinTasksInfo, "Microsoft");
+                WriteStat(writer, value.CustomTasksInfo, "Custom");
+                writer.WriteEndObject();
+
+                void WriteStat(Utf8JsonWriter writer, TasksInfo tasksInfo, string name)
+                {
+                    writer.WriteStartObject(name);
+                    WriteSingleStat(writer, tasksInfo.Total, "Total", true);
+                    WriteSingleStat(writer, tasksInfo.FromNuget, "FromNuget", false);
+                    writer.WriteEndObject();
+                }
+
+                void WriteSingleStat(Utf8JsonWriter writer, TaskExecutionStats stats, string name, bool writeIfEmpty)
+                {
+                    if (stats.ExecutionsCount > 0)
+                    {
+                        writer.WriteStartObject(name);
+                        writer.WriteNumber("TotalExecutionsCount", stats.ExecutionsCount);
+                        // We do not want decimals
+                        writer.WriteNumber("CumulativeExecutionTimeMs", (long)stats.CumulativeExecutionTime.TotalMilliseconds);
+                        // We do not want decimals
+                        writer.WriteNumber("CumulativeConsumedMemoryKB", stats.TotalMemoryConsumption / 1024);
+                        writer.WriteEndObject();
+                    }
+                }
+            }
+        }
+
+        private class NodeTelemetry : IActivityTelemetryDataHolder
+        {
+            private readonly IList<TelemetryItem> _items;
+
+            public NodeTelemetry(IList<TelemetryItem> items) => _items = items;
+
+            public IList<TelemetryItem> GetActivityProperties()
+                => _items;
+        }
+    }
+}
diff --git a/src/Build/TelemetryInfra/TelemetryForwarderProvider.cs b/src/Build/TelemetryInfra/TelemetryForwarderProvider.cs
new file mode 100644
index 00000000000..b3522dbf64a
--- /dev/null
+++ b/src/Build/TelemetryInfra/TelemetryForwarderProvider.cs
@@ -0,0 +1,91 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.TelemetryInfra;
+
+/// <summary>
+/// A build component responsible for accumulating telemetry data from worker node and then sending it to main node
+/// at the end of the build.
+/// </summary>
+internal class TelemetryForwarderProvider : IBuildComponent
+{
+    private ITelemetryForwarder? _instance;
+
+    public ITelemetryForwarder Instance => _instance ?? new NullTelemetryForwarder();
+
+    internal static IBuildComponent CreateComponent(BuildComponentType type)
+    {
+        ErrorUtilities.VerifyThrow(type == BuildComponentType.TelemetryForwarder, "Cannot create components of type {0}", type);
+        return new TelemetryForwarderProvider();
+    }
+
+    public void InitializeComponent(IBuildComponentHost host)
+    {
+        ErrorUtilities.VerifyThrow(host != null, "BuildComponentHost was null");
+
+        if (_instance == null)
+        {
+            if (host!.BuildParameters.IsTelemetryEnabled)
+            {
+                _instance = new TelemetryForwarder();
+            }
+            else
+            {
+                _instance = new NullTelemetryForwarder();
+            }
+        }
+    }
+
+    public void ShutdownComponent()
+    {
+        /* Too late here for any communication to the main node or for logging anything. Just cleanup. */
+        _instance = null;
+    }
+
+    public class TelemetryForwarder : ITelemetryForwarder
+    {
+        private readonly WorkerNodeTelemetryData _workerNodeTelemetryData = new();
+
+        // in future, this might be per event type
+        public bool IsTelemetryCollected => true;
+
+        public void AddTask(string name, TimeSpan cumulativeExecutionTime, short executionsCount, long totalMemoryConsumed, bool isCustom, bool isFromNugetCache)
+        {
+            var key = GetKey(name, isCustom, false, isFromNugetCache);
+            _workerNodeTelemetryData.AddTask(key, cumulativeExecutionTime, executionsCount, totalMemoryConsumed);
+        }
+
+        public void AddTarget(string name, bool wasExecuted, bool isCustom, bool isMetaproj, bool isFromNugetCache)
+        {
+            var key = GetKey(name, isCustom, isMetaproj, isFromNugetCache);
+            _workerNodeTelemetryData.AddTarget(key, wasExecuted);
+        }
+
+        private static TaskOrTargetTelemetryKey GetKey(string name, bool isCustom, bool isMetaproj,
+            bool isFromNugetCache)
+            => new TaskOrTargetTelemetryKey(name, isCustom, isFromNugetCache, isMetaproj);
+
+        public void FinalizeProcessing(LoggingContext loggingContext)
+        {
+            WorkerNodeTelemetryEventArgs telemetryArgs = new(_workerNodeTelemetryData)
+                { BuildEventContext = loggingContext.BuildEventContext };
+            loggingContext.LogBuildEvent(telemetryArgs);
+        }
+    }
+
+    public class NullTelemetryForwarder : ITelemetryForwarder
+    {
+        public bool IsTelemetryCollected => false;
+
+        public void AddTask(string name, TimeSpan cumulativeExecutionTime, short executionsCount, long totalMemoryConsumed, bool isCustom, bool isFromNugetCache) { }
+        public void AddTarget(string name, bool wasExecuted, bool isCustom, bool isMetaproj, bool isFromNugetCache) { }
+
+        public void FinalizeProcessing(LoggingContext loggingContext) { }
+    }
+}
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 4dbd13ede6f..5e522888bb8 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -12,8 +12,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Internal
 {
     internal static class EngineFileUtilities
@@ -22,7 +20,7 @@ internal static class EngineFileUtilities
 
         // Regexes for wildcard filespecs that should not get expanded
         // By default all wildcards are expanded.
-        private static List<Regex> s_lazyWildCardExpansionRegexes;
+        private static List<Regex>? s_lazyWildCardExpansionRegexes;
 
         static EngineFileUtilities()
         {
@@ -59,8 +57,8 @@ internal static void CaptureLazyWildcardRegexes()
         internal static string[] GetFileListUnescaped(
             string directoryEscaped,
             string filespecEscaped,
-            object loggingMechanism = null,
-            IElementLocation excludeLocation = null)
+            object? loggingMechanism = null,
+            IElementLocation? excludeLocation = null)
         {
             return GetFileList(
                 directoryEscaped,
@@ -100,17 +98,17 @@ internal static string[] GetFileListUnescaped(
         /// for the Exclude attribute after detecting a drive enumerating wildcard.</param>
         /// <returns>Array of file paths, escaped.</returns>
         internal static string[] GetFileListEscaped(
-            string directoryEscaped,
+            string? directoryEscaped,
             string filespecEscaped,
-            IEnumerable<string> excludeSpecsEscaped = null,
+            IEnumerable<string>? excludeSpecsEscaped = null,
             bool forceEvaluate = false,
-            FileMatcher fileMatcher = null,
-            object loggingMechanism = null,
-            IElementLocation includeLocation = null,
-            IElementLocation excludeLocation = null,
-            IElementLocation importLocation = null,
-            BuildEventContext buildEventContext = null,
-            string buildEventFileInfoFullPath = null,
+            FileMatcher? fileMatcher = null,
+            object? loggingMechanism = null,
+            IElementLocation? includeLocation = null,
+            IElementLocation? excludeLocation = null,
+            IElementLocation? importLocation = null,
+            BuildEventContext? buildEventContext = null,
+            string? buildEventFileInfoFullPath = null,
             bool disableExcludeDriveEnumerationWarning = false)
         {
             return GetFileList(
@@ -171,18 +169,18 @@ internal static bool FilespecHasWildcards(string filespecEscaped)
         /// for the Exclude attribute after detecting a drive enumerating wildcard.</param>
         /// <returns>Array of file paths.</returns>
         private static string[] GetFileList(
-            string directoryEscaped,
-            string filespecEscaped,
+            string? directoryEscaped,
+            string? filespecEscaped,
             bool returnEscaped,
             bool forceEvaluateWildCards,
-            IEnumerable<string> excludeSpecsEscaped,
+            IEnumerable<string>? excludeSpecsEscaped,
             FileMatcher fileMatcher,
-            object loggingMechanism = null,
-            IElementLocation includeLocation = null,
-            IElementLocation excludeLocation = null,
-            IElementLocation importLocation = null,
-            BuildEventContext buildEventContext = null,
-            string buildEventFileInfoFullPath = null,
+            object? loggingMechanism = null,
+            IElementLocation? includeLocation = null,
+            IElementLocation? excludeLocation = null,
+            IElementLocation? importLocation = null,
+            BuildEventContext? buildEventContext = null,
+            string? buildEventFileInfoFullPath = null,
             bool disableExcludeDriveEnumerationWarning = false)
         {
             ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
@@ -286,7 +284,7 @@ private static string[] GetFileList(
                         default:
                             throw new InternalErrorException(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                                 "UnknownLoggingType",
-                                loggingMechanism.GetType(),
+                                loggingMechanism?.GetType(),
                                 nameof(GetFileList)));
                     }
                 }
@@ -327,7 +325,7 @@ private static string[] GetFileList(
                         default:
                             throw new InternalErrorException(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                                 "UnknownLoggingType",
-                                loggingMechanism.GetType(),
+                                loggingMechanism?.GetType(),
                                 nameof(GetFileList)));
                     }
                 }
@@ -338,10 +336,10 @@ private static string[] GetFileList(
                     // as a relative path, we will get back a bunch of relative paths.
                     // If the filespec started out as an absolute path, we will get
                     // back a bunch of absolute paths
-                    (fileList, _, _, string globFailure) = fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
+                    (fileList, _, _, string? globFailure) = fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
 
-                    // log globing failure with the present logging mechanism
-                    if (globFailure != null)
+                    // log globing failure with the present logging mechanism, skip if there is no logging mechanism
+                    if (globFailure != null && loggingMechanism != null)
                     {
                         switch (loggingMechanism)
                         {
@@ -388,7 +386,7 @@ private static string[] GetFileList(
             return fileList;
         }
 
-        private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLoggingContext targetLoggingContext, IElementLocation includeLocation, IElementLocation excludeLocation, bool excludeFileSpecIsEmpty, bool disableExcludeDriveEnumerationWarning, string fileSpec)
+        private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLoggingContext targetLoggingContext, IElementLocation? includeLocation, IElementLocation? excludeLocation, bool excludeFileSpecIsEmpty, bool disableExcludeDriveEnumerationWarning, string fileSpec)
         {
             // Both condition lines are necessary to skip for the first GetFileListEscaped call
             // and reach for the GetFileListUnescaped call when the wildcarded Exclude attribute results
@@ -404,7 +402,7 @@ private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLog
                         fileSpec,
                         XMakeAttributes.exclude,
                         XMakeElements.itemGroup,
-                        excludeLocation.LocationString);
+                        excludeLocation?.LocationString ?? "");
             }
 
             // Both conditions are necessary to reach for both GetFileListEscaped calls
@@ -421,7 +419,7 @@ private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLog
             }
         }
 
-        private static void LogDriveEnumerationWarningWithLoggingService(ILoggingService loggingService, IElementLocation includeLocation, BuildEventContext buildEventContext, string buildEventFileInfoFullPath, string filespecUnescaped)
+        private static void LogDriveEnumerationWarningWithLoggingService(ILoggingService loggingService, IElementLocation? includeLocation, BuildEventContext? buildEventContext, string? buildEventFileInfoFullPath, string filespecUnescaped)
         {
             if (buildEventContext != null && includeLocation != null)
             {
@@ -437,7 +435,7 @@ private static void LogDriveEnumerationWarningWithLoggingService(ILoggingService
             }
         }
 
-        private static void LogDriveEnumerationWarningWithEvaluationLoggingContext(EvaluationLoggingContext evaluationLoggingContext, IElementLocation importLocation, IElementLocation includeLocation, IElementLocation excludeLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
+        private static void LogDriveEnumerationWarningWithEvaluationLoggingContext(EvaluationLoggingContext evaluationLoggingContext, IElementLocation? importLocation, IElementLocation? includeLocation, IElementLocation? excludeLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
         {
             if (importLocation != null)
             {
@@ -468,7 +466,7 @@ private static void LogDriveEnumerationWarningWithEvaluationLoggingContext(Evalu
             }
         }
 
-        private static void ThrowDriveEnumerationExceptionWithTargetLoggingContext(IElementLocation includeLocation, IElementLocation excludeLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
+        private static void ThrowDriveEnumerationExceptionWithTargetLoggingContext(IElementLocation? includeLocation, IElementLocation? excludeLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
         {
             // The first condition is necessary to reach for both GetFileListEscaped calls
             // whenever the wildcarded Include attribute results in drive enumeration, and
@@ -501,7 +499,7 @@ private static void ThrowDriveEnumerationExceptionWithTargetLoggingContext(IElem
             }
         }
 
-        private static void ThrowDriveEnumerationExceptionWithLoggingService(IElementLocation includeLocation, string filespecUnescaped)
+        private static void ThrowDriveEnumerationExceptionWithLoggingService(IElementLocation? includeLocation, string filespecUnescaped)
         {
             ProjectErrorUtilities.ThrowInvalidProject(
                 includeLocation,
@@ -509,10 +507,10 @@ private static void ThrowDriveEnumerationExceptionWithLoggingService(IElementLoc
                 filespecUnescaped,
                 XMakeAttributes.include,
                 XMakeElements.itemGroup,
-                includeLocation.LocationString);
+                includeLocation?.LocationString ?? "");
         }
 
-        private static void ThrowDriveEnumerationExceptionWithEvaluationLoggingContext(IElementLocation importLocation, IElementLocation includeLocation, IElementLocation excludeLocation, string filespecUnescaped, string fileSpec, bool excludeFileSpecIsEmpty)
+        private static void ThrowDriveEnumerationExceptionWithEvaluationLoggingContext(IElementLocation? importLocation, IElementLocation? includeLocation, IElementLocation? excludeLocation, string filespecUnescaped, string fileSpec, bool excludeFileSpecIsEmpty)
         {
             if (importLocation != null)
             {
@@ -565,7 +563,7 @@ private static bool IsValidExclude(string exclude)
 
         private static List<Regex> PopulateRegexFromEnvironment()
         {
-            string wildCards = Environment.GetEnvironmentVariable("MsBuildSkipEagerWildCardEvaluationRegexes");
+            string? wildCards = Environment.GetEnvironmentVariable("MsBuildSkipEagerWildCardEvaluationRegexes");
             if (string.IsNullOrEmpty(wildCards))
             {
                 return new List<Regex>(0);
@@ -590,7 +588,7 @@ private static List<Regex> PopulateRegexFromEnvironment()
 
         private static bool MatchesLazyWildcard(string fileSpec)
         {
-            return _regexMatchCache.Value.GetOrAdd(fileSpec, file => s_lazyWildCardExpansionRegexes.Any(regex => regex.IsMatch(fileSpec)));
+            return _regexMatchCache.Value.GetOrAdd(fileSpec, file => s_lazyWildCardExpansionRegexes!.Any(regex => regex.IsMatch(fileSpec)));
         }
 
         /// <summary>
@@ -601,7 +599,7 @@ private static bool MatchesLazyWildcard(string fileSpec)
         /// <param name="filespecsEscaped"></param>
         /// <param name="currentDirectory"></param>
         /// <returns>A Func that will return true IFF its argument matches any of the specified filespecs.</returns>
-        internal static Func<string, bool> GetFileSpecMatchTester(IList<string> filespecsEscaped, string currentDirectory)
+        internal static Func<string, bool> GetFileSpecMatchTester(IList<string> filespecsEscaped, string? currentDirectory)
         {
             var matchers = filespecsEscaped
                 .Select(fs => new Lazy<FileSpecMatcherTester>(() => FileSpecMatcherTester.Parse(currentDirectory, fs)))
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index f68d76b00c1..3e032c61c9c 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -223,7 +223,7 @@ internal static string GetXmlNodeInnerContents(XmlElementWithLocation node)
             }
 
             // ...or it looks like the whole thing is a big CDATA tag ...
-            bool startsWithCData = (innerXml.IndexOf("<![CDATA[", StringComparison.Ordinal) == 0);
+            bool startsWithCData = innerXml.AsSpan().TrimStart().StartsWith("<![CDATA[".AsSpan(), StringComparison.Ordinal);
 
             if (startsWithCData)
             {
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index 8568632ce04..4b5a516e649 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -169,7 +169,7 @@ private EmbedResourceTestOutput RunEmbeddedResourceTest(string resourceXmlToAdd,
 
         _env.SetCurrentDirectory(Path.Combine(workFolder.Path, entryProjectName));
 
-        string output = RunnerUtilities.ExecBootstrapedMSBuild("-check -restore /p:RespectCulture=" + (respectCulture ? "True" : "\"\""), out bool success);
+        string output = RunnerUtilities.ExecBootstrapedMSBuild("-check -restore /p:WarnOnCultureOverwritten=True /p:RespectCulture=" + (respectCulture ? "True" : "\"\""), out bool success);
         _env.Output.WriteLine(output);
         _env.Output.WriteLine("=========================");
         success.ShouldBeTrue();
@@ -401,6 +401,75 @@ void ReplaceStringInFile(string filePath, string original, string replacement)
         }
     }
 
+    // Windows only - due to targeting NetFx
+    [WindowsOnlyTheory]
+    [InlineData(
+        """
+        <Project ToolsVersion="msbuilddefaulttoolsversion">
+            <PropertyGroup>
+              <TargetFramework>net48</TargetFramework>
+            </PropertyGroup>
+            <Target Name="Build">
+                <Message Text="Build done"/>
+            </Target>
+        </Project>
+        """,
+        false)]
+    [InlineData(
+        """
+        <Project Sdk="Microsoft.NET.Sdk">
+          <PropertyGroup>
+            <TargetFramework>net9.0</TargetFramework>
+          </PropertyGroup>
+        </Project>
+        """,
+        false)]
+    [InlineData(
+        """
+        <Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+          <PropertyGroup>
+            <OutputType>Library</OutputType>
+            <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
+            <OutputPath>bin\Debug\</OutputPath>
+        	<NoWarn>CS2008</NoWarn>
+          </PropertyGroup>
+          <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+        </Project>
+        """,
+        false)]
+    [InlineData(
+        """
+        <Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+          <PropertyGroup>
+            <OutputType>Library</OutputType>
+            <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
+            <TargetFramework>v4.8</TargetFramework>
+            <OutputPath>bin\Debug\</OutputPath>
+        	<NoWarn>CS2008</NoWarn>
+          </PropertyGroup>
+          <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+        </Project>
+        """,
+        true)]
+    public void TFMinNonSdkCheckTest(string projectContent, bool expectCheckTrigger)
+    {
+        TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
+
+        workFolder.CreateFile("testproj.csproj", projectContent);
+
+        _env.SetCurrentDirectory(workFolder.Path);
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild($"-check -restore", out bool success);
+        _env.Output.WriteLine(output);
+        _env.Output.WriteLine("=========================");
+        success.ShouldBeTrue();
+
+        string expectedDiagnostic = "warning BC0108: .* specifies 'TargetFramework\\(s\\)' property";
+        Regex.Matches(output, expectedDiagnostic).Count.ShouldBe(expectCheckTrigger ? 2 : 0);
+
+        GetWarningsCount(output).ShouldBe(expectCheckTrigger ? 1 : 0);
+    }
+
 
     [Fact]
     public void ConfigChangeReflectedOnReuse()
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index 7cb6452f124..440a60cc86e 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -26,7 +26,8 @@
   <ItemGroup>
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
+
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index fc6affaa7d2..91e186d7fe3 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -47,10 +47,6 @@
   </PropertyGroup>
 
   <ItemGroup Condition="'$(IsUnitTestProject)' == 'true'">
-    <!-- Force updated reference to this package because xunit and shouldly
-         are netstandard1.6 and transitively bring in an old reference -->
-    <PackageReference Include="System.Security.Cryptography.X509Certificates" />
-
     <!-- As of 17.3, one TF of Microsoft.NET.Test.Sdk depends on Newtonsoft.Json
          9.0.1, causing it to be downloaded and flagged by component governance -->
     <PackageReference Include="Newtonsoft.Json" />
diff --git a/src/Framework.UnitTests/FileClassifier_Tests.cs b/src/Framework.UnitTests/FileClassifier_Tests.cs
index 5bf6c04f4ce..b0441062a44 100644
--- a/src/Framework.UnitTests/FileClassifier_Tests.cs
+++ b/src/Framework.UnitTests/FileClassifier_Tests.cs
@@ -12,6 +12,12 @@ namespace Microsoft.Build.Framework.UnitTests
 {
     public class FileClassifierTests
     {
+        private sealed class FileClassifierUnderTest : FileClassifier
+        {
+            public void RegisterImmutableDirectory(string directory)
+                => base.RegisterImmutableDirectory(directory, false);
+        }
+
         [Fact]
         public void Shared_ReturnsInstance()
         {
@@ -21,7 +27,7 @@ public void Shared_ReturnsInstance()
         [Fact]
         public void IsNonModifiable_EvaluatesModifiability()
         {
-            FileClassifier classifier = new();
+            FileClassifierUnderTest classifier = new();
 
             var volume = NativeMethodsShared.IsWindows ? @"X:\" : "/home/usr";
             classifier.RegisterImmutableDirectory($"{Path.Combine(volume, "Test1")}");
@@ -35,7 +41,7 @@ public void IsNonModifiable_EvaluatesModifiability()
         [Fact]
         public void IsNonModifiable_DuplicateNugetRegistry_EvaluatesModifiability()
         {
-            FileClassifier classifier = new();
+            FileClassifierUnderTest classifier = new();
 
             var volume = NativeMethodsShared.IsWindows ? @"X:\" : "/home/usr";
 
@@ -53,7 +59,7 @@ public void IsNonModifiable_DuplicateNugetRegistry_EvaluatesModifiability()
         [Fact]
         public void IsNonModifiable_RespectsOSCaseSensitivity()
         {
-            FileClassifier classifier = new();
+            FileClassifierUnderTest classifier = new();
 
             var volume = NativeMethodsShared.IsWindows ? @"X:\" : "/home/usr";
             classifier.RegisterImmutableDirectory($"{Path.Combine(volume, "Test1")}");
@@ -73,7 +79,7 @@ public void IsNonModifiable_RespectsOSCaseSensitivity()
         [Fact]
         public void IsNonModifiable_DoesntThrowWhenPackageFoldersAreNotRegistered()
         {
-            FileClassifier classifier = new();
+            FileClassifierUnderTest classifier = new();
 
             classifier.IsNonModifiable("X:\\Test3\\File.ext").ShouldBeFalse();
         }
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index f5931d3d9af..53222f7643a 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -12,7 +12,8 @@
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" PrivateAssets="all" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
+
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Framework.UnitTests/WorkerNodeTelemetryEventArgs_Tests.cs b/src/Framework.UnitTests/WorkerNodeTelemetryEventArgs_Tests.cs
new file mode 100644
index 00000000000..57d822d7194
--- /dev/null
+++ b/src/Framework.UnitTests/WorkerNodeTelemetryEventArgs_Tests.cs
@@ -0,0 +1,45 @@
+﻿﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Framework.UnitTests
+{
+    public class WorkerNodeTelemetryEventArgs_Tests
+    {
+        [Fact]
+        public void SerializationDeserializationTest()
+        {
+            WorkerNodeTelemetryData td = new WorkerNodeTelemetryData(
+                new Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>()
+                {
+                        { (TaskOrTargetTelemetryKey)"task1", new TaskExecutionStats(TimeSpan.FromMinutes(1), 5, 1234) },
+                        { (TaskOrTargetTelemetryKey)"task2", new TaskExecutionStats(TimeSpan.Zero, 0, 0) },
+                        { (TaskOrTargetTelemetryKey)"task3", new TaskExecutionStats(TimeSpan.FromTicks(1234), 12, 987654321) }
+                },
+                new Dictionary<TaskOrTargetTelemetryKey, bool>() { { (TaskOrTargetTelemetryKey)"target1", false }, { (TaskOrTargetTelemetryKey)"target2", true }, });
+
+            WorkerNodeTelemetryEventArgs args = new WorkerNodeTelemetryEventArgs(td);
+
+            using MemoryStream stream = new MemoryStream();
+            using BinaryWriter bw = new BinaryWriter(stream);
+            args.WriteToStream(bw);
+
+            stream.Position = 0;
+            using BinaryReader br = new BinaryReader(stream);
+            WorkerNodeTelemetryEventArgs argDeserialized = new();
+            int packetVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
+
+            argDeserialized.CreateFromStream(br, packetVersion);
+            argDeserialized.WorkerNodeTelemetryData.TargetsExecutionData.ShouldBeEquivalentTo(td.TargetsExecutionData);
+            argDeserialized.WorkerNodeTelemetryData.TasksExecutionData.ShouldBeEquivalentTo(td.TasksExecutionData);
+        }
+    }
+}
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index 41a5914dad6..c302b537038 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -493,22 +493,6 @@ public void TranslateEnum<T>(ref T value, int numericValue)
                 value = (T)Enum.ToObject(enumType, numericValue);
             }
 
-            /// <summary>
-            /// Translates a value using the .Net binary formatter.
-            /// </summary>
-            /// <typeparam name="T">The reference type.</typeparam>
-            /// <param name="value">The value to be translated.</param>
-            public void TranslateDotNet<T>(ref T value)
-            {
-                if (!TranslateNullable(value))
-                {
-                    return;
-                }
-
-                BinaryFormatter formatter = new BinaryFormatter();
-                value = (T)formatter.Deserialize(_packetStream);
-            }
-
             public void TranslateException(ref Exception value)
             {
                 if (!TranslateNullable(value))
@@ -1190,26 +1174,6 @@ public void TranslateEnum<T>(ref T value, int numericValue)
                 _writer.Write(numericValue);
             }
 
-            /// <summary>
-            /// Translates a value using the .Net binary formatter.
-            /// </summary>
-            /// <typeparam name="T">The reference type.</typeparam>
-            /// <param name="value">The value to be translated.</param>
-            public void TranslateDotNet<T>(ref T value)
-            {
-                // All the calling paths are already guarded by ChangeWaves.Wave17_10 - so it's a no-op adding it here as well.
-                // But let's have it here explicitly - so it's clearer for the CodeQL reviewers.
-                if (!TranslateNullable(value) || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))
-                {
-                    return;
-                }
-
-                // codeql[cs/dangerous-binary-deserialization] This code needs explicit opt-in to be used (ChangeWaves.Wave17_10). This exists as a temporary compat opt-in for old 3rd party loggers, before they are migrated based on documented guidance.
-                // The opt-in documentation: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves.md#1710
-                BinaryFormatter formatter = new BinaryFormatter();
-                formatter.Serialize(_packetStream, value);
-            }
-
             public void TranslateException(ref Exception value)
             {
                 if (!TranslateNullable(value))
diff --git a/src/Framework/BuildCheck/BuildCheckEventArgs.cs b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
index 442b519894e..d1d3c682a3f 100644
--- a/src/Framework/BuildCheck/BuildCheckEventArgs.cs
+++ b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
@@ -46,12 +46,7 @@ internal override void WriteToStream(BinaryWriter writer)
     {
         base.WriteToStream(writer);
 
-        writer.Write7BitEncodedInt(TracingData.InfrastructureTracingData.Count);
-        foreach (KeyValuePair<string, TimeSpan> kvp in TracingData.InfrastructureTracingData)
-        {
-            writer.Write(kvp.Key);
-            writer.Write(kvp.Value.Ticks);
-        }
+        writer.WriteDurationsDictionary(TracingData.InfrastructureTracingData);
 
         writer.Write7BitEncodedInt(TracingData.TelemetryData.Count);
         foreach (BuildCheckRuleTelemetryData data in TracingData.TelemetryData.Values)
@@ -82,17 +77,9 @@ internal override void CreateFromStream(BinaryReader reader, int version)
     {
         base.CreateFromStream(reader, version);
 
-        int count = reader.Read7BitEncodedInt();
-        var infrastructureTracingData = new Dictionary<string, TimeSpan>(count);
-        for (int i = 0; i < count; i++)
-        {
-            string key = reader.ReadString();
-            TimeSpan value = TimeSpan.FromTicks(reader.ReadInt64());
-
-            infrastructureTracingData.Add(key, value);
-        }
+        var infrastructureTracingData = reader.ReadDurationDictionary();
 
-        count = reader.Read7BitEncodedInt();
+        int count = reader.Read7BitEncodedInt();
         List<BuildCheckRuleTelemetryData> tracingData = new List<BuildCheckRuleTelemetryData>(count);
         for (int i = 0; i < count; i++)
         {
diff --git a/src/Framework/FileClassifier.cs b/src/Framework/FileClassifier.cs
index 2072633870b..648605cc33e 100644
--- a/src/Framework/FileClassifier.cs
+++ b/src/Framework/FileClassifier.cs
@@ -5,10 +5,11 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.IO;
+using System.Linq;
 using System.Runtime.InteropServices;
+using Microsoft.Build.Shared;
 #if !RUNTIME_TYPE_NETCORE
 using System.Diagnostics;
-using System.Linq;
 using System.Text.RegularExpressions;
 #endif
 
@@ -73,6 +74,12 @@ private set
         /// </summary>
         private static readonly Lazy<FileClassifier> s_sharedInstance = new(() => new FileClassifier());
 
+        private const string MicrosoftAssemblyPrefix = "Microsoft.";
+
+        // Surrogate for the span - to prevent array allocation on each span access.
+        private static readonly char[] s_microsoftAssemblyPrefixChars = MicrosoftAssemblyPrefix.ToCharArray();
+        private static ReadOnlySpan<char> MicrosoftAssemblyPrefixSpan => s_microsoftAssemblyPrefixChars;
+
         /// <summary>
         ///     Serves purpose of thread safe set of known immutable directories.
         /// </summary>
@@ -87,6 +94,13 @@ private set
         /// </summary>
         private volatile IReadOnlyList<string> _knownImmutableDirectoriesSnapshot = [];
 
+        /// <summary>
+        ///     Copy on write snapshot of <see cref="_knownImmutableDirectories"/>, without custom logic locations (e.g. nuget cache).
+        /// </summary>
+        private volatile IReadOnlyList<string> _knownBuiltInLogicDirectoriesSnapshot = [];
+
+        private IReadOnlyList<string> _nugetCacheLocations = [];
+
         /// <summary>
         ///     Creates default FileClassifier which following immutable folders:
         ///     Classifications provided are:
@@ -109,12 +123,12 @@ public FileClassifier()
                 string? programFiles = Environment.GetEnvironmentVariable(programFilesEnv);
                 if (!string.IsNullOrEmpty(programFiles))
                 {
-                    RegisterImmutableDirectory(Path.Combine(programFiles, "Reference Assemblies", "Microsoft"));
+                    RegisterImmutableDirectory(Path.Combine(programFiles, "Reference Assemblies", "Microsoft"), false);
                 }
             }
 
 #if !RUNTIME_TYPE_NETCORE
-            RegisterImmutableDirectory(GetVSInstallationDirectory());
+            RegisterImmutableDirectory(GetVSInstallationDirectory(), false);
 
             static string? GetVSInstallationDirectory()
             {
@@ -141,10 +155,10 @@ public FileClassifier()
 
                 // Seems like MSBuild did not run from VS but from CLI.
                 // Identify current process and run it
-                string processName = Process.GetCurrentProcess().MainModule.FileName;
+                string? processName = EnvironmentUtilities.ProcessPath;
                 string processFileName = Path.GetFileNameWithoutExtension(processName);
 
-                if (string.IsNullOrEmpty(processFileName))
+                if (processName == null || string.IsNullOrEmpty(processFileName))
                 {
                     return null;
                 }
@@ -196,6 +210,22 @@ static string GetFolderAbove(string path, int count = 1)
         /// </summary>
         public static FileClassifier Shared => s_sharedInstance.Value;
 
+        /// <summary>
+        ///    Checks if assembly name indicates it is a Microsoft assembly.
+        /// </summary>
+        /// <param name="assemblyName"></param>
+        public static bool IsMicrosoftAssembly(string assemblyName)
+            => assemblyName.StartsWith("Microsoft.", StringComparison.OrdinalIgnoreCase);
+
+        /// <summary>
+        ///    Checks if assembly name indicates it is a Microsoft assembly.
+        /// </summary>
+        public static bool IsMicrosoftAssembly(ReadOnlySpan<char> assemblyName)
+            => assemblyName.StartsWith(MicrosoftAssemblyPrefixSpan, StringComparison.OrdinalIgnoreCase);
+
+        private static bool IsInLocationList(string filePath, IReadOnlyList<string> locations)
+            => GetFirstMatchingLocationfromList(filePath, locations) is not null;
+
         /// <summary>
         ///     Try add path into set of known immutable paths.
         ///     Files under any of these folders are considered non-modifiable.
@@ -204,7 +234,7 @@ static string GetFolderAbove(string path, int count = 1)
         ///     This value is used by <see cref="IsNonModifiable" />.
         ///     Files in the NuGet package cache are not expected to change over time, once they are created.
         /// </remarks>
-        public void RegisterImmutableDirectory(string? directory)
+        private protected void RegisterImmutableDirectory(string? directory, bool isCustomLogicLocation)
         {
             if (directory?.Length > 0)
             {
@@ -213,6 +243,13 @@ public void RegisterImmutableDirectory(string? directory)
                 if (_knownImmutableDirectories.TryAdd(d, d))
                 {
                     _knownImmutableDirectoriesSnapshot = new List<string>(_knownImmutableDirectories.Values);
+
+                    // Add the location to the build in logic locations - but create a new readonly destination
+                    if (!isCustomLogicLocation)
+                    {
+                        _knownBuiltInLogicDirectoriesSnapshot =
+                            _knownBuiltInLogicDirectoriesSnapshot.Append(d).ToArray();
+                    }
                 }
             }
         }
@@ -222,23 +259,34 @@ public void RegisterFrameworkLocations(Func<string, string?> getPropertyValue)
             // Register toolset paths into list of immutable directories
             // example: C:\Windows\Microsoft.NET\Framework
             string? frameworksPathPrefix32 = GetExistingRootOrNull(getPropertyValue("MSBuildFrameworkToolsPath32")?.Trim());
-            RegisterImmutableDirectory(frameworksPathPrefix32);
+            RegisterImmutableDirectory(frameworksPathPrefix32, false);
             // example: C:\Windows\Microsoft.NET\Framework64
             string? frameworksPathPrefix64 = GetExistingRootOrNull(getPropertyValue("MSBuildFrameworkToolsPath64")?.Trim());
-            RegisterImmutableDirectory(frameworksPathPrefix64);
+            RegisterImmutableDirectory(frameworksPathPrefix64, false);
             // example: C:\Windows\Microsoft.NET\FrameworkArm64
             string? frameworksPathPrefixArm64 = GetExistingRootOrNull(getPropertyValue("MSBuildFrameworkToolsPathArm64")?.Trim());
-            RegisterImmutableDirectory(frameworksPathPrefixArm64);
+            RegisterImmutableDirectory(frameworksPathPrefixArm64, false);
         }
 
         public void RegisterKnownImmutableLocations(Func<string, string?> getPropertyValue)
         {
             // example: C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.7.2
-            RegisterImmutableDirectory(getPropertyValue("FrameworkPathOverride")?.Trim());
+            RegisterImmutableDirectory(getPropertyValue("FrameworkPathOverride")?.Trim(), false);
             // example: C:\Program Files\dotnet\
-            RegisterImmutableDirectory(getPropertyValue("NetCoreRoot")?.Trim());
-            // example: C:\Users\<username>\.nuget\packages\
-            RegisterImmutableDirectory(getPropertyValue("NuGetPackageFolders")?.Trim());
+            RegisterImmutableDirectory(getPropertyValue("NetCoreRoot")?.Trim(), false);
+            // example: C:\Users\<username>\.nuget\packages\;...
+            string[]? nugetLocations =
+                getPropertyValue("NuGetPackageFolders")
+                    ?.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries)
+                    .Select(p => EnsureTrailingSlash(p.Trim())).ToArray();
+            if (nugetLocations is { Length: > 0 })
+            {
+                _nugetCacheLocations = nugetLocations ?? [];
+                foreach (string location in nugetLocations!)
+                {
+                    RegisterImmutableDirectory(location, true);
+                }
+            }
 
             IsImmutablePathsInitialized = true;
         }
@@ -314,25 +362,57 @@ private static string EnsureTrailingSlash(string fileSpec)
             return fileSpec;
         }
 
+        /// <summary>
+        ///     Gets whether a file is expected to be produced as a controlled msbuild logic library ( - produced by Microsoft).
+        /// </summary>
+        /// <param name="filePath">The path to the file to test.</param>
+        /// <returns><see langword="true" /> if the file is supposed to be part of the common targets libraries set.<see langword="false" />.</returns>
+        public bool IsBuiltInLogic(string filePath)
+            => IsInLocationList(filePath, _knownBuiltInLogicDirectoriesSnapshot);
+
         /// <summary>
         ///     Gets whether a file is expected to not be modified in place on disk once it has been created.
         /// </summary>
         /// <param name="filePath">The path to the file to test.</param>
         /// <returns><see langword="true" /> if the file is non-modifiable, otherwise <see langword="false" />.</returns>
         public bool IsNonModifiable(string filePath)
+            => IsInLocationList(filePath, _knownImmutableDirectoriesSnapshot);
+
+        /// <summary>
+        ///    Gets whether a file is assumed to be inside a nuget cache location.
+        /// </summary>
+        public bool IsInNugetCache(string filePath)
+            => IsInLocationList(filePath, _nugetCacheLocations);
+
+        /// <summary>
+        ///    Gets whether a file is assumed to be in the nuget cache and name indicates it's produced by Microsoft.
+        /// </summary>
+        public bool IsMicrosoftPackageInNugetCache(string filePath)
+        {
+            string? containingNugetCache = GetFirstMatchingLocationfromList(filePath, _nugetCacheLocations);
+
+            return containingNugetCache != null &&
+                   IsMicrosoftAssembly(filePath.AsSpan(containingNugetCache.Length));
+        }
+
+        private static string? GetFirstMatchingLocationfromList(string filePath, IReadOnlyList<string> locations)
         {
+            if (string.IsNullOrEmpty(filePath))
+            {
+                return null;
+            }
+
             // Avoid a foreach loop or linq.Any because they allocate.
             // Copy _knownImmutableDirectoriesSnapshot into a local variable so other threads can't modify it during enumeration.
-            IReadOnlyList<string> immutableDirectories = _knownImmutableDirectoriesSnapshot;
-            for (int i = 0; i < immutableDirectories.Count; i++)
+            for (int i = 0; i < locations.Count; i++)
             {
-                if (filePath.StartsWith(immutableDirectories[i], PathComparison))
+                if (filePath.StartsWith(locations[i], PathComparison))
                 {
-                    return true;
+                    return locations[i];
                 }
             }
 
-            return false;
+            return null;
         }
     }
 }
diff --git a/src/Framework/IEventSource5.cs b/src/Framework/IEventSource5.cs
new file mode 100644
index 00000000000..6ce4f300c30
--- /dev/null
+++ b/src/Framework/IEventSource5.cs
@@ -0,0 +1,19 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Framework
+{
+
+    /// <summary>
+    /// Type of handler for internal telemetry from worker node
+    /// </summary>
+    internal delegate void WorkerNodeTelemetryEventHandler(object? sender, WorkerNodeTelemetryEventArgs e);
+
+    internal interface IEventSource5 : IEventSource4
+    {
+        /// <summary>
+        /// this event is raised to when internal telemetry from worker node is logged.
+        /// </summary>
+        event WorkerNodeTelemetryEventHandler WorkerNodeTelemetryLogged;
+    }
+}
diff --git a/src/Framework/ITranslator.cs b/src/Framework/ITranslator.cs
index edf5b47765e..5f6655cef36 100644
--- a/src/Framework/ITranslator.cs
+++ b/src/Framework/ITranslator.cs
@@ -255,18 +255,6 @@ BinaryWriter Writer
         void TranslateEnum<T>(ref T value, int numericValue)
             where T : struct, Enum;
 
-        /// <summary>
-        /// Translates a value using the .Net binary formatter.
-        /// </summary>
-        /// <typeparam name="T">The reference type.</typeparam>
-        /// <param name="value">The value to be translated.</param>
-        /// <remarks>
-        /// The primary purpose of this method is to support serialization of Exceptions and
-        /// custom build logging events, since these do not support our custom serialization
-        /// methods.
-        /// </remarks>
-        void TranslateDotNet<T>(ref T value);
-
         void TranslateException(ref Exception value);
 
         /// <summary>
diff --git a/src/Framework/LazyFormattedBuildEventArgs.cs b/src/Framework/LazyFormattedBuildEventArgs.cs
index cec763dd257..209c30536d4 100644
--- a/src/Framework/LazyFormattedBuildEventArgs.cs
+++ b/src/Framework/LazyFormattedBuildEventArgs.cs
@@ -117,7 +117,17 @@ internal override void WriteToStream(BinaryWriter writer)
                     // Arguments may be ints, etc, so explicitly convert
                     // Convert.ToString returns String.Empty when it cannot convert, rather than throwing
                     // It returns null if the input is null.
-                    writer.Write(Convert.ToString(argument, CultureInfo.CurrentCulture) ?? "");
+                    string argValue;
+                    try
+                    {
+                        argValue = Convert.ToString(argument, CultureInfo.CurrentCulture) ?? "";
+                    }
+                    // Let's grace handle case where custom ToString implementation (that Convert.ToString fallbacks to) throws.
+                    catch (Exception e)
+                    {
+                        argValue = $"Argument conversion to string failed{Environment.NewLine}{e}";
+                    }
+                    writer.Write(argValue);
                 }
             }
             else
diff --git a/src/Framework/Logging/AnsiCodes.cs b/src/Framework/Logging/AnsiCodes.cs
index 8466220026b..72545ea4621 100644
--- a/src/Framework/Logging/AnsiCodes.cs
+++ b/src/Framework/Logging/AnsiCodes.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-namespace Microsoft.Build.Logging.TerminalLogger;
+namespace Microsoft.Build.Framework.Logging;
 
 /// <summary>
 /// A collection of standard ANSI/VT100 control codes.
diff --git a/src/Framework/Logging/TerminalColor.cs b/src/Framework/Logging/TerminalColor.cs
index 55b63e915ac..10e66d8f719 100644
--- a/src/Framework/Logging/TerminalColor.cs
+++ b/src/Framework/Logging/TerminalColor.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-namespace Microsoft.Build.Logging.TerminalLogger;
+namespace Microsoft.Build.Framework.Logging;
 
 /// <summary>
 /// Enumerates the text colors supported by VT100 terminal.
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index 271026705ba..da61a612686 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
     <TargetFrameworks>$(LibraryTargetFrameworks)</TargetFrameworks>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
@@ -23,6 +23,15 @@
     <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" PrivateAssets="all" />
     <Reference Include="System.Xaml" />
+    <PackageReference Include="System.Text.Json" />
+    <!-- Telemetry in Framework-->
+    <PackageReference Include="Microsoft.VisualStudio.OpenTelemetry.Collector" PrivateAssets="all" />
+    <PackageReference Include="Microsoft.VisualStudio.OpenTelemetry.ClientExtensions" PrivateAssets="all" />
+  </ItemGroup>
+
+  <!-- Framework and standard don't have DiagnosticSource. -->
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' OR '$(TargetFrameworkIdentifier)' == '.NETStandard'">
+    <PackageReference Include="System.Diagnostics.DiagnosticSource" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
@@ -40,6 +49,7 @@
     <Compile Include="..\Shared\BinaryWriterExtensions.cs">
       <Link>Shared\BinaryWriterExtensions.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\EnvironmentUtilities.cs" Link="EnvironmentUtilities.cs" />
     <Compile Include="..\Shared\IMSBuildElementLocation.cs">
       <Link>Shared\IMSBuildElementLocation.cs</Link>
     </Compile>
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index bbc62463b1e..48d91964772 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -1522,9 +1522,18 @@ private static unsafe int GetCurrentDirectoryWin32(int nBufferLength, char* lpBu
     [SupportedOSPlatform("windows")]
     internal static unsafe string GetFullPath(string path)
     {
-        int bufferSize = GetFullPathWin32(path, 0, null, IntPtr.Zero);
-        char* buffer = stackalloc char[bufferSize];
-        int fullPathLength = GetFullPathWin32(path, bufferSize, buffer, IntPtr.Zero);
+        char* buffer = stackalloc char[MAX_PATH];
+        int fullPathLength = GetFullPathWin32(path, MAX_PATH, buffer, IntPtr.Zero);
+
+        // if user is using long paths we could need to allocate a larger buffer
+        if (fullPathLength > MAX_PATH)
+        {
+            char* newBuffer = stackalloc char[fullPathLength];
+            fullPathLength = GetFullPathWin32(path, fullPathLength, newBuffer, IntPtr.Zero);
+
+            buffer = newBuffer;
+        }
+
         // Avoid creating new strings unnecessarily
         return AreStringsEqual(buffer, fullPathLength, path) ? path : new string(buffer, startIndex: 0, length: fullPathLength);
     }
diff --git a/src/Framework/Profiler/EvaluationIdProvider.cs b/src/Framework/Profiler/EvaluationIdProvider.cs
index e81cc016beb..573204e1e15 100644
--- a/src/Framework/Profiler/EvaluationIdProvider.cs
+++ b/src/Framework/Profiler/EvaluationIdProvider.cs
@@ -3,6 +3,7 @@
 
 using System.Diagnostics;
 using System.Threading;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -14,7 +15,7 @@ namespace Microsoft.Build.Framework.Profiler
     internal static class EvaluationIdProvider
     {
         private static long _sAssignedId = -1;
-        private static readonly long ProcessId = Process.GetCurrentProcess().Id;
+        private static readonly long ProcessId = EnvironmentUtilities.CurrentProcessId;
 
         /// <summary>
         /// Returns a unique evaluation id
diff --git a/src/Framework/PropertyInitialValueSetEventArgs.cs b/src/Framework/PropertyInitialValueSetEventArgs.cs
index 318755fcde3..fe1e52023b6 100644
--- a/src/Framework/PropertyInitialValueSetEventArgs.cs
+++ b/src/Framework/PropertyInitialValueSetEventArgs.cs
@@ -37,13 +37,45 @@ public PropertyInitialValueSetEventArgs(
             string message,
             string helpKeyword = null,
             string senderName = null,
-            MessageImportance importance = MessageImportance.Low) : base(message, helpKeyword, senderName, importance)
+            MessageImportance importance = MessageImportance.Low)
+            : base(message, helpKeyword, senderName, importance)
         {
             this.PropertyName = propertyName;
             this.PropertyValue = propertyValue;
             this.PropertySource = propertySource;
         }
 
+        /// <summary>
+        /// Creates an instance of the <see cref="PropertyInitialValueSetEventArgs"/> class.
+        /// </summary>
+        /// <param name="propertyName">The name of the property.</param>
+        /// <param name="propertyValue">The value of the property.</param>
+        /// <param name="propertySource">The source of the property.</param>
+        /// <param name="file">The file associated with the event.</param>
+        /// <param name="line">The line number (0 if not applicable).</param>
+        /// <param name="column">The column number (0 if not applicable).</param>
+        /// <param name="message">The message of the property.</param>
+        /// <param name="helpKeyword">The help keyword.</param>
+        /// <param name="senderName">The sender name of the event.</param>
+        /// <param name="importance">The importance of the message.</param>
+        public PropertyInitialValueSetEventArgs(
+            string propertyName,
+            string propertyValue,
+            string propertySource,
+            string file,
+            int line,
+            int column,
+            string message,
+            string helpKeyword = null,
+            string senderName = null,
+            MessageImportance importance = MessageImportance.Low)
+            : base(subcategory: null, code: null, file: file, lineNumber: line, columnNumber: column, 0, 0, message, helpKeyword, senderName, importance)
+        {
+            PropertyName = propertyName;
+            PropertyValue = propertyValue;
+            PropertySource = propertySource;
+        }
+
         /// <summary>
         /// The name of the property.
         /// </summary>
@@ -59,6 +91,20 @@ public PropertyInitialValueSetEventArgs(
         /// </summary>
         public string PropertySource { get; set; }
 
+        public override string Message
+        {
+            get
+            {
+                if (RawMessage == null)
+                {
+                    string formattedLocation = File == null ? PropertySource : $"{File} ({LineNumber},{ColumnNumber})";
+                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("PropertyAssignment", PropertyName, PropertyValue, formattedLocation);
+                }
+
+                return RawMessage;
+            }
+        }
+
         internal override void WriteToStream(BinaryWriter writer)
         {
             base.WriteToStream(writer);
diff --git a/src/Framework/PropertyReassignmentEventArgs.cs b/src/Framework/PropertyReassignmentEventArgs.cs
index 29ec2935e0b..d7477ee8caa 100644
--- a/src/Framework/PropertyReassignmentEventArgs.cs
+++ b/src/Framework/PropertyReassignmentEventArgs.cs
@@ -41,12 +41,47 @@ public PropertyReassignmentEventArgs(
             string message,
             string helpKeyword = null,
             string senderName = null,
-            MessageImportance importance = MessageImportance.Low) : base(message, helpKeyword, senderName, importance)
+            MessageImportance importance = MessageImportance.Low)
+            : base(message, helpKeyword, senderName, importance)
         {
-            this.PropertyName = propertyName;
-            this.PreviousValue = previousValue;
-            this.NewValue = newValue;
-            this.Location = location;
+            PropertyName = propertyName;
+            PreviousValue = previousValue;
+            NewValue = newValue;
+            Location = location;
+        }
+
+        /// <summary>
+        /// Creates an instance of the <see cref="PropertyReassignmentEventArgs"/> class.
+        /// </summary>
+        /// <param name="propertyName">The name of the property whose value was reassigned.</param>
+        /// <param name="previousValue">The previous value of the reassigned property.</param>
+        /// <param name="newValue">The new value of the reassigned property.</param>
+        /// <param name="location">The property location (XML, command line, etc).</param>
+        /// <param name="file">The file associated with the event.</param>
+        /// <param name="line">The line number (0 if not applicable).</param>
+        /// <param name="column">The column number (0 if not applicable).</param>
+        /// <param name="message">The message of the property.</param>
+        /// <param name="helpKeyword">The help keyword.</param>
+        /// <param name="senderName">The sender name of the event.</param>
+        /// <param name="importance">The importance of the message.</param>
+        public PropertyReassignmentEventArgs(
+            string propertyName,
+            string previousValue,
+            string newValue,
+            string location,
+            string file,
+            int line,
+            int column,
+            string message,
+            string helpKeyword = null,
+            string senderName = null,
+            MessageImportance importance = MessageImportance.Low)
+            : base(subcategory: null, code: null, file: file, lineNumber: line, columnNumber: column, 0, 0, message, helpKeyword, senderName, importance)
+        {
+            PropertyName = propertyName;
+            PreviousValue = previousValue;
+            NewValue = newValue;
+            Location = location;
         }
 
         /// <summary>
@@ -75,7 +110,8 @@ public override string Message
             {
                 if (RawMessage == null)
                 {
-                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("PropertyReassignment", PropertyName, NewValue, PreviousValue, Location);
+                    string formattedLocation = File == null ? Location : $"{File} ({LineNumber},{ColumnNumber})";
+                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("PropertyReassignment", PropertyName, NewValue, PreviousValue, formattedLocation);
                 }
 
                 return RawMessage;
diff --git a/src/Framework/Telemetry/ActivityExtensions.cs b/src/Framework/Telemetry/ActivityExtensions.cs
new file mode 100644
index 00000000000..aa10b1a6615
--- /dev/null
+++ b/src/Framework/Telemetry/ActivityExtensions.cs
@@ -0,0 +1,111 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Security.Cryptography;
+using System.Text;
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+namespace Microsoft.Build.Framework.Telemetry
+{
+    /// <summary>
+    /// Extension methods for <see cref="Activity"/>. usage in VS OpenTelemetry.
+    /// </summary>
+    internal static class ActivityExtensions
+    {
+        /// <summary>
+        /// Add tags to the activity from a <see cref="IActivityTelemetryDataHolder"/>.
+        /// </summary>
+        public static Activity WithTags(this Activity activity, IActivityTelemetryDataHolder? dataHolder)
+        {
+            if (dataHolder != null)
+            {
+                activity.WithTags(dataHolder.GetActivityProperties());
+            }
+            return activity;
+        }
+
+        /// <summary>
+        /// Add tags to the activity from a list of TelemetryItems.
+        /// </summary>
+        public static Activity WithTags(this Activity activity, IList<TelemetryItem> tags)
+        {
+            foreach (var tag in tags)
+            {
+                activity.WithTag(tag);
+            }
+            return activity;
+        }
+        /// <summary>
+        /// Add a tag to the activity from a <see cref="TelemetryItem"/>.
+        /// </summary>
+        public static Activity WithTag(this Activity activity, TelemetryItem item)
+        {
+            object value = item.NeedsHashing ? GetHashed(item.Value) : item.Value;
+            activity.SetTag($"{TelemetryConstants.PropertyPrefix}{item.Name}", value);
+            return activity;
+        }
+
+        /// <summary>
+        /// Set the start time of the activity.
+        /// </summary>
+        public static Activity WithStartTime(this Activity activity, DateTime? startTime)
+        {
+            if (startTime.HasValue)
+            {
+                activity.SetStartTime(startTime.Value);
+            }
+            return activity;
+        }
+
+        /// <summary>
+        /// Depending on the platform, hash the value using an available mechanism.
+        /// </summary>
+        internal static string GetHashed(object value)
+        {
+            return Sha256Hasher.Hash(value.ToString() ?? "");
+        }
+
+        // https://github.com/dotnet/sdk/blob/8bd19a2390a6bba4aa80d1ac3b6c5385527cc311/src/Cli/Microsoft.DotNet.Cli.Utils/Sha256Hasher.cs + workaround for netstandard2.0
+        private static class Sha256Hasher
+        {
+            /// <summary>
+            /// The hashed mac address needs to be the same hashed value as produced by the other distinct sources given the same input. (e.g. VsCode)
+            /// </summary>
+            public static string Hash(string text)
+            {
+                byte[] bytes = Encoding.UTF8.GetBytes(text);
+#if NET
+                byte[] hash = SHA256.HashData(bytes);
+#if NET9_0_OR_GREATER
+                return Convert.ToHexStringLower(hash);
+#else
+                return Convert.ToHexString(hash).ToLowerInvariant();
+#endif
+
+#else
+                // Create the SHA256 object and compute the hash
+                using (var sha256 = SHA256.Create())
+                {
+                    byte[] hash = sha256.ComputeHash(bytes);
+
+                    // Convert the hash bytes to a lowercase hex string (manual loop approach)
+                    var sb = new StringBuilder(hash.Length * 2);
+                    foreach (byte b in hash)
+                    {
+                        sb.AppendFormat("{0:x2}", b);
+                    }
+
+                    return sb.ToString();
+                }
+#endif
+            }
+
+            public static string HashWithNormalizedCasing(string text)
+            {
+                return Hash(text.ToUpperInvariant());
+            }
+        }
+    }
+}
diff --git a/src/Framework/Telemetry/BuildTelemetry.cs b/src/Framework/Telemetry/BuildTelemetry.cs
index c23d9269c9b..c1a5541def3 100644
--- a/src/Framework/Telemetry/BuildTelemetry.cs
+++ b/src/Framework/Telemetry/BuildTelemetry.cs
@@ -10,7 +10,7 @@ namespace Microsoft.Build.Framework.Telemetry
     /// <summary>
     /// Telemetry of build.
     /// </summary>
-    internal class BuildTelemetry : TelemetryBase
+    internal class BuildTelemetry : TelemetryBase, IActivityTelemetryDataHolder
     {
         public override string EventName => "build";
 
@@ -40,12 +40,12 @@ internal class BuildTelemetry : TelemetryBase
         /// <summary>
         /// Overall build success.
         /// </summary>
-        public bool? Success { get; set; }
+        public bool? BuildSuccess { get; set; }
 
         /// <summary>
         /// Build Target.
         /// </summary>
-        public string? Target { get; set; }
+        public string? BuildTarget { get; set; }
 
         /// <summary>
         /// MSBuild server fallback reason.
@@ -56,23 +56,23 @@ internal class BuildTelemetry : TelemetryBase
         /// <summary>
         /// Version of MSBuild.
         /// </summary>
-        public Version? Version { get; set; }
+        public Version? BuildEngineVersion { get; set; }
 
         /// <summary>
         /// Display version of the Engine suitable for display to a user.
         /// </summary>
-        public string? DisplayVersion { get; set; }
+        public string? BuildEngineDisplayVersion { get; set; }
 
         /// <summary>
         /// Path to project file.
         /// </summary>
-        public string? Project { get; set; }
+        public string? ProjectPath { get; set; }
 
         /// <summary>
         /// Host in which MSBuild build was executed.
         /// For example: "VS", "VSCode", "Azure DevOps", "GitHub Action", "CLI", ...
         /// </summary>
-        public string? Host { get; set; }
+        public string? BuildEngineHost { get; set; }
 
         /// <summary>
         /// True if buildcheck was used.
@@ -88,84 +88,135 @@ internal class BuildTelemetry : TelemetryBase
         /// State of MSBuild server process before this build.
         /// One of 'cold', 'hot', null (if not run as server)
         /// </summary>
-        public string? InitialServerState { get; set; }
+        public string? InitialMSBuildServerState { get; set; }
 
         /// <summary>
         /// Framework name suitable for display to a user.
         /// </summary>
-        public string? FrameworkName { get; set; }
+        public string? BuildEngineFrameworkName { get; set; }
 
         public override IDictionary<string, string> GetProperties()
         {
             var properties = new Dictionary<string, string>();
 
             // populate property values
-            if (DisplayVersion != null)
+            if (BuildEngineDisplayVersion != null)
             {
-                properties["BuildEngineDisplayVersion"] = DisplayVersion;
+                properties[nameof(BuildEngineDisplayVersion)] = BuildEngineDisplayVersion;
             }
 
             if (StartAt.HasValue && FinishedAt.HasValue)
             {
-                properties["BuildDurationInMilliseconds"] = (FinishedAt.Value - StartAt.Value).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+                properties[TelemetryConstants.BuildDurationPropertyName] = (FinishedAt.Value - StartAt.Value).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
             }
 
             if (InnerStartAt.HasValue && FinishedAt.HasValue)
             {
-                properties["InnerBuildDurationInMilliseconds"] = (FinishedAt.Value - InnerStartAt.Value).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+                properties[TelemetryConstants.InnerBuildDurationPropertyName] = (FinishedAt.Value - InnerStartAt.Value).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
             }
 
-            if (FrameworkName != null)
+            if (BuildEngineFrameworkName != null)
             {
-                properties["BuildEngineFrameworkName"] = FrameworkName;
+                properties[nameof(BuildEngineFrameworkName)] = BuildEngineFrameworkName;
             }
 
-            if (Host != null)
+            if (BuildEngineHost != null)
             {
-                properties["BuildEngineHost"] = Host;
+                properties[nameof(BuildEngineHost)] = BuildEngineHost;
             }
 
-            if (InitialServerState != null)
+            if (InitialMSBuildServerState != null)
             {
-                properties["InitialMSBuildServerState"] = InitialServerState;
+                properties[nameof(InitialMSBuildServerState)] = InitialMSBuildServerState;
             }
 
-            if (Project != null)
+            if (ProjectPath != null)
             {
-                properties["ProjectPath"] = Project;
+                properties[nameof(ProjectPath)] = ProjectPath;
             }
 
             if (ServerFallbackReason != null)
             {
-                properties["ServerFallbackReason"] = ServerFallbackReason;
+                properties[nameof(ServerFallbackReason)] = ServerFallbackReason;
             }
 
-            if (Success.HasValue)
+            if (BuildSuccess.HasValue)
             {
-                properties["BuildSuccess"] = Success.HasValue.ToString(CultureInfo.InvariantCulture);
+                properties[nameof(BuildSuccess)] = BuildSuccess.Value.ToString(CultureInfo.InvariantCulture);
             }
 
-            if (Target != null)
+            if (BuildTarget != null)
             {
-                properties["BuildTarget"] = Target;
+                properties[nameof(BuildTarget)] = BuildTarget;
             }
 
-            if (Version != null)
+            if (BuildEngineVersion != null)
             {
-                properties["BuildEngineVersion"] = Version.ToString();
+                properties[nameof(BuildEngineVersion)] = BuildEngineVersion.ToString();
             }
 
             if (BuildCheckEnabled != null)
             {
-                properties["BuildCheckEnabled"] = BuildCheckEnabled.Value.ToString(CultureInfo.InvariantCulture);
+                properties[nameof(BuildCheckEnabled)] = BuildCheckEnabled.Value.ToString(CultureInfo.InvariantCulture);
             }
 
             if (SACEnabled != null)
             {
-                properties["SACEnabled"] = SACEnabled.Value.ToString(CultureInfo.InvariantCulture);
+                properties[nameof(SACEnabled)] = SACEnabled.Value.ToString(CultureInfo.InvariantCulture);
             }
 
             return properties;
         }
+
+        /// <summary>
+        /// Create a list of properties sent to VS telemetry with the information whether they should be hashed.
+        /// </summary>
+        /// <returns></returns>
+        public IList<TelemetryItem> GetActivityProperties()
+        {
+            List<TelemetryItem> telemetryItems = new(8);
+
+            if (StartAt.HasValue && FinishedAt.HasValue)
+            {
+                telemetryItems.Add(new TelemetryItem(TelemetryConstants.BuildDurationPropertyName, (FinishedAt.Value - StartAt.Value).TotalMilliseconds, false));
+            }
+
+            if (InnerStartAt.HasValue && FinishedAt.HasValue)
+            {
+                telemetryItems.Add(new TelemetryItem(TelemetryConstants.InnerBuildDurationPropertyName, (FinishedAt.Value - InnerStartAt.Value).TotalMilliseconds, false));
+            }
+
+            if (BuildEngineHost != null)
+            {
+                telemetryItems.Add(new TelemetryItem(nameof(BuildEngineHost), BuildEngineHost, false));
+            }
+
+            if (BuildSuccess.HasValue)
+            {
+                telemetryItems.Add(new TelemetryItem(nameof(BuildSuccess), BuildSuccess, false));
+            }
+
+            if (BuildTarget != null)
+            {
+                telemetryItems.Add(new TelemetryItem(nameof(BuildTarget), BuildTarget, true));
+            }
+
+            if (BuildEngineVersion != null)
+            {
+                telemetryItems.Add(new TelemetryItem(nameof(BuildEngineVersion), BuildEngineVersion.ToString(), false));
+            }
+
+            if (BuildCheckEnabled != null)
+            {
+                telemetryItems.Add(new TelemetryItem(nameof(BuildCheckEnabled), BuildCheckEnabled, false));
+            }
+
+            if (SACEnabled != null)
+            {
+                telemetryItems.Add(new TelemetryItem(nameof(SACEnabled), SACEnabled, false));
+            }
+
+            return telemetryItems;
+        }
     }
 }
diff --git a/src/Framework/Telemetry/IActivityTelemetryDataHolder.cs b/src/Framework/Telemetry/IActivityTelemetryDataHolder.cs
new file mode 100644
index 00000000000..9eeb0a7509f
--- /dev/null
+++ b/src/Framework/Telemetry/IActivityTelemetryDataHolder.cs
@@ -0,0 +1,15 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using System.Diagnostics;
+
+namespace Microsoft.Build.Framework.Telemetry;
+
+/// <summary>
+/// Interface for classes that hold telemetry data that should be added as tags to an <see cref="Activity"/>.
+/// </summary>
+internal interface IActivityTelemetryDataHolder
+{
+    IList<TelemetryItem> GetActivityProperties();
+}
diff --git a/src/Framework/Telemetry/IWorkerNodeTelemetryData.cs b/src/Framework/Telemetry/IWorkerNodeTelemetryData.cs
new file mode 100644
index 00000000000..7f439252482
--- /dev/null
+++ b/src/Framework/Telemetry/IWorkerNodeTelemetryData.cs
@@ -0,0 +1,12 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Framework;
+
+internal interface IWorkerNodeTelemetryData
+{
+    Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats> TasksExecutionData { get; }
+    Dictionary<TaskOrTargetTelemetryKey, bool> TargetsExecutionData { get; }
+}
diff --git a/src/Framework/Telemetry/InternalTelemetryForwardingLogger.cs b/src/Framework/Telemetry/InternalTelemetryForwardingLogger.cs
new file mode 100644
index 00000000000..95e38567587
--- /dev/null
+++ b/src/Framework/Telemetry/InternalTelemetryForwardingLogger.cs
@@ -0,0 +1,32 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Framework;
+
+/// <remarks>
+/// Ensure that events filtering is in sync with InternalTelemetryConsumingLogger.
+/// </remarks>
+internal class InternalTelemeteryForwardingLogger : IForwardingLogger
+{
+    public IEventRedirector? BuildEventRedirector { get; set; }
+
+    public int NodeId { get; set; }
+
+    public LoggerVerbosity Verbosity { get => LoggerVerbosity.Quiet; set { return; } }
+
+    public string? Parameters { get; set; }
+
+    public void Initialize(IEventSource eventSource, int nodeCount) => Initialize(eventSource);
+
+    public void Initialize(IEventSource eventSource)
+    {
+        if (BuildEventRedirector != null && eventSource is IEventSource5 eventSource5)
+        {
+            eventSource5.WorkerNodeTelemetryLogged += (o,e) => BuildEventRedirector.ForwardEvent(e);
+        }
+    }
+
+    public void Shutdown()
+    {
+    }
+}
diff --git a/src/Framework/Telemetry/MSBuildActivitySource.cs b/src/Framework/Telemetry/MSBuildActivitySource.cs
new file mode 100644
index 00000000000..33668c0926f
--- /dev/null
+++ b/src/Framework/Telemetry/MSBuildActivitySource.cs
@@ -0,0 +1,35 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Diagnostics;
+
+namespace Microsoft.Build.Framework.Telemetry
+{
+    /// <summary>
+    /// Wrapper class for ActivitySource with a <see cref="StartActivity(string)"/> method that wraps Activity name with VS OTel prefix.
+    /// </summary>
+    internal class MSBuildActivitySource
+    {
+        private readonly ActivitySource _source;
+        private readonly double _sampleRate;
+
+        public MSBuildActivitySource(string name, double sampleRate)
+        {
+            _source = new ActivitySource(name);
+            _sampleRate = sampleRate;
+        }
+        /// <summary>
+        /// Prefixes activity with VS OpenTelemetry.
+        /// </summary>
+        /// <param name="name">Name of the telemetry event without prefix.</param>
+        /// <returns></returns>
+        public Activity? StartActivity(string name)
+        {
+            var activity = Activity.Current?.HasRemoteParent == true
+                ? _source.StartActivity($"{TelemetryConstants.EventPrefix}{name}", ActivityKind.Internal, parentId: Activity.Current.ParentId)
+                : _source.StartActivity($"{TelemetryConstants.EventPrefix}{name}");
+            activity?.WithTag(new("SampleRate", _sampleRate, false));
+            return activity;
+        }
+    }
+}
diff --git a/src/Framework/Telemetry/OpenTelemetryManager.cs b/src/Framework/Telemetry/OpenTelemetryManager.cs
new file mode 100644
index 00000000000..f392e1c24e3
--- /dev/null
+++ b/src/Framework/Telemetry/OpenTelemetryManager.cs
@@ -0,0 +1,281 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+#if NETFRAMEWORK
+using Microsoft.VisualStudio.OpenTelemetry.ClientExtensions;
+using Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.Exporters;
+using Microsoft.VisualStudio.OpenTelemetry.Collector.Interfaces;
+using Microsoft.VisualStudio.OpenTelemetry.Collector.Settings;
+using OpenTelemetry;
+using OpenTelemetry.Trace;
+#endif
+using System;
+using System.Diagnostics;
+using System.Threading;
+using System.Globalization;
+using System.Runtime.CompilerServices;
+
+namespace Microsoft.Build.Framework.Telemetry
+{
+
+    /// <summary>
+    /// Singleton class for configuring and managing the telemetry infrastructure with System.Diagnostics.Activity,
+    /// OpenTelemetry SDK, and VS OpenTelemetry Collector.
+    /// </summary>
+    internal class OpenTelemetryManager
+    {
+        // Lazy<T> provides thread-safe lazy initialization.
+        private static readonly Lazy<OpenTelemetryManager> s_instance =
+            new Lazy<OpenTelemetryManager>(() => new OpenTelemetryManager(), LazyThreadSafetyMode.ExecutionAndPublication);
+
+        /// <summary>
+        /// Globally accessible instance of <see cref="OpenTelemetryManager"/>.
+        /// </summary>
+        public static OpenTelemetryManager Instance => s_instance.Value;
+
+        private TelemetryState _telemetryState = TelemetryState.Uninitialized;
+        private readonly object _initializeLock = new();
+        private double _sampleRate = TelemetryConstants.DefaultSampleRate;
+
+#if NETFRAMEWORK
+        private TracerProvider? _tracerProvider;
+        private IOpenTelemetryCollector? _collector;
+#endif
+
+        /// <summary>
+        /// Optional activity source for MSBuild or other telemetry usage.
+        /// </summary>
+        public MSBuildActivitySource? DefaultActivitySource { get; private set; }
+
+        private OpenTelemetryManager()
+        {
+        }
+
+        /// <summary>
+        /// Initializes the telemetry infrastructure. Multiple invocations are no-op, thread-safe.
+        /// </summary>
+        /// <param name="isStandalone">Differentiates between executing as MSBuild.exe or from VS/API.</param>
+        public void Initialize(bool isStandalone)
+        {
+            // for lock free early exit
+            if (_telemetryState != TelemetryState.Uninitialized)
+            {
+                return;
+            }
+
+            lock (_initializeLock)
+            {
+                // for correctness
+                if (_telemetryState != TelemetryState.Uninitialized)
+                {
+                    return;
+                }
+
+                if (IsOptOut())
+                {
+                    _telemetryState = TelemetryState.OptOut;
+                    return;
+                }
+
+                // TODO: temporary until we have green light to enable telemetry perf-wise
+                if (!IsOptIn())
+                {
+                    _telemetryState = TelemetryState.Unsampled;
+                    return;
+                }
+
+                if (!IsSampled())
+                {
+                    _telemetryState = TelemetryState.Unsampled;
+                    return;
+                }
+
+                InitializeActivitySources();
+            }
+#if NETFRAMEWORK
+            try
+            {
+                InitializeTracerProvider();
+
+                // TODO: Enable commented logic when Collector is present in VS
+                // if (isStandalone)
+                InitializeCollector();
+
+                // }
+            }
+            catch (Exception ex) when (ex is System.IO.FileNotFoundException or System.IO.FileLoadException)
+            {
+                // catch exceptions from loading the OTel SDK or Collector to maintain usability of Microsoft.Build.Framework package in our and downstream tests in VS.
+                _telemetryState = TelemetryState.Unsampled;
+                return;
+            }
+#endif
+        }
+
+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads
+        private void InitializeActivitySources()
+        {
+            _telemetryState = TelemetryState.TracerInitialized;
+            DefaultActivitySource = new MSBuildActivitySource(TelemetryConstants.DefaultActivitySourceNamespace, _sampleRate);
+        }
+
+#if NETFRAMEWORK
+        /// <summary>
+        /// Initializes the OpenTelemetry SDK TracerProvider with VS default exporter settings.
+        /// </summary>
+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads
+        private void InitializeTracerProvider()
+        {
+            var exporterSettings = OpenTelemetryExporterSettingsBuilder
+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)
+                .Build();
+
+            TracerProviderBuilder tracerProviderBuilder = Sdk
+                .CreateTracerProviderBuilder()
+                                // this adds listeners to ActivitySources with the prefix "Microsoft.VisualStudio.OpenTelemetry."
+                                .AddVisualStudioDefaultTraceExporter(exporterSettings);
+
+            _tracerProvider = tracerProviderBuilder.Build();
+            _telemetryState = TelemetryState.ExporterInitialized;
+        }
+
+        /// <summary>
+        /// Initializes the VS OpenTelemetry Collector with VS default settings.
+        /// </summary>
+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads
+        private void InitializeCollector()
+        {
+            IOpenTelemetryCollectorSettings collectorSettings = OpenTelemetryCollectorSettingsBuilder
+                .CreateVSDefault(TelemetryConstants.VSMajorVersion)
+                .Build();
+
+            _collector = OpenTelemetryCollectorProvider.CreateCollector(collectorSettings);
+            _collector.StartAsync().GetAwaiter().GetResult();
+
+            _telemetryState = TelemetryState.CollectorInitialized;
+        }
+#endif
+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads
+        private void ForceFlushInner()
+        {
+#if NETFRAMEWORK
+            _tracerProvider?.ForceFlush();
+#endif
+        }
+
+        /// <summary>
+        /// Flush the telemetry in TracerProvider/Exporter.
+        /// </summary>
+        public void ForceFlush()
+        {
+            if (ShouldBeCleanedUp())
+            {
+                ForceFlushInner();
+            }
+        }
+
+        // to avoid assembly loading OpenTelemetry in tests
+        [MethodImpl(MethodImplOptions.NoInlining)] // avoid assembly loads
+        private void ShutdownInner()
+        {
+#if NETFRAMEWORK
+            _tracerProvider?.Shutdown();
+            // Dispose stops the collector, with a default drain timeout of 10s
+            _collector?.Dispose();
+#endif
+        }
+
+        /// <summary>
+        /// Shuts down the telemetry infrastructure.
+        /// </summary>
+        public void Shutdown()
+        {
+            lock (_initializeLock)
+            {
+                if (ShouldBeCleanedUp())
+                {
+                    ShutdownInner();
+                }
+
+                _telemetryState = TelemetryState.Disposed;
+            }
+        }
+
+        /// <summary>
+        /// Determines if the user has explicitly opted out of telemetry.
+        /// </summary>
+        private bool IsOptOut() => Traits.Instance.FrameworkTelemetryOptOut || Traits.Instance.SdkTelemetryOptOut || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_14);
+
+        /// <summary>
+        /// TODO: Temporary until perf of loading OTel is agreed to in VS.
+        /// </summary>
+        private bool IsOptIn() => !IsOptOut() && (Traits.Instance.TelemetryOptIn || Traits.Instance.TelemetrySampleRateOverride.HasValue);
+
+        /// <summary>
+        /// Determines if telemetry should be initialized based on sampling and environment variable overrides.
+        /// </summary>
+        private bool IsSampled()
+        {
+            double? overrideRate = Traits.Instance.TelemetrySampleRateOverride;
+            if (overrideRate.HasValue)
+            {
+                _sampleRate = overrideRate.Value;
+            }
+            else
+            {
+#if !NETFRAMEWORK
+                // In core, OTel infrastructure is not initialized by default.
+                return false;
+#endif
+            }
+
+            // Simple random sampling, this method is called once, no need to save the Random instance.
+            Random random = new();
+            return random.NextDouble() < _sampleRate;
+        }
+
+        private bool ShouldBeCleanedUp() => _telemetryState == TelemetryState.CollectorInitialized || _telemetryState == TelemetryState.ExporterInitialized;
+
+        internal bool IsActive() => _telemetryState == TelemetryState.TracerInitialized || _telemetryState == TelemetryState.CollectorInitialized || _telemetryState == TelemetryState.ExporterInitialized;
+
+        /// <summary>
+        /// State of the telemetry infrastructure.
+        /// </summary>
+        internal enum TelemetryState
+        {
+            /// <summary>
+            /// Initial state.
+            /// </summary>
+            Uninitialized,
+
+            /// <summary>
+            /// Opt out of telemetry.
+            /// </summary>
+            OptOut,
+
+            /// <summary>
+            /// Run not sampled for telemetry.
+            /// </summary>
+            Unsampled,
+
+            /// <summary>
+            /// For core hook, ActivitySource is created.
+            /// </summary>
+            TracerInitialized,
+
+            /// <summary>
+            /// For VS scenario with a collector. ActivitySource, OTel TracerProvider are created.
+            /// </summary>
+            ExporterInitialized,
+
+            /// <summary>
+            /// For standalone, ActivitySource, OTel TracerProvider, VS OpenTelemetry Collector are created.
+            /// </summary>
+            CollectorInitialized,
+
+            /// <summary>
+            /// End state.
+            /// </summary>
+            Disposed
+        }
+    }
+}
diff --git a/src/Framework/Telemetry/TaskExecutionStats.cs b/src/Framework/Telemetry/TaskExecutionStats.cs
new file mode 100644
index 00000000000..b3f1564d615
--- /dev/null
+++ b/src/Framework/Telemetry/TaskExecutionStats.cs
@@ -0,0 +1,65 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Framework;
+
+internal class TaskExecutionStats(TimeSpan cumulativeExecutionTime, int executionsCount, long totalMemoryConsumption)
+{
+    private TaskExecutionStats()
+        : this(TimeSpan.Zero, 0, 0)
+    { }
+
+    internal static TaskExecutionStats CreateEmpty()
+        => new();
+
+    /// <summary>
+    /// Total execution time of the task in all nodes for all projects.
+    /// </summary>
+    public TimeSpan CumulativeExecutionTime { get; set; } = cumulativeExecutionTime;
+
+    /// <summary>
+    /// Total memory consumption (across all executions) in bytes.
+    /// </summary>
+    public long TotalMemoryConsumption { get; set; } = totalMemoryConsumption;
+
+    /// <summary>
+    /// Total number of execution of the tasks in all nodes for all projects.
+    /// </summary>
+    public int ExecutionsCount { get; set; } = executionsCount;
+
+    internal void AddAnother(TaskExecutionStats another)
+    {
+        this.CumulativeExecutionTime += another.CumulativeExecutionTime;
+        this.TotalMemoryConsumption += another.TotalMemoryConsumption;
+        this.ExecutionsCount += another.ExecutionsCount;
+    }
+
+    // We need custom Equals for easier assertations in tests
+    public override bool Equals(object? obj)
+    {
+        if (obj is TaskExecutionStats other)
+        {
+            return Equals(other);
+        }
+        return false;
+    }
+
+    protected bool Equals(TaskExecutionStats other)
+        => CumulativeExecutionTime.Equals(other.CumulativeExecutionTime) &&
+           TotalMemoryConsumption == other.TotalMemoryConsumption &&
+           ExecutionsCount == other.ExecutionsCount;
+
+    // Needed since we override Equals
+    public override int GetHashCode()
+    {
+        unchecked
+        {
+            var hashCode = CumulativeExecutionTime.GetHashCode();
+            hashCode = (hashCode * 397) ^ TotalMemoryConsumption.GetHashCode();
+            hashCode = (hashCode * 397) ^ ExecutionsCount.GetHashCode();
+            return hashCode;
+        }
+    }
+}
diff --git a/src/Framework/Telemetry/TaskOrTargetTelemetryKey.cs b/src/Framework/Telemetry/TaskOrTargetTelemetryKey.cs
new file mode 100644
index 00000000000..864ce31e7a9
--- /dev/null
+++ b/src/Framework/Telemetry/TaskOrTargetTelemetryKey.cs
@@ -0,0 +1,66 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Framework;
+
+internal struct TaskOrTargetTelemetryKey : IEquatable<TaskOrTargetTelemetryKey>
+{
+    public TaskOrTargetTelemetryKey(string name, bool isCustom, bool isFromNugetCache, bool isFromMetaProject)
+    {
+        Name = name;
+        IsCustom = isCustom;
+        IsFromNugetCache = isFromNugetCache;
+        IsFromMetaProject = isFromMetaProject;
+    }
+
+    public TaskOrTargetTelemetryKey(string name, bool isCustom, bool isFromNugetCache)
+    {
+        Name = name;
+        IsCustom = isCustom;
+        IsFromNugetCache = isFromNugetCache;
+    }
+
+    public TaskOrTargetTelemetryKey(string name) => Name = name;
+
+    public static explicit operator TaskOrTargetTelemetryKey(string key) => new(key);
+
+    public string Name { get; }
+    // Indicate custom targets/task - those must be hashed.
+    public bool IsCustom { get; }
+    // Indicate targets/tasks sourced from nuget cache - those can be custom or MSFT provided ones.
+    public bool IsFromNugetCache { get; }
+    // Indicate targets/tasks generated during build - those must be hashed (as they contain paths).
+    public bool IsFromMetaProject { get; }
+
+    public override bool Equals(object? obj)
+    {
+        if (obj is TaskOrTargetTelemetryKey other)
+        {
+            return Equals(other);
+        }
+        return false;
+    }
+
+    public bool Equals(TaskOrTargetTelemetryKey other)
+        => string.Equals(Name, other.Name, StringComparison.OrdinalIgnoreCase) &&
+           IsCustom == other.IsCustom &&
+           IsFromNugetCache == other.IsFromNugetCache &&
+           IsFromMetaProject == other.IsFromMetaProject;
+
+    // We need hash code and equals - so that we can stuff data into dictionaries
+    public override int GetHashCode()
+    {
+        unchecked
+        {
+            var hashCode = Name.GetHashCode();
+            hashCode = (hashCode * 397) ^ IsCustom.GetHashCode();
+            hashCode = (hashCode * 397) ^ IsFromNugetCache.GetHashCode();
+            hashCode = (hashCode * 397) ^ IsFromMetaProject.GetHashCode();
+            return hashCode;
+        }
+    }
+
+    public override string ToString() => $"{Name},Custom:{IsCustom},IsFromNugetCache:{IsFromNugetCache},IsFromMetaProject:{IsFromMetaProject}";
+}
diff --git a/src/Framework/Telemetry/TelemetryConstants.cs b/src/Framework/Telemetry/TelemetryConstants.cs
new file mode 100644
index 00000000000..87df7c68e1c
--- /dev/null
+++ b/src/Framework/Telemetry/TelemetryConstants.cs
@@ -0,0 +1,50 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+namespace Microsoft.Build.Framework.Telemetry;
+
+/// <summary>
+/// Constants for VS OpenTelemetry for basic configuration and appropriate naming for VS exporting/collection.
+/// </summary>
+internal static class TelemetryConstants
+{
+    /// <summary>
+    /// "Microsoft.VisualStudio.OpenTelemetry.*" namespace is required by VS exporting/collection.
+    /// </summary>
+    public const string ActivitySourceNamespacePrefix = "Microsoft.VisualStudio.OpenTelemetry.MSBuild.";
+
+    /// <summary>
+    /// Namespace of the default ActivitySource handling e.g. End of build telemetry.
+    /// </summary>
+    public const string DefaultActivitySourceNamespace = $"{ActivitySourceNamespacePrefix}Default";
+
+    /// <summary>
+    /// Prefix required by VS exporting/collection.
+    /// </summary>
+    public const string EventPrefix = "VS/MSBuild/";
+
+    /// <summary>
+    /// Prefix required by VS exporting/collection.
+    /// </summary>
+    public const string PropertyPrefix = "VS.MSBuild.";
+
+    /// <summary>
+    /// For VS OpenTelemetry Collector to apply the correct privacy policy.
+    /// </summary>
+    public const string VSMajorVersion = "17.0";
+
+    /// <summary>
+    /// Sample rate for the default namespace.
+    /// 1:25000 gives us sample size of sufficient confidence with the assumption we collect the order of 1e7 - 1e8 events per day.
+    /// </summary>
+    public const double DefaultSampleRate = 4e-5;
+
+    /// <summary>
+    /// Name of the property for build duration.
+    /// </summary>
+    public const string BuildDurationPropertyName = "BuildDurationInMilliseconds";
+
+    /// <summary>
+    /// Name of the property for inner build duration.
+    /// </summary>
+    public const string InnerBuildDurationPropertyName = "InnerBuildDurationInMilliseconds";
+}
diff --git a/src/Framework/Telemetry/TelemetryItem.cs b/src/Framework/Telemetry/TelemetryItem.cs
new file mode 100644
index 00000000000..f037d7ddbea
--- /dev/null
+++ b/src/Framework/Telemetry/TelemetryItem.cs
@@ -0,0 +1,6 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Framework.Telemetry;
+
+internal record TelemetryItem(string Name, object Value, bool NeedsHashing);
diff --git a/src/Framework/Telemetry/WorkerNodeTelemetryData.cs b/src/Framework/Telemetry/WorkerNodeTelemetryData.cs
new file mode 100644
index 00000000000..4b5afad229f
--- /dev/null
+++ b/src/Framework/Telemetry/WorkerNodeTelemetryData.cs
@@ -0,0 +1,59 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Framework;
+
+internal class WorkerNodeTelemetryData : IWorkerNodeTelemetryData
+{
+    public WorkerNodeTelemetryData(Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats> tasksExecutionData, Dictionary<TaskOrTargetTelemetryKey, bool> targetsExecutionData)
+    {
+        TasksExecutionData = tasksExecutionData;
+        TargetsExecutionData = targetsExecutionData;
+    }
+
+    public void Add(IWorkerNodeTelemetryData other)
+    {
+        foreach (var task in other.TasksExecutionData)
+        {
+            AddTask(task.Key, task.Value.CumulativeExecutionTime, task.Value.ExecutionsCount, task.Value.TotalMemoryConsumption);
+        }
+
+        foreach (var target in other.TargetsExecutionData)
+        {
+            AddTarget(target.Key, target.Value);
+        }
+    }
+
+    public void AddTask(TaskOrTargetTelemetryKey task, TimeSpan cumulativeExectionTime, int executionsCount, long totalMemoryConsumption)
+    {
+        TaskExecutionStats? taskExecutionStats;
+        if (!TasksExecutionData.TryGetValue(task, out taskExecutionStats))
+        {
+            taskExecutionStats = new(cumulativeExectionTime, executionsCount, totalMemoryConsumption);
+            TasksExecutionData[task] = taskExecutionStats;
+        }
+        else
+        {
+            taskExecutionStats.CumulativeExecutionTime += cumulativeExectionTime;
+            taskExecutionStats.ExecutionsCount += executionsCount;
+            taskExecutionStats.TotalMemoryConsumption += totalMemoryConsumption;
+        }
+    }
+
+    public void AddTarget(TaskOrTargetTelemetryKey target, bool wasExecuted)
+    {
+        TargetsExecutionData[target] =
+            // we just need to store if it was ever executed
+            wasExecuted || (TargetsExecutionData.TryGetValue(target, out bool wasAlreadyExecuted) && wasAlreadyExecuted);
+    }
+
+    public WorkerNodeTelemetryData()
+        : this(new Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>(), new Dictionary<TaskOrTargetTelemetryKey, bool>())
+    { }
+
+    public Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats> TasksExecutionData { get; }
+    public Dictionary<TaskOrTargetTelemetryKey, bool> TargetsExecutionData { get; }
+}
diff --git a/src/Framework/Telemetry/WorkerNodeTelemetryEventArgs.cs b/src/Framework/Telemetry/WorkerNodeTelemetryEventArgs.cs
new file mode 100644
index 00000000000..a416f4245ad
--- /dev/null
+++ b/src/Framework/Telemetry/WorkerNodeTelemetryEventArgs.cs
@@ -0,0 +1,77 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework;
+
+internal sealed class WorkerNodeTelemetryEventArgs(IWorkerNodeTelemetryData workerNodeTelemetryData) : BuildEventArgs
+{
+    public WorkerNodeTelemetryEventArgs()
+        : this(new WorkerNodeTelemetryData())
+    { }
+
+    public IWorkerNodeTelemetryData WorkerNodeTelemetryData { get; private set; } = workerNodeTelemetryData;
+
+    internal override void WriteToStream(BinaryWriter writer)
+    {
+        writer.Write7BitEncodedInt(WorkerNodeTelemetryData.TasksExecutionData.Count);
+        foreach (KeyValuePair<TaskOrTargetTelemetryKey, TaskExecutionStats> entry in WorkerNodeTelemetryData.TasksExecutionData)
+        {
+            WriteToStream(writer, entry.Key);
+            writer.Write(entry.Value.CumulativeExecutionTime.Ticks);
+            writer.Write(entry.Value.ExecutionsCount);
+            writer.Write(entry.Value.TotalMemoryConsumption);
+        }
+
+        writer.Write7BitEncodedInt(WorkerNodeTelemetryData.TargetsExecutionData.Count);
+        foreach (KeyValuePair<TaskOrTargetTelemetryKey, bool> entry in WorkerNodeTelemetryData.TargetsExecutionData)
+        {
+            WriteToStream(writer, entry.Key);
+            writer.Write(entry.Value);
+        }
+    }
+
+    internal override void CreateFromStream(BinaryReader reader, int version)
+    {
+        int count = reader.Read7BitEncodedInt();
+        Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats> tasksExecutionData = new();
+        for (int i = 0; i < count; i++)
+        {
+            tasksExecutionData.Add(ReadFromStream(reader),
+                new TaskExecutionStats(
+                    TimeSpan.FromTicks(reader.ReadInt64()),
+                    reader.ReadInt32(),
+                    reader.ReadInt64()));
+        }
+
+        count = reader.Read7BitEncodedInt();
+        Dictionary<TaskOrTargetTelemetryKey, bool> targetsExecutionData = new();
+        for (int i = 0; i < count; i++)
+        {
+            targetsExecutionData.Add(ReadFromStream(reader), reader.ReadBoolean());
+        }
+
+        WorkerNodeTelemetryData = new WorkerNodeTelemetryData(tasksExecutionData, targetsExecutionData);
+    }
+
+    private static void WriteToStream(BinaryWriter writer, TaskOrTargetTelemetryKey key)
+    {
+        writer.Write(key.Name);
+        writer.Write(key.IsCustom);
+        writer.Write(key.IsFromNugetCache);
+        writer.Write(key.IsFromMetaProject);
+    }
+
+    private static TaskOrTargetTelemetryKey ReadFromStream(BinaryReader reader)
+    {
+        return new TaskOrTargetTelemetryKey(
+            reader.ReadString(),
+            reader.ReadBoolean(),
+            reader.ReadBoolean(),
+            reader.ReadBoolean());
+    }
+}
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 9180690cd73..bcdc4ac195c 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Globalization;
 
-#nullable disable
-
 namespace Microsoft.Build.Framework
 {
     /// <summary>
@@ -36,7 +34,7 @@ public Traits()
 
         public EscapeHatches EscapeHatches { get; }
 
-        internal readonly string MSBuildDisableFeaturesFromVersion = Environment.GetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION");
+        internal readonly string? MSBuildDisableFeaturesFromVersion = Environment.GetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION");
 
         /// <summary>
         /// Do not expand wildcards that match a certain pattern
@@ -67,7 +65,7 @@ public Traits()
         /// <summary>
         /// Allow the user to specify that two processes should not be communicating via an environment variable.
         /// </summary>
-        public static readonly string MSBuildNodeHandshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
+        public static readonly string? MSBuildNodeHandshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
 
         /// <summary>
         /// Override property "MSBuildRuntimeType" to "Full", ignoring the actual runtime type of MSBuild.
@@ -103,7 +101,7 @@ public Traits()
         public readonly bool LogPropertyFunctionsRequiringReflection = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildLogPropertyFunctionsRequiringReflection"));
 
         /// <summary>
-        /// Log all environment variables whether or not they are used in a build in the binary log.
+        /// Log all assembly loads including those that come from known MSBuild and .NET SDK sources in the binary log.
         /// </summary>
         public readonly bool LogAllAssemblyLoads = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLASSEMBLYLOADS"));
 
@@ -134,6 +132,21 @@ public Traits()
 
         public readonly bool InProcNodeDisabled = Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") == "1";
 
+
+        /// <summary>
+        /// Variables controlling opt out at the level of not initializing telemetry infrastructure. Set to "1" or "true" to opt out.
+        /// mirroring
+        /// https://learn.microsoft.com/en-us/dotnet/core/tools/telemetry
+        /// </summary>
+        public bool SdkTelemetryOptOut = IsEnvVarOneOrTrue("DOTNET_CLI_TELEMETRY_OPTOUT");
+        public bool FrameworkTelemetryOptOut = IsEnvVarOneOrTrue("MSBUILD_TELEMETRY_OPTOUT");
+        public double? TelemetrySampleRateOverride = ParseDoubleFromEnvironmentVariable("MSBUILD_TELEMETRY_SAMPLE_RATE");
+        public bool ExcludeTasksDetailsFromTelemetry = IsEnvVarOneOrTrue("MSBUILDTELEMETRYEXCLUDETASKSDETAILS");
+
+        // for VS17.14
+        public readonly bool TelemetryOptIn = IsEnvVarOneOrTrue("MSBUILD_TELEMETRY_OPTIN");
+        public readonly bool SlnParsingWithSolutionPersistenceOptIn = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILD_PARSE_SLN_WITH_SOLUTIONPERSISTENCE"));
+
         public static void UpdateFromEnvironment()
         {
             // Re-create Traits instance to update values in Traits according to current environment.
@@ -149,6 +162,21 @@ private static int ParseIntFromEnvironmentVariableOrDefault(string environmentVa
                 ? result
                 : defaultValue;
         }
+
+        private static double? ParseDoubleFromEnvironmentVariable(string environmentVariable)
+        {
+            return double.TryParse(Environment.GetEnvironmentVariable(environmentVariable), out double result)
+                ? result
+                : null;
+        }
+
+        internal static bool IsEnvVarOneOrTrue(string name)
+        {
+            string? value = Environment.GetEnvironmentVariable(name);
+            return value != null &&
+                   (value.Equals("1", StringComparison.OrdinalIgnoreCase) ||
+                    value.Equals("true", StringComparison.OrdinalIgnoreCase));
+        }
     }
 
     internal class EscapeHatches
@@ -392,29 +420,6 @@ public SdkReferencePropertyExpansionMode? SdkReferencePropertyExpansion
             }
         }
 
-        /// <summary>
-        /// Allows displaying the deprecation warning for BinaryFormatter in your current environment.
-        /// </summary>
-        public bool EnableWarningOnCustomBuildEvent
-        {
-            get
-            {
-                var value = Environment.GetEnvironmentVariable("MSBUILDCUSTOMBUILDEVENTWARNING");
-
-                if (value == null)
-                {
-                    // If variable is not set explicitly, for .NETCORE warning appears.
-#if RUNTIME_TYPE_NETCORE
-                    return true;
-#else
-                    return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10);
-#endif
-                }
-
-                return value == "1";
-            }
-        }
-
         public bool UnquoteTargetSwitchParameters
         {
             get
@@ -423,7 +428,6 @@ public bool UnquoteTargetSwitchParameters
             }
         }
 
-
         private static bool? ParseNullableBoolFromEnvironmentVariable(string environmentVariable)
         {
             var value = Environment.GetEnvironmentVariable(environmentVariable);
@@ -539,7 +543,7 @@ internal static void ThrowInternalError(string message)
         /// <remarks>
         /// Clone from ErrorUtilities which isn't available in Framework.
         /// </remarks>
-        internal static void ThrowInternalError(string message, params object[] args)
+        internal static void ThrowInternalError(string message, params object?[] args)
         {
             throw new InternalErrorException(FormatString(message, args));
         }
@@ -558,7 +562,7 @@ internal static void ThrowInternalError(string message, params object[] args)
         /// <remarks>
         /// Clone from ResourceUtilities which isn't available in Framework.
         /// </remarks>
-        internal static string FormatString(string unformatted, params object[] args)
+        internal static string FormatString(string unformatted, params object?[] args)
         {
             string formatted = unformatted;
 
@@ -568,7 +572,7 @@ internal static string FormatString(string unformatted, params object[] args)
 #if DEBUG
                 // If you accidentally pass some random type in that can't be converted to a string,
                 // FormatResourceString calls ToString() which returns the full name of the type!
-                foreach (object param in args)
+                foreach (object? param in args)
                 {
                     // Check it has a real implementation of ToString() and the type is not actually System.String
                     if (param != null)
diff --git a/src/Framework/UninitializedPropertyReadEventArgs.cs b/src/Framework/UninitializedPropertyReadEventArgs.cs
index 781c8c33bc8..7980bdb5485 100644
--- a/src/Framework/UninitializedPropertyReadEventArgs.cs
+++ b/src/Framework/UninitializedPropertyReadEventArgs.cs
@@ -51,11 +51,25 @@ internal override void WriteToStream(BinaryWriter writer)
 
             writer.WriteOptionalString(PropertyName);
         }
+
         internal override void CreateFromStream(BinaryReader reader, int version)
         {
             base.CreateFromStream(reader, version);
 
             PropertyName = reader.ReadOptionalString();
         }
+
+        public override string Message
+        {
+            get
+            {
+                if (RawMessage == null)
+                {
+                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("UninitializedPropertyRead", PropertyName);
+                }
+
+                return RawMessage;
+            }
+        }
     }
 }
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index 1d116d117d2..0876e2b8eec 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -35,6 +35,9 @@
 
     <!-- Add this explicitly since it's marked as Private in MSBuild.csproj, but we need these at runtime to be like VS. -->
     <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
+    <!-- Remove the direct NETStandard.Library dependency when Microsoft.BuildXL.Processes stops bringing in netstandard1.x dependencies
+         or when a .NET 10 SDK is used (NuGet Package Pruning eliminates netstandard1.x dependencies). -->
+    <PackageReference Include="NETStandard.Library" VersionOverride="2.0.3" PrivateAssets="all" Condition="'$(FeatureReportFileAccesses)' == 'true'" />
   </ItemGroup>
 
   <!-- Use deps file from this project with additional dependencies listed instead of the one generated in the MSBuild project -->
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index 35fa1dbb627..b54e07f48fe 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -7,8 +7,9 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
     <PackageReference Include="Verify.Xunit" />
   </ItemGroup>
 
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.Linux.verified.txt
deleted file mode 100644
index 1631c824d25..00000000000
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.Linux.verified.txt
+++ /dev/null
@@ -1 +0,0 @@
-﻿]9;4;3;\]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.Windows.verified.txt
deleted file mode 100644
index 1631c824d25..00000000000
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintTestSummaryQuietVerbosity_Succeeded.Windows.verified.txt
+++ /dev/null
@@ -1 +0,0 @@
-﻿]9;4;3;\]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 2ce4c96e4bf..2edca8c339b 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -136,7 +136,6 @@
     <Compile Include="CommandLineSwitchException.cs" />
     <Compile Include="..\Shared\CoreCLRAssemblyLoader.cs" Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'" />
     <Compile Include="DistributedLoggerRecord.cs" />
-    <Compile Include="TerminalLogger\*.cs" />
     <Compile Include="InitializationException.cs" />
     <Compile Include="MSBuildClientApp.cs" />
     <Compile Include="NodeEndpointOutOfProcTaskHost.cs" />
@@ -174,8 +173,13 @@
   </ItemGroup>
   <ItemGroup>
     <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
+    <!-- Remove the direct NETStandard.Library dependency when Microsoft.BuildXL.Processes stops bringing in netstandard1.x dependencies
+         or when a .NET 10 SDK is used (NuGet Package Pruning eliminates netstandard1.x dependencies). -->
+    <PackageReference Include="NETStandard.Library" VersionOverride="2.0.3" PrivateAssets="all" Condition="'$(FeatureReportFileAccesses)' == 'true'" />
+
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
+    <PackageReference Include="System.Diagnostics.DiagnosticSource" /><!-- for consistency with Framework via transitives -->
   </ItemGroup>
   <!-- Manually download this library for RoslynCodeTaskFactory.
            See target AddRefAssemblies below. -->
@@ -191,10 +195,7 @@
     <Reference Include="System.Xml" />
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
   </ItemGroup>
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework' AND '$(DotNetBuildSourceOnly)' != 'true'">
-    <!-- Bump these to the latest version despite transitive references to older -->
-    <PackageReference Include="System.Private.Uri" PrivateAssets="all" />
-  </ItemGroup>
+
   <ItemGroup>
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" PrivateAssets="All" />
@@ -206,6 +207,12 @@
     <Copy SourceFiles="@(XsdsForVS)" DestinationFiles="@(XsdsForVS-&gt;'$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'xsd'))%(RecursiveDir)%(Filename)%(Extension)')" SkipUnchangedFiles="true" />
   </Target>
 
+  <Target Name="AvoidValueTupleConflict" BeforeTargets="ResolveAssemblyReferences">
+    <ItemGroup>
+      <Reference Remove="@(Reference->WithMetadataValue(`NuGetPackageId`, `System.ValueTuple`))" />
+    </ItemGroup>
+  </Target>
+
   <!-- Include MSBuild.deps.json and MSBuild.runtimeconfig.json in ContentWithTargetPath so they will be copied to the output folder of projects
        that reference this one. -->
   <Target Name="AddRuntimeDependenciesToContent" Condition=" '$(TargetFrameworkIdentifier)' == '.NETCoreApp'" BeforeTargets="GetCopyToOutputDirectoryItems">
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 607f6acafe9..05365f4f62a 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -162,6 +162,11 @@ elementFormDefault="qualified">
                     <xs:sequence minOccurs="0" maxOccurs="unbounded">
                         <xs:choice>
                             <xs:element name="WrapperTool"/>
+                            <xs:element name="EmbedInteropTypes" type="msb:boolean">
+                                <xs:annotation>
+                                <xs:documentation><!-- _locID_text="COMReference_EmbedInteropTypes" _locComment="" -->Whether the types in this reference need to embedded into the target assembly - interop assemblies only (optional, boolean)</xs:documentation>
+                                </xs:annotation>
+                            </xs:element>
                         </xs:choice>
                     </xs:sequence>
         </xs:extension>
diff --git a/src/MSBuild/MSBuildClientApp.cs b/src/MSBuild/MSBuildClientApp.cs
index fbe3d349fc4..be768b58b8d 100644
--- a/src/MSBuild/MSBuildClientApp.cs
+++ b/src/MSBuild/MSBuildClientApp.cs
@@ -113,10 +113,7 @@ private static string GetCurrentHost()
                 }
                 else
                 {
-                    using (Process currentProcess = Process.GetCurrentProcess())
-                    {
-                        CurrentHost = currentProcess.MainModule?.FileName ?? throw new InvalidOperationException("Failed to retrieve process executable.");
-                    }
+                    CurrentHost = EnvironmentUtilities.ProcessPath ?? throw new InvalidOperationException("Failed to retrieve process executable.");
                 }
             }
 
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 42b71f65fe9..f862ae2adca 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -811,8 +811,9 @@ private NodeEngineShutdownReason HandleShutdown()
             _taskRunnerThread?.Join();
 
             using StreamWriter debugWriter = _debugCommunications
-                ? File.CreateText(string.Format(CultureInfo.CurrentCulture, Path.Combine(FileUtilities.TempFileDirectory, @"MSBuild_NodeShutdown_{0}.txt"), Process.GetCurrentProcess().Id))
-                : null;
+                    ? File.CreateText(string.Format(CultureInfo.CurrentCulture, Path.Combine(FileUtilities.TempFileDirectory, @"MSBuild_NodeShutdown_{0}.txt"), EnvironmentUtilities.CurrentProcessId))
+                    : null;
+
             debugWriter?.WriteLine("Node shutting down with reason {0}.", _shutdownReason);
 
 #if !CLR2COMPATIBILITY
diff --git a/src/MSBuild/PerformanceLogEventListener.cs b/src/MSBuild/PerformanceLogEventListener.cs
index 3eb6090cd4b..6772a6aeefc 100644
--- a/src/MSBuild/PerformanceLogEventListener.cs
+++ b/src/MSBuild/PerformanceLogEventListener.cs
@@ -79,7 +79,7 @@ private PerformanceLogEventListener()
 
         internal void Initialize(string logDirectory)
         {
-            _processIDStr = Process.GetCurrentProcess().Id.ToString();
+            _processIDStr = EnvironmentUtilities.CurrentProcessId.ToString();
 
             // Use a GUID disambiguator to make sure that we have a unique file name.
             string logFilePath = Path.Combine(logDirectory, $"perf-{_processIDStr}-{Guid.NewGuid().ToString("N")}.log");
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index ece0160d846..691ded85c3a 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -1504,14 +1504,14 @@
     <value>MSBUILD : error MSB1059: Targets could not be printed. {0}</value>
     <comment>{StrBegin="MSBUILD : error MSB1059: "}</comment>
   </data>
-  <data name="LoggerCreationError" xml:space="preserve">
+  <data name="XMake.LoggerCreationError" xml:space="preserve">
     <value>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</value>
     <comment>{StrBegin="MSBUILD : error MSB1021: "}
       UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.</comment>
   </data>
-  <data name="LoggerNotFoundError" xml:space="preserve">
+  <data name="XMake.LoggerNotFoundError" xml:space="preserve">
     <value>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</value>
     <comment>
       {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
@@ -1520,7 +1520,7 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </comment>
   </data>
-  <data name="ProjectUpgradeNeededToVcxProj" xml:space="preserve">
+  <data name="XMake.ProjectUpgradeNeededToVcxProj" xml:space="preserve">
     <value>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</value>
     <comment>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</comment>
   </data>
@@ -1636,110 +1636,6 @@
       {StrBegin="MSBUILD : error MSB5016: "}
     </comment>
   </data>
-  <data name="RestoreComplete" xml:space="preserve">
-    <value>Restore complete ({0}s)</value>
-    <comment>
-      {0}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </comment>
-  </data>
-  <data name="RestoreCompleteWithMessage" xml:space="preserve">
-    <value>Restore {0} in {1}s</value>
-    <comment>
-      Restore summary when finished with warning or error
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </comment>
-  </data>
-  <data name="BuildFinished" xml:space="preserve">
-    <value>Build {0} in {1}s</value>
-    <comment>
-      Overall build summary
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </comment>
-  </data>
-  <data name="BuildSummary" xml:space="preserve">
-    <value>Build summary:</value>
-    <comment>
-      A header used by Terminal Logger to introduce the build summary.
-    </comment>
-  </data>
-  <data name="BuildResult_FailedWithErrors" xml:space="preserve">
-    <value>failed with {0} error(s)</value>
-    <comment>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </comment>
-  </data>
-  <data name="BuildResult_FailedWithErrorsAndWarnings" xml:space="preserve">
-    <value>failed with {0} error(s) and {1} warning(s)</value>
-    <comment>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </comment>
-  </data>
-  <data name="BuildResult_FailedWithWarnings" xml:space="preserve">
-    <value>failed with {0} warning(s)</value>
-    <comment>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </comment>
-  </data>
-  <data name="BuildResult_Failed" xml:space="preserve">
-    <value>failed</value>
-    <comment>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </comment>
-  </data>
-  <data name="BuildResult_Succeeded" xml:space="preserve">
-    <value>succeeded</value>
-    <comment>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </comment>
-  </data>
-  <data name="BuildResult_SucceededWithWarnings" xml:space="preserve">
-    <value>succeeded with {0} warning(s)</value>
-    <comment>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </comment>
-  </data>
-  <data name="ProjectFinished_NoTF" xml:space="preserve">
-    <value>{0}{1} {2} ({3}s)</value>
-    <comment>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </comment>
-  </data>
-  <data name="ProjectFinished_WithTF" xml:space="preserve">
-    <value>{0}{1} {2} {3} ({4}s)</value>
-    <comment>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </comment>
-  </data>
-  <data name="ProjectFinished_OutputPath" xml:space="preserve">
-    <value> → {0}</value>
-    <comment>
-      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
-      {0}: VT100 coded hyperlink to project output directory
-    </comment>
-  </data>
-  <data name="DurationDisplay" xml:space="preserve">
-    <value>({0:F1}s)</value>
-    <comment>
-        {0}: duration in seconds with 1 decimal point
-        's' should reflect the localized abbreviation for seconds
-      </comment>
-  </data>
   <data name="BuildFailedWithPropertiesItemsOrTargetResultsRequested" xml:space="preserve">
     <value>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</value>
   </data>
@@ -1752,52 +1648,6 @@
   <data name="TerminalLoggerNotUsedRedirected" xml:space="preserve">
     <value>Terminal Logger was not used because the output is being redirected to a file.</value>
   </data>
-  <data name="TestProjectFinished_NoTF" xml:space="preserve">
-    <value>{0}{1} test {2} ({3}s)</value>
-    <comment>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </comment>
-  </data>
-  <data name="TestProjectFinished_WithTF" xml:space="preserve">
-    <value>{0}{1} test {2} {3} ({4}s)</value>
-    <comment>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </comment>
-  </data>
-  <data name="TestSummary_BannerAndTotal" xml:space="preserve">
-    <value>Test summary: total: {0}</value>
-    <comment>{0} whole number</comment>
-  </data>
-  <data name="TestSummary_Duration" xml:space="preserve">
-    <value>duration: {0}s</value>
-    <comment>
-      {0} whole number
-      's' should reflect the localized abbreviation for seconds
-    </comment>
-  </data>
-  <data name="TestSummary_Failed" xml:space="preserve">
-    <value>failed: {0}</value>
-    <comment>{0} whole number</comment>
-  </data>
-  <data name="TestSummary_Skipped" xml:space="preserve">
-    <value>skipped: {0}</value>
-    <comment>{0} whole number</comment>
-  </data>
-  <data name="TestSummary_Succeeded" xml:space="preserve">
-    <value>succeeded: {0}</value>
-    <comment>{0} whole number</comment>
-  </data>
   <data name="LongPaths" xml:space="preserve">
     <value>Based on the Windows registry key LongPathsEnabled, the LongPaths feature is {0}.</value>
     <comment>"Windows" is the OS, "LongPathsEnabled" should not be localized, and {0} will be "enabled"/"disabled"/"not set"</comment>
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index cf608d268e5..17f88bf1e8b 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -15,65 +15,6 @@
         <target state="translated">Sestavení se nezdařilo. Nelze získat výsledky vlastností, položek a cíle. Viz podrobnosti ve stderr výše.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildFinished">
-        <source>Build {0} in {1}s</source>
-        <target state="translated">Sestavení {0} za {1}s</target>
-        <note>
-      Overall build summary
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Failed">
-        <source>failed</source>
-        <target state="translated">neúspěšné</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrors">
-        <source>failed with {0} error(s)</source>
-        <target state="translated">selhalo s {0} chybami.</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
-        <source>failed with {0} error(s) and {1} warning(s)</source>
-        <target state="translated">selhalo s {0} chybami a {1} upozorněními.</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithWarnings">
-        <source>failed with {0} warning(s)</source>
-        <target state="translated">selhalo s {0} upozorněním(i).</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Succeeded">
-        <source>succeeded</source>
-        <target state="translated">úspěšné</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_SucceededWithWarnings">
-        <source>succeeded with {0} warning(s)</source>
-        <target state="translated">akce proběhla úspěšně s {0} upozorněním(i).</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildSummary">
-        <source>Build summary:</source>
-        <target state="translated">Souhrn sestavení:</target>
-        <note>
-      A header used by Terminal Logger to introduce the build summary.
-    </note>
-      </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
         <target state="translated">Argumenty příkazového řádku = {0}</target>
@@ -92,14 +33,6 @@
         <target state="translated">MSBUILD : error MSB1027: Přepínač -noAutoResponse nelze zadat v souboru automatických odpovědí MSBuild.rsp ani v žádném jiném souboru odpovědí, na který se v souboru automatických odpovědí odkazuje.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DurationDisplay">
-        <source>({0:F1}s)</source>
-        <target state="translated">({0:F1} s)</target>
-        <note>
-        {0}: duration in seconds with 1 decimal point
-        's' should reflect the localized abbreviation for seconds
-      </note>
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -1748,39 +1681,6 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
         <target state="translated">Proces = {0}</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectFinished_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}s)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_OutputPath">
-        <source> → {0}</source>
-        <target state="translated"> → {0}</target>
-        <note>
-      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
-      {0}: VT100 coded hyperlink to project output directory
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Soubor projektu neexistuje.</target>
@@ -1826,24 +1726,6 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
         <target state="translated">{0} přišla z {1}</target>
         <note>
       These are response file switches with the location of the response file on disk.
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreComplete">
-        <source>Restore complete ({0}s)</source>
-        <target state="translated">Obnovení dokončeno ({0}s)</target>
-        <note>
-      {0}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreCompleteWithMessage">
-        <source>Restore {0} in {1}s</source>
-        <target state="translated">Obnoví se {0} za {1}s</target>
-        <note>
-      Restore summary when finished with warning or error
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
     </note>
       </trans-unit>
       <trans-unit id="SAC">
@@ -1930,59 +1812,6 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
         <target state="translated">Terminálový protokolovač se nepoužil, protože výstup se přesměrovává do souboru.</target>
         <note />
       </trans-unit>
-      <trans-unit id="TestProjectFinished_NoTF">
-        <source>{0}{1} test {2} ({3}s)</source>
-        <target state="translated">{0}{1} – test {2} ({3} s)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestProjectFinished_WithTF">
-        <source>{0}{1} test {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} – test {2} {3} ({4} s)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_BannerAndTotal">
-        <source>Test summary: total: {0}</source>
-        <target state="translated">Souhrn testu: celkem: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Duration">
-        <source>duration: {0}s</source>
-        <target state="translated">doba trvání: {0} s</target>
-        <note>
-      {0} whole number
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Failed">
-        <source>failed: {0}</source>
-        <target state="translated">selhalo: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Skipped">
-        <source>skipped: {0}</source>
-        <target state="translated">přeskočeno: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Succeeded">
-        <source>succeeded: {0}</source>
-        <target state="translated">úspěšné: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Pro tento přepínač se nepoužívají žádné parametry.</target>
@@ -2065,29 +1894,6 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
         <target state="translated">MSBUILD : error MSB1047: Soubor, do kterého má být provedeno předběžné zpracování, není platný. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1047: "}</note>
       </trans-unit>
-      <trans-unit id="LoggerCreationError">
-        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
-        <target state="translated">MSBUILD : error MSB1021: Nelze vytvořit instanci protokolovacího nástroje. {0}</target>
-        <note>{StrBegin="MSBUILD : error MSB1021: "}
-      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
-      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
-      </trans-unit>
-      <trans-unit id="LoggerNotFoundError">
-        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
-        <target state="translated">MSBUILD : error MSB1020: Protokolovací nástroj se nenašel. Zkontrolujte následující body: 1.) Zadaný název protokolovacího nástroje je stejný jako název třídy protokolovacího nástroje. 2.) Třída protokolovacího nástroje je veřejná (public) a implementuje rozhraní Microsoft.Build.Framework.ILogger. 3.) Cesta k sestavení protokolovacího nástroje je správná, nebo se protokolovací nástroj dá načíst jenom pomocí zadaného názvu sestavení.</target>
-        <note>
-      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
-      logger class must exist in the given assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectUpgradeNeededToVcxProj">
-        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
-        <target state="translated">MSBUILD : error MSB4192: Soubor projektu {0} je ve formátu .vcproj nebo .dsp, který nástroj MSBuild nemůže přímo sestavit. Proveďte převod projektu – otevřete projekt v prostředí IDE sady Visual Studio nebo spusťte nástroj pro převod. V případě souboru .vcproj můžete místo toho sestavit soubor řešení obsahující projekt pomocí nástroje MSBuild.</target>
-        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
-      </trans-unit>
       <trans-unit id="NeedJustMyCode">
         <source>If MSBuild debugging does not work correctly, please verify that the "Just My Code" feature is enabled in Visual Studio, and that you have selected the managed debugger.</source>
         <target state="translated">Pokud ladění MSBuild nepracuje správně, ověřte, zda je v sadě Visual Studio povolena možnost Pouze můj kód a zda byl zvolen spravovaný ladicí nástroj.</target>
@@ -2382,6 +2188,29 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
         <target state="translated">MSBUILD: chyba MSB1054: Kvůli vygenerování výsledku profileru musí být zadaný název souboru.</target>
         <note />
       </trans-unit>
+      <trans-unit id="XMake.LoggerCreationError">
+        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
+        <target state="translated">MSBUILD : error MSB1021: Nelze vytvořit instanci protokolovacího nástroje. {0}</target>
+        <note>{StrBegin="MSBUILD : error MSB1021: "}
+      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
+      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
+      </trans-unit>
+      <trans-unit id="XMake.LoggerNotFoundError">
+        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
+        <target state="translated">MSBUILD : error MSB1020: Protokolovací nástroj se nenašel. Zkontrolujte následující body: 1.) Zadaný název protokolovacího nástroje je stejný jako název třídy protokolovacího nástroje. 2.) Třída protokolovacího nástroje je veřejná (public) a implementuje rozhraní Microsoft.Build.Framework.ILogger. 3.) Cesta k sestavení protokolovacího nástroje je správná, nebo se protokolovací nástroj dá načíst jenom pomocí zadaného názvu sestavení.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
+      logger class must exist in the given assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="XMake.ProjectUpgradeNeededToVcxProj">
+        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
+        <target state="translated">MSBUILD : error MSB4192: Soubor projektu {0} je ve formátu .vcproj nebo .dsp, který nástroj MSBuild nemůže přímo sestavit. Proveďte převod projektu – otevřete projekt v prostředí IDE sady Visual Studio nebo spusťte nástroj pro převod. V případě souboru .vcproj můžete místo toho sestavit soubor řešení obsahující projekt pomocí nástroje MSBuild.</target>
+        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 8cdef174367..03c2ca750fb 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -15,65 +15,6 @@
         <target state="translated">Fehler beim Buildvorgang. Eigenschaften, Elemente und Zielergebnisse können nicht abgerufen werden. Details finden Sie oben in stderr.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildFinished">
-        <source>Build {0} in {1}s</source>
-        <target state="translated">Erstellen von {0} in {1}s</target>
-        <note>
-      Overall build summary
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Failed">
-        <source>failed</source>
-        <target state="translated">Fehlgeschlagen</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrors">
-        <source>failed with {0} error(s)</source>
-        <target state="translated">fehlerhaft mit {0} Fehler(n)</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
-        <source>failed with {0} error(s) and {1} warning(s)</source>
-        <target state="translated">fehlerhaft mit {0} Fehler(n) und {1} Warnung(en)</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithWarnings">
-        <source>failed with {0} warning(s)</source>
-        <target state="translated">fehlerhaft mit {0} Warnung(en)</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Succeeded">
-        <source>succeeded</source>
-        <target state="translated">Erfolgreich</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_SucceededWithWarnings">
-        <source>succeeded with {0} warning(s)</source>
-        <target state="translated">erfolgreich mit {0} Warnung(en)</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildSummary">
-        <source>Build summary:</source>
-        <target state="translated">Build-Zusammenfassung:</target>
-        <note>
-      A header used by Terminal Logger to introduce the build summary.
-    </note>
-      </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
         <target state="translated">Befehlszeilenargumente = "{0}"</target>
@@ -92,14 +33,6 @@
         <target state="translated">MSBUILD : error MSB1027: Der Schalter "-noAutoResponse" kann weder in der automatischen Antwortdatei "MSBuild.rsp" noch in einer anderen Antwortdatei verwendet werden, auf die die automatische Antwortdatei verweist.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DurationDisplay">
-        <source>({0:F1}s)</source>
-        <target state="translated">({0:F1}s)</target>
-        <note>
-        {0}: duration in seconds with 1 decimal point
-        's' should reflect the localized abbreviation for seconds
-      </note>
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -1736,39 +1669,6 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <target state="translated">Prozess = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectFinished_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}s)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_OutputPath">
-        <source> → {0}</source>
-        <target state="translated"> → {0}</target>
-        <note>
-      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
-      {0}: VT100 coded hyperlink to project output directory
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Die Projektdatei ist nicht vorhanden.</target>
@@ -1814,24 +1714,6 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <target state="translated">„{0}“ stammt aus „{1}“</target>
         <note>
       These are response file switches with the location of the response file on disk.
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreComplete">
-        <source>Restore complete ({0}s)</source>
-        <target state="translated">Wiederherstellung abgeschlossen ({0}s)</target>
-        <note>
-      {0}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreCompleteWithMessage">
-        <source>Restore {0} in {1}s</source>
-        <target state="translated">Wiederherstellen von {0} in {1}s</target>
-        <note>
-      Restore summary when finished with warning or error
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
     </note>
       </trans-unit>
       <trans-unit id="SAC">
@@ -1918,59 +1800,6 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <target state="translated">Die Terminalprotokollierung wurde nicht verwendet, da die Ausgabe an eine Datei umgeleitet wird.</target>
         <note />
       </trans-unit>
-      <trans-unit id="TestProjectFinished_NoTF">
-        <source>{0}{1} test {2} ({3}s)</source>
-        <target state="translated">{0}{1} Test {2} ({3}s)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestProjectFinished_WithTF">
-        <source>{0}{1} test {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} Test {2} {3} ({4}s)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_BannerAndTotal">
-        <source>Test summary: total: {0}</source>
-        <target state="translated">Testzusammenfassung: insgesamt: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Duration">
-        <source>duration: {0}s</source>
-        <target state="translated">Dauer: {0} Sek.</target>
-        <note>
-      {0} whole number
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Failed">
-        <source>failed: {0}</source>
-        <target state="translated">fehlgeschlagen: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Skipped">
-        <source>skipped: {0}</source>
-        <target state="translated">übersprungen: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Succeeded">
-        <source>succeeded: {0}</source>
-        <target state="translated">erfolgreich: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Der Schalter erlaubt keine Parameter.</target>
@@ -2053,29 +1882,6 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <target state="translated">MSBUILD : error MSB1047: Die vorzuverarbeitende Datei ist ungültig. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1047: "}</note>
       </trans-unit>
-      <trans-unit id="LoggerCreationError">
-        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
-        <target state="translated">MSBUILD : error MSB1021: Eine Instanz der Protokollierung kann nicht erzeugt werden. {0}</target>
-        <note>{StrBegin="MSBUILD : error MSB1021: "}
-      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
-      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
-      </trans-unit>
-      <trans-unit id="LoggerNotFoundError">
-        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
-        <target state="translated">MSBUILD : error MSB1020: Die Protokollierung konnte nicht gefunden werden. Überprüfen Sie Folgendes: 1.) Der angegebene Protokollierungsname entspricht dem Namen der Protokollierungsklasse. 2.) Die Protokollierungsklasse ist "public" und implementiert die Microsoft.Build.Framework.ILogger-Schnittstelle. 3.) Der Pfad der Protokollierungsassembly ist richtig, oder die Protokollierung kann nur mit dem angegebenen Assemblynamen geladen werden.</target>
-        <note>
-      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
-      logger class must exist in the given assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectUpgradeNeededToVcxProj">
-        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
-        <target state="translated">MSBUILD : error MSB4192: Die Projektdatei "{0}" weist das Dateiformat ".vcproj" oder ".dsp" auf, das von MSBuild nicht direkt erstellt werden kann. Konvertieren Sie das Projekt, indem Sie es in der Visual Studio IDE öffnen oder das Konvertierungstool ausführen. Für ".vcproj" verwenden Sie zum Erstellen der Projektmappendatei, die stattdessen das Projekt enthält, MSBuild.</target>
-        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
-      </trans-unit>
       <trans-unit id="NeedJustMyCode">
         <source>If MSBuild debugging does not work correctly, please verify that the "Just My Code" feature is enabled in Visual Studio, and that you have selected the managed debugger.</source>
         <target state="translated">Wenn das MSBuild-Debugging nicht ordnungsgemäß funktioniert, überprüfen Sie, ob die Funktion "Nur mein Code" in Visual Studio aktiviert ist und ob Sie den verwalteten Debugger ausgewählt haben.</target>
@@ -2370,6 +2176,29 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <target state="translated">MSBUILD : error MSB1054: Ein Dateiname muss angegeben werden, um das Profilerergebnis zu generieren.</target>
         <note />
       </trans-unit>
+      <trans-unit id="XMake.LoggerCreationError">
+        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
+        <target state="translated">MSBUILD : error MSB1021: Eine Instanz der Protokollierung kann nicht erzeugt werden. {0}</target>
+        <note>{StrBegin="MSBUILD : error MSB1021: "}
+      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
+      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
+      </trans-unit>
+      <trans-unit id="XMake.LoggerNotFoundError">
+        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
+        <target state="translated">MSBUILD : error MSB1020: Die Protokollierung konnte nicht gefunden werden. Überprüfen Sie Folgendes: 1.) Der angegebene Protokollierungsname entspricht dem Namen der Protokollierungsklasse. 2.) Die Protokollierungsklasse ist "public" und implementiert die Microsoft.Build.Framework.ILogger-Schnittstelle. 3.) Der Pfad der Protokollierungsassembly ist richtig, oder die Protokollierung kann nur mit dem angegebenen Assemblynamen geladen werden.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
+      logger class must exist in the given assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="XMake.ProjectUpgradeNeededToVcxProj">
+        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
+        <target state="translated">MSBUILD : error MSB4192: Die Projektdatei "{0}" weist das Dateiformat ".vcproj" oder ".dsp" auf, das von MSBuild nicht direkt erstellt werden kann. Konvertieren Sie das Projekt, indem Sie es in der Visual Studio IDE öffnen oder das Konvertierungstool ausführen. Für ".vcproj" verwenden Sie zum Erstellen der Projektmappendatei, die stattdessen das Projekt enthält, MSBuild.</target>
+        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index ed508d49fd7..d8d6d837bb7 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -15,65 +15,6 @@
         <target state="translated">Error de compilación. No se pueden obtener los resultados de propiedades, elementos y destinos. Vea los detalles en stderr anterior.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildFinished">
-        <source>Build {0} in {1}s</source>
-        <target state="translated">Compilación {0} en {1}s</target>
-        <note>
-      Overall build summary
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Failed">
-        <source>failed</source>
-        <target state="translated">erróneo</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrors">
-        <source>failed with {0} error(s)</source>
-        <target state="translated">error con {0} errores</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
-        <source>failed with {0} error(s) and {1} warning(s)</source>
-        <target state="translated">error con {0} errores y {1} advertencias</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithWarnings">
-        <source>failed with {0} warning(s)</source>
-        <target state="translated">error con {0} advertencias</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Succeeded">
-        <source>succeeded</source>
-        <target state="translated">realizado correctamente</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_SucceededWithWarnings">
-        <source>succeeded with {0} warning(s)</source>
-        <target state="translated">correcto con {0} advertencias</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildSummary">
-        <source>Build summary:</source>
-        <target state="translated">Resumen de la compilación:</target>
-        <note>
-      A header used by Terminal Logger to introduce the build summary.
-    </note>
-      </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
         <target state="translated">Argumentos de la línea de comandos: "{0}"</target>
@@ -92,14 +33,6 @@
         <target state="translated">MSBUILD : error MSB1027: El modificador -noAutoResponse no puede especificarse en el archivo de respuesta automática MSBuild.rsp ni en ningún archivo de respuesta al que el archivo de respuesta automática haga referencia.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DurationDisplay">
-        <source>({0:F1}s)</source>
-        <target state="translated">({0:F1}s)</target>
-        <note>
-        {0}: duration in seconds with 1 decimal point
-        's' should reflect the localized abbreviation for seconds
-      </note>
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -1742,39 +1675,6 @@ Esta marca es experimental y puede que no funcione según lo previsto.
         <target state="translated">Proceso: "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectFinished_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}s)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_OutputPath">
-        <source> → {0}</source>
-        <target state="translated"> → {0}</target>
-        <note>
-      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
-      {0}: VT100 coded hyperlink to project output directory
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: El archivo de proyecto no existe.</target>
@@ -1820,24 +1720,6 @@ Esta marca es experimental y puede que no funcione según lo previsto.
         <target state="translated">'{0}' procedía de '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreComplete">
-        <source>Restore complete ({0}s)</source>
-        <target state="translated">Restauración completada ({0}s)</target>
-        <note>
-      {0}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreCompleteWithMessage">
-        <source>Restore {0} in {1}s</source>
-        <target state="translated">Restaurar {0} en {1}s</target>
-        <note>
-      Restore summary when finished with warning or error
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
     </note>
       </trans-unit>
       <trans-unit id="SAC">
@@ -1924,59 +1806,6 @@ Esta marca es experimental y puede que no funcione según lo previsto.
         <target state="translated">No se usó el terminal de Logger porque la salida se está redirigiendo a un archivo.</target>
         <note />
       </trans-unit>
-      <trans-unit id="TestProjectFinished_NoTF">
-        <source>{0}{1} test {2} ({3}s)</source>
-        <target state="translated">{0}{1} prueba{2} ({3}s)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestProjectFinished_WithTF">
-        <source>{0}{1} test {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} prueba ({4}s)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_BannerAndTotal">
-        <source>Test summary: total: {0}</source>
-        <target state="translated">Resumen de pruebas: total: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Duration">
-        <source>duration: {0}s</source>
-        <target state="translated">duración: {0} s</target>
-        <note>
-      {0} whole number
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Failed">
-        <source>failed: {0}</source>
-        <target state="translated">con errores: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Skipped">
-        <source>skipped: {0}</source>
-        <target state="translated">omitido: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Succeeded">
-        <source>succeeded: {0}</source>
-        <target state="translated">correcto: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Este modificador no tiene ningún parámetro.</target>
@@ -2059,29 +1888,6 @@ Esta marca es experimental y puede que no funcione según lo previsto.
         <target state="translated">MSBUILD : error MSB1047: El archivo en el que se preprocesará no es válido. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1047: "}</note>
       </trans-unit>
-      <trans-unit id="LoggerCreationError">
-        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
-        <target state="translated">MSBUILD : error MSB1021: No se puede crear una instancia del registrador. {0}</target>
-        <note>{StrBegin="MSBUILD : error MSB1021: "}
-      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
-      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
-      </trans-unit>
-      <trans-unit id="LoggerNotFoundError">
-        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
-        <target state="translated">MSBUILD : error MSB1020: No se encontró el registrador. Compruebe lo siguiente: 1.) El nombre del registrador especificado es el mismo que el nombre de la clase de registrador. 2.) La clase de registrador es "public" e implementa la interfaz Microsoft.Build.Framework.ILogger. 3.) La ruta de acceso del ensamblado del registrador es correcta o el registrador puede cargarse usando solo el nombre del ensamblado especificado.</target>
-        <note>
-      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
-      logger class must exist in the given assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectUpgradeNeededToVcxProj">
-        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
-        <target state="translated">MSBUILD : error MSB4192: El formato de archivo del proyecto "{0}" es ".vcproj" o ".dsp", que MSBuild no puede compilar directamente. Convierta el proyecto abriéndolo en el IDE de Visual Studio o ejecutando la herramienta de conversión; o bien, para ".vcproj", use MSBuild para compilar el archivo de solución que contiene el proyecto.</target>
-        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
-      </trans-unit>
       <trans-unit id="NeedJustMyCode">
         <source>If MSBuild debugging does not work correctly, please verify that the "Just My Code" feature is enabled in Visual Studio, and that you have selected the managed debugger.</source>
         <target state="translated">Si la depuración de MSBuild no funciona correctamente, compruebe que la funcionalidad "Solo mi código" está habilitada en Visual Studio y que ha seleccionado el depurador administrado.</target>
@@ -2374,6 +2180,29 @@ Esta marca es experimental y puede que no funcione según lo previsto.
         <target state="translated">MSBUILD :error MSB1054: Es necesario especificar un nombre de archivo para generar el resultado del generador de perfiles.</target>
         <note />
       </trans-unit>
+      <trans-unit id="XMake.LoggerCreationError">
+        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
+        <target state="translated">MSBUILD : error MSB1021: No se puede crear una instancia del registrador. {0}</target>
+        <note>{StrBegin="MSBUILD : error MSB1021: "}
+      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
+      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
+      </trans-unit>
+      <trans-unit id="XMake.LoggerNotFoundError">
+        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
+        <target state="translated">MSBUILD : error MSB1020: No se encontró el registrador. Compruebe lo siguiente: 1.) El nombre del registrador especificado es el mismo que el nombre de la clase de registrador. 2.) La clase de registrador es "public" e implementa la interfaz Microsoft.Build.Framework.ILogger. 3.) La ruta de acceso del ensamblado del registrador es correcta o el registrador puede cargarse usando solo el nombre del ensamblado especificado.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
+      logger class must exist in the given assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="XMake.ProjectUpgradeNeededToVcxProj">
+        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
+        <target state="translated">MSBUILD : error MSB4192: El formato de archivo del proyecto "{0}" es ".vcproj" o ".dsp", que MSBuild no puede compilar directamente. Convierta el proyecto abriéndolo en el IDE de Visual Studio o ejecutando la herramienta de conversión; o bien, para ".vcproj", use MSBuild para compilar el archivo de solución que contiene el proyecto.</target>
+        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index eec15d4d2ff..ac46ff96a7d 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -15,65 +15,6 @@
         <target state="translated">Échec de la génération. Impossible d’obtenir les propriétés, les éléments et les résultats cibles. Consultez les détails dans stderr ci-dessus.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildFinished">
-        <source>Build {0} in {1}s</source>
-        <target state="translated">Générer {0} dans {1}s</target>
-        <note>
-      Overall build summary
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Failed">
-        <source>failed</source>
-        <target state="translated">échec</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrors">
-        <source>failed with {0} error(s)</source>
-        <target state="translated">a échoué avec {0} erreur(s)</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
-        <source>failed with {0} error(s) and {1} warning(s)</source>
-        <target state="translated">a échoué avec {0} erreur(s) et {1} avertissement(s)</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithWarnings">
-        <source>failed with {0} warning(s)</source>
-        <target state="translated">a échoué avec {0} avertissement(s)</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Succeeded">
-        <source>succeeded</source>
-        <target state="translated">a réussi</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_SucceededWithWarnings">
-        <source>succeeded with {0} warning(s)</source>
-        <target state="translated">a réussi avec {0} avertissement(s)</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildSummary">
-        <source>Build summary:</source>
-        <target state="translated">Résumé de la build :</target>
-        <note>
-      A header used by Terminal Logger to introduce the build summary.
-    </note>
-      </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
         <target state="translated">Arguments de ligne de commande = "{0}"</target>
@@ -92,14 +33,6 @@
         <target state="translated">MSBUILD : error MSB1027: Impossible de spécifier le commutateur -noAutoResponse dans le fichier réponse automatique MSBuild.rsp, ni dans aucun autre fichier réponse référencé par le fichier réponse automatique.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DurationDisplay">
-        <source>({0:F1}s)</source>
-        <target state="translated">({0:F1}s)</target>
-        <note>
-        {0}: duration in seconds with 1 decimal point
-        's' should reflect the localized abbreviation for seconds
-      </note>
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -1736,39 +1669,6 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
         <target state="translated">Processus = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectFinished_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}s)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_OutputPath">
-        <source> → {0}</source>
-        <target state="translated"> → {0}</target>
-        <note>
-      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
-      {0}: VT100 coded hyperlink to project output directory
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Le fichier projet n'existe pas.</target>
@@ -1814,24 +1714,6 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
         <target state="translated">'{0}' provient de '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreComplete">
-        <source>Restore complete ({0}s)</source>
-        <target state="translated">Restauration terminée ({0}s)</target>
-        <note>
-      {0}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreCompleteWithMessage">
-        <source>Restore {0} in {1}s</source>
-        <target state="translated">Restaurer {0} en {1}s</target>
-        <note>
-      Restore summary when finished with warning or error
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
     </note>
       </trans-unit>
       <trans-unit id="SAC">
@@ -1918,59 +1800,6 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
         <target state="translated">L’enregistreur d’événements du terminal n’a pas été utilisé car la sortie est redirigée vers un fichier.</target>
         <note />
       </trans-unit>
-      <trans-unit id="TestProjectFinished_NoTF">
-        <source>{0}{1} test {2} ({3}s)</source>
-        <target state="translated">{0}Test de {1} : {2} ({3} s)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestProjectFinished_WithTF">
-        <source>{0}{1} test {2} {3} ({4}s)</source>
-        <target state="translated">{0}Test de {1} {2} : {3} ({4} s)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_BannerAndTotal">
-        <source>Test summary: total: {0}</source>
-        <target state="translated">Récapitulatif du test : total : {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Duration">
-        <source>duration: {0}s</source>
-        <target state="translated">durée : {0}s</target>
-        <note>
-      {0} whole number
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Failed">
-        <source>failed: {0}</source>
-        <target state="translated">échec : {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Skipped">
-        <source>skipped: {0}</source>
-        <target state="translated">ignoré : {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Succeeded">
-        <source>succeeded: {0}</source>
-        <target state="translated">réussi : {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Ce commutateur n'accepte aucun paramètre.</target>
@@ -2053,29 +1882,6 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
         <target state="translated">MSBUILD : error MSB1047: Le fichier à prétraiter n'est pas valide. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1047: "}</note>
       </trans-unit>
-      <trans-unit id="LoggerCreationError">
-        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
-        <target state="translated">MSBUILD : error MSB1021: Impossible de créer une instance du journal. {0}</target>
-        <note>{StrBegin="MSBUILD : error MSB1021: "}
-      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
-      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
-      </trans-unit>
-      <trans-unit id="LoggerNotFoundError">
-        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
-        <target state="translated">MSBUILD : error MSB1020: Le journal est introuvable. Vérifiez les points suivants : 1.) Le nom du journal est le même que celui de la classe de journalisation. 2.) La classe de journalisation est "public" et implémente l'interface Microsoft.Build.Framework.ILogger. 3.) Le chemin de l'assembly de journalisation est correct ou le journal peut uniquement être chargé à l'aide du nom d'assembly fourni.</target>
-        <note>
-      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
-      logger class must exist in the given assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectUpgradeNeededToVcxProj">
-        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
-        <target state="translated">MSBUILD : error MSB4192: Le fichier projet "{0}" utilise le format de fichier ".vcproj" ou ".dsp", que MSBuild ne peut pas générer directement. Convertissez le projet en l'ouvrant dans l'IDE de Visual Studio ou en exécutant l'outil de conversion. Pour ".vcproj", utilisez à la place MSBuild pour générer le fichier solution contenant le projet.</target>
-        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
-      </trans-unit>
       <trans-unit id="NeedJustMyCode">
         <source>If MSBuild debugging does not work correctly, please verify that the "Just My Code" feature is enabled in Visual Studio, and that you have selected the managed debugger.</source>
         <target state="translated">Si le débogage MSBuild ne fonctionne pas correctement, vérifiez que la fonctionnalité "Uniquement mon code" est activée dans Visual Studio, et que vous avez sélectionné le débogueur managé.</target>
@@ -2388,6 +2194,29 @@ fois plus petit que le journal
         <target state="translated">MSBUILD : erreur MSB1054 : Un nom de fichier doit être spécifié pour générer le résultat du profileur.</target>
         <note />
       </trans-unit>
+      <trans-unit id="XMake.LoggerCreationError">
+        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
+        <target state="translated">MSBUILD : error MSB1021: Impossible de créer une instance du journal. {0}</target>
+        <note>{StrBegin="MSBUILD : error MSB1021: "}
+      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
+      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
+      </trans-unit>
+      <trans-unit id="XMake.LoggerNotFoundError">
+        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
+        <target state="translated">MSBUILD : error MSB1020: Le journal est introuvable. Vérifiez les points suivants : 1.) Le nom du journal est le même que celui de la classe de journalisation. 2.) La classe de journalisation est "public" et implémente l'interface Microsoft.Build.Framework.ILogger. 3.) Le chemin de l'assembly de journalisation est correct ou le journal peut uniquement être chargé à l'aide du nom d'assembly fourni.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
+      logger class must exist in the given assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="XMake.ProjectUpgradeNeededToVcxProj">
+        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
+        <target state="translated">MSBUILD : error MSB4192: Le fichier projet "{0}" utilise le format de fichier ".vcproj" ou ".dsp", que MSBuild ne peut pas générer directement. Convertissez le projet en l'ouvrant dans l'IDE de Visual Studio ou en exécutant l'outil de conversion. Pour ".vcproj", utilisez à la place MSBuild pour générer le fichier solution contenant le projet.</target>
+        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 1700cf2e875..842cdf22a24 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -15,65 +15,6 @@
         <target state="translated">Compilazione non riuscita. Non è possibile ottenere proprietà, elementi e risultati di destinazione. Vedere i dettagli in stderr sopra.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildFinished">
-        <source>Build {0} in {1}s</source>
-        <target state="translated">Compilazione {0} in {1}s</target>
-        <note>
-      Overall build summary
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Failed">
-        <source>failed</source>
-        <target state="translated">non riuscito</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrors">
-        <source>failed with {0} error(s)</source>
-        <target state="translated">non riuscito con {0} errori</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
-        <source>failed with {0} error(s) and {1} warning(s)</source>
-        <target state="translated">non riuscito con {0} errori e {1} avvisi</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithWarnings">
-        <source>failed with {0} warning(s)</source>
-        <target state="translated">non riuscito con {0} avvisi</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Succeeded">
-        <source>succeeded</source>
-        <target state="translated">operazione riuscita</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_SucceededWithWarnings">
-        <source>succeeded with {0} warning(s)</source>
-        <target state="translated">completato con {0} avvisi</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildSummary">
-        <source>Build summary:</source>
-        <target state="translated">Riepilogo build:</target>
-        <note>
-      A header used by Terminal Logger to introduce the build summary.
-    </note>
-      </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
         <target state="translated">Argomenti della riga di comando = "{0}"</target>
@@ -92,14 +33,6 @@
         <target state="translated">MSBUILD : error MSB1027: non è possibile specificare l'opzione -noAutoResponse nel file di risposta automatica MSBuild.rsp o in file di risposta a cui il file di risposta automatica fa riferimento.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DurationDisplay">
-        <source>({0:F1}s)</source>
-        <target state="translated">({0:F1}s)</target>
-        <note>
-        {0}: duration in seconds with 1 decimal point
-        's' should reflect the localized abbreviation for seconds
-      </note>
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -1747,39 +1680,6 @@ Nota: livello di dettaglio dei logger di file
         <target state="translated">Processo = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectFinished_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}s)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_OutputPath">
-        <source> → {0}</source>
-        <target state="translated"> → {0}</target>
-        <note>
-      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
-      {0}: VT100 coded hyperlink to project output directory
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: il file di progetto non esiste.</target>
@@ -1825,24 +1725,6 @@ Nota: livello di dettaglio dei logger di file
         <target state="translated">'{0}' proviene da '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreComplete">
-        <source>Restore complete ({0}s)</source>
-        <target state="translated">Ripristino completato ({0})</target>
-        <note>
-      {0}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreCompleteWithMessage">
-        <source>Restore {0} in {1}s</source>
-        <target state="translated">Ripristinare {0} in {1}s</target>
-        <note>
-      Restore summary when finished with warning or error
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
     </note>
       </trans-unit>
       <trans-unit id="SAC">
@@ -1929,59 +1811,6 @@ Nota: livello di dettaglio dei logger di file
         <target state="translated">Il logger del terminale non è stato usato perché l'output viene reindirizzato a un file.</target>
         <note />
       </trans-unit>
-      <trans-unit id="TestProjectFinished_NoTF">
-        <source>{0}{1} test {2} ({3}s)</source>
-        <target state="translated">{0}{1} test {2} {3}</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestProjectFinished_WithTF">
-        <source>{0}{1} test {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} test {2} {3} {4}</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_BannerAndTotal">
-        <source>Test summary: total: {0}</source>
-        <target state="translated">Riepilogo test: totale: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Duration">
-        <source>duration: {0}s</source>
-        <target state="translated">durata: {0}s</target>
-        <note>
-      {0} whole number
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Failed">
-        <source>failed: {0}</source>
-        <target state="translated">non riuscito: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Skipped">
-        <source>skipped: {0}</source>
-        <target state="translated">ignorato: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Succeeded">
-        <source>succeeded: {0}</source>
-        <target state="translated">riuscito: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: questa opzione non accetta parametri.</target>
@@ -2064,29 +1893,6 @@ Nota: livello di dettaglio dei logger di file
         <target state="translated">MSBUILD : error MSB1047: file da pre-elaborare non valido. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1047: "}</note>
       </trans-unit>
-      <trans-unit id="LoggerCreationError">
-        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
-        <target state="translated">MSBUILD : error MSB1021: non è possibile creare un'istanza del logger. {0}</target>
-        <note>{StrBegin="MSBUILD : error MSB1021: "}
-      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
-      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
-      </trans-unit>
-      <trans-unit id="LoggerNotFoundError">
-        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
-        <target state="translated">MSBUILD : error MSB1020: il logger non è stato trovato. Verificare quanto segue: 1.) Il nome del logger specificato è uguale al nome della classe logger. 2.) La classe logger è "public" e implementa l'interfaccia Microsoft.Build.Framework.ILogger. 3.) Il percorso dell'assembly logger è corretto o è possibile caricare il logger usando esclusivamente il nome di assembly fornito.</target>
-        <note>
-      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
-      logger class must exist in the given assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectUpgradeNeededToVcxProj">
-        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
-        <target state="translated">MSBUILD : error MSB4192: il file di progetto "{0}" è in formato ".vcproj" o ".dsp", che non è possibile compilare direttamente con MSBuild. Per convertire il progetto, aprirlo in Visual Studio IDE o eseguire lo strumento di conversione oppure, per ".vcproj", usare MSBuild per compilare il file della soluzione contenente il progetto.</target>
-        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
-      </trans-unit>
       <trans-unit id="NeedJustMyCode">
         <source>If MSBuild debugging does not work correctly, please verify that the "Just My Code" feature is enabled in Visual Studio, and that you have selected the managed debugger.</source>
         <target state="translated">Se il debug di MSBuild non funziona correttamente, verificare che la funzionalità "Just My Code" sia abilitata in Visual Studio e che sia stato selezionato il debugger gestito.</target>
@@ -2386,6 +2192,29 @@ Esegue la profilatura della valutazione di MSBuild e scrive
         <target state="translated">MSBUILD :error MSB1054: per generare il risultato del profiler, è necessario specificare un nome file.</target>
         <note />
       </trans-unit>
+      <trans-unit id="XMake.LoggerCreationError">
+        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
+        <target state="translated">MSBUILD : error MSB1021: non è possibile creare un'istanza del logger. {0}</target>
+        <note>{StrBegin="MSBUILD : error MSB1021: "}
+      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
+      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
+      </trans-unit>
+      <trans-unit id="XMake.LoggerNotFoundError">
+        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
+        <target state="translated">MSBUILD : error MSB1020: il logger non è stato trovato. Verificare quanto segue: 1.) Il nome del logger specificato è uguale al nome della classe logger. 2.) La classe logger è "public" e implementa l'interfaccia Microsoft.Build.Framework.ILogger. 3.) Il percorso dell'assembly logger è corretto o è possibile caricare il logger usando esclusivamente il nome di assembly fornito.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
+      logger class must exist in the given assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="XMake.ProjectUpgradeNeededToVcxProj">
+        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
+        <target state="translated">MSBUILD : error MSB4192: il file di progetto "{0}" è in formato ".vcproj" o ".dsp", che non è possibile compilare direttamente con MSBuild. Per convertire il progetto, aprirlo in Visual Studio IDE o eseguire lo strumento di conversione oppure, per ".vcproj", usare MSBuild per compilare il file della soluzione contenente il progetto.</target>
+        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 0681526a4e5..4dad67e4fa9 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -15,65 +15,6 @@
         <target state="translated">ビルドに失敗しました。プロパティ、項目、ターゲットの結果を取得できません。上の stderr で詳細を参照してください。</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildFinished">
-        <source>Build {0} in {1}s</source>
-        <target state="translated">{1} 秒後に {0} をビルド</target>
-        <note>
-      Overall build summary
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Failed">
-        <source>failed</source>
-        <target state="translated">失敗しました</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrors">
-        <source>failed with {0} error(s)</source>
-        <target state="translated">{0} 件のエラーで失敗しました</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
-        <source>failed with {0} error(s) and {1} warning(s)</source>
-        <target state="translated">{0} 件のエラーと {1} 件の警告で失敗しました</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithWarnings">
-        <source>failed with {0} warning(s)</source>
-        <target state="translated">{0} 件の警告付きで失敗しました</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Succeeded">
-        <source>succeeded</source>
-        <target state="translated">成功しました</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_SucceededWithWarnings">
-        <source>succeeded with {0} warning(s)</source>
-        <target state="translated">{0} 件の警告付きで成功しました</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildSummary">
-        <source>Build summary:</source>
-        <target state="translated">ビルドの概要:</target>
-        <note>
-      A header used by Terminal Logger to introduce the build summary.
-    </note>
-      </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
         <target state="translated">コマンド ライン引数 = "{0}"</target>
@@ -92,14 +33,6 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp 自動応答ファイルや、自動応答ファイルによって参照される応答ファイルに -noAutoResponse スイッチを指定することはできません。</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DurationDisplay">
-        <source>({0:F1}s)</source>
-        <target state="translated">({0:F1}s)</target>
-        <note>
-        {0}: duration in seconds with 1 decimal point
-        's' should reflect the localized abbreviation for seconds
-      </note>
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -1736,39 +1669,6 @@
         <target state="translated">プロセス = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectFinished_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3} 秒)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_OutputPath">
-        <source> → {0}</source>
-        <target state="translated"> → {0}</target>
-        <note>
-      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
-      {0}: VT100 coded hyperlink to project output directory
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4} 秒)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: プロジェクト ファイルが存在しません。</target>
@@ -1814,24 +1714,6 @@
         <target state="translated">`{0}`からの `{1}`</target>
         <note>
       These are response file switches with the location of the response file on disk.
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreComplete">
-        <source>Restore complete ({0}s)</source>
-        <target state="translated">復元が完了しました ({0} 秒)</target>
-        <note>
-      {0}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreCompleteWithMessage">
-        <source>Restore {0} in {1}s</source>
-        <target state="translated">{1} 秒後に {0} を復元する</target>
-        <note>
-      Restore summary when finished with warning or error
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
     </note>
       </trans-unit>
       <trans-unit id="SAC">
@@ -1918,59 +1800,6 @@
         <target state="translated">出力がファイルにリダイレクトされているため、ターミナル ロガーは使用されませんでした。</target>
         <note />
       </trans-unit>
-      <trans-unit id="TestProjectFinished_NoTF">
-        <source>{0}{1} test {2} ({3}s)</source>
-        <target state="translated">{0}{1} テスト {2} ({3} 秒)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestProjectFinished_WithTF">
-        <source>{0}{1} test {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} テスト {2} {3} ({4} 秒)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_BannerAndTotal">
-        <source>Test summary: total: {0}</source>
-        <target state="translated">テスト概要: 合計: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Duration">
-        <source>duration: {0}s</source>
-        <target state="translated">期間: {0} 秒</target>
-        <note>
-      {0} whole number
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Failed">
-        <source>failed: {0}</source>
-        <target state="translated">失敗数: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Skipped">
-        <source>skipped: {0}</source>
-        <target state="translated">スキップ済み数: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Succeeded">
-        <source>succeeded: {0}</source>
-        <target state="translated">成功数: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: このスイッチにはパラメーターを指定できません。</target>
@@ -2053,29 +1882,6 @@
         <target state="translated">MSBUILD : error MSB1047: 前処理するファイルが無効です。{0}</target>
         <note>{StrBegin="MSBUILD : error MSB1047: "}</note>
       </trans-unit>
-      <trans-unit id="LoggerCreationError">
-        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
-        <target state="translated">MSBUILD : error MSB1021: Logger のインスタンスを作成できません。{0}</target>
-        <note>{StrBegin="MSBUILD : error MSB1021: "}
-      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
-      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
-      </trans-unit>
-      <trans-unit id="LoggerNotFoundError">
-        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
-        <target state="translated">MSBUILD : error MSB1020: Logger が見つかりませんでした。次のことを確認してください。1.)指定した logger 名が logger クラス名と同一であること。2.)logger クラスが public であり Microsoft.Build.Framework.ILogger インターフェイスを実装すること。3.)logger アセンブリへのパスが正しいこと、または指定されたアセンブリ名のみを使って logger が読み込まれること。</target>
-        <note>
-      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
-      logger class must exist in the given assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectUpgradeNeededToVcxProj">
-        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
-        <target state="translated">MSBUILD : error MSB4192: プロジェクト ファイル "{0}" は ".vcproj" または ".dsp" ファイル形式であり、MSBuild では直接ビルドできません。Visual Studio IDE でファイルを開くか、変換ツールを実行して、プロジェクトを変換してください。または、".vcproj" の場合は、MSBuild を使用して、このプロジェクトを含むソリューション ファイルを代わりにビルドできます。</target>
-        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
-      </trans-unit>
       <trans-unit id="NeedJustMyCode">
         <source>If MSBuild debugging does not work correctly, please verify that the "Just My Code" feature is enabled in Visual Studio, and that you have selected the managed debugger.</source>
         <target state="translated">MSBuild デバッグが正常に機能しない場合は、Visual Studio で [マイ コードのみ] 機能が有効になっていること、およびマネージ デバッガーが選択されていることを確認してください。</target>
@@ -2370,6 +2176,29 @@
         <target state="translated">MSBUILD : エラー MSB1054: プロファイラーの結果を生成するには、ファイル名を指定する必要があります。</target>
         <note />
       </trans-unit>
+      <trans-unit id="XMake.LoggerCreationError">
+        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
+        <target state="translated">MSBUILD : error MSB1021: Logger のインスタンスを作成できません。{0}</target>
+        <note>{StrBegin="MSBUILD : error MSB1021: "}
+      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
+      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
+      </trans-unit>
+      <trans-unit id="XMake.LoggerNotFoundError">
+        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
+        <target state="translated">MSBUILD : error MSB1020: Logger が見つかりませんでした。次のことを確認してください。1.)指定した logger 名が logger クラス名と同一であること。2.)logger クラスが public であり Microsoft.Build.Framework.ILogger インターフェイスを実装すること。3.)logger アセンブリへのパスが正しいこと、または指定されたアセンブリ名のみを使って logger が読み込まれること。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
+      logger class must exist in the given assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="XMake.ProjectUpgradeNeededToVcxProj">
+        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
+        <target state="translated">MSBUILD : error MSB4192: プロジェクト ファイル "{0}" は ".vcproj" または ".dsp" ファイル形式であり、MSBuild では直接ビルドできません。Visual Studio IDE でファイルを開くか、変換ツールを実行して、プロジェクトを変換してください。または、".vcproj" の場合は、MSBuild を使用して、このプロジェクトを含むソリューション ファイルを代わりにビルドできます。</target>
+        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 276327b19c2..b4c9c4b26fe 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -15,65 +15,6 @@
         <target state="translated">빌드하지 못했습니다. 속성, 항목 및 대상 결과를 가져올 수 없습니다. 위의 stderr에서 세부 정보를 참조하세요.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildFinished">
-        <source>Build {0} in {1}s</source>
-        <target state="translated">{0} 빌드({1}초)</target>
-        <note>
-      Overall build summary
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Failed">
-        <source>failed</source>
-        <target state="translated">실패</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrors">
-        <source>failed with {0} error(s)</source>
-        <target state="translated">{0} 오류와 함께 실패</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
-        <source>failed with {0} error(s) and {1} warning(s)</source>
-        <target state="translated">{0} 오류와 {1} 경고와 함께 실패</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithWarnings">
-        <source>failed with {0} warning(s)</source>
-        <target state="translated">{0} 경고와 함께 실패</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Succeeded">
-        <source>succeeded</source>
-        <target state="translated">성공</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_SucceededWithWarnings">
-        <source>succeeded with {0} warning(s)</source>
-        <target state="translated">{0} 경고와 함께 성공</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildSummary">
-        <source>Build summary:</source>
-        <target state="translated">빌드 요약:</target>
-        <note>
-      A header used by Terminal Logger to introduce the build summary.
-    </note>
-      </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
         <target state="translated">명령줄 인수 = "{0}"</target>
@@ -92,14 +33,6 @@
         <target state="translated">MSBUILD : error MSB1027: MSBuild.rsp 자동 지시 파일과 자동 지시 파일에서 참조하는 모든 지시 파일에는 -noAutoResponse 스위치를 지정할 수 없습니다.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DurationDisplay">
-        <source>({0:F1}s)</source>
-        <target state="translated">({0:F1}s)</target>
-        <note>
-        {0}: duration in seconds with 1 decimal point
-        's' should reflect the localized abbreviation for seconds
-      </note>
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -1736,39 +1669,6 @@
         <target state="translated">프로세스 = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectFinished_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}초)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_OutputPath">
-        <source> → {0}</source>
-        <target state="translated"> → {0}</target>
-        <note>
-      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
-      {0}: VT100 coded hyperlink to project output directory
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}초)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: 프로젝트 파일이 없습니다.</target>
@@ -1814,24 +1714,6 @@
         <target state="translated">'{0}'은(는) '{1}'에서 제공되었습니다.</target>
         <note>
       These are response file switches with the location of the response file on disk.
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreComplete">
-        <source>Restore complete ({0}s)</source>
-        <target state="translated">복원 완료({0}초)</target>
-        <note>
-      {0}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreCompleteWithMessage">
-        <source>Restore {0} in {1}s</source>
-        <target state="translated">{0} 복원({1}초)</target>
-        <note>
-      Restore summary when finished with warning or error
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
     </note>
       </trans-unit>
       <trans-unit id="SAC">
@@ -1918,59 +1800,6 @@
         <target state="translated">출력이 파일로 리디렉션되기 때문에 터미널 로거가 사용되지 않았습니다.</target>
         <note />
       </trans-unit>
-      <trans-unit id="TestProjectFinished_NoTF">
-        <source>{0}{1} test {2} ({3}s)</source>
-        <target state="translated">{0}{1} 테스트 {2}({3}초)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestProjectFinished_WithTF">
-        <source>{0}{1} test {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} 테스트 {2} {3}({4}초)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_BannerAndTotal">
-        <source>Test summary: total: {0}</source>
-        <target state="translated">테스트 요약: 합계: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Duration">
-        <source>duration: {0}s</source>
-        <target state="translated">기간: {0}초</target>
-        <note>
-      {0} whole number
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Failed">
-        <source>failed: {0}</source>
-        <target state="translated">실패: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Skipped">
-        <source>skipped: {0}</source>
-        <target state="translated">건너뜀: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Succeeded">
-        <source>succeeded: {0}</source>
-        <target state="translated">성공: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: 이 스위치에는 매개 변수를 지정할 수 없습니다.</target>
@@ -2053,29 +1882,6 @@
         <target state="translated">MSBUILD : error MSB1047: 전처리할 파일이 잘못되었습니다. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1047: "}</note>
       </trans-unit>
-      <trans-unit id="LoggerCreationError">
-        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
-        <target state="translated">MSBUILD : error MSB1021: 로거의 인스턴스를 만들 수 없습니다. {0}</target>
-        <note>{StrBegin="MSBUILD : error MSB1021: "}
-      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
-      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
-      </trans-unit>
-      <trans-unit id="LoggerNotFoundError">
-        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
-        <target state="translated">MSBUILD : error MSB1020: 로거를 찾을 수 없습니다. 다음을 확인하세요. 1) 지정한 로거 이름이 로거 클래스 이름과 같은지 확인합니다. 2.) 로거 클래스가 "public"이고 Microsoft.Build.Framework.ILogger 인터페이스를 구현하는지 확인합니다. 3.) 로거 어셈블리의 경로가 올바른지 또는 지정한 어셈블리 이름만 사용하여 로거를 로드할 수 있는지 확인합니다.</target>
-        <note>
-      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
-      logger class must exist in the given assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectUpgradeNeededToVcxProj">
-        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
-        <target state="translated">MSBUILD : error MSB4192: 프로젝트 파일 "{0}"이(가) MSBuild에서 직접 빌드할 수 없는 ".vcproj" 또는 ".dsp" 파일 형식입니다. 프로젝트를 Visual Studio IDE에서 열거나 변환 도구를 실행하여 프로젝트를 변환하거나, ".vcproj"의 경우 MSBuild를 사용하여 해당 프로젝트가 포함된 솔루션 파일을 대신 빌드하세요.</target>
-        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
-      </trans-unit>
       <trans-unit id="NeedJustMyCode">
         <source>If MSBuild debugging does not work correctly, please verify that the "Just My Code" feature is enabled in Visual Studio, and that you have selected the managed debugger.</source>
         <target state="translated">MSBuild 디버깅이 제대로 작동하지 않을 경우, Visual Studio에서 "내 코드만" 기능이 설정되어 있는지와 관리되는 디버거를 선택했는지를 확인하십시오.</target>
@@ -2370,6 +2176,29 @@
         <target state="translated">MSBUILD :오류 MSB1054: 프로파일러 결과를 생성하려면 파일 이름을 지정해야 합니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="XMake.LoggerCreationError">
+        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
+        <target state="translated">MSBUILD : error MSB1021: 로거의 인스턴스를 만들 수 없습니다. {0}</target>
+        <note>{StrBegin="MSBUILD : error MSB1021: "}
+      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
+      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
+      </trans-unit>
+      <trans-unit id="XMake.LoggerNotFoundError">
+        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
+        <target state="translated">MSBUILD : error MSB1020: 로거를 찾을 수 없습니다. 다음을 확인하세요. 1) 지정한 로거 이름이 로거 클래스 이름과 같은지 확인합니다. 2.) 로거 클래스가 "public"이고 Microsoft.Build.Framework.ILogger 인터페이스를 구현하는지 확인합니다. 3.) 로거 어셈블리의 경로가 올바른지 또는 지정한 어셈블리 이름만 사용하여 로거를 로드할 수 있는지 확인합니다.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
+      logger class must exist in the given assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="XMake.ProjectUpgradeNeededToVcxProj">
+        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
+        <target state="translated">MSBUILD : error MSB4192: 프로젝트 파일 "{0}"이(가) MSBuild에서 직접 빌드할 수 없는 ".vcproj" 또는 ".dsp" 파일 형식입니다. 프로젝트를 Visual Studio IDE에서 열거나 변환 도구를 실행하여 프로젝트를 변환하거나, ".vcproj"의 경우 MSBuild를 사용하여 해당 프로젝트가 포함된 솔루션 파일을 대신 빌드하세요.</target>
+        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 36da70fd656..5d20dcb3b21 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -15,65 +15,6 @@
         <target state="translated">Kompilacja nie powiodła się. Nie można uzyskać wyników właściwości, elementów i celu. Zobacz szczegóły w sekcji stderr powyżej.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildFinished">
-        <source>Build {0} in {1}s</source>
-        <target state="translated">Kompiluj {0} w {1}s</target>
-        <note>
-      Overall build summary
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Failed">
-        <source>failed</source>
-        <target state="translated">niepowodzenie</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrors">
-        <source>failed with {0} error(s)</source>
-        <target state="translated">zakończono niepowodzeniem, z błędami w liczbie: {0}</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
-        <source>failed with {0} error(s) and {1} warning(s)</source>
-        <target state="translated">zakończono niepowodzeniem, z błędami w liczbie: {0} i ostrzeżeniami w liczbie: {1}</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithWarnings">
-        <source>failed with {0} warning(s)</source>
-        <target state="translated">zakończono niepowodzeniem, z ostrzeżeniami w liczbie: {0}</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Succeeded">
-        <source>succeeded</source>
-        <target state="translated">powodzenie</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_SucceededWithWarnings">
-        <source>succeeded with {0} warning(s)</source>
-        <target state="translated">zakończono powodzeniem, z ostrzeżeniami w liczbie: {0}</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildSummary">
-        <source>Build summary:</source>
-        <target state="translated">Podsumowanie kompilacji:</target>
-        <note>
-      A header used by Terminal Logger to introduce the build summary.
-    </note>
-      </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
         <target state="translated">Argumenty wiersza polecenia = „{0}”</target>
@@ -92,14 +33,6 @@
         <target state="translated">MSBUILD : error MSB1027: przełącznika -noAutoResponse nie można określić w pliku autoodpowiedzi MSBuild.rsp ani w żadnym pliku odpowiedzi, do którego odwołuje się plik autoodpowiedzi.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DurationDisplay">
-        <source>({0:F1}s)</source>
-        <target state="translated">({0:F1}s)</target>
-        <note>
-        {0}: duration in seconds with 1 decimal point
-        's' should reflect the localized abbreviation for seconds
-      </note>
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -1746,39 +1679,6 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
         <target state="translated">Proces = „{0}”</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectFinished_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}s)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_OutputPath">
-        <source> → {0}</source>
-        <target state="translated"> → {0}</target>
-        <note>
-      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
-      {0}: VT100 coded hyperlink to project output directory
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: plik projektu nie istnieje.</target>
@@ -1824,24 +1724,6 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
         <target state="translated">Element „{0}“ pochodzi z „{1}“</target>
         <note>
       These are response file switches with the location of the response file on disk.
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreComplete">
-        <source>Restore complete ({0}s)</source>
-        <target state="translated">Zakończono przywracanie ({0}s)</target>
-        <note>
-      {0}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreCompleteWithMessage">
-        <source>Restore {0} in {1}s</source>
-        <target state="translated">Przywróć {0} w {1}s</target>
-        <note>
-      Restore summary when finished with warning or error
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
     </note>
       </trans-unit>
       <trans-unit id="SAC">
@@ -1928,59 +1810,6 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
         <target state="translated">Rejestrator terminali nie został użyty, ponieważ dane wyjściowe są przekierowywane do pliku.</target>
         <note />
       </trans-unit>
-      <trans-unit id="TestProjectFinished_NoTF">
-        <source>{0}{1} test {2} ({3}s)</source>
-        <target state="translated">{0}{1} test {2} ({3}s)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestProjectFinished_WithTF">
-        <source>{0}{1} test {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} test {2} {3} ({4}s)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_BannerAndTotal">
-        <source>Test summary: total: {0}</source>
-        <target state="translated">Podsumowanie testu: łącznie: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Duration">
-        <source>duration: {0}s</source>
-        <target state="translated">czas trwania: {0}s</target>
-        <note>
-      {0} whole number
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Failed">
-        <source>failed: {0}</source>
-        <target state="translated">niepowodzenie: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Skipped">
-        <source>skipped: {0}</source>
-        <target state="translated">pominięto: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Succeeded">
-        <source>succeeded: {0}</source>
-        <target state="translated">zakończone powodzeniem: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: ten przełącznik nie ma żadnych parametrów.</target>
@@ -2063,29 +1892,6 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
         <target state="translated">MSBUILD : error MSB1047: Plik, który ma zostać wstępnie przetworzony, jest nieprawidłowy. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1047: "}</note>
       </trans-unit>
-      <trans-unit id="LoggerCreationError">
-        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
-        <target state="translated">MSBUILD : error MSB1021: nie można utworzyć wystąpienia rejestratora. {0}</target>
-        <note>{StrBegin="MSBUILD : error MSB1021: "}
-      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
-      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
-      </trans-unit>
-      <trans-unit id="LoggerNotFoundError">
-        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
-        <target state="translated">MSBUILD : error MSB1020: Nie można odnaleźć rejestratora. Sprawdź, czy: 1.) Określona nazwa rejestratora jest taka sama jak nazwa klasy rejestratora. 2.) Klasą rejestratora jest klasa „public”, która implementuje interfejs Microsoft.Build.Framework.ILogger. 3.) Ścieżka do zestawu rejestratora jest prawidłowa lub rejestrator można załadować wyłącznie przy użyciu podanej nazwy zestawu.</target>
-        <note>
-      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
-      logger class must exist in the given assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectUpgradeNeededToVcxProj">
-        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
-        <target state="translated">MSBUILD : error MSB4192: Plik projektu „{0}” ma format „.vcproj” lub „.dsp”, którego program MSBuild nie może skompilować bezpośrednio. Przekonwertuj projekt, otwierając go w programie Visual Studio IDE lub uruchamiając narzędzie konwersji, albo (w przypadku pliku „.vcproj”) użyj programu MSBuild, aby utworzyć plik rozwiązania zawierający ten projekt.</target>
-        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
-      </trans-unit>
       <trans-unit id="NeedJustMyCode">
         <source>If MSBuild debugging does not work correctly, please verify that the "Just My Code" feature is enabled in Visual Studio, and that you have selected the managed debugger.</source>
         <target state="translated">Jeśli debugowanie w programie MSBuild nie działa poprawnie, sprawdź, czy w programie Visual Studio jest włączona funkcja „Just My Code” i czy został wybrany debuger zarządzany.</target>
@@ -2380,6 +2186,29 @@ dzienników                     tekstowych i wykorzystać w innych narzędziach
         <target state="translated">MSBUILD : błąd MSB1054: Należy określić nazwę pliku, aby wygenerować wynik profilera.</target>
         <note />
       </trans-unit>
+      <trans-unit id="XMake.LoggerCreationError">
+        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
+        <target state="translated">MSBUILD : error MSB1021: nie można utworzyć wystąpienia rejestratora. {0}</target>
+        <note>{StrBegin="MSBUILD : error MSB1021: "}
+      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
+      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
+      </trans-unit>
+      <trans-unit id="XMake.LoggerNotFoundError">
+        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
+        <target state="translated">MSBUILD : error MSB1020: Nie można odnaleźć rejestratora. Sprawdź, czy: 1.) Określona nazwa rejestratora jest taka sama jak nazwa klasy rejestratora. 2.) Klasą rejestratora jest klasa „public”, która implementuje interfejs Microsoft.Build.Framework.ILogger. 3.) Ścieżka do zestawu rejestratora jest prawidłowa lub rejestrator można załadować wyłącznie przy użyciu podanej nazwy zestawu.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
+      logger class must exist in the given assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="XMake.ProjectUpgradeNeededToVcxProj">
+        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
+        <target state="translated">MSBUILD : error MSB4192: Plik projektu „{0}” ma format „.vcproj” lub „.dsp”, którego program MSBuild nie może skompilować bezpośrednio. Przekonwertuj projekt, otwierając go w programie Visual Studio IDE lub uruchamiając narzędzie konwersji, albo (w przypadku pliku „.vcproj”) użyj programu MSBuild, aby utworzyć plik rozwiązania zawierający ten projekt.</target>
+        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 44f14597a37..873f8078d9d 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -15,65 +15,6 @@
         <target state="translated">Falha na compilação. Não foi possível obter os resultados de Propriedades, Itens e Destino. Veja os detalhes no stderr acima.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildFinished">
-        <source>Build {0} in {1}s</source>
-        <target state="translated">Construir {0} em {1}s</target>
-        <note>
-      Overall build summary
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Failed">
-        <source>failed</source>
-        <target state="translated">falhou</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrors">
-        <source>failed with {0} error(s)</source>
-        <target state="translated">falhou com {0} erro(s)</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
-        <source>failed with {0} error(s) and {1} warning(s)</source>
-        <target state="translated">falhou com{0} erros e {1} avisos</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithWarnings">
-        <source>failed with {0} warning(s)</source>
-        <target state="translated">falhou com {0} aviso(s)</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Succeeded">
-        <source>succeeded</source>
-        <target state="translated">êxito</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_SucceededWithWarnings">
-        <source>succeeded with {0} warning(s)</source>
-        <target state="translated">êxito(s) com {0} aviso(s)</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildSummary">
-        <source>Build summary:</source>
-        <target state="translated">Resumo da compilação:</target>
-        <note>
-      A header used by Terminal Logger to introduce the build summary.
-    </note>
-      </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
         <target state="translated">Argumentos de linha de comando = "{0}"</target>
@@ -92,14 +33,6 @@
         <target state="translated">MSBUILD : error MSB1027: A opção /noAutoResponse não pode ser especificada no arquivo de resposta automática MSBuild.rsp nem em qualquer arquivo de resposta usado como referência para o arquivo de resposta automática.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DurationDisplay">
-        <source>({0:F1}s)</source>
-        <target state="translated">({0:F1}s)</target>
-        <note>
-        {0}: duration in seconds with 1 decimal point
-        's' should reflect the localized abbreviation for seconds
-      </note>
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -1736,39 +1669,6 @@ arquivo de resposta.
         <target state="translated">Processo = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectFinished_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}s)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_OutputPath">
-        <source> → {0}</source>
-        <target state="translated"> → {0}</target>
-        <note>
-      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
-      {0}: VT100 coded hyperlink to project output directory
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4}s)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Arquivo de projeto não existe.</target>
@@ -1814,24 +1714,6 @@ arquivo de resposta.
         <target state="translated">'{0}' proveniente de '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreComplete">
-        <source>Restore complete ({0}s)</source>
-        <target state="translated">Restauração concluída ({0}s)</target>
-        <note>
-      {0}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreCompleteWithMessage">
-        <source>Restore {0} in {1}s</source>
-        <target state="translated">Restaurar {0} em {1}s</target>
-        <note>
-      Restore summary when finished with warning or error
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
     </note>
       </trans-unit>
       <trans-unit id="SAC">
@@ -1918,59 +1800,6 @@ arquivo de resposta.
         <target state="translated">O Agente de Terminal não foi usado porque a saída está sendo redirecionada para um arquivo.</target>
         <note />
       </trans-unit>
-      <trans-unit id="TestProjectFinished_NoTF">
-        <source>{0}{1} test {2} ({3}s)</source>
-        <target state="translated">{0}{1} teste {2} ({3}s)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestProjectFinished_WithTF">
-        <source>{0}{1} test {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} teste {2} {3} ({4}s)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_BannerAndTotal">
-        <source>Test summary: total: {0}</source>
-        <target state="translated">Resumo do teste: total: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Duration">
-        <source>duration: {0}s</source>
-        <target state="translated">duração: {0}s</target>
-        <note>
-      {0} whole number
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Failed">
-        <source>failed: {0}</source>
-        <target state="translated">falhou: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Skipped">
-        <source>skipped: {0}</source>
-        <target state="translated">ignorado: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Succeeded">
-        <source>succeeded: {0}</source>
-        <target state="translated">bem-sucedido: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Esta opção não aceita parâmetros.</target>
@@ -2053,29 +1882,6 @@ arquivo de resposta.
         <target state="translated">MSBUILD : error MSB1047: O arquivo a ser pré-processado é inválido. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1047: "}</note>
       </trans-unit>
-      <trans-unit id="LoggerCreationError">
-        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
-        <target state="translated">MSBUILD : error MSB1021: Não é possível criar instância do agente de log. {0}</target>
-        <note>{StrBegin="MSBUILD : error MSB1021: "}
-      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
-      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
-      </trans-unit>
-      <trans-unit id="LoggerNotFoundError">
-        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
-        <target state="translated">MSBUILD : error MSB1020: O agente não foi encontrado. Verifique se: 1.) O nome do agente especificado é igual ao nome da classe de agente. 2.) A classe de agente é "public" e implementa a interface Microsoft.Build.Framework.ILogger. 3.) O caminho para o assembly de agente está correto ou o agente pode ser carregado somente com o nome do assembly fornecido.</target>
-        <note>
-      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
-      logger class must exist in the given assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectUpgradeNeededToVcxProj">
-        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
-        <target state="translated">MSBUILD : error MSB4192: O arquivo de projeto "{0}" está no formato de arquivo ".vcproj" ou ".dsp", o qual não pode ser compilado diretamente pelo MSBuild. Converta o projeto abrindo-o no IDE do Visual Studio ou executando uma ferramenta de conversão ou, para ".vcproj", use o MSBuild para compilar o arquivo de solução que contém o projeto.</target>
-        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
-      </trans-unit>
       <trans-unit id="NeedJustMyCode">
         <source>If MSBuild debugging does not work correctly, please verify that the "Just My Code" feature is enabled in Visual Studio, and that you have selected the managed debugger.</source>
         <target state="translated">Se a depuração do MSBuild não funcionar corretamente, verifique se o recurso "Apenas Meu Código" está habilitado no Visual Studio e se o depurador gerenciado foi selecionado.</target>
@@ -2370,6 +2176,29 @@ arquivo de resposta.
         <target state="translated">MSBUILD :erro MSB1054: um nome de arquivo deve ser especificado para gerar o resultado do criador de perfil.</target>
         <note />
       </trans-unit>
+      <trans-unit id="XMake.LoggerCreationError">
+        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
+        <target state="translated">MSBUILD : error MSB1021: Não é possível criar instância do agente de log. {0}</target>
+        <note>{StrBegin="MSBUILD : error MSB1021: "}
+      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
+      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
+      </trans-unit>
+      <trans-unit id="XMake.LoggerNotFoundError">
+        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
+        <target state="translated">MSBUILD : error MSB1020: O agente não foi encontrado. Verifique se: 1.) O nome do agente especificado é igual ao nome da classe de agente. 2.) A classe de agente é "public" e implementa a interface Microsoft.Build.Framework.ILogger. 3.) O caminho para o assembly de agente está correto ou o agente pode ser carregado somente com o nome do assembly fornecido.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
+      logger class must exist in the given assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="XMake.ProjectUpgradeNeededToVcxProj">
+        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
+        <target state="translated">MSBUILD : error MSB4192: O arquivo de projeto "{0}" está no formato de arquivo ".vcproj" ou ".dsp", o qual não pode ser compilado diretamente pelo MSBuild. Converta o projeto abrindo-o no IDE do Visual Studio ou executando uma ferramenta de conversão ou, para ".vcproj", use o MSBuild para compilar o arquivo de solução que contém o projeto.</target>
+        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 3e5f3a5c98f..53e8695e09b 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -15,65 +15,6 @@
         <target state="translated">Сборка не удалась. Не удается получить свойства, элементы и целевые результаты. См. подробности в stderr выше.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildFinished">
-        <source>Build {0} in {1}s</source>
-        <target state="translated">Сборка {0} через {1} с</target>
-        <note>
-      Overall build summary
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Failed">
-        <source>failed</source>
-        <target state="translated">сбой</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrors">
-        <source>failed with {0} error(s)</source>
-        <target state="translated">сбой с ошибками ({0})</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
-        <source>failed with {0} error(s) and {1} warning(s)</source>
-        <target state="translated">сбой с ошибками ({0}) и предупреждениями ({1})</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithWarnings">
-        <source>failed with {0} warning(s)</source>
-        <target state="translated">сбой с предупреждениями ({0})</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Succeeded">
-        <source>succeeded</source>
-        <target state="translated">успешно выполнено</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_SucceededWithWarnings">
-        <source>succeeded with {0} warning(s)</source>
-        <target state="translated">успешно выполнено с предупреждениями ({0})</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildSummary">
-        <source>Build summary:</source>
-        <target state="translated">Сводка сборки:</target>
-        <note>
-      A header used by Terminal Logger to introduce the build summary.
-    </note>
-      </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
         <target state="translated">Аргументы командной строки = "{0}"</target>
@@ -92,14 +33,6 @@
         <target state="translated">MSBUILD : error MSB1027: ключ noAutoResponse не может быть указан в файле автоответа MSBuild.rsp или в любом другом файле ответа, на который файл автоответа ссылается.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DurationDisplay">
-        <source>({0:F1}s)</source>
-        <target state="translated">({0:F1}s)</target>
-        <note>
-        {0}: duration in seconds with 1 decimal point
-        's' should reflect the localized abbreviation for seconds
-      </note>
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -1734,39 +1667,6 @@
         <target state="translated">Процесс = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectFinished_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3} с)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_OutputPath">
-        <source> → {0}</source>
-        <target state="translated"> → {0}</target>
-        <note>
-      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
-      {0}: VT100 coded hyperlink to project output directory
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4} с)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: файл проекта не существует.</target>
@@ -1812,24 +1712,6 @@
         <target state="translated">\"{0}\" получен из \"{1}\"</target>
         <note>
       These are response file switches with the location of the response file on disk.
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreComplete">
-        <source>Restore complete ({0}s)</source>
-        <target state="translated">Восстановление завершено ({0} с)</target>
-        <note>
-      {0}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreCompleteWithMessage">
-        <source>Restore {0} in {1}s</source>
-        <target state="translated">Восстановление {0} через {1} с</target>
-        <note>
-      Restore summary when finished with warning or error
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
     </note>
       </trans-unit>
       <trans-unit id="SAC">
@@ -1916,59 +1798,6 @@
         <target state="translated">Средство ведения журнала терминалов не используется, так как выходные данные перенаправляются в файл.</target>
         <note />
       </trans-unit>
-      <trans-unit id="TestProjectFinished_NoTF">
-        <source>{0}{1} test {2} ({3}s)</source>
-        <target state="translated">{0}{1} (тест) {2} ({3} с)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestProjectFinished_WithTF">
-        <source>{0}{1} test {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} (тест) {2} {3} ({4} с)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_BannerAndTotal">
-        <source>Test summary: total: {0}</source>
-        <target state="translated">Сводка теста: всего: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Duration">
-        <source>duration: {0}s</source>
-        <target state="translated">длительность: {0} с</target>
-        <note>
-      {0} whole number
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Failed">
-        <source>failed: {0}</source>
-        <target state="translated">сбой: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Skipped">
-        <source>skipped: {0}</source>
-        <target state="translated">пропущено: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Succeeded">
-        <source>succeeded: {0}</source>
-        <target state="translated">успешно: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: у этого ключа нет параметров.</target>
@@ -2051,29 +1880,6 @@
         <target state="translated">MSBUILD : error MSB1047: недопустимый файл для предварительной обработки. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1047: "}</note>
       </trans-unit>
-      <trans-unit id="LoggerCreationError">
-        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
-        <target state="translated">MSBUILD : error MSB1021: не удается создать экземпляр журнала. {0}</target>
-        <note>{StrBegin="MSBUILD : error MSB1021: "}
-      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
-      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
-      </trans-unit>
-      <trans-unit id="LoggerNotFoundError">
-        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
-        <target state="translated">MSBUILD : error MSB1020: не удалось найти средство ведения журнала. Убедитесь в следующем. 1. Имя средства ведения журнала совпадает с именем класса средства ведения журнала. 2. Класс средства ведения журнала является открытым и реализует интерфейс Microsoft.Build.Framework.ILogger. 3. Путь к сборке ведения журнала правильный или средство ведения журнала можно успешно загрузить, используя только указанное имя сборки.</target>
-        <note>
-      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
-      logger class must exist in the given assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectUpgradeNeededToVcxProj">
-        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
-        <target state="translated">MSBUILD : error MSB4192: файл проекта "{0}" указан в формате "VCPROJ" или "DSP", непосредственная сборка которого с помощью MSBuild невозможна. Преобразуйте проект, открыв его в Visual Studio IDE или запустив инструмент преобразования, либо (в случае с "VCPROJ") используйте MSBuild для сборки файла решения, содержащего данный проект.</target>
-        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
-      </trans-unit>
       <trans-unit id="NeedJustMyCode">
         <source>If MSBuild debugging does not work correctly, please verify that the "Just My Code" feature is enabled in Visual Studio, and that you have selected the managed debugger.</source>
         <target state="translated">Если отладка MSBuild работает неправильно, убедитесь, что выбран управляемый отладчик, а в Visual Studio включен режим "Только мой код".</target>
@@ -2370,6 +2176,29 @@
         <target state="translated">MSBUILD: ошибка MSB1054 — укажите имя файла, чтобы создать результат профилировщика.</target>
         <note />
       </trans-unit>
+      <trans-unit id="XMake.LoggerCreationError">
+        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
+        <target state="translated">MSBUILD : error MSB1021: не удается создать экземпляр журнала. {0}</target>
+        <note>{StrBegin="MSBUILD : error MSB1021: "}
+      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
+      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
+      </trans-unit>
+      <trans-unit id="XMake.LoggerNotFoundError">
+        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
+        <target state="translated">MSBUILD : error MSB1020: не удалось найти средство ведения журнала. Убедитесь в следующем. 1. Имя средства ведения журнала совпадает с именем класса средства ведения журнала. 2. Класс средства ведения журнала является открытым и реализует интерфейс Microsoft.Build.Framework.ILogger. 3. Путь к сборке ведения журнала правильный или средство ведения журнала можно успешно загрузить, используя только указанное имя сборки.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
+      logger class must exist in the given assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="XMake.ProjectUpgradeNeededToVcxProj">
+        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
+        <target state="translated">MSBUILD : error MSB4192: файл проекта "{0}" указан в формате "VCPROJ" или "DSP", непосредственная сборка которого с помощью MSBuild невозможна. Преобразуйте проект, открыв его в Visual Studio IDE или запустив инструмент преобразования, либо (в случае с "VCPROJ") используйте MSBuild для сборки файла решения, содержащего данный проект.</target>
+        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 62c19884023..f01b080e37d 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -15,65 +15,6 @@
         <target state="translated">Derleme başarısız oldu. Özellikler, Öğeler ve Hedef sonuçları alınamıyor. Yukarıda stderr'de ayrıntılara bakın.</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildFinished">
-        <source>Build {0} in {1}s</source>
-        <target state="translated">"{1}" sn'de {0} oluşturun</target>
-        <note>
-      Overall build summary
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Failed">
-        <source>failed</source>
-        <target state="translated">başarısız oldu</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrors">
-        <source>failed with {0} error(s)</source>
-        <target state="translated">{0} hata ile başarısız oldu</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
-        <source>failed with {0} error(s) and {1} warning(s)</source>
-        <target state="translated">{0} hata ve {1} uyarıyla başarısız oldu</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithWarnings">
-        <source>failed with {0} warning(s)</source>
-        <target state="translated">{0} uyarıyla başarısız oldu</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Succeeded">
-        <source>succeeded</source>
-        <target state="translated">başarılı</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_SucceededWithWarnings">
-        <source>succeeded with {0} warning(s)</source>
-        <target state="translated">{0} uyarıyla başarılı oldu</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildSummary">
-        <source>Build summary:</source>
-        <target state="translated">Derleme özeti:</target>
-        <note>
-      A header used by Terminal Logger to introduce the build summary.
-    </note>
-      </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
         <target state="translated">Komut satırı bağımsız değişkenleri = "{0}"</target>
@@ -92,14 +33,6 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse anahtarı, MSBuild.rsp otomatik yanıt dosyasında ve bu dosyanın başvuruda bulunduğu herhangi bir yanıt dosyasında belirtilemez.</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DurationDisplay">
-        <source>({0:F1}s)</source>
-        <target state="translated">({0:F1}s)</target>
-        <note>
-        {0}: duration in seconds with 1 decimal point
-        's' should reflect the localized abbreviation for seconds
-      </note>
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -1739,39 +1672,6 @@
         <target state="translated">İşlem = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectFinished_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3}sn)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_OutputPath">
-        <source> → {0}</source>
-        <target state="translated"> → {0}</target>
-        <note>
-      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
-      {0}: VT100 coded hyperlink to project output directory
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3}({4}sn)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Proje dosyası yok.</target>
@@ -1817,24 +1717,6 @@
         <target state="translated">'{0}', '{1}' kaynağından geldi</target>
         <note>
       These are response file switches with the location of the response file on disk.
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreComplete">
-        <source>Restore complete ({0}s)</source>
-        <target state="translated">Geri yükleme tamamlandı ({0}sn)</target>
-        <note>
-      {0}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreCompleteWithMessage">
-        <source>Restore {0} in {1}s</source>
-        <target state="translated">{1}sn içinde {0} geri yükle</target>
-        <note>
-      Restore summary when finished with warning or error
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
     </note>
       </trans-unit>
       <trans-unit id="SAC">
@@ -1921,59 +1803,6 @@
         <target state="translated">Çıkış bir dosyaya yeniden yönlendirildiği için Terminal Günlükçüsü kullanılmadı.</target>
         <note />
       </trans-unit>
-      <trans-unit id="TestProjectFinished_NoTF">
-        <source>{0}{1} test {2} ({3}s)</source>
-        <target state="translated">{0}{1} testi {2} ({3}s)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestProjectFinished_WithTF">
-        <source>{0}{1} test {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} testi {2} {3} ({4}s)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_BannerAndTotal">
-        <source>Test summary: total: {0}</source>
-        <target state="translated">Test özeti: toplam: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Duration">
-        <source>duration: {0}s</source>
-        <target state="translated">süre: {0}s</target>
-        <note>
-      {0} whole number
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Failed">
-        <source>failed: {0}</source>
-        <target state="translated">başarısız: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Skipped">
-        <source>skipped: {0}</source>
-        <target state="translated">atlandı: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Succeeded">
-        <source>succeeded: {0}</source>
-        <target state="translated">başarılı: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: Bu anahtar parametreyle kullanılmaz.</target>
@@ -2056,29 +1885,6 @@
         <target state="translated">MSBUILD : error MSB1047: Ön işlem uygulanacak dosya geçerli değil. {0}</target>
         <note>{StrBegin="MSBUILD : error MSB1047: "}</note>
       </trans-unit>
-      <trans-unit id="LoggerCreationError">
-        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
-        <target state="translated">MSBUILD : error MSB1021: Günlük oluşturucunun bir örneği oluşturulamıyor. {0}</target>
-        <note>{StrBegin="MSBUILD : error MSB1021: "}
-      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
-      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
-      </trans-unit>
-      <trans-unit id="LoggerNotFoundError">
-        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
-        <target state="translated">MSBUILD : error MSB1020: Günlükçü bulunamadı. Aşağıdakileri denetleyin: 1.) Belirtilen günlükçü adı, günlükçü sınıfının adıyla aynıdır. 2.) Günlükçü sınıfı "geneldir" ve Microsoft.Build.Framework.ILogger arabirimini uygular. 3.) Günlükçü bütünleştirilmiş kodunun yolu doğrudur veya günlükçü yalnızca belirtilen günlükçü adı kullanılarak yüklenebilir.</target>
-        <note>
-      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
-      logger class must exist in the given assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectUpgradeNeededToVcxProj">
-        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
-        <target state="translated">MSBUILD : error MSB4192: "{0}" proje dosyası, MSBuild’in doğrudan derleyemeyeceği ".vcproj" veya ".dsp" dosya biçiminde. Lütfen projeyi Visual Studio IDE içinde açarak veya dönüştürme aracını kullanarak dönüştürün ya da “.vcproj” için MSBuild kullanarak projeyi içeren çözüm dosyasını derleyin.</target>
-        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
-      </trans-unit>
       <trans-unit id="NeedJustMyCode">
         <source>If MSBuild debugging does not work correctly, please verify that the "Just My Code" feature is enabled in Visual Studio, and that you have selected the managed debugger.</source>
         <target state="translated">MSBuild hata ayıklaması düzgün çalışmıyorsa, lütfen Visual Studio'da "Yalnızca Kendi Kodum" özelliğinin etkinleştirildiğinden ve yönetilen hata ayıklayıcıyı seçtiğinizden emin olun.</target>
@@ -2373,6 +2179,29 @@
         <target state="translated">MSBUILD: MSB1054 hatası: Profil oluşturucu sonucunun oluşturulması için bir dosya adı belirtilmelidir.</target>
         <note />
       </trans-unit>
+      <trans-unit id="XMake.LoggerCreationError">
+        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
+        <target state="translated">MSBUILD : error MSB1021: Günlük oluşturucunun bir örneği oluşturulamıyor. {0}</target>
+        <note>{StrBegin="MSBUILD : error MSB1021: "}
+      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
+      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
+      </trans-unit>
+      <trans-unit id="XMake.LoggerNotFoundError">
+        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
+        <target state="translated">MSBUILD : error MSB1020: Günlükçü bulunamadı. Aşağıdakileri denetleyin: 1.) Belirtilen günlükçü adı, günlükçü sınıfının adıyla aynıdır. 2.) Günlükçü sınıfı "geneldir" ve Microsoft.Build.Framework.ILogger arabirimini uygular. 3.) Günlükçü bütünleştirilmiş kodunun yolu doğrudur veya günlükçü yalnızca belirtilen günlükçü adı kullanılarak yüklenebilir.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
+      logger class must exist in the given assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="XMake.ProjectUpgradeNeededToVcxProj">
+        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
+        <target state="translated">MSBUILD : error MSB4192: "{0}" proje dosyası, MSBuild’in doğrudan derleyemeyeceği ".vcproj" veya ".dsp" dosya biçiminde. Lütfen projeyi Visual Studio IDE içinde açarak veya dönüştürme aracını kullanarak dönüştürün ya da “.vcproj” için MSBuild kullanarak projeyi içeren çözüm dosyasını derleyin.</target>
+        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 464d639afcd..0968a8a75fb 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -15,65 +15,6 @@
         <target state="translated">生成失败。无法获取属性、项目和目标结果。在上面的 stderr 中查看详细信息。</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildFinished">
-        <source>Build {0} in {1}s</source>
-        <target state="translated">在 {1} 秒内生成 {0}</target>
-        <note>
-      Overall build summary
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Failed">
-        <source>failed</source>
-        <target state="translated">失败</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrors">
-        <source>failed with {0} error(s)</source>
-        <target state="translated">失败，出现 {0} 错误</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
-        <source>failed with {0} error(s) and {1} warning(s)</source>
-        <target state="translated">失败，出现 {0} 错误和 {1} 警告</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithWarnings">
-        <source>failed with {0} warning(s)</source>
-        <target state="translated">失败，出现 {0} 警告</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Succeeded">
-        <source>succeeded</source>
-        <target state="translated">已成功</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_SucceededWithWarnings">
-        <source>succeeded with {0} warning(s)</source>
-        <target state="translated">成功，出现 {0} 警告</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildSummary">
-        <source>Build summary:</source>
-        <target state="translated">生成摘要:</target>
-        <note>
-      A header used by Terminal Logger to introduce the build summary.
-    </note>
-      </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
         <target state="translated">命令行参数 = "{0}"</target>
@@ -92,14 +33,6 @@
         <target state="translated">MSBUILD : error MSB1027: 不能在 MSBuild.rsp 自动响应文件中或由该自动响应文件引用的任何响应文件中指定 -noAutoResponse 开关。</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DurationDisplay">
-        <source>({0:F1}s)</source>
-        <target state="translated">({0:F1}s)</target>
-        <note>
-        {0}: duration in seconds with 1 decimal point
-        's' should reflect the localized abbreviation for seconds
-      </note>
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -1735,39 +1668,6 @@
         <target state="translated">进程 = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectFinished_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3} 秒)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_OutputPath">
-        <source> → {0}</source>
-        <target state="translated"> → {0}</target>
-        <note>
-      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
-      {0}: VT100 coded hyperlink to project output directory
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4} 秒)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: 项目文件不存在。</target>
@@ -1813,24 +1713,6 @@
         <target state="translated">“{0}”来自“{1}”</target>
         <note>
       These are response file switches with the location of the response file on disk.
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreComplete">
-        <source>Restore complete ({0}s)</source>
-        <target state="translated">还原完成({0} 秒)</target>
-        <note>
-      {0}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreCompleteWithMessage">
-        <source>Restore {0} in {1}s</source>
-        <target state="translated">在 {1} 秒内还原 {0}</target>
-        <note>
-      Restore summary when finished with warning or error
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
     </note>
       </trans-unit>
       <trans-unit id="SAC">
@@ -1917,59 +1799,6 @@
         <target state="translated">未使用终端记录器，因为正在将输出重定向到文件。</target>
         <note />
       </trans-unit>
-      <trans-unit id="TestProjectFinished_NoTF">
-        <source>{0}{1} test {2} ({3}s)</source>
-        <target state="translated">{0}{1} 测试 {2} ({3} 秒)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestProjectFinished_WithTF">
-        <source>{0}{1} test {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} 测试 {2} {3} ({4} 秒)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_BannerAndTotal">
-        <source>Test summary: total: {0}</source>
-        <target state="translated">测试摘要: 总计: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Duration">
-        <source>duration: {0}s</source>
-        <target state="translated">持续时间: {0} 秒</target>
-        <note>
-      {0} whole number
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Failed">
-        <source>failed: {0}</source>
-        <target state="translated">失败: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Skipped">
-        <source>skipped: {0}</source>
-        <target state="translated">已跳过: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Succeeded">
-        <source>succeeded: {0}</source>
-        <target state="translated">成功: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: 此开关不采用任何参数。</target>
@@ -2052,29 +1881,6 @@
         <target state="translated">MSBUILD : error MSB1047: 要预处理的文件无效。{0}</target>
         <note>{StrBegin="MSBUILD : error MSB1047: "}</note>
       </trans-unit>
-      <trans-unit id="LoggerCreationError">
-        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
-        <target state="translated">MSBUILD : error MSB1021: 无法创建记录器的实例。{0}</target>
-        <note>{StrBegin="MSBUILD : error MSB1021: "}
-      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
-      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
-      </trans-unit>
-      <trans-unit id="LoggerNotFoundError">
-        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
-        <target state="translated">MSBUILD : error MSB1020: 找不到记录器。请检查下列各项: 1.)指定的记录器名称与记录器类的名称相同。2.)记录器类为“public”并且实现 Microsoft.Build.Framework.ILogger 接口。3.)记录器程序集的路径正确无误，或者只使用所提供的程序集名称就可以加载记录器。</target>
-        <note>
-      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
-      logger class must exist in the given assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectUpgradeNeededToVcxProj">
-        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
-        <target state="translated">MSBUILD : error MSB4192: 项目文件“{0}”为“.vcproj”或“.dsp”文件格式，而 MSBuild 无法直接生成这些文件格式。请通过在 Visual Studio IDE 中打开该项目或运行转换工具来转换该项目；对于“.vcproj”格式，还可以使用 MSBuild 来生成包含该项目的解决方案文件。</target>
-        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
-      </trans-unit>
       <trans-unit id="NeedJustMyCode">
         <source>If MSBuild debugging does not work correctly, please verify that the "Just My Code" feature is enabled in Visual Studio, and that you have selected the managed debugger.</source>
         <target state="translated">如果 MSBuild 调试无法正常工作，请验证 Visual Studio 中是否已启用“仅我的代码”功能，以及您是否选择了托管调试器。</target>
@@ -2369,6 +2175,29 @@
         <target state="translated">MSBUILD :错误 MSB1054: 必须指定文件名才可生成探查器结果。</target>
         <note />
       </trans-unit>
+      <trans-unit id="XMake.LoggerCreationError">
+        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
+        <target state="translated">MSBUILD : error MSB1021: 无法创建记录器的实例。{0}</target>
+        <note>{StrBegin="MSBUILD : error MSB1021: "}
+      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
+      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
+      </trans-unit>
+      <trans-unit id="XMake.LoggerNotFoundError">
+        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
+        <target state="translated">MSBUILD : error MSB1020: 找不到记录器。请检查下列各项: 1.)指定的记录器名称与记录器类的名称相同。2.)记录器类为“public”并且实现 Microsoft.Build.Framework.ILogger 接口。3.)记录器程序集的路径正确无误，或者只使用所提供的程序集名称就可以加载记录器。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
+      logger class must exist in the given assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="XMake.ProjectUpgradeNeededToVcxProj">
+        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
+        <target state="translated">MSBUILD : error MSB4192: 项目文件“{0}”为“.vcproj”或“.dsp”文件格式，而 MSBuild 无法直接生成这些文件格式。请通过在 Visual Studio IDE 中打开该项目或运行转换工具来转换该项目；对于“.vcproj”格式，还可以使用 MSBuild 来生成包含该项目的解决方案文件。</target>
+        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 43815fdeb50..b2b8fb45067 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -15,65 +15,6 @@
         <target state="translated">建置失敗。無法取得屬性、項目及目標結果。請參閱上述 stderr 中的詳細資料。</target>
         <note />
       </trans-unit>
-      <trans-unit id="BuildFinished">
-        <source>Build {0} in {1}s</source>
-        <target state="translated">在 {1} 秒內建置 {0}</target>
-        <note>
-      Overall build summary
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Failed">
-        <source>failed</source>
-        <target state="translated">失敗</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrors">
-        <source>failed with {0} error(s)</source>
-        <target state="translated">失敗，有 {0} 個錯誤</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithErrorsAndWarnings">
-        <source>failed with {0} error(s) and {1} warning(s)</source>
-        <target state="translated">失敗，有 {0} 個錯誤和 {1} 個警告</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_FailedWithWarnings">
-        <source>failed with {0} warning(s)</source>
-        <target state="translated">失敗，有 {0} 個警告</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_Succeeded">
-        <source>succeeded</source>
-        <target state="translated">成功</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildResult_SucceededWithWarnings">
-        <source>succeeded with {0} warning(s)</source>
-        <target state="translated">成功但有 {0} 個警告</target>
-        <note>
-      Part of Terminal Logger summary message: "Build {BuildResult_X} in {duration}s"
-    </note>
-      </trans-unit>
-      <trans-unit id="BuildSummary">
-        <source>Build summary:</source>
-        <target state="translated">組建摘要:</target>
-        <note>
-      A header used by Terminal Logger to introduce the build summary.
-    </note>
-      </trans-unit>
       <trans-unit id="CommandLine">
         <source>Command line arguments = "{0}"</source>
         <target state="translated">命令列引數 = "{0}"</target>
@@ -92,14 +33,6 @@
         <target state="translated">MSBUILD : error MSB1027: -noAutoResponse 參數不能在 MSBuild.rsp 自動回應檔中指定，也不能在自動回應檔所參考的任何回應檔中指定。</target>
         <note>{StrBegin="MSBUILD : error MSB1027: "}LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:", "-noAutoResponse" and "MSBuild.rsp" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="DurationDisplay">
-        <source>({0:F1}s)</source>
-        <target state="translated">({0:F1} 秒)</target>
-        <note>
-        {0}: duration in seconds with 1 decimal point
-        's' should reflect the localized abbreviation for seconds
-      </note>
-      </trans-unit>
       <trans-unit id="HelpMessage_41_QuestionSwitch">
         <source>  -question
                      (Experimental) Question whether there is any build work.
@@ -1736,39 +1669,6 @@
         <target state="translated">流程 = "{0}"</target>
         <note />
       </trans-unit>
-      <trans-unit id="ProjectFinished_NoTF">
-        <source>{0}{1} {2} ({3}s)</source>
-        <target state="translated">{0}{1} {2} ({3} 秒)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_OutputPath">
-        <source> → {0}</source>
-        <target state="translated"> → {0}</target>
-        <note>
-      Info about project output - when known. Printed after ProjectFinished_NoTF or ProjectFinished_WithTF.
-      {0}: VT100 coded hyperlink to project output directory
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectFinished_WithTF">
-        <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4} 秒)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: 專案檔不存在。</target>
@@ -1814,24 +1714,6 @@
         <target state="translated">'{0}' 來自 '{1}'</target>
         <note>
       These are response file switches with the location of the response file on disk.
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreComplete">
-        <source>Restore complete ({0}s)</source>
-        <target state="translated">還原完成 ({0} 秒)</target>
-        <note>
-      {0}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="RestoreCompleteWithMessage">
-        <source>Restore {0} in {1}s</source>
-        <target state="translated">在 {1} 秒內還原 {0}</target>
-        <note>
-      Restore summary when finished with warning or error
-      {0}: BuildResult_X (below)
-      {1}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
     </note>
       </trans-unit>
       <trans-unit id="SAC">
@@ -1918,59 +1800,6 @@
         <target state="translated">因為輸出正重新導向至檔案，所以未使用終端記錄器。</target>
         <note />
       </trans-unit>
-      <trans-unit id="TestProjectFinished_NoTF">
-        <source>{0}{1} test {2} ({3}s)</source>
-        <target state="translated">{0}{1} 測試 {2} ({3} 秒)</target>
-        <note>
-      Project finished summary.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: BuildResult_{X}
-      {3}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestProjectFinished_WithTF">
-        <source>{0}{1} test {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} 測試 {2} {3} ({4} 秒)</target>
-        <note>
-      Project finished summary including target framework information.
-      {0}: indentation - few spaces to visually indent row
-      {1}: project name
-      {2}: target framework
-      {3}: BuildResult_{X}
-      {4}: duration in seconds with 1 decimal point
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_BannerAndTotal">
-        <source>Test summary: total: {0}</source>
-        <target state="translated">測試摘要: 總計: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Duration">
-        <source>duration: {0}s</source>
-        <target state="translated">持續時間: {0} 秒</target>
-        <note>
-      {0} whole number
-      's' should reflect the localized abbreviation for seconds
-    </note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Failed">
-        <source>failed: {0}</source>
-        <target state="translated">失敗: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Skipped">
-        <source>skipped: {0}</source>
-        <target state="translated">已跳過: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
-      <trans-unit id="TestSummary_Succeeded">
-        <source>succeeded: {0}</source>
-        <target state="translated">成功: {0}</target>
-        <note>{0} whole number</note>
-      </trans-unit>
       <trans-unit id="UnexpectedParametersError">
         <source>MSBUILD : error MSB1002: This switch does not take any parameters.</source>
         <target state="translated">MSBUILD : error MSB1002: 這個參數不使用任何參數。</target>
@@ -2053,29 +1882,6 @@
         <target state="translated">MSBUILD : error MSB1047: 要前置處理的目地檔案無效。{0}</target>
         <note>{StrBegin="MSBUILD : error MSB1047: "}</note>
       </trans-unit>
-      <trans-unit id="LoggerCreationError">
-        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
-        <target state="translated">MSBUILD : error MSB1021: 無法建立記錄器的執行個體。{0}</target>
-        <note>{StrBegin="MSBUILD : error MSB1021: "}
-      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
-      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
-      </trans-unit>
-      <trans-unit id="LoggerNotFoundError">
-        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
-        <target state="translated">MSBUILD : error MSB1020: 找不到記錄器。請檢查下列事項: 1.) 指定的記錄器名稱與記錄器類別的名稱相同。2.) 記錄器類別為 "public" 且實作 Microsoft.Build.Framework.ILogger 介面。3.) 記錄器組件的路徑為正確，或記錄器只能使用所提供的組件名稱載入。</target>
-        <note>
-      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
-      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
-      logger class must exist in the given assembly.
-      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
-    </note>
-      </trans-unit>
-      <trans-unit id="ProjectUpgradeNeededToVcxProj">
-        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
-        <target state="translated">MSBUILD : error MSB4192: 專案檔 "{0}" 的檔案格式為 ".vcproj" 或 ".dsp"，MSBuild 無法直接加以建置。請在 Visual Studio IDE 中開啟此專案或執行轉換工具加以轉換，若是 ".vcproj"，則改為使用 MSBuild 建置包含專案的方案檔。</target>
-        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
-      </trans-unit>
       <trans-unit id="NeedJustMyCode">
         <source>If MSBuild debugging does not work correctly, please verify that the "Just My Code" feature is enabled in Visual Studio, and that you have selected the managed debugger.</source>
         <target state="translated">如果 MSBuild 偵錯無法正確運作，請確認是否已在 Visual Studio 中啟用 [Just My Code] 功能、以及是否已選取受控偵錯工具。</target>
@@ -2370,6 +2176,29 @@
         <target state="translated">MSBUILD :錯誤 MSB1054: 必須指定檔案名稱才能產生分析工具結果。</target>
         <note />
       </trans-unit>
+      <trans-unit id="XMake.LoggerCreationError">
+        <source>MSBUILD : error MSB1021: Cannot create an instance of the logger. {0}</source>
+        <target state="translated">MSBUILD : error MSB1021: 無法建立記錄器的執行個體。{0}</target>
+        <note>{StrBegin="MSBUILD : error MSB1021: "}
+      UE: This error is shown when a logger cannot be loaded and instantiated from its assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized. {0} contains a message explaining why the
+      logger could not be created -- this message comes from the CLR/FX and is localized.</note>
+      </trans-unit>
+      <trans-unit id="XMake.LoggerNotFoundError">
+        <source>MSBUILD : error MSB1020: The logger was not found. Check the following: 1.) The logger name specified is the same as the name of the logger class. 2.) The logger class is "public" and implements the Microsoft.Build.Framework.ILogger interface. 3.) The path to the logger assembly is correct, or the logger can be loaded using only the assembly name provided.</source>
+        <target state="translated">MSBUILD : error MSB1020: 找不到記錄器。請檢查下列事項: 1.) 指定的記錄器名稱與記錄器類別的名稱相同。2.) 記錄器類別為 "public" 且實作 Microsoft.Build.Framework.ILogger 介面。3.) 記錄器組件的路徑為正確，或記錄器只能使用所提供的組件名稱載入。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1020: "}UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies an logger that does not exist e.g. "msbuild -logger:FooLoggerClass,FooAssembly". The
+      logger class must exist in the given assembly.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="XMake.ProjectUpgradeNeededToVcxProj">
+        <source>MSBUILD : error MSB4192: The project file "{0}" is in the ".vcproj" or ".dsp" file format, which MSBuild cannot build directly. Please convert the project by opening it in the Visual Studio IDE or running the conversion tool, or, for ".vcproj", use MSBuild to build the solution file containing the project instead.</source>
+        <target state="translated">MSBUILD : error MSB4192: 專案檔 "{0}" 的檔案格式為 ".vcproj" 或 ".dsp"，MSBuild 無法直接加以建置。請在 Visual Studio IDE 中開啟此專案或執行轉換工具加以轉換，若是 ".vcproj"，則改為使用 MSBuild 建置包含專案的方案檔。</target>
+        <note>{StrBegin="MSBUILD : error MSB4192: "} LOC: ".vcproj" and ".dsp" should not be localized</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/MSBuild/TerminalLogger/TestSummary.cs b/src/MSBuild/TerminalLogger/TestSummary.cs
deleted file mode 100644
index dff316e37b8..00000000000
--- a/src/MSBuild/TerminalLogger/TestSummary.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-
-namespace Microsoft.Build.Logging.TerminalLogger
-{
-    internal readonly record struct TestSummary(int Total, int Passed, int Skipped, int Failed);
-}
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index aeddef7aba4..8bf202edc41 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -41,7 +41,7 @@
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
 using SimpleErrorLogger = Microsoft.Build.Logging.SimpleErrorLogger.SimpleErrorLogger;
-using TerminalLogger = Microsoft.Build.Logging.TerminalLogger.TerminalLogger;
+using TerminalLogger = Microsoft.Build.Logging.TerminalLogger;
 
 #if NETFRAMEWORK
 // Use I/O operations from Microsoft.IO.Redist which is generally higher perf
@@ -248,6 +248,8 @@ string[] args
 
             // Initialize new build telemetry and record start of this build.
             KnownTelemetry.PartialBuildTelemetry = new BuildTelemetry { StartAt = DateTime.UtcNow };
+            // Initialize OpenTelemetry infrastructure
+            OpenTelemetryManager.Instance.Initialize(isStandalone: true);
 
             using PerformanceLogEventListener eventListener = PerformanceLogEventListener.Create();
 
@@ -295,6 +297,7 @@ string[] args
             {
                 DumpCounters(false /* log to console */);
             }
+            OpenTelemetryManager.Instance.Shutdown();
 
             return exitCode;
         }
@@ -431,7 +434,7 @@ private static void AppendOutputFile(string path, long elapsedTime)
         /// </comments>
         private static void DumpCounters(bool initializeOnly)
         {
-            Process currentProcess = Process.GetCurrentProcess();
+            using Process currentProcess = Process.GetCurrentProcess();
 
             if (!initializeOnly)
             {
@@ -461,7 +464,7 @@ private static void DumpCounters(bool initializeOnly)
                 using PerformanceCounter counter = new PerformanceCounter(".NET CLR Memory", "Process ID", instance, true);
                 try
                 {
-                    if ((int)counter.RawValue == currentProcess.Id)
+                    if ((int)counter.RawValue == EnvironmentUtilities.CurrentProcessId)
                     {
                         currentInstance = instance;
                         break;
@@ -627,9 +630,9 @@ private static void DebuggerLaunchCheck()
 #endif
                 case "2":
                     // Sometimes easier to attach rather than deal with JIT prompt
-                    Process currentProcess = Process.GetCurrentProcess();
-                    Console.WriteLine($"Waiting for debugger to attach ({currentProcess.MainModule.FileName} PID {currentProcess.Id}).  Press enter to continue...");
+                    Console.WriteLine($"Waiting for debugger to attach ({EnvironmentUtilities.ProcessPath} PID {EnvironmentUtilities.CurrentProcessId}).  Press enter to continue...");
                     Console.ReadLine();
+
                     break;
             }
         }
@@ -835,6 +838,9 @@ public static ExitType Execute(
                         {
                             using (ProjectCollection collection = new(globalProperties, loggers, ToolsetDefinitionLocations.Default))
                             {
+                                // globalProperties collection contains values only from CommandLine at this stage populated by ProcessCommandLineSwitches
+                                collection.PropertiesFromCommandLine = [.. globalProperties.Keys];
+
                                 Project project = collection.LoadProject(projectFile, globalProperties, toolsVersion);
 
                                 if (getResultOutputFile.Length == 0)
@@ -1303,7 +1309,7 @@ internal static bool BuildProject(
         {
             if (FileUtilities.IsVCProjFilename(projectFile) || FileUtilities.IsDspFilename(projectFile))
             {
-                InitializationException.Throw(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectUpgradeNeededToVcxProj", projectFile), null);
+                InitializationException.Throw(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("XMake.ProjectUpgradeNeededToVcxProj", projectFile), null);
             }
 
             bool success = true;
@@ -1393,6 +1399,9 @@ internal static bool BuildProject(
                     useAsynchronousLogging: true,
                     reuseProjectRootElementCache: s_isServerNode);
 
+                // globalProperties collection contains values only from CommandLine at this stage populated by ProcessCommandLineSwitches
+                projectCollection.PropertiesFromCommandLine = [.. globalProperties.Keys];
+
                 if (toolsVersion != null && !projectCollection.ContainsToolset(toolsVersion))
                 {
                     ThrowInvalidToolsVersionInitializationException(projectCollection.Toolsets, toolsVersion);
@@ -1736,7 +1745,7 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
                 new BuildManager.DeferredBuildMessage(
                     ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                         "Process",
-                        Process.GetCurrentProcess().MainModule?.FileName ?? string.Empty),
+                        EnvironmentUtilities.ProcessPath ?? string.Empty),
                     MessageImportance.Low),
                 new BuildManager.DeferredBuildMessage(
                     ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
@@ -2527,8 +2536,7 @@ private static bool ProcessCommandLineSwitches(
 
                 if (!Debugger.IsAttached)
                 {
-                    Process currentProcess = Process.GetCurrentProcess();
-                    Console.WriteLine($"Waiting for debugger to attach... ({currentProcess.MainModule.FileName} PID {currentProcess.Id})");
+                    Console.WriteLine($"Waiting for debugger to attach... ({EnvironmentUtilities.ProcessPath} PID {EnvironmentUtilities.CurrentProcessId})");
                     while (!Debugger.IsAttached)
                     {
                         Thread.Sleep(100);
@@ -2555,9 +2563,13 @@ private static bool ProcessCommandLineSwitches(
             }
             try
             {
-                if (lowPriority && Process.GetCurrentProcess().PriorityClass != ProcessPriorityClass.Idle)
+                if (lowPriority)
                 {
-                    Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.BelowNormal;
+                    using Process currentProcess = Process.GetCurrentProcess();
+                    if (currentProcess.PriorityClass != ProcessPriorityClass.Idle)
+                    {
+                        currentProcess.PriorityClass = ProcessPriorityClass.BelowNormal;
+                    }
                 }
             }
             // We avoid increasing priority because that causes failures on mac/linux, but there is no good way to
@@ -4019,11 +4031,10 @@ private static void ProcessTerminalLogger(bool noConsoleLogger,
         {
             if (!noConsoleLogger)
             {
-                // A central logger will be created for both single proc and multiproc.
-                TerminalLogger logger = new TerminalLogger(verbosity)
-                {
-                    Parameters = aggregatedLoggerParameters
-                };
+                // We can't use InternalsVisibleTo to access the internal TerminalLogger ctor from here, so we use reflection.
+                // This can be fixed when we remove shared files across projects.
+                var logger = (TerminalLogger)Activator.CreateInstance(typeof(TerminalLogger), BindingFlags.Instance | BindingFlags.NonPublic, null, [verbosity], null);
+                logger.Parameters = aggregatedLoggerParameters;
 
                 // Check to see if there is a possibility we will be logging from an out-of-proc node.
                 // If so (we're multi-proc or the in-proc node is disabled), we register a distributed logger.
@@ -4033,8 +4044,26 @@ private static void ProcessTerminalLogger(bool noConsoleLogger,
                 }
                 else
                 {
+                    /// If TerminalLogger runs as a distributed logger, MSBuild out-of-proc nodes might filter the events that will go to the main
+                    /// node using an instance of <see cref="ConfigurableForwardingLogger"/> with the following parameters.
+                    /// Important: Note that TerminalLogger is special-cased in <see cref="BackEnd.Logging.LoggingService.UpdateMinimumMessageImportance"/>
+                    /// so changing this list may impact the minimum message importance logging optimization.
+                    string[] configurableForwardingLoggerParameters =
+                    [
+                        "BUILDSTARTEDEVENT",
+                        "BUILDFINISHEDEVENT",
+                        "PROJECTSTARTEDEVENT",
+                        "PROJECTFINISHEDEVENT",
+                        "TARGETSTARTEDEVENT",
+                        "TARGETFINISHEDEVENT",
+                        "TASKSTARTEDEVENT",
+                        "HIGHMESSAGEEVENT",
+                        "WARNINGEVENT",
+                        "ERROREVENT"
+                    ];
+
                     // For performance, register this logger using the forwarding logger mechanism.
-                    DistributedLoggerRecord forwardingLoggerRecord = CreateForwardingLoggerRecord(logger, string.Join(";", TerminalLogger.ConfigurableForwardingLoggerParameters), LoggerVerbosity.Quiet);
+                    DistributedLoggerRecord forwardingLoggerRecord = CreateForwardingLoggerRecord(logger, string.Join(";", configurableForwardingLoggerParameters), LoggerVerbosity.Quiet);
                     distributedLoggerRecords.Add(forwardingLoggerRecord);
                 }
             }
@@ -4385,27 +4414,27 @@ private static bool CreateAndConfigureLogger(
             {
                 logger = loggerDescription.CreateLogger();
 
-                InitializationException.VerifyThrow(logger != null, "LoggerNotFoundError", unquotedParameter);
+                InitializationException.VerifyThrow(logger != null, "XMake.LoggerNotFoundError", unquotedParameter);
             }
             catch (IOException e) when (!loggerDescription.IsOptional)
             {
-                InitializationException.Throw("LoggerCreationError", unquotedParameter, e, false);
+                InitializationException.Throw("XMake.LoggerCreationError", unquotedParameter, e, false);
             }
             catch (BadImageFormatException e) when (!loggerDescription.IsOptional)
             {
-                InitializationException.Throw("LoggerCreationError", unquotedParameter, e, false);
+                InitializationException.Throw("XMake.LoggerCreationError", unquotedParameter, e, false);
             }
             catch (SecurityException e) when (!loggerDescription.IsOptional)
             {
-                InitializationException.Throw("LoggerCreationError", unquotedParameter, e, false);
+                InitializationException.Throw("XMake.LoggerCreationError", unquotedParameter, e, false);
             }
             catch (ReflectionTypeLoadException e) when (!loggerDescription.IsOptional)
             {
-                InitializationException.Throw("LoggerCreationError", unquotedParameter, e, false);
+                InitializationException.Throw("XMake.LoggerCreationError", unquotedParameter, e, false);
             }
             catch (MemberAccessException e) when (!loggerDescription.IsOptional)
             {
-                InitializationException.Throw("LoggerCreationError", unquotedParameter, e, false);
+                InitializationException.Throw("XMake.LoggerCreationError", unquotedParameter, e, false);
             }
             catch (TargetInvocationException e) when (!loggerDescription.IsOptional)
             {
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index e2321bc67aa..733ccc7fb0b 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -56,14 +56,27 @@
           <assemblyIdentity name="BuildXL.Utilities.Core" publicKeyToken="6212d9137135ce5d" culture="neutral" />
           <codeBase version="1.0.0.0" href="..\BuildXL.Utilities.Core.dll"/>
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.VisualStudio.OpenTelemetry.ClientExtensions" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <codeBase version="0.1.0.0" href="..\Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.VisualStudio.OpenTelemetry.Collector" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <codeBase version="0.1.0.0" href="..\Microsoft.VisualStudio.OpenTelemetry.Collector.dll"/>
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.VisualStudio.SolutionPersistence" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <codeBase version="1.0.0.0" href="..\Microsoft.VisualStudio.SolutionPersistence.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\Microsoft.Bcl.AsyncInterfaces.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\Microsoft.Bcl.AsyncInterfaces.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Bcl.HashCode" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+          <codeBase version="1.0.0.0" href="..\Microsoft.Bcl.HashCode.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -88,8 +101,92 @@
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Collections.Immutable.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Collections.Immutable.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Diagnostics.DiagnosticSource" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Diagnostics.DiagnosticSource.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Formats.Nrbf" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Formats.Nrbf.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.IO.Pipelines" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.IO.Pipelines.dll"/>
+        </dependentAssembly>
+
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Extensions.Configuration.Abstractions" publicKeyToken="adb9793829ddae60" culture="neutral" />
+          <codeBase version="8.0.0.0" href="..\Microsoft.Extensions.Configuration.Abstractions.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Extensions.Configuration.Binder" publicKeyToken="adb9793829ddae60" culture="neutral" />
+          <codeBase version="8.0.0.0" href="..\Microsoft.Extensions.Configuration.Binder.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Extensions.Configuration" publicKeyToken="adb9793829ddae60" culture="neutral" />
+          <codeBase version="8.0.0.0" href="..\Microsoft.Extensions.Configuration.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Extensions.DependencyInjection.Abstractions" publicKeyToken="adb9793829ddae60" culture="neutral" />
+          <codeBase version="8.0.0.0" href="..\Microsoft.Extensions.DependencyInjection.Abstractions.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Extensions.DependencyInjection" publicKeyToken="adb9793829ddae60" culture="neutral" />
+          <codeBase version="8.0.0.0" href="..\Microsoft.Extensions.DependencyInjection.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Extensions.Logging.Abstractions" publicKeyToken="adb9793829ddae60" culture="neutral" />
+          <codeBase version="8.0.0.0" href="..\Microsoft.Extensions.Logging.Abstractions.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Extensions.Logging.Configuration" publicKeyToken="adb9793829ddae60" culture="neutral" />
+          <codeBase version="8.0.0.0" href="..\Microsoft.Extensions.Logging.Configuration.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Extensions.Logging" publicKeyToken="adb9793829ddae60" culture="neutral" />
+          <codeBase version="8.0.0.0" href="..\Microsoft.Extensions.Logging.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Extensions.Primitives" publicKeyToken="adb9793829ddae60" culture="neutral" />
+          <codeBase version="8.0.0.0" href="..\Microsoft.Extensions.Primitives.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.VisualStudio.Utilities.Internal" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <codeBase version="14.0.0.0" href="..\Microsoft.VisualStudio.Utilities.Internal.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Extensions.Diagnostics.Abstractions" publicKeyToken="adb9793829ddae60" culture="neutral" />
+          <codeBase version="8.0.0.0" href="..\Microsoft.Extensions.Diagnostics.Abstractions.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Extensions.Options.ConfigurationExtensions" publicKeyToken="adb9793829ddae60" culture="neutral" />
+          <codeBase version="8.0.0.0" href="..\Microsoft.Extensions.Options.ConfigurationExtensions.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Extensions.Options" publicKeyToken="adb9793829ddae60" culture="neutral" />
+          <codeBase version="8.0.0.0" href="..\Microsoft.Extensions.Options.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Newtonsoft.Json" publicKeyToken="30ad4fe6b2a6aeed" culture="neutral" />
+          <codeBase version="13.0.0.0" href="..\Newtonsoft.Json.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="OpenTelemetry" publicKeyToken="7bd6737fe5b67e3c" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\OpenTelemetry.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="OpenTelemetry.Api" publicKeyToken="7bd6737fe5b67e3c" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\OpenTelemetry.Api.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="OpenTelemetry.Api.ProviderBuilderExtensions" publicKeyToken="7bd6737fe5b67e3c" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\OpenTelemetry.Api.ProviderBuilderExtensions.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -103,18 +200,18 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Reflection.Metadata.dll" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Reflection.Metadata.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.MetadataLoadContext" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Reflection.MetadataLoadContext.dll" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Reflection.MetadataLoadContext.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Resources.Extensions.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Resources.Extensions.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -123,23 +220,23 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Text.Encodings.Web.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Text.Encodings.Web.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.5" newVersion="8.0.0.5" />
-          <codeBase version="8.0.0.5" href="..\System.Text.Json.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Text.Json.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Channels" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Threading.Channels.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Threading.Channels.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Threading.Tasks.Dataflow.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Threading.Tasks.Dataflow.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index ae0e56f3811..5aa6fe4fa41 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -33,6 +33,14 @@
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Bcl.HashCode" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Extensions.Primitives" publicKeyToken="adb9793829ddae60" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
@@ -54,7 +62,19 @@
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Formats.Nrbf" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.IO.Pipelines" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Diagnostics.DiagnosticSource" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -66,15 +86,15 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.MetadataLoadContext" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -82,15 +102,15 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.5" newVersion="8.0.0.5" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index da3dae7bf0f..a189f58567a 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
        a .props file that prevents building the project from doing much of anything. -->
@@ -70,6 +70,7 @@
       <Link>CopyOnWriteDictionary.cs</Link>
     </Compile>
     <Compile Include="..\Shared\Constants.cs" />
+    <Compile Include="..\Shared\EnvironmentUtilities.cs" Link="EnvironmentUtilities.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
     <Compile Include="..\Framework\ErrorUtilities.cs">
       <Link>ErrorUtilities.cs</Link>
diff --git a/src/MSBuildTaskHost/OutOfProcTaskHost.cs b/src/MSBuildTaskHost/OutOfProcTaskHost.cs
index 0998734f9ce..90a7970b5e7 100644
--- a/src/MSBuildTaskHost/OutOfProcTaskHost.cs
+++ b/src/MSBuildTaskHost/OutOfProcTaskHost.cs
@@ -90,8 +90,8 @@ internal static ExitType Execute()
 #endif
                 case "2":
                     // Sometimes easier to attach rather than deal with JIT prompt
-                    Process currentProcess = Process.GetCurrentProcess();
-                    Console.WriteLine($"Waiting for debugger to attach ({currentProcess.MainModule.FileName} PID {currentProcess.Id}).  Press enter to continue...");
+                    Console.WriteLine($"Waiting for debugger to attach ({EnvironmentUtilities.ProcessPath} PID {EnvironmentUtilities.CurrentProcessId}).  Press enter to continue...");
+
                     Console.ReadLine();
                     break;
             }
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index fcd8630dbd6..3330195df6e 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -39,9 +39,12 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)BuildXL.Native.dll
   file source=$(X86BinPath)BuildXL.Processes.dll
   file source=$(X86BinPath)BuildXL.Utilities.Core.dll
-  file source=$(X86BinPath)Microsoft.VisualStudio.SolutionPersistence.dll
+  file source=$(X86BinPath)Microsoft.VisualStudio.SolutionPersistence.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)RuntimeContracts.dll
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Diagnostics.DiagnosticSource.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Formats.Nrbf.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.IO.Pipelines.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Reflection.Metadata.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
@@ -56,6 +59,7 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Bcl.HashCode.dll
   file source=$(X86BinPath)Microsoft.NET.StringTools.dll vs.file.ngenArchitecture=all
   file source=$(TaskHostBinPath)Microsoft.NET.StringTools.net35.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
@@ -86,6 +90,25 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.ServiceModel.targets
   file source=$(X86BinPath)Microsoft.WinFx.targets
   file source=$(X86BinPath)Microsoft.WorkflowBuildExtensions.targets
+  file source=$(X86BinPath)Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.VisualStudio.OpenTelemetry.Collector.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.VisualStudio.Utilities.Internal.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)OpenTelemetry.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)OpenTelemetry.Api.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)OpenTelemetry.Api.ProviderBuilderExtensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Extensions.Configuration.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Extensions.Configuration.Binder.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Extensions.Configuration.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Extensions.DependencyInjection.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Extensions.DependencyInjection.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Extensions.Logging.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Extensions.Logging.Configuration.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Extensions.Logging.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Extensions.Options.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Extensions.Options.ConfigurationExtensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Extensions.Primitives.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Extensions.Diagnostics.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Newtonsoft.Json.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
 
 folder InstallDir:\MSBuild\Current\Bin\MSBuild
   file source=$(X86BinPath)\MSBuild\Microsoft.Build.Core.xsd
@@ -189,6 +212,8 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Formats.Nrbf.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.IO.Pipelines.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Reflection.Metadata.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenArchitecture=all
@@ -199,10 +224,11 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.ValueTuple.dll
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Resources.Extensions.dll
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.Bcl.HashCode.dll
   file source=$(X86BinPath)Microsoft.NET.StringTools.dll vs.file.ngenArchitecture=all
   file source=$(TaskHostBinPath)Microsoft.NET.StringTools.net35.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
diff --git a/src/Package/Microsoft.Build.UnGAC/Program.cs b/src/Package/Microsoft.Build.UnGAC/Program.cs
index d686da3dc75..a13f518146d 100644
--- a/src/Package/Microsoft.Build.UnGAC/Program.cs
+++ b/src/Package/Microsoft.Build.UnGAC/Program.cs
@@ -32,6 +32,8 @@ private static void Main(string[] args)
                     "BuildXL.Utilities.Core, Version=1.0.0.0",
                     "BuildXL.Native, Version=1.0.0.0",
                     "Microsoft.VisualStudio.SolutionPersistence, Version=1.0.0.0",
+                    "Microsoft.VisualStudio.OpenTelemetry.ClientExtensions, Version=0.1.0.0",
+                    "Microsoft.VisualStudio.OpenTelemetry.Collector, Version=0.1.0.0",
                 };
 
                 uint hresult = NativeMethods.CreateAssemblyCache(out IAssemblyCache assemblyCache, 0);
diff --git a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
index 5ba08499c68..f1c67c65ad0 100644
--- a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
+++ b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
@@ -13,6 +13,6 @@
   </ItemGroup>
   <ItemGroup>
     <PackageReference Include="Shouldly" Version="4.2.1" />
-    <PackageReference Include="System.Net.Http" Version="4.3.4" />
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 </Project>
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
index 7990d261f93..9078401ba2f 100644
--- a/src/Shared/BinaryReaderExtensions.cs
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -125,5 +125,20 @@ public static void ReadExtendedBuildEventData(this BinaryReader reader, IExtende
                 data.ExtendedMetadata = null;
             }
         }
+
+        public static Dictionary<string, TimeSpan> ReadDurationDictionary(this BinaryReader reader)
+        {
+            int count = reader.Read7BitEncodedInt();
+            var durations = new Dictionary<string, TimeSpan>(count);
+            for (int i = 0; i < count; i++)
+            {
+                string key = reader.ReadString();
+                TimeSpan value = TimeSpan.FromTicks(reader.ReadInt64());
+
+                durations.Add(key, value);
+            }
+
+            return durations;
+        }
     }
 }
diff --git a/src/Shared/BinaryWriterExtensions.cs b/src/Shared/BinaryWriterExtensions.cs
index 5f7a0046a6e..9cb458f4ec7 100644
--- a/src/Shared/BinaryWriterExtensions.cs
+++ b/src/Shared/BinaryWriterExtensions.cs
@@ -129,5 +129,15 @@ public static void WriteExtendedBuildEventData(this BinaryWriter writer, IExtend
                 }
             }
         }
+
+        public static void WriteDurationsDictionary(this BinaryWriter writer, Dictionary<string, TimeSpan> durations)
+        {
+            writer.Write7BitEncodedInt(durations.Count);
+            foreach (KeyValuePair<string, TimeSpan> kvp in durations)
+            {
+                writer.Write(kvp.Key);
+                writer.Write(kvp.Value.Ticks);
+            }
+        }
     }
 }
diff --git a/src/Shared/BufferedReadStream.cs b/src/Shared/BufferedReadStream.cs
index 783a9dde80f..55bba5986f8 100644
--- a/src/Shared/BufferedReadStream.cs
+++ b/src/Shared/BufferedReadStream.cs
@@ -3,6 +3,12 @@
 
 using System;
 using System.IO;
+using System.IO.Pipes;
+using System.Threading;
+
+#if NET451_OR_GREATER || NETCOREAPP
+using System.Threading.Tasks;
+#endif
 
 #nullable disable
 
@@ -11,14 +17,14 @@ namespace Microsoft.Build.BackEnd
     internal class BufferedReadStream : Stream
     {
         private const int BUFFER_SIZE = 1024;
-        private Stream _innerStream;
+        private NamedPipeServerStream _innerStream;
         private byte[] _buffer;
 
         // The number of bytes in the buffer that have been read from the underlying stream but not read by consumers of this stream
         private int _currentlyBufferedByteCount;
         private int _currentIndexInBuffer;
 
-        public BufferedReadStream(Stream innerStream)
+        public BufferedReadStream(NamedPipeServerStream innerStream)
         {
             _innerStream = innerStream;
             _buffer = new byte[BUFFER_SIZE];
@@ -120,6 +126,62 @@ public override int Read(byte[] buffer, int offset, int count)
             }
         }
 
+#if NET451_OR_GREATER || NETCOREAPP
+        public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
+        {
+            if (count > BUFFER_SIZE)
+            {
+                // Trying to read more data than the buffer can hold
+                int alreadyCopied = CopyToBuffer(buffer, offset);
+
+#pragma warning disable CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+                int innerReadCount = await _innerStream.ReadAsync(buffer, offset + alreadyCopied, count - alreadyCopied, cancellationToken);
+#pragma warning restore CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+                return innerReadCount + alreadyCopied;
+            }
+            else if (count <= _currentlyBufferedByteCount)
+            {
+                // Enough data buffered to satisfy read request
+                Array.Copy(_buffer, _currentIndexInBuffer, buffer, offset, count);
+                _currentIndexInBuffer += count;
+                _currentlyBufferedByteCount -= count;
+                return count;
+            }
+            else
+            {
+                // Need to read more data
+                int alreadyCopied = CopyToBuffer(buffer, offset);
+
+#pragma warning disable CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+                int innerReadCount = await _innerStream.ReadAsync(_buffer, 0, BUFFER_SIZE, cancellationToken);
+#pragma warning restore CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+                _currentIndexInBuffer = 0;
+                _currentlyBufferedByteCount = innerReadCount;
+
+                int remainingCopyCount = alreadyCopied + innerReadCount >= count ? count - alreadyCopied : innerReadCount;
+                Array.Copy(_buffer, 0, buffer, offset + alreadyCopied, remainingCopyCount);
+                _currentIndexInBuffer += remainingCopyCount;
+                _currentlyBufferedByteCount -= remainingCopyCount;
+
+                return alreadyCopied + remainingCopyCount;
+            }
+
+            int CopyToBuffer(byte[] buffer, int offset)
+            {
+                int alreadyCopied = 0;
+                if (_currentlyBufferedByteCount > 0)
+                {
+                    Array.Copy(_buffer, _currentIndexInBuffer, buffer, offset, _currentlyBufferedByteCount);
+                    alreadyCopied = _currentlyBufferedByteCount;
+                    _currentIndexInBuffer = 0;
+                    _currentlyBufferedByteCount = 0;
+                }
+
+                return alreadyCopied;
+            }
+        }
+#endif
+
         public override long Seek(long offset, SeekOrigin origin)
         {
             throw new NotSupportedException();
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 2f3dce9f66b..c3615e4acf6 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -431,12 +431,13 @@ private static string GetProcessFromRunningProcess()
             // an unmanaged application (for example, using custom CLR hosting).
             if (AssemblyUtilities.EntryAssembly == null)
             {
-                return Process.GetCurrentProcess().MainModule.FileName;
+                return EnvironmentUtilities.ProcessPath;
             }
 
             return AssemblyUtilities.GetAssemblyLocation(AssemblyUtilities.EntryAssembly);
 #else
-            return Process.GetCurrentProcess().MainModule.FileName;
+
+            return EnvironmentUtilities.ProcessPath;
 #endif
         }
 
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index d9d361df7ba..12061206c4d 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -108,7 +108,8 @@ protected internal Handshake(HandshakeOptions nodeType)
             fileVersionMinor = fileVersion.Minor;
             fileVersionBuild = fileVersion.Build;
             fileVersionPrivate = fileVersion.Revision;
-            sessionId = Process.GetCurrentProcess().SessionId;
+            using Process currentProcess = Process.GetCurrentProcess();
+            sessionId = currentProcess.SessionId;
         }
 
         // This is used as a key, so it does not need to be human readable.
@@ -539,26 +540,21 @@ internal static int ReadIntForHandshake(this PipeStream stream, byte? byteToAcce
             else
 #endif
             {
-                // Legacy approach with an early-abort for connection attempts from ancient MSBuild.exes
-                for (int i = 0; i < bytes.Length; i++)
-                {
-                    int read = stream.ReadByte();
+                int bytesRead = stream.Read(bytes, 0, bytes.Length);
 
-                    if (read == -1)
-                    {
-                        // We've unexpectly reached end of stream.
-                        // We are now in a bad state, disconnect on our end
-                        throw new IOException(String.Format(CultureInfo.InvariantCulture, "Unexpected end of stream while reading for handshake"));
-                    }
-
-                    bytes[i] = Convert.ToByte(read);
+                // Abort for connection attempts from ancient MSBuild.exes
+                if (byteToAccept != null && bytesRead > 0 && byteToAccept != bytes[0])
+                {
+                    stream.WriteIntForHandshake(0x0F0F0F0F);
+                    stream.WriteIntForHandshake(0x0F0F0F0F);
+                    throw new InvalidOperationException(String.Format(CultureInfo.InvariantCulture, "Client: rejected old host. Received byte {0} instead of {1}.", bytes[0], byteToAccept));
+                }
 
-                    if (i == 0 && byteToAccept != null && byteToAccept != bytes[0])
-                    {
-                        stream.WriteIntForHandshake(0x0F0F0F0F);
-                        stream.WriteIntForHandshake(0x0F0F0F0F);
-                        throw new InvalidOperationException(String.Format(CultureInfo.InvariantCulture, "Client: rejected old host. Received byte {0} instead of {1}.", bytes[0], byteToAccept));
-                    }
+                if (bytesRead != bytes.Length)
+                {
+                    // We've unexpectly reached end of stream.
+                    // We are now in a bad state, disconnect on our end
+                    throw new IOException(String.Format(CultureInfo.InvariantCulture, "Unexpected end of stream while reading for handshake"));
                 }
             }
 
@@ -836,7 +832,7 @@ private static void TraceCore(int nodeId, string message)
                     fileName += ".txt";
 
                     using (StreamWriter file = FileUtilities.OpenWrite(
-                        String.Format(CultureInfo.CurrentCulture, Path.Combine(s_debugDumpPath, fileName), Process.GetCurrentProcess().Id, nodeId), append: true))
+                        string.Format(CultureInfo.CurrentCulture, Path.Combine(s_debugDumpPath, fileName), EnvironmentUtilities.CurrentProcessId, nodeId), append: true))
                     {
                         long now = DateTime.UtcNow.Ticks;
                         float millisecondsSinceLastLog = (float)(now - s_lastLoggedTicks) / 10000L;
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 1139c492224..e435d354935 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -144,6 +144,7 @@ internal static class PropertyNames
         internal const string InnerBuildPropertyValues = nameof(InnerBuildPropertyValues);
         internal const string TargetFrameworks = nameof(TargetFrameworks);
         internal const string TargetFramework = nameof(TargetFramework);
+        internal const string UsingMicrosoftNETSdk = nameof(UsingMicrosoftNETSdk);
     }
 
     // TODO: Remove these when VS gets updated to setup project cache plugins.
@@ -209,6 +210,7 @@ internal static class ItemMetadataNames
         internal const string withCulture = "WithCulture";
         internal const string copyToOutputDirectory = "CopyToOutputDirectory";
         internal const string copyAlways = "Always";
+        internal const string managed = "Managed";
 
         /// <summary>
         /// The output path for a given item.
@@ -249,5 +251,6 @@ internal static class ItemNames
         internal const string EmbeddedResource = "EmbeddedResource";
         internal const string None = "None";
         internal const string Reference = "Reference";
+        internal const string ProjectCapability = "ProjectCapability";
     }
 }
diff --git a/src/Shared/Debugging/DebugUtils.cs b/src/Shared/Debugging/DebugUtils.cs
index de83a6de360..ed9da076678 100644
--- a/src/Shared/Debugging/DebugUtils.cs
+++ b/src/Shared/Debugging/DebugUtils.cs
@@ -92,13 +92,13 @@ private static bool CurrentProcessMatchesDebugName()
         {
             var processNameToBreakInto = Environment.GetEnvironmentVariable("MSBuildDebugProcessName");
             var thisProcessMatchesName = string.IsNullOrWhiteSpace(processNameToBreakInto) ||
-                                         Process.GetCurrentProcess().ProcessName.Contains(processNameToBreakInto);
+                                         EnvironmentUtilities.ProcessName.Contains(processNameToBreakInto);
 
             return thisProcessMatchesName;
         }
 
         public static readonly string ProcessInfoString =
-            $"{ProcessNodeMode.Value}_{Process.GetCurrentProcess().ProcessName}_PID={Process.GetCurrentProcess().Id}_x{(Environment.Is64BitProcess ? "64" : "86")}";
+            $"{ProcessNodeMode.Value}_{EnvironmentUtilities.ProcessName}_PID={EnvironmentUtilities.CurrentProcessId}_x{(Environment.Is64BitProcess ? "64" : "86")}";
 
         public static readonly bool ShouldDebugCurrentProcess = CurrentProcessMatchesDebugName();
 
diff --git a/src/Shared/EnvironmentUtilities.cs b/src/Shared/EnvironmentUtilities.cs
index 3b275ef40b5..b64e792b53d 100644
--- a/src/Shared/EnvironmentUtilities.cs
+++ b/src/Shared/EnvironmentUtilities.cs
@@ -1,17 +1,100 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#nullable enable
+
 using System;
+using System.Diagnostics;
 using System.Runtime.InteropServices;
+using System.Threading;
 
 namespace Microsoft.Build.Shared
 {
     internal static partial class EnvironmentUtilities
     {
+#if NET472_OR_GREATER || NETCOREAPP
         public static bool Is64BitProcess => Marshal.SizeOf<IntPtr>() == 8;
 
         public static bool Is64BitOperatingSystem =>
             Environment.Is64BitOperatingSystem;
+#endif
+
+#if !NETCOREAPP
+        private static volatile int s_processId;
+        private static volatile string? s_processPath;
+#endif
+        private static volatile string? s_processName;
+
+        /// <summary>Gets the unique identifier for the current process.</summary>
+        public static int CurrentProcessId
+        {
+            get
+            {
+#if NETCOREAPP
+                return Environment.ProcessId;
+#else
+                // copied from Environment.ProcessId
+                int processId = s_processId;
+                if (processId == 0)
+                {
+                    using Process currentProcess = Process.GetCurrentProcess();
+                    s_processId = processId = currentProcess.Id;
+
+                    // Assume that process Id zero is invalid for user processes. It holds for all mainstream operating systems.
+                    Debug.Assert(processId != 0);
+                }
+
+                return processId;
+#endif
+            }
+        }
+
+        /// <summary>
+        /// Returns the path of the executable that started the currently executing process. Returns null when the path is not available.
+        /// </summary>
+        /// <returns>Path of the executable that started the currently executing process</returns>
+        /// <remarks>
+        /// If the executable is renamed or deleted before this property is first accessed, the return value is undefined and depends on the operating system.
+        /// </remarks>
+        public static string? ProcessPath
+        {
+            get
+            {
+#if NETCOREAPP
+                return Environment.ProcessPath;
+#else
+                // copied from Environment.ProcessPath
+                string? processPath = s_processPath;
+                if (processPath == null)
+                {
+                    // The value is cached both as a performance optimization and to ensure that the API always returns
+                    // the same path in a given process.
+                    using Process currentProcess = Process.GetCurrentProcess();
+                    Interlocked.CompareExchange(ref s_processPath, currentProcess.MainModule.FileName ?? "", null);
+                    processPath = s_processPath;
+                    Debug.Assert(processPath != null);
+                }
+
+                return (processPath?.Length != 0) ? processPath : null;
+#endif
+            }
+        }
+
+        public static string ProcessName
+        {
+            get
+            {
+                string? processName = s_processName;
+                if (processName == null)
+                {
+                    using Process currentProcess = Process.GetCurrentProcess();
+                    Interlocked.CompareExchange(ref s_processName, currentProcess.ProcessName, null);
+                    processName = s_processName;
+                }
+
+                return processName;
+            }
+        }
 
         public static bool IsWellKnownEnvironmentDerivedProperty(string propertyName)
         {
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index bfce3376e3e..16a19dcadc2 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -352,7 +352,7 @@ internal static void DumpExceptionToFile(Exception ex)
                         // because we're a child node with no console to log to, so die
                         Directory.CreateDirectory(DebugDumpPath);
 
-                        var pid = Process.GetCurrentProcess().Id;
+                        var pid = EnvironmentUtilities.CurrentProcessId;
                         // This naming pattern is assumed in ReadAnyExceptionFromFile
                         s_dumpFileName = Path.Combine(DebugDumpPath, $"MSBuild_pid-{pid}_{guid:n}.failure.txt");
 
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index bbb4413632e..82d4f55b354 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -128,7 +128,7 @@ internal static string GetCacheDirectory()
         {
             if (cacheDirectory == null)
             {
-                cacheDirectory = Path.Combine(TempFileDirectory, String.Format(CultureInfo.CurrentUICulture, "MSBuild{0}-{1}", Process.GetCurrentProcess().Id, AppDomain.CurrentDomain.Id));
+                cacheDirectory = Path.Combine(TempFileDirectory, string.Format(CultureInfo.CurrentUICulture, "MSBuild{0}-{1}", EnvironmentUtilities.CurrentProcessId, AppDomain.CurrentDomain.Id));
             }
 
             return cacheDirectory;
@@ -182,7 +182,7 @@ internal static bool CanWriteToDirectory(string directory)
                 string testFilePath = Path.Combine(directory, $"MSBuild_{Guid.NewGuid().ToString("N")}_testFile.txt");
                 FileInfo file = new(testFilePath);
                 file.Directory.Create(); // If the directory already exists, this method does nothing.
-                File.WriteAllText(testFilePath, $"MSBuild process {Process.GetCurrentProcess().Id} successfully wrote to file.");
+                File.WriteAllText(testFilePath, $"MSBuild process {EnvironmentUtilities.CurrentProcessId} successfully wrote to file.");
                 File.Delete(testFilePath);
                 return true;
             }
@@ -752,14 +752,20 @@ internal static bool HasExtension(string fileName, string[] allowedExtensions)
         /// </summary>
         /// <param name="fileSpec">The file spec to get the full path of.</param>
         /// <param name="currentDirectory"></param>
-        /// <returns>full path</returns>
-        internal static string GetFullPath(string fileSpec, string currentDirectory)
+        /// <param name="escape">Whether to escape the path after getting the full path.</param>
+        /// <returns>Full path to the file, escaped if not specified otherwise.</returns>
+        internal static string GetFullPath(string fileSpec, string currentDirectory, bool escape = true)
         {
             // Sending data out of the engine into the filesystem, so time to unescape.
             fileSpec = FixFilePath(EscapingUtilities.UnescapeAll(fileSpec));
 
-            // Data coming back from the filesystem into the engine, so time to escape it back.
-            string fullPath = EscapingUtilities.Escape(NormalizePath(Path.Combine(currentDirectory, fileSpec)));
+            string fullPath = NormalizePath(Path.Combine(currentDirectory, fileSpec));
+            // In some cases we might want to NOT escape in order to preserve symbols like @, %, $ etc.
+            if (escape)
+            {
+                // Data coming back from the filesystem into the engine, so time to escape it back.
+                fullPath = EscapingUtilities.Escape(fullPath);
+            }
 
             if (NativeMethodsShared.IsWindows && !EndsWithSlash(fullPath))
             {
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index b0b620ad68a..2bc28819c6e 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -1390,6 +1390,7 @@ public virtual string GetPathToDotNetFramework(DotNetFrameworkArchitecture archi
                 // Assume if either MSBuild.exe or Microsoft.Build.dll are shipped, there is a valid install.
                 // Note: net481 did not ship an ARM64 MSBuild.exe, so checking its dll's is the fallback for a valid install.
                 // Context: https://github.com/dotnet/msbuild/pull/7689
+                // Rollback see https://developercommunity.visualstudio.com/t/Unable-to-locate-MSBuild-path-with-Lates/10824132 
                 if (this._hasMsBuild &&
                     generatedPathToDotNetFramework != null &&
                     (!File.Exists(Path.Combine(generatedPathToDotNetFramework, NativeMethodsShared.IsWindows ? "MSBuild.exe" : "mcs.exe")) &&
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 650b62c2a1b..36e8e9db0df 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -249,6 +249,11 @@ internal enum LoggingEventType : int
         /// Event is <see cref="BuildCanceledEventArgs"/>
         /// </summary>
         BuildCanceledEvent = 41,
+
+        /// <summary>
+        /// Event is <see cref="WorkerNodeTelemetryEventArgs"/>
+        /// </summary>
+        WorkerNodeTelemetryEvent = 42,
     }
     #endregion
 
@@ -275,23 +280,6 @@ internal abstract class LogMessagePacketBase : INodePacket
         /// </summary>
         private static Dictionary<LoggingEventType, MethodInfo> s_writeMethodCache = new Dictionary<LoggingEventType, MethodInfo>();
 
-        /// <summary>
-        /// Dictionary of assemblies we've added to the resolver.
-        /// </summary>
-        private static HashSet<string> s_customEventsLoaded = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
-
-#if FEATURE_APPDOMAIN
-        /// <summary>
-        /// The resolver used to load custom event types.
-        /// </summary>
-        private static TaskEngineAssemblyResolver s_resolver;
-#endif
-
-        /// <summary>
-        /// The object used to synchronize access to shared data.
-        /// </summary>
-        private static object s_lockObject = new Object();
-
         /// <summary>
         /// Delegate for translating targetfinished events.
         /// </summary>
@@ -421,25 +409,25 @@ public void Translate(ITranslator translator)
         /// </summary>
         internal void WriteToStream(ITranslator translator)
         {
-            if (_eventType != LoggingEventType.CustomEvent)
+            ErrorUtilities.VerifyThrow(_eventType != LoggingEventType.CustomEvent, "_eventType should not be a custom event");
+
+            MethodInfo methodInfo = null;
+            lock (s_writeMethodCache)
             {
-                MethodInfo methodInfo = null;
-                lock (s_writeMethodCache)
+                if (!s_writeMethodCache.TryGetValue(_eventType, out methodInfo))
                 {
-                    if (!s_writeMethodCache.TryGetValue(_eventType, out methodInfo))
-                    {
-                        Type eventDerivedType = _buildEvent.GetType();
-                        methodInfo = eventDerivedType.GetMethod("WriteToStream", BindingFlags.NonPublic | BindingFlags.Instance);
-                        s_writeMethodCache.Add(_eventType, methodInfo);
-                    }
+                    Type eventDerivedType = _buildEvent.GetType();
+                    methodInfo = eventDerivedType.GetMethod("WriteToStream", BindingFlags.NonPublic | BindingFlags.Instance);
+                    s_writeMethodCache.Add(_eventType, methodInfo);
                 }
+            }
 
-                int packetVersion = s_defaultPacketVersion;
+            int packetVersion = s_defaultPacketVersion;
 
-                // Make sure the other side knows what sort of serialization is coming
-                translator.Translate(ref packetVersion);
+            // Make sure the other side knows what sort of serialization is coming
+            translator.Translate(ref packetVersion);
 
-                bool eventCanSerializeItself = methodInfo != null;
+            bool eventCanSerializeItself = methodInfo != null;
 
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
                 if (_buildEvent is ProjectEvaluationStartedEventArgs
@@ -452,34 +440,22 @@ or ProjectEvaluationFinishedEventArgs
                 }
 #endif
 
-                translator.Translate(ref eventCanSerializeItself);
+            translator.Translate(ref eventCanSerializeItself);
 
-                if (eventCanSerializeItself)
-                {
-                    // 3.5 or later -- we have custom serialization methods, so let's use them.
-                    ArgsWriterDelegate writerMethod = (ArgsWriterDelegate)CreateDelegateRobust(typeof(ArgsWriterDelegate), _buildEvent, methodInfo);
-                    writerMethod(translator.Writer);
+            if (eventCanSerializeItself)
+            {
+                // 3.5 or later -- we have custom serialization methods, so let's use them.
+                ArgsWriterDelegate writerMethod = (ArgsWriterDelegate)CreateDelegateRobust(typeof(ArgsWriterDelegate), _buildEvent, methodInfo);
+                writerMethod(translator.Writer);
 
-                    if (_eventType == LoggingEventType.TargetFinishedEvent && _targetFinishedTranslator != null)
-                    {
-                        _targetFinishedTranslator(translator, (TargetFinishedEventArgs)_buildEvent);
-                    }
-                }
-                else
+                if (_eventType == LoggingEventType.TargetFinishedEvent && _targetFinishedTranslator != null)
                 {
-                    WriteEventToStream(_buildEvent, _eventType, translator);
+                    _targetFinishedTranslator(translator, (TargetFinishedEventArgs)_buildEvent);
                 }
             }
             else
             {
-#if FEATURE_ASSEMBLY_LOCATION
-                string assemblyLocation = _buildEvent.GetType().GetTypeInfo().Assembly.Location;
-                translator.Translate(ref assemblyLocation);
-#else
-                string assemblyName = _buildEvent.GetType().GetTypeInfo().Assembly.FullName;
-                translator.Translate(ref assemblyName);
-#endif
-                translator.TranslateDotNet(ref _buildEvent);
+                WriteEventToStream(_buildEvent, _eventType, translator);
             }
         }
 
@@ -488,89 +464,44 @@ or ProjectEvaluationFinishedEventArgs
         /// </summary>
         internal void ReadFromStream(ITranslator translator)
         {
-            if (LoggingEventType.CustomEvent != _eventType)
-            {
-                _buildEvent = GetBuildEventArgFromId();
+            ErrorUtilities.VerifyThrow(_eventType != LoggingEventType.CustomEvent, "_eventType should not be a custom event");
 
-                // The other side is telling us whether the event knows how to log itself, or whether we're going to have
-                // to do it manually
-                int packetVersion = s_defaultPacketVersion;
-                translator.Translate(ref packetVersion);
+            _buildEvent = GetBuildEventArgFromId();
 
-                bool eventCanSerializeItself = true;
-                translator.Translate(ref eventCanSerializeItself);
+            // The other side is telling us whether the event knows how to log itself, or whether we're going to have
+            // to do it manually
+            int packetVersion = s_defaultPacketVersion;
+            translator.Translate(ref packetVersion);
 
-                if (eventCanSerializeItself)
-                {
-                    MethodInfo methodInfo = null;
-                    lock (s_readMethodCache)
-                    {
-                        if (!s_readMethodCache.TryGetValue(_eventType, out methodInfo))
-                        {
-                            Type eventDerivedType = _buildEvent.GetType();
-                            methodInfo = eventDerivedType.GetMethod("CreateFromStream", BindingFlags.NonPublic | BindingFlags.Instance);
-                            s_readMethodCache.Add(_eventType, methodInfo);
-                        }
-                    }
+            bool eventCanSerializeItself = true;
+            translator.Translate(ref eventCanSerializeItself);
 
-                    ArgsReaderDelegate readerMethod = (ArgsReaderDelegate)CreateDelegateRobust(typeof(ArgsReaderDelegate), _buildEvent, methodInfo);
-
-                    readerMethod(translator.Reader, packetVersion);
-                    if (_eventType == LoggingEventType.TargetFinishedEvent && _targetFinishedTranslator != null)
-                    {
-                        _targetFinishedTranslator(translator, (TargetFinishedEventArgs)_buildEvent);
-                    }
-                }
-                else
-                {
-                    _buildEvent = ReadEventFromStream(_eventType, translator);
-                    ErrorUtilities.VerifyThrow(_buildEvent is not null, "Not Supported LoggingEventType {0}", _eventType.ToString());
-                }
-            }
-            else
+            if (eventCanSerializeItself)
             {
-                string fileLocation = null;
-                translator.Translate(ref fileLocation);
-
-                bool resolveAssembly = false;
-                lock (s_lockObject)
+                MethodInfo methodInfo = null;
+                lock (s_readMethodCache)
                 {
-                    if (!s_customEventsLoaded.Contains(fileLocation))
-                    {
-                        resolveAssembly = true;
-                    }
-
-                    // If we are to resolve the assembly add it to the list of assemblies resolved
-                    if (resolveAssembly)
+                    if (!s_readMethodCache.TryGetValue(_eventType, out methodInfo))
                     {
-                        s_customEventsLoaded.Add(fileLocation);
+                        Type eventDerivedType = _buildEvent.GetType();
+                        methodInfo = eventDerivedType.GetMethod("CreateFromStream", BindingFlags.NonPublic | BindingFlags.Instance);
+                        s_readMethodCache.Add(_eventType, methodInfo);
                     }
                 }
 
-#if FEATURE_APPDOMAIN
-                if (resolveAssembly)
-                {
-                    s_resolver = new TaskEngineAssemblyResolver();
-                    s_resolver.InstallHandler();
-                    s_resolver.Initialize(fileLocation);
-                }
-#endif
+                ArgsReaderDelegate readerMethod = (ArgsReaderDelegate)CreateDelegateRobust(typeof(ArgsReaderDelegate), _buildEvent, methodInfo);
 
-                try
+                readerMethod(translator.Reader, packetVersion);
+                if (_eventType == LoggingEventType.TargetFinishedEvent && _targetFinishedTranslator != null)
                 {
-                    translator.TranslateDotNet(ref _buildEvent);
-                }
-                finally
-                {
-#if FEATURE_APPDOMAIN
-                    if (resolveAssembly)
-                    {
-                        s_resolver.RemoveHandler();
-                        s_resolver = null;
-                    }
-#endif
+                    _targetFinishedTranslator(translator, (TargetFinishedEventArgs)_buildEvent);
                 }
             }
+            else
+            {
+                _buildEvent = ReadEventFromStream(_eventType, translator);
+                ErrorUtilities.VerifyThrow(_buildEvent is not null, "Not Supported LoggingEventType {0}", _eventType.ToString());
+            }
 
             _eventType = GetLoggingEventId(_buildEvent);
         }
@@ -662,6 +593,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
                 LoggingEventType.BuildSubmissionStartedEvent => new BuildSubmissionStartedEventArgs(),
                 LoggingEventType.BuildCanceledEvent => new BuildCanceledEventArgs("Build canceled."),
+                LoggingEventType.WorkerNodeTelemetryEvent => new WorkerNodeTelemetryEventArgs(),
 #endif
                 _ => throw new InternalErrorException("Should not get to the default of GetBuildEventArgFromId ID: " + _eventType)
             };
@@ -809,6 +741,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.BuildCanceledEvent;
             }
+            else if (eventType == typeof(WorkerNodeTelemetryEventArgs))
+            {
+                return LoggingEventType.WorkerNodeTelemetryEvent;
+            }
 #endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
diff --git a/src/Shared/NamedPipeUtil.cs b/src/Shared/NamedPipeUtil.cs
index 5c5290b40c8..bf31c0193f6 100644
--- a/src/Shared/NamedPipeUtil.cs
+++ b/src/Shared/NamedPipeUtil.cs
@@ -12,7 +12,7 @@ internal static string GetPlatformSpecificPipeName(int? processId = null)
         {
             if (processId is null)
             {
-                processId = Process.GetCurrentProcess().Id;
+                processId = EnvironmentUtilities.CurrentProcessId;
             }
 
             string pipeName = $"MSBuild{processId}";
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 7e8e8506a8c..70629ecf2d8 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -15,12 +15,11 @@
 using Microsoft.Build.Shared;
 #if FEATURE_SECURITY_PERMISSIONS || FEATURE_PIPE_SECURITY
 using System.Security.AccessControl;
-
 #endif
 #if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
 using System.Security.Principal;
 #endif
-#if !FEATURE_APM
+#if NET451_OR_GREATER || NETCOREAPP
 using System.Threading.Tasks;
 #endif
 
@@ -152,7 +151,7 @@ public LinkStatus LinkStatus
         public void Listen(INodePacketFactory factory)
         {
             ErrorUtilities.VerifyThrow(_status == LinkStatus.Inactive, "Link not inactive.  Status is {0}", _status);
-            ErrorUtilities.VerifyThrowArgumentNull(factory);
+            ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
             _packetFactory = factory;
 
             InitializeAsyncPacketThread();
@@ -314,7 +313,7 @@ private void InternalDisconnect()
         /// <param name="packet">The packet to be transmitted.</param>
         private void EnqueuePacket(INodePacket packet)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(packet);
+            ErrorUtilities.VerifyThrowArgumentNull(packet, nameof(packet));
             ErrorUtilities.VerifyThrow(_packetQueue != null, "packetQueue is null");
             ErrorUtilities.VerifyThrow(_packetAvailable != null, "packetAvailable is null");
             _packetQueue.Enqueue(packet);
@@ -511,7 +510,7 @@ private void PacketPumpProc()
             }
         }
 
-        private void RunReadLoop(Stream localReadPipe, Stream localWritePipe,
+        private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream localWritePipe,
             ConcurrentQueue<INodePacket> localPacketQueue, AutoResetEvent localPacketAvailable, AutoResetEvent localTerminatePacketPump)
         {
             // Ordering of the wait handles is important.  The first signalled wait handle in the array
@@ -520,27 +519,30 @@ private void RunReadLoop(Stream localReadPipe, Stream localWritePipe,
             // spammed to the endpoint and it never gets an opportunity to shutdown.
             CommunicationsUtilities.Trace("Entering read loop.");
             byte[] headerByte = new byte[5];
-#if FEATURE_APM
-            IAsyncResult result = localReadPipe.BeginRead(headerByte, 0, headerByte.Length, null, null);
-#else
+#if NET451_OR_GREATER
+            Task<int> readTask = localReadPipe.ReadAsync(headerByte, 0, headerByte.Length, CancellationToken.None);
+#elif NETCOREAPP
             Task<int> readTask = CommunicationsUtilities.ReadAsync(localReadPipe, headerByte, headerByte.Length);
+#else
+            IAsyncResult result = localReadPipe.BeginRead(headerByte, 0, headerByte.Length, null, null);
 #endif
 
-            bool exitLoop = false;
-            do
+            // Ordering is important.  We want packetAvailable to supercede terminate otherwise we will not properly wait for all
+            // packets to be sent by other threads which are shutting down, such as the logging thread.
+            WaitHandle[] handles = new WaitHandle[]
             {
-                // Ordering is important.  We want packetAvailable to supercede terminate otherwise we will not properly wait for all
-                // packets to be sent by other threads which are shutting down, such as the logging thread.
-                WaitHandle[] handles =
-                [
-#if FEATURE_APM
-                    result.AsyncWaitHandle,
+#if NET451_OR_GREATER || NETCOREAPP
+                ((IAsyncResult)readTask).AsyncWaitHandle,
 #else
-                    ((IAsyncResult)readTask).AsyncWaitHandle,
+                result.AsyncWaitHandle,
 #endif
-                    localPacketAvailable, localTerminatePacketPump
-                ];
+                localPacketAvailable,
+                localTerminatePacketPump,
+            };
 
+            bool exitLoop = false;
+            do
+            {
                 int waitId = WaitHandle.WaitAny(handles);
                 switch (waitId)
                 {
@@ -549,10 +551,10 @@ private void RunReadLoop(Stream localReadPipe, Stream localWritePipe,
                             int bytesRead = 0;
                             try
                             {
-#if FEATURE_APM
-                                bytesRead = localReadPipe.EndRead(result);
-#else
+#if NET451_OR_GREATER || NETCOREAPP
                                 bytesRead = readTask.Result;
+#else
+                                bytesRead = localReadPipe.EndRead(result);
 #endif
                             }
                             catch (Exception e)
@@ -593,7 +595,7 @@ private void RunReadLoop(Stream localReadPipe, Stream localWritePipe,
                                 break;
                             }
 
-                            NodePacketType packetType = (NodePacketType)Enum.ToObject(typeof(NodePacketType), headerByte[0]);
+                            NodePacketType packetType = (NodePacketType)headerByte[0];
 
                             try
                             {
@@ -609,10 +611,18 @@ private void RunReadLoop(Stream localReadPipe, Stream localWritePipe,
                                 break;
                             }
 
-#if FEATURE_APM
+#if NET451_OR_GREATER
+                            readTask = localReadPipe.ReadAsync(headerByte, 0, headerByte.Length, CancellationToken.None);
+#elif NETCOREAPP
+                            readTask = CommunicationsUtilities.ReadAsync(localReadPipe, headerByte, headerByte.Length);
+#else
                             result = localReadPipe.BeginRead(headerByte, 0, headerByte.Length, null, null);
+#endif
+
+#if NET451_OR_GREATER || NETCOREAPP
+                            handles[0] = ((IAsyncResult)readTask).AsyncWaitHandle;
 #else
-                            readTask = CommunicationsUtilities.ReadAsync(localReadPipe, headerByte, headerByte.Length);
+                            handles[0] = result.AsyncWaitHandle;
 #endif
                         }
 
@@ -675,8 +685,8 @@ private void RunReadLoop(Stream localReadPipe, Stream localWritePipe,
             while (!exitLoop);
         }
 
-        #endregion
+#endregion
 
-        #endregion
+#endregion
     }
 }
diff --git a/src/Shared/Resources/Strings.shared.resx b/src/Shared/Resources/Strings.shared.resx
index a4a6c77b65b..d9209007dd5 100644
--- a/src/Shared/Resources/Strings.shared.resx
+++ b/src/Shared/Resources/Strings.shared.resx
@@ -136,7 +136,7 @@
     <value>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</value>
   </data>
   <data name="DeprecatedEventSerialization" xml:space="preserve">
-    <value>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</value>
+    <value>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</value>
   </data>
   <data name="FileLocation" xml:space="preserve">
     <value>{0} ({1},{2})</value>
@@ -364,4 +364,4 @@
   <data name="CollectionCopyToFailureProvidedArrayIsTooSmall" xml:space="preserve">
     <value>The number of elements in the collection is greater than the available space in the destination array (when starting at the specified index).</value>
   </data>
-</root>
\ No newline at end of file
+</root>
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index 6112e7fc577..a26162270f6 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Použití nezabezpečeného BinaryFormatteru během serializace vlastního typu události {0}. Tento způsob bude brzy zastaralý. Místo toho prosím použijte Extended*EventArgs. Další informace najdete zde: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Vlastní typ události '{0}' se nepodporuje, protože všechny vlastní typy událostí jsou zastaralé. Použijte prosím místo toho Extended*EventArgs. Další informace: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index be05ce4a4ed..415beb539f4 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Verwendung eines unsicheren BinaryFormatter während der Serialisierung des benutzerdefinierten Ereignistyps '{0}'. Dies wird in Kürze eingestellt. Verwenden Sie stattdessen Extended*EventArgs. Weitere Informationen: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Der benutzerdefinierte Ereignistyp '{0}' wird nicht unterstützt, weil alle benutzerdefinierten Ereignistypen veraltet waren. Verwenden Sie stattdessen Extended*EventArgs. Weitere Informationen: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index f8c5d9b5028..3897e1e1701 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Uso de BinaryFormatter no seguro durante la serialización del tipo de evento personalizado "{0}". Esto estará en desuso pronto. En su lugar, use Extended*EventArgs. Más información: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">No se admite el tipo de evento personalizado '{0}' porque todos los tipos de eventos personalizados estaban en desuso. Use Extended*EventArgs en su lugar. Más información: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 89b1346466e..b5bf698e5e1 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Utilisation de BinaryFormatter non sécurisé lors de la sérialisation d’un type d’événement personnalisé '{0}'. Cette opération sera bientôt déconseillée. Utilisez Extended*EventArgs à la place. Plus d’informations : https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Le type d’événement personnalisé '{0}' n’est pas pris en charge, car tous les types d’événement personnalisés ont été dépréciés. Utilisez Extended*EventArgs à la place. Plus d’informations : https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index 943424a181a..04956ec3b05 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Utilizzo di BinaryFormatter non sicuro durante la serializzazione del tipo di evento personalizzato '{0}'. Questa operazione verrà presto deprecata. Usare invece Extended*EventArgs. Altre informazioni: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Il tipo di evento personalizzato '{0}' non è supportato perché tutti i tipi di evento personalizzati sono deprecati. Usare Invece Extended*EventArgs. Altre informazioni: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index e392ac1eff6..4d0c669cf9c 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">カスタム イベントの種類 '{0}' のシリアル化中のセキュリティで保護されていない BinaryFormatter の使用。これは間もなく非推奨になります。代わりに Extended*EventArgs を使用してください。詳細情報: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">カスタム イベントの種類 '{0}' は、すべてのカスタム イベントの種類が非推奨になったため、サポートされていません。代わりに Extended*EventArgs を使用してください。詳細情報: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index b03debaa45e..8248d487466 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">사용자 지정 이벤트 유형 '{0}'의 직렬화 중 보안되지 않은 BinaryFormatter 사용. 이 항목은 곧 지원 중단될 예정입니다. 대신 Extended*EventArgs를 사용하세요. 추가 정보: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">모든 사용자 지정 이벤트 유형이 사용되지 않으므로 사용자 지정 이벤트 유형 '{0}' 지원되지 않습니다. 대신 Extended*EventArgs를 사용하세요. 추가 정보: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index 6731c418bbc..9e29e409ee2 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Użycie niezabezpieczonego formatu BinaryFormatter podczas serializacji niestandardowego typu zdarzenia „{0}”. Wkrótce ta funkcja będzie przestarzała. Zamiast tego należy użyć Extended*EventArgs. Więcej informacji: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Niestandardowy typ zdarzenia '{0}' nie jest obsługiwany, ponieważ wszystkie typy zdarzeń niestandardowych były przestarzałe. Zamiast tego użyj elementu Extended*EventArgs. Więcej informacji: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index f8cc9843098..20ef67ae7bd 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Uso de BinaryFormatter não seguro durante a serialização do tipo de evento personalizado '{0}'. Isso será obsoleto em breve. Em vez disso, use Extended*EventArgs. Mais informações: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Não há suporte '{0}' tipo de evento personalizado porque todos os tipos de eventos personalizados foram preteridos. Use Extended*EventArgs em vez disso. Mais informações: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index bbffde258e5..c94516fc238 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">Использование небезопасного BinaryFormatter во время сериализации настраиваемого типа события "{0}". Скоро этот параметр станет нерекомендуемым. Вместо этого используйте Extended*EventArgs. Дополнительные сведения: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Настраиваемый тип '{0}' не поддерживается, так как все пользовательские типы событий устарели. Используйте extended*EventArgs. Дополнительные сведения: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index 72a139c0b26..6757424f8b9 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">'{0}' özel olay türünü serileştirme işlemi sırasında güvenli olmayan BinaryFormatter kullanımı. Bu özellik yakında kullanımdan kaldırılacak. Lütfen bunun yerine Extended*EventArgs özelliğini kullanın. Daha fazla bilgi: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">Tüm özel '{0}' türleri kullanım dışı bırakıldığinden özel olay türü türü desteklenmiyor. Lütfen bunun yerine Extended*EventArgs kullanın. Daha fazla bilgi: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index 8be5cf61c86..22864d30dde 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">在自定义事件类型“{0}”的序列化期间使用了不安全的 BinaryFormatter。这将很快被弃用。请改用 Extended*EventArgs。详细信息: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">不支持自定义事件类型 '{0}'，因为已弃用所有自定义事件类型。请改用 Extended*EventArgs。详细信息： https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index e08a6eea736..e6296025673 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -28,8 +28,8 @@
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
-        <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="translated">自訂事件類型 '{0}' 序列化期間使用不安全的 BinaryFormatter。即將取代此項目。請改用 Extended*EventArgs。更多資訊: https://aka.ms/msbuild/eventargs</target>
+        <source>Custom event type '{0}' is not supported as all custom event types were deprecated. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
+        <target state="translated">不支援自定義事件類型 '{0}'，因為所有自定義事件類型都已過時。請改用 Extended*EventArgs。更多資訊： https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/StringTools.Benchmark/StringTools.Benchmark.csproj b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
index 763be443c66..193a82a792b 100644
--- a/src/StringTools.Benchmark/StringTools.Benchmark.csproj
+++ b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
@@ -16,12 +16,6 @@
     <PackageReference Include="BenchmarkDotNet" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(DotNetBuildSourceOnly)' != 'true'">
-    <!-- Bump these to the latest version despite transitive references to older -->
-    <PackageReference Include="System.Private.Uri" />
-    <PackageReference Include="System.Runtime" />
-  </ItemGroup>
-
   <ItemGroup>
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
   </ItemGroup>
diff --git a/src/StringTools.UnitTests/StringTools.UnitTests.csproj b/src/StringTools.UnitTests/StringTools.UnitTests.csproj
index b48cd46cb93..0cb576f1675 100644
--- a/src/StringTools.UnitTests/StringTools.UnitTests.csproj
+++ b/src/StringTools.UnitTests/StringTools.UnitTests.csproj
@@ -12,7 +12,7 @@
 
   <ItemGroup>
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 26e53c59436..d79ac579d3d 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -79,11 +79,6 @@ public static IEnumerable<object[]> GetNullAndEmptyArrays() =>
             */
         };
 
-        private const int NoParallelismThreadCount = 1;
-        private const int DefaultParallelismThreadCount = int.MaxValue;
-
-        private int GetParallelismThreadCount(bool isUseSingleThreadedCopy) => isUseSingleThreadedCopy ? NoParallelismThreadCount : DefaultParallelismThreadCount;
-
         /// <summary>
         /// Temporarily save off the value of MSBUILDALWAYSOVERWRITEREADONLYFILES, so that we can run
         /// the tests isolated from the current state of the environment, but put it back how it belongs
@@ -509,7 +504,7 @@ public void DontCopyOverSameFile(bool isUseHardLinks, bool isUseSymbolicLinks, b
                     UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
-                t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy));
+                t.Execute(m.CopyFile, !isUseSingleThreadedCopy);
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -557,7 +552,7 @@ public void QuestionCopyFile(bool isUseHardLinks, bool isUseSymbolicLinks, bool
                     FailIfNotIncremental = true,
                 };
 
-                Assert.False(t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy)));
+                Assert.False(t.Execute(m.CopyFile, !isUseSingleThreadedCopy));
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -617,7 +612,7 @@ public void QuestionCopyFileSameContent(bool isUseHardLinks, bool isUseSymbolicL
                     SkipUnchangedFiles = true,
                     FailIfNotIncremental = true,
                 };
-                Assert.True(t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy)));
+                Assert.True(t.Execute(m.CopyFile, !isUseSingleThreadedCopy));
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -670,7 +665,7 @@ public void QuestionCopyFileNotSameContent(bool isUseHardLinks, bool isUseSymbol
                     FailIfNotIncremental = true,
                 };
 
-                Assert.False(t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy)));
+                Assert.False(t.Execute(m.CopyFile, !isUseSingleThreadedCopy));
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -2015,7 +2010,7 @@ public void CopyWithDuplicatesUsingFolder(bool isUseHardLinks, bool isUseSymboli
                     filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));
                 }
                 return true;
-            }, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            }, !isUseSingleThreadedCopy);
 
             Assert.True(success);
             Assert.Equal(2, filesActuallyCopied.Count);
@@ -2082,7 +2077,7 @@ public void CopyWithDuplicatesUsingFiles(bool isUseHardLinks, bool isUseSymbolic
                     filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));
                 }
                 return true;
-            }, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            }, !isUseSingleThreadedCopy);
 
             Assert.True(success);
             Assert.Equal(4, filesActuallyCopied.Count);
@@ -2352,7 +2347,7 @@ public void FailureWithNoRetries(bool isUseHardLinks, bool isUseSymbolicLinks, b
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            bool result = t.Execute(copyFunctor.Copy, !isUseSingleThreadedCopy);
 
             Assert.False(result);
             engine.AssertLogDoesntContain("MSB3026");
@@ -2419,7 +2414,7 @@ public void SuccessAfterOneRetry(bool isUseHardLinks, bool isUseSymbolicLinks, b
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            bool result = t.Execute(copyFunctor.Copy, !isUseSingleThreadedCopy);
 
             Assert.True(result);
             engine.AssertLogContains("MSB3026");
@@ -2446,7 +2441,7 @@ public void SuccessAfterOneRetryContinueToNextFile(bool isUseHardLinks, bool isU
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            bool result = t.Execute(copyFunctor.Copy, !isUseSingleThreadedCopy);
 
             Assert.True(result);
             engine.AssertLogContains("MSB3026");
@@ -2478,7 +2473,7 @@ public void TooFewRetriesReturnsFalse(bool isUseHardLinks, bool isUseSymbolicLin
             };
 
             var copyFunctor = new CopyFunctor(4, false /* do not throw */);
-            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            bool result = t.Execute(copyFunctor.Copy, !isUseSingleThreadedCopy);
 
             Assert.False(result);
             engine.AssertLogContains("MSB3026");
@@ -2507,7 +2502,7 @@ public void TooFewRetriesThrows(bool isUseHardLinks, bool isUseSymbolicLinks, bo
             };
 
             var copyFunctor = new CopyFunctor(3, true /* throw */);
-            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            bool result = t.Execute(copyFunctor.Copy, !isUseSingleThreadedCopy);
 
             Assert.False(result);
             engine.AssertLogContains("MSB3026");
diff --git a/src/Tasks.UnitTests/DownloadFile_Tests.cs b/src/Tasks.UnitTests/DownloadFile_Tests.cs
index b2f22466194..398677ca2c9 100644
--- a/src/Tasks.UnitTests/DownloadFile_Tests.cs
+++ b/src/Tasks.UnitTests/DownloadFile_Tests.cs
@@ -37,7 +37,7 @@ public void CanBeCanceled()
                     DestinationFolder = new TaskItem(folder.Path),
                     HttpMessageHandler = new MockHttpMessageHandler((message, token) => new HttpResponseMessage(HttpStatusCode.OK)
                     {
-                        Content = new StringContent(new String('!', 10000000)),
+                        Content = new StreamContent(new FakeStream()),
                         RequestMessage = new HttpRequestMessage(HttpMethod.Get, "http://largedownload/foo.txt")
                     }),
                     SourceUrl = "http://largedownload/foo.txt"
@@ -47,7 +47,7 @@ public void CanBeCanceled()
 
                 downloadFile.Cancel();
 
-                task.Wait(TimeSpan.FromSeconds(1)).ShouldBeTrue();
+                task.Wait(TimeSpan.FromMilliseconds(1500)).ShouldBeTrue();
 
                 task.Result.ShouldBeFalse();
             }
@@ -401,4 +401,40 @@ protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage reques
             }
         }
     }
+
+    // Fake stream that simulates providing a single character A~Z per a couple of milliseconds without high memory cost.
+    public class FakeStream : Stream
+    {
+        private readonly int delayMilliseconds;
+
+        public FakeStream(int delayInMilliseconds = 20)
+        {
+            delayMilliseconds = delayInMilliseconds;
+            Position = 0;
+        }
+
+        public override bool CanRead => true;
+        public override bool CanSeek => true;
+        public override bool CanWrite => false;
+        public override long Length => long.MaxValue;
+        public override long Position { get; set; }
+
+        public override int Read(byte[] buffer, int offset, int count)
+        {
+            // Simulate infinite stream by keeping providing a single character to the beginning of the requested destination.
+            // Writes next char A ~ Z in alphabet into the begining of requested destination. The count could be ignored.
+            buffer[offset] = (byte)('A' + Position % 26);
+            Position++;
+            Task.Delay(delayMilliseconds).Wait();
+            return 1;
+        }
+
+        public override long Seek(long offset, SeekOrigin origin) => throw new NotImplementedException();
+
+        public override void SetLength(long value) => throw new NotImplementedException();
+
+        public override void Write(byte[] buffer, int offset, int count) => throw new NotImplementedException();
+
+        public override void Flush() => throw new NotImplementedException();
+    }
 }
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index a38fd0f4bbd..458fc147f78 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -2033,7 +2033,7 @@ public void GenerateResourceWarnsWhenUsingBinaryFormatter()
 
             gr.Execute().ShouldBeTrue();
 
-            Utilities.AssertLogContainsResource(gr, "GenerateResource.BinaryFormatterUse", "$this.Icon", "System.Drawing.Icon, System.Drawing");
+            Utilities.AssertLogContainsResource(gr, "GenerateResource.BinaryFormatterUse", "$this.Icon");
         }
 
         /// <summary>
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index c5b39e5675c..4c3af84873a 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -48,6 +48,11 @@ public class AssignCulture : TaskExtension
         /// </summary>
         public bool RespectAlreadyAssignedItemCulture { get; set; } = false;
 
+        /// <summary>
+        /// If the flag set to 'true' the task will log a warning when the culture metadata is overwritten by the task.
+        /// </summary>
+        public bool WarnOnCultureOverwritten { get; set; } = false;
+
         /// <summary>
         /// This outgoing list of files is exactly the same as the incoming Files
         /// list except that an attribute name "Culture" will have been added if
@@ -160,7 +165,7 @@ public override bool Execute()
                             ConversionUtilities.ValidBooleanFalse(AssignedFiles[i].GetMetadata(ItemMetadataNames.withCulture)));
 
                         // The culture was explicitly specified, but not opted in via 'RespectAlreadyAssignedItemCulture' and different will be used
-                        if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_14) &&
+                        if (WarnOnCultureOverwritten &&
                             !string.IsNullOrEmpty(existingCulture) &&
                             !MSBuildNameIgnoreCaseComparer.Default.Equals(existingCulture, info.culture))
                         {
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index e553d1765af..3cf26dc3eb4 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -15,6 +15,8 @@
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
+using TPLTask = System.Threading.Tasks.Task;
+
 #nullable disable
 
 namespace Microsoft.Build.Tasks
@@ -44,6 +46,33 @@ public class Copy : TaskExtension, IIncrementalTask, ICancelableTask
         // taking up the whole threadpool esp. when hosted in Visual Studio. IOW we use a specific number
         // instead of int.MaxValue.
         private static readonly int DefaultCopyParallelism = NativeMethodsShared.GetLogicalCoreCount() > 4 ? 6 : 4;
+        private static Thread[] copyThreads;
+        private static AutoResetEvent[] copyThreadSignals;
+        private AutoResetEvent _signalCopyTasksCompleted;
+
+        private static ConcurrentQueue<Action> _copyActionQueue = new ConcurrentQueue<Action>();
+
+        private static void InitializeCopyThreads()
+        {
+            lock (_copyActionQueue)
+            {
+                if (copyThreads == null)
+                {
+                    copyThreadSignals = new AutoResetEvent[DefaultCopyParallelism];
+                    copyThreads = new Thread[DefaultCopyParallelism];
+                    for (int i = 0; i < copyThreads.Length; ++i)
+                    {
+                        AutoResetEvent autoResetEvent = new AutoResetEvent(false);
+                        copyThreadSignals[i] = autoResetEvent;
+                        Thread newThread = new Thread(ParallelCopyTask);
+                        newThread.IsBackground = true;
+                        newThread.Name = "Parallel Copy Thread";
+                        newThread.Start(autoResetEvent);
+                        copyThreads[i] = newThread;
+                    }
+                }
+            }
+        }
 
         /// <summary>
         /// Constructor.
@@ -63,6 +92,8 @@ public Copy()
                 RemovingReadOnlyAttribute = Log.GetResourceMessage("Copy.RemovingReadOnlyAttribute");
                 SymbolicLinkComment = Log.GetResourceMessage("Copy.SymbolicLinkComment");
             }
+
+            _signalCopyTasksCompleted = new AutoResetEvent(false);
         }
 
         private static string CreatesDirectory;
@@ -79,7 +110,7 @@ public Copy()
         private readonly CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();
 
         // Bool is just a placeholder, we're mainly interested in a threadsafe key set.
-        private readonly ConcurrentDictionary<string, bool> _directoriesKnownToExist = new ConcurrentDictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
+        private readonly ConcurrentDictionary<string, bool> _directoriesKnownToExist = new ConcurrentDictionary<string, bool>(DefaultCopyParallelism, DefaultCopyParallelism, StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Force the copy to retry even when it hits ERROR_ACCESS_DENIED -- normally we wouldn't retry in this case since
@@ -93,7 +124,7 @@ public Copy()
         /// </summary>
         private static readonly bool s_forceSymlinks = Environment.GetEnvironmentVariable("MSBuildUseSymboliclinksIfPossible") != null;
 
-        private static readonly int s_parallelism = GetParallelismFromEnvironment();
+        private static readonly bool s_copyInParallel = GetParallelismFromEnvironment();
 
         /// <summary>
         /// Default milliseconds to wait between necessary retries
@@ -395,12 +426,12 @@ private void MakeFileWriteable(FileState file, bool logActivity)
         /// Copy the files.
         /// </summary>
         /// <param name="copyFile">Delegate used to copy the files.</param>
-        /// <param name="parallelism">
+        /// <param name="copyInParallel">
         /// Thread parallelism allowed during copies. 1 uses the original algorithm, >1 uses newer algorithm.
         /// </param>
         internal bool Execute(
             CopyFileWithState copyFile,
-            int parallelism)
+            bool copyInParallel)
         {
             // If there are no source files then just return success.
             if (IsSourceSetEmpty())
@@ -430,9 +461,9 @@ internal bool Execute(
 
             try
             {
-                success = parallelism == 1 || DestinationFiles.Length == 1
+                success = !copyInParallel || DestinationFiles.Length == 1
                     ? CopySingleThreaded(copyFile, out destinationFilesSuccessfullyCopied)
-                    : CopyParallel(copyFile, parallelism, out destinationFilesSuccessfullyCopied);
+                    : CopyParallel(copyFile, out destinationFilesSuccessfullyCopied);
             }
             catch (OperationCanceledException)
             {
@@ -507,6 +538,22 @@ private bool CopySingleThreaded(
             return success;
         }
 
+        private static void ParallelCopyTask(object state)
+        {
+            AutoResetEvent autoResetEvent = (AutoResetEvent)state;
+            while (true)
+            {
+                if (_copyActionQueue.TryDequeue(out Action copyAction))
+                {
+                    copyAction();
+                }
+                else
+                {
+                    autoResetEvent.WaitOne();
+                }
+            }
+        }
+
         /// <summary>
         /// Parallelize I/O with the same semantics as the single-threaded copy method above.
         /// ResolveAssemblyReferences tends to generate longer and longer lists of files to send
@@ -516,7 +563,6 @@ private bool CopySingleThreaded(
         /// </summary>
         private bool CopyParallel(
             CopyFileWithState copyFile,
-            int parallelism,
             out List<ITaskItem> destinationFilesSuccessfullyCopied)
         {
             bool success = true;
@@ -559,77 +605,23 @@ private bool CopyParallel(
 
             // Lockless flags updated from each thread - each needs to be a processor word for atomicity.
             var successFlags = new IntPtr[DestinationFiles.Length];
-            var actionBlockOptions = new ExecutionDataflowBlockOptions
-            {
-                MaxDegreeOfParallelism = parallelism,
-                CancellationToken = _cancellationTokenSource.Token
-            };
-            var partitionCopyActionBlock = new ActionBlock<List<int>>(
-                async (List<int> partition) =>
-                {
-                    // Break from synchronous thread context of caller to get onto thread pool thread.
-                    await System.Threading.Tasks.Task.Yield();
 
-                    for (int partitionIndex = 0; partitionIndex < partition.Count && !_cancellationTokenSource.IsCancellationRequested; partitionIndex++)
-                    {
-                        int fileIndex = partition[partitionIndex];
-                        ITaskItem sourceItem = SourceFiles[fileIndex];
-                        ITaskItem destItem = DestinationFiles[fileIndex];
-                        string sourcePath = sourceItem.ItemSpec;
-
-                        // Check if we just copied from this location to the destination, don't copy again.
-                        MSBuildEventSource.Log.CopyUpToDateStart(destItem.ItemSpec);
-                        bool copyComplete = partitionIndex > 0 &&
-                                            String.Equals(
-                                                sourcePath,
-                                                SourceFiles[partition[partitionIndex - 1]].ItemSpec,
-                                                StringComparison.OrdinalIgnoreCase);
-
-                        if (!copyComplete)
-                        {
-                            if (DoCopyIfNecessary(
-                                new FileState(sourceItem.ItemSpec),
-                                new FileState(destItem.ItemSpec),
-                                copyFile))
-                            {
-                                copyComplete = true;
-                            }
-                            else
-                            {
-                                // Thread race to set outer variable but they race to set the same (false) value.
-                                success = false;
-                            }
-                        }
-                        else
-                        {
-                            MSBuildEventSource.Log.CopyUpToDateStop(destItem.ItemSpec, true);
-                        }
+            ConcurrentQueue<List<int>> partitionQueue = new ConcurrentQueue<List<int>>(partitionsByDestination.Values);
 
-                        if (copyComplete)
-                        {
-                            sourceItem.CopyMetadataTo(destItem);
-                            successFlags[fileIndex] = (IntPtr)1;
-                        }
-                    }
-                },
-                actionBlockOptions);
+            int activeCopyThreads = DefaultCopyParallelism;
+            for (int i = 0; i < DefaultCopyParallelism; ++i)
+            {
+                _copyActionQueue.Enqueue(ProcessPartition);
+            }
+
+            InitializeCopyThreads();
 
-            foreach (List<int> partition in partitionsByDestination.Values)
+            for (int i = 0; i < DefaultCopyParallelism; ++i)
             {
-                bool partitionAccepted = partitionCopyActionBlock.Post(partition);
-                if (_cancellationTokenSource.IsCancellationRequested)
-                {
-                    break;
-                }
-                else if (!partitionAccepted)
-                {
-                    // Retail assert...
-                    ErrorUtilities.ThrowInternalError("Failed posting a file copy to an ActionBlock. Should not happen with block at max int capacity.");
-                }
+                copyThreadSignals[i].Set();
             }
 
-            partitionCopyActionBlock.Complete();
-            partitionCopyActionBlock.Completion.GetAwaiter().GetResult();
+            _signalCopyTasksCompleted.WaitOne();
 
             // Assemble an in-order list of destination items that succeeded.
             destinationFilesSuccessfullyCopied = new List<ITaskItem>(DestinationFiles.Length);
@@ -642,6 +634,65 @@ private bool CopyParallel(
             }
 
             return success;
+
+            void ProcessPartition()
+            {
+                try
+                {
+                    while (partitionQueue.TryDequeue(out List<int> partition))
+                    {
+                        for (int partitionIndex = 0; partitionIndex < partition.Count && !_cancellationTokenSource.IsCancellationRequested; partitionIndex++)
+                        {
+                            int fileIndex = partition[partitionIndex];
+                            ITaskItem sourceItem = SourceFiles[fileIndex];
+                            ITaskItem destItem = DestinationFiles[fileIndex];
+                            string sourcePath = sourceItem.ItemSpec;
+
+                            // Check if we just copied from this location to the destination, don't copy again.
+                            MSBuildEventSource.Log.CopyUpToDateStart(destItem.ItemSpec);
+                            bool copyComplete = partitionIndex > 0 &&
+                                                String.Equals(
+                                                    sourcePath,
+                                                    SourceFiles[partition[partitionIndex - 1]].ItemSpec,
+                                                    StringComparison.OrdinalIgnoreCase);
+
+                            if (!copyComplete)
+                            {
+                                if (DoCopyIfNecessary(
+                                    new FileState(sourceItem.ItemSpec),
+                                    new FileState(destItem.ItemSpec),
+                                    copyFile))
+                                {
+                                    copyComplete = true;
+                                }
+                                else
+                                {
+                                    // Thread race to set outer variable but they race to set the same (false) value.
+                                    success = false;
+                                }
+                            }
+                            else
+                            {
+                                MSBuildEventSource.Log.CopyUpToDateStop(destItem.ItemSpec, true);
+                            }
+
+                            if (copyComplete)
+                            {
+                                sourceItem.CopyMetadataTo(destItem);
+                                successFlags[fileIndex] = (IntPtr)1;
+                            }
+                        }
+                    }
+                }
+                finally
+                {
+                    int count = System.Threading.Interlocked.Decrement(ref activeCopyThreads);
+                    if (count == 0)
+                    {
+                        _signalCopyTasksCompleted.Set();
+                    }
+                }
+            }
         }
 
         private bool IsSourceSetEmpty()
@@ -1028,7 +1079,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
         /// <returns></returns>
         public override bool Execute()
         {
-            return Execute(CopyFileWithLogging, s_parallelism);
+            return Execute(CopyFileWithLogging, s_copyInParallel);
         }
 
         #endregion
@@ -1049,18 +1100,10 @@ private static bool PathsAreIdentical(FileState source, FileState destination)
             return string.Equals(source.FileNameFullPath, destination.FileNameFullPath, FileUtilities.PathComparison);
         }
 
-        private static int GetParallelismFromEnvironment()
+        private static bool GetParallelismFromEnvironment()
         {
             int parallelism = Traits.Instance.CopyTaskParallelism;
-            if (parallelism < 0)
-            {
-                parallelism = DefaultCopyParallelism;
-            }
-            else if (parallelism == 0)
-            {
-                parallelism = int.MaxValue;
-            }
-            return parallelism;
+            return parallelism != 1;
         }
     }
 }
diff --git a/src/Tasks/ManifestUtil/CngLightup.cs b/src/Tasks/ManifestUtil/CngLightup.cs
index 9df8266fb8e..94e6a9c206c 100644
--- a/src/Tasks/ManifestUtil/CngLightup.cs
+++ b/src/Tasks/ManifestUtil/CngLightup.cs
@@ -26,7 +26,6 @@ namespace System.Security.Cryptography
 {
     internal static partial class CngLightup
     {
-        private const string DsaOid = "1.2.840.10040.4.1";
         private const string RsaOid = "1.2.840.113549.1.1.1";
 
         private const string HashAlgorithmNameTypeName = "System.Security.Cryptography.HashAlgorithmName";
@@ -57,9 +56,6 @@ internal static partial class CngLightup
 
         private static readonly Lazy<bool> s_preferRsaCng = new Lazy<bool>(DetectRsaCngSupport);
 
-        private static volatile Func<X509Certificate2, DSA> s_getDsaPublicKey;
-        private static volatile Func<X509Certificate2, DSA> s_getDsaPrivateKey;
-
         private static volatile Func<X509Certificate2, RSA> s_getRsaPublicKey;
         private static volatile Func<X509Certificate2, RSA> s_getRsaPrivateKey;
         private static volatile Func<RSA, byte[], string, byte[]> s_rsaPkcs1SignMethod;
@@ -112,30 +108,6 @@ internal static RSA GetRSAPrivateKey(X509Certificate2 cert)
             return s_getRsaPrivateKey(cert);
         }
 
-        internal static DSA GetDSAPublicKey(X509Certificate2 cert)
-        {
-            if (s_getDsaPublicKey == null)
-            {
-                s_getDsaPublicKey =
-                    BindCoreDelegate<DSA>("DSA", isPublic: true) ??
-                    BindGetCapiPublicKey<DSA, DSACryptoServiceProvider>(DsaOid);
-            }
-
-            return s_getDsaPublicKey(cert);
-        }
-
-        internal static DSA GetDSAPrivateKey(X509Certificate2 cert)
-        {
-            if (s_getDsaPrivateKey == null)
-            {
-                s_getDsaPrivateKey =
-                    BindCoreDelegate<DSA>("DSA", isPublic: false) ??
-                    BindGetCapiPrivateKey<DSA>(DsaOid, csp => new DSACryptoServiceProvider(csp));
-            }
-
-            return s_getDsaPrivateKey(cert);
-        }
-
 #if !CNG_LIGHTUP_NO_SYSTEM_CORE
         internal static ECDsa GetECDsaPublicKey(X509Certificate2 cert)
         {
@@ -526,7 +498,6 @@ private static Func<X509Certificate2, T> BindCoreDelegate<T>(string algorithmNam
             // Load System.Core.dll and load the appropriate extension class
             // (one of
             //    System.Security.Cryptography.X509Certificates.RSACertificateExtensions
-            //    System.Security.Cryptography.X509Certificates.DSACertificateExtensions
             //    System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions
             // )
             string typeName = "System.Security.Cryptography.X509Certificates." + algorithmName + "CertificateExtensions";
@@ -547,8 +518,6 @@ private static Func<X509Certificate2, T> BindCoreDelegate<T>(string algorithmNam
             // (one of
             //     GetRSAPublicKey(this X509Certificate2 c)
             //     GetRSAPrivateKey(this X509Certificate2 c)
-            //     GetDSAPublicKey(this X509Certificate2 c)
-            //     GetDSAPrivateKey(this X509Certificate2 c)
             //     GetECDsaPublicKey(this X509Certificate2 c)
             //     GetECDsaPrivateKey(this X509Certificate2 c)
             // )
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 9c4db39cb77..37d7cece260 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -37,9 +37,6 @@
   </ItemGroup>
   <ItemGroup>
     <!-- Source Files -->
-    <Compile Include="..\Shared\EnvironmentUtilities.cs">
-      <Link>EnvironmentUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\AssemblyFolders\AssemblyFoldersEx.cs">
       <Link>AssemblyDependency\AssemblyFoldersEx.cs</Link>
     </Compile>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 3fdfff8ac43..80694ad6d50 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -497,7 +497,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <!-- Output location for publish target. -->
   <PropertyGroup>
     <PublishDir Condition="'$(PublishDir)' != '' and !HasTrailingSlash('$(PublishDir)')">$(PublishDir)\</PublishDir>
-    <PublishDir Condition="'$(PublishDir)'==''">$(OutputPath)app.publish\</PublishDir>
+    <PublishDir Condition="'$(PublishDir)'==''">$([MSBuild]::EnsureTrailingSlash('$(OutputPath)'))app.publish\</PublishDir>
   </PropertyGroup>
 
   <!--
@@ -2578,13 +2578,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       SourceFiles="@(AppConfigWithTargetPath->'%(FullPath)')"
       DestinationFiles="$(_GenerateBindingRedirectsIntermediateAppConfig)"
       SkipUnchangedFiles="true"
-      Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true'">
+      Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true' and '$(DesignTimeBuild)' != 'true'">
       <Output TaskParameter="CopiedFiles" ItemName="FileWrites"/>
     </Copy>
     <Touch
       Files="$(_GenerateBindingRedirectsIntermediateAppConfig)"
       AlwaysCreate="true"
-      Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true'"/>
+      Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true' and '$(DesignTimeBuild)' != 'true'"/>
 
     <ItemGroup Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">
       <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
@@ -3287,6 +3287,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <PropertyGroup>
       <RespectAlreadyAssignedItemCulture Condition="'$(RespectAlreadyAssignedItemCulture)' == ''">false</RespectAlreadyAssignedItemCulture>
+      <WarnOnCultureOverwritten Condition="'$(WarnOnCultureOverwritten)' == ''">false</WarnOnCultureOverwritten>
     </PropertyGroup>
 
     <MSBuildInternalMessage Condition="'@(ResxWithNoCulture)'!=''" ResourceName="CommonSdk.SplitResourcesByCultureEmbeddedResourceMessage" Severity="Warning" FormatArguments="MSB9000;ResxWithNoCulture" />
@@ -3306,7 +3307,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </EmbeddedResource>
     </ItemGroup>
 
-    <AssignCulture Files="@(EmbeddedResource)" Condition="'%(Extension)'!='.licx'"  RespectAlreadyAssignedItemCulture="$(RespectAlreadyAssignedItemCulture)">
+    <AssignCulture Files="@(EmbeddedResource)" Condition="'%(Extension)'!='.licx'"  RespectAlreadyAssignedItemCulture="$(RespectAlreadyAssignedItemCulture)" WarnOnCultureOverwritten="$(WarnOnCultureOverwritten)">
       <!-- Create the list of culture resx and embedded resource files -->
       <Output TaskParameter="AssignedFilesWithCulture" ItemName="_MixedResourceWithCulture"/>
       <!-- Create the list of non-culture resx and embedded resource files -->
@@ -3847,7 +3848,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     contribute to incremental build inconsistencies.
     ============================================================
     -->
-  <Target Name="_GenerateCompileDependencyCache" Condition="'$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'" DependsOnTargets="ResolveAssemblyReferences">
+  <Target Name="_GenerateCompileDependencyCache" Condition="'$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'" DependsOnTargets="ResolveAssemblyReferences;_GenerateCompileInputs">
     <ItemGroup>
       <CustomAdditionalCompileInputs Include="$(IntermediateOutputPath)$(MSBuildProjectFile).CoreCompileInputs.cache" />
       <CoreCompileCache Include="@(Compile)" />
@@ -3856,6 +3857,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <CoreCompileCache Include="$(LangVersion)" />
       <CoreCompileCache Include="$(Deterministic)" />
       <CoreCompileCache Include="$(PathMap)" />
+      <CoreCompileCache Include="@(_CoreCompileResourceInputs)"/>
     </ItemGroup>
 
     <Hash
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index 29ca1ce275f..ea1ffae0211 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -197,7 +197,7 @@ private static void ParseData(
                         // Warn of BinaryFormatter exposure (SDK should turn this on by default in .NET 8+)
                         if (logWarningForBinaryFormatter)
                         {
-                            log?.LogWarningWithCodeFromResources(null, resxFilename, ((IXmlLineInfo)elem).LineNumber, ((IXmlLineInfo)elem).LinePosition, 0, 0, "GenerateResource.BinaryFormatterUse", name, typename);
+                            log?.LogWarningWithCodeFromResources(null, resxFilename, ((IXmlLineInfo)elem).LineNumber, ((IXmlLineInfo)elem).LinePosition, 0, 0, "GenerateResource.BinaryFormatterUse", name);
                         }
 
                         // BinaryFormatter from byte array
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 341e85c7e55..9a0e3de5f65 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -1169,7 +1169,7 @@
     <comment>{StrBegin="MSB3824: "}</comment>
   </data>
   <data name="GenerateResource.BinaryFormatterUse">
-    <value>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+    <value>MSB3825: Resource "{0}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</value>
     <comment>{StrBegin="MSB3825: "}</comment>
   </data>
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index ed494375293..c0696bf2bbe 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: Prostředek {0} typu {1} může být deserializován přes BinaryFormatter za běhu. BinaryFormatter je zastaralý kvůli známým bezpečnostním rizikům a byl odebrán z rozhraní .NET 9+. Pokud ho chcete dál používat, nastavte vlastnost GenerateResourceWarnOnBinaryFormatterUse na false.
+        <target state="translated">MSB3825: Prostředek {0} bude deserializován přes BinaryFormatter za běhu. BinaryFormatter je kvůli známým bezpečnostním rizikům zastaralý a byl odebrán z rozhraní .NET 9+. Pokud ho chcete dál používat, nastavte vlastnost GenerateResourceWarnOnBinaryFormatterUse na false.
            Další informace: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 8bd7effeaef..3a965f2df0e 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: Die Ressource "{0}" vom Typ "{1}" kann zur Laufzeit über BinaryFormatter deserialisiert werden. BinaryFormatter ist aufgrund bekannter Sicherheitsrisiken veraltet und wird aus .NET 9 und höher entfernt. Wenn Sie ihn weiterhin verwenden möchten, legen Sie die Eigenschaft "GenerateResourceWarnOnBinaryFormatterUse" auf "false" fest.
+        <target state="translated">MSB3825: Die Ressource „{0}“ wird während der Laufzeit über BinaryFormatter deserialisiert. BinaryFormatter ist aufgrund bekannter Sicherheitsrisiken veraltet und wird aus .NET 9 und höher entfernt. Wenn Sie ihn weiterhin verwenden möchten, legen Sie die Eigenschaft „GenerateResourceWarnOnBinaryFormatterUse“ auf FALSCH fest.
            Weitere Informationen finden Sie unter: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 15ef00ad1aa..fc44eec2ecc 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: El recurso "{0}" del tipo "{1}" puede que se haya deserializado a través de BinaryFormatter en el tiempo de ejecución. BinaryFormatter está en desuso debido a riesgos de seguridad conocidos y se ha eliminado de .NET 9+. Si desea seguir usándolo, establezca la propiedad "GenerateResourceWarnOnBinaryFormatterUse" en false.
+        <target state="translated">MSB3825: El recurso "{0}" se deserializará a través de BinaryFormatter en tiempo de ejecución. BinaryFormatter está en desuso debido a riesgos de seguridad conocidos y se ha quitado de.NET 9 y versiones superiores. Si deseas seguir usándolo, establece la propiedad "GenerateResourceWarnOnBinaryFormatterUse" en false.
            Más información: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 023466072c9..58f4de820af 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -1178,10 +1178,10 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: La ressource « {0} » de type « {1} » peut être désérialisée via BinaryFormatter lors de l'exécution. BinaryFormatter est obsolète en raison de risques de sécurité connus et est supprimé de .NET 9+. Si vous souhaitez continuer à l'utiliser, définissez la propriété « GenerateResourceWarnOnBinaryFormatterUse » sur false.
-           Plus d'informations : https://aka.ms/binaryformatter-migration-guide</target>
+        <target state="translated">MSB3825: la ressource « {0} » sera désérialisée via BinaryFormatter lors de l’exécution. BinaryFormatter est déconseillé en raison de risques de sécurité connus et est supprimé de .NET 9+. Si vous souhaitez continuer à l’utiliser, définissez la propriété « GenerateResourceWarnOnBinaryFormatterUse » sur la valeur false.
+           Plus découvrir d’informations : https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 8724e9b865a..82941a83d6b 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: la risorsa "{0}" di tipo "{1}" può essere deserializzata tramite BinaryFormatter in fase di esecuzione. BinaryFormatter è deprecato a causa di rischi noti per la sicurezza ed è stato rimosso da .NET 9+. Se si desidera continuare a usarlo, impostare la proprietà "GenerateResourceWarnOnBinaryFormatterUse" su false.
+        <target state="translated">MSB3825: la risorsa "{0}" verrà deserializzata tramite BinaryFormatter al runtime. BinaryFormatter è deprecato a causa di rischi noti per la sicurezza ed è stato rimosso da .NET 9+. Se si desidera continuare a usarlo, impostare la proprietà "GenerateResourceWarnOnBinaryFormatterUse" su false.
            Altre informazioni: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index fb42f9471c7..8acf0d6c73a 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: 実行時に BinaryFormatter を使用して、型が "{1}" のリソース "{0}" が逆シリアル化されている可能性があります。BinaryFormatter は、既知のセキュリティ リスクにより非推奨となり、.NET 9 以降では削除されます。引き続き使用する場合は、プロパティ "GenerateResourceWarnOnBinaryFormatterUse" を false に設定します。
+        <target state="translated">MSB3825: リソース "{0}" は実行時に BinaryFormatter を介して逆シリアル化されます。BinaryFormatter は、既知のセキュリティ リスクにより非推奨となり、.NET 9 以降では削除されています。引き続き使用する場合は、プロパティ "GenerateResourceWarnOnBinaryFormatterUse" を false に設定します。
            詳細情報: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 488674964ff..575580b261e 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: "{1}" 형식의 리소스 "{0}"은(는) 런타임 시 BinaryFormatter를 통해 역직렬화될 수 있습니다. BinaryFormatter는 알려진 보안 위험으로 인해 사용되지 않으며 .NET 9 이상에서 제거됩니다. 계속 사용하려면 "GenerateResourceWarnOnBinaryFormatterUse" 속성을 false로 설정합니다.
+        <target state="translated">MSB3825: 리소스 "{0}"은(는) 런타임 시 BinaryFormatter를 통해 역직렬화됩니다. BinaryFormatter는 알려진 보안 위험으로 인해 사용되지 않으며 .NET 9 이상에서 제거됩니다. 계속 사용하려면 "GenerateResourceWarnOnBinaryFormatterUse" 속성을 false로 설정하세요.
            추가 정보: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 1be6493ac7e..13aa2b655c3 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: zasób „{0}” typu „{1}” może być deserializowany za pośrednictwem elementu BinaryFormatter w czasie wykonywania. Element BinaryFormatter jest przestarzały ze względu na znane zagrożenia bezpieczeństwa i został usunięty z platformy .NET 9 lub nowszej. Jeśli chcesz nadal go używać, ustaw właściwość „GenerateResourceWarnOnBinaryFormatterUse” na false.
+        <target state="translated">MSB3825: zasób „{0}” może być deserializowany za pośrednictwem funkcji BinaryFormatter w czasie wykonywania. Funkcja BinaryFormatter jest przestarzała ze względu na znane zagrożenia bezpieczeństwa i została usunięta z platformy .NET 9 lub nowszej. Jeśli chcesz nadal jej używać, ustaw właściwość „GenerateResourceWarnOnBinaryFormatterUse” na wartość false.
            Więcej informacji: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index dbf2d3b1507..5e73c068203 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -1178,10 +1178,10 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: O recurso "{0}" do tipo "{1}" pode ser desserializado via BinaryFormatter em tempo de execução. O BinaryFormatter foi preterido devido a riscos de segurança conhecidos e foi removido do .NET 9+. Se desejar continuar usando, defina a propriedade "GenerateResourceWarnOnBinaryFormatterUse" como false.
-           Mais informações: https://aka.ms/binaryformatter-migration-guide</target>
+        <target state="translated">MSB3825: O recurso "{0}" será desserializado via BinaryFormatter em tempo de execução. BinaryFormatter foi preterido devido a riscos de segurança conhecidos e foi removido do .NET 9+. Se você quiser continuar a usá-lo, defina a propriedade "GenerateResourceWarnOnBinaryFormatterUse" como falso.
+           Mais informações: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 1458e4be35d..0d2481f88f1 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -1178,10 +1178,10 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: для ресурса "{0}" с типом "{1}" может быть выполнена десериализация с помощью BinaryFormatter во время выполнения. BinaryFormatter является нерекомендуемым из-за известных рисков безопасности и удален из .NET 9+. Если вы хотите продолжить использовать его, задайте для свойства GenerateResourceWarnOnBinaryFormatterUse значение false.
-           Дополнительные сведения см. в руководстве по миграции по ссылке https://aka.ms/binaryformatter.</target>
+        <target state="translated">MSB3825: для ресурса "{0}" будет выполнена десериализация с помощью BinaryFormatter во время выполнения. Сериализация BinaryFormatter упразднена из-за известных рисков безопасности и удалена из .NET 9 и более поздних версий. Чтобы продолжить использовать эту сериализацию, задайте для свойства "GenerateResourceWarnOnBinaryFormatterUse" значение false.
+           Подробнее: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 5e21f464b5d..c5628afda25 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -1178,10 +1178,10 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: "{1}" türündeki "{0}" kaynağı çalışma zamanında BinaryFormatter aracılığıyla seri duruma getiriliyor olabilir. BinaryFormatter, bilinen güvenlik riskleri nedeniyle kullanım dışıdır ve .NET 9+'dan kaldırılır. Kullanmaya devam etmek istiyorsanız "GenerateResourceWarnOnBinaryFormatterUse" özelliğini false olarak ayarlayın.
-           Daha fazla bilgi için bkz. https://aka.ms/binaryformatter-migration-guide.</target>
+        <target state="translated">MSB3825: "{0}" kaynağı çalışma zamanında BinaryFormatter aracılığıyla seri durumdan çıkarılacak. BinaryFormatter, bilinen güvenlik riskleri nedeniyle kullanım dışı bırakıldı ve .NET 9+'dan kaldırdı. Kullanmaya devam etmek istiyorsanız "GenerateResourceWarnOnBinaryFormatterUse" özelliğini false olarak ayarlayın.
+           Daha fazla bilgi için bkz. https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CoreSupportsLimitedScenarios">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index df77a4fa0d8..f0de3169f48 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: 可在运行时通过 BinaryFormatter 反序列化类型为“{1}”的资源“{0}”。由于已知的安全风险，BinaryFormatter 已被弃用，并从 .NET 9+ 中删除。如果要继续使用它，请将属性“GenerateResourceWarnOnBinaryFormatterUse”设置为 false。
+        <target state="translated">MSB3825: 在运行时将通过 BinaryFormatter 反序列化资源“{0}”。由于已知的安全风险，BinaryFormatter 已弃用，并从 .NET 9+ 中删除。如果要继续使用它，请将属性 "GenerateResourceWarnOnBinaryFormatterUse" 设置为 false。
            有关详细信息，请参阅：https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index cb6e2af101c..7a9aa294f34 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -1178,9 +1178,9 @@
         <note>{StrBegin="MSB3190: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.BinaryFormatterUse">
-        <source>MSB3825: Resource "{0}" of type "{1}" may be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
+        <source>MSB3825: Resource "{0}" will be deserialized via BinaryFormatter at runtime. BinaryFormatter is deprecated due to known security risks and is removed from .NET 9+. If you wish to continue using it, set property "GenerateResourceWarnOnBinaryFormatterUse" to false.
            More information: https://aka.ms/binaryformatter-migration-guide</source>
-        <target state="translated">MSB3825: 在執行階段，可能會透過 BinaryFormatter 將類型為「{1}」的資源「{0}」取消初始化。BinaryFormatter 已因已知的安全性風險而被棄用，且已從 .NET 9+ 中移除。如果您想要繼續使用它，請將屬性 "GenerateResourceWarnOnBinaryFormatterUse" 設為 false。
+        <target state="translated">MSB3825: 資源「{0}」會在執行階段透過 BinaryFormatter 進行還原序列化。BinaryFormatter 已因已知的安全性風險而被取代，且已從 .NET 9+ 中移除。如果您想要繼續使用它，請將屬性 "GenerateResourceWarnOnBinaryFormatterUse" 設為 false。
            詳細資訊: https://aka.ms/binaryformatter-migration-guide</target>
         <note>{StrBegin="MSB3825: "}</note>
       </trans-unit>
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs
index 2d97134b43c..50a26f7f5f2 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs
@@ -6,6 +6,7 @@
 using System.Linq;
 using System.Runtime.InteropServices;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
 #nullable disable
@@ -52,7 +53,7 @@ protected RoslynCodeTaskFactoryCompilerBase()
             if (string.IsNullOrEmpty(_dotnetCliPath))
             {
                 // Fallback to get dotnet path from current process which might be dotnet executable.
-                _dotnetCliPath = System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName;
+                _dotnetCliPath = EnvironmentUtilities.ProcessPath;
             }
 
             // If dotnet path is not found, rely on dotnet via the system's PATH
diff --git a/src/Tasks/System.Resources.Extensions.pkgdef b/src/Tasks/System.Resources.Extensions.pkgdef
index 62579ad4643..4e811b44871 100644
--- a/src/Tasks/System.Resources.Extensions.pkgdef
+++ b/src/Tasks/System.Resources.Extensions.pkgdef
@@ -3,5 +3,5 @@
 "codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\System.Resources.Extensions.dll"
 "publicKeyToken"="cc7b13ffcd2ddd51"
 "culture"="neutral"
-"oldVersion"="0.0.0.0-99.9.9.9"
-"newVersion"="8.0.0.0"
+"oldVersion"="0.0.0.0-9.0.0.0"
+"newVersion"="9.0.0.0"
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index cf3ad3dad96..f85dc93eb7e 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -456,9 +456,7 @@ private AssemblyNameExtension GetAssemblyName(string path)
             // then we can short-circuit the File IO involved with GetAssemblyName()
             if (redistList != null)
             {
-                string extension = Path.GetExtension(path);
-
-                if (string.Equals(extension, ".dll", StringComparison.OrdinalIgnoreCase))
+                if (!string.IsNullOrEmpty(path) && path.EndsWith(".dll", StringComparison.OrdinalIgnoreCase))
                 {
                     IEnumerable<AssemblyEntry> assemblyNames = redistList.FindAssemblyNameFromSimpleName(
                             Path.GetFileNameWithoutExtension(path));
diff --git a/src/UnitTests.Shared/ObjectModelHelpers.cs b/src/UnitTests.Shared/ObjectModelHelpers.cs
index 99d1e251890..375c84d6779 100644
--- a/src/UnitTests.Shared/ObjectModelHelpers.cs
+++ b/src/UnitTests.Shared/ObjectModelHelpers.cs
@@ -1394,7 +1394,7 @@ public static MockLogger BuildProjectContentUsingBuildManagerExpectResult([Strin
             return logger;
         }
 
-        public static BuildResult BuildProjectContentUsingBuildManager([StringSyntax(StringSyntaxAttribute.Xml)] string content, MockLogger logger, BuildParameters parameters = null)
+        public static BuildResult BuildProjectContentUsingBuildManager([StringSyntax(StringSyntaxAttribute.Xml)] string content, ILogger logger, BuildParameters parameters = null)
         {
             // Replace the nonstandard quotes with real ones
             content = ObjectModelHelpers.CleanupFileContents(content);
@@ -1409,7 +1409,7 @@ public static BuildResult BuildProjectContentUsingBuildManager([StringSyntax(Str
 
         public static BuildResult BuildProjectFileUsingBuildManager(
             string projectFile,
-            MockLogger logger = null,
+            ILogger logger = null,
             BuildParameters parameters = null,
             IList<string> targetsToBuild = null)
         {
diff --git a/src/UnitTests.Shared/TestEnvironment.cs b/src/UnitTests.Shared/TestEnvironment.cs
index e725764a93a..1df70aad6af 100644
--- a/src/UnitTests.Shared/TestEnvironment.cs
+++ b/src/UnitTests.Shared/TestEnvironment.cs
@@ -56,6 +56,7 @@ public static TestEnvironment Create(ITestOutputHelper output = null, bool ignor
             // Clear these two environment variables first in case pre-setting affects the test.
             env.SetEnvironmentVariable("MSBUILDLIVELOGGER", null);
             env.SetEnvironmentVariable("MSBUILDTERMINALLOGGER", null);
+            env.SetEnvironmentVariable("MSBUILDUSESERVER", null);
 
             return env;
         }
diff --git a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
index e29bd389537..cdc831de205 100644
--- a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
+++ b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
@@ -9,8 +9,9 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
 
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 6b8153dbc9c..e5a0a89b595 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -48,9 +48,6 @@
     <Compile Include="..\Shared\AssemblyFolders\Serialization\AssemblyFolderItem.cs">
       <Link>Shared\AssemblyFolders\Serialization\AssemblyFolderItem.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\EnvironmentUtilities.cs">
-      <Link>Shared\EnvironmentUtilities.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>Shared\BuildEnvironmentHelper.cs</Link>
     </Compile>
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 0d45b676cd8..3f13658e0dd 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -3584,6 +3584,7 @@ public static string GetPathToBuildToolsFile(string fileName, string toolsVersio
             {
                 toolPath = Path.Combine(toolPath, fileName);
 
+                // Rollback see https://developercommunity.visualstudio.com/t/Unable-to-locate-MSBuild-path-with-Lates/10824132 
                 if (!File.Exists(toolPath))
                 {
                     toolPath = null;
