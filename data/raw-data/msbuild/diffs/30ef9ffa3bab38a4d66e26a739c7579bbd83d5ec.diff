diff --git a/documentation/specs/static-graph-implementation-details.md b/documentation/specs/static-graph-implementation-details.md
index 03c4bbaeff0..4845fff794d 100644
--- a/documentation/specs/static-graph-implementation-details.md
+++ b/documentation/specs/static-graph-implementation-details.md
@@ -8,7 +8,7 @@
 <!-- workflow -->
 Single project isolated builds can be achieved by providing MSBuild with input and output cache files.
 
-The input cache files contain the cached results of all the targets that a project calls on its references. When a project executes, it builds its references via [MSBuild task](aka.ms/msbuild_tasks) calls. In isolated builds, the engine, instead of executing these tasks, serves them from the provided input caches. In an isolated project build, only the current project should build targets. Any other referenced projects should be provided from the input caches. 
+The input cache files contain the cached results of all the targets that a project calls on its references. When a project builds without isolation, it builds its references via [MSBuild task](aka.ms/msbuild_tasks) calls. In isolated builds, the engine, instead of executing these tasks, serves their results from the provided input caches. In an isolated project build, only the top level project (built via the BuildManager APIs) should build targets. Any referenced projects by the top level project should be provided from the input caches.
 
 The output cache file tells MSBuild where to serialize the results of building the current project. This output cache becomes an input cache for all other projects that depend on the current project.
 The output cache file can be omitted in which case the build reuses prior results but does not write out any new results. This is useful when one wants to re-execute the build for a project without building its references.
@@ -35,7 +35,7 @@ The following constraints are enforced during cache aggregation:
 The output cache file **only contains results for additional work performed in the current BeginBuild / EndBuild session**. Entries from input caches are not transferred to the output cache.
 
 <!-- How input / output cache entries are separated with the override caches -->
-Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache (isolation exemption complicates this, more on that [further down](#how-isolation-exemption-complicates-everything)). The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.
+Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/microsoft/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache. The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.
 
 ## Isolation implementation
 
@@ -56,8 +56,4 @@ The build results for the exempt project are also included in the current cache
    1. `A` builds targets from `D` that already exist in the input cache file from `B`. This is handled in the same way as the above case `2.1.`
    2. `A` builds targets from `D` that do not exist in the input cache file from `B`, meaning that `A` builds additional targets from `D` which `B` didn't build. This is handled in the same way as teh above case `2.2.`
 
-<!-- How are these exemption cases implemented?-->
-
-Cases `2.2.` and `3.2.` complicate the requirement that the output cache should only contain newly built targets, and complicate the desirable goal that the override cache should never be mutated. In these cases initial entries (`BuildRequestConfiguration` for the `ConfigCache` and `BuildResult` / `TargetResult` for the `ResultsCache`) are already loaded in the override cache from previous builds, but then additional new builds on the isolation exempt entries need to be migrated / promoted to the current cache. This promotion is achieved differently for configs and build results:
-- `ConfigCache` entries [are moved](https://github.com/cdmihai/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs#L178) from the override cache into the current cache whenever a corresponding `BuildResult` is written into `BuildResultsWithOverride` (`BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`).
-- `BuildResult` / `TargetResult` entries are trickier. Sadly, the engine has a deep dependency on mutating existing results entries, so it's not possible to migrate result entries like config entries. Once the engine has obtained a reference to a result entry from the override cache, it will mutate it. In this particular case, [the BuildResultsWithOverride cache waives the requirement of non overlapping caches](https://github.com/cdmihai/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs#L139), and the new results are written both in the override caches (alongside the result entries deserialized from input caches), and also in the current cache. Thus, the override results cache will contain all build results, both old and new, while the current cache will contain only the new build results executed by the current build session.   
+**Current issue:** if multiple nodes in the graph exempt the same project file, the build results of the exempt project will trickle up and conflict in the first parent that tries to merge them. Documented in issue [#4386](https://github.com/dotnet/msbuild/issues/4386).
