diff --git a/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml b/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml
new file mode 100644
index 00000000000..edf0c00532e
--- /dev/null
+++ b/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml
@@ -0,0 +1,171 @@
+name: Sync Microsoft.Build version in analyzer template with Version.props
+on:
+  push:
+    branches:
+      - main
+    paths:
+      - 'eng/Versions.props'
+
+jobs:
+  Sync-version:
+    runs-on: ubuntu-latest
+
+    steps:
+    - name: Checkout repository
+      uses: actions/checkout@v3
+
+    - name: Set baseBranch variable
+      id: vars
+      run: echo "baseBranch=${{ github.ref_name }}" >> $GITHUB_ENV
+
+    - name: Update analyzer template version with version from Versions.props
+      shell: pwsh
+      run: |
+        try {
+            # Define the paths to your XML and JSON files
+            $xmlFilePath = "eng/Versions.props"
+            $jsonFilePath = "template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json"
+
+            # Check if the XML file exists
+            if (-Not (Test-Path -Path $xmlFilePath)) {
+                throw "Versions.props file not found: $xmlFilePath"
+            }
+
+            # Load and parse the XML content
+            [xml]$xmlContent = Get-Content -Path $xmlFilePath
+            $versionPrefix = [string]$xmlContent.Project.PropertyGroup.VersionPrefix
+            $versionPrefix = $versionPrefix.Trim()
+
+            # Validate the versionPrefix
+            if ([string]::IsNullOrWhiteSpace($versionPrefix)) {
+                throw "VersionPrefix is empty or null in the XML file: $xmlFilePath"
+            }
+
+            # Check if the JSON file exists
+            if (-Not (Test-Path -Path $jsonFilePath)) {
+                throw "Analyzer template file not found: $jsonFilePath"
+            }
+
+            # Load the JSON template
+            $jsonContent = Get-Content -Path $jsonFilePath -Raw | ConvertFrom-Json
+
+            # Check if the versionPrefix is different from the current defaultValue
+            if ($versionPrefix -ne $jsonContent.symbols.MicrosoftBuildVersion.defaultValue) {
+                # Update the defaultValue of MicrosoftBuildVersion in the JSON template
+                $jsonContent.symbols.MicrosoftBuildVersion.defaultValue = $versionPrefix
+        
+                # Convert the JSON content back to a string
+                $jsonString = $jsonContent | ConvertTo-Json -Depth 10
+        
+                # Write the updated JSON back to the file
+                Set-Content -Path $jsonFilePath -Value $jsonString
+                Write-Output "Updated MicrosoftBuildVersion to $versionPrefix"
+        
+                # Set the updateNeeded output variable to true
+                $updateNeeded = "true"
+            } else {
+                Write-Output "No update needed. MicrosoftBuildVersion is already $versionPrefix"
+        
+                # Set the updateNeeded output variable to false
+                $updateNeeded = "false"
+            }
+
+            # Set the versionPrefix and template filePath as an output
+            Add-Content -Path $env:GITHUB_ENV -Value "versionPrefix=$versionPrefix"
+            Add-Content -Path $env:GITHUB_ENV -Value "jsonFilePath=$jsonFilePath"
+            Add-Content -Path $env:GITHUB_ENV -Value "updateNeeded=$updateNeeded"
+            Write-Output "Extracted versionPrefix: $versionPrefix"
+            Write-Output "Extracted jsonFilePath: $jsonFilePath"
+            Write-Output "Update needed: $updateNeeded"
+        }
+        catch {
+            Write-Error "An error occurred: $_"
+        }
+
+    - name: Create Pull Request
+      if: env.updateNeeded == 'true'
+      uses: actions/github-script@v7
+      with:
+        script: |
+          const baseBranch = process.env.baseBranch;
+          const versionPrefix = process.env.versionPrefix;
+          const filePath = process.env.jsonFilePath;
+          const newBranch = `${baseBranch}-update-msbuild-version-for-analyzer-template`;
+          const commitMessage = `Update MicrosoftBuildVersion to ${versionPrefix}`;
+          const prBody = '[Automated] Update the MicrosoftBuildVersion defaultValue in the template.json.';
+          const prTitle = 'Update MicrosoftBuildVersion in analyzer template';
+          
+          // Main execution
+          (async () => {
+            try {
+              // Configure git
+              await configureGit();
+          
+              // Create and switch to the new branch
+              await createAndSwitchBranch(newBranch);
+          
+              // Check if the branch PR already exists on the remote
+              const shouldOpenPullRequest = await checkBranchPRExists(newBranch,baseBranch);
+          
+              // Stage and commit the changes
+              await stageAndCommitChanges(filePath, commitMessage);
+          
+              // Push the new branch to the repository
+              await pushBranch(newBranch);
+          
+              // Create the pull request if needed
+              if (shouldOpenPullRequest) {
+                await createPullRequest(baseBranch, newBranch, prTitle, prBody);
+              } else {
+                console.log("The PR already exists, skipping opening a new PR.");
+              }
+            } catch (error) {
+              core.setFailed(error);
+            }
+          })();
+          
+          async function configureGit() {
+            await exec.exec(`git config user.name "github-actions"`);
+            await exec.exec(`git config user.email "github-actions@github.com"`);
+          }
+          
+          async function createAndSwitchBranch(branch) {
+            await exec.exec('git', ['checkout', '-b', branch]);
+          }
+          
+          async function checkBranchPRExists(newBranch,baseBranch) {
+            // Check if a pull request already exists
+            const { data: pullRequests } = await github.rest.pulls.list({
+              owner: context.repo.owner,
+              repo: context.repo.repo,
+              head: newBranch,
+              base: baseBranch,
+              state: 'open',
+            });
+          
+            if (pullRequests.length === 0) {
+              return true;
+            } else {
+              return false;
+            }
+          }
+          
+          async function stageAndCommitChanges(filePath, commitMessage) {
+            await exec.exec(`git add ${filePath}`);
+            await exec.exec(`git commit -m "${commitMessage}"`);
+          }
+          
+          async function pushBranch(branch) {
+            await exec.exec(`git push --force --set-upstream origin HEAD:${branch}`);
+          }
+          
+          async function createPullRequest(baseBranch, newBranch, title, body) {
+            await github.rest.pulls.create({
+              owner: context.repo.owner,
+              repo: context.repo.repo,
+              title: title,
+              body: body,
+              head: newBranch,
+              base: baseBranch
+            });
+          }
diff --git a/documentation/High-level-overview.md b/documentation/High-level-overview.md
index 0f31a36c077..4ee9aaa9e30 100644
--- a/documentation/High-level-overview.md
+++ b/documentation/High-level-overview.md
@@ -1,39 +1,39 @@
 # What is MSBuild
 MSBuild is a build platform used mainly for .NET and Visual Studio. When referencing MSBuild technically we can divide what MSBuild is in a few main parts:
-- Programming language that uses XML semantics to define build actions and data.
+- Programming language that uses XML to define build actions and data.
 - A standard set of scripts authored in the MSBuild language (so called 'common targets') that are shipped together with the MSBuild binaries and that define what a build process means.
-- API and command line interface that interprets and manipulates the programming language.
+- API and command line interface that interprets and requests results from programs written in the programming language.
 - Build engine that executes a build based on the programming language inputs.
 
-MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.
+MSBuild is extensible via XML and .NET plugins. These are built to increase customization and interaction capability.
 
 This document covers all parts of MSBuild in a general manner from the perspective of an MSBuild codebase maintainer. There will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit Microsoft Learn's [MSBuild documentation](https://learn.microsoft.com/visualstudio/msbuild).
 
 
 # MSBuild XML Language
-The MSBuild markup language is a subset of XML with a focus on describing a project. An advanced example of this, is our own MSBuild executable's [project here](../src/MSBuild/MSBuild.csproj).
+The MSBuild markup language is a subset of XML with a focus on describing a project. An advanced example of this is our own [MSBuild executable's project](../src/MSBuild/MSBuild.csproj).
 
-The MSBuild XML is built around representing a project's data. It uses various elements to do so:
+An MSBuild project file primarily declares a project's data. It uses various XML elements to do so:
+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used within the project.
 - [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are data enumerations, where single element is a string value with optional enumeration of key-value strings - so called `metadata`. `Items` represent project files, code files, libraries and most things that a project can depend on. Together with `Properties`, `Items` are data inputs to the build system - mostly to tasks or targets.
-- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.
 - [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-tasks) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Many tasks are defined within MSBuild itself, but tasks can also be authored by third parties by implementing the `ITask` interface.
-- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.
+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to execute. Targets can be ordered relative to other targets.
 
-These attributes are defined within project files (`.csproj`, `.vbproj` etc.). The solution files (`.sln`) are not written with MSBuild XML. They are originally exclusive to Visual Studio and yet the MSBuild command-line application can parse them to find projects to build. It does so by converting the solution file to a MSBuild project file in-memory and acts upon it instead.
+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). Solution files (`.sln`) are not an MSBuild XML format. They are originally exclusive to Visual Studio, but the MSBuild command-line application can parse them to find projects to build.
 
 While the project file defines the data used for the build, the actual build instructions are generally imported from a common location through the `Import` element or [MSBuild SDKs](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk) that contain their own tasks and targets. One example that is widely used is the [`Microsoft.NET.Sdk`](https://learn.microsoft.com/dotnet/core/project-sdk/overview) from the .NET SDK.
 
 
 # Common Targets
-MSBuild has some Common Targets that adds functionalites to the build and interactictions with the XML projects. This functionality includes build management, like the creation and management of output folders and intermidiary folders, and custom task creation, etc...
+MSBuild has some Common Targets that adds baseline functionality to the build. This functionality includes build management, like the creation and management of output folders and intermediary folders, defining a project's “primary output”, implementing the [`ProjectReference` protocol](ProjectReference-Protocol.md), and so on.
 
-Visual Studio also uses common targets to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly. Some use cases for Visual Studio also include:
-- Population of the Solution Explorer window. Which projects and files need to be added to the view of the complete solution.
-- Executing design-time builds to populate language services.
+Visual Studio also depends on the common targets to enable configuring the build through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly. Some use cases for Visual Studio also include:
+- Population of the Solution Explorer window. For each project, what files need to be added to the view of the complete solution.
+- Executing [design-time builds](https://github.com/dotnet/project-system/blob/500720852f21ac8496390827881eabe4d718c5e2/docs/design-time-builds.md) to extract more detailed information for Visual Studio components like language services.
 
 
 # MSBuild API
-The MSBuild API is .NET library with a focus on building and fetching data from MSBuild projects. It is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. This API is also available for any third parties to use.
+The MSBuild API is a .NET library that can build, fetch data from, and edit MSBuild projects. It is used by Visual Studio and the .NET SDK to integrate MSBuild as their project build system. This API is also available for any third parties to use.
 
 
 # Engine
@@ -54,7 +54,7 @@ flowchart LR
     API([API])
     end
     
-    subgraph API inputs
+    subgraph API consumers
     VS[Visual Studio] --> API
     SDK[.NET SDK] --> API
     NC[NuGet Client] --> API
@@ -67,7 +67,7 @@ flowchart LR
     EN --IPC--> WN[Worker Nodes]
     WN <--IPC--> TH[Task Host]
     L[Loggers] --> EN
-    FW[Forwarding Loggers] --> WN
+    WN --> FW[Forwarding Loggers] --> EN
 ```
 
 ## Entry points
@@ -79,9 +79,7 @@ The inputs necessary to start a build include:
  - The generated build imports (`.g.props` and `.g.targets`) from NuGet restore.
 
  ```mermaid
-flowchart TD
-    UI[User specific imports]
-    
+flowchart TD    
     UL["`User defined import logic
     _.props_ and _.targets_`"]
     
@@ -94,7 +92,6 @@ flowchart TD
     NI["`NuGet imports
     _.g.props_ and _.g.targets_`"]
 
-    UI --> PROJ
     UL --> PROJ
     IL --> PROJ
     NI --> PROJ
@@ -104,12 +101,12 @@ An example of the imported build logic is the `<Project Sdk="Microsoft.NET.Sdk">
 
 More on this in the [Restore](#restore) section below.
 
-## Evaluate operation
+## Project Evaluation
 For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).
 
-Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking the entry point project for imports, items, and tasks. Some API consumers, like Visual Studio project systems, extract information about which C# files, solution files and project files are relevant to a project after evaluation.
+Evaluation of a project is the first step of the process. Its main objective is to collect information on the project being built. This includes checking the entry point project for imports, items, and tasks. Some API consumers, like Visual Studio project systems, extract information about which C# files, solution files and project files are relevant to a project after evaluation.
 
-The first step of evaluation is to load the project file and the XML data it contains. There are multiple evaluation passes within the same project, each is responsible for evaluating a different type of data is required for subsequent passes. Data within the evaluation can be modified depending on the pass the build is currently executing. For example, during the pass that evaluated imports and properties, properties can be modified, but after the pass is done the properties are read-only until the execution phase.
+The first step of evaluation is to load XML project file. There are multiple evaluation passes within the same project; each is responsible for evaluating a different type of data that may be required for subsequent passes. Data within the evaluation can be modified depending on the pass the build is currently executing. For example, during the pass that evaluates imports and properties, properties can be modified, but after that pass is done the properties are read-only until the execution phase.
 
 ```mermaid
 ---
@@ -117,34 +114,34 @@ title: Evaluation passes
 ---
 flowchart LR
     PE[Project evaluation] --> 
-    EV[Environmental variables] --> 
+    EV[Environment variables] --> 
     IP[Imports and Properties 
-    outisde targets] -->
-    ID[Item definition] -->
-    IO[Items outside tagets] -->
-    UE[UsingTask elements] -->
+    outside targets] -->
+    ID[Item definitions] -->
+    IO[Items outside targets] -->
+    UE[UsingTasks] -->
     T[Targets]
 ```
 
-At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brought within the project logic, so other projects can refence the same import logic instead of having a copy of it.
+Evaluation may occur before or after NuGet restore has run. Since NuGet packages can contain build logic, the pre-restore evaluation should be used only to run restore. After restore, all imports are files on disk and are processed as paths by the engine.
 
-The evaluation stage should not have any side effect on disk, no new or deleted files. One exception is the SDK resolution phase. The built-in MSBuild SDK resolver just looks for SDKs already installed or existing on disk. But, MSBuild also has support for custom resolvers that can run arbitrary .NET Code such as referencing SDKs through a Network Share or fetching SDK packages from a remote server.
+The evaluation stage should not have any side effect on disk, no new or deleted files. One exception is the SDK resolution phase. The .NET SDK resolver looks for SDKs already installed or existing on disk. But MSBuild also has support for resolvers that can run arbitrary .NET code such as referencing SDKs through a network share or fetching SDK packages from a remote server.
 One such resolver that comes with the .NET SDK and Visual Studio is the NuGet's MSBuild SDK resolver (`Microsoft.Build.NuGetSdkResolver`) which downloads the SDK packages from NuGet repositories to local storage.
 
 ### Imports
-In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.
+In MSBuild imports are all treated like a property plus path expansion, however they can take various forms when being defined - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports.
 
 Historically a single version of MSBuild supported multiple `ToolsVersions` that could result in differing imports for the same expression, but today an MSBuild distribution provides only the current version of `ToolsVersion` and selection between versions is expected to be done outside of MSBuild.
 
-## Execution operation
+## Project Execution
 For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#execution-phase).
 
-The execution phase is simply executing a request that contains a list of targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes. During execution, if a target that is being executed changes attributes or properties from another target, the final execution order might change due to the dependency chain changing. The full executing order can be [found here](https://learn.microsoft.com/visualstudio/msbuild/target-build-order#determine-the-target-build-order).
+The execution phase starts with a request to build a list of targets defined in the project (in its own XML or an import). Those targets and their prerequisite targets will then execute. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes as it depends on more things during a build. The full executing order can be [found here](https://learn.microsoft.com/visualstudio/msbuild/target-build-order#determine-the-target-build-order).
 
-Another target order issue arises when there is a project dependency. Project dependencies are dicovered during target execution, so targets can start executing in a certain order, hit a project dependency that has not been completed yet. In this case, the node that is processing the targets will be considered blocked, and will pause the current execution to start another project. Once the dependencies have been fullfilled, the original build resumes and the target execution will continue in the original order.
+Another target order issue arises when there is a project dependency. Project dependencies are expressed using the `MSBuild` task, so a project target can start executing and then hit a project dependency that has not been completed yet. In this case, the project that is processing the targets will be considered blocked, and will pause its execution (the node building it may be used to work on another project). Once the dependencies have been fullfilled, the original build can resume resume and the target execution will continue in the original order.
 
 ### Task Host
-MSBuild has an ability to run tasks out of process via the so called Task Host. That allows tasks to run in a different .NET runtime or bitness than the one used by the build engine for the build execution.
+MSBuild generally runs tasks in its own process, but has an ability to run tasks out of process via the “task host”. That allows tasks to run in a different .NET runtime or processor architecture than the one used by the build engine for the build execution.
 
 A specific task host is automatically selected when a task explicitly declares the need for a specific runtime or architecture that is different from the one used by the executing MSBuild engine. The runtime and architecture can be requested via `Runtime` and `Architecture` attributes in [`UsingTask`](https://learn.microsoft.com/visualstudio/msbuild/usingtask-element-msbuild) element defining the task or in the [`Task`](https://learn.microsoft.com/visualstudio/msbuild/task-element-msbuild) element used for task invocation.
 
@@ -162,53 +159,56 @@ There is also another Project Cache Plugin, which focuses on result cache in dis
 During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.
 
 ### Incremental Build Cache
-The build incrementality is controled by individual `Tasks` and `Targets`. Those can define their `Inputs` and `Outputs` - and if both specified, MSBuild engine will control if `Outputs` are up-to-date via checking presence of specified files and file system update timestamps (and if outputs have newer timestamps - they are considered up to date) and skip execution of such `Tasks` or/and `Targets` that are deemed up to date.
+The build incrementality is controled by individual `Tasks` and `Targets`. Targets can define their `Inputs` and `Outputs` - and if both specified, MSBuild engine will skip execution of `Targets` that are deemed up to date. Tasks may also internally implement incremental behavior.
 For this reason many `Targets` in the MSBuild SDK, that perform intermediate operations, specifies explicit `Inputs` and `Outputs` - while flushing the outputs usually into `IntermediateOutputDirectory` (AKA the 'obj' directory). This helps to follow the incrementality of the build. The `IntermediateOutputDirectory` can hence be regarded as the incremental build cache - though it's not any centraly managed cache with a single de/serialization mechanism. Each Target controls the way how it wants to create and read the intermediate files. The Targets within MSBuild SDK store only up front know data types (no type information is being stored into the cache).
 
 #### RAR Cache
-Special case of incremental build cache within the `IntermediateOutputDirectory` is a `ResolveAssemblyReference` (RAR) cache.
-[`ResolveAssemblyReference`](../../src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs) (RAR) is one of the most important tasks in the MSBuild toolset. It is responsible for obtain all references needed to build the project and resolve the full paths to the assemblies representing those references (so that the compiler task can operate on a deterministic, fully defined, input). For more information on RAR please see [the RAR documentation](../documentation/wiki/ResolveAssemblyReference.md).
-RAR stores the resolved information in the `obj` folder (pointed via `IntermediateOutputDirectory` property) in the files with configurable name with '.cache' extension. The cache content is de/serialized via MSBuild proprietary de/serialization protocol (AKA `ITranslatable`), that requires exact upfront knowledge of the types being de/serialized (means - no type information is being exchanged).
+A special case of incremental build cache within a task implementation is the `ResolveAssemblyReference` (RAR) cache.
+[`ResolveAssemblyReference`](../../src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs) (RAR) is one of the most important tasks in the MSBuild toolset. It is responsible for computing the closure of all references needed to build the project and resolving the full paths to the assemblies representing those references (so that the compiler task can operate on a fully defined input). For more information on RAR please see [the RAR documentation](../documentation/wiki/ResolveAssemblyReference.md).
+To speed subsequent runs over identical or almost-identical inputs, RAR stores assembly information in an intermediate file. The cache content is de/serialized via a custom MSBuild serialization protocol (`ITranslatable`).
 
 ## Scheduler
-The scheduler is the part of the MSBuild engine responsible for scheduling work, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a worker node (generally the in-proc node). The project's execution starts and proceeds until the whole project ends or is blocked. A project is considered blocked, when the project that it is currently building depends on another project that has not yet finished executing. Once a node is not proceeding with the current project, the scheduler then asseses if it has more work to be given to that node and assigns it.
+The scheduler is the part of the MSBuild engine responsible for scheduling work, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a worker node (generally the in-proc node). The project's execution starts and proceeds until the whole project ends or is blocked. A project is considered blocked when the project that it is currently building depends on another project that has not yet finished executing. When a node becomes free because it has completed its project or its project is blocked, the scheduler then assesses if it has more work to be given to that node and assigns it.
 
-On a project's operation end and returned result, it sends that information to the scheduler. The scheduler maintains results of all of the build's executed requests, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache.
+When a build request completes, the result is sent to the scheduler. The scheduler maintains results of all of the build's executed requests, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. This means that a project can be built only once even if referenced by many projects.
 
-If the node's operation is blocked by a dependency, it asks the scheduler for the results of the dependency's execution. If the dependency has been executed, the result is retrieved from the Project Result Cache. If the process has not been executed, the scheduler suspends the current project, making the target / project a pending request. When a request is pending, the scheduler adds to the list of requests to execute, and will eventually assign the dependency to be executed to either the current node or another one that is free.
+If the node's operation is blocked by a dependency, it asks the scheduler for the results of the dependency's execution. If the dependency has been executed, the result is retrieved from the Project Result Cache. If the process has not been executed, the scheduler suspends the current project, making the target / project a pending request. When a request is pending, the scheduler adds to the list of requests to execute, and will eventually assign the dependency to be executed on either the current node or another one that is free.
 
 ```mermaid
----
-title: Build where project A depends on project B
----
 flowchart TD
-   A1[Build Request] --Project A--> S1[Scheduler]
+   A1[Build Request] --> S1[Scheduler]
+   
    S1 --> C1{Is cached}
-   C1 ---Yes1[Yes]--> Result1[Return result]
-   C1 ---No1[No]--> Build1[Build Project A]
-   Build1 --Dependency identified--> PB1[Project B]
-   PB1 --Request Build--> S1
+   C1 --Yes--> Result1[Return result]
+   C1 -- No --> Build1[Build Project]
+
+   Build1 --> HD{Has 
+   Dependency}
+   HD --No --> PF[Project Finished]
+   HD --Yes --> DI[Identify Project Dependency]
+
+   DI --Request Dependency Build--> S1
 ```
 
 ### Incremental build
 Incremental builds are extremely useful for local development, as it speeds consecutive builds on local machines. For this, the output from build targets is persisted to disk, which becomes one big cache for MSBuild.
 
 ## Parallelism
-Parallelism for MSBuild is implemented at project level. Each project is assigned to different working nodes, which will execute the tasks at the same time, with the Scheduler organizing sequence and work division. Within project targets run sequentially, however they can have parallelism implemented independently within tasks.
+Parallelism for MSBuild is implemented at the project level. Each project is assigned to a specific worker node, and the worker nodes will execute the project build in parallel, with the Scheduler organizing sequence and work division. Within project builds, targets run sequentially and within targets, tasks run sequentially; however a task can maintain its own internal parallelism.
 
-For multi-targeted builds parallelism is a specific case with some extra work before the build. The outer build produces a list of projects to build. This list contains the same project file with a different metadata for the target framework. This list is then passed to the MSBuild execute target so it can be built in parallel.
+For multi-targeted builds parallelism between TargetFrameworks is enabled by creating distinct projects for each "inner build" from an "outer build". The outer build produces a list of projects to build. This list contains the same project file with a different global property for the target framework. This list is then passed to the MSBuild execute target so the TargetFrameworks can be built in parallel.
 
 ### Processes and nodes
 When a new build is started, MSBuild starts a process that runs some setup code and prepares itself to start a build. The process of defining the scheduler differs slightly depending on the environment the build is being executed. 
 
-In the case of a CLI build the first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build finishes execution, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. 
+In the case of a CLI build the process that starts the build becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build finishes execution, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. 
 
-This has been partially addressed by the long lived worker nodes feature (AKA 'nodes reuse'), where the worker nodes keeps alive and can be reused by multiple build requests. The main node (with scheduler, loggers, etc.) is still being teared down. In the case of a Visual Studio build, that uses the MSBuild API to manage the builds, this problem has been solved by having the scheduler process be separate from the Main Visual Studio (`devenv.exe`) process and keeping it very long lived. In case of CLI and experimental feature - [`MSBuild Server`](#msbuild-server) has been authored to address this gap by keeping the main node alive between build requests as well.
+This has been partially addressed by the long lived worker nodes feature (AKA 'node reuse'), where the worker nodes stay idle in the background for some time and can be reused by multiple build requests. The main node (with scheduler, loggers, etc.) is still torn down. In the case of a Visual Studio build that uses the MSBuild API to manage the builds, this problem has been solved by having the scheduler process be within the main Visual Studio process (`devenv.exe`) and keeping it very long lived. In case of CLI an experimental feature - [`MSBuild Server`](#msbuild-server) tries to address this gap by keeping the main node alive between build requests as well.
 
 
 ## IPC (Inter-Process Communication)
 In multi-process MSBuild execution, many OS processes exist that need to communicate with each other. There are two main reasons:
- - Dealing with blocked tasks on processes: Communicating with the engine, scheduler, cache, etc...
+ - Dealing with Build Result data: Communicating with the engine, scheduler, cache, etc...
  - Communication on task execution for a task host: Task definition, task inputs, task outputs.
 
 The transport layer for messages is a [.NET named pipe](https://learn.microsoft.com/dotnet/standard/io/how-to-use-named-pipes-for-network-interprocess-communication).
@@ -220,7 +220,7 @@ A graph build changes the sequence in which MSBuild processes projects. Normally
 
 There are a couple of different modes to run graph mode in (see [the spec](../documentation/specs/static-graph.md#what-is-static-graph) for more details):
 - Standard mode (`-graph`): Tried to work from the leaves of the dependency graph and makes sure all results are within the cache. If there is a cache miss / unexpected reference, it just schedules the missing reference for execution.
-- Strict / isolate mode (`-graph -isolate`): If there is a cache miss when building, the whole build is failed. This can be used when the graph of the build is fully known upfront and is not expected to change. Avoiding the need for dynamic resolution of dependencies can lead to improved scheduling and caching. Usually a first run with `-graph` is needed on initial run or on dependencies changes in order to construct/refresh the graph and to be able to consequently run in a strict mode.
+- Strict / isolate mode (`-graph -isolate`): If there is a cache miss when building, the whole build is failed.
 - Single project isolated mode: This is not directly invokable by users, instead it is used from higher order build systems to achive distributed / cached builds (in which the individual projects need to run in isolation from their dependencies - as those can be pulled from distributed cache or scheduled to run on different computation nodes).
 
 ## MSBuid Server
@@ -228,32 +228,32 @@ In normal MSBuild command-line build execution the main process exists after the
 For more information please see [the spec](../documentation/MSBuild-Server.md).
 
 # Extensibility
-MSBuild includes some extra features that are related to the build process but does not fit on the previous categories. These extensibility features are critical for the build process, but they can also be customized by third parties for their own use.
+MSBuild includes some features that are related to the build process but do not fit in the previous categories. These extensibility features are critical for the build process, but they can also be customized by third parties for their own use.
 
-## Packaging system
+## Packaging
 MSBuild interacts with external packages in almost every build. However, the MSBuild engine does not recognize external packages as third parties, and it also does not handle external dependencies. This is done by a packaging system. The supported one being NuGet. As such, it is NuGet that is responsible for finding the packages, downloading them, and providing the MSBuild engine with a package path for the build.
 
 ## Restore
-The restore operation is a built-in target, and it executed as any other target within MSBuild. The main function is to walk through the project references and `packages.config` file about all the packages that need to be restored. This process might result in new or updated files in disk, as well as new imports to the build process. The packaging system is handled by NuGet, it includes finding project references, downloading and adding packages to the right place in memory for MSBuild access.
+The restore operation is defined as a no-op in common targets, but provided by NuGet in Visual Studio and .NET SDK. It is executed as any other target within MSBuild. The restore operation walks through the project references and package references to determine information about all the packages that need to be restored. This process might result in new or updated files on disk, as well as new imports to the build process.
 
 ## Tasks
-An [msbuild task](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) is a unit of executable code used by MSBuild to perform atomic build operations. There are many build-in tasks living in [`Microsoft.Build.Tasks`](../src/Tasks/README.md) package. Tasks can also be authored by third parties by implementing the `ITask` interface, please see documentation on [Task Writing](https://learn.microsoft.com/visualstudio/msbuild/task-writing).
+An [msbuild task](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) is a unit of executable code used by MSBuild to perform build operations. There are many built-in tasks living in the [`Microsoft.Build.Tasks`](../src/Tasks/README.md) assembly. [Tasks can also be authored by third parties](https://learn.microsoft.com/visualstudio/msbuild/task-writing) by implementing the `ITask` interface.
 
-Implemented tasks also have additional fields that can have access to .NET functions to be executed during the task. So it is possible to do anything that is publicly available in .NET during task execution.
+Since a task can be delivered as a .NET assembly, it is possible to run arbitrary code during task execution.
 
 ### ToolTask
-Users can implement custom tasks via arbitrary .NET code, and MSBuild provides helper classes for common use cases like "build a command line for and then run a command-line tool".
+`ToolTask` is a widely-used helper class for the use case "build a command line for and then run a command-line tool".
 
 ## Diagnosability / Loggers
-Diagnosability within MSBuild went through some changes. Before we had a debugger in additional to basic logs, where you could step through the XML during the build and debug. This was discarded in favor of a log focused approach, where MSBuild has a more robust logging system that contains more data to identify what is happening during a build.
+Current diagnosability within MSBuild follows a log focused approach, where MSBuild has a more robust logging system that contains more data to identify what is happening during a build.
 
 ### General Loggers
 Logging within MSBuild consists of various integrated and third-party loggers. Both use the [`ILogger`](https://learn.microsoft.com/dotnet/api/microsoft.build.framework.ilogger) API. Built-in loggers include the Binary Logger which produces compressed `.binlog` files, the Console and Terminal loggers for interactive output, and a Text Log. Third party loggers  receive events through `ILogger`, and multiple loggers can be connected to a single build.
 
-Third-party loggers must be specified before the build begins. Because of this, build logic (and NuGet) is not able to manipulate loggers.
+Loggers must be specified before the build begins. Because of this, build logic (and NuGet) is not able to manipulate loggers.
 
 ### Binary logger
-The Binary Logger, also called binlog, is a structured log that captures all the events within a build as well as files that are critical to the build. To read a binlog, the MSBuild executable (`MSBuild.exe` in Windows, and `msbuild` in unix) can replay the events through arbitrary loggers, and third-party tooling like the [Structured Log Viewer](https://msbuildlog.com) can also read binlogs, but it is not officially supported by the MSBuild team.
+The Binary Logger, also called binlog, is a structured log that captures all the events within a build as well as files that are critical to the build. To read a binlog, the MSBuild CLI can replay the events through arbitrary loggers, and third-party tooling like the [Structured Log Viewer](https://msbuildlog.com) can also read binlogs.
 
 
 ## Project result cache plugin
@@ -266,7 +266,7 @@ BuildCheck is new MSBuild extensible and configurable linting/diagnostic feature
 For more information please see [the spec](../documentation/specs/BuildCheck/BuildCheck.md).
 
 ## Resolvers
-There are a few elements within the MSBuild XML that indicate that a call to the .NET SDK is necessary. When such interaction is necessary for a project build, the first thing that needs to be done is to figure out where the SDK is installed so MSBuild can access the content. This is solved by resolvers, which look for the SDK version that was specified, or gets the latest version.
+There are a few elements within the MSBuild XML that indicate that a call to the .NET SDK is necessary. When such interaction is necessary for a project build, the first thing that needs to be done is to figure out where the SDK is installed so MSBuild can access the content. This is solved by resolvers, which look for the SDK version that was specified, or gets the latest version by looking for them on the folder adjacent to where MSBuild is executing from.
 
 To read more about SDK resolver you can check the [Microsoft Learn page](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk#how-project-sdks-are-resolved), or see the [spec documentation](specs/sdk-resolvers-algorithm.md).
 
@@ -276,4 +276,4 @@ MSBuild has a few telemetry points, mostly through the .NET SDK. It is implement
 Visual Studio telemetry was removed once MSBuild went open source, and it was never added again.
 
 ## FileTracker
-In order to automatically detect task inputs and outputs, MSBuild can intercept Windows I/O API calls to track the dependencies. A [FileTracker](https://github.com/dotnet/msbuild/blob/main/src/Utilities/TrackedDependencies/FileTracker.cs) utility is used to accomplish this. For more information please see [the spec](../documentation/specs/static-graph.md#detours).
+In order to automatically detect task inputs and outputs, MSBuild can intercept Windows I/O API calls to track the dependencies. A [FileTracker](https://github.com/dotnet/msbuild/blob/main/src/Utilities/TrackedDependencies/FileTracker.cs) utility is used to accomplish this. It uses [Detours](https://github.com/microsoft/detours) to inject logging code when a tracked application performs filesystem operations.
diff --git a/documentation/specs/BuildCheck/BuildCheck-Architecture.md b/documentation/specs/BuildCheck/BuildCheck-Architecture.md
index d51504ad8f4..87c6a30b30e 100644
--- a/documentation/specs/BuildCheck/BuildCheck-Architecture.md
+++ b/documentation/specs/BuildCheck/BuildCheck-Architecture.md
@@ -11,8 +11,8 @@ This is an internal engineering document. For general overview and user point of
 | Advisory/Leadership | @rainersigwald |
 | Infrastructure      | @jankrivanek |
 | Configuration       | @f-alizada   |
-| Custom Analyzers    | @YuliiaKovalova |
-| Inbox Analyzers     | @ladipro |
+| Custom Checks       | @YuliiaKovalova |
+| Inbox Checks        | @ladipro |
 | Replay Mode         | @surayya-MS |
 | Tracing             | @maridematte |
 | Perf Advisory       | @AR-May |
@@ -47,29 +47,29 @@ In both cases the sink for the data is actualy a `LoggingContext` - this is to e
 
 #### Sample in-node data case - evaluated project
 
-One example of rich data that might be helpful for internal analyses is [`Project`](https://github.com/dotnet/msbuild/blob/28f488a74ed75bf5f21ca93ac2463a8cb1586d79/src/Build/Definition/Project.cs#L49). This OM is not currently being used during the standard build execution (`ProjectInstance` is used instead) - but we can conditionaly create and expose `Project` and satisfy the current internal consumers of `ProjectInstance` - spike of that is available [in experimental branch](https://github.com/dotnet/msbuild/compare/main...JanKrivanek:msbuild:research/analyzers-evaluation-hooking#diff-08a12a2fa138c3bfcabc7639bb75dda8534f3b662db4aca4f2b5595dbf9ba197).
+One example of rich data that might be helpful for internal checks is [`Project`](https://github.com/dotnet/msbuild/blob/28f488a74ed75bf5f21ca93ac2463a8cb1586d79/src/Build/Definition/Project.cs#L49). This OM is not currently being used during the standard build execution (`ProjectInstance` is used instead) - but we can conditionaly create and expose `Project` and satisfy the current internal consumers of `ProjectInstance` - spike of that is available [in experimental branch](https://github.com/dotnet/msbuild/compare/main...JanKrivanek:msbuild:research/analyzers-evaluation-hooking#diff-08a12a2fa138c3bfcabc7639bb75dda8534f3b662db4aca4f2b5595dbf9ba197).
 
 ## Execution Modes
 
-**Replay Mode** - so that users can choose to perform analyses post build, without impacting the performance of the build. And so that some level of analysis can be run on artifacts from builds produced by MSBuild from NET 9.0 / VS 17.12 or newer. The older versions won't be supported.
+**Replay Mode** - so that users can choose to perform checks post build, without impacting the performance of the build. And so that some level of checking can be run on artifacts from builds produced by MSBuild from NET 9.0 / VS 17.12 or newer. The older versions won't be supported.
 
-**Live mode** - this is what users are used to from compilation analyses. Integrating into build execution will as well help driving adoption by opting-in users by default to some level of checking and hence exposing them to the feature.
+**Live mode** - this is what users are used to from compilation checks. Integrating into build execution will as well help driving adoption by opting-in users by default to some level of checking and hence exposing them to the feature.
 
 ## Live Mode Hosting
 
 Prerequisites: [MSBuild Nodes Orchestration](../../wiki/Nodes-Orchestration.md#orchestration)
 
 The BuildCheck infrastructure will be prepared to be available concurrently within the `scheduler node` as well as in the additional `worker nodes`. There are 2 reasons for this:
-* BuildCheck will need to recognize custom analyzers packages during the evaluation time - so some basic code related to BuildCheck will need to be present in the worker node.
-* Presence in worker node (as part of the `RequestBuilder`), will allow inbox analyzers to agile leverage data not available within `BuildEventArgs` (while data proven to be useful should over time be exposed to `BuildEventArgs`)
+* BuildCheck will need to recognize custom check packages during the evaluation time - so some basic code related to BuildCheck will need to be present in the worker node.
+* Presence in worker node (as part of the `RequestBuilder`), will allow inbox checks to agile leverage data not available within `BuildEventArgs` (while data proven to be useful should over time be exposed to `BuildEventArgs`)
 
 ## Replay Mode
 
 Prerequisites: [MSBuild Replaying a Binary Log](../../wiki/Binary-Log.md#replaying-a-binary-log)
 
-When replaying a binary log, we can apply BuildCheck with help of `-analyze` switch:
+When replaying a binary log, we can apply BuildCheck with help of `-check` switch:
 ```
-> msbuild.exe msbuild.binlog -analyze
+> msbuild.exe msbuild.binlog -check
 ```
 
 If BuildCheck is enabled, then the events from `BinaryLogReplayEventSource` and new events from BuildCheck are merged into the `IEventSource`, from which the loggers get events.
@@ -89,36 +89,36 @@ flowchart TD
 
 ## Handling the Distributed Model
 
-We want to get some benefits (mostly inbox analyzers agility) from hosting BuildCheck infrastructure in worker nodes, but foremost we should prevent leaking the details of this model into public API and OM, until we are sure we cannot achieve all goals from just scheduler node from `BuildEventArgs` (which will likely never happen - as the build should be fully reconstructable from the `BuildEventArgs`).
+We want to get some benefits (mostly inbox checks agility) from hosting BuildCheck infrastructure in worker nodes, but foremost we should prevent leaking the details of this model into public API and OM, until we are sure we cannot achieve all goals from just scheduler node from `BuildEventArgs` (which will likely never happen - as the build should be fully reconstructable from the `BuildEventArgs`).
 
 How we'll internally handle the distributed model:
 * Each node will have just a single instance of infrastructure (`IBuildCheckManager`) available (registered via the MSBuild dependency injection container - `IBuildComponentHost`). This applies to a scheduler node with inproc worker node as well.
 * Scheduler node will have an MSBuild `ILogger` registered that will enable communicating information from worker nodes BuildCheck module to the scheduler node BuildCheck module - namely:
-    * Acquisition module from worker node will be able to communicated to the scheduler node that it encountered `PackageReference` for particular analyzer and that it should be loaded and instantiated in the main node.
+    * Acquisition module from worker node will be able to communicated to the scheduler node that it encountered `PackageReference` for particular check and that it should be loaded and instantiated in the main node.
     * Tracing module will be able to send perf stats from current worker node and aggregate all of those together in the main node.
-    * Theoretical execution-data-only sourcing inbox analyzer will be able to aggregate data from the whole build context (again - we should use this only for agility purposes, but shoot for analyzer that needs presence only in scheduler node). The way to do that can be via being present in all worker nodes, sending a specific type of 'in progress result' BuildEventArgs and aggreggating those intermediary results in the single instance running in the main node.
-* Apart from the scenarios above - the BuildCheck infrastructure modules in individual nodes should be able to function independently (namely - load the inbox analyzers that should live in nodes; send the analyzers reports via logging infrastructure; load user configuration from `.editorconfig` and decide on need to enable/disable/configure particular analyzers).
-* The custom analyzers will be hosted only in the main node - and hence the distributed model will be fully hidden from them. This might be a subject for revision in future versions.
+    * Theoretical execution-data-only sourcing inbox check will be able to aggregate data from the whole build context (again - we should use this only for agility purposes, but shoot for check that needs presence only in scheduler node). The way to do that can be via being present in all worker nodes, sending a specific type of 'in progress result' BuildEventArgs and aggreggating those intermediary results in the single instance running in the main node.
+* Apart from the scenarios above - the BuildCheck infrastructure modules in individual nodes should be able to function independently (namely - load the inbox checks that should live in nodes; send the checks reports via logging infrastructure; load user configuration from `.editorconfig` and decide on need to enable/disable/configure particular checks).
+* The custom checks will be hosted only in the main node - and hence the distributed model will be fully hidden from them. This might be a subject for revision in future versions.
 * Communication from main to worker node between BuildCheck infra modules is not planned (this might be revisited - even for the V1).
 
-## Analyzers Lifecycle
+## Check Lifecycle
 
 Planned model:
-* Analyzers factories get registered with the BuildCheck infrastructure (`BuildCheckManager`)
-    * For inbox analyzers - this happens on startup.
-    * For custom analyzers - this happens on connecting `ILogger` instance in scheduler node receives acquistion event (`BuildCheckAcquisitionEventArgs`). This event is being sent by worker node as soon as it hits a special marker (a magic property function call) during early evaluation. Loading is not processed by worker node as currently we want custom analyzers only in the main node (as they will be only given data proxied from BuildEventArgs).
-    The `BuildCheckAcquisitionEventArgs` should be sent prior `ProjectEvaluationStartedEventArgs` (buffering will need to take place), or main node will need to replay some initial data after custom analyzer is registered.
+* Checks factories get registered with the BuildCheck infrastructure (`BuildCheckManager`)
+    * For inbox checks - this happens on startup.
+    * For custom checks - this happens on connecting `ILogger` instance in scheduler node receives acquistion event (`BuildCheckAcquisitionEventArgs`). This event is being sent by worker node as soon as it hits a special marker (a magic property function call) during early evaluation. Loading is not processed by worker node as currently we want custom checks only in the main node (as they will be only given data proxied from BuildEventArgs).
+    The `BuildCheckAcquisitionEventArgs` should be sent prior `ProjectEvaluationStartedEventArgs` (buffering will need to take place), or main node will need to replay some initial data after custom check is registered.
 * `BuildCheckManager` receives info about new project starting to be build
     * On scheduler node the information is sourced from `ProjectEvaluationStartedEventArgs`
     * On worker node this is received from `RequestBuilder.BuildProject`
-* `BuildCheckManager` calls Configuration module and gets information for all analyzers in it's registry
-    * Analyzers with issues in configuration (communicated via `BuildCheckConfigurationException`) will issue an error and then be deregistered for the rest of the build.
+* `BuildCheckManager` calls Configuration module and gets information for all checks in it's registry
+    * Checks with issues in configuration (communicated via `BuildCheckConfigurationException`) will issue an error and then be deregistered for the rest of the build.
     * Global configuration issue (communicated via `BuildCheckConfigurationException`) will issue an error and then entirely disable BuildCheck.
-* `BuildCheckManager` instantiates all newly enabled analyzers and updates configuration for all already instantiated analyzers.
-* At that point of time analyzers are prepared for receiving data and performing their work. MSBuild will start calling `BuildCheckManager` callbacks (mostly pumping `BuildEventArgs`), passed data will be translated into BuildCheck OM and passed to analyzers.
-* Analyzers may decide to report results of their findings (via `BuildCheckDataContext.ReportResult`), the infrastructure will then perform post-processing (filter out reports for `Rule`s that are disabled, set the severity based on configuration) and send the result via the standard MSBuild logging infrastructure.
-* Analysis result might hence be reported after project's final `ProjectFinishedEventArgs`
-* Final status of the build should not be reported (and `BuildFinishedEventArgs` logged) until all analyzers are done processing and their results are accounted for.
+* `BuildCheckManager` instantiates all newly enabled checks and updates configuration for all already instantiated checks.
+* At that point of time checks are prepared for receiving data and performing their work. MSBuild will start calling `BuildCheckManager` callbacks (mostly pumping `BuildEventArgs`), passed data will be translated into BuildCheck OM and passed to checks.
+* Checks may decide to report results of their findings (via `BuildCheckDataContext.ReportResult`), the infrastructure will then perform post-processing (filter out reports for `Rule`s that are disabled, set the severity based on configuration) and send the result via the standard MSBuild logging infrastructure.
+* Checks result might hence be reported after project's final `ProjectFinishedEventArgs`
+* Final status of the build should not be reported (and `BuildFinishedEventArgs` logged) until all checks are done processing and their results are accounted for.
 
 # Configuration
 
@@ -126,35 +126,35 @@ Planned model:
 
 ## High-level logic
 
-MSBuild engine always finds and parses relevant `.editorconfig` files to see which analyzers should be enabled, if any. In typical builds this operation will not be expensive compared to everything else happening as part of building a project. It's a new cost to all builds though, and in the unlikely case that it starts showing as a perf bottleneck, we can cache the data relevant to MSBuild in a separate intermediate file, in a process-wide in-memory cache invalidated by timestamp checks, and so on.
+MSBuild engine always finds and parses relevant `.editorconfig` files to see which checks should be enabled, if any. In typical builds this operation will not be expensive compared to everything else happening as part of building a project. It's a new cost to all builds though, and in the unlikely case that it starts showing as a perf bottleneck, we can cache the data relevant to MSBuild in a separate intermediate file, in a process-wide in-memory cache invalidated by timestamp checks, and so on.
 
-The rest of the configuration comes directly or indirectly from project files in the form of properties, which creates an interesting ordering issue. For the engine to know the final values of properties such as `TargetFramework`, it needs to evaluate the project. However, if it turns out that an analyzer should be enabled that is interested in _tracing_ the evaluation, it is already too late. It's important to note that this issue exists only for a subset of analyzers. Analyzers interested in the _result_ of evaluation, for example, are fine. The best way of handling this would be to simply evaluate again. Technically, we only need to finish Pass 1 of evaluation to know the value of properties and have the relevant property functions called, so the extra work can be limited to pass 0 and 1. Measurements show that 75% of evaluation is spent in passes 0 and 1. In the very worst case when an extra pass 0/1 runs for each project and lacks any kind of further optimization, single-process incremental build of OrchardCore has been measured to take about 5% longer. There are opportunities for optimizing this, for example by adding a marker to SDK targets files notifying MSBuild of the point after which `TargetFramework` is expected to be fixed so the engine can bail early.
+The rest of the configuration comes directly or indirectly from project files in the form of properties, which creates an interesting ordering issue. For the engine to know the final values of properties such as `TargetFramework`, it needs to evaluate the project. However, if it turns out that an checks should be enabled that is interested in _tracing_ the evaluation, it is already too late. It's important to note that this issue exists only for a subset of checks. Checks interested in the _result_ of evaluation, for example, are fine. The best way of handling this would be to simply evaluate again. Technically, we only need to finish Pass 1 of evaluation to know the value of properties and have the relevant property functions called, so the extra work can be limited to pass 0 and 1. Measurements show that 75% of evaluation is spent in passes 0 and 1. In the very worst case when an extra pass 0/1 runs for each project and lacks any kind of further optimization, single-process incremental build of OrchardCore has been measured to take about 5% longer. There are opportunities for optimizing this, for example by adding a marker to SDK targets files notifying MSBuild of the point after which `TargetFramework` is expected to be fixed so the engine can bail early.
 
-Once `TargetFramework` is known, we can combine the default analyzer config with what came from `.editorconfig`, restart evaluation if an evaluation-tracing analyzer just got enabled, and continue with the rest of the build. Unlike `TargetFramework` which has an additive effect on the enabled analyzers, a master switch like `RunMSBuildChecks` may instruct the engine to not run anything. It would be unfortunate if the user had to pay any extra cost when `RunMSBuildChecks` evaluates to false. So preferrably we don't do anything perf sensitive until we hit the point in evaluation when `TargetFramework`, `RunMSBuildChecks`, `SdkAnalysisLevel`, ... are all known and the set of analyzers to use is finalized.
+Once `TargetFramework` is known, we can combine the default checks config with what came from `.editorconfig`, restart evaluation if an evaluation-tracing check just got enabled, and continue with the rest of the build. Unlike `TargetFramework` which has an additive effect on the enabled checks, a master switch like `RunMSBuildChecks` may instruct the engine to not run anything. It would be unfortunate if the user had to pay any extra cost when `RunMSBuildChecks` evaluates to false. So preferrably we don't do anything perf sensitive until we hit the point in evaluation when `TargetFramework`, `RunMSBuildChecks`, `SdkAnalysisLevel`, ... are all known and the set of checks to use is finalized.
 
-Since we are unlikely to enable any analyzers by default in .NET 9, the focus in this release should be on optimizing the `.editorconfig` handling.
+Since we are unlikely to enable any checks by default in .NET 9, the focus in this release should be on optimizing the `.editorconfig` handling.
 
 # Acquisition
 
-BuildCheck employs two distinct types of analyzers: inbox and custom. As a result, the acquisition and distribution processes vary.
-Inbox rules are integrated into the MSBuild repository, while custom analyzers can be packaged as NuGet packages and detected by MSBuild provided they adhere to a specific structure. 
+BuildCheck employs two distinct types of checks: inbox and custom. As a result, the acquisition and distribution processes vary.
+Inbox rules are integrated into the MSBuild repository, while custom checks can be packaged as NuGet packages and detected by MSBuild provided they adhere to a specific structure. 
 
 To streamline the creation of custom rules, a special [template](https://learn.microsoft.com/dotnet/core/tools/custom-templates) has been introduced.
-To enable MSBuild to recognize a custom analyzer, it must invoke the intrinsic function [`void RegisterBuildCheck(string path)`](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/src/Build/Evaluation/IntrinsicFunctions.cs#L700), which requires the path to the assembly as input. Therefore, it's essential for the user to ensure that the assembly exists in the specified location.
-Additionally, the custom rule must use [`BuildAnalyzerRule`](https://github.com/dotnet/msbuild/blob/9cdb3615adb4115f92b390de2f258fac5f320909/src/Build/BuildCheck/API/BuildAnalyzerRule.cs#L11C14-L11C31) as a parent class; otherwise, MSBuild will not register it.
+To enable MSBuild to recognize a custom check, it must invoke the intrinsic function [`void RegisterBuildCheck(string path)`](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/src/Build/Evaluation/IntrinsicFunctions.cs#L700), which requires the path to the assembly as input. Therefore, it's essential for the user to ensure that the assembly exists in the specified location.
+Additionally, the custom rule must use [`BuildCheckRule`](https://github.com/dotnet/msbuild/blob/9cdb3615adb4115f92b390de2f258fac5f320909/src/Build/BuildCheck/API/BuildAnalyzerRule.cs#L11C14-L11C31) as a parent class; otherwise, MSBuild will not register it.
 
 Examples of custom rules can be found in the [end-to-end tests](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/src/BuildCheck.UnitTests/EndToEndTests.cs#L139), showcasing various scenarios:
 
 1. [`Single Custom Rule Packaged as a NuGet Package`](https://github.com/dotnet/msbuild/tree/main/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate): Demonstrates the implementation of a custom rule encapsulated within a NuGet package. It contains the process of creating, packaging, and integrating a single custom rule into a project.
-2. [`Project with Multiple Analyzers Referenced`](https://github.com/dotnet/msbuild/tree/main/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected): Illustrates a project setup where multiple custom analyzers are referenced. This scenario is common in larger projects where multiple rule sets need to be enforced simultaneously.
+2. [`Project with Multiple Checks Referenced`](https://github.com/dotnet/msbuild/tree/main/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleChecksInjected): Illustrates a project setup where multiple custom checks are referenced. This scenario is common in larger projects where multiple rule sets need to be enforced simultaneously.
 
 Important Notes: 
-- In these examples, pay attention to the presence of the `CustomAnalyzerName.props` file. This file contains intrinsic function invocations necessary for successful rule registration. Understanding and correctly implementing these invocations are crucial for integrating custom rules into your projects effectively.
-- The examples do not include references to third-party assemblies that might be required in other custom analyzers. To load the custom instance in MSBuild, third-party assemblies have to be included in the NuGet package. The current implementation achieves this goal by using a special target: [AddNuGetDlls](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj#L22).
+- In these examples, pay attention to the presence of the `CustomCheckName.props` file. This file contains intrinsic function invocations necessary for successful rule registration. Understanding and correctly implementing these invocations are crucial for integrating custom rules into your projects effectively.
+- The examples do not include references to third-party assemblies that might be required in other custom checks. To load the custom instance in MSBuild, third-party assemblies have to be included in the NuGet package. The current implementation achieves this goal by using a special target: [AddNuGetDlls](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj#L22).
 
 ### Future Enhancements
 As our library of custom rules expands, we plan to enrich this section with real-world production rule examples. These examples will showcase a diverse range of rules addressing common development challenges. Once these production rules are published and available on nuget.org, we will update this documentation accordingly.
 
-# Build OM for Analyzers Authoring
+# Build OM for Checks Authoring
 
-**TBD** - details for the initial inbox analyzers set to be amended by @ladipro
+**TBD** - details for the initial inbox checks set to be amended by @ladipro
diff --git a/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md b/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md
index ec1944a8700..2bc17291362 100644
--- a/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md
+++ b/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md
@@ -4,8 +4,8 @@
 ## BuildCheck Feature Description
 
 The infrastructure within MSBuild allowing pluggability and execution of
-Analyzers and their Rules previously known as "warning waves" and
-"MSBuild Analyzers".
+Checks and their Rules previously known as "warning waves" and
+"MSBuild Checks".
 
 The feature is meant to help customers to improve and understand quality of their MSBuild scripts via rules violations reporting. It will allow MSBuild to gradually roll out additional rules, as users will be capable to configure their opt-in and severity of reports – preventing unwanted build breakages. And to equip powerusers to roll out their own quality checks – whether for general community or internal enterprise usage.
 
@@ -24,45 +24,45 @@ For this document, we do not address any threats that result from violating thes
 
 ## Acquisition
 
-### Threat: Supply chain attack on custom analyzer
+### Threat: Supply chain attack on custom check
 
-Custom BuildCheck analyzers are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box.
+Custom BuildCheck checks are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box.
 
 #### Mitigation
 
 Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
 
-Custom analyzers are delivered as regular nuget packages by MSBuild `<PackageReference />` element.
-Users is expected to implement process to detect and warn about known malicious custom analyzers.
+Custom checks are delivered as regular nuget packages by MSBuild `<PackageReference />` element.
+Users is expected to implement process to detect and warn about known malicious custom checks.
 
 #### Important Notice:
-Users should not add untrusted build analyzers to their projects. The use of untrusted or unverified 3rd party analyzers can introduce security risks and vulnerabilities into the build process. Always ensure that any build analyzers integrated into your projects come from reputable sources and have been thoroughly vetted.
+Users should not add untrusted build checks to their projects. The use of untrusted or unverified 3rd party checks can introduce security risks and vulnerabilities into the build process. Always ensure that any build checks integrated into your projects come from reputable sources and have been thoroughly vetted.
 
 To ensure a secure and reliable build environment, the following steps should be taken:
 
 #### Use Dedicated Security Tools:
-Utilize specialized security tools and services to scan and monitor 3rd party analyzer packages and their dependencies. 
+Utilize specialized security tools and services to scan and monitor 3rd party check packages and their dependencies. 
 #### Regular Updates:
 Ensure that all 3rd party packages and dependencies are regularly updated to the latest versions, which often include security patches and vulnerability fixes.
 
 #### Vendor Documentation and Support:
-Refer to the official documentation and support channels provided by the developers of the 3rd party analyzer packages. They may offer guidance and tools for managing security and addressing vulnerabilities.
+Refer to the official documentation and support channels provided by the developers of the 3rd party check packages. They may offer guidance and tools for managing security and addressing vulnerabilities.
 
 #### Internal Security Policies:
 Implement internal policies and processes for the assessment and mitigation of security risks associated with using 3rd party packages. This can include regular security audits, dependency management protocols, and automated vulnerability scanning during the build process.
 
 ## Execution
 
-### Threat: Supply chain attack by custom analyzer
+### Threat: Supply chain attack by custom check
 
-Custom BuildCheck analyzers are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box, with intent to inject malicious behavior into build artifacts.
+Custom BuildCheck checks are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box, with intent to inject malicious behavior into build artifacts.
 
 #### Mitigation
 
 Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
 
 ### Threat: Third-Party Vulnerabilities
-Vulnerabilities in custom analyzer or its dependencies.
+Vulnerabilities in custom check or its dependencies.
 
 #### Mitigation
 
@@ -72,18 +72,18 @@ Detecting unsecure packages is not MSBuild responsibility and is currently out o
 
 ### Threat: Malicious configuration value
 
-Although .editorconfig shall be part of trusted sources, and hence not malicious, .editorconfig is looked up in parent folders up to the root. This can allow attacked to store malicious editor config up in parent folders with intent of disabling an analyzer or cause build malfunction for any reason.
+Although .editorconfig shall be part of trusted sources, and hence not malicious, .editorconfig is looked up in parent folders up to the root. This can allow attacked to store malicious editor config up in parent folders with intent of disabling an check or cause build malfunction for any reason.
 
 #### Mitigation
 
-This problem is identical to existing .editorconfig for Roslyn analyzers and since we share code for parsing it, we adopt same mitigation strategy, which is:
+This problem is identical to existing .editorconfig for Roslyn checks and since we share code for parsing it, we adopt same mitigation strategy, which is:
 
 - default template for editor config has `root = true` stopping parent config traversing
 - code is unit tested to verify and sanitize .editorconfig values
 
-### Threat: Intentional analyzer ID conflict or misleading ID
+### Threat: Intentional check ID conflict or misleading ID
 
-Malicious actors can define analyzer ID to be identical or like existing well known analyzer ID to increase probability of executing malicious analyzer code.
+Malicious actors can define check ID to be identical or like existing well known check ID to increase probability of executing malicious check code.
 
 #### Mitigation
 
@@ -91,9 +91,9 @@ Detecting unsecure packages is not MSBuild responsibility and is currently out o
 
 ## Declaration
 
-### Threat: Malicious analyzer registration property function
+### Threat: Malicious check registration property function
 
-Threat actor can write malicious analyzer registration property function in project files, with intent to run code from non-governed assemblies.
+Threat actor can write malicious check registration property function in project files, with intent to run code from non-governed assemblies.
 
 #### Mitigation
 
diff --git a/documentation/specs/BuildCheck/BuildCheck.md b/documentation/specs/BuildCheck/BuildCheck.md
index a4db495c6ae..c2f6e0e8864 100644
--- a/documentation/specs/BuildCheck/BuildCheck.md
+++ b/documentation/specs/BuildCheck/BuildCheck.md
@@ -1,32 +1,32 @@
 
 # BuildCheck - Design Spec
 
-Previously known as "warning waves" and "MSBuild Analyzers"
+Previously known as "warning waves" and "MSBuild Checks"
 
 The feature is meant to help customers to improve and understand quality of their MSBuild scripts via rules violations reporting. It will allow MSBuild to gradually roll out additional rules, as users will be capable to configure their opt-in and severity of reports – preventing unwanted build breakages. And to equip powerusers to roll out their own quality checks – whether for general community or internal enterprise usage.
 
 # Terminology
 
-* **Analyzer** – unit of execution (single implementing class), can host multiple rules. 
+* **Check** – unit of execution (single implementing class), can host multiple rules. 
 * **Rule** – Single violation type, with single unique code (`“BC1234: Redefining built-in target”`). 
-* **Report** – Output from Analyzer informing about violating particular rule.
+* **Report** – Output from check informing about violating particular rule.
 * **CodeFix** – Violation remedy suggestion. Not yet applicable for MSBuild.
-* **BuildCheck** - Feature name. The infrastructure within MSBuild allowing pluggability and execution of Analyzers and their Rules
+* **BuildCheck** - Feature name. The infrastructure within MSBuild allowing pluggability and execution of checks and their Rules
 
 
 # North Star / Longer-term vision
 
-MSBuild provides a rich object model (further just OM) exposing representation of the build scripts (unstructured and structured model of documents contributing to the build), build data (the definition and evaluated values of MSBuild primitives) and build execution (the eventing model of inputs, processing and outputs of the orchestrated execution) so that various quality checking rules can be authored. This includes static analysis rules (e.g. checking validity of condition expressions) as well as build execution rules (e.g. checking of referencing nonexistent files) and composition rules (e.g. unintended outputs overwrites checking). Identical OM is exposed from live build execution and via post-build log event sourcing – so that users can choose whether the build analysis will happen as part of the build or as a separate process.
+MSBuild provides a rich object model (further just OM) exposing representation of the build scripts (unstructured and structured model of documents contributing to the build), build data (the definition and evaluated values of MSBuild primitives) and build execution (the eventing model of inputs, processing and outputs of the orchestrated execution) so that various quality checking rules can be authored. This includes static check rules (e.g. checking validity of condition expressions) as well as build execution rules (e.g. checking of referencing nonexistent files) and composition rules (e.g. unintended outputs overwrites checking). Identical OM is exposed from live build execution and via post-build log event sourcing – so that users can choose whether the build check will happen as part of the build or as a separate process.
 
-Users are able to tune the behavior of the checks via `.editorconfig` which brings unified and standardized experience with other tooling (including built-in and third-party C# analyzers) leveraging `.editorconfig` files.
+Users are able to tune the behavior of the checks via `.editorconfig` which brings unified and standardized experience with other tooling (including built-in and third-party C# checks) leveraging `.editorconfig` files.
 
-Powerusers are able to develop, test and publish their custom analyzers easily and contribute them back to community. The local development scenario doesn’t require roundtrip through packaging.
+Powerusers are able to develop, test and publish their custom checks easily and contribute them back to community. The local development scenario doesn’t require roundtrip through packaging.
 
-A solid set of in-the-box analyzers is provided by MSBuild and the .NET SDK, extended each release, with high quality reports (pointing exact locations of issue, offering clear and actionable explanations, not repetitive for builds with multi-execution or/and multi-importing of a same script in single build context). The existing in-the-box analyzers are gradually enabled by default and their severity increased - in waves (likely tied to sdk releases) - aiming to constantly increase the quality of our customers build scripts. To avoid breaking customers builds, there will still be an explicit user gesture required to opt into running the analysis. This will be done either by configuring the analyzers with `.editorconfig` or auto-enabling the analysis based on the TFM of the project. There will be no difference between building with `dotnet build` and with `MSBuild.exe`, they will follow the same enablement rules with the set of enabled built-in analyzers derived from `.editorconfig` and TFM/props. Building in Visual Studio will eventually reach parity with command-line build as well.
+A solid set of in-the-box checks is provided by MSBuild and the .NET SDK, extended each release, with high quality reports (pointing exact locations of issue, offering clear and actionable explanations, not repetitive for builds with multi-execution or/and multi-importing of a same script in single build context). The existing in-the-box checks are gradually enabled by default and their severity increased - in waves (likely tied to sdk releases) - aiming to constantly increase the quality of our customers build scripts. To avoid breaking customers builds, there will still be an explicit user gesture required to opt into running the check. This will be done either by configuring the checks with `.editorconfig` or auto-enabling the check based on the TFM of the project. There will be no difference between building with `dotnet build` and with `MSBuild.exe`, they will follow the same enablement rules with the set of enabled built-in checks derived from `.editorconfig` and TFM/props. Building in Visual Studio will eventually reach parity with command-line build as well.
 
-Projects that don't use the .NET SDK and those that are not SDK-style at all are TBD. There is a possibility of using a property like `MSBuildAnalysisLevel` to enable some base analyzers we believe will add value everywhere.
+Projects that don't use the .NET SDK and those that are not SDK-style at all are TBD. There is a possibility of using a property like `MSBuildCheckLevel` to enable some base checks we believe will add value everywhere.
 
-The analysis has small impact on build duration with ability to disable analysis altogether which will remove all the performance costs associated with the analysis. The perf impact on representative projects is continuously monitored and documented by the MSBuild team.
+The check has small impact on build duration with ability to disable check altogether which will remove all the performance costs associated with the check. The perf impact on representative projects is continuously monitored and documented by the MSBuild team.
 
 
 # Scope of initial iteration
@@ -34,43 +34,43 @@ The analysis has small impact on build duration with ability to disable analysis
 Majority of following cases are included in appropriate context within the scenarios in [User Experience](#user-experience) section. Following is a quick overview.
 
 ## In scope
-* Inbox (built-in) analyzers that run during the build execution.
-* Inbox analyzers that run when replaying binlog.
-* Custom authored analyzers, delivered via nuget.
-* Analyzers reports (errors, warnings, messages) are in logger output, VS error window.
+* Inbox (built-in) checks that run during the build execution.
+* Inbox checks that run when replaying binlog.
+* Custom authored checks, delivered via nuget.
+* Checks reports (errors, warnings, messages) are in logger output, VS error window.
 * Codes will be distinguishable from standard build warnings/error (to prevent easy mixups and attempts to configure standard msbuild warnings/errors via editorconfig), but otherwise the outputs are very similar.
-* Default opt-ins and levels for inbox analyzers set by sdk version (via [`$SdkAnalysisLevel`]((https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md))) or other agreed mechanism for controlling increasing strictness between .NET versions.
-* Custom analyzers opted in via `PackageReference` of a particular nuget with the analyzer.
-* Explicit overrides of enablement and analysis levels via `.editorconfig` file (with up to a per-project scope).
+* Default opt-ins and levels for inbox checks set by sdk version (via [`$SdkAnalysisLevel`]((https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md))) or other agreed mechanism for controlling increasing strictness between .NET versions.
+* Custom checks opted in via `PackageReference` of a particular nuget with the check.
+* Explicit overrides of enablement and check levels via `.editorconfig` file (with up to a per-project scope).
 * [Specification of `.editorconfig`](https://spec.editorconfig.org/) will be observed. 
 * Simplified authoring experience via template and doc.
-* Single analyzer can produce reports for multiple rules. However those need to be declared upfront.
-* Opt-in reporting of time spent via specific analyzers and infra overall.
+* Single check can produce reports for multiple rules. However those need to be declared upfront.
+* Opt-in reporting of time spent via specific checks and infra overall.
 * Collect touched `.editorconfig`s into binlog embedded files.
-* Possibility to opt-out from analysis - the perf should not be impacted when done so.
-* Team collects performance impact numbers on a set of benchmark builds with the inbox analyzers enabled.
+* Possibility to opt-out from check - the perf should not be impacted when done so.
+* Team collects performance impact numbers on a set of benchmark builds with the inbox checks enabled.
 
 ## Non Goals, but subject for consideration
-* Custom analyzer in a local project (source codes) or a binary.
+* Custom check in a local project (source codes) or a binary.
 * Bulk configuration of multiple rules (based on prefixes).
-* Specifying scope of MSBuild imports that will be considered for analysis (so that e.g. data from sdk won't even be passed to analyzer, if not requested).
+* Specifying scope of MSBuild imports that will be considered for check (so that e.g. data from sdk won't even be passed to check, if not requested).
 * Attempts to try to configure standard msbuild warnings/errors via `.editorconfig` should lead to fail fast errors.
-* Configuring analysis levels when analyzing from binlog - beyond the collected editorconfigs
-* Structured information in VS error window (similarly to the Roslyn analyzer reports - reports have titles, details, locations, searchable codes and exposed links leading to detailed documentation).
+* Configuring BuildCheck levels when checking from binlog - beyond the collected editorconfigs
+* Structured information in VS error window (similarly to the Roslyn check reports - reports have titles, details, locations, searchable codes and exposed links leading to detailed documentation).
 
 
 ## Out of scope
 * Instrumentation for telemetry.
-* Design time build analysis.
+* Design time build check.
 * Localization support (for reports message formats, identifiers, etc.).
-* Custom analyzers have equal data access as the inbox analyzers. We'll aim to ship analyzers that use public BuildCheck API/OM surface. But for extra agility we might chose to implement and ship some analyzers using unexposed data.
-* All inbox analyzers reports have precise location(s) of issues (however for each individual analyzer not providing precise location we should have a very strong reason, why location cannot be provided and why it still brings value even without precise location).
-* Opt-out of analysis on code-level (something like C# `#pragma warning disable`, but within msbuild xml files).
+* Custom checks have equal data access as the inbox checks. We'll aim to ship checks that use public BuildCheck API/OM surface. But for extra agility we might chose to implement and ship some checks using unexposed data.
+* All inbox checks reports have precise location(s) of issues (however for each individual check not providing precise location we should have a very strong reason, why location cannot be provided and why it still brings value even without precise location).
+* Opt-out of BuildCheck on code-level (something like C# `#pragma warning disable`, but within msbuild xml files).
 * Simplified authoring experience via dedicated reference assembly.
-* Restore phase analysis.
-* Turning analysis off/on based on target (e.g. multi-targeted builds, calling MSBuild task etc.).
-* Controlling/Configuring lifetime of analyzers - analyzers will currently be held alive, as single instance per analyzer, for the whole duration of the build. But future versions might prevent some of the analyzers to survive beyond a scope of a single project built (means for sharing data would be provided).
-* Event Tracing for Windows (ETW) for analyzers.
+* Restore phase check.
+* Turning check off/on based on target (e.g. multi-targeted builds, calling MSBuild task etc.).
+* Controlling/Configuring lifetime of checks - checks will currently be held alive, as single instance per check, for the whole duration of the build. But future versions might prevent some of the checks to survive beyond a scope of a single project built (means for sharing data would be provided).
+* Event Tracing for Windows (ETW) for checks.
 * Attributing `.editorconfig` configurations to .sln files. E.g.:
 ```ini
 # I expect this to apply to all projects within my solution, but not to projects which are not part of the solution
@@ -91,17 +91,17 @@ build_check.BC0101.Severity=warning
 
 ## Running / UX
 
-### Inbox Analyzers
+### Inbox Checks
 
-Suggested list of analyzers to be shipped with V1: https://github.com/dotnet/msbuild/issues/9630#issuecomment-2007440323
+Suggested list of checks to be shipped with V1: https://github.com/dotnet/msbuild/issues/9630#issuecomment-2007440323
 
-The proposed initial configuration for those is TBD (as well based on initial test runs of the analyzers of chosen public repositories).
+The proposed initial configuration for those is TBD (as well based on initial test runs of the checks of chosen public repositories).
 
 ### Live Build
 
-BuildCheck will run as part of the build and execute [inbox analyzers](#inbox-analyzers) and [custom analyzers](#acquisition-of-custom-analyzers) based on the [configuration](#configuration). Users will have an option to completely opt-out from BuildCheck to run via an MSBuild property (could be set in a project file or passed on the commandline).
+BuildCheck will run as part of the build and execute [inbox checks](#inbox-checks) and [custom checks](#acquisition-of-custom-checks) based on the [configuration](#configuration). Users will have an option to completely opt-out from BuildCheck to run via an MSBuild property (could be set in a project file or passed on the commandline).
 
-Findings - reports - of analyzers will be output as build messages/warnings/errors, and the message/warnings/error code should help distinguish BuildCheck produced reports from regular build errors/warnings.
+Findings - reports - of checks will be output as build messages/warnings/errors, and the message/warnings/error code should help distinguish BuildCheck produced reports from regular build errors/warnings.
 
 BuildCheck reports will have power to fail the build (via errors or warnings), that would otherwise succeed without the BuildCheck. This is actually the main benefit of the feature - as it helps enforcing new rules, that are easily user configurable individually or as a whole feature - to prevent unwanted breakages of legacy builds not ready for improvements.
 
@@ -110,36 +110,36 @@ BuildCheck reports will have power to fail the build (via errors or warnings), t
 Users will have option to explicitly opt-in to run BuildCheck during the binlog replay mode:
 
 ```bash
-> dotnet build msbuild.binlog /analyze
+> dotnet build msbuild.binlog /check
 ```
 
-Would there be any analyzers that are not possible to run during the replay mode (subject to internal design - this difference won't be exposed during [custom analyzers authoring](#custom-analyzers-authoring)), replay mode will inform user about those via warnings.
+Would there be any checks that are not possible to run during the replay mode (subject to internal design - this difference won't be exposed during [custom checks authoring](#custom-checks-authoring)), replay mode will inform user about those via warnings.
 
-Replay mode will by default consider `.editorconfig` files stored within the binlog and will run analyzers based on those. This would possibly lead to unintended double-reports – as binlog will have the runtime analysis reports stored, plus the replay-time analysis reports will be augmented. At the same time we might want to run some additional checks in the replay mode, that have not been enabled (or not even available) during the build time.
+Replay mode will by default consider `.editorconfig` files stored within the binlog and will run checks based on those. This would possibly lead to unintended double-reports – as binlog will have the runtime check reports stored, plus the replay-time check reports will be augmented. At the same time we might want to run some additional checks in the replay mode, that have not been enabled (or not even available) during the build time.
 
 For this reason we will consider following modes (all are non-goals):
 * All binlog stored reports are skipped by default. We add option to request not skipping them (but they might need to be prefixed or otherwise distinguished from the 'fresh' reports).
 * Ability to specify skipping of the stored .editorconfig files
 * Ability to specify single replay-time .editorconfig file and it’s precedence (only the specified, specified as most significant, specified as least significant)
 
-We might as well consider specifying custom analyzers on a command line (as a non-goal) - so that unreferenced custom analyzers can be run against the binlog.
+We might as well consider specifying custom checks on a command line (as a non-goal) - so that unreferenced custom checks can be run against the binlog.
 
 ## Configuration
 
-There will be 3 mechanisms of configuring the analyzers and rules:
-* The default configuration declared by the analyzers themselves ([more details on implementation](#rules-declaration))
-* The TFM of the project and the [Sdk Analysis Level property](https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md) – mostly for the inbox analyzers
+There will be 3 mechanisms of configuring the checks and rules:
+* The default configuration declared by the checks themselves ([more details on implementation](#rules-declaration))
+* The TFM of the project and the [Sdk Analysis Level property](https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md) – mostly for the inbox checks
 * `.editorconfig` file
 
 We will also consider respecting `SdkAnalysisLevel` to override the per-TFM defaults. Additionally, we may introduce a new "master switch" property, tentatively called `RunMSBuildChecks`, to make it possible to disable everything whole-sale. This would be used in scenarios like F5 in VS.
 ```
-Skipping analyzers to speed up the build. You can execute 'Build' or 'Rebuild' command to run analyzers.
+Skipping checks to speed up the build. You can execute 'Build' or 'Rebuild' command to run checks.
 ```
 
 Here's the proposed release schedule:
-- **.NET 9** - the feature is introduced and enabled in `dotnet build` and `MSBuild.exe` command-line builds. It is not enabled in VS just yet. No analyzers are enabled by default. It is not technically required to read the TFM or any other props during evaluation, though it would be nice to respect `RunMSBuildChecks` already in this release. `.editorconfig` can be the sole source of configuration.
-- **.NET 10** - based on feedback and testing, we choose a set of analyzers to enable by default for projects targeting `net10.0`, and enable the feature as a whole in Visual Studio. Depending on how we feel about the perf characteristics of evaluation, especially the "double evaluation" mandated by discovering evaluation-tracking analyzers just-in-time, we may want to omit such analyzers from the default set.
-- **.NET 11** and beyond - some more analyzers are enabled for projects targeting `net11.0`, the `net10.0` does not change. Everything is mature and performant enough that we are able to auto-enable any analyzer. The gradual tightening of rules enabled by default gets us closer to the long envisioned "strict mode", which will ultimately allow us to evolve MSBuild to be simpler and more performant.
+- **.NET 9** - the feature is introduced and enabled in `dotnet build` and `MSBuild.exe` command-line builds. It is not enabled in VS just yet. No checks are enabled by default. It is not technically required to read the TFM or any other props during evaluation, though it would be nice to respect `RunMSBuildChecks` already in this release. `.editorconfig` can be the sole source of configuration.
+- **.NET 10** - based on feedback and testing, we choose a set of checks to enable by default for projects targeting `net10.0`, and enable the feature as a whole in Visual Studio. Depending on how we feel about the perf characteristics of evaluation, especially the "double evaluation" mandated by discovering evaluation-tracking checks just-in-time, we may want to omit such checks from the default set.
+- **.NET 11** and beyond - some more checks are enabled for projects targeting `net11.0`, the `net10.0` does not change. Everything is mature and performant enough that we are able to auto-enable any check. The gradual tightening of rules enabled by default gets us closer to the long envisioned "strict mode", which will ultimately allow us to evolve MSBuild to be simpler and more performant.
 
 
 For the `.editorconfig` file configuration, following will apply:
@@ -148,16 +148,16 @@ For the `.editorconfig` file configuration, following will apply:
 * `.editorconfig` files packaged within nuget packages within local nuget cache won’t be considered.
 
 ### Non-Goals (but might be considered):
-* bulk configuration of multiple rules - based on analyzers/rules prefixes or/and categories.
+* bulk configuration of multiple rules - based on checks/rules prefixes or/and categories.
 * attempts to try to configure standard msbuild warnings/errors via `.editorconfig` should lead to fail fast errors.
-* configuring analysis levels when analyzing from binlog - beyond the collected editorconfigs.
-* Aliasing the analyzers/rules, allowing to create multiple instances with different custom configuration (e.g. single analyzer checking configurable list of forbidden properties prefixes can have 2 instance, each initialized with different list to check, each of the instance configurable for individual projects separately).
+* configuring check levels when checking from binlog - beyond the collected editorconfigs.
+* Aliasing the checks/rules, allowing to create multiple instances with different custom configuration (e.g. single check checking configurable list of forbidden properties prefixes can have 2 instance, each initialized with different list to check, each of the instance configurable for individual projects separately).
 
 ### Out of scope for configuration:
-* opt-out of analysis on code-level (analogy to C# pragmas, but within msbuild xml files).
+* opt-out of check on code-level (analogy to C# pragmas, but within msbuild xml files).
 * lower granularity of `.editorconfig` settings other than whole projects.
 * attributing configuration to a .sln file and expecting it will apply to all contained projects.
-* Support for multiple [custom configurations](#custom-configuration-declaration) within a single build for a single rule. (Not to be mixed with [standardized configuration](#standardized-configuration-declaration) - which can be configured freely per project) If a custom configuration will be used, it will need to be specified identically in each explicit configurations of the rule. This is chosen so that there are no implicit requirements on lifetime of the analyzer or analyzer instancing – each analyzer will be instantiated only once per build (this is however something that will very likely change in future versions – so authors are advised not to take hard dependency on single instance policy).
+* Support for multiple [custom configurations](#custom-configuration-declaration) within a single build for a single rule. (Not to be mixed with [standardized configuration](#standardized-configuration-declaration) - which can be configured freely per project) If a custom configuration will be used, it will need to be specified identically in each explicit configurations of the rule. This is chosen so that there are no implicit requirements on lifetime of the check or check instancing – each check will be instantiated only once per build (this is however something that will very likely change in future versions – so authors are advised not to take hard dependency on single instance policy).
 
 ### Sample configuration
 
@@ -172,7 +172,7 @@ build_check.COND0543.custom_switch=QWERTY
 
 ### User Configurable Options
 
-Initial version of BuildCheck plans a limited set of options configurable by user (via `.editorconfig`) by which users can override default configuration of individual analyzer rules.
+Initial version of BuildCheck plans a limited set of options configurable by user (via `.editorconfig`) by which users can override default configuration of individual check rules.
 
 **NOTE:** The actual naming of the configuration options is yet to be determined.
 
@@ -188,13 +188,13 @@ Option `Severity` with following values will be available:
 | Warning | `warning` |
 | Error | `error` |
 
-Severity levels are in line with [roslyn analyzers severity levels](https://learn.microsoft.com/en-us/visualstudio/code-quality/use-roslyn-analyzers). `Default` severity in `.editorconfig` will lead to using build-in severity from the analyzer (so this can be used for clearing custom severity setting from higher level `.editorconfig` file). `Default` severity in the build-in code has same effect as if the code doesn't specify severity at all - an infrastruture default of `None` is considered.
+Severity levels are in line with [roslyn analyzers severity levels](https://learn.microsoft.com/en-us/visualstudio/code-quality/use-roslyn-analyzers). `Default` severity in `.editorconfig` will lead to using build-in severity from the check (so this can be used for clearing custom severity setting from higher level `.editorconfig` file). `Default` severity in the build-in code has same effect as if the code doesn't specify severity at all - an infrastruture default of `None` is considered.
 
-Configuration will dictate transformation of the analyzer report to particular build output type (message, warning or error).
+Configuration will dictate transformation of the check report to particular build output type (message, warning or error).
 
-Each rule has a severity, even if multiple rules are defined in a single analyzer. The rule can have different severities for different projects within a single build session.
+Each rule has a severity, even if multiple rules are defined in a single check. The rule can have different severities for different projects within a single build session.
 
-If all the rules from a single analyzer have severity `None` - analyzer won't be given any data for such configured part of the build (specific project or a whole build). If analyzer have some rules enabled and some disabled - it will be still fed with data, but the reports will be post-filtered.
+If all the rules from a single check have severity `None` - check won't be given any data for such configured part of the build (specific project or a whole build). If check have some rules enabled and some disabled - it will be still fed with data, but the reports will be post-filtered.
 
 #### Configuring severity level
 
@@ -203,22 +203,22 @@ If all the rules from a single analyzer have severity `None` - analyzer won't be
 build_check.BC0101.severity=warning
 ```
 
-#### Scope of Analysis
+#### Scope of Check
 
-Option `EvaluationAnalysisScope` with following possible options will be available:
+Option `EvaluationCheckScope` (just `scope` in `.editorconfig`) with following possible options will be available:
 
-| EvaluationAnalysisScope (Solution Explorer)   | EditorConfig option      |  Behavior  | 
+| EvaluationCheckScope (scope)   | EditorConfig option      |  Behavior  | 
 | ------------- | ------------- |   ------------- |
-| ProjectOnly | `project` | Only the data from currently analyzed project will be sent to the analyzer. Imports will be discarded. | 
-| ProjectWithImportsFromCurrentWorkTree | `current_imports` |  Only the data from currently analyzed project and imports from files under the entry project or solution will be sent to the analyzer. Other imports will be discarded. | 
-| ProjectWithImportsWithoutSdks | `without_sdks` | Imports from SDKs will not be sent to the analyzer. Other imports will be sent. | 
-| ProjectWithAllImports | `all` | All data will be sent to the analyzer. | 
+| ProjectFileOnly | `project_file` | Only the data from currently checked project will be sent to the check. Imports will be discarded. | 
+| WorkTreeImports | `work_tree_imports` |  Only the data from currently checked project and imports from files not recognized to be in nuget cache or SDK install folder will be sent to the check. Other imports will be discarded. |  
+| ProjectWithAllImports | `all` | All data will be sent to the check. | 
 
-All rules of a single analyzer must have the `EvaluationAnalysisScope` configured to a same value. If any rule from the analyzer have the value configured differently - a warning will be issued during the build and analyzer will be deregistered.
+Same rule can have `EvaluationCheckScope` configured to different values for different projects. If check has multiple rules (this is e.g. case of PropertyUsageCheck rules - [BC0201](Codes.md#bc0201---usage-of-undefined-property), [BC0202](Codes.md#bc0202---property-first-declared-after-it-was-used) and [BC0203](Codes.md#bc0203----property-declared-but-never-used)) - those can have the `EvaluationCheckScope` set to distinct values.
 
-Same rule can have `EvaluationAnalysisScope` configured to different values for different projects.
+Currently the proper filtering of data is at the discretion of the Check - as the infrastructure might not be able to decide what can be considered in scope (e.g. in case of [BC0203](Codes.md#bc0203----property-declared-but-never-used) - "_Property declared, but never used_" - the property writes (definitions) are scoped, but reads (usages) are not, while [BC0201](Codes.md#bc0201---usage-of-undefined-property) "_Usage of undefined property_" needs to scope reads, but not writes (definitions). Identical input data need to be scoped differently based on the meaning of the Check). 
+
+Some checks might completely ignore the `EvaluationCheckScope` setting - as they can operate on data, that are sourced from build execution (as opposed from build evaluation) and hence the scoping is not possible. This is e.g. case of [BC0102](Codes.md#bc0102---double-writes) "_Double Writes_" check.
 
-BuildCheck might not be able to guarantee to properly filter the data with this distinction for all [registration types](#RegisterActions) - in case an explicit value is attempted to be configured (either [from the analyzer code](#BuildAnalyzerConfiguration) or from `.editorconfig` file) for an analyzer that has a subscription to unfilterable data - a warning will be issued during the build and analyzer will be deregistered.
 
 #### Configuring evalution scope
 
@@ -227,7 +227,7 @@ BuildCheck might not be able to guarantee to properly filter the data with this
 build_check.BC0101.scope=all
 ```
 
-## Analyzers and Rules Identification
+## Checks and Rules Identification
 
 **TBD**
 
@@ -237,36 +237,36 @@ build_check.BC0101.scope=all
 * Ability to use prefixes during configuration
 
 
-## Custom Analyzers Authoring
+## Custom Checks Authoring
 
 ### Implementation
 
-To author custom analyzer, user will need to implement given contract (delivered in Microsoft.Build package). The contract will provide access to the exposed BuildCheck OM focused on build analysis.
+To author custom check, user will need to implement given contract (delivered in Microsoft.Build package). The contract will provide access to the exposed BuildCheck OM focused on build check.
 
-#### Analyzer declaration
+#### Check declaration
 
 Simplified proposal:
 
 ```csharp
-public abstract class BuildAnalyzer : IDisposable
+public abstract class BuildExecutionCheck : IDisposable
 {
     /// <summary>
-    /// Friendly name of the analyzer.
+    /// Friendly name of the check.
     /// Should be unique - as it will be used in the tracing stats, infrastructure error messages, etc.
     /// </summary>
     public abstract string FriendlyName { get; }
 
     /// <summary>
-    /// Single or multiple rules supported by the analyzer.
+    /// Single or multiple rules supported by the check.
     /// </summary>
-    public abstract IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; }
+    public abstract IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; }
 
     /// <summary>
-    /// Optional initialization of the analyzer.
+    /// Optional initialization of the check.
     /// </summary>
     /// <param name="configurationContext">
     /// Custom data (not recognized by the infrastructure) passed from .editorconfig
-    /// Currently the custom data has to be identical for all rules in the analyzer and all projects.
+    /// Currently the custom data has to be identical for all rules in the check and all projects.
     /// </param>
     public abstract void Initialize(ConfigurationContext configurationContext);
 
@@ -288,26 +288,26 @@ Sample of how registrations might look like:
 ```csharp
 public interface IBuildCheckRegistrationContext
 {
-    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction);
+    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction);
 
-    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction);
+    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction);
 
     // ...
 }
 ```
 
-The data provided in callbacks for registered actions will allow the analyzer to submit reports for its rules. A single callback can lead to multiple reports being generated.
+The data provided in callbacks for registered actions will allow the check to submit reports for its rules. A single callback can lead to multiple reports being generated.
 
-Any analyzer will be allowed to produce reports only for Rules that it declared in it’s `SupportedRules` definition.
+Any check will be allowed to produce reports only for Rules that it declared in it’s `SupportedRules` definition.
 
 #### Rules declaration
 
-A single analyzer can declare support of multiple rules – since it might produce reports for those on top of same input data – and for efficiency reasons a single processing of data might be needed.
+A single check can declare support of multiple rules – since it might produce reports for those on top of same input data – and for efficiency reasons a single processing of data might be needed.
 
 Simplified proposal of definition of a single rule:
 
 ```csharp
-public class BuildAnalyzerRule
+public class BuildExecutionCheckRule
 {
     // Identification/Description fields
     // (To be defined more precisely by https://github.com/dotnet/msbuild/issues/9823)
@@ -316,11 +316,11 @@ public class BuildAnalyzerRule
     /// The default configuration - overridable by the user via .editorconfig.
     /// If no user specified configuration is provided, this default will be used.
     /// </summary>
-    public BuildAnalyzerConfiguration DefaultConfiguration { get; }
+    public BuildExecutionCheckConfiguration DefaultConfiguration { get; }
 }
 ```
 
-<a name="BuildAnalyzerConfiguration"></a>Each rule will supply its default configuration (mainly enablement and report severity) – those will apply if `.editorconfig` file will not set those settings explicitly. If the rule doesn't provide (some of) its defaults, a global hardcoded default is used (`severity: message, enabled: false`).
+<a name="BuildExecutionCheckConfiguration"></a>Each rule will supply its default configuration (mainly enablement and report severity) – those will apply if `.editorconfig` file will not set those settings explicitly. If the rule doesn't provide (some of) its defaults, a global hardcoded default is used (`severity: message, enabled: false`).
 
 #### Standardized configuration declaration
 
@@ -328,37 +328,37 @@ Proposal of configuration specification:
 
 ```csharp
 /// <summary>
-/// Configuration for a build analyzer.
-/// Default values can be specified by the Analyzer in code.
+/// Configuration for a build check.
+/// Default values can be specified by the check in code.
 /// Users can overwrite the defaults by explicit settings in the .editorconfig file.
 /// Each rule can have its own configuration, which can differ per each project.
-/// The <see cref="EvaluationAnalysisScope"/> setting must be same for all rules in the same analyzer (but can differ between projects)
+/// The <see cref="EvaluationCheckScope"/> setting must be same for all rules in the same check (but can differ between projects)
 /// </summary>
-public class BuildAnalyzerConfiguration
+public class BuildExecutionCheckConfiguration
 {
     /// <summary>
     /// This applies only to specific events, that can distinguish whether they are directly inferred from
-    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from analysis.
+    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from check.
     ///
     /// If not supported by the data source - then the setting is ignored
     /// </summary>
-    public EvaluationAnalysisScope? EvaluationAnalysisScope { get; internal init; }
+    public EvaluationCheckScope? EvaluationCheckScope { get; internal init; }
 
     /// <summary>
     /// The default severity of the result for the rule. May be overridden by user configuration.
     ///
-    /// If all rules within the analyzer are `none`, the whole analyzer will not be run.
-    /// If some rules are `none` and some are not, the analyzer will be run and reports will be post-filtered.
+    /// If all rules within the check are `none`, the whole check will not be run.
+    /// If some rules are `none` and some are not, the check will be run and reports will be post-filtered.
     /// </summary>
-    public BuildAnalyzerResultSeverity? Severity { get; internal init; }
+    public BuildExecutionCheckResultSeverity? Severity { get; internal init; }
 }
 ```
 
-Values for this recognized contract, that are explicitly specified via .editorconfig files are passed both to the BuildCheck infrastructure as well as individual analyzers.
+Values for this recognized contract, that are explicitly specified via .editorconfig files are passed both to the BuildCheck infrastructure as well as individual checks.
 
 #### Custom configuration declaration
 
-However if user will specify additional – unrecognized - values in `.editorconfig` file as part of a particular analyzer configuration – those values will be extracted as key-value pairs and passed to the analyzer initialization call (`Initialize`) via `ConfigurationContext`:
+However if user will specify additional – unrecognized - values in `.editorconfig` file as part of a particular check configuration – those values will be extracted as key-value pairs and passed to the check initialization call (`Initialize`) via `ConfigurationContext`:
 
 ```csharp
 /// <summary>
@@ -374,7 +374,7 @@ public class ConfigurationContext
     /// <summary>
     /// Configuration data from standard declarations
     /// </summary>
-    public IReadOnlyList<BuildAnalyzerConfiguration> BuildAnalyzerConfig { get; init; }
+    public IReadOnlyList<BuildExecutionCheckConfiguration> BuildExecutionCheckConfig { get; init; }
 }
 ```
 
@@ -391,35 +391,35 @@ All the publicly exposed contracts will be available within `Microsoft.Build.Exp
 var availability = Features.CheckFeatureAvailability("BuildCheck.Beta");
 ```
 
-This way the analyzers authors will be equipped to write highly-compatible analyzers even in a possibility of changing API.
+This way the checks authors will be equipped to write highly-compatible checks even in a possibility of changing API.
 
 
 ### Testing and Debugging
 
 **TBD**
 
-We aim to provide ability to locally test analyzers from local projects or assemblies without a need to roundtrip through packaging them. The exact way is yet to be determined.
+We aim to provide ability to locally test checks from local projects or assemblies without a need to roundtrip through packaging them. The exact way is yet to be determined.
 
 At the same time we aim to provide mocks providing the BuildCheck context data – this work is however a non-goal.
 
 ### Packaging
 
-Several requirements are mandated for analyzer packages to be properly recognized (Netstandard only, A call to designated property function will need to be part of the packaged build assets, dependencies will need to be packaged, binaries structure flattened). There might as well be couple of optional practices making the analyzer package more resources savvy (E.g. defining the rule ids and enablement status within the mentioned property function - so that such information doesn't require loading and calling of the analyzer type).
+Several requirements are mandated for check packages to be properly recognized (Netstandard only, A call to designated property function will need to be part of the packaged build assets, dependencies will need to be packaged, binaries structure flattened). There might as well be couple of optional practices making the check package more resources savvy (E.g. defining the rule ids and enablement status within the mentioned property function - so that such information doesn't require loading and calling of the check type).
 
-Also custom analyzer package is a dependency is a purely development time harness - so it should be marked as [`DevelopmentDependency`](https://learn.microsoft.com/en-us/nuget/reference/nuspec#developmentdependency).
+Also custom check package is a dependency is a purely development time harness - so it should be marked as [`DevelopmentDependency`](https://learn.microsoft.com/en-us/nuget/reference/nuspec#developmentdependency).
 
 In order to simplify the packaging process (and meeting above mentioned requirements) a dotnet template will be provided producing proper package on pack action.
 
 **TBD** - dotnet new sample on initiating the development.
 
-## Acquisition of custom analyzers
+## Acquisition of custom checks
 
-Apart from [inbox analyzers](#inbox-analyzers) (shipped together with msbuild), users will be able to plug-in packaged analyzers shipped as nugets (this will serve for community contributions, but possibly as a venue for off-cycle distribution of official analyzers).
+Apart from [inbox checks](#inbox-checks) (shipped together with msbuild), users will be able to plug-in packaged checks shipped as nugets (this will serve for community contributions, but possibly as a venue for off-cycle distribution of official checks).
 
-In order to use an analyzer package users just need to reference them via `<PackageReference>` element as standard package reference. 
+In order to use an check package users just need to reference them via `<PackageReference>` element as standard package reference. 
 
 ```xml
-<PackageReference Include="Contoso.Analyzers" Version="1.2.3" />
+<PackageReference Include="Contoso.checks" Version="1.2.3" />
 ```
 
-Only projects referencing the package will be able to run its analyzers. Enabling the rules from package on other projects won’t take any effect.
+Only projects referencing the package will be able to run its checks. Enabling the rules from package on other projects won’t take any effect.
diff --git a/documentation/specs/BuildCheck/Codes.md b/documentation/specs/BuildCheck/Codes.md
index 6698d20a2dc..1af3e371ae1 100644
--- a/documentation/specs/BuildCheck/Codes.md
+++ b/documentation/specs/BuildCheck/Codes.md
@@ -2,22 +2,25 @@
 
 Report codes are chosen to conform to suggested guidelines. Those guidelines are currently in revew: https://github.com/dotnet/msbuild/pull/10088
 
-| Exit&nbsp;Code | Reason |
-|:-----|----------|
-| 0 | Success |
-| [BC0101](#BC0101) | Shared output path. |
-| [BC0102](#BC0102) | Double writes. |
-| [BC0103](#BC0103) | Used environment variable. |
+| Diagnostic&nbsp;Code | Default Severity | Reason |
+|:-----|-------|----------|
+| [BC0101](#bc0101---shared-output-path) | Warning | Shared output path. |
+| [BC0102](#bc0102---double-writes) | Warning | Double writes. |
+| [BC0103](#bc0103---used-environment-variable) | Suggestion | Used environment variable. |
+| [BC0201](#bc0201---usage-of-undefined-property) | Warning | Usage of undefined property. |
+| [BC0202](#bc0202---property-first-declared-after-it-was-used) | Warning | Property first declared after it was used. |
+| [BC0203](#bc0203----property-declared-but-never-used) | None | Property declared but never used. |
 
 
 To enable verbose logging in order to troubleshoot issue(s), enable [binary logging](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Binary-Log.md#msbuild-binary-log-overview)
 
 _Cmd:_
 ```cmd
-dotnet build -bl -analyze
+dotnet build -bl -check
 ```
 
-## <a name="BC0101"></a>BC0101 - Shared output path.
+<a name="BC0101"></a>
+## BC0101 - Shared output path.
 
 "Two projects should not share their OutputPath nor IntermediateOutputPath locations"
 
@@ -26,7 +29,8 @@ It is not recommended to share output path nor intermediate output path between
 If you want to produce outputs in a consolidated output folder - consider using the [Artifacts output layout](https://learn.microsoft.com/en-us/dotnet/core/sdk/artifacts-output) and/or [Microsoft.Build.Artifacts SDK](https://github.com/microsoft/MSBuildSdks/tree/main/src/Artifacts).
 
 
-## <a name="BC0102"></a>BC0102 - Double writes.
+<a name="BC0102"></a>
+## BC0102 - Double writes.
 
 "Two tasks should not write the same file"
 
@@ -34,7 +38,8 @@ This is a similar problem as ['BC0101 - Shared output path'](#BC0101) - however
 
 If you want multiple tasks to update file in a one-by-one pipeline fashion, it is recommended to give each intermediate output a distinct name - preventing silent mixups if any of the tasks in the chain are skipped or removed.
 
-## <a name="BC0103"></a>BC0103 - Used environment variable.
+<a name="BC0103"></a>
+## BC0103 - Used environment variable.
 
 "Environment variables should not be used as a value source for the properties"
 
@@ -43,6 +48,51 @@ Relying on environment variables introduces variability and unpredictability, as
 
 This practice can result in inconsistent build outcomes and makes debugging difficult, since environment variables are external to project files and build scripts. To ensure consistent and reproducible builds, avoid using environment variables. Instead, explicitly pass properties using the /p option, which offers better control and traceability.
 
+<a name="BC0201"></a>
+## BC0201 - Usage of undefined property.
+
+"A property that is accessed should be declared first."
+
+This check indicates that a property was accessed without being declared (the declaration might have happen later - see [BC0202](#BC0202) for such checking). Only accessing in the configured scope (by default it's the project file only) are checked.
+
+There are couple cases which are allowed by the check:
+
+* Selfreferencing declaration is allowed - e.g.:
+  `<ChainProp>$(ChainProp)</ChainProp>`
+
+* Checking the property for emptyness - e.g.:
+  `<PropertyGroup Condition="'$(PropertyThatMightNotBeDefined)' == ''">`
+
+* Any usage of property in condition. This can be opted out via the configuration `AllowUninitializedPropertiesInConditions` - e.g.:
+  ```ini
+  [*.csproj]
+  build_check.BC0201.severity=error
+  build_check.BC0201.AllowUninitializedPropertiesInConditions=false
+  build_check.BC0202.AllowUninitializedPropertiesInConditions=false
+  ```
+
+  BC0201 and BC0202 must have same value for the optional switch - as both operate on top of same data and same filtering.
+
+<a name="BC0202"></a>
+## BC0202 - Property first declared after it was used.
+
+"A property should be declared before it is first used."
+
+This check indicates that a property was accessed before it was declared. The default scope of this rule is the project file only. The scope captures the read and write operations as well. So this rule reports:
+ * Uninitialized reads that happened anywhere during the build, while the uninitialized property was later defined within the scope of this check (e.g. project file).
+ * Uninitialized reads that happened within the scope of check (e.g. project file), while later defined anywhere in the build
+
+If `BC0202` and [BC0201](#BC0201) are both enabled - then `BC0201` reports only the undefined reads that are not reported by this rule (so those that do not have late definitions).
+
+<a name="BC0203"></a>
+## BC0203 -  Property declared but never used.
+
+"A property that is not used should not be declared."
+
+This check indicates that a property was defined in the observed scope (by default it's the project file only) and it was then not used anywhere in the build.
+
+This is a runtime check, not a static analysis check - so it can have false positives (as property not used in particular build might be needed in a build with different conditions). For this reasons it's currently only suggestion.
+
 <BR/>
 <BR/>
 <BR/>
diff --git a/documentation/specs/proposed/BuildCheck-acquisition-challenge.md b/documentation/specs/proposed/BuildCheck-acquisition-challenge.md
index b92a45f36a4..cc19390f06a 100644
--- a/documentation/specs/proposed/BuildCheck-acquisition-challenge.md
+++ b/documentation/specs/proposed/BuildCheck-acquisition-challenge.md
@@ -4,21 +4,21 @@ This is an internal engineering document. For general overview and user-oriented
 
 # Challenge
 
-Let's recall some details of BuildCheck analyzers acquisition. There might be two types of the build analyzer: build-in and custom. 
-The build-in analyzers are configured in the `.editorconfig` file. The custom analyzers are declared in the project files via PackageReference and also configured in the `.editorconfig` file.
-Project files are read during the first pass of the evaluation of the project. Given the multi-processing nature of MSBuild, this might happen either on main node or on the msbuild worker node. When the analyzer is encountered, the event `BuildCheckAcquisitionEventArgs` is logged with information concerning the analyzer that is needed to be loaded. This event is forwarded by `BuildCheckForwardingLogger` through logging system via the named pipes to the main msbuild node, where it is processed by `BuildCheckConnectorLogger`. This requires the logging system to be configured on main and worker msbuild nodes. 
+Let's recall some details of BuildCheck checks acquisition. There might be two types of the build check: build-in and custom. 
+The build-in checks are configured in the `.editorconfig` file. The custom checks are declared in the project files via PackageReference and also configured in the `.editorconfig` file.
+Project files are read during the first pass of the evaluation of the project. Given the multi-processing nature of MSBuild, this might happen either on main node or on the msbuild worker node. When the check is encountered, the event `BuildCheckAcquisitionEventArgs` is logged with information concerning the check that is needed to be loaded. This event is forwarded by `BuildCheckForwardingLogger` through logging system via the named pipes to the main msbuild node, where it is processed by `BuildCheckConnectorLogger`. This requires the logging system to be configured on main and worker msbuild nodes. 
 
-![analyzers-acquisition](analyzers-acquisition.png)
+![checks-acquisition](checks-acquisition.png)
 
 There are two issues that arise from such a design:
-1. The configuration of the logging system should be ideally dependent on the set of the applied build analyzers. Verbosity of the build hugely affects the set of logging events that are logged by default. Moreover, some events are not forwarded with forwarding loggers, depending on forwarding loggers configuration. This is done for performance reasons to allow to drop the events that are not consumed by any of the central loggers. We need to ensure that the events required for the analyzers to work pass through. For that we need to have information about active rules from the `.editorconfig` file and the declarations in the project files via PackageReference when setting up the logging system.
+1. The configuration of the logging system should be ideally dependent on the set of the applied build checks. Verbosity of the build hugely affects the set of logging events that are logged by default. Moreover, some events are not forwarded with forwarding loggers, depending on forwarding loggers configuration. This is done for performance reasons to allow to drop the events that are not consumed by any of the central loggers. We need to ensure that the events required for the checks to work pass through. For that we need to have information about active rules from the `.editorconfig` file and the declarations in the project files via PackageReference when setting up the logging system.
 2. There is no synchronization between build manager and logging service. When the build check acquisition events get to the main node, most of the build might have been already finished on worker nodes.
 
 # Solution ideas
 
-- When analyzers are used, always create and forward all the events. This will have a considerable impact on performance but makes configuring of the logging system easy.
-- Set up the logger configuration before the build starts on the worker nodes: the main node can read the `.editorconfig` file and set up the correct configuration. For custom analysers we cannot do that, as they could be downloaded during the restore and discovered during the evaluation. 
+- When checks are used, always create and forward all the events. This will have a considerable impact on performance but makes configuring of the logging system easy.
+- Set up the logger configuration before the build starts on the worker nodes: the main node can read the `.editorconfig` file and set up the correct configuration. For custom checks we cannot do that, as they could be downloaded during the restore and discovered during the evaluation. 
 - Change the initial confuguration of the logging system (in particular, forwardning loggers) during the build. 
-    - Do that as soon as we get the events `BuildCheckAcquisitionEventArgs` in forwarding logger: create a custom `BuildCheckForwardingLogger` that will re-configure itself when it gets `BuildCheckAcquisitionEventArgs`. This will need reading the editorconfig files and possibly loading custom analyzers in the worker node in order to find which events are needed for the custom analyzers. We will miss some of the events on the evaluation prior `BuildCheckAcquisitionEventArgs` event but since the events are processed in an order, the new filters in the forwarding logger will apply to the later events.
-    - Process the events `BuildCheckAcquisitionEventArgs` in the build check manager and send a message to the worker node to re-configure it. However due to the absence of syncronization between build manager and logging service, this message might get processed on the worker node late and we will miss a lot of events needed for the analyzers.  
+    - Do that as soon as we get the events `BuildCheckAcquisitionEventArgs` in forwarding logger: create a custom `BuildCheckForwardingLogger` that will re-configure itself when it gets `BuildCheckAcquisitionEventArgs`. This will need reading the editorconfig files and possibly loading custom checks in the worker node in order to find which events are needed for the custom checks. We will miss some of the events on the evaluation prior `BuildCheckAcquisitionEventArgs` event but since the events are processed in an order, the new filters in the forwarding logger will apply to the later events.
+    - Process the events `BuildCheckAcquisitionEventArgs` in the build check manager and send a message to the worker node to re-configure it. However due to the absence of syncronization between build manager and logging service, this message might get processed on the worker node late and we will miss a lot of events needed for the checks.  
 - As an addition the previous ideas, we may initialize the loggers from cache (either in-process cache or cache file in file system). We might have a strict mode which in case of cache miss invalidates and restarts a corresponding build.
diff --git a/documentation/specs/proposed/Wasm-tasks.md b/documentation/specs/proposed/Wasm-tasks.md
new file mode 100644
index 00000000000..519815bcd66
--- /dev/null
+++ b/documentation/specs/proposed/Wasm-tasks.md
@@ -0,0 +1,354 @@
+# Wasm/WASI tasks in MSBuild
+Exploration of using Wasm/WASI to create sandboxed [Tasks in MSBuild](https://learn.microsoft.com/visualstudio/msbuild/msbuild-tasks) using non-dotnet Wasm/WASI compatible language.
+
+## Stories 
+Currently MSBuild tasks have unrestricted access to resources (filesystem, network, environment variables), Wasm/WASI runtimes provide a way to sandbox tasks (all access to resources has to be specified). Sandboxing is useful from a security perspective if someone wanted to run a task from an untrusted source without decompiling and analyzing it.
+
+Today a MSBuild task = .NET class. We want to enable users to write a task in another language. This feature includes designing how tasks will communicate with MSBuild if they're running out of the .NET runtime. Ecosystems that support the Wasm/WASI development features are: Rust and C/C++ at the moment, with ongoing development in Go and others.
+
+## Terminology and context
+-  **WebAssembly (abbreviated Wasm)**
+> is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications. - [webassembly.org/](https://webassembly.org/)
+
+- [**WASI**](https://wasi.dev/) : WebAssembly System Interface is a standard for APIs for software compiled to Wasm to use system resouces outside of browsers.
+    - WASIp1 filesystem, environment variables, stdIO, programs are "Modules"
+    - WASIp2 rich interface data types, networking, programs are "Components"
+- [**Wasmtime**](https://wasmtime.dev) : Wasm runtime implementation for desktops supporting WASI
+- **Wasm Module** a compiled Wasm program that exposes functions to the host and expects imports functions from the host
+
+### Diagram of a Wasm execution from a host
+```mermaid 
+flowchart TD
+    a[guest language] -->|compile with wasi-sdk| K[Wasm Module]
+
+    A[Engine]  --> E[Linker]
+    
+    E -->|Define host functions & WASI| H[Instance]
+
+    H <---> Mem[Shared Memory]
+    
+    K[Module] -->|Piece of functionality| H
+    
+    L[Store] -->|Config for runtime| H
+    
+    H -->|Invoke module functions| M[Execution]
+
+    subgraph " "
+    A
+    K
+    L
+    end
+
+    subgraph "Single run"
+    H
+    E
+    M
+    Mem
+    end
+
+```
+
+### Interacting with Wasm/WASI in MSBuild without Wasm/WASI Tasks
+In a build, we can use the [`Exec` task](https://learn.microsoft.com/visualstudio/msbuild/exec-task) with Wasmtime and an executable .wasm file, but this execution would not have any MSBuild capabilities such as logging and passing of file parameters.
+
+#### Rust example:
+1. install [wasi-sdk](https://github.com/WebAssembly/wasi-sdk), [wasmtime](https://wasmtime.dev), [cargo](https://doc.rust-lang.org/cargo/getting-started/installation.html)
+3. write your Rust program
+3. `project.csproj`
+```xml
+  <Target Name="CompileAndRun" BeforeTargets="Build">
+    <Exec Command="cargo build --target wasm32-wasi --release --manifest-path='sometask/Cargo.toml'">
+    <Exec Command="wasmtime run path_to_compiled_rust_program.wasm --additional_args_for_wasmtime_enabling_more_than_CPU_and_memory" />
+</Target>
+```
+4. `dotnet build`
+This does not provide an ergonomic way to pass MSBuild parameters to the "task" or get outputs from it.
+
+## Goals for the Wasm tasks feature
+1. specify how a Wasm/WASI task should communicate with MSBuild, and what it should contain to be recognized as a task
+2. Write an `ITaskFactory` and a supporting `ITask` classes that when passed a `.wasm` file implementing required functions runs it as an MSBuild task
+3. Demos/examples
+
+### Prototype features
+Prototypes are implemented in [https://github.com/JanProvaznik/MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm)
+- ✅ WasmTask - creating tasks from .wasm files
+    - ✅ Specification for what should this .wasm file export and how it will be ran
+    - ✅ ITaskFactory that let's msbuild use task parameters defined inside the .wasm module
+- ✅ Rust example
+
+#### User Experience
+1. `dotnet new install MSBuildWasm.Templates`
+2. `dotnet new rust.msbuild.task -o new-project-using-rust-task` 
+3. The user Writes a task in Rust based on the template, compiles it to a .wasm module e.g. `cargo b --target wasm32-wasi`
+4. The user adds the task to their .proj file and it runs and logs as if it were a C# task. Template:
+```xml
+<ItemGroup>
+  <PackageReference Include="MSBuildWasm" Version="0.2.0" />
+</ItemGroup>
+
+...
+
+<UsingTask TaskName="FancyWasmTask" 
+           AssemblyFile="$(MSBuildWasmAssembly)" 
+           TaskFactory="WasmTaskFactory" 
+           Condition="$(MSBuildWasmAssembly) != ''">
+  <Task>compiled_task_implementation.wasm</Task>
+</UsingTask>
+
+<Target Name="name">
+  <FancyWasmTask Param="..." Param2="asdf">
+    <Output .../>
+  </FancyWasiTask>
+</Target>
+```
+
+### Advanced features
+- ✅ prototype `MSBuildWasm.Templates` package
+- ❌ ~~.NET example~~ (WASIp1 will not be supported in .NET)
+- [ ] integrating pipeline for creating Wasm/WASI tasks from code in Rust 
+    - [ ] investigate integrating tools compiling languages to Wasm/WASI
+    - On task level
+        - [ ] RustTaskFactory
+        - exploring other languages (Go, C/C++, Zig)
+- investigate running an arbitrary .NET task distributed as a dll in the WASI sandbox (👀 Mono runtime)
+    - ❌ Due to the prototype implementing WasmTasks with WASIp1, it will not compatible with .NET runtime effort to support WASIp2; ecosystem for implementing WasmTasks with WASIp2 is not ready yet
+
+
+## Design
+### diagram
+
+```mermaid
+flowchart TD
+    A[MSBuild] -.->|1. Registering tasks| B[WasmTaskFactory]
+    A -.->|5. Target execution| C[TaskExecutionHost]
+    C -->|6. a. instantiate \n b. set parameters from XML\n c. Execute task| D[WasmTask]
+    H[languages targeting wasi P1] -->|"0. compile using wasi-sdk/cargo"| G
+    D -->|9. properties| C 
+    
+    D -->|7. run module's Execute function| E[wasmtime-dotnet]
+    E -->|8. stdout json \nwith property values| D
+    E <--> F[Wasmtime]
+
+    B -->|4. Create Type for\n the specific WasmTask| D
+    B <-->|3. GetTaskParameters| E
+    G[.wasm module] -->|2. module path via XML| B
+    %%B, C, D%%
+    style A fill:magenta
+    style B fill:#512bd4
+    style C fill:#512bd4
+    style D fill:#512bd4
+```
+MSBuildWasm classes are purple.
+
+
+### Wasm/WASI communication with MSBuild
+Without WASIp2 WIT (which is not yet implemented in wasmtime-dotnet: [issue](https://github.com/bytecodealliance/wasmtime-dotnet/issues/324) ), the only data type that can be a Wasm function parameter and output is a number. MSBuild Tasks have parameters which are of the following types: `string`, `bool`, [ITaskItem](https://github.com/dotnet/msbuild/blob/main/src/Framework/ITaskItem.cs) (basically a string dict), and arrays of these types.
+
+In the current implementation the .wasm task module has to: 
+-  **import** functions from "module" `msbuild-log`: `LogError(u32 message_ptr, u32 message_len)`, `LogWarning(u32 message_ptr, u32 message_len)`, `LogMessage(u32 MessageImportance, u32 message_ptr, u32 message_len)`. 
+-  **export** functions `GetTaskInfo()`; `Execute() -> u32`, which returns 0 for success and 1 for failure.
+
+### Task parameters 
+What parameters the task has is obtained by calling GetTaskInfo() in the Task wasm module. When initializing the task with the `WasmTaskFactory` we use reflection to create a C# type with corresponding properties.
+Task parameter values are passed into the wasm module as a JSON string in stdin.
+
+For future reference we describe the proposed interface [in the WASIp2 WIT format](./wasmtask.wit) once it is supported in wasmtime-dotnet as a model for rewrite to WASIp2. This would remove the need to use JSON strings for passing parameters and logs could be passed using strings rather than pointers, the [wit-bindgen](https://github.com/bytecodealliance/wit-bindgen) tool could be used to generate guest language bindings/composite types.
+
+Every resource available to the Wasm/WASI runtime has to be specified explicitly when running the host - Wasmtime is a sandbox by default. WASIp1 via wasmtime-dotnet enables: preopening directories, environment variables, stdIO, args (if ran as a standalone program), 
+The prototype implementation uses the following features:
+It copies items on input to a temporary directory and passes the path to the Wasm module. The module can access these files and write to the directory. Output properties are copied out after the run. StdIn is used for passing parameters and StdOut for getting the output.
+Users can specify in the task usage `Directories="directories on host that can be accessed in addition to the temporary one"`
+- After the task is run, Output parameters as a JSON are read from stdout of the Wasm execution, and parsed back into C# class properties so the rest of MSBuild can use them.
+WASIp2 defines more host features, but configuring them [is not yet exposed](https://github.com/bytecodealliance/wasmtime/issues/8036#issuecomment-2180272305) in the .NET host API: [WASI docs](https://github.com/WebAssembly/WASI/tree/main/wasip2) e.g. random, networking, clocks.
+
+### Json format for parameter spec
+They mirror MSBuild Task parameters as they need to be reflected to a C# class.
+```jsonc
+{
+    "properties": [
+        {
+            "name": "Param1",
+            "property_type": "String", 
+            "required": true, // Maps to RequiredAttribute in MSBuild
+            "output": false // Maps to OutputAttribute in MSBuild
+        },
+        {
+            "name": "Param2",
+            "property_type": "Bool",
+            "required": false,
+            "output": false
+        },
+        {
+            "name": "Param3",
+            "property_type": "ITaskItem", 
+            "required": false,
+            "output": false
+        },
+        {
+            "name": "Param4",
+            "property_type": "ITaskItemArray",
+            "required": false,
+            "output": true // output means that the parameter is read from the output of the task, but it can be inputted too
+        }
+    ]
+}
+```
+### Json format for parameter values
+```jsonc
+{
+    "Param1": "hello",
+    "Param2": true,
+    "Param3": {
+        "ItemSpec": "C:\\real\\path\\file.txt",
+        "WasmPath": "file.txt", // guest runtime path
+        "More .NET metadata": "..."
+    },
+    "Param4": [
+        {
+            "ItemSpec": "item1",
+            "Metadata1": "value1"
+        },
+        {
+            "ItemSpec": "item2",
+            "Metadata2": "value2"
+        }
+    ]
+}
+```
+
+### Json format for task output
+Only parameters with the output attribute set to true are recognized from the output in the MSBuild task.
+```jsonc
+{
+    "Param4": [
+        {
+            "ItemSpec": "also/can/be/dir",
+            "WasmPath": "also/can/be/dir"
+        },
+        {
+            "ItemSpec": "name_in_host.txt",
+            "WasmPath": "item.txt"
+        }
+    ]
+}
+```
+
+
+### Testing
+#### Unit tests
+- [ ] setting parameters in the task
+- [ ] parsing outputs
+- [ ] examples contain expected functions
+
+#### E2E tests
+- Using Wasm/WASI Tasks in a build
+- [ ] Rust tasks
+    - [ ] logging
+    - [x] passing parameters
+    - [x] accessing files
+
+
+## Implementation details
+### wasmtime-dotnet bindings and basic usage
+```csharp
+using var engine = new Engine();
+using var module = Module.FromFile(engine, WasmFilePath);
+using var linker = new Linker(engine);
+linker.DefineWasi(); // linking WASI
+linker.Define("namespace", "function", (Action)delegate { /* do something */ }); // Host function that can be called from Wasm
+using var store = new Store(engine);
+var wasiConfigBuilder = new WasiConfiguration(); // enable resources: InheritEnvironment, PreopenedDirectory, StdIO 
+store.SetWasiConfiguration(wasiConfigBuilder);
+Instance instance = linker.Instantiate(store, module);
+Action fn = instance.GetAction("Execute");
+fn.Invoke();
+```
+
+
+## Development remarks
+
+### Architectural decision record
+- **Inside MSBuild or as an external package?**
+    - the feature seems largely independent
+    - *-> separate repo https://github.com/JanProvaznik/MSBuild-Wasm, some features might need coordination - feature branch `dev/wasi-tasks`*
+    - *-> actually the TaskExecutionHost is a very deep MSBuild thing and would need refactoring*
+
+- **implementing WASI api on our own like [wasm in vscode](https://github.com/microsoft/vscode-wasm)?**
+    - customizable👍
+    - hard to maintain👎, wasi is changing
+    - lot of work 👎
+    - *-> resolved to use wasmtime*
+    - Choosing Wasm/WASI runtime 
+        - https://wasi.dev/ mentions several possible runtimes: Wasmtime, WAMR, WasmEdge, wazero, Wasmer, wasmi, and wasm3.
+        - An important criterion is popularity/activity in development as the WASM standard is evolving and needs a lot of developers to implement it.
+        - This leads to considering [Wasmtime](https://wasmtime.dev/) or [Wasmer](https://wasmer.io/).
+        - Interaction with C# is especially important for us so we will use **Wasmtime** because the integration via a NuGet package is more up to date and there is more active development in tooling and other .NET projects use it. [wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) provides access to wasmtime API
+
+- **bundling wasm runtime with MSBuild?**
+    - compatibility👍
+    - ease of use 👍
+    - size👎
+    - maintenance👎
+    - *-> make a nuget package, no need to release under msbuild now, eventually could happen, lot of compat/licencing concerns. bytecodealliance is a consortium containing Microsoft*
+
+- **Interacting with the tooling for creating .wasi files from other languages?**
+    - hard, unstable
+    - *-> in scope but ambitious, the package can check/download and install tooling (wasi-sdk, rust) in simple cases*
+
+- **start with windows or UNIX?**
+    - *-> most different is the investigation about how to bundle tooling for other languages*
+
+- **renaming this feature from WASI-... to Wasm-...**
+    - file extensions are called .wasm 👍
+    - WASI is a standard building on Wasm 👍
+    - the compilation target is called wasm-wasi 👍👎
+    - *-> use Wasm/WASI, the repo is called [MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm) for brevity*
+
+- **communication between host and a wasm module**
+    - shared memory, both host and wasm can access it; callbacks where to read from it, environment vars, stdIO 
+    - eventually with Wasm/WASI component model better data-structures  
+    - component model would help us a lot with passing data it has support for complex types [WebAssembly interface type](https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md) 
+        - but wasmtime-dotnet does not support it now and the implementation is nontrivial: https://github.com/bytecodealliance/wasmtime-dotnet/issues/324#issuecomment-2218889279
+    - *-> use JSON strings with callbacks and stdIO for now, with parsing on both sides, WIT is not implemented in wasmtime-dotnet*
+        - JSON is a suitable format because we pass: lists, dicts strings and bools; and [`serde`](https://serde.rs/) in Rust enables ergonomic serialization to/from data structures
+     
+- **TaskExecutionHost?**
+    - TaskExecutionHost is the class that usually runs instantiated tasks and uses reflection to give them property values, 
+    - if we want this layer to handle setting up the environment for the task it has to be abstracted and the interface implemented by custom WasmTaskExecutionHost
+    - Blocked by having to bring the feature to MSBuild repo and refactoring TaskBuilder and including wasmtime-dotnet
+    - *-> keep it separate from MSBuild for now, it's OK that the base WasmTask class will handle setting up the Wasm/WASI environment*
+
+### Related projects
+
+[wasmtime](https://wasmtime.dev/) - Wasm runtime supporting the WASI standard written in Rust by *Bytecode Alliance* - consortium, where Microsoft is a member 
+
+[wasmtime-dotnet](https://github.com/bytecodealliance/wasmtime-dotnet) - Bindings for wasmtime API in C#, via the C API, maintained by *Bytecode Alliance*
+
+[componentize-dotnet](https://github.com/bytecodealliance/componentize-dotnet) NuGet package to easily make a WASI component from a C#.NET project using NativeAOT-LLVM, experimental release June 2024, created by people from Microsoft, the prototype can't use it because components are different from modules and we can't switch because wasmtime-dotnet does not support components.
+
+[dotnet-wasi-sdk](https://github.com/dotnet/dotnet-wasi-sdk) 
+- compile dotnet to Wasm
+- moved to sdk and runtime repos `dotnet workload install wasi-experimental` in .NET 8.0 
+    - Discussions: [1](https://github.com/dotnet/runtime/tree/main/src/mono/wasm) [2](https://github.com/dotnet/runtime/discussions/98538#discussioncomment-8499105) [3](https://github.com/dotnet/runtime/issues/65895#issuecomment-1511265657)
+    - it does not support function exports and imports to the extent needed for prototype implementation
+- developments that would enable using Wasm/WASI tasks written in .NET were added after the workload release but recently removed as .NET will focus only on WASIp2
+
+MSBuild issues for making other environments for running tasks: [711](https://github.com/dotnet/msbuild/issues/711) [4834](https://github.com/dotnet/msbuild/issues/4834) [7257](https://github.com/dotnet/msbuild/issues/7257)
+
+### Random
+- wasmtime-dotnet needs to be signed to have a StrongName and put in a private feed if we'd like to integrate it to MSBuild proper eventually [PR](https://github.com/bytecodealliance/wasmtime-dotnet/pull/320)
+
+- languages other than Rust are moving slowly and it's unclear if they'll implement WASIp1 at all or just like .NET will focus on WASIp2. Closest to support is Go but it's missing function exports [issue](https://github.com/golang/go/issues/65199). .NET 9 preview 6 possibly implements everything needed for Wasm/WASI tasks via Mono but in preview 7 it changed to target WASIp2 and it won't come back [PR](https://github.com/dotnet/runtime/pull/104683).
+
+### Conclusion and Future work
+State of the Wasm/WASI ecosystem does not enable implementing a robust useful solution right now (August 2024), in terms of functionality [MSBuildWasm](https://github.com/JanProvaznik/MSBuildWasm) is close to what is ergonomically possible using WASIp1 modules.
+To get the sandboxing benefit of using WASI runtimes, several things need to happen first:
+- wasmtime C API to support WASIp2 components and better granularity for giving access to resources in the guest. 
+- wasmtime-dotnet has to implement bindings to the updated C API 
+- an easy way to convert WIT to C# host bindings (wit-bindgen only handles guest bindings)
+- figure out what MSBuild context do we want to pass (now it's just the logging functions)
+- less experimental Mono WASIp2 support
+- make a component for executing .NET tasks
+
+To get the multilanguage task authoring benefit:
+- Other languages have to implement the component model and an easy workflow to compile library components
\ No newline at end of file
diff --git a/documentation/specs/proposed/wasmtask.wit b/documentation/specs/proposed/wasmtask.wit
new file mode 100644
index 00000000000..97db65fbc14
--- /dev/null
+++ b/documentation/specs/proposed/wasmtask.wit
@@ -0,0 +1,88 @@
+﻿package msbuild:wasm-task;
+
+// Callbacks with logs from the task to the MSBuild logging system
+interface host-logger {
+    enum message-importance {
+        high, 
+        normal,
+        low
+    }
+
+    log-message: func(importance: message-importance, message: string);
+    log-warning: func(message: string);
+    log-error: func(message: string);
+}
+
+// Describes the task's interface to MSBuild
+world wasm-task {
+    // wit doesn't have maps/dictionaries
+    record string-kv-pair {
+        key: string,
+        value: string
+    }
+    type string-map = list<string-kv-pair>;
+
+    // Mirroring TaskItem in MSBuild - it's a description of a file or directory
+    record task-item { 
+        // Path inside the sandbox
+        wasm-path: string,
+        metadata: string-map
+    }
+    // Enum for types of properties in tasks
+    enum property-type {
+        bool-type,
+        string-type,
+        task-item-type,
+        bool-array-type,
+        string-array-type,
+        task-item-array-type
+    }
+
+    // Variant contains one of the possible types of properties
+    variant property-value {
+        bool-value(bool),
+        string-value(string),
+        task-item(task-item),
+        bool-array(bool-list),
+        string-array(string-list),
+        task-item-array(task-item-list)
+    }
+
+    type task-item-list = list<task-item>;
+    type bool-list = list<bool>;
+    type string-list = list<string>;
+
+    // Mirrors MSBuild's TaskPropertyInfo
+    record task-property-info {
+        name: string,
+        proptype: property-type,
+        output: bool,
+        required: bool
+    }
+
+    // Information about a task passed from the task to MSBuild
+    record task-info {
+        name: string,
+        parameters: list<task-property-info>,
+        metadata: string-map // E.g., requirements for the host environment
+    }
+
+    // Information about the host environment passed from MSBuild to the task
+    record host-info {
+        preopened-directories: task-item-list
+    }
+
+    // Input to execute 
+    // (In MSBuild, normally the task already magically has set its properties to the values from the project file, but here we need to pass them)
+    record task-input {
+        host-info: host-info,
+        properties: list<property-value>
+    }
+
+    // Host obtains information about the task to know what properties to read from the project file and pass in
+    export get-task-info: func() -> task-info;
+    // Execute is the entry point for the task, returns success
+    export execute: func(input: task-input) -> bool;
+    // Task should call host-logger functions to log messages
+    import host-logger;
+}
diff --git a/documentation/wiki/Binary-Log.md b/documentation/wiki/Binary-Log.md
index d9bb101159f..100f45c363a 100644
--- a/documentation/wiki/Binary-Log.md
+++ b/documentation/wiki/Binary-Log.md
@@ -82,6 +82,16 @@ It is a `GZipStream`-compressed binary stream of serialized `BuildEventArgs` obj
  * https://source.dot.net/#Microsoft.Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
  * https://source.dot.net/#Microsoft.Build/Logging/BinaryLogger/BuildEventArgsReader.cs
 
+## Meaning of various Ids in the BuildEventArgs
+
+The [`BuildEventArgs`](https://github.com/dotnet/msbuild/blob/main/src/Framework/BuildEventArgs.cs) sent to the loggers (and later stored in the binlog) can have [`BuildEventContext`](https://github.com/dotnet/msbuild/blob/main/src/Framework/BuildEventContext.cs) attached. This context contains multiple integer Ids, that can be of interest for the consumer:
+* `ProjectInstanceId` - This indicates unique combination of a project and global properties (basically a project configuration for a build.). The same combination dictates a need for evaluation (or possibility to reuse existing) - so the id correlates with `EvaluationId`. `ProjectInstanceId` is however not present on evaluation events.
+* `EvaluationId` - Indicates unique evaluation run - that needs to happen for each unique combination of project and global properties. `EvaluationId` is present on all evaluation time events and on the `ProjectStartedEventArgs` (this event can be used to correlate the `EvaluationId` with `ProjectInstanceId` - to get all build execution time events that used a specific evaluation).
+* `ProjectContextId` - This indicates unique build request (so request for result from project + target(s) combination). There can be multiple build requests using the same evaluation - so a single `ProjectInstanceId` (and `EvaluationId`) often maps to multiple `ProjectContextId`s
+* `NodeId` - indicates the node where the event was generated ('0' for the SchedulerNode with possible in-proc execution node, positive ids for the out-of-proc execution nodes). The whole evaluation happens on a single node - so all evaluation time events with single `EvaluationId` have same `NodeId`. Execution is attempted to be performed on a node which evaluated ('evaluation affinity') - so usually all events with corresponding `EvaluationId` and `InstanceId` have the same `NodeId`. But evaluation results are transferable between nodes (it's `Translatable`) so evaluation events and build events `NodeId` doesn't have to match. Single build execution happens on the same node - so all events with same `ProjectContextId` have same `NodeId`. Though multiple build executions can be interleaved on a same node (due to 'Yielding' - either voluntarily explicitly called by the Task, or implicitly enforced by `RequestBuilder`).
+
+It's also good to note that those Ids can have negative values - indicating uninitialized value (this can be expected in many cases - e.g. evaluation time events cannot have `ProjectContextId` as they are not tied to single result request; or `ProjectInstanceId` are not ever populated on evaluation time events).
+
 ## Incrementing the file format
 
 Every .binlog file has the first four bytes that indicate the file version. The current file format is indicated in [`BinaryLogger.cs`](/src/Build/Logging/BinaryLogger/BinaryLogger.cs).
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index ef38fa5942e..5a3d6067090 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -28,9 +28,10 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Convert.ToString during a property evaluation uses the InvariantCulture for all types](https://github.com/dotnet/msbuild/pull/9874)
 - [Fix oversharing of build results in ResultsCache](https://github.com/dotnet/msbuild/pull/9987)
 - [Add ParameterName and PropertyName to TaskParameterEventArgs](https://github.com/dotnet/msbuild/pull/10130)
+- [Emit eval props if requested by any sink](https://github.com/dotnet/msbuild/pull/10243)
 
 ### 17.10
-- [AppDomain configuration is serialized without using BinFmt](https://github.com/dotnet/msbuild/pull/9320) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
+- [AppDomain configuration is serialized without using BinFmt](https://github.com/dotnet/msbuild/pull/9320) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`. **Please note that [any usage of BinaryFormatter is insecure](https://learn.microsoft.com/dotnet/standard/serialization/binaryformatter-security-guide).**
 - [Warning on serialization custom events by default in .NET framework](https://github.com/dotnet/msbuild/pull/9318)
 - [Cache SDK resolver data process-wide](https://github.com/dotnet/msbuild/pull/9335)
 - [Target parameters will be unquoted](https://github.com/dotnet/msbuild/pull/9452), meaning  the ';' symbol in the parameter target name will always be treated as separator
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index f1d1ac8aa51..f402448b04f 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -2,9 +2,9 @@
 <Dependencies>
   <ProductDependencies>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.24372.3">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.24415.1">
       <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>30ed464acd37779c64e9dc652d4460543ebf9966</Sha>
+      <Sha>fe3794a68bd668d36d4d5014a9e6c9d22c0e6d86</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
@@ -104,9 +104,9 @@
       <Sha>5e3a11e2e7f952da93f9d35bd63a2fa181c0608b</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24376.1">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24413.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>1e2be7464703499cf98e20536fb4da4218c8fce1</Sha>
+      <Sha>51321b7e150a2f426cb9e1334687bdfab68ec323</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 8e667cbc5c6..1924e4b68dc 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -3,7 +3,7 @@
 <Project>
   <PropertyGroup>
     <VersionPrefix>17.12.0</VersionPrefix>
-    <PackageValidationBaselineVersion>17.11.0-preview-24318-05</PackageValidationBaselineVersion>
+    <PackageValidationBaselineVersion>17.11.4</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -49,7 +49,7 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24376.1</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24413.2</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.1</MicrosoftIORedistVersion>
     <MicrosoftNetCompilersToolsetVersion>4.11.0-3.24378.3</MicrosoftNetCompilersToolsetVersion>
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index faf9f3f8ccf..1d65cf6b471 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -82,7 +82,7 @@ public BuildManager_Tests(ITestOutputHelper output)
                 EnableNodeReuse = false
             };
             _buildManager = new BuildManager();
-            _projectCollection = new ProjectCollection();
+            _projectCollection = new ProjectCollection(globalProperties: null, _parameters.Loggers, ToolsetDefinitionLocations.Default);
 
             _env = TestEnvironment.Create(output);
             _inProcEnvCheckTransientEnvironmentVariable = _env.SetEnvironmentVariable("MSBUILDINPROCENVCHECK", "1");
@@ -137,8 +137,8 @@ public void SimpleBuild()
             _logger.AssertLogContains("[success]");
             Assert.Single(_logger.ProjectStartedEvents);
 
-            ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
-            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
+            ProjectEvaluationFinishedEventArgs evalFinishedEvent = _logger.EvaluationFinishedEvents[0];
+            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(evalFinishedEvent.Properties);
 
             Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.Equal("InitialProperty1", propertyValue);
@@ -254,8 +254,8 @@ public void SimpleGraphBuild()
             _logger.AssertLogContains("[success]");
             _logger.ProjectStartedEvents.Count.ShouldBe(1);
 
-            ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
-            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
+            ProjectEvaluationFinishedEventArgs evalFinishedEvent = _logger.EvaluationFinishedEvents[0];
+            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(evalFinishedEvent.Properties);
 
             properties.TryGetValue("InitialProperty1", out string propertyValue).ShouldBeTrue();
             propertyValue.ShouldBe("InitialProperty1", StringCompareShould.IgnoreCase);
@@ -571,8 +571,8 @@ public void InProcForwardPropertiesFromChild()
             _logger.AssertLogContains("[success]");
             Assert.Single(_logger.ProjectStartedEvents);
 
-            ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
-            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
+            ProjectEvaluationFinishedEventArgs evalFinishedEvent = _logger.EvaluationFinishedEvents[0];
+            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(evalFinishedEvent.Properties);
 
             Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.Equal("InitialProperty1", propertyValue);
@@ -611,8 +611,8 @@ public void InProcMsBuildForwardAllPropertiesFromChild()
             _logger.AssertLogContains("[success]");
             Assert.Single(_logger.ProjectStartedEvents);
 
-            ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
-            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
+            ProjectEvaluationFinishedEventArgs evalFinishedEvent = _logger.EvaluationFinishedEvents[0];
+            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(evalFinishedEvent.Properties);
 
             Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.Equal("InitialProperty1", propertyValue);
@@ -655,8 +655,8 @@ public void MsBuildForwardAllPropertiesFromChildLaunchChildNode()
             _logger.AssertLogContains("[success]");
             Assert.Single(_logger.ProjectStartedEvents);
 
-            ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
-            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
+            ProjectEvaluationFinishedEventArgs evalFinishedEvent = _logger.EvaluationFinishedEvents[0];
+            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(evalFinishedEvent.Properties);
 
             Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.Equal("InitialProperty1", propertyValue);
@@ -704,7 +704,15 @@ public void OutOfProcNodeForwardCertainproperties()
             var data = new BuildRequestData(project.FullPath, new Dictionary<string, string>(),
                 MSBuildDefaultToolsVersion, Array.Empty<string>(), null);
 
-            BuildResult result = _buildManager.Build(_parameters, data);
+            // We need to recreate build parameters to ensure proper capturing of newly set environment variables
+            BuildParameters parameters = new BuildParameters
+            {
+                ShutdownInProcNodeOnBuildFinish = true,
+                Loggers = new ILogger[] { _logger },
+                EnableNodeReuse = false
+            };
+
+            BuildResult result = _buildManager.Build(parameters, data);
             Assert.Equal(BuildResultCode.Success, result.OverallResult);
             _logger.AssertLogContains("[success]");
             Assert.Single(_logger.ProjectStartedEvents);
@@ -760,11 +768,21 @@ public void OutOfProcNodeForwardCertainpropertiesAlsoGetResultsFromCache()
             _env.SetEnvironmentVariable("MsBuildForwardPropertiesFromChild", "InitialProperty3;IAMNOTREAL");
             _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
 
+            _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "0");
+
             var project = CreateProject(contents, null, _projectCollection, false);
             var data = new BuildRequestData(project.FullPath, new Dictionary<string, string>(),
                 MSBuildDefaultToolsVersion, Array.Empty<string>(), null);
 
-            BuildResult result = _buildManager.Build(_parameters, data);
+            // We need to recreate build parameters to ensure proper capturing of newly set environment variables
+            BuildParameters parameters = new BuildParameters
+            {
+                ShutdownInProcNodeOnBuildFinish = true,
+                Loggers = new ILogger[] { _logger },
+                EnableNodeReuse = false
+            };
+
+            BuildResult result = _buildManager.Build(parameters, data);
             Assert.Equal(BuildResultCode.Success, result.OverallResult);
             _logger.AssertLogContains("[success]");
             Assert.Equal(3, _logger.ProjectStartedEvents.Count);
@@ -785,7 +803,8 @@ public void OutOfProcNodeForwardCertainpropertiesAlsoGetResultsFromCache()
             Assert.Equal("InitialProperty3", propertyValue);
 
             projectStartedEvent = _logger.ProjectStartedEvents[2];
-            Assert.Null(projectStartedEvent.Properties);
+            properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
+            (properties == null || properties.Count == 0).ShouldBeTrue();
         }
 
         /// <summary>
@@ -822,7 +841,7 @@ public void ForwardNoPropertiesLaunchChildNode()
 
             ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
             Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
-            Assert.Null(properties);
+            (properties == null || properties.Count == 0).ShouldBeTrue();
         }
 
         /// <summary>
@@ -919,7 +938,7 @@ public void ForwardNoPropertiesLaunchChildNodeDefault()
 
             ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
             Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
-            Assert.Null(properties);
+            (properties == null || properties.Count == 0).ShouldBeTrue();
         }
 
         /// <summary>
@@ -3475,9 +3494,11 @@ private static string BuildAndCheckCache(BuildManager localBuildManager, IEnumer
         /// </summary>
         private static Dictionary<string, string> ExtractProjectStartedPropertyList(IEnumerable properties)
         {
-            // Gather a sorted list of all the properties.
-            return properties?.Cast<DictionaryEntry>()
-                .ToDictionary(prop => (string)prop.Key, prop => (string)prop.Value, StringComparer.OrdinalIgnoreCase);
+            Dictionary<string, string> propertiesLookup = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+            Internal.Utilities.EnumerateProperties(properties, propertiesLookup,
+                static (dict, kvp) => dict.Add(kvp.Key, kvp.Value));
+
+            return propertiesLookup;
         }
 
         /// <summary>
@@ -4280,13 +4301,16 @@ public void GraphBuildShouldBeAbleToConstructGraphButSkipBuild()
 
             using (var buildSession = new Helpers.BuildManagerSession(_env))
             {
-                var graphResult = buildSession.BuildGraphSubmission(
-                    new GraphBuildRequestData(
-                        projectGraphEntryPoints: new[] { new ProjectGraphEntryPoint(graph.GraphRoots.First().ProjectInstance.FullPath) },
+                var requestData = new GraphBuildRequestData(
+                        projectGraphEntryPoints: new[] { new ProjectGraphEntryPoint(
+                            graph.GraphRoots.First().ProjectInstance.FullPath,
+                            new Dictionary<string, string>() { {"property1", "value1" } }) },
                         targetsToBuild: Array.Empty<string>(),
                         hostServices: null,
                         flags: BuildRequestDataFlags.None,
-                        graphBuildOptions: new GraphBuildOptions { Build = false }));
+                        graphBuildOptions: new GraphBuildOptions { Build = false });
+
+                var graphResult = buildSession.BuildGraphSubmission(requestData);
 
                 graphResult.OverallResult.ShouldBe(BuildResultCode.Success);
                 logger = buildSession.Logger;
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index cbc0a2d02c3..e19d7fbec5b 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -222,14 +222,21 @@ public bool IncludeEvaluationProfile
             set { }
         }
 
-        /// <summary>
-        /// Log properties and items on ProjectEvaluationFinishedEventArgs
-        /// instead of ProjectStartedEventArgs.
-        /// </summary>
-        public bool IncludeEvaluationPropertiesAndItems
+        /// <inheritdoc cref="ILoggingService.SetIncludeEvaluationPropertiesAndItemsInEvents"/>
+        public void SetIncludeEvaluationPropertiesAndItemsInEvents(bool inProjectStartedEvent,
+            bool inEvaluationFinishedEvent)
+        { }
+
+        /// <inheritdoc cref="ILoggingService.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent"/>
+        public bool IncludeEvaluationPropertiesAndItemsInProjectStartedEvent
+        {
+            get => false;
+        }
+
+        /// <inheritdoc cref="ILoggingService.IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent"/>
+        public bool IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent
         {
             get => false;
-            set { }
         }
 
         /// <summary>
@@ -656,10 +663,13 @@ public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)
 
         #endregion
 
-        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)
+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext checkContext)
+        { /* Ignore the data */ }
+
+        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext checkContext)
         { /* Ignore the data */ }
 
-        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext analysisContext)
+        public void ProcessProjectEvaluationStarted(ICheckContext analysisContext, string projectFullPath)
         { /* Ignore the data */ }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 60c356dc515..c63606144c8 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -7,6 +7,7 @@
 using System.Linq;
 using FluentAssertions;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
@@ -75,6 +76,7 @@ public void VerifyEventType()
             UninitializedPropertyReadEventArgs uninitializedPropertyRead = new("prop", "message", "help", "sender", MessageImportance.Normal);
             EnvironmentVariableReadEventArgs environmentVariableRead = new("env", "message", "file", 0, 0);
             GeneratedFileUsedEventArgs generatedFileUsed = new GeneratedFileUsedEventArgs("path", "some content");
+            BuildSubmissionStartedEventArgs buildSubmissionStarted = new(new Dictionary<string, string> { { "Value1", "Value2" } }, ["Path1"], ["TargetName"], BuildRequestDataFlags.ReplaceExistingProjectInstance, 123);
 
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
             VerifyLoggingPacket(buildStarted, LoggingEventType.BuildStartedEvent);
@@ -108,6 +110,7 @@ public void VerifyEventType()
             VerifyLoggingPacket(uninitializedPropertyRead, LoggingEventType.UninitializedPropertyRead);
             VerifyLoggingPacket(environmentVariableRead, LoggingEventType.EnvironmentVariableReadEvent);
             VerifyLoggingPacket(generatedFileUsed, LoggingEventType.GeneratedFileUsedEvent);
+            VerifyLoggingPacket(buildSubmissionStarted, LoggingEventType.BuildSubmissionStartedEvent);
         }
 
         private static BuildEventContext CreateBuildEventContext()
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 7f855ca0350..2ed1f77f758 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -95,6 +95,45 @@ public void RoundtripBuildFinishedEventArgs()
                 e => e.Succeeded.ToString());
         }
 
+        [Fact]
+        public void RoundtripBuildSubmissionStartedEventArgs()
+        {
+            var globalVariables = new Dictionary<string, string>
+            {
+                {"Variable1", "Value1" },
+                {"Variable2", "" },
+                {"Variable3", null },
+            };
+            var entryPointProjects = new List<string>()
+            {
+                "project1",
+                "project2",
+                "",
+            };
+            var targetNames = new List<string>()
+            {
+                "target1",
+                "target2",
+                "",
+            };
+            var flag = Execution.BuildRequestDataFlags.FailOnUnresolvedSdk;
+            var submissionId = 1234;
+
+            BuildSubmissionStartedEventArgs args = new(
+                globalVariables,
+                entryPointProjects,
+                targetNames,
+                flag,
+                submissionId);
+
+            Roundtrip<BuildSubmissionStartedEventArgs>(args,
+                e => TranslationHelpers.GetPropertiesString(e.GlobalProperties),
+                e => TranslationHelpers.GetPropertiesString(e.EntryProjectsFullPath),
+                e => TranslationHelpers.GetPropertiesString(e.TargetNames),
+                e => e.Flags.ToString(),
+                e => e.SubmissionId.ToString());
+        }
+
         [Fact]
         public void RoundtripProjectStartedEventArgs()
         {
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 10859bb9ce5..c1fdc67f6a5 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -277,7 +277,7 @@ public void ErrorMessageWithMultiplePropertiesInMessage(bool includeEvaluationPr
 
             if (includeEvaluationPropertiesAndItems)
             {
-                pc.Collection.LoggingService.IncludeEvaluationPropertiesAndItems = true;
+                pc.Collection.LoggingService.SetIncludeEvaluationPropertiesAndItemsInEvents(inProjectStartedEvent: false, inEvaluationFinishedEvent: true);
             }
 
             var project = env.CreateTestProjectWithFiles(@"
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index b1f5ce88f7d..b1a0b664c80 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -70,7 +70,7 @@ public void InvalidCacheFilesShouldLogError(byte[] cacheContents)
             result.OverallResult.ShouldBe(BuildResultCode.Failure);
 
             _logger.FullLog.ShouldContain("MSB4256:");
-            _logger.AllBuildEvents.Count.ShouldBe(5);
+            _logger.AllBuildEvents.Count.ShouldBe(6);
             _logger.ErrorCount.ShouldBe(1);
         }
 
@@ -566,7 +566,7 @@ public void NonExistingInputResultsCacheShouldLogError()
 
             result.OverallResult.ShouldBe(BuildResultCode.Failure);
 
-            _logger.AllBuildEvents.Count.ShouldBe(5);
+            _logger.AllBuildEvents.Count.ShouldBe(6);
             _logger.Errors.First().Message.ShouldContain("MSB4255:");
             _logger.Errors.First().Message.ShouldContain("FileDoesNotExist1");
             _logger.Errors.First().Message.ShouldContain("FileDoesNotExist2");
diff --git a/src/Build/AssemblyInfo.cs b/src/Build/AssemblyInfo.cs
index b4dbc09c40a..36254bf8544 100644
--- a/src/Build/AssemblyInfo.cs
+++ b/src/Build/AssemblyInfo.cs
@@ -38,3 +38,5 @@
 
 [assembly: Dependency("BuildXL.Utilities.Core", LoadHint.Sometimes)]
 [assembly: Dependency("BuildXL.Processes", LoadHint.Sometimes)]
+
+[assembly: TypeForwardedTo(typeof(Microsoft.Build.Execution.BuildRequestDataFlags))]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 38922b2de85..ffd2b33a2ed 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1375,10 +1375,24 @@ internal void ExecuteSubmission<TRequestData, TResultData>(
             where TRequestData : BuildRequestDataBase
             where TResultData : BuildResultBase
         {
-            // TODO: here we should add BuildRequestStarted https://github.com/dotnet/msbuild/issues/10145
-            // BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-            // ((IBuildComponentHost)this).LoggingService.LogBuildEvent()
-
+            // For the current submission we only know the SubmissionId and that it happened on scheduler node - all other BuildEventContext dimensions are unknown now.
+            BuildEventContext buildEventContext = new BuildEventContext(
+                submission.SubmissionId,
+                nodeId: 1,
+                BuildEventContext.InvalidProjectInstanceId,
+                BuildEventContext.InvalidProjectContextId,
+                BuildEventContext.InvalidTargetId,
+                BuildEventContext.InvalidTaskId);
+
+            BuildSubmissionStartedEventArgs submissionStartedEvent = new(
+                submission.BuildRequestDataBase.GlobalPropertiesLookup,
+                submission.BuildRequestDataBase.EntryProjectsFullPath,
+                submission.BuildRequestDataBase.TargetNames,
+                submission.BuildRequestDataBase.Flags,
+                submission.SubmissionId);
+            submissionStartedEvent.BuildEventContext = buildEventContext;
+
+            ((IBuildComponentHost)this).LoggingService.LogBuildEvent(submissionStartedEvent);
 
             if (submission is BuildSubmission buildSubmission)
             {
@@ -2757,7 +2771,8 @@ private NodeConfiguration GetNodeConfiguration()
                 , new LoggingNodeConfiguration(
                     loggingService.IncludeEvaluationMetaprojects,
                     loggingService.IncludeEvaluationProfile,
-                    loggingService.IncludeEvaluationPropertiesAndItems,
+                    loggingService.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent,
+                    loggingService.IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent,
                     loggingService.IncludeTaskInputs));
             }
 
@@ -2920,7 +2935,7 @@ private ILoggingService CreateLoggingService(
                     verbosity: LoggerVerbosity.Quiet);
 
                 ILogger buildCheckLogger =
-                    new BuildCheckConnectorLogger(new AnalysisLoggingContextFactory(loggingService),
+                    new BuildCheckConnectorLogger(new CheckLoggingContextFactory(loggingService),
                         buildCheckManagerProvider.Instance);
 
                 ForwardingLoggerRecord[] forwardingLogger = { new ForwardingLoggerRecord(buildCheckLogger, forwardingLoggerDescription) };
@@ -3265,25 +3280,19 @@ public string? Parameters
             /// </summary>
             public void Initialize(IEventSource eventSource)
             {
-                // The concrete type we get should always be our internal
-                // implementation and up-to-date, but we need to meet the
-                // external contract so can't specify that for the
-                // argument.
-
-                IEventSource4 eventSource4 = (IEventSource4)eventSource;
-
                 // Most checks in LoggingService are "does any attached logger
                 // specifically opt into this new behavior?". As such, the
                 // NullLogger shouldn't opt into them explicitly and should
                 // let other loggers opt in.
 
-                // IncludeEvaluationPropertiesAndItems is different though,
-                // because its check is "do ALL attached loggers opt into
-                // the new behavior?", since the new behavior removes
-                // information from old loggers. So the NullLogger must
-                // opt in to ensure it doesn't accidentally veto the new
-                // behavior.
-                eventSource4.IncludeEvaluationPropertiesAndItems();
+                // IncludeEvaluationPropertiesAndItems was different,
+                // because it checked "do ALL attached loggers opt into
+                // the new behavior?".
+                // It was fixed and hence we need to be careful not to opt in
+                // the behavior as it was done before - but let the other loggers choose.
+                //
+                // For this reason NullLogger MUST NOT call
+                // ((IEventSource4)eventSource).IncludeEvaluationPropertiesAndItems();
             }
 
             /// <summary>
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 9657019dc00..0ce71397288 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -840,7 +840,7 @@ public bool Question
         }
 
         /// <summary>
-        /// Gets or sets an indication of build analysis enablement.
+        /// Gets or sets an indication of build check enablement.
         /// </summary>
         public bool IsBuildCheckEnabled
         {
diff --git a/src/Build/BackEnd/BuildManager/BuildRequestData.cs b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
index b9a221afbd9..5c69b4aebd0 100644
--- a/src/Build/BackEnd/BuildManager/BuildRequestData.cs
+++ b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
@@ -6,88 +6,15 @@
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Linq;
+using System.Runtime.CompilerServices;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Execution
 {
-    /// <summary>
-    /// Flags providing additional control over the build request
-    /// </summary>
-    [Flags]
-    public enum BuildRequestDataFlags
-    {
-        /// <summary>
-        /// No flags.
-        /// </summary>
-        None = 0,
-
-        /// <summary>
-        /// When this flag is present, the existing ProjectInstance in the build will be replaced by this one.
-        /// </summary>
-        ReplaceExistingProjectInstance = 1 << 0,
-
-        /// <summary>
-        /// When this flag is present, the <see cref="BuildResult"/> issued in response to this request will
-        /// include <see cref="BuildResult.ProjectStateAfterBuild"/>.
-        /// </summary>
-        ProvideProjectStateAfterBuild = 1 << 1,
-
-        /// <summary>
-        /// When this flag is present and the project has previously been built on a node whose affinity is
-        /// incompatible with the affinity this request requires, we will ignore the project state (but not
-        /// target results) that were previously generated.
-        /// </summary>
-        /// <remarks>
-        /// This usually is not desired behavior.  It is only provided for those cases where the client
-        /// knows that the new build request does not depend on project state generated by a previous request.  Setting
-        /// this flag can provide a performance boost in the case of incompatible node affinities, as MSBuild would
-        /// otherwise have to serialize the project state from one node to another, which may be
-        /// expensive depending on how much data the project previously generated.
-        ///
-        /// This flag has no effect on target results, so if a previous request already built a target, the new
-        /// request will not re-build that target (nor will any of the project state mutations which previously
-        /// occurred as a consequence of building that target be re-applied.)
-        /// </remarks>
-        IgnoreExistingProjectState = 1 << 2,
-
-        /// <summary>
-        /// When this flag is present, caches including the <see cref="ProjectRootElementCacheBase"/> will be cleared
-        /// after the build request completes.  This is used when the build request is known to modify a lot of
-        /// state such as restoring packages or generating parts of the import graph.
-        /// </summary>
-        ClearCachesAfterBuild = 1 << 3,
-
-        /// <summary>
-        /// When this flag is present, the top level target(s) in the build request will be skipped if those targets
-        /// are not defined in the Project to build. This only applies to this build request (if another target calls
-        /// the "missing target" at any other point this will still result in an error).
-        /// </summary>
-        SkipNonexistentTargets = 1 << 4,
-
-        /// <summary>
-        /// When this flag is present, the <see cref="BuildResult"/> issued in response to this request will
-        /// include a <see cref="BuildResult.ProjectStateAfterBuild"/> that includes ONLY the
-        /// explicitly-requested properties, items, and metadata.
-        /// </summary>
-        ProvideSubsetOfStateAfterBuild = 1 << 5,
-
-        /// <summary>
-        /// When this flag is present, projects loaded during build will ignore missing imports (<see cref="ProjectLoadSettings.IgnoreMissingImports"/> and <see cref="ProjectLoadSettings.IgnoreInvalidImports"/>).
-        /// This is especially useful during a restore since some imports might come from packages that haven't been restored yet.
-        /// </summary>
-        IgnoreMissingEmptyAndInvalidImports = 1 << 6,
-
-        /// <summary>
-        /// When this flag is present, an unresolved MSBuild project SDK will fail the build.  This flag is used to
-        /// change the <see cref="IgnoreMissingEmptyAndInvalidImports" /> behavior to still fail when an SDK is missing
-        /// because those are more fatal.
-        /// </summary>
-        FailOnUnresolvedSdk = 1 << 7,
-    }
-
     /// <summary>
     /// BuildRequestData encapsulates all the data needed to submit a build request.
     /// </summary>
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmission.cs b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
index e96185fc640..1dba5f10f78 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmission.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
@@ -202,6 +202,16 @@ public override BuildResult Execute()
             return BuildResult!;
         }
 
+        /// <summary>
+        /// Whether the build has started.
+        /// </summary>
+        internal override bool IsStarted
+        {
+            get => BuildRequest != null;
+            // Ignore the set - the submission is started once the BuildRequest is set.
+            set { }
+        }
+
         protected internal override BuildResult CreateFailedResult(Exception exception)
         {
             ErrorUtilities.VerifyThrow(BuildRequest != null,
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmissionBase.cs b/src/Build/BackEnd/BuildManager/BuildSubmissionBase.cs
index ba6f45afc09..1cf4819c51d 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmissionBase.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmissionBase.cs
@@ -77,7 +77,7 @@ protected internal BuildSubmissionBase(BuildManager buildManager, int submission
         /// <summary>
         /// Whether the build has started.
         /// </summary>
-        internal bool IsStarted { get; set; }
+        internal abstract bool IsStarted { get; set; }
 
         /// <summary>
         /// Indicates that all logging events for this submission are complete.
diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index 7983229f5b2..a3fc16da831 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -144,7 +144,7 @@ internal enum BuildComponentType
         NodeLauncher,
 
         /// <summary>
-        /// The Build Analyzer Manager.
+        /// The Build Check Manager.
         /// </summary>
         BuildCheckManagerProvider,
     }
diff --git a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
index d9cb65d4b93..15f4387218a 100644
--- a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
@@ -3,6 +3,7 @@
 
 using System.Collections;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
@@ -30,6 +31,8 @@ public EvaluationLoggingContext(ILoggingService loggingService, BuildEventContex
         public void LogProjectEvaluationStarted()
         {
             LoggingService.LogProjectEvaluationStarted(BuildEventContext, _projectFile);
+            LoggingService.BuildEngineDataRouter.ProcessProjectEvaluationStarted(
+                new CheckLoggingContext(LoggingService, BuildEventContext), _projectFile);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index ecbf7b8026b..104dac56f6f 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -206,12 +206,24 @@ bool IncludeEvaluationProfile
 
         /// <summary>
         /// Should properties and items be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
-        /// instead of <see cref="ProjectStartedEventArgs"/>?
+        /// or/and <see cref="ProjectStartedEventArgs"/>?
         /// </summary>
-        bool IncludeEvaluationPropertiesAndItems
+        void SetIncludeEvaluationPropertiesAndItemsInEvents(bool inProjectStartedEvent, bool inEvaluationFinishedEvent);
+
+        /// <summary>
+        /// Indicates whether properties and items should be logged on <see cref="ProjectStartedEventArgs"/>.
+        /// </summary>
+        bool IncludeEvaluationPropertiesAndItemsInProjectStartedEvent
+        {
+            get;
+        }
+
+        /// <summary>
+        /// Indicates whether properties and items should be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>.
+        /// </summary>
+        bool IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent
         {
             get;
-            set;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index e06b2a85864..6c871f7667c 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -316,12 +316,12 @@ internal void LogIncludeFile(string filePath)
         public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo)
             => _loggingService.BuildEngineDataRouter.ProcessPropertyRead(
                     propertyReadInfo,
-                    new AnalysisLoggingContext(_loggingService, BuildEventContext));
+                    new CheckLoggingContext(_loggingService, BuildEventContext));
 
         public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo)
             => _loggingService.BuildEngineDataRouter.ProcessPropertyWrite(
                     propertyWriteInfo,
-                    new AnalysisLoggingContext(_loggingService, BuildEventContext));
+                    new CheckLoggingContext(_loggingService, BuildEventContext));
 
         private protected void CheckValidity()
         {
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index f547084425d..df990251a96 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -201,12 +201,6 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler
         /// </summary>
         private bool? _includeEvaluationProfile;
 
-        /// <summary>
-        /// Whether properties and items should be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
-        /// instead of <see cref="ProjectStartedEventArgs"/>.
-        /// </summary>
-        private bool? _includeEvaluationPropertiesAndItems;
-
         /// <summary>
         /// Whether to include task inputs in task events.
         /// </summary>
@@ -546,33 +540,77 @@ public bool IncludeTaskInputs
             set => _includeTaskInputs = value;
         }
 
-        /// <summary>
-        /// Should properties and items be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
-        /// instead of <see cref="ProjectStartedEventArgs"/>?
-        /// </summary>
-        public bool IncludeEvaluationPropertiesAndItems
+        /// <inheritdoc cref="ILoggingService.SetIncludeEvaluationPropertiesAndItemsInEvents"/>
+        public void SetIncludeEvaluationPropertiesAndItemsInEvents(bool inProjectStartedEvent, bool inEvaluationFinishedEvent)
         {
-            get
+            _evalDataBehaviorSet = true;
+            IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent = inEvaluationFinishedEvent;
+            IncludeEvaluationPropertiesAndItemsInProjectStartedEvent = inProjectStartedEvent;
+        }
+
+        private bool _evalDataBehaviorSet;
+        private bool _includeEvaluationPropertiesAndItemsInProjectStartedEvent;
+        private bool _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent;
+        private void InferEvalDataBehavior()
+        {
+            if (_evalDataBehaviorSet)
             {
-                if (_includeEvaluationPropertiesAndItems == null)
+                return;
+            }
+            // Set this right away - to prevent SO exception in case of any future refactoring
+            //  that would refer to the IncludeEvaluation... properties here
+            _evalDataBehaviorSet = true;
+
+            bool? escapeHatch = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation;
+            if (escapeHatch.HasValue)
+            {
+                IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent = escapeHatch.Value;
+                IncludeEvaluationPropertiesAndItemsInProjectStartedEvent = !escapeHatch.Value;
+            }
+            else
+            {
+                var sinks = _eventSinkDictionary.Values.OfType<EventSourceSink>().ToList();
+
+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12))
                 {
-                    var escapeHatch = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation;
-                    if (escapeHatch.HasValue)
-                    {
-                        _includeEvaluationPropertiesAndItems = escapeHatch.Value;
-                    }
-                    else
-                    {
-                        var sinks = _eventSinkDictionary.Values.OfType<EventSourceSink>();
-                        // .All() on an empty list defaults to true, we want to default to false
-                        _includeEvaluationPropertiesAndItems = sinks.Any() && sinks.All(sink => sink.IncludeEvaluationPropertiesAndItems);
-                    }
+                    // If any logger requested the data - we need to emit them
+                    IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent =
+                        sinks.Any(sink => sink.IncludeEvaluationPropertiesAndItems);
+                    // If any logger didn't request the data - hence it's likely legacy logger
+                    //  - we need to populate the data in legacy way
+                    IncludeEvaluationPropertiesAndItemsInProjectStartedEvent =
+                        sinks.Any(sink => !sink.IncludeEvaluationPropertiesAndItems);
                 }
+                else
+                {
+                    bool allSinksIncludeEvalData = sinks.Any() && sinks.All(sink => sink.IncludeEvaluationPropertiesAndItems);
 
-                return _includeEvaluationPropertiesAndItems ?? false;
+                    IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent = allSinksIncludeEvalData;
+                    IncludeEvaluationPropertiesAndItemsInProjectStartedEvent = !allSinksIncludeEvalData;
+                }
             }
+        }
 
-            set => _includeEvaluationPropertiesAndItems = value;
+        /// <inheritdoc cref="ILoggingService.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent"/>
+        public bool IncludeEvaluationPropertiesAndItemsInProjectStartedEvent
+        {
+            get
+            {
+                InferEvalDataBehavior();
+                return _includeEvaluationPropertiesAndItemsInProjectStartedEvent;
+            }
+            private set => _includeEvaluationPropertiesAndItemsInProjectStartedEvent = value;
+        }
+
+        /// <inheritdoc cref="ILoggingService.IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent"/>
+        public bool IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent
+        {
+            get
+            {
+                InferEvalDataBehavior();
+                return _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent;
+            }
+            private set => _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent = value;
         }
 
         /// <summary>
@@ -1288,8 +1326,7 @@ internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
         {
             if (loggingPacket?.NodeBuildEvent != null && _componentHost != null)
             {
-                var projectStartedEventArgs = loggingPacket.NodeBuildEvent.Value.Value as ProjectStartedEventArgs;
-                if (projectStartedEventArgs != null && _configCache.Value != null)
+                if (loggingPacket.NodeBuildEvent.Value.Value is ProjectStartedEventArgs projectStartedEventArgs && _configCache.Value != null)
                 {
                     ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(projectStartedEventArgs.ProjectId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
                     BuildRequestConfiguration buildRequestConfiguration = _configCache.Value[projectStartedEventArgs.ProjectId];
@@ -1300,6 +1337,12 @@ internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
                     s_projectStartedEventArgsGlobalProperties.Value.SetValue(projectStartedEventArgs, buildRequestConfiguration.GlobalProperties.ToDictionary(), index: null);
 
                     s_projectStartedEventArgsToolsVersion.Value.SetValue(projectStartedEventArgs, buildRequestConfiguration.ToolsVersion, null);
+
+                    // When logging happens out of process, we need to map the project context id to the project file on the receiving side.
+                    if (!_projectFileMap.ContainsKey(projectStartedEventArgs.BuildEventContext.ProjectContextId))
+                    {
+                        _projectFileMap[projectStartedEventArgs.BuildEventContext.ProjectContextId] = projectStartedEventArgs.ProjectFile;
+                    }
                 }
             }
         }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index c7822f0c7aa..40762761917 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -798,10 +798,13 @@ public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)
 
         #endregion
 
-        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)
-            => BuildCheckManagerProvider.GlobalBuildEngineDataRouter?.ProcessPropertyRead(propertyReadInfo, analysisContext);
+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext checkContext)
+            => BuildCheckManagerProvider.GlobalBuildEngineDataRouter?.ProcessPropertyRead(propertyReadInfo, checkContext);
 
-        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext analysisContext)
-            => BuildCheckManagerProvider.GlobalBuildEngineDataRouter?.ProcessPropertyWrite(propertyWriteInfo, analysisContext);
+        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext checkContext)
+            => BuildCheckManagerProvider.GlobalBuildEngineDataRouter?.ProcessPropertyWrite(propertyWriteInfo, checkContext);
+
+        public void ProcessProjectEvaluationStarted(ICheckContext checkContext, string projectFullPath)
+            => BuildCheckManagerProvider.GlobalBuildEngineDataRouter?.ProcessProjectEvaluationStarted(checkContext, projectFullPath);
     }
 }
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 49a3cd48fb7..06614c42125 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -132,7 +132,7 @@ private static BuildEventContext CreateInitialContext(
 
             // If we are only logging critical events lets not pass back the items or properties
             if (!loggingService.OnlyLogCriticalEvents &&
-                !loggingService.IncludeEvaluationPropertiesAndItems &&
+                loggingService.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent &&
                 (!loggingService.RunningOnRemoteNode || loggingService.SerializeAllProperties))
             {
                 if (projectProperties is null)
@@ -152,7 +152,7 @@ private static BuildEventContext CreateInitialContext(
             }
 
             if (projectProperties != null &&
-                !loggingService.IncludeEvaluationPropertiesAndItems &&
+                loggingService.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent &&
                 propertiesToSerialize?.Length > 0 &&
                 !loggingService.SerializeAllProperties)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index cd819c32d26..27bc3fa75be 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -1105,9 +1105,13 @@ private async Task<BuildResult> BuildProject()
             ErrorUtilities.VerifyThrow(_targetBuilder != null, "Target builder is null");
 
             // We consider this the entrypoint for the project build for purposes of BuildCheck processing 
+            bool isRestoring = _requestEntry.RequestConfiguration.GlobalProperties[MSBuildConstants.MSBuildIsRestoring] is null;
 
-            var buildCheckManager = (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)!.Instance;
-            buildCheckManager.SetDataSource(BuildCheckDataSource.BuildExecution);
+            var buildCheckManager = isRestoring
+                ? (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)!.Instance
+                : null;
+
+            buildCheckManager?.SetDataSource(BuildCheckDataSource.BuildExecution);
 
             // Make sure it is null before loading the configuration into the request, because if there is a problem
             // we do not wand to have an invalid projectLoggingContext floating around. Also if this is null the error will be
@@ -1121,9 +1125,9 @@ private async Task<BuildResult> BuildProject()
                 // Load the project
                 if (!_requestEntry.RequestConfiguration.IsLoaded)
                 {
-                    buildCheckManager.StartProjectEvaluation(
+                    buildCheckManager?.ProjectFirstEncountered(
                         BuildCheckDataSource.BuildExecution,
-                        new AnalysisLoggingContext(_nodeLoggingContext.LoggingService, _requestEntry.Request.BuildEventContext),
+                        new CheckLoggingContext(_nodeLoggingContext.LoggingService, _requestEntry.Request.BuildEventContext),
                         _requestEntry.RequestConfiguration.ProjectFullPath);
 
                     _requestEntry.RequestConfiguration.LoadProjectIntoConfiguration(
@@ -1146,15 +1150,13 @@ private async Task<BuildResult> BuildProject()
             }
             finally
             {
-                buildCheckManager.EndProjectEvaluation(
-                    BuildCheckDataSource.BuildExecution,
+                buildCheckManager?.EndProjectEvaluation(
                     _requestEntry.Request.BuildEventContext);
             }
 
             _projectLoggingContext = _nodeLoggingContext.LogProjectStarted(_requestEntry);
-            buildCheckManager.StartProjectRequest(
-                BuildCheckDataSource.BuildExecution,
-                _requestEntry.Request.BuildEventContext,
+            buildCheckManager?.StartProjectRequest(
+                _projectLoggingContext.BuildEventContext,
                 _requestEntry.RequestConfiguration.ProjectFullPath);
 
             try
@@ -1224,9 +1226,8 @@ private async Task<BuildResult> BuildProject()
             }
             finally
             {
-                buildCheckManager.EndProjectRequest(
-                    BuildCheckDataSource.BuildExecution,
-                    new AnalysisLoggingContext(_nodeLoggingContext.LoggingService, _requestEntry.Request.BuildEventContext),
+                buildCheckManager?.EndProjectRequest(
+                    new CheckLoggingContext(_nodeLoggingContext.LoggingService, _projectLoggingContext.BuildEventContext),
                     _requestEntry.RequestConfiguration.ProjectFullPath);
             }
 
@@ -1404,10 +1405,7 @@ private void ConfigureKnownImmutableFolders()
             ProjectInstance project = _requestEntry?.RequestConfiguration?.Project;
             if (project != null)
             {
-                // example: C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.7.2
-                FileClassifier.Shared.RegisterImmutableDirectory(project.GetPropertyValue("FrameworkPathOverride")?.Trim());
-                // example: C:\Program Files\dotnet\
-                FileClassifier.Shared.RegisterImmutableDirectory(project.GetPropertyValue("NetCoreRoot")?.Trim());
+                FileClassifier.Shared.RegisterKnownImmutableLocations(project.GetPropertyValue);
             }
         }
 
diff --git a/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs b/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
index 1bae5efa98b..8c6315338da 100644
--- a/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
+++ b/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
@@ -9,12 +9,14 @@ internal sealed class LoggingNodeConfiguration : ITranslatable
     {
         private bool _includeEvaluationMetaprojects;
         private bool _includeEvaluationProfiles;
-        private bool _includeEvaluationPropertiesAndItems;
+        private bool _includeEvaluationPropertiesAndItemsInProjectStartedEvent;
+        private bool _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent;
         private bool _includeTaskInputs;
 
         public bool IncludeEvaluationMetaprojects => _includeEvaluationMetaprojects;
         public bool IncludeEvaluationProfiles => _includeEvaluationProfiles;
-        public bool IncludeEvaluationPropertiesAndItems => _includeEvaluationPropertiesAndItems;
+        public bool IncludeEvaluationPropertiesAndItemsInProjectStartedEvent => _includeEvaluationPropertiesAndItemsInProjectStartedEvent;
+        public bool IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent => _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent;
         public bool IncludeTaskInputs => _includeTaskInputs;
 
         public LoggingNodeConfiguration()
@@ -24,12 +26,14 @@ public LoggingNodeConfiguration()
         public LoggingNodeConfiguration(
             bool includeEvaluationMetaprojects,
             bool includeEvaluationProfiles,
-            bool includeEvaluationPropertiesAndItems,
+            bool includeEvaluationPropertiesAndItemsInProjectStartedEvent,
+            bool includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent,
             bool includeTaskInputs)
         {
             _includeEvaluationMetaprojects = includeEvaluationMetaprojects;
             _includeEvaluationProfiles = includeEvaluationProfiles;
-            _includeEvaluationPropertiesAndItems = includeEvaluationPropertiesAndItems;
+            _includeEvaluationPropertiesAndItemsInProjectStartedEvent = includeEvaluationPropertiesAndItemsInProjectStartedEvent;
+            _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent = includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent;
             _includeTaskInputs = includeTaskInputs;
         }
 
@@ -37,7 +41,8 @@ void ITranslatable.Translate(ITranslator translator)
         {
             translator.Translate(ref _includeEvaluationMetaprojects);
             translator.Translate(ref _includeEvaluationProfiles);
-            translator.Translate(ref _includeEvaluationPropertiesAndItems);
+            translator.Translate(ref _includeEvaluationPropertiesAndItemsInProjectStartedEvent);
+            translator.Translate(ref _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent);
             translator.Translate(ref _includeTaskInputs);
         }
     }
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 14706fc57cd..af13beb079d 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -779,9 +779,12 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
                 _loggingService.IncludeTaskInputs = true;
             }
 
-            if (configuration.LoggingNodeConfiguration.IncludeEvaluationPropertiesAndItems)
+            if (configuration.LoggingNodeConfiguration.IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent)
             {
-                _loggingService.IncludeEvaluationPropertiesAndItems = true;
+                _loggingService.SetIncludeEvaluationPropertiesAndItemsInEvents(
+                    configuration.LoggingNodeConfiguration.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent,
+                    configuration.LoggingNodeConfiguration
+                        .IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent);
             }
 
             try
diff --git a/src/Build/BuildCheck/API/BuildCheckResult.cs b/src/Build/BuildCheck/API/BuildCheckResult.cs
index b6cb67e7d56..fe8a234e12d 100644
--- a/src/Build/BuildCheck/API/BuildCheckResult.cs
+++ b/src/Build/BuildCheck/API/BuildCheckResult.cs
@@ -2,56 +2,54 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.IO;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Representation of a single report of a single finding from a BuildAnalyzer
+/// Representation of a single report of a single finding from a Check
 /// Each rule has upfront known message format - so only the concrete arguments are added
 /// Optionally a location is attached - in the near future we might need to support multiple locations
-///  (for 2 cases - a) grouped result for multiple occurrences; b) a single report for a finding resulting from combination of multiple locations)
+///  (for 2 cases - a) grouped result for multiple occurrences; b) a single report for a finding resulting from combination of multiple locations).
 /// </summary>
 public sealed class BuildCheckResult : IBuildCheckResult
 {
-    public static BuildCheckResult Create(BuildAnalyzerRule rule, ElementLocation location, params string[] messageArgs)
-    {
-        return new BuildCheckResult(rule, location, messageArgs);
-    }
+    public static BuildCheckResult Create(CheckRule rule, IMSBuildElementLocation location, params string[] messageArgs) => new BuildCheckResult(rule, location, messageArgs);
 
-    public BuildCheckResult(BuildAnalyzerRule buildAnalyzerRule, ElementLocation location, string[] messageArgs)
+    public BuildCheckResult(CheckRule checkConfig, IMSBuildElementLocation location, string[] messageArgs)
     {
-        BuildAnalyzerRule = buildAnalyzerRule;
+        CheckRule = checkConfig;
         Location = location;
         MessageArgs = messageArgs;
     }
 
-    internal BuildEventArgs ToEventArgs(BuildAnalyzerResultSeverity severity)
+    internal BuildEventArgs ToEventArgs(CheckResultSeverity severity)
         => severity switch
         {
-            BuildAnalyzerResultSeverity.Suggestion => new BuildCheckResultMessage(this),
-            BuildAnalyzerResultSeverity.Warning => new BuildCheckResultWarning(this, BuildAnalyzerRule.Id),
-            BuildAnalyzerResultSeverity.Error => new BuildCheckResultError(this, BuildAnalyzerRule.Id),
+            CheckResultSeverity.Suggestion => new BuildCheckResultMessage(this),
+            CheckResultSeverity.Warning => new BuildCheckResultWarning(this, CheckRule.Id),
+            CheckResultSeverity.Error => new BuildCheckResultError(this, CheckRule.Id),
             _ => throw new ArgumentOutOfRangeException(nameof(severity), severity, null),
         };
 
-    public BuildAnalyzerRule BuildAnalyzerRule { get; }
+    public CheckRule CheckRule { get; }
 
     /// <summary>
     /// Optional location of the finding (in near future we might need to support multiple locations).
     /// </summary>
-    public ElementLocation Location { get; }
+    public IMSBuildElementLocation Location { get; }
 
     public string LocationString => Location.LocationString;
 
     public string[] MessageArgs { get; }
-    public string MessageFormat => BuildAnalyzerRule.MessageFormat;
+
+    public string MessageFormat => CheckRule.MessageFormat;
 
     // Here we will provide different link for built-in rules and custom rules - once we have the base classes differentiated.
     public string FormatMessage() =>
-        _message ??= $"{(Equals(Location ?? ElementLocation.EmptyLocation, ElementLocation.EmptyLocation) ? string.Empty : (Location!.LocationString + ": "))}https://aka.ms/buildcheck/codes#{BuildAnalyzerRule.Id} - {string.Format(BuildAnalyzerRule.MessageFormat, MessageArgs)}";
+        _message ??= $"{(Equals(Location ?? ElementLocation.EmptyLocation, ElementLocation.EmptyLocation) ? string.Empty : (Location!.LocationString + ": "))}https://aka.ms/buildcheck/codes#{CheckRule.Id} - {string.Format(CheckRule.MessageFormat, MessageArgs)}";
 
     private string? _message;
 }
diff --git a/src/Build/BuildCheck/API/BuildAnalyzer.cs b/src/Build/BuildCheck/API/Check.cs
similarity index 70%
rename from src/Build/BuildCheck/API/BuildAnalyzer.cs
rename to src/Build/BuildCheck/API/Check.cs
index 0c6ed5a0752..4eeeb8599f1 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzer.cs
+++ b/src/Build/BuildCheck/API/Check.cs
@@ -9,29 +9,29 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Base class for build analyzers.
-/// Same base will be used for custom and built-in analyzers.
-/// <see cref="BuildAnalyzer"/> is a unit of build analysis execution, but it can contain multiple rules - each representing a distinct violation.
+/// Base class for build checks.
+/// Same base will be used for custom and built-in checks.
+/// <see cref="Check"/> is a unit of build checks execution, but it can contain multiple rules - each representing a distinct violation.
 /// </summary>
-public abstract class BuildAnalyzer : IDisposable
+public abstract class Check : IDisposable
 {
     /// <summary>
-    /// Friendly name of the analyzer.
+    /// Friendly name of the check.
     /// Should be unique - as it will be used in the tracing stats, infrastructure error messages, etc.
     /// </summary>
     public abstract string FriendlyName { get; }
 
     /// <summary>
-    /// Single or multiple rules supported by the analyzer.
+    /// Single or multiple rules supported by the check.
     /// </summary>
-    public abstract IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; }
+    public abstract IReadOnlyList<CheckRule> SupportedRules { get; }
 
     /// <summary>
-    /// Optional initialization of the analyzer.
+    /// Optional initialization of the check.
     /// </summary>
     /// <param name="configurationContext">
     /// Custom data (not recognized by the infrastructure) passed from .editorconfig
-    /// Currently the custom data has to be identical for all rules in the analyzer and all projects.
+    /// Currently the custom data has to be identical for all rules in the check and all projects.
     /// </param>
     public abstract void Initialize(ConfigurationContext configurationContext);
 
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs b/src/Build/BuildCheck/API/CheckConfiguration.cs
similarity index 53%
rename from src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
rename to src/Build/BuildCheck/API/CheckConfiguration.cs
index 25492910718..33950a40edc 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
+++ b/src/Build/BuildCheck/API/CheckConfiguration.cs
@@ -9,51 +9,51 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Configuration for a build analyzer.
-/// Default values can be specified by the Analyzer in code.
+/// Configuration for a build check.
+/// Default values can be specified by the Check in code.
 /// Users can overwrite the defaults by explicit settings in the .editorconfig file.
 /// Each rule can have its own configuration, which can differ per each project.
-/// The <see cref="EvaluationAnalysisScope"/> setting must be same for all rules in the same analyzer (but can differ between projects)
+/// The <see cref="EvaluationCheckScope"/> setting must be same for all rules in the same check (but can differ between projects)
 /// </summary>
-public class BuildAnalyzerConfiguration
+public class CheckConfiguration
 {
     // Defaults to be used if any configuration property is not specified neither as default
     //  nor in the editorconfig configuration file.
-    public static BuildAnalyzerConfiguration Default { get; } = new()
+    public static CheckConfiguration Default { get; } = new()
     {
-        EvaluationAnalysisScope = BuildCheck.EvaluationAnalysisScope.ProjectOnly,
-        Severity = BuildAnalyzerResultSeverity.None
+        EvaluationCheckScope = BuildCheck.EvaluationCheckScope.ProjectFileOnly,
+        Severity = CheckResultSeverity.None
     };
 
-    public static BuildAnalyzerConfiguration Null { get; } = new();
+    public static CheckConfiguration Null { get; } = new();
 
     public string? RuleId { get; internal set; }
 
     /// <summary>
     /// This applies only to specific events, that can distinguish whether they are directly inferred from
-    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from analysis.
+    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from check.
     ///
     /// If not supported by the data source - then the setting is ignored
     /// </summary>
-    public EvaluationAnalysisScope? EvaluationAnalysisScope { get; internal init; }
+    public EvaluationCheckScope? EvaluationCheckScope { get; internal init; }
 
     /// <summary>
     /// The severity of the result for the rule.
     /// </summary>
-    public BuildAnalyzerResultSeverity? Severity { get; internal init; }
+    public CheckResultSeverity? Severity { get; internal init; }
 
     /// <summary>
-    /// Whether the analyzer rule is enabled.
-    /// If all rules within the analyzer are not enabled, it will not be run.
-    /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.
+    /// Whether the check rule is enabled.
+    /// If all rules within the check are not enabled, it will not be run.
+    /// If some rules are enabled and some are not, the check will be run and reports will be post-filtered.
     /// </summary>
     public bool? IsEnabled {
         get
         {
-            // Do not consider Default as enabled, because the default severity of the rule coule be set to None
-            if (Severity.HasValue && Severity.Value != BuildAnalyzerResultSeverity.Default)
+            // Do not consider Default as enabled, because the default severity of the rule could be set to None
+            if (Severity.HasValue && Severity.Value != CheckResultSeverity.Default)
             {
-                return !Severity.Value.Equals(BuildAnalyzerResultSeverity.None);
+                return !Severity.Value.Equals(CheckResultSeverity.None);
             }
 
             return null;
@@ -61,20 +61,19 @@ public bool? IsEnabled {
     }
 
     /// <summary>
-    /// Creates a <see cref="BuildAnalyzerConfiguration"/> object based on the provided configuration dictionary.
-    /// If the BuildAnalyzerConfiguration's property name presented in the dictionary, the value of this key-value pair is parsed and assigned to the instance's field.
+    /// Creates a <see cref="CheckConfiguration"/> object based on the provided configuration dictionary.
+    /// If the BuildCheckConfiguration's property name presented in the dictionary, the value of this key-value pair is parsed and assigned to the instance's field.
     /// If parsing failed the value will be equal to null.
     /// </summary>
-    /// <param name="configDictionary">The configuration dictionary containing the settings for the build analyzer. The configuration's keys are expected to be in lower case or the EqualityComparer to ignore case.</param>
-    /// <returns>A new instance of <see cref="BuildAnalyzerConfiguration"/> with the specified settings.</returns>
-    internal static BuildAnalyzerConfiguration Create(Dictionary<string, string>? configDictionary) => new()
+    /// <param name="configDictionary">The configuration dictionary containing the settings for the build check. The configuration's keys are expected to be in lower case or the EqualityComparer to ignore case.</param>
+    /// <returns>A new instance of <see cref="CheckConfiguration"/> with the specified settings.</returns>
+    internal static CheckConfiguration Create(Dictionary<string, string>? configDictionary) => new()
     {
-        EvaluationAnalysisScope = TryExtractEvaluationAnalysisScope(configDictionary),
+        EvaluationCheckScope = TryExtractEvaluationCheckScope(configDictionary),
         Severity = TryExtractSeverity(configDictionary),
     };
 
-
-    private static EvaluationAnalysisScope? TryExtractEvaluationAnalysisScope(Dictionary<string, string>? config)
+    private static EvaluationCheckScope? TryExtractEvaluationCheckScope(Dictionary<string, string>? config)
     {
 
         if (!TryExtractValue(BuildCheckConstants.scopeConfigurationKey, config, out string? stringValue) || stringValue is null)
@@ -84,14 +83,13 @@ public bool? IsEnabled {
 
         switch (stringValue)
         {
-            case "project":
-                return BuildCheck.EvaluationAnalysisScope.ProjectOnly;
-            case "current_imports":
-                return BuildCheck.EvaluationAnalysisScope.ProjectWithImportsFromCurrentWorkTree;
-            case "without_sdks":
-                return BuildCheck.EvaluationAnalysisScope.ProjectWithImportsWithoutSdks;
+            case "projectfile":
+            case "project_file":
+                return BuildCheck.EvaluationCheckScope.ProjectFileOnly;
+            case "work_tree_imports":
+                return BuildCheck.EvaluationCheckScope.WorkTreeImports;
             case "all":
-                return BuildCheck.EvaluationAnalysisScope.ProjectWithAllImports;
+                return BuildCheck.EvaluationCheckScope.All;
             default:
                 ThrowIncorrectValueException(BuildCheckConstants.scopeConfigurationKey, stringValue);
                 break;
@@ -100,7 +98,7 @@ public bool? IsEnabled {
         return null;
     }
 
-    private static BuildAnalyzerResultSeverity? TryExtractSeverity(Dictionary<string, string>? config)
+    private static CheckResultSeverity? TryExtractSeverity(Dictionary<string, string>? config)
     {
         if (!TryExtractValue(BuildCheckConstants.severityConfigurationKey, config, out string? stringValue) || stringValue is null)
         {
@@ -110,15 +108,15 @@ public bool? IsEnabled {
         switch (stringValue)
         {
             case "none":
-                return BuildAnalyzerResultSeverity.None;
+                return CheckResultSeverity.None;
             case "default":
-                return BuildAnalyzerResultSeverity.Default;
+                return CheckResultSeverity.Default;
             case "suggestion":
-                return BuildAnalyzerResultSeverity.Suggestion;
+                return CheckResultSeverity.Suggestion;
             case "warning":
-                return BuildAnalyzerResultSeverity.Warning;
+                return CheckResultSeverity.Warning;
             case "error":
-                return BuildAnalyzerResultSeverity.Error;
+                return CheckResultSeverity.Error;
             default:
                 ThrowIncorrectValueException(BuildCheckConstants.severityConfigurationKey, stringValue);
                 break;
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs b/src/Build/BuildCheck/API/CheckResultSeverity.cs
similarity index 95%
rename from src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs
rename to src/Build/BuildCheck/API/CheckResultSeverity.cs
index cd98bdbbf22..dc26b9d4532 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs
+++ b/src/Build/BuildCheck/API/CheckResultSeverity.cs
@@ -6,7 +6,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// The severity of reported result (or preconfigured or user configured severity for a rule).
 /// </summary>
-public enum BuildAnalyzerResultSeverity
+public enum CheckResultSeverity
 {
     /// <summary>
     /// When set, the default value of the BuildCheck rule will be used.
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerRule.cs b/src/Build/BuildCheck/API/CheckRule.cs
similarity index 75%
rename from src/Build/BuildCheck/API/BuildAnalyzerRule.cs
rename to src/Build/BuildCheck/API/CheckRule.cs
index 8b43dad4999..3fdf97bbc44 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerRule.cs
+++ b/src/Build/BuildCheck/API/CheckRule.cs
@@ -4,14 +4,18 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Represents a rule that is a unit of build analysis.
-/// <see cref="BuildAnalyzer"/> is a unit of executing the analysis, but it can be discovering multiple distinct violation types,
-///  for this reason a single <see cref="BuildAnalyzer"/> can expose multiple <see cref="BuildAnalyzerRule"/>s.
+/// Represents a rule that is a unit of a build check.
+/// <see cref="Check"/> is a unit of executing the check, but it can be discovering multiple distinct violation types,
+///  for this reason a single <see cref="Check"/> can expose multiple <see cref="CheckRule"/>s.
 /// </summary>
-public class BuildAnalyzerRule
+public class CheckRule
 {
-    public BuildAnalyzerRule(string id, string title, string description, string messageFormat,
-        BuildAnalyzerConfiguration defaultConfiguration)
+    public CheckRule(
+        string id,
+        string title,
+        string description,
+        string messageFormat,
+        CheckConfiguration defaultConfiguration)
     {
         Id = id;
         Title = title;
@@ -51,5 +55,5 @@ public BuildAnalyzerRule(string id, string title, string description, string mes
     /// The default configuration - overridable by the user via .editorconfig.
     /// If no user specified configuration is provided, this default will be used.
     /// </summary>
-    public BuildAnalyzerConfiguration DefaultConfiguration { get; }
+    public CheckConfiguration DefaultConfiguration { get; }
 }
diff --git a/src/Build/BuildCheck/API/ConfigurationContext.cs b/src/Build/BuildCheck/API/ConfigurationContext.cs
index 8f06a14717e..86a52ae1a11 100644
--- a/src/Build/BuildCheck/API/ConfigurationContext.cs
+++ b/src/Build/BuildCheck/API/ConfigurationContext.cs
@@ -13,15 +13,15 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// </summary>
 public class ConfigurationContext
 {
-    private ConfigurationContext(CustomConfigurationData[] customConfigurationData, BuildAnalyzerConfigurationEffective[] buildAnalyzerConfig)
+    private ConfigurationContext(CustomConfigurationData[] customConfigurationData, CheckConfigurationEffective[] checkConfig)
     {
         CustomConfigurationData = customConfigurationData;
-        BuildAnalyzerConfig = buildAnalyzerConfig;
+        CheckConfig = checkConfig;
     }
 
-    internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData[] customConfigurationData, BuildAnalyzerConfigurationEffective[] buildAnalyzerConfig)
+    internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData[] customConfigurationData, CheckConfigurationEffective[] checkConfig)
     {
-        return new ConfigurationContext(customConfigurationData, buildAnalyzerConfig);
+        return new ConfigurationContext(customConfigurationData, checkConfig);
     }
 
     /// <summary>
@@ -32,5 +32,5 @@ internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData
     /// <summary>
     /// Infrastructure configuration data
     /// </summary>
-    public IReadOnlyList<BuildAnalyzerConfigurationEffective> BuildAnalyzerConfig { get; init; }
+    public IReadOnlyList<CheckConfigurationEffective> CheckConfig { get; init; }
 }
diff --git a/src/Build/BuildCheck/API/EvaluationAnalysisScope.cs b/src/Build/BuildCheck/API/EvaluationAnalysisScope.cs
deleted file mode 100644
index 39781649359..00000000000
--- a/src/Build/BuildCheck/API/EvaluationAnalysisScope.cs
+++ /dev/null
@@ -1,33 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-namespace Microsoft.Build.Experimental.BuildCheck;
-
-/// <summary>
-/// For datasource events that can differentiate from where exactly they originate - e.g.
-///  For a condition string or AST - was that directly in hte analyzed project or imported?
-///
-/// Ignored by infrastructure if the current datasource doesn't support this level of setting.
-/// </summary>
-public enum EvaluationAnalysisScope
-{
-    /// <summary>
-    /// Only the data from currently analyzed project will be sent to the analyzer. Imports will be discarded.
-    /// </summary>
-    ProjectOnly,
-
-    /// <summary>
-    /// Only the data from currently analyzed project and imports from files under the entry project or solution will be sent to the analyzer. Other imports will be discarded.
-    /// </summary>
-    ProjectWithImportsFromCurrentWorkTree,
-
-    /// <summary>
-    /// Imports from SDKs will not be sent to the analyzer. Other imports will be sent.
-    /// </summary>
-    ProjectWithImportsWithoutSdks,
-
-    /// <summary>
-    /// All data will be sent to the analyzer.
-    /// </summary>
-    ProjectWithAllImports,
-}
diff --git a/src/Build/BuildCheck/API/EvaluationCheckScope.cs b/src/Build/BuildCheck/API/EvaluationCheckScope.cs
new file mode 100644
index 00000000000..08aecf49c80
--- /dev/null
+++ b/src/Build/BuildCheck/API/EvaluationCheckScope.cs
@@ -0,0 +1,29 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// For datasource events that can differentiate from where exactly they originate - e.g.
+///  For a condition string or AST - was that directly in the checked project or imported?
+///
+/// Ignored by infrastructure if the current datasource doesn't support this level of setting.
+/// </summary>
+public enum EvaluationCheckScope
+{
+    /// <summary>
+    /// Only the data from currently checked project will be sent to the check. Imports will be discarded.
+    /// </summary>
+    ProjectFileOnly,
+
+    /// <summary>
+    /// Only the data from currently checked project and imports from files not recognized to be in nuget cache or SDK install folder will be sent to the check. Other imports will be discarded.
+    /// The generated nuget.g.props, nuget.g.targets will be ignored as well.
+    /// </summary>
+    WorkTreeImports,
+
+    /// <summary>
+    /// All data will be sent to the check.
+    /// </summary>
+    All,
+}
diff --git a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
index b34ab8f726b..4e164d177c3 100644
--- a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
+++ b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
@@ -7,9 +7,13 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 
 public interface IBuildCheckRegistrationContext
 {
-    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction);
+    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction);
 
-    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction);
+    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction);
 
-    void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction);
+    void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction);
+
+    void RegisterEnvironmentVariableReadAction(Action<BuildCheckDataContext<EnvironmentVariableCheckData>> environmentVariableAction);
+
+    void RegisterBuildFinishedAction(Action<BuildCheckDataContext<BuildFinishedCheckData>> buildFinishedAction);
 }
diff --git a/src/Build/BuildCheck/API/IInternalCheckRegistrationContext.cs b/src/Build/BuildCheck/API/IInternalCheckRegistrationContext.cs
new file mode 100644
index 00000000000..2f8875fb62a
--- /dev/null
+++ b/src/Build/BuildCheck/API/IInternalCheckRegistrationContext.cs
@@ -0,0 +1,12 @@
+﻿using System;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
+
+internal interface IInternalCheckRegistrationContext : IBuildCheckRegistrationContext
+{
+    void RegisterPropertyReadAction(Action<BuildCheckDataContext<PropertyReadData>> propertyReadAction);
+
+    void RegisterPropertyWriteAction(Action<BuildCheckDataContext<PropertyWriteData>> propertyWriteAction);
+
+    void RegisterProjectRequestProcessingDoneAction(Action<BuildCheckDataContext<ProjectRequestProcessingDoneData>> propertyWriteAction);
+}
diff --git a/src/Build/BuildCheck/API/InternalCheck.cs b/src/Build/BuildCheck/API/InternalCheck.cs
new file mode 100644
index 00000000000..58e71338e93
--- /dev/null
+++ b/src/Build/BuildCheck/API/InternalCheck.cs
@@ -0,0 +1,28 @@
+﻿using System;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
+
+internal abstract class InternalCheck : Check
+{
+    /// <summary>
+    /// Used by the implementors to subscribe to data and events they are interested in.
+    /// This offers superset of registrations options to <see cref="Check.RegisterActions"/>.
+    /// </summary>
+    /// <param name="registrationContext"></param>
+    public abstract void RegisterInternalActions(IInternalCheckRegistrationContext registrationContext);
+
+    /// <summary>
+    /// This is intentionally not implemented, as it is extended by <see cref="RegisterInternalActions"/>.
+    /// </summary>
+    /// <param name="registrationContext"></param>
+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+    {
+        if (registrationContext is not IInternalCheckRegistrationContext internalRegistrationContext)
+        {
+            throw new ArgumentException("The registration context for InternalBuildAnalyzer must be of type IInternalBuildCheckRegistrationContext.", nameof(registrationContext));
+        }
+
+        this.RegisterInternalActions(internalRegistrationContext);
+    }
+}
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index ccb9dcfdafb..b0899f22134 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -5,9 +5,7 @@
 using System.Collections.Generic;
 using System.Linq;
 using System.Reflection;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -23,36 +21,36 @@ internal class BuildCheckAcquisitionModule : IBuildCheckAcquisitionModule
 #endif
 
     /// <summary>
-    /// Creates a list of factory delegates for building analyzer rules instances from a given assembly path.
+    /// Creates a list of factory delegates for building check rules instances from a given assembly path.
     /// </summary>
-    public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(
-        AnalyzerAcquisitionData analyzerAcquisitionData,
-        IAnalysisContext analysisContext)
+    public List<CheckFactory> CreateCheckFactories(
+        CheckAcquisitionData checkAcquisitionData,
+        ICheckContext checkContext)
     {
-        var analyzersFactories = new List<BuildAnalyzerFactory>();
+        var checksFactories = new List<CheckFactory>();
 
         try
         {
             Assembly? assembly = null;
 #if FEATURE_ASSEMBLYLOADCONTEXT
-            assembly = s_coreClrAssemblyLoader.LoadFromPath(analyzerAcquisitionData.AssemblyPath);
+            assembly = s_coreClrAssemblyLoader.LoadFromPath(checkAcquisitionData.AssemblyPath);
 #else
-            assembly = Assembly.LoadFrom(analyzerAcquisitionData.AssemblyPath);
+            assembly = Assembly.LoadFrom(checkAcquisitionData.AssemblyPath);
 #endif
 
             IList<Type> availableTypes = assembly.GetExportedTypes();
-            IList<Type> analyzerTypes = availableTypes.Where(t => typeof(BuildAnalyzer).IsAssignableFrom(t)).ToArray();
+            IList<Type> checkTypes = availableTypes.Where(t => typeof(Check).IsAssignableFrom(t)).ToArray();
 
-            foreach (Type analyzerCandidate in analyzerTypes)
+            foreach (Type checkCandidate in checkTypes)
             {
-                analyzersFactories.Add(() => (BuildAnalyzer)Activator.CreateInstance(analyzerCandidate)!);
-                analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerRegistered", analyzerCandidate.Name, analyzerCandidate.Assembly);
+                checksFactories.Add(() => (Check)Activator.CreateInstance(checkCandidate)!);
+                checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckRegistered", checkCandidate.Name, checkCandidate.Assembly);
             }
 
-            if (availableTypes.Count != analyzerTypes.Count)
+            if (availableTypes.Count != checkTypes.Count)
             {
-                availableTypes.Except(analyzerTypes).ToList()
-                    .ForEach(t => analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerBaseTypeNotAssignable", t.Name, t.Assembly));
+                availableTypes.Except(checkTypes).ToList()
+                    .ForEach(t => checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckBaseTypeNotAssignable", t.Name, t.Assembly));
             }
         }
         catch (ReflectionTypeLoadException ex)
@@ -61,15 +59,15 @@ public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(
             {
                 foreach (Exception? loaderException in ex.LoaderExceptions)
                 {
-                    analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerFailedRuleLoading", loaderException?.Message);
+                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedRuleLoading", loaderException?.Message);
                 }
             }
         }
         catch (Exception ex)
         {
-            analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerFailedRuleLoading", ex?.Message);
+            checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedRuleLoading", ex?.Message);
         }
 
-        return analyzersFactories;
+        return checksFactories;
     }
 }
diff --git a/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs b/src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs
similarity index 59%
rename from src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
rename to src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs
index 908aa931bef..74a0c87be38 100644
--- a/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
+++ b/src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs
@@ -13,15 +13,17 @@ namespace Microsoft.Build.Experimental.BuildCheck.Acquisition;
 // https://github.com/dotnet/msbuild/issues/9633
 // Acquisition
 //  define the data that will be passed to the acquisition module (and remoted if needed)
-internal class AnalyzerAcquisitionData(string assemblyPath)
+internal class CheckAcquisitionData(string assemblyPath, string projectPath)
 {
     public string AssemblyPath { get; init; } = assemblyPath;
+
+    public string ProjectPath { get; init; } = projectPath;
 }
 
-internal static class AnalyzerAcquisitionDataExtensions
+internal static class CheckAcquisitionDataExtensions
 {
-    public static AnalyzerAcquisitionData ToAnalyzerAcquisitionData(this BuildCheckAcquisitionEventArgs eventArgs) =>
-        new(eventArgs.AcquisitionPath);
+    public static CheckAcquisitionData ToCheckAcquisitionData(this BuildCheckAcquisitionEventArgs eventArgs) =>
+        new(eventArgs.AcquisitionPath, eventArgs.ProjectPath);
 
-    public static BuildCheckAcquisitionEventArgs ToBuildEventArgs(this AnalyzerAcquisitionData data) => new(data.AssemblyPath);
+    public static BuildCheckAcquisitionEventArgs ToBuildEventArgs(this CheckAcquisitionData data) => new(data.AssemblyPath, data.ProjectPath);
 }
diff --git a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
index 20259725b4f..245736ca67a 100644
--- a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
@@ -10,7 +10,7 @@ namespace Microsoft.Build.Experimental.BuildCheck.Acquisition;
 internal interface IBuildCheckAcquisitionModule
 {
     /// <summary>
-    /// Creates a list of factory delegates for building analyzer rules instances from a given assembly path.
+    /// Creates a list of factory delegates for building check rules instances from a given assembly path.
     /// </summary>
-    List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisitionData analyzerAcquisitionData, IAnalysisContext analysisContext);
+    List<CheckFactory> CreateCheckFactories(CheckAcquisitionData checkAcquisitionData, ICheckContext checkContext);
 }
diff --git a/src/Build/BuildCheck/Analyzers/NoEnvironmentVariablePropertyAnalyzer.cs b/src/Build/BuildCheck/Analyzers/NoEnvironmentVariablePropertyAnalyzer.cs
deleted file mode 100644
index 6c3cd071d7b..00000000000
--- a/src/Build/BuildCheck/Analyzers/NoEnvironmentVariablePropertyAnalyzer.cs
+++ /dev/null
@@ -1,84 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using Microsoft.Build.Construction;
-
-namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;
-
-internal sealed class NoEnvironmentVariablePropertyAnalyzer : BuildAnalyzer
-{
-    /// <summary>
-    /// Contains the list of reported environment variables.
-    /// </summary>
-    private readonly HashSet<EnvironmentVariableIdentityKey> _environmentVariablesReported = new HashSet<EnvironmentVariableIdentityKey>();
-
-    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
-        "BC0103",
-        "NoEnvironmentVariablePropertyAnalyzer",
-        "No implicit property derived from an environment variable should be used during the build",
-        "Property is derived from environment variable: '{0}' with value: '{1}'. Properties should be passed explicitly using the /p option.",
-        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Suggestion });
-
-    public override string FriendlyName => "MSBuild.NoEnvironmentVariablePropertyAnalyzer";
-
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
-
-    public override void Initialize(ConfigurationContext configurationContext)
-    {
-        // No custom configuration
-    }
-
-    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);
-
-    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
-    {
-        if (context.Data.EvaluatedEnvironmentVariables.Count != 0)
-        {
-            foreach (var envVariableData in context.Data.EvaluatedEnvironmentVariables)
-            {
-                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column);
-                if (!_environmentVariablesReported.Contains(identityKey))
-                {
-                    context.ReportResult(BuildCheckResult.Create(
-                        SupportedRule,
-                        ElementLocation.Create(envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column),
-                        envVariableData.Key,
-                        envVariableData.Value.EnvVarValue));
-
-                    _environmentVariablesReported.Add(identityKey);
-                }
-            }
-        }
-    }
-
-    internal class EnvironmentVariableIdentityKey(string environmentVariableName, string file, int line, int column) : IEquatable<EnvironmentVariableIdentityKey>
-    {
-        public string EnvironmentVariableName { get; } = environmentVariableName;
-
-        public string File { get; } = file;
-
-        public int Line { get; } = line;
-
-        public int Column { get; } = column;
-
-        public override bool Equals(object? obj) => Equals(obj as EnvironmentVariableIdentityKey);
-
-        public bool Equals(EnvironmentVariableIdentityKey? other) =>
-            other != null &&
-            EnvironmentVariableName == other.EnvironmentVariableName &&
-            File == other.File &&
-            Line == other.Line &&
-            Column == other.Column;
-
-        public override int GetHashCode()
-        {
-            int hashCode = 17;
-            hashCode = hashCode * 31 + (File != null ? File.GetHashCode() : 0);
-            hashCode = hashCode * 31 + Line.GetHashCode();
-            hashCode = hashCode * 31 + Column.GetHashCode();
-            return hashCode;
-        }
-    }
-}
diff --git a/src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
similarity index 73%
rename from src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs
rename to src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
index 0804d6d76c3..df2cbd61145 100644
--- a/src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs
+++ b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
@@ -10,26 +10,26 @@
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
-using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData;
+using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationCheckData;
 
 #if FEATURE_MSIOREDIST
 using Path = Microsoft.IO.Path;
 #endif
 
-namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
 
-internal sealed class DoubleWritesAnalyzer : BuildAnalyzer
+internal sealed class DoubleWritesCheck : Check
 {
-    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+    public static CheckRule SupportedRule = new CheckRule(
         "BC0102",
         "DoubleWrites",
         "Two tasks should not write the same file",
         "Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.",
-        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning });
+        new CheckConfiguration() { Severity = CheckResultSeverity.Warning });
 
-    public override string FriendlyName => "MSBuild.DoubleWritesAnalyzer";
+    public override string FriendlyName => "MSBuild.DoubleWritesCheck";
 
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
@@ -46,39 +46,39 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
     /// </summary>
     private readonly Dictionary<string, (string projectFilePath, string taskName)> _filesWritten = new(StringComparer.CurrentCultureIgnoreCase);
 
-    private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+    private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationCheckData> context)
     {
-        // This analyzer uses a hard-coded list of tasks known to write files.
+        // This check uses a hard-coded list of tasks known to write files.
         switch (context.Data.TaskName)
         {
             case "Csc":
             case "Vbc":
-            case "Fsc": AnalyzeCompilerTask(context); break;
-            case "Copy": AnalyzeCopyTask(context); break;
+            case "Fsc": CheckCompilerTask(context); break;
+            case "Copy": CheckCopyTask(context); break;
         }
     }
 
-    private void AnalyzeCompilerTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+    private void CheckCompilerTask(BuildCheckDataContext<TaskInvocationCheckData> context)
     {
         var taskParameters = context.Data.Parameters;
 
         // Compiler tasks have several parameters representing files being written.
-        AnalyzeParameter("OutputAssembly");
-        AnalyzeParameter("OutputRefAssembly");
-        AnalyzeParameter("DocumentationFile");
-        AnalyzeParameter("PdbFile");
+        CheckParameter("OutputAssembly");
+        CheckParameter("OutputRefAssembly");
+        CheckParameter("DocumentationFile");
+        CheckParameter("PdbFile");
 
-        void AnalyzeParameter(string parameterName)
+        void CheckParameter(string parameterName)
         {
             if (taskParameters.TryGetValue(parameterName, out TaskParameter? taskParameter))
             {
                 string outputPath = taskParameter.EnumerateStringValues().FirstOrDefault() ?? "";
-                AnalyzeWrite(context, outputPath);
+                CheckWrite(context, outputPath);
             }
         }
     }
 
-    private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+    private void CheckCopyTask(BuildCheckDataContext<TaskInvocationCheckData> context)
     {
         var taskParameters = context.Data.Parameters;
 
@@ -89,19 +89,19 @@ private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationAnalysisData> c
             string destinationFolderPath = destinationFolder.EnumerateStringValues().FirstOrDefault() ?? "";
             foreach (string sourceFilePath in sourceFiles.EnumerateStringValues())
             {
-                AnalyzeWrite(context, Path.Combine(destinationFolderPath, Path.GetFileName(sourceFilePath)));
+                CheckWrite(context, Path.Combine(destinationFolderPath, Path.GetFileName(sourceFilePath)));
             }
         }
         else if (taskParameters.TryGetValue("DestinationFiles", out TaskParameter? destinationFiles))
         {
             foreach (string destinationFilePath in destinationFiles.EnumerateStringValues())
             {
-                AnalyzeWrite(context, destinationFilePath);
+                CheckWrite(context, destinationFilePath);
             }
         }
     }
 
-    private void AnalyzeWrite(BuildCheckDataContext<TaskInvocationAnalysisData> context, string fileBeingWritten)
+    private void CheckWrite(BuildCheckDataContext<TaskInvocationCheckData> context, string fileBeingWritten)
     {
         if (!string.IsNullOrEmpty(fileBeingWritten))
         {
diff --git a/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
new file mode 100644
index 00000000000..51411b9502f
--- /dev/null
+++ b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
@@ -0,0 +1,125 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
+
+internal sealed class NoEnvironmentVariablePropertyCheck : Check
+{
+    public static CheckRule SupportedRule = new CheckRule(
+        "BC0103",
+        "NoEnvironmentVariablePropertyCheck",
+        "No implicit property derived from an environment variable should be used during the build",
+        "Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.",
+        new CheckConfiguration() { Severity = CheckResultSeverity.Suggestion });
+
+    private const string RuleId = "BC0103";
+
+    private const string VerboseEnvVariableOutputKey = "allow_displaying_environment_variable_value";
+
+    private readonly Queue<(string projectPath, BuildCheckDataContext<EnvironmentVariableCheckData>)> _buildCheckResults = new Queue<(string, BuildCheckDataContext<EnvironmentVariableCheckData>)>();
+
+    /// <summary>
+    /// Contains the list of viewed environment variables.
+    /// </summary>
+    private readonly HashSet<EnvironmentVariableIdentityKey> _environmentVariablesCache = new HashSet<EnvironmentVariableIdentityKey>();
+
+    private bool _isVerboseEnvVarOutput;
+    private EvaluationCheckScope _scope;
+
+    public override string FriendlyName => "MSBuild.NoEnvironmentVariablePropertyCheck";
+
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
+
+    public override void Initialize(ConfigurationContext configurationContext)
+    {
+        _scope = configurationContext.CheckConfig[0].EvaluationCheckScope;
+        foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)
+        {
+            bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);
+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;
+        }
+
+        CheckScopeClassifier.NotifyOnScopingReadiness += HandleScopeReadiness;
+    }
+
+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEnvironmentVariableReadAction(ProcessEnvironmentVariableReadAction);
+
+    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EnvironmentVariableCheckData> context)
+    {
+        EnvironmentVariableIdentityKey identityKey = new(context.Data.EnvironmentVariableName, context.Data.EnvironmentVariableLocation);
+        if (!_environmentVariablesCache.Contains(identityKey))
+        {
+            // Scope information is available after evaluation of the project file. If it is not ready, we will report the check later.
+            if (!CheckScopeClassifier.IsScopingReady(_scope))
+            {
+                _buildCheckResults.Enqueue((context.Data.ProjectFilePath, context));
+            }
+            else if (CheckScopeClassifier.IsActionInObservedScope(_scope, context.Data.EnvironmentVariableLocation.File, context.Data.ProjectFilePath))
+            {
+                context.ReportResult(BuildCheckResult.Create(
+                    SupportedRule,
+                    context.Data.EnvironmentVariableLocation,
+                    GetFormattedMessage(context.Data.EnvironmentVariableName, context.Data.EnvironmentVariableValue)));
+            }
+
+            _environmentVariablesCache.Add(identityKey);
+        }
+    }
+
+    private static bool? GetVerboseEnvVarOutputConfig(CustomConfigurationData customConfigurationData, string ruleId) => customConfigurationData.RuleId.Equals(ruleId, StringComparison.InvariantCultureIgnoreCase)
+            && (customConfigurationData.ConfigurationData?.TryGetValue(VerboseEnvVariableOutputKey, out string? configVal) ?? false)
+            ? bool.Parse(configVal)
+            : null;
+
+    private void HandleScopeReadiness()
+    {
+        while (_buildCheckResults.Count > 0)
+        {
+            (string projectPath, BuildCheckDataContext<EnvironmentVariableCheckData> context) = _buildCheckResults.Dequeue();
+            if (!CheckScopeClassifier.IsActionInObservedScope(_scope, context.Data.EnvironmentVariableLocation.File, projectPath))
+            {
+                continue;
+            }
+
+            context.ReportResult(BuildCheckResult.Create(
+                SupportedRule,
+                context.Data.EnvironmentVariableLocation,
+                GetFormattedMessage(context.Data.EnvironmentVariableName, context.Data.EnvironmentVariableValue)));
+        }
+
+        CheckScopeClassifier.NotifyOnScopingReadiness -= HandleScopeReadiness;
+    }
+
+    private string GetFormattedMessage(string envVariableName, string envVariableValue) => _isVerboseEnvVarOutput? $"'{envVariableName}' with value: '{envVariableValue}'" : $"'{envVariableName}'";
+
+    internal class EnvironmentVariableIdentityKey(string environmentVariableName, IMSBuildElementLocation location) : IEquatable<EnvironmentVariableIdentityKey>
+    {
+        public string EnvironmentVariableName { get; } = environmentVariableName;
+
+        public IMSBuildElementLocation Location { get; } = location;
+
+        public override bool Equals(object? obj) => Equals(obj as EnvironmentVariableIdentityKey);
+
+        public bool Equals(EnvironmentVariableIdentityKey? other) =>
+            other != null &&
+            EnvironmentVariableName == other.EnvironmentVariableName &&
+            Location.File == other.Location.File &&
+            Location.Line == other.Location.Line &&
+            Location.Column == other.Location.Column;
+
+        public override int GetHashCode()
+        {
+            int hashCode = 17;
+            hashCode = hashCode * 31 + (Location.File != null ? Location.File.GetHashCode() : 0);
+            hashCode = hashCode * 31 + Location.Line.GetHashCode();
+            hashCode = hashCode * 31 + Location.Column.GetHashCode();
+
+            return hashCode;
+        }
+    }
+}
diff --git a/src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs b/src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs
new file mode 100644
index 00000000000..f2e7d2fc37a
--- /dev/null
+++ b/src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs
@@ -0,0 +1,242 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
+
+internal class PropertiesUsageCheck : InternalCheck
+{
+    private static readonly CheckRule _usedBeforeInitializedRule = new CheckRule("BC0201", "PropertyUsedBeforeDeclared",
+        "A property that is accessed should be declared first.",
+        "Property: [{0}] was accessed, but it was never initialized.",
+        new CheckConfiguration() { Severity = CheckResultSeverity.Warning, EvaluationCheckScope = EvaluationCheckScope.ProjectFileOnly });
+
+    private static readonly CheckRule _initializedAfterUsedRule = new CheckRule("BC0202", "PropertyDeclaredAfterUsed",
+        "A property should be declared before it is first used.",
+        "Property: [{0}] first declared/initialized at [{1}] used before it was initialized.",
+        new CheckConfiguration() { Severity = CheckResultSeverity.Warning, EvaluationCheckScope = EvaluationCheckScope.ProjectFileOnly });
+
+    private static readonly CheckRule _unusedPropertyRule = new CheckRule("BC0203", "UnusedPropertyDeclared",
+        "A property that is not used should not be declared.",
+        "Property: [{0}] was declared/initialized, but it was never used.",
+        new CheckConfiguration() { Severity = CheckResultSeverity.Suggestion, EvaluationCheckScope = EvaluationCheckScope.ProjectFileOnly });
+
+    internal static readonly IReadOnlyList<CheckRule> SupportedRulesList = [_usedBeforeInitializedRule, _initializedAfterUsedRule, _unusedPropertyRule];
+
+    public override string FriendlyName => "MSBuild.PropertiesUsageAnalyzer";
+
+    public override IReadOnlyList<CheckRule> SupportedRules => SupportedRulesList;
+
+    private const string _allowUninitPropsInConditionsKey = "AllowUninitializedPropertiesInConditions";
+    private bool _allowUninitPropsInConditions = false;
+    // Each check can have it's scope and enablement
+    private EvaluationCheckScope _uninitializedReadScope;
+    private EvaluationCheckScope _unusedPropertyScope;
+    private EvaluationCheckScope _initializedAfterUseScope;
+    private bool _uninitializedReadEnabled;
+    private bool _unusedPropertyEnabled;
+    private bool _initializedAfterUseEnabled;
+    public override void Initialize(ConfigurationContext configurationContext)
+    {
+        var config = configurationContext.CheckConfig.FirstOrDefault(c => c.RuleId == _usedBeforeInitializedRule.Id)
+                ?? CheckConfigurationEffective.Default;
+
+        _uninitializedReadEnabled = config.IsEnabled;
+        _uninitializedReadScope = config.EvaluationCheckScope;
+
+        config = configurationContext.CheckConfig.FirstOrDefault(c => c.RuleId == _unusedPropertyRule.Id)
+                 ?? CheckConfigurationEffective.Default;
+
+        _unusedPropertyEnabled = config.IsEnabled;
+        _unusedPropertyScope = config.EvaluationCheckScope;
+
+        config = configurationContext.CheckConfig.FirstOrDefault(c => c.RuleId == _usedBeforeInitializedRule.Id)
+                 ?? CheckConfigurationEffective.Default;
+
+        _initializedAfterUseEnabled = config.IsEnabled;
+        _initializedAfterUseScope = config.EvaluationCheckScope;
+
+        bool? allowUninitPropsInConditionsRule1 = null;
+        bool? allowUninitPropsInConditionsRule2 = null;
+
+        foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)
+        {
+            allowUninitPropsInConditionsRule1 =
+                GetAllowUninitPropsInConditionsConfig(customConfigurationData, _usedBeforeInitializedRule.Id);
+            allowUninitPropsInConditionsRule2 =
+                GetAllowUninitPropsInConditionsConfig(customConfigurationData, _initializedAfterUsedRule.Id);
+        }
+
+        if (allowUninitPropsInConditionsRule1.HasValue &&
+            allowUninitPropsInConditionsRule2.HasValue &&
+            allowUninitPropsInConditionsRule1 != allowUninitPropsInConditionsRule2)
+        {
+            throw new BuildCheckConfigurationException(
+                $"[{_usedBeforeInitializedRule.Id}] and [{_initializedAfterUsedRule.Id}] are not allowed to have differing configuration value for [{_allowUninitPropsInConditionsKey}]");
+        }
+
+        if (allowUninitPropsInConditionsRule1.HasValue || allowUninitPropsInConditionsRule2.HasValue)
+        {
+            _allowUninitPropsInConditions = allowUninitPropsInConditionsRule1 ?? allowUninitPropsInConditionsRule2 ?? false;
+        }
+    }
+
+    private static bool? GetAllowUninitPropsInConditionsConfig(CustomConfigurationData customConfigurationData,
+        string ruleId)
+    {
+        if (customConfigurationData.RuleId.Equals(ruleId, StringComparison.InvariantCultureIgnoreCase) &&
+            (customConfigurationData.ConfigurationData?.TryGetValue(_allowUninitPropsInConditionsKey, out string? configVal) ?? false))
+        {
+            return bool.Parse(configVal);
+        }
+
+        return null;
+    }
+
+    public override void RegisterInternalActions(IInternalCheckRegistrationContext registrationContext)
+    {
+        registrationContext.RegisterPropertyReadAction(ProcessPropertyRead);
+
+        if (_unusedPropertyEnabled || _initializedAfterUseEnabled)
+        {
+            registrationContext.RegisterPropertyWriteAction(ProcessPropertyWrite);
+        }
+
+        if (_unusedPropertyEnabled || _uninitializedReadEnabled)
+        {
+            registrationContext.RegisterProjectRequestProcessingDoneAction(DoneWithProject);
+        }
+    }
+
+    private Dictionary<string, IMSBuildElementLocation?> _writenProperties = new(MSBuildNameIgnoreCaseComparer.Default);
+    private HashSet<string> _readProperties = new(MSBuildNameIgnoreCaseComparer.Default);
+    // For the 'Property Initialized after used' check - we are interested in cases where:
+    //   1. Property is read anywhere and then initialized in the checked scope.
+    //   2. Property is read in the checked scope and then initialized anywhere.
+    private Dictionary<string, IMSBuildElementLocation> _uninitializedReadsInScope = new(MSBuildNameIgnoreCaseComparer.Default);
+    private Dictionary<string, IMSBuildElementLocation> _uninitializedReadsOutOfScope = new(MSBuildNameIgnoreCaseComparer.Default);
+
+    private void ProcessPropertyWrite(BuildCheckDataContext<PropertyWriteData> context)
+    {
+        PropertyWriteData writeData = context.Data;
+
+        // If we want to track unused properties - store all definitions that are in scope.
+        if (_unusedPropertyEnabled && CheckScopeClassifier.IsActionInObservedScope(_unusedPropertyScope,
+                writeData.ElementLocation, writeData.ProjectFilePath))
+        {
+            _writenProperties[writeData.PropertyName] = writeData.ElementLocation;
+        }
+
+        if (_initializedAfterUseEnabled && !writeData.IsEmpty)
+        {
+            // For initialized after used check - we can remove the read from dictionary after hitting write - because
+            //  once the property is written it should no more be uninitialized (so shouldn't be added again).
+
+            if (_uninitializedReadsInScope.TryGetValue(writeData.PropertyName, out IMSBuildElementLocation? uninitInScopeReadLocation))
+            {
+                _uninitializedReadsInScope.Remove(writeData.PropertyName);
+
+                context.ReportResult(BuildCheckResult.Create(
+                    _initializedAfterUsedRule,
+                    uninitInScopeReadLocation,
+                    writeData.PropertyName, writeData.ElementLocation?.LocationString ?? string.Empty));
+            }
+
+            if (CheckScopeClassifier.IsActionInObservedScope(_initializedAfterUseScope,
+                    writeData.ElementLocation, writeData.ProjectFilePath) &&
+                _uninitializedReadsOutOfScope.TryGetValue(writeData.PropertyName, out IMSBuildElementLocation? uninitOutScopeReadLocation))
+            {
+                _uninitializedReadsOutOfScope.Remove(writeData.PropertyName);
+
+                context.ReportResult(BuildCheckResult.Create(
+                    _initializedAfterUsedRule,
+                    uninitOutScopeReadLocation,
+                    writeData.PropertyName, writeData.ElementLocation?.LocationString ?? string.Empty));
+            }
+        }
+    }
+
+    private void ProcessPropertyRead(BuildCheckDataContext<PropertyReadData> context)
+    {
+        PropertyReadData readData = context.Data;
+
+        // Self property initialization is not considered as a violation.
+        if (readData.PropertyReadContext != PropertyReadContext.PropertyEvaluationSelf &&
+            // If we are interested in missing usage checking - let's store, regardless of location of read.
+            _unusedPropertyEnabled)
+        {
+            _readProperties.Add(readData.PropertyName);
+        }
+
+        if (readData.IsUninitialized &&
+            (_uninitializedReadEnabled || _initializedAfterUseEnabled) &&
+            readData.PropertyReadContext != PropertyReadContext.PropertyEvaluationSelf &&
+            readData.PropertyReadContext != PropertyReadContext.ConditionEvaluationWithOneSideEmpty &&
+            (!_allowUninitPropsInConditions ||
+             readData.PropertyReadContext != PropertyReadContext.ConditionEvaluation))
+        {
+            // We want to wait with reporting uninitialized reads until we are sure there wasn't later attempts to initialize them.
+            if (_initializedAfterUseEnabled)
+            {
+                if (CheckScopeClassifier.IsActionInObservedScope(_initializedAfterUseScope,
+                        readData.ElementLocation, readData.ProjectFilePath))
+                {
+                    _uninitializedReadsInScope[readData.PropertyName] = readData.ElementLocation;
+                }
+                // If uninitialized read happened in scope and out of scope - keep just that in scope.
+                else if (!_uninitializedReadsInScope.ContainsKey(readData.PropertyName))
+                {
+                    _uninitializedReadsOutOfScope[readData.PropertyName] = readData.ElementLocation;
+                }
+            }
+            else if (CheckScopeClassifier.IsActionInObservedScope(_uninitializedReadScope,
+                         readData.ElementLocation, readData.ProjectFilePath))
+            {
+                // report immediately
+                context.ReportResult(BuildCheckResult.Create(
+                    _usedBeforeInitializedRule,
+                    readData.ElementLocation,
+                    readData.PropertyName));
+            }
+        }
+    }
+
+
+    private void DoneWithProject(BuildCheckDataContext<ProjectRequestProcessingDoneData> context)
+    {
+        foreach (var propWithLocation in _writenProperties)
+        {
+            if (propWithLocation.Value != null && !_readProperties.Contains(propWithLocation.Key))
+            {
+                context.ReportResult(BuildCheckResult.Create(
+                    _unusedPropertyRule,
+                    propWithLocation.Value,
+                    propWithLocation.Key));
+            }
+        }
+
+        // Report the remaining uninitialized reads - as if 'initialized after read' check was enabled - we cannot report
+        //  uninitialized reads immediately (instead we wait if they are attempted to be initialized late).
+        foreach (var uninitializedRead in _uninitializedReadsInScope)
+        {
+            context.ReportResult(BuildCheckResult.Create(
+                _usedBeforeInitializedRule,
+                uninitializedRead.Value,
+                uninitializedRead.Key));
+        }
+
+        _readProperties = new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+        _writenProperties = new Dictionary<string, IMSBuildElementLocation?>(MSBuildNameIgnoreCaseComparer.Default);
+        _uninitializedReadsInScope = new Dictionary<string, IMSBuildElementLocation>(MSBuildNameIgnoreCaseComparer.Default);
+    }
+}
diff --git a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
similarity index 79%
rename from src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
rename to src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
index 8d531105a94..1ec84093e3a 100644
--- a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
+++ b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
@@ -11,19 +11,19 @@
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Shared;
 
-namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
 
-internal sealed class SharedOutputPathAnalyzer : BuildAnalyzer
+internal sealed class SharedOutputPathCheck : Check
 {
     private const string RuleId = "BC0101";
-    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(RuleId, "ConflictingOutputPath",
+    public static CheckRule SupportedRule = new CheckRule(RuleId, "ConflictingOutputPath",
         "Two projects should not share their OutputPath nor IntermediateOutputPath locations",
         "Projects {0} and {1} have conflicting output paths: {2}.",
-        new BuildAnalyzerConfiguration() { RuleId = RuleId, Severity = BuildAnalyzerResultSeverity.Warning });
+        new CheckConfiguration() { RuleId = RuleId, Severity = CheckResultSeverity.Warning });
 
-    public override string FriendlyName => "MSBuild.SharedOutputPathAnalyzer";
+    public override string FriendlyName => "MSBuild.SharedOutputPathCheck";
 
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
@@ -38,7 +38,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
     private readonly Dictionary<string, string> _projectsPerOutputPath = new(StringComparer.CurrentCultureIgnoreCase);
     private readonly HashSet<string> _projects = new(StringComparer.CurrentCultureIgnoreCase);
 
-    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
     {
         if (!_projects.Add(context.Data.ProjectFilePath))
         {
@@ -46,8 +46,9 @@ private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedProperties
         }
 
         string? binPath, objPath;
-        context.Data.EvaluatedProperties.TryGetPathValue("OutputPath", out binPath);
-        context.Data.EvaluatedProperties.TryGetPathValue("IntermediateOutputPath", out objPath);
+
+        context.Data.EvaluatedProperties.TryGetValue("OutputPath", out binPath);
+        context.Data.EvaluatedProperties.TryGetValue("IntermediateOutputPath", out objPath);
 
         string? absoluteBinPath = CheckAndAddFullOutputPath(binPath, context);
         // Check objPath only if it is different from binPath
@@ -61,7 +62,7 @@ private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedProperties
         }
     }
 
-    private string? CheckAndAddFullOutputPath(string? path, BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    private string? CheckAndAddFullOutputPath(string? path, BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
     {
         if (string.IsNullOrEmpty(path))
         {
@@ -76,7 +77,7 @@ private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedProperties
         }
 
         // Normalize the path to avoid false negatives due to different path representations.
-        path = Path.GetFullPath(path);
+        path = FileUtilities.NormalizePath(path);
 
         if (_projectsPerOutputPath.TryGetValue(path!, out string? conflictingProject))
         {
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationEffective.cs b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationEffective.cs
deleted file mode 100644
index 2b7bbf16ebc..00000000000
--- a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationEffective.cs
+++ /dev/null
@@ -1,41 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using Microsoft.Build.Experimental.BuildCheck;
-
-namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-
-/// <summary>
-/// Counterpart type for BuildAnalyzerConfiguration - with all properties non-nullable
-/// </summary>
-public sealed class BuildAnalyzerConfigurationEffective
-{
-    public BuildAnalyzerConfigurationEffective(string ruleId, EvaluationAnalysisScope evaluationAnalysisScope, BuildAnalyzerResultSeverity severity)
-    {
-        if (severity == BuildAnalyzerResultSeverity.Default)
-        {
-            throw new ArgumentOutOfRangeException(nameof(severity), severity, "Severity 'Default' is not recognized by the BuildCheck reports infrastructure");
-        }
-
-        RuleId = ruleId;
-        EvaluationAnalysisScope = evaluationAnalysisScope;
-        Severity = severity;
-    }
-
-    public string RuleId { get; }
-
-    public EvaluationAnalysisScope EvaluationAnalysisScope { get; }
-
-    public BuildAnalyzerResultSeverity Severity { get; }
-
-    public bool IsEnabled => Severity >= BuildAnalyzerResultSeverity.Suggestion;
-
-    // Intentionally not checking the RuleId
-    //  as for analyzers with multiple rules, we can squash config to a single one,
-    //  if the ruleId is the only thing differing.
-    public bool IsSameConfigurationAs(BuildAnalyzerConfigurationEffective? other) =>
-        other != null &&
-        Severity == other.Severity &&
-        EvaluationAnalysisScope == other.EvaluationAnalysisScope;
-}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
index 2b6b94aa2d5..419ca2c9f26 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
@@ -10,29 +10,33 @@
 using Microsoft.Build.Experimental.BuildCheck.Acquisition;
 using Microsoft.Build.Experimental.BuildCheck.Utilities;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal class BuildCheckBuildEventHandler
 {
     private readonly IBuildCheckManager _buildCheckManager;
-    private readonly IAnalysisContextFactory _analyzerContextFactory;
+    private readonly ICheckContextFactory _checkContextFactory;
 
-    private readonly Dictionary<Type, Action<BuildEventArgs>> _eventHandlers;
+    private Dictionary<Type, Action<BuildEventArgs>> _eventHandlers;
+    private readonly Dictionary<Type, Action<BuildEventArgs>> _eventHandlersFull;
+    private readonly Dictionary<Type, Action<BuildEventArgs>> _eventHandlersRestore;
 
     internal BuildCheckBuildEventHandler(
-        IAnalysisContextFactory analyzerContextFactory,
+        ICheckContextFactory checkContextFactory,
         IBuildCheckManager buildCheckManager)
     {
         _buildCheckManager = buildCheckManager;
-        _analyzerContextFactory = analyzerContextFactory;
+        _checkContextFactory = checkContextFactory;
 
-        _eventHandlers = new()
+        _eventHandlersFull = new()
         {
+            { typeof(BuildSubmissionStartedEventArgs), (BuildEventArgs e) => HandleBuildSubmissionStartedEvent((BuildSubmissionStartedEventArgs)e) },
             { typeof(ProjectEvaluationFinishedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationFinishedEvent((ProjectEvaluationFinishedEventArgs)e) },
             { typeof(ProjectEvaluationStartedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs)e) },
             { typeof(EnvironmentVariableReadEventArgs), (BuildEventArgs e) => HandleEnvironmentVariableReadEvent((EnvironmentVariableReadEventArgs)e) },
-            { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => _buildCheckManager.StartProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!, ((ProjectStartedEventArgs)e).ProjectFile!) },
+            { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => _buildCheckManager.StartProjectRequest(e.BuildEventContext!, ((ProjectStartedEventArgs)e).ProjectFile!) },
             { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => HandleProjectFinishedRequest((ProjectFinishedEventArgs)e) },
             { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => HandleBuildCheckTracingEvent((BuildCheckTracingEventArgs)e) },
             { typeof(BuildCheckAcquisitionEventArgs), (BuildEventArgs e) => HandleBuildCheckAcquisitionEvent((BuildCheckAcquisitionEventArgs)e) },
@@ -41,6 +45,14 @@ internal BuildCheckBuildEventHandler(
             { typeof(TaskParameterEventArgs), (BuildEventArgs e) => HandleTaskParameterEvent((TaskParameterEventArgs)e) },
             { typeof(BuildFinishedEventArgs), (BuildEventArgs e) => HandleBuildFinishedEvent((BuildFinishedEventArgs)e) },
         };
+
+        // During restore we'll wait only for restore to be done.
+        _eventHandlersRestore = new()
+        {
+            { typeof(BuildSubmissionStartedEventArgs), (BuildEventArgs e) => HandleBuildSubmissionStartedEvent((BuildSubmissionStartedEventArgs)e) },
+        };
+
+        _eventHandlers = _eventHandlersFull;
     }
 
     public void HandleBuildEvent(BuildEventArgs e)
@@ -51,15 +63,23 @@ public void HandleBuildEvent(BuildEventArgs e)
         }
     }
 
+    private void HandleBuildSubmissionStartedEvent(BuildSubmissionStartedEventArgs eventArgs)
+    {
+        eventArgs.GlobalProperties.TryGetValue(MSBuildConstants.MSBuildIsRestoring, out string? restoreProperty);
+        bool isRestoring = restoreProperty is not null && Convert.ToBoolean(restoreProperty);
+
+        _eventHandlers = isRestoring ? _eventHandlersRestore : _eventHandlersFull;
+    }
+
     private void HandleProjectEvaluationFinishedEvent(ProjectEvaluationFinishedEventArgs eventArgs)
     {
         if (!IsMetaProjFile(eventArgs.ProjectFile))
         {
             _buildCheckManager.ProcessEvaluationFinishedEventArgs(
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs);
 
-            _buildCheckManager.EndProjectEvaluation(BuildCheckDataSource.EventArgs, eventArgs.BuildEventContext!);
+            _buildCheckManager.EndProjectEvaluation(eventArgs.BuildEventContext!);
         }
     }
 
@@ -67,17 +87,20 @@ private void HandleProjectEvaluationStartedEvent(ProjectEvaluationStartedEventAr
     {
         if (!IsMetaProjFile(eventArgs.ProjectFile))
         {
-            _buildCheckManager.StartProjectEvaluation(
+            var checkContext = _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!);
+            _buildCheckManager.ProjectFirstEncountered(
                 BuildCheckDataSource.EventArgs,
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                checkContext,
+                eventArgs.ProjectFile!);
+            _buildCheckManager.ProcessProjectEvaluationStarted(
+                checkContext,
                 eventArgs.ProjectFile!);
         }
     }
 
     private void HandleProjectFinishedRequest(ProjectFinishedEventArgs eventArgs)
         => _buildCheckManager.EndProjectRequest(
-                BuildCheckDataSource.EventArgs,
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs!.ProjectFile!);
 
     private void HandleBuildCheckTracingEvent(BuildCheckTracingEventArgs eventArgs)
@@ -90,27 +113,27 @@ private void HandleBuildCheckTracingEvent(BuildCheckTracingEventArgs eventArgs)
 
     private void HandleTaskStartedEvent(TaskStartedEventArgs eventArgs)
         => _buildCheckManager.ProcessTaskStartedEventArgs(
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs);
 
     private void HandleTaskFinishedEvent(TaskFinishedEventArgs eventArgs)
         => _buildCheckManager.ProcessTaskFinishedEventArgs(
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs);
 
     private void HandleTaskParameterEvent(TaskParameterEventArgs eventArgs)
         => _buildCheckManager.ProcessTaskParameterEventArgs(
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs);
 
     private void HandleBuildCheckAcquisitionEvent(BuildCheckAcquisitionEventArgs eventArgs)
-        => _buildCheckManager.ProcessAnalyzerAcquisition(
-                eventArgs.ToAnalyzerAcquisitionData(),
-                _analyzerContextFactory.CreateAnalysisContext(GetBuildEventContext(eventArgs)));
+        => _buildCheckManager.ProcessCheckAcquisition(
+                eventArgs.ToCheckAcquisitionData(),
+                _checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)));
 
     private void HandleEnvironmentVariableReadEvent(EnvironmentVariableReadEventArgs eventArgs)
         => _buildCheckManager.ProcessEnvironmentVariableReadEventArgs(
-                _analyzerContextFactory.CreateAnalysisContext(GetBuildEventContext(eventArgs)),
+                _checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)),
                 eventArgs);
 
     private bool IsMetaProjFile(string? projectFile) => projectFile?.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase) == true;
@@ -119,15 +142,17 @@ private void HandleEnvironmentVariableReadEvent(EnvironmentVariableReadEventArgs
 
     private void HandleBuildFinishedEvent(BuildFinishedEventArgs eventArgs)
     {
-        _stats.Merge(_buildCheckManager.CreateAnalyzerTracingStats(), (span1, span2) => span1 + span2);
+        _buildCheckManager.ProcessBuildFinished(_checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!));
+
+        _stats.Merge(_buildCheckManager.CreateCheckTracingStats(), (span1, span2) => span1 + span2);
 
-        LogAnalyzerStats(_analyzerContextFactory.CreateAnalysisContext(GetBuildEventContext(eventArgs)));
+        LogCheckStats(_checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)));
     }
 
-    private void LogAnalyzerStats(IAnalysisContext analysisContext)
+    private void LogCheckStats(ICheckContext checkContext)
     {
         Dictionary<string, TimeSpan> infraStats = new Dictionary<string, TimeSpan>();
-        Dictionary<string, TimeSpan> analyzerStats = new Dictionary<string, TimeSpan>();
+        Dictionary<string, TimeSpan> checkStats = new Dictionary<string, TimeSpan>();
 
         foreach (var stat in _stats)
         {
@@ -138,20 +163,20 @@ private void LogAnalyzerStats(IAnalysisContext analysisContext)
             }
             else
             {
-                analyzerStats[stat.Key] = stat.Value;
+                checkStats[stat.Key] = stat.Value;
             }
         }
 
         BuildCheckTracingEventArgs statEvent = new BuildCheckTracingEventArgs(_stats, true)
-        { BuildEventContext = analysisContext.BuildEventContext };
+        { BuildEventContext = checkContext.BuildEventContext };
 
-        analysisContext.DispatchBuildEvent(statEvent);
+        checkContext.DispatchBuildEvent(statEvent);
 
-        analysisContext.DispatchAsCommentFromText(MessageImportance.Low, $"BuildCheck run times{Environment.NewLine}");
+        checkContext.DispatchAsCommentFromText(MessageImportance.Low, $"BuildCheck run times{Environment.NewLine}");
         string infraData = BuildCsvString("Infrastructure run times", infraStats);
-        analysisContext.DispatchAsCommentFromText(MessageImportance.Low, infraData);
-        string analyzerData = BuildCsvString("Analyzer run times", analyzerStats);
-        analysisContext.DispatchAsCommentFromText(MessageImportance.Low, analyzerData);
+        checkContext.DispatchAsCommentFromText(MessageImportance.Low, infraData);
+        string checkData = BuildCsvString("Checks run times", checkStats);
+        checkContext.DispatchAsCommentFromText(MessageImportance.Low, checkData);
     }
 
     private string BuildCsvString(string title, Dictionary<string, TimeSpan> rowData)
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index 36419acdf49..310dc29b0f6 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -4,39 +4,43 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Threading.Tasks;
-using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.BuildCheck.Infrastructure;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
-/// A manager of the runs of the analyzers - deciding based on configuration of what to run and what to postfilter.
+/// A manager of the runs of the checks - deciding based on configuration of what to run and what to postfilter.
 /// </summary>
 internal sealed class BuildCheckCentralContext
 {
-    private readonly ConfigurationProvider _configurationProvider;
+    private readonly IConfigurationProvider _configurationProvider;
 
-    internal BuildCheckCentralContext(ConfigurationProvider configurationProvider)
+    internal BuildCheckCentralContext(IConfigurationProvider configurationProvider)
         => _configurationProvider = configurationProvider;
 
     private record CallbackRegistry(
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>>)> EvaluatedPropertiesActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<ParsedItemsAnalysisData>>)> ParsedItemsActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<TaskInvocationAnalysisData>>)> TaskInvocationActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<PropertyReadData>>)> PropertyReadActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<PropertyWriteData>>)> PropertyWriteActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<ProjectProcessingDoneData>>)> ProjectProcessingDoneActions)
+        List<(CheckWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>>)> EvaluatedPropertiesActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<ParsedItemsCheckData>>)> ParsedItemsActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<TaskInvocationCheckData>>)> TaskInvocationActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<PropertyReadData>>)> PropertyReadActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<PropertyWriteData>>)> PropertyWriteActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<ProjectRequestProcessingDoneData>>)> ProjectRequestProcessingDoneActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<BuildFinishedCheckData>>)> BuildFinishedActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<EnvironmentVariableCheckData>>)> EnvironmentVariableCheckDataActions)
     {
-        public CallbackRegistry() : this([], [], [], [], [], []) { }
+        public CallbackRegistry()
+            : this([], [], [], [], [], [], [], [])
+        {
+        }
 
-        internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
+        internal void DeregisterCheck(CheckWrapper check)
         {
-            EvaluatedPropertiesActions.RemoveAll(a => a.Item1 == analyzer);
-            ParsedItemsActions.RemoveAll(a => a.Item1 == analyzer);
-            PropertyReadActions.RemoveAll(a => a.Item1 == analyzer);
-            PropertyWriteActions.RemoveAll(a => a.Item1 == analyzer);
-            ProjectProcessingDoneActions.RemoveAll(a => a.Item1 == analyzer);
+            EvaluatedPropertiesActions.RemoveAll(a => a.Item1 == check);
+            ParsedItemsActions.RemoveAll(a => a.Item1 == check);
+            PropertyReadActions.RemoveAll(a => a.Item1 == check);
+            PropertyWriteActions.RemoveAll(a => a.Item1 == check);
+            ProjectRequestProcessingDoneActions.RemoveAll(a => a.Item1 == check);
+            BuildFinishedActions.RemoveAll(a => a.Item1 == check);
         }
     }
 
@@ -44,122 +48,142 @@ internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
     private readonly CallbackRegistry _globalCallbacks = new();
 
     // This we can potentially use to subscribe for receiving evaluated props in the
-    //  build event args. However - this needs to be done early on, when analyzers might not be known yet
+    //  build event args. However - this needs to be done early on, when checks might not be known yet
     internal bool HasEvaluatedPropertiesActions => _globalCallbacks.EvaluatedPropertiesActions.Count > 0;
 
     internal bool HasParsedItemsActions => _globalCallbacks.ParsedItemsActions.Count > 0;
 
     internal bool HasTaskInvocationActions => _globalCallbacks.TaskInvocationActions.Count > 0;
+
     internal bool HasPropertyReadActions => _globalCallbacks.PropertyReadActions.Count > 0;
+
     internal bool HasPropertyWriteActions => _globalCallbacks.PropertyWriteActions.Count > 0;
+    internal bool HasBuildFinishedActions => _globalCallbacks.BuildFinishedActions.Count > 0;
+
+    internal void RegisterEnvironmentVariableReadAction(CheckWrapper check, Action<BuildCheckDataContext<EnvironmentVariableCheckData>> environmentVariableAction)
+       => RegisterAction(check, environmentVariableAction, _globalCallbacks.EnvironmentVariableCheckDataActions);
 
-    internal void RegisterEvaluatedPropertiesAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction)
+    internal void RegisterEvaluatedPropertiesAction(CheckWrapper check, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction)
         // Here we might want to communicate to node that props need to be sent.
         //  (it was being communicated via MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION)
-        => RegisterAction(analyzer, evaluatedPropertiesAction, _globalCallbacks.EvaluatedPropertiesActions);
+        => RegisterAction(check, evaluatedPropertiesAction, _globalCallbacks.EvaluatedPropertiesActions);
+
+    internal void RegisterParsedItemsAction(CheckWrapper check, Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction)
+        => RegisterAction(check, parsedItemsAction, _globalCallbacks.ParsedItemsActions);
 
-    internal void RegisterParsedItemsAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction)
-        => RegisterAction(analyzer, parsedItemsAction, _globalCallbacks.ParsedItemsActions);
+    internal void RegisterTaskInvocationAction(CheckWrapper check, Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction)
+        => RegisterAction(check, taskInvocationAction, _globalCallbacks.TaskInvocationActions);
 
-    internal void RegisterTaskInvocationAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
-        => RegisterAction(analyzer, taskInvocationAction, _globalCallbacks.TaskInvocationActions);
+    internal void RegisterPropertyReadAction(CheckWrapper check, Action<BuildCheckDataContext<PropertyReadData>> propertyReadAction)
+        => RegisterAction(check, propertyReadAction, _globalCallbacks.PropertyReadActions);
 
-    internal void RegisterPropertyReadAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<PropertyReadData>> propertyReadAction)
-        => RegisterAction(analyzer, propertyReadAction, _globalCallbacks.PropertyReadActions);
+    internal void RegisterPropertyWriteAction(CheckWrapper check, Action<BuildCheckDataContext<PropertyWriteData>> propertyWriteAction)
+        => RegisterAction(check, propertyWriteAction, _globalCallbacks.PropertyWriteActions);
 
-    internal void RegisterPropertyWriteAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<PropertyWriteData>> propertyWriteAction)
-        => RegisterAction(analyzer, propertyWriteAction, _globalCallbacks.PropertyWriteActions);
+    internal void RegisterProjectRequestProcessingDoneAction(CheckWrapper check, Action<BuildCheckDataContext<ProjectRequestProcessingDoneData>> projectDoneAction)
+        => RegisterAction(check, projectDoneAction, _globalCallbacks.ProjectRequestProcessingDoneActions);
 
-    internal void RegisterProjectProcessingDoneAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<ProjectProcessingDoneData>> projectDoneAction)
-        => RegisterAction(analyzer, projectDoneAction, _globalCallbacks.ProjectProcessingDoneActions);
+    internal void RegisterBuildFinishedAction(CheckWrapper check, Action<BuildCheckDataContext<BuildFinishedCheckData>> buildFinishedAction)
+        => RegisterAction(check, buildFinishedAction, _globalCallbacks.BuildFinishedActions);
 
     private void RegisterAction<T>(
-        BuildAnalyzerWrapper wrappedAnalyzer,
+        CheckWrapper wrappedCheck,
         Action<BuildCheckDataContext<T>> handler,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<T>>)> handlersRegistry)
-        where T : AnalysisData
+        List<(CheckWrapper, Action<BuildCheckDataContext<T>>)> handlersRegistry)
+        where T : CheckData
     {
         void WrappedHandler(BuildCheckDataContext<T> context)
         {
-            using var _ = wrappedAnalyzer.StartSpan();
+            using var _ = wrappedCheck.StartSpan();
             handler(context);
         }
 
         lock (handlersRegistry)
         {
-            handlersRegistry.Add((wrappedAnalyzer, WrappedHandler));
+            handlersRegistry.Add((wrappedCheck, WrappedHandler));
         }
     }
 
-    internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
-    {
-        _globalCallbacks.DeregisterAnalyzer(analyzer);
-    }
+    internal void DeregisterCheck(CheckWrapper check) => _globalCallbacks.DeregisterCheck(check);
+
+    internal void RunEnvironmentVariableActions(
+        EnvironmentVariableCheckData environmentVariableCheckData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
+            resultHandler)
+        => RunRegisteredActions(_globalCallbacks.EnvironmentVariableCheckDataActions, environmentVariableCheckData, checkContext, resultHandler);
 
     internal void RunEvaluatedPropertiesActions(
-        EvaluatedPropertiesAnalysisData evaluatedPropertiesAnalysisData,
-        IAnalysisContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        EvaluatedPropertiesCheckData evaluatedPropertiesCheckData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
-        => RunRegisteredActions(_globalCallbacks.EvaluatedPropertiesActions, evaluatedPropertiesAnalysisData,
-            analysisContext, resultHandler);
+        => RunRegisteredActions(_globalCallbacks.EvaluatedPropertiesActions, evaluatedPropertiesCheckData, checkContext, resultHandler);
 
     internal void RunParsedItemsActions(
-        ParsedItemsAnalysisData parsedItemsAnalysisData,
-        IAnalysisContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        ParsedItemsCheckData parsedItemsCheckData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
-        => RunRegisteredActions(_globalCallbacks.ParsedItemsActions, parsedItemsAnalysisData,
-            analysisContext, resultHandler);
+        => RunRegisteredActions(_globalCallbacks.ParsedItemsActions, parsedItemsCheckData,
+            checkContext, resultHandler);
 
     internal void RunTaskInvocationActions(
-        TaskInvocationAnalysisData taskInvocationAnalysisData,
-        IAnalysisContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        TaskInvocationCheckData taskInvocationCheckData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
-        => RunRegisteredActions(_globalCallbacks.TaskInvocationActions, taskInvocationAnalysisData,
-            analysisContext, resultHandler);
+        => RunRegisteredActions(_globalCallbacks.TaskInvocationActions, taskInvocationCheckData,
+            checkContext, resultHandler);
 
     internal void RunPropertyReadActions(
         PropertyReadData propertyReadDataData,
-        AnalysisLoggingContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        CheckLoggingContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.PropertyReadActions, propertyReadDataData,
-            analysisContext, resultHandler);
+            checkContext, resultHandler);
 
     internal void RunPropertyWriteActions(
         PropertyWriteData propertyWriteData,
-        AnalysisLoggingContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        CheckLoggingContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.PropertyWriteActions, propertyWriteData,
-            analysisContext, resultHandler);
+            checkContext, resultHandler);
 
     internal void RunProjectProcessingDoneActions(
-        ProjectProcessingDoneData projectProcessingDoneData,
-        IAnalysisContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        ProjectRequestProcessingDoneData projectProcessingDoneData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
+            resultHandler)
+        => RunRegisteredActions(_globalCallbacks.ProjectRequestProcessingDoneActions, projectProcessingDoneData,
+            checkContext, resultHandler);
+
+    internal void RunBuildFinishedActions(
+        BuildFinishedCheckData buildFinishedCheckData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
-        => RunRegisteredActions(_globalCallbacks.ProjectProcessingDoneActions, projectProcessingDoneData,
-            analysisContext, resultHandler);
+        => RunRegisteredActions(_globalCallbacks.BuildFinishedActions, buildFinishedCheckData,
+            checkContext, resultHandler);
 
     private void RunRegisteredActions<T>(
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
-        T analysisData,
-        IAnalysisContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult> resultHandler)
-    where T : AnalysisData
+        List<(CheckWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
+        T checkData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult> resultHandler)
+    where T : CheckData
     {
-        string projectFullPath = analysisData.ProjectFilePath;
+        string projectFullPath = checkData.ProjectFilePath;
 
-        foreach (var analyzerCallback in registeredCallbacks)
+        foreach (var checkCallback in registeredCallbacks)
         {
             // Tracing - https://github.com/dotnet/msbuild/issues/9629 - we might want to account this entire block
-            //  to the relevant analyzer (with BuildAnalyzerConfigurationEffectiveonly the currently accounted part as being the 'core-execution' subspan)
+            //  to the relevant check (with BuildCheckConfigurationEffective only the currently accounted part as being the 'core-execution' subspan)
 
-            BuildAnalyzerConfigurationEffective? commonConfig = analyzerCallback.Item1.CommonConfig;
-            BuildAnalyzerConfigurationEffective[] configPerRule;
+            CheckConfigurationEffective? commonConfig = checkCallback.Item1.CommonConfig;
+            CheckConfigurationEffective[] configPerRule;
 
             if (commonConfig != null)
             {
@@ -172,27 +196,25 @@ private void RunRegisteredActions<T>(
             }
             else
             {
-                configPerRule =
-                    _configurationProvider.GetMergedConfigurations(projectFullPath,
-                        analyzerCallback.Item1.BuildAnalyzer);
+                configPerRule = _configurationProvider.GetMergedConfigurations(projectFullPath, checkCallback.Item1.Check);
                 if (configPerRule.All(c => !c.IsEnabled))
                 {
                     return;
                 }
             }
 
-            // Here we might want to check the configPerRule[0].EvaluationAnalysisScope - if the input data supports that
+            // Here we might want to check the configPerRule[0].EvaluationsCheckScope - if the input data supports that
             // The decision and implementation depends on the outcome of the investigation tracked in:
             // https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57851137
 
             BuildCheckDataContext<T> context = new BuildCheckDataContext<T>(
-                analyzerCallback.Item1,
-                analysisContext,
+                checkCallback.Item1,
+                checkContext,
                 configPerRule,
                 resultHandler,
-                analysisData);
+                checkData);
 
-            analyzerCallback.Item2(context);
+            checkCallback.Item2(context);
         }
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
index 69f3335681d..98c04bb78f5 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
@@ -13,7 +13,7 @@ internal sealed class BuildCheckConfigurationException : Exception
 {
     /// <summary>
     /// Exception to communicate issues with user specified configuration - unsupported scenarios, malformations, etc.
-    /// This exception usually leads to defuncting the particular analyzer for the rest of the build (even if issue occured with a single project).
+    /// This exception usually leads to defuncting the particular check for the rest of the build (even if issue occured with a single project).
     /// </summary>
     internal BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope;
 
@@ -26,4 +26,7 @@ public BuildCheckConfigurationException(string message, BuildCheckConfigurationE
     {
         this.buildCheckConfigurationErrorScope = buildCheckConfigurationErrorScope;
     }
+
+    public BuildCheckConfigurationException(string message, Exception innerException) : base(message, innerException)
+    { }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index 1e1964748af..7e581e2979d 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 /// <summary>
 /// Central logger for the build check infrastructure.
 /// Receives events from the <see cref="BuildCheckForwardingLogger"/>.
-/// Processes the events and forwards them to the <see cref="IBuildCheckManager"/> and registered analyzers.
+/// Processes the events and forwards them to the <see cref="IBuildCheckManager"/> and registered checks.
 /// </summary>
 /// <remarks>
 /// Ensure that the consuming events are in sync with <see cref="BuildCheckForwardingLogger"/>.
@@ -24,15 +24,15 @@ internal sealed class BuildCheckConnectorLogger : ILogger
 {
     private readonly BuildCheckBuildEventHandler _eventHandler;
     private readonly IBuildCheckManager _buildCheckManager;
-    private readonly IAnalysisContextFactory _analysisContextFactory;
+    private readonly ICheckContextFactory _checkContextFactory;
 
     internal BuildCheckConnectorLogger(
-        IAnalysisContextFactory analyzerContextFactory,
+        ICheckContextFactory checkContextFactory,
         IBuildCheckManager buildCheckManager)
     {
         _buildCheckManager = buildCheckManager;
-        _analysisContextFactory = analyzerContextFactory;
-        _eventHandler = new BuildCheckBuildEventHandler(analyzerContextFactory, buildCheckManager);
+        _checkContextFactory = checkContextFactory;
+        _eventHandler = new BuildCheckBuildEventHandler(checkContextFactory, buildCheckManager);
     }
 
     public LoggerVerbosity Verbosity { get; set; }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
deleted file mode 100644
index 76ac5ec7767..00000000000
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
+++ /dev/null
@@ -1,26 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Threading;
-using Microsoft.Build.Experimental.BuildCheck;
-
-namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-
-internal sealed class BuildCheckRegistrationContext(BuildAnalyzerWrapper analyzerWrapper, BuildCheckCentralContext buildCheckCentralContext) : IBuildCheckRegistrationContext
-{
-    public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction)
-    {
-        buildCheckCentralContext.RegisterEvaluatedPropertiesAction(analyzerWrapper, evaluatedPropertiesAction);
-    }
-
-    public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction)
-    {
-        buildCheckCentralContext.RegisterParsedItemsAction(analyzerWrapper, parsedItemsAction);
-    }
-
-    public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
-    {
-        buildCheckCentralContext.RegisterTaskInvocationAction(analyzerWrapper, taskInvocationAction);
-    }
-}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
index 02808f434a5..491fe92d700 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 /// <summary>
 /// Forwarding logger for the build check infrastructure.
 /// For now we just want to forward all events that are needed for BuildCheckConnectorLogger and filter out all other.
-/// If the custom analyzer is detected, starts to unconditionally forward all events.
+/// If the custom check is detected, starts to unconditionally forward all events.
 /// In the future we may need more specific behavior.
 /// </summary>
 /// <remarks>
@@ -38,6 +38,7 @@ internal class BuildCheckForwardingLogger : IForwardingLogger
     private HashSet<Type> _eventsToForward = new HashSet<Type>
     {
         typeof(EnvironmentVariableReadEventArgs),
+        typeof(BuildSubmissionStartedEventArgs),
         typeof(ProjectEvaluationFinishedEventArgs),
         typeof(ProjectEvaluationStartedEventArgs),
         typeof(ProjectStartedEventArgs),
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 3e8d53982c5..c152982551d 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -9,17 +9,17 @@
 using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck.Acquisition;
-using Microsoft.Build.Experimental.BuildCheck.Analyzers;
+using Microsoft.Build.Experimental.BuildCheck.Checks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Evaluation;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-internal delegate BuildAnalyzer BuildAnalyzerFactory();
-internal delegate BuildAnalyzerWrapper BuildAnalyzerWrapperFactory(ConfigurationContext configurationContext);
+internal delegate Check CheckFactory();
+internal delegate CheckWrapper CheckWrapperFactory(ConfigurationContext configurationContext);
 
 /// <summary>
 /// The central manager for the BuildCheck - this is the integration point with MSBuild infrastructure.
@@ -33,6 +33,7 @@ internal sealed class BuildCheckManagerProvider : IBuildCheckManagerProvider
     public IBuildCheckManager Instance => GlobalInstance;
 
     public IBuildEngineDataRouter BuildEngineDataRouter => (IBuildEngineDataRouter)GlobalInstance;
+
     public static IBuildEngineDataRouter? GlobalBuildEngineDataRouter => (IBuildEngineDataRouter?)s_globalInstance;
 
     internal static IBuildComponent CreateComponent(BuildComponentType type)
@@ -68,16 +69,16 @@ public void InitializeComponent(IBuildComponentHost host)
     internal sealed class BuildCheckManager : IBuildCheckManager, IBuildEngineDataRouter
     {
         private readonly TracingReporter _tracingReporter = new TracingReporter();
-        private readonly ConfigurationProvider _configurationProvider = new ConfigurationProvider();
+        private readonly IConfigurationProvider _configurationProvider = new ConfigurationProvider();
         private readonly BuildCheckCentralContext _buildCheckCentralContext;
-        private readonly List<BuildAnalyzerFactoryContext> _analyzersRegistry;
+        private readonly List<CheckFactoryContext> _checkRegistry;
         private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
         private readonly BuildEventsProcessor _buildEventsProcessor;
         private readonly IBuildCheckAcquisitionModule _acquisitionModule;
 
         internal BuildCheckManager()
         {
-            _analyzersRegistry = new List<BuildAnalyzerFactoryContext>();
+            _checkRegistry = new List<CheckFactoryContext>();
             _acquisitionModule = new BuildCheckAcquisitionModule();
             _buildCheckCentralContext = new(_configurationProvider);
             _buildEventsProcessor = new(_buildCheckCentralContext);
@@ -88,7 +89,7 @@ internal BuildCheckManager()
 
         /// <summary>
         /// Notifies the manager that the data source will be used -
-        ///   so it should register the built-in analyzers for the source if it hasn't been done yet.
+        ///   so it should register the built-in checks for the source if it hasn't been done yet.
         /// </summary>
         /// <param name="buildCheckDataSource"></param>
         public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
@@ -97,35 +98,35 @@ public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
             if (!_enabledDataSources[(int)buildCheckDataSource])
             {
                 _enabledDataSources[(int)buildCheckDataSource] = true;
-                RegisterBuiltInAnalyzers(buildCheckDataSource);
-            }
+                RegisterBuiltInChecks(buildCheckDataSource);
+            } 
             stopwatch.Stop();
             _tracingReporter.AddSetDataSourceStats(stopwatch.Elapsed);
         }
 
-        public void ProcessAnalyzerAcquisition(
-            AnalyzerAcquisitionData acquisitionData,
-            IAnalysisContext analysisContext)
+        public void ProcessCheckAcquisition(
+            CheckAcquisitionData acquisitionData,
+            ICheckContext checkContext)
         {
             Stopwatch stopwatch = Stopwatch.StartNew();
             if (IsInProcNode)
             {
-                var analyzersFactories = _acquisitionModule.CreateBuildAnalyzerFactories(acquisitionData, analysisContext);
-                if (analyzersFactories.Count != 0)
+                var checksFactories = _acquisitionModule.CreateCheckFactories(acquisitionData, checkContext);
+                if (checksFactories.Count != 0)
                 {
-                    RegisterCustomAnalyzer(BuildCheckDataSource.EventArgs, analyzersFactories, analysisContext);
+                    RegisterCustomCheck(acquisitionData.ProjectPath, BuildCheckDataSource.EventArgs, checksFactories, checkContext);
                 }
                 else
                 {
-                    analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerFailedAcquisition", acquisitionData.AssemblyPath);
+                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedAcquisition", acquisitionData.AssemblyPath);
                 }
             }
             else
             {
                 BuildCheckAcquisitionEventArgs eventArgs = acquisitionData.ToBuildEventArgs();
-                eventArgs.BuildEventContext = analysisContext.BuildEventContext!;
+                eventArgs.BuildEventContext = checkContext.BuildEventContext!;
 
-                analysisContext.DispatchBuildEvent(eventArgs);
+                checkContext.DispatchBuildEvent(eventArgs);
             }
 
             stopwatch.Stop();
@@ -134,200 +135,183 @@ public void ProcessAnalyzerAcquisition(
 
         private static T Construct<T>() where T : new() => new();
 
-        private static readonly (string[] ruleIds, bool defaultEnablement, BuildAnalyzerFactory factory)[][] s_builtInFactoriesPerDataSource =
+        private static readonly (string[] ruleIds, bool defaultEnablement, CheckFactory factory)[][] s_builtInFactoriesPerDataSource =
         [
+
             // BuildCheckDataSource.EventArgs
             [
-                ([SharedOutputPathAnalyzer.SupportedRule.Id], SharedOutputPathAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathAnalyzer>),
-                ([DoubleWritesAnalyzer.SupportedRule.Id], DoubleWritesAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<DoubleWritesAnalyzer>),
-                ([NoEnvironmentVariablePropertyAnalyzer.SupportedRule.Id], NoEnvironmentVariablePropertyAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<NoEnvironmentVariablePropertyAnalyzer>)
+                ([SharedOutputPathCheck.SupportedRule.Id], SharedOutputPathCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathCheck>),
+                ([DoubleWritesCheck.SupportedRule.Id], DoubleWritesCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<DoubleWritesCheck>),
+                ([NoEnvironmentVariablePropertyCheck.SupportedRule.Id], NoEnvironmentVariablePropertyCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<NoEnvironmentVariablePropertyCheck>)
             ],
+
             // BuildCheckDataSource.Execution
-            []
+            [
+                (PropertiesUsageCheck.SupportedRulesList.Select(r => r.Id).ToArray(),
+                    PropertiesUsageCheck.SupportedRulesList.Any(r => r.DefaultConfiguration.IsEnabled ?? false),
+                    Construct<PropertiesUsageCheck>)
+            ]
         ];
 
         /// <summary>
-        /// For tests only. TODO: Remove when analyzer acquisition is done.
+        /// For tests only. TODO: Remove when check acquisition is done.
         /// </summary>
-        internal static (string[] ruleIds, bool defaultEnablement, BuildAnalyzerFactory factory)[][]? s_testFactoriesPerDataSource;
+        internal static (string[] ruleIds, bool defaultEnablement, CheckFactory factory)[][]? s_testFactoriesPerDataSource;
 
-        private void RegisterBuiltInAnalyzers(BuildCheckDataSource buildCheckDataSource)
+        private void RegisterBuiltInChecks(BuildCheckDataSource buildCheckDataSource)
         {
-            _analyzersRegistry.AddRange(
+            _checkRegistry.AddRange(
                 s_builtInFactoriesPerDataSource[(int)buildCheckDataSource]
-                    .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
+                    .Select(v => new CheckFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
 
             if (s_testFactoriesPerDataSource is not null)
             {
-                _analyzersRegistry.AddRange(
+                _checkRegistry.AddRange(
                     s_testFactoriesPerDataSource[(int)buildCheckDataSource]
-                        .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
-            }
-        }
-
-        /// <summary>
-        /// To be used by acquisition module.
-        /// Registers the custom analyzers, the construction of analyzers is deferred until the first using project is encountered.
-        /// </summary>
-        internal void RegisterCustomAnalyzers(
-            BuildCheckDataSource buildCheckDataSource,
-            IEnumerable<BuildAnalyzerFactory> factories,
-            string[] ruleIds,
-            bool defaultEnablement,
-            IAnalysisContext analysisContext)
-        {
-            if (_enabledDataSources[(int)buildCheckDataSource])
-            {
-                foreach (BuildAnalyzerFactory factory in factories)
-                {
-                    _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(factory, ruleIds, defaultEnablement));
-
-                    var instance = factory();
-                    analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.FriendlyName);
-                }
+                        .Select(v => new CheckFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
             }
         }
 
         /// <summary>
         /// To be used by acquisition module
-        /// Registers the custom analyzer, the construction of analyzer is needed during registration.
+        /// Registers the custom check, the construction of check is needed during registration.
         /// </summary>
+        /// <param name="projectPath">The project path is used for the correct .editorconfig resolution.</param>
         /// <param name="buildCheckDataSource">Represents different data sources used in build check operations.</param>
-        /// <param name="factories">A collection of build analyzer factories for rules instantiation.</param>
-        /// <param name="analysisContext">The logging context of the build event.</param>
-        internal void RegisterCustomAnalyzer(
+        /// <param name="factories">A collection of build check factories for rules instantiation.</param>
+        /// <param name="checkContext">The logging context of the build event.</param>
+        internal void RegisterCustomCheck(
+            string projectPath,
             BuildCheckDataSource buildCheckDataSource,
-            IEnumerable<BuildAnalyzerFactory> factories,
-            IAnalysisContext analysisContext)
+            IEnumerable<CheckFactory> factories,
+            ICheckContext checkContext)
         {
             if (_enabledDataSources[(int)buildCheckDataSource])
             {
                 foreach (var factory in factories)
                 {
                     var instance = factory();
-                    _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(
+                    var checkFactoryContext = new CheckFactoryContext(
                         factory,
                         instance.SupportedRules.Select(r => r.Id).ToArray(),
-                        instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true)));
-                    analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.FriendlyName);
+                        instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true));
+
+                    if (checkFactoryContext != null)
+                    {
+                        _checkRegistry.Add(checkFactoryContext);
+                        SetupSingleCheck(checkFactoryContext, projectPath);
+                        checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckSuccessfulAcquisition", instance.FriendlyName);
+                    }
                 }
             }
         }
 
-        private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryContext, string projectFullPath)
+        private void SetupSingleCheck(CheckFactoryContext checkFactoryContext, string projectFullPath)
         {
-            // For custom analyzers - it should run only on projects where referenced
+            // For custom checks - it should run only on projects where referenced
             // (otherwise error out - https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57849480)
             // on others it should work similarly as disabling them.
-            // Disabled analyzer should not only post-filter results - it shouldn't even see the data 
-            BuildAnalyzerWrapper wrapper;
-            BuildAnalyzerConfigurationEffective[] configurations;
-            if (analyzerFactoryContext.MaterializedAnalyzer == null)
+            // Disabled check should not only post-filter results - it shouldn't even see the data 
+            CheckWrapper wrapper;
+            CheckConfigurationEffective[] configurations;
+            if (checkFactoryContext.MaterializedCheck == null)
             {
-                BuildAnalyzerConfiguration[] userConfigs =
-                    _configurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                CheckConfiguration[] userConfigs =
+                    _configurationProvider.GetUserConfigurations(projectFullPath, checkFactoryContext.RuleIds);
 
-                if (userConfigs.All(c => !(c.IsEnabled ?? analyzerFactoryContext.IsEnabledByDefault)))
+                if (userConfigs.All(c => !(c.IsEnabled ?? checkFactoryContext.IsEnabledByDefault)))
                 {
-                    // the analyzer was not yet instantiated nor mounted - so nothing to do here now.
+                    // the check was not yet instantiated nor mounted - so nothing to do here now.
                     return;
                 }
 
                 CustomConfigurationData[] customConfigData =
-                    _configurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                    _configurationProvider.GetCustomConfigurations(projectFullPath, checkFactoryContext.RuleIds);
 
-                BuildAnalyzer uninitializedAnalyzer = analyzerFactoryContext.Factory();
-                configurations = _configurationProvider.GetMergedConfigurations(userConfigs, uninitializedAnalyzer);
+                Check uninitializedCheck = checkFactoryContext.Factory();
+                configurations = _configurationProvider.GetMergedConfigurations(userConfigs, uninitializedCheck);
 
                 ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData, configurations);
 
-                wrapper = analyzerFactoryContext.Initialize(uninitializedAnalyzer, configurationContext);
-                analyzerFactoryContext.MaterializedAnalyzer = wrapper;
-                BuildAnalyzer analyzer = wrapper.BuildAnalyzer;
+                wrapper = checkFactoryContext.Initialize(uninitializedCheck, configurationContext);
+                checkFactoryContext.MaterializedCheck = wrapper;
+                Check check = wrapper.Check;
 
-                // This is to facilitate possible perf improvement for custom analyzers - as we might want to
+                // This is to facilitate possible perf improvement for custom checks - as we might want to
                 //  avoid loading the assembly and type just to check if it's supported.
                 // If we expose a way to declare the enablement status and rule ids during registration (e.g. via
                 //  optional arguments of the intrinsic property function) - we can then avoid loading it.
                 // But once loaded - we should verify that the declared enablement status and rule ids match the actual ones.
                 if (
-                    analyzer.SupportedRules.Count != analyzerFactoryContext.RuleIds.Length
+                    check.SupportedRules.Count != checkFactoryContext.RuleIds.Length
                     ||
-                    !analyzer.SupportedRules.Select(r => r.Id)
-                        .SequenceEqual(analyzerFactoryContext.RuleIds, StringComparer.CurrentCultureIgnoreCase)
+                    !check.SupportedRules.Select(r => r.Id)
+                        .SequenceEqual(checkFactoryContext.RuleIds, StringComparer.CurrentCultureIgnoreCase)
                 )
                 {
                     throw new BuildCheckConfigurationException(
-                        $"The analyzer '{analyzer.FriendlyName}' exposes rules '{analyzer.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{analyzerFactoryContext.RuleIds.ToCsvString()}'");
+                        $"The check '{check.FriendlyName}' exposes rules '{check.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{checkFactoryContext.RuleIds.ToCsvString()}'");
                 }
 
-                // technically all analyzers rules could be disabled, but that would mean
+                // technically all checks rules could be disabled, but that would mean
                 // that the provided 'IsEnabledByDefault' value wasn't correct - the only
                 // price to be paid in that case is slight performance cost.
 
                 // Create the wrapper and register to central context
                 wrapper.StartNewProject(projectFullPath, configurations);
-                var wrappedContext = new BuildCheckRegistrationContext(wrapper, _buildCheckCentralContext);
-                analyzer.RegisterActions(wrappedContext);
+                var wrappedContext = new CheckRegistrationContext(wrapper, _buildCheckCentralContext);
+                check.RegisterActions(wrappedContext);
             }
             else
             {
-                wrapper = analyzerFactoryContext.MaterializedAnalyzer;
+                wrapper = checkFactoryContext.MaterializedCheck;
 
-                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
+                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.Check);
 
                 _configurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
-                    analyzerFactoryContext.RuleIds[0]);
+                    checkFactoryContext.RuleIds[0]);
 
                 // Update the wrapper
                 wrapper.StartNewProject(projectFullPath, configurations);
             }
-
-            if (configurations.GroupBy(c => c.EvaluationAnalysisScope).Count() > 1)
-            {
-                throw new BuildCheckConfigurationException(
-                    string.Format("All rules for a single analyzer should have the same EvaluationAnalysisScope for a single project (violating rules: [{0}], project: {1})",
-                        analyzerFactoryContext.RuleIds.ToCsvString(),
-                        projectFullPath));
-            }
         }
 
-        private void SetupAnalyzersForNewProject(string projectFullPath, IAnalysisContext analysisContext)
+        private void SetupChecksForNewProject(string projectFullPath, ICheckContext checkContext)
         {
-            // Only add analyzers here
-            // On an execution node - we might remove and dispose the analyzers once project is done
+            // Only add checks here
+            // On an execution node - we might remove and dispose the checks once project is done
 
             // If it's already constructed - just control the custom settings do not differ
             Stopwatch stopwatch = Stopwatch.StartNew();
-            List<BuildAnalyzerFactoryContext> analyzersToRemove = new();
-            foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
+            List<CheckFactoryContext> checksToRemove = new();
+            foreach (CheckFactoryContext checkFactoryContext in _checkRegistry)
             {
                 try
                 {
-                    SetupSingleAnalyzer(analyzerFactoryContext, projectFullPath);
+                    SetupSingleCheck(checkFactoryContext, projectFullPath);
                 }
                 catch (BuildCheckConfigurationException e)
                 {
-                    analysisContext.DispatchAsErrorFromText(
+                    checkContext.DispatchAsErrorFromText(
                         null,
                         null,
                         null,
                         new BuildEventFileInfo(projectFullPath),
                         e.Message);
-                    analyzersToRemove.Add(analyzerFactoryContext);
+                    checksToRemove.Add(checkFactoryContext);
                 }
             }
 
-            analyzersToRemove.ForEach(c =>
+            checksToRemove.ForEach(c =>
             {
-                _analyzersRegistry.Remove(c);
-                analysisContext.DispatchAsCommentFromText(MessageImportance.High, $"Dismounting analyzer '{c.FriendlyName}'");
+                _checkRegistry.Remove(c);
+                checkContext.DispatchAsCommentFromText(MessageImportance.High, $"Dismounting check '{c.FriendlyName}'");
             });
-            foreach (var analyzerToRemove in analyzersToRemove.Select(a => a.MaterializedAnalyzer).Where(a => a != null))
+            foreach (var checkToRemove in checksToRemove.Select(a => a.MaterializedCheck).Where(a => a != null))
             {
-                _buildCheckCentralContext.DeregisterAnalyzer(analyzerToRemove!);
-                _tracingReporter.AddAnalyzerStats(analyzerToRemove!.BuildAnalyzer.FriendlyName, analyzerToRemove.Elapsed);
-                analyzerToRemove.BuildAnalyzer.Dispose();
+                _buildCheckCentralContext.DeregisterCheck(checkToRemove!);
+                _tracingReporter.AddCheckStats(checkToRemove!.Check.FriendlyName, checkToRemove.Elapsed);
+                checkToRemove.Check.Dispose();
             }
 
             stopwatch.Stop();
@@ -335,54 +319,77 @@ private void SetupAnalyzersForNewProject(string projectFullPath, IAnalysisContex
         }
 
         public void ProcessEvaluationFinishedEventArgs(
-            IAnalysisContext analysisContext,
+            ICheckContext checkContext,
             ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
-            => _buildEventsProcessor
-                .ProcessEvaluationFinishedEventArgs(analysisContext, evaluationFinishedEventArgs);
+        {
+            Dictionary<string, string>? propertiesLookup = null;
 
-        public void ProcessEnvironmentVariableReadEventArgs(IAnalysisContext analysisContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
+            // The FileClassifier is normally initialized by executing build requests.
+            // However, if we are running in a main node that has no execution nodes - we need to initialize it here (from events).
+            if (!IsInProcNode)
+            {
+                propertiesLookup =
+                    BuildEventsProcessor.ExtractPropertiesLookup(evaluationFinishedEventArgs);
+                Func<string, string?> getPropertyValue = p =>
+                    propertiesLookup.TryGetValue(p, out string? value) ? value : null;
+
+                FileClassifier.Shared.RegisterFrameworkLocations(getPropertyValue);
+                FileClassifier.Shared.RegisterKnownImmutableLocations(getPropertyValue);
+            }
+
+            _buildEventsProcessor
+                .ProcessEvaluationFinishedEventArgs(checkContext, evaluationFinishedEventArgs, propertiesLookup);
+        }
+
+        public void ProcessEnvironmentVariableReadEventArgs(ICheckContext checkContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
         {
             if (projectEvaluationEventArgs is EnvironmentVariableReadEventArgs evr)
             {
-                _buildEventsProcessor.ProcessEnvironmentVariableReadEventArgs(
-                    evr.EnvironmentVariableName,
-                    evr.Message ?? string.Empty,
-                    evr.File,
-                    evr.LineNumber,
-                    evr.ColumnNumber);
+                if (TryGetProjectFullPath(checkContext.BuildEventContext, out string projectPath))
+                {
+                    _buildEventsProcessor.ProcessEnvironmentVariableReadEventArgs(
+                        checkContext,
+                        projectPath,
+                        evr.EnvironmentVariableName,
+                        evr.Message ?? string.Empty,
+                        ElementLocation.Create(evr.File, evr.LineNumber, evr.ColumnNumber));
+                }
             }
         }
 
         public void ProcessTaskStartedEventArgs(
-            IAnalysisContext analysisContext,
+            ICheckContext checkContext,
             TaskStartedEventArgs taskStartedEventArgs)
             => _buildEventsProcessor
-                .ProcessTaskStartedEventArgs(analysisContext, taskStartedEventArgs);
+                .ProcessTaskStartedEventArgs(checkContext, taskStartedEventArgs);
+
+        public void ProcessBuildFinished(ICheckContext checkContext)
+            => _buildEventsProcessor.ProcessBuildDone(checkContext);
 
         public void ProcessTaskFinishedEventArgs(
-            IAnalysisContext analysisContext,
+            ICheckContext checkContext,
             TaskFinishedEventArgs taskFinishedEventArgs)
             => _buildEventsProcessor
-                .ProcessTaskFinishedEventArgs(analysisContext, taskFinishedEventArgs);
+                .ProcessTaskFinishedEventArgs(checkContext, taskFinishedEventArgs);
 
         public void ProcessTaskParameterEventArgs(
-            IAnalysisContext analysisContext,
+            ICheckContext checkContext,
             TaskParameterEventArgs taskParameterEventArgs)
             => _buildEventsProcessor
-                .ProcessTaskParameterEventArgs(analysisContext, taskParameterEventArgs);
+                .ProcessTaskParameterEventArgs(checkContext, taskParameterEventArgs);
 
-        public Dictionary<string, TimeSpan> CreateAnalyzerTracingStats()
+        public Dictionary<string, TimeSpan> CreateCheckTracingStats()
         {
-            foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
+            foreach (CheckFactoryContext checkFactoryContext in _checkRegistry)
             {
-                if (analyzerFactoryContext.MaterializedAnalyzer != null)
+                if (checkFactoryContext.MaterializedCheck != null)
                 {
-                    _tracingReporter.AddAnalyzerStats(analyzerFactoryContext.FriendlyName, analyzerFactoryContext.MaterializedAnalyzer.Elapsed);
-                    analyzerFactoryContext.MaterializedAnalyzer.ClearStats();
+                    _tracingReporter.AddCheckStats(checkFactoryContext.FriendlyName, checkFactoryContext.MaterializedCheck.Elapsed);
+                    checkFactoryContext.MaterializedCheck.ClearStats();
                 }
             }
 
-            _tracingReporter.AddAnalyzerInfraStats();
+            _tracingReporter.AddCheckInfraStats();
             return _tracingReporter.TracingStats;
         }
 
@@ -394,138 +401,185 @@ public void FinalizeProcessing(LoggingContext loggingContext)
                 return;
             }
 
-            var analyzerEventStats = CreateAnalyzerTracingStats();
+            var checkEventStats = CreateCheckTracingStats();
 
-            BuildCheckTracingEventArgs analyzerEventArg =
-                new(analyzerEventStats) { BuildEventContext = loggingContext.BuildEventContext };
-            loggingContext.LogBuildEvent(analyzerEventArg);
+            BuildCheckTracingEventArgs checkEventArg =
+                new(checkEventStats) { BuildEventContext = loggingContext.BuildEventContext };
+            loggingContext.LogBuildEvent(checkEventArg);
         }
 
-        private readonly ConcurrentDictionary<int, string> _projectsByContextId = new();
+        private readonly ConcurrentDictionary<int, string> _projectsByInstanceId = new();
+        private readonly ConcurrentDictionary<int, string> _projectsByEvaluationId = new();
+
         /// <summary>
         /// This method fetches the project full path from the context id.
         /// This is needed because the full path is needed for configuration and later for fetching configured checks
         ///  (future version might optimize by using the ProjectContextId directly for fetching the checks).
         /// </summary>
         /// <param name="buildEventContext"></param>
+        /// <param name="projectFullPath"></param>
         /// <returns></returns>
-        private string GetProjectFullPath(BuildEventContext buildEventContext)
+        private bool TryGetProjectFullPath(BuildEventContext buildEventContext, out string projectFullPath)
         {
-            const string defaultProjectFullPath = "Unknown_Project";
-
-            if (_projectsByContextId.TryGetValue(buildEventContext.ProjectContextId, out string? projectFullPath))
+            if (buildEventContext.EvaluationId >= 0)
+            {
+                if (_projectsByEvaluationId.TryGetValue(buildEventContext.EvaluationId, out string? val))
+                {
+                    projectFullPath = val;
+                    return true;
+                }
+            }
+            else if (buildEventContext.ProjectInstanceId >= 0)
             {
-                return projectFullPath;
+                if (_projectsByInstanceId.TryGetValue(buildEventContext.ProjectInstanceId, out string? val))
+                {
+                    projectFullPath = val;
+                    return true;
+                }
             }
-            else if (buildEventContext.ProjectContextId == BuildEventContext.InvalidProjectContextId &&
-                     _projectsByContextId.Count == 1)
+            else if (_projectsByInstanceId.Count == 1)
             {
-                // The coalescing is for a rare possibility of a race where other thread removed the item (between the if check and fetch here).
+                projectFullPath = _projectsByInstanceId.FirstOrDefault().Value;
+                // This is for a rare possibility of a race where other thread removed the item (between the if check and fetch here).
                 // We currently do not support multiple projects in parallel in a single node anyway.
-                return _projectsByContextId.FirstOrDefault().Value ?? defaultProjectFullPath;
+                if (!string.IsNullOrEmpty(projectFullPath))
+                {
+                    return true;
+                }
+            }
+            else if (_projectsByEvaluationId.Count == 1)
+            {
+                projectFullPath = _projectsByEvaluationId.FirstOrDefault().Value;
+                if (!string.IsNullOrEmpty(projectFullPath))
+                {
+                    return true;
+                }
             }
 
-            return defaultProjectFullPath;
+            projectFullPath = string.Empty;
+            return false;
         }
 
-        public void StartProjectEvaluation(
+        public void ProjectFirstEncountered(
             BuildCheckDataSource buildCheckDataSource,
-            IAnalysisContext analysisContext,
+            ICheckContext checkContext,
             string projectFullPath)
         {
             if (buildCheckDataSource == BuildCheckDataSource.EventArgs && IsInProcNode)
             {
                 // Skipping this event - as it was already handled by the in-proc node.
-                // This is because in-proc node has the BuildEventArgs source and BuildExecution source
+                // This is because in-proc node has the BuildEventArgs source and check source
                 //  both in a single manager. The project started is first encountered by the execution before the EventArg is sent
                 return;
             }
 
-            SetupAnalyzersForNewProject(projectFullPath, analysisContext);
-            _projectsByContextId[analysisContext.BuildEventContext.ProjectContextId] = projectFullPath;
+            SetupChecksForNewProject(projectFullPath, checkContext);
+        }
+
+        public void ProcessProjectEvaluationStarted(
+            ICheckContext checkContext,
+            string projectFullPath)
+        {
+            _projectsByEvaluationId[checkContext.BuildEventContext.EvaluationId] = projectFullPath;
         }
 
         /*
          *
-         * Following methods are for future use (should we decide to approach in-execution analysis)
+         * Following methods are for future use (should we decide to approach in-execution check)
          *
          */
 
 
-        public void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+        public void EndProjectEvaluation(BuildEventContext buildEventContext)
         {
         }
 
-        public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext, string projectFullPath)
+        public void StartProjectRequest(BuildEventContext buildEventContext, string projectFullPath)
         {
             // There can be multiple ProjectStarted-ProjectFinished per single configuration project build (each request for different target)
-            _projectsByContextId[buildEventContext.ProjectContextId] = projectFullPath;
+            _projectsByInstanceId[buildEventContext.ProjectInstanceId] = projectFullPath;
         }
 
         public void EndProjectRequest(
-            BuildCheckDataSource buildCheckDataSource,
-            IAnalysisContext analysisContext,
+            ICheckContext checkContext,
             string projectFullPath)
         {
-            _buildEventsProcessor.ProcessProjectDone(analysisContext, projectFullPath);
-            _projectsByContextId.TryRemove(analysisContext.BuildEventContext.ProjectContextId, out _);
+            _buildEventsProcessor.ProcessProjectDone(checkContext, projectFullPath);
         }
 
-        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)
+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext checkContext)
         {
             if (!_buildCheckCentralContext.HasPropertyReadActions)
             {
                 return;
             }
 
-            PropertyReadData propertyReadData = new(
-                GetProjectFullPath(analysisContext.BuildEventContext),
-                analysisContext.BuildEventContext.ProjectInstanceId,
-                propertyReadInfo);
-            _buildEventsProcessor.ProcessPropertyRead(propertyReadData, analysisContext);
+            if (TryGetProjectFullPath(checkContext.BuildEventContext, out string projectFullPath))
+            {
+                PropertyReadData propertyReadData = new(
+                    projectFullPath,
+                    checkContext.BuildEventContext.ProjectInstanceId,
+                    propertyReadInfo);
+                _buildEventsProcessor.ProcessPropertyRead(propertyReadData, checkContext);
+            }
         }
 
-        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext analysisContext)
+        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext checkContext)
         {
             if (!_buildCheckCentralContext.HasPropertyWriteActions)
             {
                 return;
             }
 
-            PropertyWriteData propertyWriteData = new(
-                GetProjectFullPath(analysisContext.BuildEventContext),
-                analysisContext.BuildEventContext.ProjectInstanceId,
-                propertyWriteInfo);
-            _buildEventsProcessor.ProcessPropertyWrite(propertyWriteData, analysisContext);
+            if (TryGetProjectFullPath(checkContext.BuildEventContext, out string projectFullPath))
+            {
+                PropertyWriteData propertyWriteData = new(
+                    projectFullPath,
+                    checkContext.BuildEventContext.ProjectInstanceId,
+                    propertyWriteInfo);
+                _buildEventsProcessor.ProcessPropertyWrite(propertyWriteData, checkContext);
+            }
         }
 
         public void Shutdown()
         { /* Too late here for any communication to the main node or for logging anything */ }
 
-        private class BuildAnalyzerFactoryContext(
-            BuildAnalyzerFactory factory,
+        private class CheckFactoryContext(
+            CheckFactory factory,
             string[] ruleIds,
             bool isEnabledByDefault)
         {
-            public BuildAnalyzer Factory()
+            public Check Factory()
             {
-                BuildAnalyzer ba = factory();
+                Check ba = factory();
                 return ba;
             }
 
-            public BuildAnalyzerWrapper Initialize(BuildAnalyzer ba, ConfigurationContext configContext)
+            public CheckWrapper Initialize(Check ba, ConfigurationContext configContext)
             {
-                ba.Initialize(configContext);
-                return new BuildAnalyzerWrapper(ba);
+                try
+                {
+                    ba.Initialize(configContext);
+                }
+                catch (BuildCheckConfigurationException)
+                {
+                    throw;
+                }
+                catch (Exception e)
+                {
+                    throw new BuildCheckConfigurationException(
+                        $"The Check '{ba.FriendlyName}' failed to initialize: {e.Message}", e);
+                }
+                return new CheckWrapper(ba);
             }
 
-            public BuildAnalyzerWrapper? MaterializedAnalyzer { get; set; }
+            public CheckWrapper? MaterializedCheck { get; set; }
 
             public string[] RuleIds { get; init; } = ruleIds;
 
             public bool IsEnabledByDefault { get; init; } = isEnabledByDefault;
 
-            public string FriendlyName => MaterializedAnalyzer?.BuildAnalyzer.FriendlyName ?? factory().FriendlyName;
+            public string FriendlyName => MaterializedCheck?.Check.FriendlyName ?? factory().FriendlyName;
         }
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckReplayModeConnector.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckReplayModeConnector.cs
index 9405818dc9f..515b050a8cc 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckReplayModeConnector.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckReplayModeConnector.cs
@@ -43,7 +43,7 @@ public static IEventSource GetMergedEventSource(
 
         // Create BuildCheckBuildEventHandler that passes new events to the mergedEventSource
         var buildCheckEventHandler = new BuildCheckBuildEventHandler(
-            new AnalysisDispatchingContextFactory(mergedEventSource),
+            new CheckDispatchingContextFactory(mergedEventSource),
             buildCheckManagerProvider.Instance);
 
         // Pass the events from replayEventSource to the BuildCheckBuildEventHandler to produce new events
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
index 05134a3c8c1..f2925ff1556 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -17,13 +17,13 @@ internal class BuildEventsProcessor(BuildCheckCentralContext buildCheckCentralCo
     /// Represents a task currently being executed.
     /// </summary>
     /// <remarks>
-    /// <see cref="TaskParameters"/> is stored in its own field typed as a mutable dictionary because <see cref="AnalysisData"/>
+    /// <see cref="TaskParameters"/> is stored in its own field typed as a mutable dictionary because <see cref="CheckData"/>
     /// is immutable.
     /// </remarks>
     private struct ExecutingTaskData
     {
-        public TaskInvocationAnalysisData AnalysisData;
-        public Dictionary<string, TaskInvocationAnalysisData.TaskParameter> TaskParameters;
+        public TaskInvocationCheckData CheckData;
+        public Dictionary<string, TaskInvocationCheckData.TaskParameter> TaskParameters;
     }
 
     /// <summary>
@@ -38,29 +38,38 @@ public TaskKey(BuildEventContext context)
 
     private readonly SimpleProjectRootElementCache _cache = new SimpleProjectRootElementCache();
     private readonly BuildCheckCentralContext _buildCheckCentralContext = buildCheckCentralContext;
-    private Dictionary<string, (string EnvVarValue, string File, int Line, int Column)> _evaluatedEnvironmentVariables = new Dictionary<string, (string EnvVarValue, string File, int Line, int Column)>();
 
     /// <summary>
     /// Keeps track of in-flight tasks. Keyed by task ID as passed in <see cref="BuildEventContext.TaskId"/>.
     /// </summary>
     private readonly Dictionary<TaskKey, ExecutingTaskData> _tasksBeingExecuted = [];
 
-    // This requires MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION set to 1
-    internal void ProcessEvaluationFinishedEventArgs(
-        IAnalysisContext analysisContext,
-        ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
+    internal static Dictionary<string, string> ExtractPropertiesLookup(ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
     {
         Dictionary<string, string> propertiesLookup = new Dictionary<string, string>();
         Internal.Utilities.EnumerateProperties(evaluationFinishedEventArgs.Properties, propertiesLookup,
             static (dict, kvp) => dict.Add(kvp.Key, kvp.Value));
 
-        EvaluatedPropertiesAnalysisData analysisData =
-            new(evaluationFinishedEventArgs.ProjectFile!,
-                evaluationFinishedEventArgs.BuildEventContext?.ProjectInstanceId,
-                propertiesLookup,
-                _evaluatedEnvironmentVariables);
+        return propertiesLookup;
+    }
+
+    // This requires MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION set to 1
+    internal void ProcessEvaluationFinishedEventArgs(
+        ICheckContext checkContext,
+        ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs,
+        Dictionary<string, string>? propertiesLookup)
+    {
+        if (_buildCheckCentralContext.HasEvaluatedPropertiesActions)
+        {
+            propertiesLookup ??= ExtractPropertiesLookup(evaluationFinishedEventArgs);
 
-        _buildCheckCentralContext.RunEvaluatedPropertiesActions(analysisData, analysisContext, ReportResult);
+            EvaluatedPropertiesCheckData checkData =
+                new(evaluationFinishedEventArgs.ProjectFile!,
+                    evaluationFinishedEventArgs.BuildEventContext?.ProjectInstanceId,
+                    propertiesLookup!);
+
+            _buildCheckCentralContext.RunEvaluatedPropertiesActions(checkData, checkContext, ReportResult);
+        }
 
         if (_buildCheckCentralContext.HasParsedItemsActions)
         {
@@ -68,33 +77,43 @@ internal void ProcessEvaluationFinishedEventArgs(
                 evaluationFinishedEventArgs.ProjectFile!, /*unused*/
                 null, /*unused*/null, _cache, false /*Not explicitly loaded - unused*/);
 
-            ParsedItemsAnalysisData itemsAnalysisData = new(
+            ParsedItemsCheckData itemsCheckData = new(
                 evaluationFinishedEventArgs.ProjectFile!,
                 evaluationFinishedEventArgs.BuildEventContext?.ProjectInstanceId,
                 new ItemsHolder(xml.Items, xml.ItemGroups));
 
-            _buildCheckCentralContext.RunParsedItemsActions(itemsAnalysisData, analysisContext, ReportResult);
+            _buildCheckCentralContext.RunParsedItemsActions(itemsCheckData, checkContext, ReportResult);
         }
     }
 
     /// <summary>
     /// The method collects events associated with the used environment variables in projects.
     /// </summary>
-    internal void ProcessEnvironmentVariableReadEventArgs(string envVarName, string envVarValue, string file, int line, int column)
+    internal void ProcessEnvironmentVariableReadEventArgs(ICheckContext checkContext, string projectPath, string envVarKey, string envVarValue, IElementLocation elementLocation)
+    {
+        EnvironmentVariableCheckData checkData = new(projectPath, checkContext.BuildEventContext?.ProjectInstanceId, envVarKey, envVarValue, elementLocation);
+
+        _buildCheckCentralContext.RunEnvironmentVariableActions(checkData, checkContext, ReportResult);
+    }
+
+    internal void ProcessBuildDone(ICheckContext checkContext)
     {
-        if (!_evaluatedEnvironmentVariables.ContainsKey(envVarName))
+        if (!_buildCheckCentralContext.HasBuildFinishedActions)
         {
-            _evaluatedEnvironmentVariables.Add(envVarName, (envVarValue, file, line, column));
+            // No analyzer is interested in the event -> nothing to do.
+            return;
         }
+
+        _buildCheckCentralContext.RunBuildFinishedActions(new BuildFinishedCheckData(), checkContext, ReportResult);
     }
 
     internal void ProcessTaskStartedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checkContext,
         TaskStartedEventArgs taskStartedEventArgs)
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
         {
-            // No analyzer is interested in task invocation actions -> nothing to do.
+            // No check is interested in task invocation actions -> nothing to do.
             return;
         }
 
@@ -107,12 +126,12 @@ internal void ProcessTaskStartedEventArgs(
 
             // Add a new entry to _tasksBeingExecuted. TaskParameters are initialized empty and will be recorded
             // based on TaskParameterEventArgs we receive later.
-            Dictionary<string, TaskInvocationAnalysisData.TaskParameter> taskParameters = new();
+            Dictionary<string, TaskInvocationCheckData.TaskParameter> taskParameters = new();
 
             ExecutingTaskData taskData = new()
             {
                 TaskParameters = taskParameters,
-                AnalysisData = new(
+                CheckData = new(
                     projectFilePath: taskStartedEventArgs.ProjectFile!,
                     projectConfigurationId: taskStartedEventArgs.BuildEventContext.ProjectInstanceId,
                     taskInvocationLocation: invocationLocation,
@@ -126,12 +145,12 @@ internal void ProcessTaskStartedEventArgs(
     }
 
     internal void ProcessTaskFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checkContext,
         TaskFinishedEventArgs taskFinishedEventArgs)
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
         {
-            // No analyzer is interested in task invocation actions -> nothing to do.
+            // No check is interested in task invocation actions -> nothing to do.
             return;
         }
 
@@ -142,18 +161,18 @@ internal void ProcessTaskFinishedEventArgs(
             {
                 // All task parameters have been recorded by now so remove the task from the dictionary and fire the registered build check actions.
                 _tasksBeingExecuted.Remove(taskKey);
-                _buildCheckCentralContext.RunTaskInvocationActions(taskData.AnalysisData, analysisContext, ReportResult);
+                _buildCheckCentralContext.RunTaskInvocationActions(taskData.CheckData, checkContext, ReportResult);
             }
         }
     }
 
     internal void ProcessTaskParameterEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checkContext,
         TaskParameterEventArgs taskParameterEventArgs)
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
         {
-            // No analyzer is interested in task invocation actions -> nothing to do.
+            // No check is interested in task invocation actions -> nothing to do.
             return;
         }
 
@@ -177,46 +196,46 @@ internal void ProcessTaskParameterEventArgs(
                 _ => taskParameterEventArgs.Items,
             };
 
-            taskData.TaskParameters[parameterName] = new TaskInvocationAnalysisData.TaskParameter(parameterValue, isOutput);
+            taskData.TaskParameters[parameterName] = new TaskInvocationCheckData.TaskParameter(parameterValue, isOutput);
         }
     }
 
-    public void ProcessPropertyRead(PropertyReadData propertyReadData, AnalysisLoggingContext analysisContext)
+    public void ProcessPropertyRead(PropertyReadData propertyReadData, CheckLoggingContext checkContext)
         => _buildCheckCentralContext.RunPropertyReadActions(
                 propertyReadData,
-                analysisContext,
+                checkContext,
                 ReportResult);
 
-    public void ProcessPropertyWrite(PropertyWriteData propertyWriteData, AnalysisLoggingContext analysisContext)
+    public void ProcessPropertyWrite(PropertyWriteData propertyWriteData, CheckLoggingContext checkContext)
         => _buildCheckCentralContext.RunPropertyWriteActions(
                 propertyWriteData,
-                analysisContext,
+                checkContext,
                 ReportResult);
 
-    public void ProcessProjectDone(IAnalysisContext analysisContext, string projectFullPath)
+    public void ProcessProjectDone(ICheckContext checkContext, string projectFullPath)
         => _buildCheckCentralContext.RunProjectProcessingDoneActions(
-                new ProjectProcessingDoneData(projectFullPath, analysisContext.BuildEventContext.ProjectInstanceId),
-                analysisContext,
+                new ProjectRequestProcessingDoneData(projectFullPath, checkContext.BuildEventContext.ProjectInstanceId),
+                checkContext,
                 ReportResult);
 
     private static void ReportResult(
-        BuildAnalyzerWrapper analyzerWrapper,
-        IAnalysisContext analysisContext,
-        BuildAnalyzerConfigurationEffective[] configPerRule,
+        CheckWrapper checkWrapper,
+        ICheckContext checkContext,
+        CheckConfigurationEffective[] configPerRule,
         BuildCheckResult result)
     {
-        if (!analyzerWrapper.BuildAnalyzer.SupportedRules.Contains(result.BuildAnalyzerRule))
+        if (!checkWrapper.Check.SupportedRules.Contains(result.CheckRule))
         {
-            analysisContext.DispatchAsErrorFromText(null, null, null,
+            checkContext.DispatchAsErrorFromText(null, null, null,
                 BuildEventFileInfo.Empty,
-                $"The analyzer '{analyzerWrapper.BuildAnalyzer.FriendlyName}' reported a result for a rule '{result.BuildAnalyzerRule.Id}' that it does not support.");
+                $"The check '{checkWrapper.Check.FriendlyName}' reported a result for a rule '{result.CheckRule.Id}' that it does not support.");
             return;
         }
 
-        BuildAnalyzerConfigurationEffective config = configPerRule.Length == 1
+        CheckConfigurationEffective config = configPerRule.Length == 1
             ? configPerRule[0]
             : configPerRule.First(r =>
-                r.RuleId.Equals(result.BuildAnalyzerRule.Id, StringComparison.CurrentCultureIgnoreCase));
+                r.RuleId.Equals(result.CheckRule.Id, StringComparison.CurrentCultureIgnoreCase));
 
         if (!config.IsEnabled)
         {
@@ -225,10 +244,8 @@ private static void ReportResult(
 
         BuildEventArgs eventArgs = result.ToEventArgs(config.Severity);
 
-        // TODO: This is a workaround for https://github.com/dotnet/msbuild/issues/10176
-        // eventArgs.BuildEventContext = loggingContext.BuildEventContext;
-        eventArgs.BuildEventContext = BuildEventContext.Invalid;
+        eventArgs.BuildEventContext = checkContext.BuildEventContext;
 
-        analysisContext.DispatchBuildEvent(eventArgs);
+        checkContext.DispatchBuildEvent(eventArgs);
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/CheckConfigurationEffective.cs b/src/Build/BuildCheck/Infrastructure/CheckConfigurationEffective.cs
new file mode 100644
index 00000000000..0f857dad631
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/CheckConfigurationEffective.cs
@@ -0,0 +1,45 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+/// <summary>
+/// Counterpart type for BuildCheckConfiguration - with all properties non-nullable
+/// </summary>
+public sealed class CheckConfigurationEffective
+{
+    public CheckConfigurationEffective(string ruleId, EvaluationCheckScope evaluationCheckScope, CheckResultSeverity severity)
+    {
+        if (severity == CheckResultSeverity.Default)
+        {
+            throw new ArgumentOutOfRangeException(nameof(severity), severity, "Severity 'Default' is not recognized by the BuildCheck reports infrastructure");
+        }
+
+        RuleId = ruleId;
+        EvaluationCheckScope = evaluationCheckScope;
+        Severity = severity;
+    }
+
+    internal static CheckConfigurationEffective Default { get; } =
+        new(string.Empty, CheckConfiguration.Default.EvaluationCheckScope!.Value,
+            CheckConfiguration.Default.Severity!.Value);
+
+    public string RuleId { get; }
+
+    public EvaluationCheckScope EvaluationCheckScope { get; }
+
+    public CheckResultSeverity Severity { get; }
+
+    public bool IsEnabled => Severity >= CheckResultSeverity.Suggestion;
+
+    // Intentionally not checking the RuleId
+    //  as for checks with multiple rules, we can squash config to a single one,
+    //  if the ruleId is the only thing differing.
+    public bool IsSameConfigurationAs(CheckConfigurationEffective? other) =>
+        other != null &&
+        Severity == other.Severity &&
+        EvaluationCheckScope == other.EvaluationCheckScope;
+}
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContext.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs
similarity index 92%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContext.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs
index f9e8cd36cfb..71befe7991b 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs
@@ -15,14 +15,14 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// <see cref="IAnalysisContext"/> that uses <see cref="EventArgsDispatcher"/> to dispatch.
+/// <see cref="ICheckContext"/> that uses <see cref="EventArgsDispatcher"/> to dispatch.
 /// </summary>
-internal class AnalysisDispatchingContext : IAnalysisContext
+internal class CheckDispatchingContext : ICheckContext
 {
     private readonly EventArgsDispatcher _eventDispatcher;
     private readonly BuildEventContext _eventContext;
 
-    public AnalysisDispatchingContext(
+    public CheckDispatchingContext(
         EventArgsDispatcher dispatch,
         BuildEventContext eventContext)
     {
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContextFactory.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContextFactory.cs
similarity index 62%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContextFactory.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContextFactory.cs
index 0a133f90f3d..6c536a14df9 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContextFactory.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContextFactory.cs
@@ -6,19 +6,19 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
-internal class AnalysisDispatchingContextFactory : IAnalysisContextFactory
+internal class CheckDispatchingContextFactory : ICheckContextFactory
 {
     private readonly EventArgsDispatcher _eventDispatcher;
 
     public event AnyEventHandler? AnyEventRaised;
 
-    public AnalysisDispatchingContextFactory(EventArgsDispatcher eventDispatcher)
+    public CheckDispatchingContextFactory(EventArgsDispatcher eventDispatcher)
     {
         _eventDispatcher = eventDispatcher;
 
         _eventDispatcher.AnyEventRaised += (sender, e) => AnyEventRaised?.Invoke(sender, e);
     }
 
-    public IAnalysisContext CreateAnalysisContext(BuildEventContext eventContext)
-        => new AnalysisDispatchingContext(_eventDispatcher, eventContext);
+    public ICheckContext CreateCheckContext(BuildEventContext eventContext)
+        => new CheckDispatchingContext(_eventDispatcher, eventContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs
similarity index 87%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs
index 5df77259f6e..c295b254f49 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs
@@ -13,14 +13,14 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// <see cref="IAnalysisContext"/> that uses <see cref="ILoggingService"/> to dispatch.
+/// <see cref="ICheckContext"/> that uses <see cref="ILoggingService"/> to dispatch.
 /// </summary>
 /// <remarks>
 /// Making this a record struct to avoid allocations (unless called through interface - which leads to boxing).
 /// This is wanted since this can be used in a hot path (of property reads and writes)
 /// </remarks>
-internal readonly struct AnalysisLoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
-    : IAnalysisContext
+internal readonly struct CheckLoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
+    : ICheckContext
 {
     public BuildEventContext BuildEventContext => eventContext;
 
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContextFactory.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContextFactory.cs
similarity index 57%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContextFactory.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContextFactory.cs
index b1a716d7b7f..5f429c94b02 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContextFactory.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContextFactory.cs
@@ -11,12 +11,12 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
-internal class AnalysisLoggingContextFactory : IAnalysisContextFactory
+internal class CheckLoggingContextFactory : ICheckContextFactory
 {
     private readonly ILoggingService _loggingService;
 
-    public AnalysisLoggingContextFactory(ILoggingService loggingService) => _loggingService = loggingService;
+    public CheckLoggingContextFactory(ILoggingService loggingService) => _loggingService = loggingService;
 
-    public IAnalysisContext CreateAnalysisContext(BuildEventContext eventContext)
-        => new AnalysisLoggingContext(_loggingService, eventContext);
+    public ICheckContext CreateCheckContext(BuildEventContext eventContext)
+        => new CheckLoggingContext(_loggingService, eventContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContext.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContext.cs
similarity index 97%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContext.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContext.cs
index 00439c6dd55..7c4e82861ea 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContext.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// Interface that contains an instance of <see cref="BuildEventContext"/> and methods to dispatch it.
 /// </summary>
-internal interface IAnalysisContext
+internal interface ICheckContext
 {
     /// <summary>
     /// Instance of <see cref="BuildEventContext"/>.
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContextFactory.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContextFactory.cs
similarity index 66%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContextFactory.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContextFactory.cs
index 66cc71f507c..da90050598d 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContextFactory.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContextFactory.cs
@@ -5,7 +5,7 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
-internal interface IAnalysisContextFactory
+internal interface ICheckContextFactory
 {
-    IAnalysisContext CreateAnalysisContext(BuildEventContext eventContext);
+    ICheckContext CreateCheckContext(BuildEventContext eventContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/CheckRegistrationContext.cs b/src/Build/BuildCheck/Infrastructure/CheckRegistrationContext.cs
new file mode 100644
index 00000000000..1a0565a50fb
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/CheckRegistrationContext.cs
@@ -0,0 +1,36 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Threading;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Checks;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+internal sealed class CheckRegistrationContext(CheckWrapper checkWrapper, BuildCheckCentralContext buildCheckCentralContext) : IInternalCheckRegistrationContext
+{
+    public void RegisterEnvironmentVariableReadAction(Action<BuildCheckDataContext<EnvironmentVariableCheckData>> environmentVariableAction) =>
+        buildCheckCentralContext.RegisterEnvironmentVariableReadAction(checkWrapper, environmentVariableAction);
+
+    public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction) =>
+        buildCheckCentralContext.RegisterEvaluatedPropertiesAction(checkWrapper, evaluatedPropertiesAction);
+
+    public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction) =>
+        buildCheckCentralContext.RegisterParsedItemsAction(checkWrapper, parsedItemsAction);
+
+    public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction) =>
+        buildCheckCentralContext.RegisterTaskInvocationAction(checkWrapper, taskInvocationAction);
+
+    public void RegisterPropertyReadAction(Action<BuildCheckDataContext<PropertyReadData>> propertyReadAction)
+        => buildCheckCentralContext.RegisterPropertyReadAction(checkWrapper, propertyReadAction);
+
+    public void RegisterPropertyWriteAction(Action<BuildCheckDataContext<PropertyWriteData>> propertyWriteAction)
+        => buildCheckCentralContext.RegisterPropertyWriteAction(checkWrapper, propertyWriteAction);
+
+    public void RegisterProjectRequestProcessingDoneAction(Action<BuildCheckDataContext<ProjectRequestProcessingDoneData>> projectDoneAction)
+        => buildCheckCentralContext.RegisterProjectRequestProcessingDoneAction(checkWrapper, projectDoneAction);
+
+    public void RegisterBuildFinishedAction(Action<BuildCheckDataContext<BuildFinishedCheckData>> buildFinishedAction)
+        => buildCheckCentralContext.RegisterBuildFinishedAction(checkWrapper, buildFinishedAction);
+}
diff --git a/src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs b/src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs
new file mode 100644
index 00000000000..2185f509a26
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs
@@ -0,0 +1,80 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal static class CheckScopeClassifier
+{
+    static CheckScopeClassifier()
+    {
+        FileClassifier.Shared.OnImmutablePathsInitialized += SubscribeImmutablePathsInitialized;
+    }
+
+    internal static event Action? NotifyOnScopingReadiness;
+
+    internal static bool IsScopingInitialized => FileClassifier.Shared.IsImmutablePathsInitialized;
+
+    /// <summary>
+    /// Notifies the subscribers that the scoping is ready.
+    /// </summary>
+    internal static Func<EvaluationCheckScope, bool> IsScopingReady => (scope) => (scope is EvaluationCheckScope.ProjectFileOnly or EvaluationCheckScope.All) || IsScopingInitialized;
+
+    /// <summary>
+    /// Indicates whether given location is in the observed scope, based on currently built project path.
+    /// </summary>
+    /// <param name="scope"></param>
+    /// <param name="location"></param>
+    /// <param name="projectFileFullPath"></param>
+    /// <returns></returns>
+    /// <exception cref="ArgumentOutOfRangeException"></exception>
+    internal static bool IsActionInObservedScope(
+        EvaluationCheckScope scope,
+        IMSBuildElementLocation? location,
+        string projectFileFullPath)
+        => IsActionInObservedScope(scope, location?.File, projectFileFullPath);
+
+    /// <summary>
+    /// Indicates whether given location is in the observed scope, based on currently built project path.
+    /// </summary>
+    /// <param name="scope"></param>
+    /// <param name="filePathOfEvent"></param>
+    /// <param name="projectFileFullPath"></param>
+    /// <returns></returns>
+    /// <exception cref="ArgumentOutOfRangeException"></exception>
+    internal static bool IsActionInObservedScope(
+        EvaluationCheckScope scope,
+        string? filePathOfEvent,
+        string projectFileFullPath)
+    {
+        switch (scope)
+        {
+            case EvaluationCheckScope.ProjectFileOnly:
+                return filePathOfEvent == projectFileFullPath;
+            case EvaluationCheckScope.WorkTreeImports:
+                return
+                    filePathOfEvent != null &&
+                    !FileClassifier.Shared.IsNonModifiable(filePathOfEvent) &&
+                    !IsGeneratedNugetImport(filePathOfEvent);
+            case EvaluationCheckScope.All:
+                return true;
+            default:
+                throw new ArgumentOutOfRangeException(nameof(scope), scope, null);
+        }
+    }
+
+    private static bool IsGeneratedNugetImport(string file) =>
+        file.EndsWith("nuget.g.props", StringComparison.OrdinalIgnoreCase)
+        || file.EndsWith("nuget.g.targets", StringComparison.OrdinalIgnoreCase);
+
+    private static void SubscribeImmutablePathsInitialized()
+    {
+        NotifyOnScopingReadiness?.Invoke();
+
+        FileClassifier.Shared.OnImmutablePathsInitialized -= () => NotifyOnScopingReadiness?.Invoke();
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs b/src/Build/BuildCheck/Infrastructure/CheckWrapper.cs
similarity index 77%
rename from src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
rename to src/Build/BuildCheck/Infrastructure/CheckWrapper.cs
index 46c42eaa4d1..62011296cb5 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckWrapper.cs
@@ -11,28 +11,28 @@
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
-/// A wrapping, enriching class for BuildAnalyzer - so that we have additional data and functionality.
+/// A wrapping, enriching class for BuildCheck - so that we have additional data and functionality.
 /// </summary>
-internal sealed class BuildAnalyzerWrapper
+internal sealed class CheckWrapper
 {
     private readonly Stopwatch _stopwatch = new Stopwatch();
 
-    public BuildAnalyzerWrapper(BuildAnalyzer buildAnalyzer)
+    public CheckWrapper(Check check)
     {
-        BuildAnalyzer = buildAnalyzer;
+        Check = check;
     }
 
-    internal BuildAnalyzer BuildAnalyzer { get; }
+    internal Check Check { get; }
     private bool _isInitialized = false;
 
     // Let's optimize for the scenario where users have a single .editorconfig file that applies to the whole solution.
     // In such case - configuration will be same for all projects. So we do not need to store it per project in a collection.
-    internal BuildAnalyzerConfigurationEffective? CommonConfig { get; private set; }
+    internal CheckConfigurationEffective? CommonConfig { get; private set; }
 
     // start new project
     internal void StartNewProject(
         string fullProjectPath,
-        IReadOnlyList<BuildAnalyzerConfigurationEffective> userConfigs)
+        IReadOnlyList<CheckConfigurationEffective> userConfigs)
     {
         if (!_isInitialized)
         {
@@ -52,7 +52,7 @@ internal void StartNewProject(
         }
     }
 
-    // to be used on eval node (BuildCheckDataSource.BuildExecution)
+    // to be used on eval node (BuildCheckDataSource.check)
     internal void Uninitialize()
     {
         _isInitialized = false;
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
index a927682ef76..e102fe96ced 100644
--- a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -8,19 +8,20 @@
 using Microsoft.Build.Experimental.BuildCheck;
 using System.Collections.Concurrent;
 using Microsoft.Build.Experimental.BuildCheck.Utilities;
+using Microsoft.Build.BuildCheck.Infrastructure;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-internal sealed class ConfigurationProvider
+internal sealed class ConfigurationProvider : IConfigurationProvider
 {
     private readonly EditorConfigParser _editorConfigParser = new EditorConfigParser();
 
     private const string BuildCheck_ConfigurationKey = "build_check";
 
     /// <summary>
-    /// The dictionary used for storing the BuildAnalyzerConfiguration per projectfile and rule id. The key is equal to {projectFullPath}-{ruleId}.
+    /// The dictionary used for storing the BuildCheckConfiguration per projectfile and rule id. The key is equal to {projectFullPath}-{ruleId}.
     /// </summary>
-    private readonly ConcurrentDictionary<string, BuildAnalyzerConfiguration> _buildAnalyzerConfiguration = new ConcurrentDictionary<string, BuildAnalyzerConfiguration>(StringComparer.InvariantCultureIgnoreCase);
+    private readonly ConcurrentDictionary<string, CheckConfiguration> _checkConfiguration = new ConcurrentDictionary<string, CheckConfiguration>(StringComparer.InvariantCultureIgnoreCase);
 
     /// <summary>
     /// The dictionary used for storing the key-value pairs retrieved from the .editorconfigs for specific projectfile. The key is equal to projectFullPath.
@@ -38,7 +39,7 @@ internal sealed class ConfigurationProvider
     };
 
     /// <summary>
-    /// Gets the user specified unrecognized configuration for the given analyzer rule.
+    /// Gets the user specified unrecognized configuration for the given check rule.
     /// 
     /// The configuration module should as well check that CustomConfigurationData
     ///  for a particular rule is equal across the whole build (for all projects)  - otherwise it should error out.
@@ -84,7 +85,7 @@ public CustomConfigurationData GetCustomConfiguration(string projectFullPath, st
     /// <param name="ruleId"></param>
     /// <throws><see cref="BuildCheckConfigurationException"/> If CustomConfigurationData differs in a build for a same ruleId</throws>
     /// <returns></returns>
-    internal void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
+    public void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
     {
         var configuration = GetCustomConfiguration(projectFullPath, ruleId);
         VerifyCustomConfigurationEquality(ruleId, configuration);
@@ -101,12 +102,12 @@ internal void VerifyCustomConfigurationEquality(string ruleId, CustomConfigurati
         }
     }
 
-    internal BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(
+    public CheckConfigurationEffective[] GetMergedConfigurations(
         string projectFullPath,
-        BuildAnalyzer analyzer)
-        => FillConfiguration(projectFullPath, analyzer.SupportedRules, GetMergedConfiguration);
+        Check check)
+        => FillConfiguration(projectFullPath, check.SupportedRules, GetMergedConfiguration);
 
-    internal BuildAnalyzerConfiguration[] GetUserConfigurations(
+    public CheckConfiguration[] GetUserConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetUserConfiguration);
@@ -122,17 +123,17 @@ public CustomConfigurationData[] GetCustomConfigurations(
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetCustomConfiguration);
 
-    internal BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(
-        BuildAnalyzerConfiguration[] userConfigs,
-        BuildAnalyzer analyzer)
+    public CheckConfigurationEffective[] GetMergedConfigurations(
+        CheckConfiguration[] userConfigs,
+        Check check)
     {
-        var configurations = new BuildAnalyzerConfigurationEffective[userConfigs.Length];
+        var configurations = new CheckConfigurationEffective[userConfigs.Length];
 
         for (int idx = 0; idx < userConfigs.Length; idx++)
         {
             configurations[idx] = MergeConfiguration(
-                analyzer.SupportedRules[idx].Id,
-                analyzer.SupportedRules[idx].DefaultConfiguration,
+                check.SupportedRules[idx].Id,
+                check.SupportedRules[idx].DefaultConfiguration,
                 userConfigs[idx]);
         }
 
@@ -217,28 +218,28 @@ internal Dictionary<string, string> GetConfiguration(string projectFullPath, str
     }
 
     /// <summary>
-    /// Gets effective user specified (or default) configuration for the given analyzer rule.
+    /// Gets effective user specified (or default) configuration for the given check rule.
     /// The configuration values CAN be null upon this operation.
     /// 
-    /// The configuration module should as well check that BuildAnalyzerConfigurationInternal.EvaluationAnalysisScope
+    /// The configuration module should as well check that BuildCheckConfigurationInternal.EvaluationCheckScope
     ///  for all rules is equal - otherwise it should error out.
     /// </summary>
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <returns></returns>
-    internal BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
+    internal CheckConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
     {
         var cacheKey = $"{ruleId}-{projectFullPath}";
 
-        var editorConfigValue = _buildAnalyzerConfiguration.GetOrAdd(cacheKey, (key) =>
+        var editorConfigValue = _checkConfiguration.GetOrAdd(cacheKey, (key) =>
         {
-            BuildAnalyzerConfiguration? editorConfig = BuildAnalyzerConfiguration.Null;
+            CheckConfiguration? editorConfig = CheckConfiguration.Null;
             editorConfig.RuleId = ruleId;
             var config = GetConfiguration(projectFullPath, ruleId);
 
             if (config.Any())
             {
-                editorConfig = BuildAnalyzerConfiguration.Create(config);
+                editorConfig = CheckConfiguration.Create(config);
             }
 
             return editorConfig;
@@ -248,50 +249,50 @@ internal BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath,
     }
 
     /// <summary>
-    /// Gets effective configuration for the given analyzer rule.
+    /// Gets effective configuration for the given check rule.
     /// The configuration values are guaranteed to be non-null upon this merge operation.
     /// </summary>
     /// <param name="projectFullPath"></param>
-    /// <param name="analyzerRule"></param>
+    /// <param name="checkRule"></param>
     /// <returns></returns>
-    internal BuildAnalyzerConfigurationEffective GetMergedConfiguration(string projectFullPath, BuildAnalyzerRule analyzerRule)
-        => GetMergedConfiguration(projectFullPath, analyzerRule.Id, analyzerRule.DefaultConfiguration);
+    internal CheckConfigurationEffective GetMergedConfiguration(string projectFullPath, CheckRule checkRule)
+        => GetMergedConfiguration(projectFullPath, checkRule.Id, checkRule.DefaultConfiguration);
 
-    internal BuildAnalyzerConfigurationEffective MergeConfiguration(
+    internal CheckConfigurationEffective MergeConfiguration(
         string ruleId,
-        BuildAnalyzerConfiguration defaultConfig,
-        BuildAnalyzerConfiguration editorConfig)
-        => new BuildAnalyzerConfigurationEffective(
+        CheckConfiguration defaultConfig,
+        CheckConfiguration editorConfig)
+        => new CheckConfigurationEffective(
             ruleId: ruleId,
-            evaluationAnalysisScope: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.EvaluationAnalysisScope),
+            evaluationCheckScope: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.EvaluationCheckScope),
             severity: GetSeverityValue(editorConfig, defaultConfig));
 
-    private BuildAnalyzerConfigurationEffective GetMergedConfiguration(
+    private CheckConfigurationEffective GetMergedConfiguration(
         string projectFullPath,
         string ruleId,
-        BuildAnalyzerConfiguration defaultConfig)
+        CheckConfiguration defaultConfig)
         => MergeConfiguration(ruleId, defaultConfig, GetUserConfiguration(projectFullPath, ruleId));
 
     private T GetConfigValue<T>(
-        BuildAnalyzerConfiguration editorConfigValue,
-        BuildAnalyzerConfiguration defaultValue,
-        Func<BuildAnalyzerConfiguration, T?> propertyGetter) where T : struct
+        CheckConfiguration editorConfigValue,
+        CheckConfiguration defaultValue,
+        Func<CheckConfiguration, T?> propertyGetter) where T : struct
         => propertyGetter(editorConfigValue) ??
            propertyGetter(defaultValue) ??
-           EnsureNonNull(propertyGetter(BuildAnalyzerConfiguration.Default));
+           EnsureNonNull(propertyGetter(CheckConfiguration.Default));
 
-    private BuildAnalyzerResultSeverity GetSeverityValue(BuildAnalyzerConfiguration editorConfigValue, BuildAnalyzerConfiguration defaultValue)
+    private CheckResultSeverity GetSeverityValue(CheckConfiguration editorConfigValue, CheckConfiguration defaultValue)
     {
-        BuildAnalyzerResultSeverity? resultSeverity = null;
+        CheckResultSeverity? resultSeverity = null;
 
         // Consider Default as null, so the severity from the default value could be selected.
         // Default severity is not recognized by the infrastructure and serves for configuration purpuses only. 
-        if (editorConfigValue.Severity != null && editorConfigValue.Severity != BuildAnalyzerResultSeverity.Default)
+        if (editorConfigValue.Severity != null && editorConfigValue.Severity != CheckResultSeverity.Default)
         {
             resultSeverity = editorConfigValue.Severity;
         }
 
-        resultSeverity ??= defaultValue.Severity ?? EnsureNonNull(BuildAnalyzerConfiguration.Default.Severity);
+        resultSeverity ??= defaultValue.Severity ?? EnsureNonNull(CheckConfiguration.Default.Severity);
 
         return resultSeverity.Value;
     }
diff --git a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
index afd3645cf2e..ac8d8012e01 100644
--- a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
+++ b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
@@ -13,7 +13,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// Holder for the key-value pairs of unstructured data from .editorconfig file,
 ///  that were attribute to a particular rule, but were not recognized by the infrastructure.
-/// The configuration data that is recognized by the infrastructure is passed as <see cref="BuildAnalyzerConfiguration"/>.
+/// The configuration data that is recognized by the infrastructure is passed as <see cref="CheckConfiguration"/>.
 /// </summary>
 public sealed class CustomConfigurationData
 {
@@ -41,7 +41,7 @@ public CustomConfigurationData(string ruleId, Dictionary<string, string> propert
     /// Key-value pairs of unstructured data from .editorconfig file.
     /// E.g. if in editorconfig file we'd have:
     /// [*.csrpoj]
-    /// build_analyzer.microsoft.BC0101.name_of_targets_to_restrict = "Build,CoreCompile,ResolveAssemblyReferences"
+    /// build_check.microsoft.BC0101.name_of_targets_to_restrict = "Build,CoreCompile,ResolveAssemblyReferences"
     ///
     /// the ConfigurationData would be:
     /// "name_of_targets_to_restrict" -> "Build,CoreCompile,ResolveAssemblyReferences"
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
index e19b61c2c40..163fd84f1ff 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
@@ -7,7 +7,7 @@ To track the request on sharing the code: https://github.com/dotnet/roslyn/issue
 In current implementation the usage of the editorconfig is internal only and exposed via ConfigurationProvider functionality. 
 
 Configuration divided into two categories: 
-- Infra related configuration. IsEnabled, Severity, EvaluationAnalysisScope
+- Infra related configuration. IsEnabled, Severity, EvaluationCheckScope
 - Custom configuration, any other config specified by user for this particular rule
 
 ### Example
@@ -38,7 +38,7 @@ list<editorConfig>{
 }
 ```
 Reverse the order and collect all matching section key-value pairs into new dictionary
-Remove non-msbuild-analyzer related key-values (keys not starting with msbuild_analyzer.RULEID)
+Remove non-msbuild-check related key-values (keys not starting with msbuild_check.RULEID)
 
 The implementation differs depending on category: 
  - Infra related config: Merges the configuration retrieved from configuration module with default values (respecting the specified configs in editorconfig) 
@@ -67,12 +67,12 @@ Lifecycle of BuildCheckManager could be found [here](https://github.com/dotnet/m
 
 
 #### Custom configuration data
-CustomConfigurationData is propogated to the BuildCheck Analyzer instance by passing the instance of [ConfigurationContext](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/ConfigurationContext.cs#L14)
-during the initialization of the [BuildAnalyzer](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/BuildAnalyzer.cs#L36).
+CustomConfigurationData is propogated to the BuildCheck Check instance by passing the instance of [ConfigurationContext](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/ConfigurationContext.cs#L14)
+during the initialization of the [BuildExecutionCheck](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/BuildExecutionCheck.cs#L36).
 
 
 #### Example of consuming the CustomConfigurationData
-The `Initialize` method of BuildCheck Analyzer:
+The `Initialize` method of BuildCheck Check:
 ```C#
 public override void Initialize(ConfigurationContext configurationContext)
 {
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
index d3174b94ed0..88c644954e7 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -36,44 +36,52 @@ internal enum BuildCheckDataSource
 internal interface IBuildCheckManager
 {
     void ProcessEvaluationFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checksContext,
         ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs);
 
     void ProcessEnvironmentVariableReadEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checksContext,
         EnvironmentVariableReadEventArgs envVariableReadEventArgs);
 
     void ProcessTaskStartedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checksContext,
         TaskStartedEventArgs taskStartedEventArgs);
 
     void ProcessTaskFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checksContext,
         TaskFinishedEventArgs taskFinishedEventArgs);
 
     void ProcessTaskParameterEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checksContext,
         TaskParameterEventArgs taskParameterEventArgs);
 
+    void ProcessBuildFinished(ICheckContext analysisContext);
+
     void SetDataSource(BuildCheckDataSource buildCheckDataSource);
 
-    void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, IAnalysisContext analysisContext);
+    void ProcessCheckAcquisition(CheckAcquisitionData acquisitionData, ICheckContext checksContext);
 
-    Dictionary<string, TimeSpan> CreateAnalyzerTracingStats();
+    Dictionary<string, TimeSpan> CreateCheckTracingStats();
 
     void FinalizeProcessing(LoggingContext loggingContext);
 
     // All those to be called from RequestBuilder,
     //  but as well from the ConnectorLogger - as even if interleaved, it gives the info
-    //  to manager about what analyzers need to be materialized and configuration fetched.
-    // No unloading of analyzers is yet considered - once loaded it stays for whole build.
-    void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, IAnalysisContext analysisContext, string projectFullPath);
+    //  to manager about what checks need to be materialized and configuration fetched.
+    // No unloading of checks is yet considered - once loaded it stays for whole build.
+    
+	
+    // Project might be encountered first time in some node, but be already evaluated in another - so StartProjectEvaluation won't happen
+    //  - but we still need to know about it, hence the dedicated event.
+    void ProjectFirstEncountered(BuildCheckDataSource buildCheckDataSource, ICheckContext analysisContext, string projectFullPath);
+
+    void ProcessProjectEvaluationStarted(ICheckContext checksContext, string projectFullPath);
 
-    void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
+    void EndProjectEvaluation(BuildEventContext buildEventContext);
 
-    void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext, string projectFullPath);
+    void StartProjectRequest(BuildEventContext buildEventContext, string projectFullPath);
 
-    void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, IAnalysisContext analysisContext, string projectFullPath);
+    void EndProjectRequest(ICheckContext checksContext, string projectFullPath);
 
     void Shutdown();
 }
diff --git a/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs
new file mode 100644
index 00000000000..e51903fb06e
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs
@@ -0,0 +1,28 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+internal interface IConfigurationProvider
+{
+    CheckConfiguration[] GetUserConfigurations(
+        string projectFullPath,
+        IReadOnlyList<string> ruleIds);
+
+    CheckConfigurationEffective[] GetMergedConfigurations(
+        string projectFullPath,
+        Check check);
+
+    CheckConfigurationEffective[] GetMergedConfigurations(
+        CheckConfiguration[] userConfigs,
+        Check check);
+
+    CustomConfigurationData[] GetCustomConfigurations(
+        string projectFullPath,
+        IReadOnlyList<string> ruleIds);
+
+    void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId);
+}
diff --git a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataConsumer.cs b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataConsumer.cs
index 9331ad4bc38..ac9a4323dfb 100644
--- a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataConsumer.cs
+++ b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataConsumer.cs
@@ -5,7 +5,7 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
 /// Consumer of the data from the build engine.
-/// Currently, this is used to send data for analysis to the BuildCheck.
+/// Currently, this is used to send data for checks to the BuildCheck.
 /// In the future we can multiplex the data to other consumers (e.g. copilot).
 /// </summary>
 internal interface IBuildEngineDataConsumer
@@ -19,5 +19,5 @@ internal interface IBuildEngineDataConsumer
     void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo);
 
     // TODO: We might want to move acquisition data processing into this interface as well
-    // void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData);
+    // void ProcessCheckAcquisition(CheckAcquisitionData acquisitionData);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
index 4aceff798f6..6d94625052c 100644
--- a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
+++ b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
@@ -5,21 +5,28 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
 /// The module that routes the data to the final consumer.
-/// Typically, it is the BuildCheck (in case of in-node analysis) or LoggingService
-///  (in case of centralized analysis, where the data will first be wrapped to BuildEventArgs and sent to central node).
+/// Typically, it is the BuildCheck (in case of in-node check) or LoggingService
+///  (in case of centralized check, where the data will first be wrapped to BuildEventArgs and sent to central node).
 /// </summary>
 internal interface IBuildEngineDataRouter
 {
     void ProcessPropertyRead(
         PropertyReadInfo propertyReadInfo,
-        // This is intentionally AnalysisLoggingContext instead of IAnalysisContext - to avoid boxing allocations
+        // This is intentionally CheckLoggingContext instead of ICheckContext - to avoid boxing allocations
         //  on a hot path of properties reading (same for writing)
-        AnalysisLoggingContext analysisContext);
+        CheckLoggingContext checkContext);
 
     /// <summary>
     /// Signals that a property was written to.
     /// </summary>
     void ProcessPropertyWrite(
         PropertyWriteInfo propertyWriteInfo,
-        AnalysisLoggingContext analysisContext);
+        CheckLoggingContext checkContext);
+
+    /// <summary>
+    /// Signals that evaluation in current node is starting
+    /// </summary>
+    /// <param name="checkContext"></param>
+    /// <param name="projectFullPath"></param>
+    void ProcessProjectEvaluationStarted(ICheckContext checkContext, string projectFullPath);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyReadInfo.cs b/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyReadInfo.cs
index 7b04208bc25..9fa2029535a 100644
--- a/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyReadInfo.cs
+++ b/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyReadInfo.cs
@@ -19,6 +19,6 @@ internal readonly record struct PropertyReadInfo(
     string PropertyName,
     int StartIndex,
     int EndIndex,
-    IMsBuildElementLocation ElementLocation,
+    IMSBuildElementLocation ElementLocation,
     bool IsUninitialized,
     PropertyReadContext PropertyReadContext);
diff --git a/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyWriteInfo.cs b/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyWriteInfo.cs
index 96046f59eae..b93e256dac6 100644
--- a/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyWriteInfo.cs
+++ b/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyWriteInfo.cs
@@ -14,4 +14,4 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 internal readonly record struct PropertyWriteInfo(
     string PropertyName,
     bool IsEmpty,
-    IMsBuildElementLocation? ElementLocation);
+    IMSBuildElementLocation? ElementLocation);
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
index 338a282cdcd..a5bf0b968a8 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -17,36 +17,40 @@ public void Shutdown()
     }
 
     public void ProcessEvaluationFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checkContext,
         ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs)
     {
     }
 
+    public void ProcessBuildFinished(ICheckContext analysisContext)
+    {
+    }
+
     public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
     {
     }
 
     public void ProcessTaskStartedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checkContext,
         TaskStartedEventArgs taskStartedEventArgs)
     {
     }
 
     public void ProcessTaskFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checkContext,
         TaskFinishedEventArgs taskFinishedEventArgs)
     {
     }
 
     public void ProcessTaskParameterEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checkContext,
         TaskParameterEventArgs taskParameterEventArgs)
     {
     }
 
-    public void ProcessAnalyzerAcquisition(
-        AnalyzerAcquisitionData acquisitionData,
-        IAnalysisContext analysisContext)
+    public void ProcessCheckAcquisition(
+        CheckAcquisitionData acquisitionData,
+        ICheckContext checkContext)
     {
     }
 
@@ -54,48 +58,35 @@ public void FinalizeProcessing(LoggingContext loggingContext)
     {
     }
 
-    public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, IAnalysisContext analysisContext, string fullPath)
+    public void ProjectFirstEncountered(BuildCheckDataSource buildCheckDataSource, ICheckContext checkContext,
+        string projectFullPath)
     {
     }
 
-    public void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    public void ProcessProjectEvaluationStarted(ICheckContext checkContext, string projectFullPath)
     {
     }
 
-    public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext, string projectFullPath)
+    public void EndProjectEvaluation(BuildEventContext buildEventContext)
     {
     }
 
-    public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, IAnalysisContext analysisContext,
-        string projectFullPath)
+    public void StartProjectRequest(BuildEventContext buildEventContext, string projectFullPath)
     {
     }
 
-    public void YieldProject(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    public void EndProjectRequest(ICheckContext checkContext, string projectFullPath)
     {
     }
 
-    public void ResumeProject(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
-    {
-    }
+    public Dictionary<string, TimeSpan> CreateCheckTracingStats() => new Dictionary<string, TimeSpan>();
 
-    public Dictionary<string, TimeSpan> CreateAnalyzerTracingStats() => new Dictionary<string, TimeSpan>();
-
-    public void StartTaskInvocation(BuildCheckDataSource buildCheckDataSource, TaskStartedEventArgs eventArgs)
-    { }
-
-    public void EndTaskInvocation(BuildCheckDataSource buildCheckDataSource, TaskFinishedEventArgs eventArgs)
+    public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext buildEventContext)
     { }
 
-    public void ProcessTaskParameter(BuildCheckDataSource buildCheckDataSource, TaskParameterEventArgs eventArg)
+    public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext buildEventContext)
     { }
 
-    public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext buildEventContext)
-    { }
-
-    public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext buildEventContext)
-    { }
-	
-    public void ProcessEnvironmentVariableReadEventArgs(IAnalysisContext analysisContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
+    public void ProcessEnvironmentVariableReadEventArgs(ICheckContext checkContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
     { }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
index 9809ad27e49..d7f75922966 100644
--- a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
+++ b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
@@ -17,11 +17,11 @@ internal class TracingReporter
 
     // Infrastructure time keepers
     // TODO: add more timers throughout BuildCheck run
-    private TimeSpan analyzerAcquisitionTime;
-    private TimeSpan analyzerSetDataSourceTime;
-    private TimeSpan newProjectAnalyzersTime;
+    private TimeSpan checkAcquisitionTime;
+    private TimeSpan checkSetDataSourceTime;
+    private TimeSpan newProjectChecksTime;
 
-    public void AddAnalyzerStats(string name, TimeSpan subtotal)
+    public void AddCheckStats(string name, TimeSpan subtotal)
     {
         if (TracingStats.TryGetValue(name, out TimeSpan existing))
         {
@@ -35,25 +35,25 @@ public void AddAnalyzerStats(string name, TimeSpan subtotal)
 
     public void AddAcquisitionStats(TimeSpan subtotal)
     {
-        analyzerAcquisitionTime += subtotal;
+        checkAcquisitionTime += subtotal;
     }
 
     public void AddSetDataSourceStats(TimeSpan subtotal)
     {
-        analyzerSetDataSourceTime += subtotal;
+        checkSetDataSourceTime += subtotal;
     }
 
     public void AddNewProjectStats(TimeSpan subtotal)
     {
-        newProjectAnalyzersTime += subtotal;
+        newProjectChecksTime += subtotal;
     }
 
-    public void AddAnalyzerInfraStats()
+    public void AddCheckInfraStats()
     {
         var infraStats = new Dictionary<string, TimeSpan>() {
-                { $"{BuildCheckConstants.infraStatPrefix}analyzerAcquisitionTime", analyzerAcquisitionTime },
-                { $"{BuildCheckConstants.infraStatPrefix}analyzerSetDataSourceTime", analyzerSetDataSourceTime },
-                { $"{BuildCheckConstants.infraStatPrefix}newProjectAnalyzersTime", newProjectAnalyzersTime }
+                { $"{BuildCheckConstants.infraStatPrefix}checkAcquisitionTime", checkAcquisitionTime },
+                { $"{BuildCheckConstants.infraStatPrefix}checkSetDataSourceTime", checkSetDataSourceTime },
+                { $"{BuildCheckConstants.infraStatPrefix}newProjectChecksTime", newProjectChecksTime }
             };
 
         TracingStats.Merge(infraStats, (span1, span2) => span1 + span2);
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
index 823e9f0541c..fd33666fbd9 100644
--- a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -15,11 +15,11 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Base for a data passed from infrastructure to build analyzers.
+/// Base for a data passed from infrastructure to build checks.
 /// </summary>
 /// <param name="projectFilePath">Currently built project.</param>
 /// <param name="projectConfigurationId">The unique id of a project with unique global properties set.</param>
-public abstract class AnalysisData(string projectFilePath, int? projectConfigurationId)
+public abstract class CheckData(string projectFilePath, int? projectConfigurationId)
 {
     private string? _projectFileDirectory;
     // The id is going to be used in future revision
@@ -57,39 +57,39 @@ public abstract class AnalysisData(string projectFilePath, int? projectConfigura
 }
 
 /// <summary>
-/// Data passed from infrastructure to build analyzers.
+/// Data passed from infrastructure to build checks.
 /// </summary>
-/// <typeparam name="T">The type of the actual data for analysis.</typeparam>
-public class BuildCheckDataContext<T> where T : AnalysisData
+/// <typeparam name="T">The type of the actual data for checking.</typeparam>
+public class BuildCheckDataContext<T> where T : CheckData
 {
-    private readonly BuildAnalyzerWrapper _analyzerWrapper;
-    private readonly IAnalysisContext _analysisContext;
-    private readonly BuildAnalyzerConfigurationEffective[] _configPerRule;
-    private readonly Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult> _resultHandler;
+    private readonly CheckWrapper _executionCheckWrapper;
+    private readonly ICheckContext _checkContext;
+    private readonly CheckConfigurationEffective[] _configPerRule;
+    private readonly Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult> _resultHandler;
 
     internal BuildCheckDataContext(
-        BuildAnalyzerWrapper analyzerWrapper,
-        IAnalysisContext loggingContext,
-        BuildAnalyzerConfigurationEffective[] configPerRule,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult> resultHandler,
+        CheckWrapper checkWrapper,
+        ICheckContext loggingContext,
+        CheckConfigurationEffective[] configPerRule,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult> resultHandler,
         T data)
     {
-        _analyzerWrapper = analyzerWrapper;
-        _analysisContext = loggingContext;
+        _executionCheckWrapper = checkWrapper;
+        _checkContext = loggingContext;
         _configPerRule = configPerRule;
         _resultHandler = resultHandler;
         Data = data;
     }
 
     /// <summary>
-    /// Method for reporting the result of the build analyzer rule.
+    /// Method for reporting the result of the build check rule.
     /// </summary>
     /// <param name="result"></param>
     public void ReportResult(BuildCheckResult result)
-        => _resultHandler(_analyzerWrapper, _analysisContext, _configPerRule, result);
+        => _resultHandler(_executionCheckWrapper, _checkContext, _configPerRule, result);
 
     /// <summary>
-    /// Data to be analyzed.
+    /// Data to be checked.
     /// </summary>
     public T Data { get; }
 }
diff --git a/src/Build/BuildCheck/OM/BuildFinishedCheckData.cs b/src/Build/BuildCheck/OM/BuildFinishedCheckData.cs
new file mode 100644
index 00000000000..e22cf937908
--- /dev/null
+++ b/src/Build/BuildCheck/OM/BuildFinishedCheckData.cs
@@ -0,0 +1,11 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// BuildCheck data indicating end of the build.
+/// This is the last event that can be received from the BuildCheck infrastructure.
+/// </summary>
+public class BuildFinishedCheckData() : CheckData(string.Empty, null)
+{ }
diff --git a/src/Build/BuildCheck/OM/EnvironmentVariableCheckData.cs b/src/Build/BuildCheck/OM/EnvironmentVariableCheckData.cs
new file mode 100644
index 00000000000..c1e4575b65b
--- /dev/null
+++ b/src/Build/BuildCheck/OM/EnvironmentVariableCheckData.cs
@@ -0,0 +1,40 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// BuildCheck OM data representing the environment variables used in a project file and its imports.
+/// </summary>
+public class EnvironmentVariableCheckData : CheckData
+{
+    internal EnvironmentVariableCheckData(
+        string projectFilePath,
+        int? projectConfigurationId,
+        string envVarName,
+        string envVarValue,
+        IMSBuildElementLocation Location)
+        : base(projectFilePath, projectConfigurationId)
+    {
+        EnvironmentVariableName = envVarName;
+        EnvironmentVariableValue = envVarValue;
+        EnvironmentVariableLocation = Location;
+    }
+
+    /// <summary>
+    /// Gets the evaluated environment variable location.
+    /// </summary>
+    public IMSBuildElementLocation EnvironmentVariableLocation { get; }
+
+    /// <summary>
+    /// Gets the evaluated environment variable name.
+    /// </summary>
+    public string EnvironmentVariableName { get; }
+
+    /// <summary>
+    /// Gets the evaluated environment variable value.
+    /// </summary>
+    public string EnvironmentVariableValue { get; }
+}
diff --git a/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs b/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
deleted file mode 100644
index be24b5346c0..00000000000
--- a/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
+++ /dev/null
@@ -1,34 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Collections.Generic;
-using Microsoft.Build.BackEnd.Logging;
-
-namespace Microsoft.Build.Experimental.BuildCheck;
-
-/// <summary>
-/// BuildCheck OM data representing the evaluated properties of a project.
-/// </summary>
-public class EvaluatedPropertiesAnalysisData : AnalysisData
-{
-    internal EvaluatedPropertiesAnalysisData(
-        string projectFilePath,
-        int? projectConfigurationId,
-        IReadOnlyDictionary<string, string> evaluatedProperties,
-        IReadOnlyDictionary<string, (string EnvVarValue, string File, int Line, int Column)> evaluatedEnvironmentVariables)
-        : base(projectFilePath, projectConfigurationId)
-    {
-        EvaluatedProperties = evaluatedProperties;
-        EvaluatedEnvironmentVariables = evaluatedEnvironmentVariables;
-    }
-
-    /// <summary>
-    /// Gets the evaluated properties of the project.
-    /// </summary>
-    public IReadOnlyDictionary<string, string> EvaluatedProperties { get; }
-
-    /// <summary>
-    /// Gets the evaluated environment variables and their metadata.
-    /// </summary>
-    public IReadOnlyDictionary<string, (string EnvVarValue, string File, int Line, int Column)> EvaluatedEnvironmentVariables { get; }
-}
diff --git a/src/Build/BuildCheck/OM/EvaluatedPropertiesCheckData.cs b/src/Build/BuildCheck/OM/EvaluatedPropertiesCheckData.cs
new file mode 100644
index 00000000000..fdf60017a4a
--- /dev/null
+++ b/src/Build/BuildCheck/OM/EvaluatedPropertiesCheckData.cs
@@ -0,0 +1,23 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// BuildCheck OM data representing the evaluated properties of a project.
+/// </summary>
+public class EvaluatedPropertiesCheckData : CheckData
+{
+    internal EvaluatedPropertiesCheckData(
+        string projectFilePath,
+        int? projectConfigurationId,
+        IReadOnlyDictionary<string, string> evaluatedProperties)
+        : base(projectFilePath, projectConfigurationId) => EvaluatedProperties = evaluatedProperties;
+
+    /// <summary>
+    /// Gets the evaluated properties of the project.
+    /// </summary>
+    public IReadOnlyDictionary<string, string> EvaluatedProperties { get; }
+}
diff --git a/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs b/src/Build/BuildCheck/OM/ParsedItemsCheckData.cs
similarity index 96%
rename from src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
rename to src/Build/BuildCheck/OM/ParsedItemsCheckData.cs
index 6d3cb3aa1fe..46c295514c3 100644
--- a/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
+++ b/src/Build/BuildCheck/OM/ParsedItemsCheckData.cs
@@ -42,9 +42,9 @@ public IEnumerable<ProjectItemElement> GetItemsOfType(string itemType)
 /// <summary>
 /// BuildCheck OM data representing the evaluated items of a project.
 /// </summary>
-public class ParsedItemsAnalysisData : AnalysisData
+public class ParsedItemsCheckData : CheckData
 {
-    internal ParsedItemsAnalysisData(
+    internal ParsedItemsCheckData(
         string projectFilePath,
         int? projectConfigurationId,
         ItemsHolder itemsHolder) :
@@ -56,7 +56,7 @@ internal ParsedItemsAnalysisData(
 /// <summary>
 /// BuildCheck OM data representing a task executed by a project.
 /// </summary>
-public sealed class TaskInvocationAnalysisData : AnalysisData
+public sealed class TaskInvocationCheckData : CheckData
 {
     /// <summary>
     /// Represents an input or output parameter of a task.
@@ -107,7 +107,7 @@ public IEnumerable<string> EnumerateStringValues()
         }
     }
 
-    internal TaskInvocationAnalysisData(
+    internal TaskInvocationCheckData(
         string projectFilePath,
         int? projectConfigurationId,
         ElementLocation taskInvocationLocation,
diff --git a/src/Build/BuildCheck/OM/ProjectProcessingDoneData.cs b/src/Build/BuildCheck/OM/ProjectProcessingDoneData.cs
deleted file mode 100644
index 79c1ece94be..00000000000
--- a/src/Build/BuildCheck/OM/ProjectProcessingDoneData.cs
+++ /dev/null
@@ -1,8 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using Microsoft.Build.Experimental.BuildCheck;
-
-namespace Microsoft.Build.Experimental.BuildCheck;
-
-internal class ProjectProcessingDoneData(string projectFilePath, int? projectConfigurationId) : AnalysisData(projectFilePath, projectConfigurationId);
diff --git a/src/Build/BuildCheck/OM/ProjectRequestProcessingDoneData.cs b/src/Build/BuildCheck/OM/ProjectRequestProcessingDoneData.cs
new file mode 100644
index 00000000000..3fa36d4cde5
--- /dev/null
+++ b/src/Build/BuildCheck/OM/ProjectRequestProcessingDoneData.cs
@@ -0,0 +1,15 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// This data captures end of single build request on a project.
+/// There can be multiple build request on a single project within single build
+/// (e.g. multiple targetting, or there can be explicit request for results of specific targets)
+/// </summary>
+/// <param name="projectFilePath"></param>
+/// <param name="projectConfigurationId"></param>
+internal class ProjectRequestProcessingDoneData(string projectFilePath, int? projectConfigurationId) : CheckData(projectFilePath, projectConfigurationId);
diff --git a/src/Build/BuildCheck/OM/PropertyReadData.cs b/src/Build/BuildCheck/OM/PropertyReadData.cs
index 4efb1107ffd..3599b381a5d 100644
--- a/src/Build/BuildCheck/OM/PropertyReadData.cs
+++ b/src/Build/BuildCheck/OM/PropertyReadData.cs
@@ -15,10 +15,10 @@ internal class PropertyReadData(
     string projectFilePath,
     int? projectConfigurationId,
     string propertyName,
-    IMsBuildElementLocation elementLocation,
+    IMSBuildElementLocation elementLocation,
     bool isUninitialized,
     PropertyReadContext propertyReadContext)
-    : AnalysisData(projectFilePath, projectConfigurationId)
+    : CheckData(projectFilePath, projectConfigurationId)
 {
     public PropertyReadData(
         string projectFilePath,
@@ -40,7 +40,7 @@ public PropertyReadData(
     /// <summary>
     /// Location of the property access.
     /// </summary>
-    public IMsBuildElementLocation ElementLocation { get; } = elementLocation;
+    public IMSBuildElementLocation ElementLocation { get; } = elementLocation;
 
     /// <summary>
     /// Indicates whether the property was accessed before being initialized.
diff --git a/src/Build/BuildCheck/OM/PropertyWriteData.cs b/src/Build/BuildCheck/OM/PropertyWriteData.cs
index f2148075e43..c15ac695031 100644
--- a/src/Build/BuildCheck/OM/PropertyWriteData.cs
+++ b/src/Build/BuildCheck/OM/PropertyWriteData.cs
@@ -15,9 +15,9 @@ internal class PropertyWriteData(
     string projectFilePath,
     int? projectConfigurationId,
     string propertyName,
-    IMsBuildElementLocation? elementLocation,
+    IMSBuildElementLocation? elementLocation,
     bool isEmpty)
-    : AnalysisData(projectFilePath, projectConfigurationId)
+    : CheckData(projectFilePath, projectConfigurationId)
 {
     public PropertyWriteData(string projectFilePath, int? projectConfigurationId, PropertyWriteInfo propertyWriteInfo)
         : this(projectFilePath,
@@ -37,7 +37,7 @@ public PropertyWriteData(string projectFilePath, int? projectConfigurationId, Pr
     /// If the location is null, it means that the property doesn't come from xml, but rather other sources
     ///  (environment variable, global property, toolset properties etc.).
     /// </summary>
-    public IMsBuildElementLocation? ElementLocation { get; } = elementLocation;
+    public IMSBuildElementLocation? ElementLocation { get; } = elementLocation;
 
     /// <summary>
     /// Was any value written? (E.g. if we set propA with value propB, while propB is undefined - the isEmpty will be true).
diff --git a/src/Build/CompatibilitySuppressions.xml b/src/Build/CompatibilitySuppressions.xml
index 5196ad5b466..588971270af 100644
--- a/src/Build/CompatibilitySuppressions.xml
+++ b/src/Build/CompatibilitySuppressions.xml
@@ -1,81 +1,557 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerConfiguration</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerConfiguration</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerConfiguration</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerConfiguration</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Info</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.#ctor(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.Create(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.AnalysisData.#ctor(System.String)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_BuildAnalyzerRule</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Info</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_Location</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData}})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData}})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData}})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.#ctor(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.Create(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_BuildAnalyzerRule</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_Location</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData}})</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData}})</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData}})</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.#ctor(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.Create(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.AnalysisData.#ctor(System.String)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_BuildAnalyzerRule</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Error</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_Location</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Warning</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData}})</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Error</Target>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData}})</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Warning</Target>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData}})</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
-  <!--
-    https://learn.microsoft.com/en-us/dotnet/fundamentals/apicompat/diagnostic-ids
-    Suppress PKV006 for net8.0 (The target framework is dropped in the latest version.)  -->
   <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net8.0</Target>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.#ctor(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.Create(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_BuildAnalyzerRule</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_Location</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData}})</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData}})</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData}})</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterBuildFinishedAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.BuildFinishedCheckData}})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEnvironmentVariableReadAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EnvironmentVariableCheckData}})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesCheckData}})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsCheckData}})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationCheckData}})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterBuildFinishedAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.BuildFinishedCheckData}})</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEnvironmentVariableReadAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EnvironmentVariableCheckData}})</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesCheckData}})</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsCheckData}})</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationCheckData}})</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterBuildFinishedAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.BuildFinishedCheckData}})</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEnvironmentVariableReadAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EnvironmentVariableCheckData}})</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesCheckData}})</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsCheckData}})</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationCheckData}})</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
 </Suppressions>
\ No newline at end of file
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 0799d38db90..fdc817b930c 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -419,16 +419,8 @@ private void ReadEachToolset(
 
                     Toolset toolset = ReadToolset(toolsVersion, globalProperties, initialPropertiesClone, accumulateProperties);
 
-                    // Register toolset paths into list of immutable directories
-                    // example: C:\Windows\Microsoft.NET\Framework
-                    string frameworksPathPrefix32 = existingRootOrNull(initialPropertiesClone.GetProperty("MSBuildFrameworkToolsPath32")?.EvaluatedValue?.Trim());
-                    FileClassifier.Shared.RegisterImmutableDirectory(frameworksPathPrefix32);
-                    // example: C:\Windows\Microsoft.NET\Framework64
-                    string frameworksPathPrefix64 = existingRootOrNull(initialPropertiesClone.GetProperty("MSBuildFrameworkToolsPath64")?.EvaluatedValue?.Trim());
-                    FileClassifier.Shared.RegisterImmutableDirectory(frameworksPathPrefix64);
-                    // example: C:\Windows\Microsoft.NET\FrameworkArm64
-                    string frameworksPathPrefixArm64 = existingRootOrNull(initialPropertiesClone.GetProperty("MSBuildFrameworkToolsPathArm64")?.EvaluatedValue?.Trim());
-                    FileClassifier.Shared.RegisterImmutableDirectory(frameworksPathPrefixArm64);
+                    FileClassifier.Shared.RegisterFrameworkLocations(p =>
+                        initialPropertiesClone.GetProperty(p)?.EvaluatedValue);
 
                     if (toolset != null)
                     {
@@ -436,28 +428,6 @@ private void ReadEachToolset(
                     }
                 }
             }
-
-            string existingRootOrNull(string path)
-            {
-                if (!string.IsNullOrEmpty(path))
-                {
-                    try
-                    {
-                        path = Directory.GetParent(FileUtilities.EnsureNoTrailingSlash(path))?.FullName;
-
-                        if (!Directory.Exists(path))
-                        {
-                            path = null;
-                        }
-                    }
-                    catch
-                    {
-                        path = null;
-                    }
-                }
-
-                return path;
-            }
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 33513cc27ec..7e400d10138 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -343,7 +343,7 @@ internal static void Evaluate(
                 IEnumerable properties = null;
                 IEnumerable items = null;
 
-                if (evaluator._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)
+                if (evaluator._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent)
                 {
                     globalProperties = evaluator._data.GlobalPropertiesDictionary;
                     properties = Traits.LogAllEnvironmentVariables ? evaluator._data.Properties : evaluator.FilterOutEnvironmentDerivedProperties(evaluator._data.Properties);
@@ -614,13 +614,16 @@ private static ProjectTargetInstance ReadNewTargetElement(ProjectTargetElement t
         private void Evaluate()
         {
             string projectFile = String.IsNullOrEmpty(_projectRootElement.ProjectFileLocation.File) ? "(null)" : _projectRootElement.ProjectFileLocation.File;
-            using (AssemblyLoadsTracker.StartTracking(_evaluationLoggingContext, AssemblyLoadingContext.Evaluation))
             using (_evaluationProfiler.TrackPass(EvaluationPass.TotalEvaluation))
             {
                 ErrorUtilities.VerifyThrow(_data.EvaluationId == BuildEventContext.InvalidEvaluationId, "There is no prior evaluation ID. The evaluator data needs to be reset at this point");
                 _data.EvaluationId = _evaluationLoggingContext.BuildEventContext.EvaluationId;
                 _evaluationLoggingContext.LogProjectEvaluationStarted();
 
+                // Track loads only after start of evaluation was actually logged
+                using var assemblyLoadsTracker =
+                    AssemblyLoadsTracker.StartTracking(_evaluationLoggingContext, AssemblyLoadingContext.Evaluation);
+
                 _logProjectImportedEvents = Traits.Instance.EscapeHatches.LogProjectImports;
 
                 int globalPropertiesCount;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 7f2680b75ab..ac58b5a67a2 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -340,7 +340,7 @@ internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem, Loggi
         /// Properties may be null.
         ///
         /// Used for tests and for ToolsetReader - that operates agnostic on the project
-        ///   - so no logging context is passed, and no BuildCheck analysis will be executed.
+        ///   - so no logging context is passed, and no BuildCheck check will be executed.
         /// </summary>
         internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem)
         : this(properties, fileSystem, null)
@@ -394,7 +394,7 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMeta
         /// Any or all may be null.
         ///
         /// This is for the purpose of evaluations through API calls, that might not be able to pass the logging context
-        ///  - BuildCheck analysis won't be executed for those.
+        ///  - BuildCheck checking won't be executed for those.
         /// (for one of the calls we can actually pass IDataConsumingContext - as we have logging service and project)
         ///
         /// </summary>
@@ -1554,12 +1554,12 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
 
                 object propertyValue;
 
-                bool isArtifical = property == null && ((endIndex - startIndex) >= 7) &&
+                bool isArtificial = property == null && ((endIndex - startIndex) >= 7) &&
                                    MSBuildNameIgnoreCaseComparer.Default.Equals("MSBuild", propertyName, startIndex, 7);
 
-                propertiesUseTracker.TrackRead(propertyName, startIndex, endIndex, elementLocation, property == null, isArtifical);
+                propertiesUseTracker.TrackRead(propertyName, startIndex, endIndex, elementLocation, property == null, isArtificial);
 
-                if (isArtifical)
+                if (isArtificial)
                 {
                     // It could be one of the MSBuildThisFileXXXX properties,
                     // whose values vary according to the file they are in.
@@ -3569,8 +3569,14 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                         try
                         {
                             // First attempt to recognize some well-known functions to avoid binding
-                            // and potential first-chance MissingMethodExceptions
+                            // and potential first-chance MissingMethodExceptions.
                             wellKnownFunctionSuccess = TryExecuteWellKnownFunction(out functionResult, objectInstance, args);
+
+                            if (!wellKnownFunctionSuccess)
+                            {
+                                // Some well-known functions need evaluated value from properties.
+                                wellKnownFunctionSuccess = TryExecuteWellKnownFunctionWithPropertiesParam(properties, out functionResult, objectInstance, args);
+                            }
                         }
                         // we need to preserve the same behavior on exceptions as the actual binder
                         catch (Exception ex)
@@ -3667,6 +3673,27 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                 }
             }
 
+            private bool TryExecuteWellKnownFunctionWithPropertiesParam(IPropertyProvider<T> properties, out object returnVal, object objectInstance, object[] args)
+            {
+                returnVal = null;
+
+                if (_receiverType == typeof(IntrinsicFunctions))
+                {
+                    if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RegisterBuildCheck), StringComparison.OrdinalIgnoreCase))
+                    {
+                        string projectPath = properties.GetProperty("MSBuildProjectFullPath")?.EvaluatedValue ?? string.Empty;
+                        ErrorUtilities.VerifyThrow(_loggingContext != null, $"The logging context is missed. {nameof(IntrinsicFunctions.RegisterBuildCheck)} can not be invoked.");
+                        if (TryGetArg(args, out string arg0))
+                        {
+                            returnVal = IntrinsicFunctions.RegisterBuildCheck(projectPath, arg0, _loggingContext);
+                            return true;
+                        }
+                    }
+                }
+
+                return false;
+            }
+
             /// <summary>
             /// Shortcut to avoid calling into binding if we recognize some most common functions.
             /// Binding is expensive and throws first-chance MissingMethodExceptions, which is
@@ -3932,16 +3959,6 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                     }
                     else if (_receiverType == typeof(IntrinsicFunctions))
                     {
-                        if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RegisterBuildCheck), StringComparison.OrdinalIgnoreCase))
-                        {
-                            ErrorUtilities.VerifyThrow(_loggingContext != null, $"The logging context is missed. {nameof(IntrinsicFunctions.RegisterBuildCheck)} can not be invoked.");
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.RegisterBuildCheck(arg0, _loggingContext);
-                                return true;
-                            }
-                        }
-
                         if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.EnsureTrailingSlash), StringComparison.OrdinalIgnoreCase))
                         {
                             if (TryGetArg(args, out string arg0))
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index d9de22f294e..4a4a183d24f 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -693,17 +693,17 @@ public static string GetMSBuildExtensionsPath()
 
         public static bool IsRunningFromVisualStudio() => BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio;
 
-        public static bool RegisterBuildCheck(string pathToAssembly, LoggingContext loggingContext)
+        public static bool RegisterBuildCheck(string projectPath, string pathToAssembly, LoggingContext loggingContext)
         {
             pathToAssembly = FileUtilities.GetFullPathNoThrow(pathToAssembly);
             if (File.Exists(pathToAssembly))
             {
-                loggingContext.LogBuildEvent(new BuildCheckAcquisitionEventArgs(pathToAssembly));
+                loggingContext.LogBuildEvent(new BuildCheckAcquisitionEventArgs(pathToAssembly, projectPath));
 
                 return true;
             }
 
-            loggingContext.LogComment(MessageImportance.Low, "CustomAnalyzerAssemblyNotExist", pathToAssembly);
+            loggingContext.LogComment(MessageImportance.Low, "CustomCheckAssemblyNotExist", pathToAssembly);
 
             return false;
         }
diff --git a/src/Build/Graph/GraphBuildRequestData.cs b/src/Build/Graph/GraphBuildRequestData.cs
index 7762547528b..31e8cae7c7e 100644
--- a/src/Build/Graph/GraphBuildRequestData.cs
+++ b/src/Build/Graph/GraphBuildRequestData.cs
@@ -6,6 +6,7 @@
 using System.Linq;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Graph
diff --git a/src/Build/Graph/GraphBuildSubmission.cs b/src/Build/Graph/GraphBuildSubmission.cs
index 270134614f5..164cfc8e377 100644
--- a/src/Build/Graph/GraphBuildSubmission.cs
+++ b/src/Build/Graph/GraphBuildSubmission.cs
@@ -71,6 +71,11 @@ protected internal override void CheckResultValidForCompletion(GraphBuildResult
         protected internal override GraphBuildResult CreateFailedResult(Exception exception)
             => new(SubmissionId, exception);
 
+        /// <summary>
+        /// Whether the build has started.
+        /// </summary>
+        internal override bool IsStarted { get; set; }
+
         // WARNING!: Do not remove the below proxy properties.
         //  They are required to make the OM forward compatible
         //  (code built against this OM should run against binaries with previous version of OM).
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index 22921695dea..afda13dd6e5 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -40,5 +40,11 @@ public enum BinaryLogRecordKind
         TaskParameter,
         ResponseFileUsed,
         AssemblyLoad,
+        BuildCheckMessage,
+        BuildCheckWarning,
+        BuildCheckError,
+        BuildCheckTracing,
+        BuildCheckAcquisition,
+        BuildSubmissionStarted,
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index fb21e16522d..56efb97f9a2 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -75,13 +75,17 @@ public sealed class BinaryLogger : ILogger
         //   - TaskParameterEventArgs: Added ParameterName and PropertyName properties
         // version 22:
         //    - extend EnvironmentVariableRead with location where environment variable was used.
+        // version 23:
+        //    - new record kinds: BuildCheckMessageEvent, BuildCheckWarningEvent, BuildCheckErrorEvent,
+        //    BuildCheckTracingEvent, BuildCheckAcquisitionEvent, BuildSubmissionStartedEvent
+
         // This should be never changed.
         // The minimum version of the binary log reader that can read log of above version.
         internal const int ForwardCompatibilityMinimalVersion = 18;
 
         // The current version of the binary log representation.
         // Changes with each update of the binary log format.
-        internal const int FileFormatVersion = 22;
+        internal const int FileFormatVersion = 23;
 
         // The minimum version of the binary log reader that can read log of above version.
         // This should be changed only when the binary log format is changed in a way that would prevent it from being
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index f5affd98478..9de51e2a05d 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -6,11 +6,14 @@
 using System.Collections.Generic;
 using System.IO;
 using System.IO.Compression;
+using System.Linq;
 using System.Reflection;
 using System.Runtime.CompilerServices;
 using System.Text;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
@@ -294,6 +297,7 @@ void HandleError(FormatErrorMessage msgFactory, bool noThrow, ReaderErrorType re
             {
                 BinaryLogRecordKind.BuildStarted => ReadBuildStartedEventArgs(),
                 BinaryLogRecordKind.BuildFinished => ReadBuildFinishedEventArgs(),
+                BinaryLogRecordKind.BuildSubmissionStarted => ReadBuildSubmissionStartedEventArgs(),
                 BinaryLogRecordKind.ProjectStarted => ReadProjectStartedEventArgs(),
                 BinaryLogRecordKind.ProjectFinished => ReadProjectFinishedEventArgs(),
                 BinaryLogRecordKind.TargetStarted => ReadTargetStartedEventArgs(),
@@ -316,6 +320,11 @@ void HandleError(FormatErrorMessage msgFactory, bool noThrow, ReaderErrorType re
                 BinaryLogRecordKind.UninitializedPropertyRead => ReadUninitializedPropertyReadEventArgs(),
                 BinaryLogRecordKind.PropertyInitialValueSet => ReadPropertyInitialValueSetEventArgs(),
                 BinaryLogRecordKind.AssemblyLoad => ReadAssemblyLoadEventArgs(),
+                BinaryLogRecordKind.BuildCheckMessage => ReadBuildCheckMessageEventArgs(),
+                BinaryLogRecordKind.BuildCheckWarning => ReadBuildCheckWarningEventArgs(),
+                BinaryLogRecordKind.BuildCheckError => ReadBuildCheckErrorEventArgs(),
+                BinaryLogRecordKind.BuildCheckTracing => ReadBuildCheckTracingEventArgs(),
+                BinaryLogRecordKind.BuildCheckAcquisition => ReadBuildCheckAcquisitionEventArgs(),
                 _ => null
             };
 
@@ -497,6 +506,7 @@ private IDictionary<string, string> GetNameValueList(int id)
         }
 
         private readonly StringReadEventArgs stringReadEventArgs = new StringReadEventArgs(string.Empty);
+
         private void ReadStringRecord()
         {
             string text = ReadString();
@@ -617,6 +627,29 @@ private BuildEventArgs ReadBuildFinishedEventArgs()
             return e;
         }
 
+        private BuildEventArgs ReadBuildSubmissionStartedEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+
+            IDictionary<string, string>? globalProperties = null;
+            globalProperties = ReadStringDictionary() ?? new Dictionary<string, string>();
+
+            var entryProjectsFullPath = ReadStringIEnumerable() ?? Enumerable.Empty<string>();
+            var targetNames = ReadStringIEnumerable() ?? Enumerable.Empty<string>();
+            var flags = (BuildRequestDataFlags)ReadInt32();
+            var submissionId = ReadInt32();
+
+            var e = new BuildSubmissionStartedEventArgs(
+                (IReadOnlyDictionary<string, string?>)globalProperties,
+                entryProjectsFullPath,
+                targetNames,
+                flags,
+                submissionId);
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
         private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
@@ -1209,6 +1242,46 @@ private AssemblyLoadBuildEventArgs ReadAssemblyLoadEventArgs()
             return e;
         }
 
+        private BuildEventArgs ReadBuildCheckEventArgs<T>(Func<BuildEventArgsFields, string, T> createEvent)
+            where T : BuildEventArgs
+        {
+            var fields = ReadBuildEventArgsFields();
+            var e = createEvent(fields, fields.Message);
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
+        private BuildEventArgs ReadBuildCheckMessageEventArgs() => ReadBuildCheckEventArgs((_, rawMessage) => new BuildCheckResultMessage(rawMessage));
+
+        private BuildEventArgs ReadBuildCheckWarningEventArgs() => ReadBuildCheckEventArgs((fields, rawMessage) => new BuildCheckResultWarning(rawMessage, fields.Code));
+
+        private BuildEventArgs ReadBuildCheckErrorEventArgs() => ReadBuildCheckEventArgs((fields, rawMessage) => new BuildCheckResultError(rawMessage, fields.Code));
+
+        private BuildEventArgs ReadBuildCheckTracingEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+            var rawTracingData = ReadStringDictionary() ?? new Dictionary<string, string>();
+
+            var e = new BuildCheckTracingEventArgs(rawTracingData.ToDictionary(
+                kvp => kvp.Key,
+                kvp => TimeSpan.FromTicks(long.Parse(kvp.Value))));
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
+        private BuildEventArgs ReadBuildCheckAcquisitionEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+            var acquisitionPath = ReadString();
+            var projectPath = ReadString();
+            var e = new BuildCheckAcquisitionEventArgs(acquisitionPath, projectPath);
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
         /// <summary>
         /// For errors and warnings these 8 fields are written out explicitly
         /// (their presence is not marked as a bit in the flags). So we have to
@@ -1555,6 +1628,28 @@ private ITaskItem ReadTaskItem()
             return list;
         }
 
+        private IEnumerable<string>? ReadStringIEnumerable()
+        {
+            int count = ReadInt32();
+            if (count == 0)
+            {
+                return null;
+            }
+
+            var list = new string[count];
+
+            for (int i = 0; i < count; i++)
+            {
+                string? item = ReadDeduplicatedString();
+                if (item is not null)
+                {
+                    list[i] = item;
+                }
+            }
+
+            return list;
+        }
+
         private string ReadString()
         {
             string text = _binaryReader.ReadString();
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 6ee4aff9d74..b5d7f6fb73c 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
@@ -123,7 +124,7 @@ internal class BuildEventArgsWriter
         /// <param name="binaryWriter">A BinaryWriter to write the BuildEventArgs instances to</param>
         public BuildEventArgsWriter(BinaryWriter binaryWriter)
         {
-            this.originalStream = binaryWriter.BaseStream;
+            originalStream = binaryWriter.BaseStream;
 
             // this doesn't exceed 30K for smaller binlogs so seems like a reasonable
             // starting point to avoid reallocations in the common case
@@ -183,6 +184,7 @@ Base types and inheritance ("EventArgs" suffix omitted):
                     TargetFinished
                     ProjectStarted
                     ProjectFinished
+                    BuildSubmissionStarted
                     BuildStarted
                     BuildFinished
                     ProjectEvaluationStarted
@@ -210,10 +212,13 @@ private BinaryLogRecordKind WriteCore(BuildEventArgs e)
                 case BuildWarningEventArgs buildWarning: return Write(buildWarning);
                 case ProjectStartedEventArgs projectStarted: return Write(projectStarted);
                 case ProjectFinishedEventArgs projectFinished: return Write(projectFinished);
+                case BuildSubmissionStartedEventArgs buildSubmissionStarted: return Write(buildSubmissionStarted);
                 case BuildStartedEventArgs buildStarted: return Write(buildStarted);
                 case BuildFinishedEventArgs buildFinished: return Write(buildFinished);
                 case ProjectEvaluationStartedEventArgs projectEvaluationStarted: return Write(projectEvaluationStarted);
                 case ProjectEvaluationFinishedEventArgs projectEvaluationFinished: return Write(projectEvaluationFinished);
+                case BuildCheckTracingEventArgs buildCheckTracing: return Write(buildCheckTracing);
+                case BuildCheckAcquisitionEventArgs buildCheckAcquisition: return Write(buildCheckAcquisition);
                 default:
                     // convert all unrecognized objects to message
                     // and just preserve the message
@@ -309,6 +314,44 @@ private BinaryLogRecordKind Write(ProjectEvaluationStartedEventArgs e)
             return BinaryLogRecordKind.ProjectEvaluationStarted;
         }
 
+        private BinaryLogRecordKind Write(BuildCheckResultMessage e)
+        {
+            WriteBuildEventArgsFields(e, writeMessage: true);
+
+            return BinaryLogRecordKind.BuildCheckMessage;
+        }
+
+        private BinaryLogRecordKind Write(BuildCheckResultWarning e)
+        {
+            WriteBuildEventArgsFields(e, writeMessage: true);
+
+            return BinaryLogRecordKind.BuildCheckWarning;
+        }
+
+        private BinaryLogRecordKind Write(BuildCheckResultError e)
+        {
+            WriteBuildEventArgsFields(e, writeMessage: true);
+
+            return BinaryLogRecordKind.BuildCheckError;
+        }
+
+        private BinaryLogRecordKind Write(BuildCheckTracingEventArgs e)
+        {
+            WriteBuildEventArgsFields(e, writeMessage: false);
+            WriteProperties(e.TracingData);
+
+            return BinaryLogRecordKind.BuildCheckTracing;
+        }
+
+        private BinaryLogRecordKind Write(BuildCheckAcquisitionEventArgs e)
+        {
+            WriteBuildEventArgsFields(e, writeMessage: false);
+            WriteDeduplicatedString(e.AcquisitionPath);
+            WriteDeduplicatedString(e.ProjectPath);
+
+            return BinaryLogRecordKind.BuildCheckAcquisition;
+        }
+
         private BinaryLogRecordKind Write(ProjectEvaluationFinishedEventArgs e)
         {
             WriteBuildEventArgsFields(e, writeMessage: false);
@@ -336,6 +379,18 @@ private BinaryLogRecordKind Write(ProjectEvaluationFinishedEventArgs e)
             return BinaryLogRecordKind.ProjectEvaluationFinished;
         }
 
+        private BinaryLogRecordKind Write(BuildSubmissionStartedEventArgs e)
+        {
+            WriteBuildEventArgsFields(e, writeMessage: false);
+            Write(e.GlobalProperties);
+            WriteStringList(e.EntryProjectsFullPath);
+            WriteStringList(e.TargetNames);
+            Write((int)e.Flags);
+            Write(e.SubmissionId);
+
+            return BinaryLogRecordKind.BuildSubmissionStarted;
+        }
+
         private BinaryLogRecordKind Write(ProjectStartedEventArgs e)
         {
             WriteBuildEventArgsFields(e, writeMessage: false);
@@ -424,6 +479,11 @@ private BinaryLogRecordKind Write(TaskFinishedEventArgs e)
 
         private BinaryLogRecordKind Write(BuildErrorEventArgs e)
         {
+            if (e is BuildCheckResultError buildCheckError)
+            {
+                return Write(buildCheckError);
+            }
+
             WriteBuildEventArgsFields(e);
             WriteArguments(e.RawArguments);
             WriteDeduplicatedString(e.Subcategory);
@@ -440,6 +500,11 @@ private BinaryLogRecordKind Write(BuildErrorEventArgs e)
 
         private BinaryLogRecordKind Write(BuildWarningEventArgs e)
         {
+            if (e is BuildCheckResultWarning buildCheckWarning)
+            {
+                return Write(buildCheckWarning);
+            }
+
             WriteBuildEventArgsFields(e);
             WriteArguments(e.RawArguments);
             WriteDeduplicatedString(e.Subcategory);
@@ -469,6 +534,8 @@ private BinaryLogRecordKind Write(BuildMessageEventArgs e)
                 case PropertyInitialValueSetEventArgs propertyInitialValueSet: return Write(propertyInitialValueSet);
                 case CriticalBuildMessageEventArgs criticalBuildMessage: return Write(criticalBuildMessage);
                 case AssemblyLoadBuildEventArgs assemblyLoad: return Write(assemblyLoad);
+                case BuildCheckResultMessage buildCheckMessage: return Write(buildCheckMessage);
+
                 default: // actual BuildMessageEventArgs
                     WriteMessageFields(e, writeImportance: true);
                     return BinaryLogRecordKind.Message;
@@ -560,6 +627,7 @@ private BinaryLogRecordKind Write(ResponseFileUsedEventArgs e)
             WriteDeduplicatedString(e.ResponseFilePath);
             return BinaryLogRecordKind.ResponseFileUsed;
         }
+
         private BinaryLogRecordKind Write(TaskCommandLineEventArgs e)
         {
             WriteMessageFields(e, writeMessage: false, writeImportance: true);
@@ -1044,6 +1112,16 @@ private void Write(IEnumerable<KeyValuePair<string, string>> keyValuePairs)
             nameValueListBuffer.Clear();
         }
 
+        private void WriteStringList(IEnumerable<string> items)
+        {
+            int length = items.Count();
+            Write(length);
+            foreach (string entry in items)
+            {
+                WriteDeduplicatedString(entry);
+            }
+        }
+
         private void WriteNameValueList()
         {
             if (nameValueListBuffer.Count == 0)
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 741e731b9ad..53df24ba2d9 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -2107,25 +2107,25 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
     </comment>
   </data>
-  <data name="CustomAnalyzerSuccessfulAcquisition" xml:space="preserve">
-    <value>Custom analyzer rule: '{0}' has been registered successfully.</value>
-    <comment>The message is emitted on successful loading of the custom analyzer rule in process.</comment>
+  <data name="CustomCheckSuccessfulAcquisition" xml:space="preserve">
+    <value>Custom check rule: '{0}' has been registered successfully.</value>
+    <comment>The message is emitted on successful loading of the custom check rule in process.</comment>
   </data>
-  <data name="CustomAnalyzerFailedAcquisition" xml:space="preserve">
-    <value>Failed to register the custom analyzer: '{0}'.</value>
-    <comment>The message is emitted on failed loading of the custom analyzer in process.</comment>
+  <data name="CustomCheckFailedAcquisition" xml:space="preserve">
+    <value>Failed to register the custom check: '{0}'.</value>
+    <comment>The message is emitted on failed loading of the custom check in process.</comment>
   </data>
-  <data name="CustomAnalyzerFailedRuleLoading" xml:space="preserve">
-    <value>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</value>
-    <comment>The message is emitted on failed loading of the custom analyzer rule in process.</comment>
+  <data name="CustomCheckFailedRuleLoading" xml:space="preserve">
+    <value>Failed to instantiate the custom check rule with the following exception: '{0}'.</value>
+    <comment>The message is emitted on failed loading of the custom check rule in process.</comment>
   </data>
-  <data name="CustomAnalyzerAssemblyNotExist" xml:space="preserve">
-    <value>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</value>
-    <comment>The message is emitted when the custom analyzer assembly can not be found.</comment>
+  <data name="CustomCheckAssemblyNotExist" xml:space="preserve">
+    <value>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</value>
+    <comment>The message is emitted when the custom check assembly can not be found.</comment>
   </data>
-  <data name="CustomAnalyzerBaseTypeNotAssignable" xml:space="preserve">
-    <value>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</value>
-    <comment>The message is emitted when the custom analyzer assembly can not be successfully registered.</comment>
+  <data name="CustomCheckBaseTypeNotAssignable" xml:space="preserve">
+    <value>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</value>
+    <comment>The message is emitted when the custom check assembly can not be successfully registered.</comment>
   </data>
   <data name="TaskAssemblyLocationMismatch" xml:space="preserve">
     <value>Task assembly was loaded from '{0}' while the desired location was '{1}'.</value>
@@ -2136,8 +2136,8 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="BuildCheckEnabled" xml:space="preserve">
     <value>The BuildCheck is enabled for this build.</value>
   </data>
-  <data name="CustomAnalyzerRegistered" xml:space="preserve">
-    <value>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</value>
+  <data name="CustomCheckRegistered" xml:space="preserve">
+    <value>The custom check: '{0}' is registered for the build from the location: '{1}'.</value>
   </data>
   <!--
         The Build message bucket is: MSB4000 - MSB4999
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 9bb7feac68f..c4eeb22066d 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Nepodařilo se najít zadané sestavení vlastního analyzátoru: {0}. Zkontrolujte prosím, jestli existuje.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Nepodařilo se načíst typ vlastního analyzátoru: {0} ze sestavení: {1}. Ujistěte se, že dědí základní třídu Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Pokud se nemá jednat o vlastní analyzátor, neměl by být exponovaný. Další informace: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Nepodařilo se zaregistrovat vlastní analyzátor: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Nepovedlo se vytvořit instanci pravidla vlastního analyzátoru s následující výjimkou: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">Vlastní analyzátor {0} je pro build zaregistrován z umístění: {1}.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Pravidlo vlastního analyzátoru: {0} se úspěšně zaregistrovalo.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="translated">Nepodařilo se najít zadané sestavení vlastní kontroly: {0}. Zkontrolujte prosím, jestli existuje.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Nepodařilo se načíst typ vlastní kontroly: {0} ze sestavení: {1}. Ujistěte se, že dědí základní třídu Microsoft.Build.Experimental.BuildCheck.Check. Pokud se nemá jednat o vlastní kontrolu, neměl by být exponovaný. Další informace: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="translated">Nepodařilo se zaregistrovat vlastní kontrolu: {0}.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="translated">Nepovedlo se vytvořit instanci pravidla vlastní kontroly s následující výjimkou: {0}.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="translated">Vlastní kontrola {0} je pro build zaregistrován z umístění: {1}.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="translated">Pravidlo vlastní kontroly: {0} se úspěšně zaregistrovalo.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index d188d5430bb..236caffc6a1 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Fehler beim Suchen der angegebenen benutzerdefinierten Analysetoolassembly: {0}. Überprüfen Sie, ob sie vorhanden ist.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Fehler beim Laden des benutzerdefinierten Analysetooltyps „{0}“ aus der Assembly: {1}. Stellen Sie sicher, dass es die Basisklasse „Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer“ erbt. Wenn es sich nicht um ein benutzerdefiniertes Analysetool handelt, sollte es nicht verfügbar gemacht werden. Weitere Informationen: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Fehler beim Registrieren des benutzerdefinierten Analysetools: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Fehler beim Instanziieren der benutzerdefinierten Analyseregel. Ausnahme: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">Das benutzerdefinierte Analysetool „{0}“ ist für den Build vom Folgenden aus registriert: {1}.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Die benutzerdefinierte Analyseregel „{0}“ wurde erfolgreich registriert.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="translated">Fehler beim Suchen der angegebenen benutzerdefinierten Prüfassembly: {0}. Überprüfen Sie, ob sie vorhanden ist.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Fehler beim Laden des benutzerdefinierten Prüftyps „{0}“ aus der Assembly: {1}. Stellen Sie sicher, dass es die Basisklasse „Microsoft.Build.Experimental.BuildCheck.Check“ erbt. Wenn es sich nicht um eine benutzerdefinierte Überprüfung handelt, sollte es nicht verfügbar gemacht werden. Weitere Informationen: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="translated">Fehler beim Registrieren der benutzerdefinierten Überprüfung: „{0}”.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="translated">Fehler beim Instanziieren der benutzerdefinierten Prüfregel. Ausnahme: {0}.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="translated">Dies benutzerdefinierte Überprüfung „{0}“ ist für den Build vom Folgenden aus registriert: „{1}”.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="translated">Die benutzerdefinierte Prüfregel „{0}“ wurde erfolgreich registriert.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index c1dac10107d..0191965a4d8 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">No se pudo encontrar el ensamblado del analizador personalizado especificado: '{0}'. Compruebe si existe.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">No se pudo cargar el tipo de analizador personalizado: '{0}' del ensamblado: '{1}'. Asegúrese de que hereda la clase base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Si no está pensado para ser un analizador personalizado, no debe exponerse. Más información: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">No se pudo registrar el analizador personalizado: '{0}'.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">No se pudo crear una instancia de la regla del analizador personalizado con la siguiente excepción: '{0}'.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">El analizador personalizado: '{0}' está registrado para la compilación desde la ubicación: '{1}'.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">La regla del analizador personalizado: '{0}' se ha registrado correctamente.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="translated">No se pudo encontrar el ensamblado de comprobación personalizado especificado: "{0}". Compruebe si existe.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">No se pudo cargar el tipo de comprobación personalizado: "{0}" desde el ensamblado: "{1}". Asegúrese de que hereda la clase base Microsoft.Build.Experimental.BuildCheck.Check. Si no está pensado para ser una comprobación personalizada, no debe exponerse. Más información: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="translated">No se pudo registrar la comprobación personalizada: "{0}".</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="translated">No se pudo crear una instancia de la regla de comprobación personalizada con la siguiente excepción: "{0}".</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="translated">La comprobación personalizada: "{0}" está registrada para la compilación desde la ubicación: "{1}".</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="translated">La regla de comprobación personalizada: "{0}" se ha registrado correctamente.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 9e0deee0b2a..68e56fa1b5f 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Désolé... Nous n’avons pas pu trouver l’assembly d’analyseur personnalisé : « {0} ». Veuillez vérifier s’il existe.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Désolé... Nous n’avons pas pu charger le type d’analyseur personnalisé : « {0} » à partir de l’assembly : « {1} ». Vérifiez qu’il hérite de la classe de base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. S’il n’est pas destiné à être un analyseur personnalisé, il ne doit pas être exposé. Plus d’informations : https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Désolé... Nous n’avons pas pu inscrire l’analyseur personnalisé : « {0} ».</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Désolé... Nous n’avons pas pu instancier la règle d’analyseur personnalisé avec l’exception suivante : « {0} ».</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">L’analyseur personnalisé : « {0} » est inscrit pour la build à partir de l’emplacement : « {1} ».</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Règle de l’analyseur personnalisé : {0} a été correctement inscrit.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="translated">Impossible de trouver l’assembly de vérification personnalisé spécifié : «{0}». Veuillez vérifier s’il existe.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Échec du chargement du type de vérification personnalisé «{0}» à partir de l’assembly : «{1}». Assurez-vous qu’il hérite de la classe de base Microsoft.Build.Experimental.BuildCheck.Check. S’il ne s’agit pas d’une vérification personnalisée, elle ne doit pas être exposée. Plus d’informations : https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="translated">Échec de l’inscription de la vérification personnalisée : «{0}».</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="translated">Échec de l’instanciation de la règle de vérification personnalisée avec l’exception suivante : «{0}».</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="translated">La vérification personnalisée «{0}» est inscrite pour la build à partir de l’emplacement : «{1}».</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="translated">Règle de vérification personnalisée : «{0}» a été correctement inscrite.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 3a11303b9de..c8c48d62be5 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Impossibile trovare l'assembly dell'analizzatore personalizzato specificato: '{0}'. Verificare se esiste.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Non è stato possibile caricare il tipo di analizzatore diagnostico personalizzato: '{0}' dall'assembly: '{1}'. Assicurarsi che erediti la classe di base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Se non è destinato a essere un analizzatore personalizzato, non deve essere esposto. Per altre informazioni: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Impossibile registrare l'analizzatore personalizzato: '{0}'.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Impossibile creare un'istanza della regola dell'analizzatore personalizzato con l'eccezione seguente: '{0}'.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">Analizzatore personalizzato: '{0}' registrato per la compilazione dal percorso: '{1}'.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Regola dell'analizzatore personalizzato: '{0}' è stata registrata.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="translated">Impossibile trovare l'assembly di controllo personalizzato specificato: “{0}”. Verificare se esiste.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Non è stato possibile caricare il tipo di controllo personalizzato: “{0}” dall'assembly: “{1}”. Assicurarsi che erediti la classe di base Microsoft.Build.Experimental.BuildCheck.Check. Se non è destinato a essere un controllo personalizzato, non deve essere esposto. Per altre informazioni: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="translated">Impossibile registrare il controllo personalizzato: “{0}”.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="translated">Non è stato possibile creare un'istanza della regola di controllo personalizzata con l'eccezione seguente: “{0}”.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="translated">Il controllo personalizzato “{0}” è registrato per la compilazione dal percorso “{1}”.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="translated">La regola di controllo personalizzata “{0}” è stata registrata correttamente.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index ee8227044f8..ba6b67d85e9 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">指定されたカスタム アナライザー アセンブリが見つかりませんでした: '{0}'。存在するかどうか確認してください。</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">カスタム アナライザーの種類を読み込めませんでした: アセンブリ '{1}' の '{0}'。Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基底クラスを継承していることを確認してください。カスタム アナライザーを意図していない場合は、公開しないでください。詳細情報: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">カスタム アナライザーを登録できませんでした: '{0}'。</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">次の例外により、カスタム アナライザー ルールのインスタンスを作成できませんでした: '{0}'。</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">カスタム アナライザー'{0}' は、場所 '{1}' からビルドに登録されています。</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">カスタム アナライザー ルール: '{0}' が正常に登録されました。</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="translated">指定されたカスタム チェック アセンブリが見つかりませんでした: '{0}'。存在するかどうか確認してください。</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">カスタム チェックの種類を読み込めませんでした: アセンブリ '{1}' の '{0}'。Microsoft.Build.Experimental.BuildCheck.Check 基底クラスを継承していることを確認してください。カスタム チェックを意図していない場合は、公開しないでください。詳細情報: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="translated">カスタム チェックを登録できませんでした: '{0}'。</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="translated">次の例外により、カスタム チェック ルールをインスタンス化できませんでした: '{0}'。</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="translated">カスタム チェック '{0}' は、場所 '{1}' からビルドに登録されています。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="translated">カスタム チェック ルール: '{0}' が正常に登録されました。</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index f517d92f530..6b348a4fe7e 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">지정한 사용자 지정 분석기 어셈블리 '{0}'을(를) 찾지 못했습니다. 있는지 확인하세요.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">'{1}' 어셈블리에서 사용자 지정 분석기 유형 '{0}'을(를) 로드하지 못했습니다. Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 기본 클래스를 상속해야 합니다. 사용자 지정 분석기가 아닌 경우 노출되지 않아야 합니다. 추가 정보: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">사용자 지정 분석기 '{0}'을(를) 등록하지 못했습니다.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">'{0}' 예외로 인해 사용자 지정 분석기 규칙을 인스턴스화하지 못했습니다.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">사용자 지정 분석기 '{0}'이(가) '{1}' 위치의 빌드에 등록되었습니다.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">사용자 지정 분석기 규칙 '{0}'이(가) 등록되었습니다.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="translated">지정한 사용자 지정 검사 어셈블리를 찾지 못했습니다. '{0}'. 있는지 확인하세요.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">어셈블리에서 사용자 지정 검사 유형 '{0}'을(를) 로드하지 못했습니다. '{1}'. Microsoft.Build.Experimental.BuildCheck.Check 기본 클래스를 상속해야 합니다. 사용자 지정 검사가 아닌 경우 노출되지 않아야 합니다. 추가 정보: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="translated">사용자 지정 검사를 등록하지 못했습니다. '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="translated">다음 예외로 인해 사용자 지정 검사 규칙을 인스턴스화하지 못했습니다. '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="translated">사용자 지정 검사 '{0}'이(가) 다음 위치의 빌드에 등록되었습니다. '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="translated">사용자 지정 검사 규칙 '{0}'이(가) 등록되었습니다.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index b7b9a18f770..a80e09f0a00 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Nie można odnaleźć określonego zestawu analizatora niestandardowego: „{0}”. Sprawdź, czy istnieje.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Nie udało się załadować niestandardowego analizatora typu: „{0}” z zestawu: „{1}”. Upewnij się, że dziedziczy po klasie bazowej Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Jeśli nie jest przeznaczony do niestandardowego analizatora, nie powinien być ujawniany. Więcej informacji: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Nie można zarejestrować analizatora niestandardowego: „{0}”.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Nie można utworzyć wystąpienia niestandardowej reguły analizatora z następującym wyjątkiem: „{0}”.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">Analizator niestandardowy „{0}” jest zarejestrowany dla kompilacji z lokalizacji: „{1}”.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Niestandardowa reguła analizatora: „{0}” została pomyślnie zarejestrowana.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="translated">Nie udało się znaleźć określonego niestandardowego zestawu kontrolnego: „{0}”. Sprawdź, czy istnieje.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Nie udało się załadować niestandardowego typu kontrolnego: „{0}” z zestawu: „{1}”. Upewnij się, że dziedziczy po klasie bazowej Microsoft.Build.Experimental.BuildCheck.Check. Jeśli nie ma to być kontrola niestandardowa, to nie powinna być ona ujawniana. Więcej informacji: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="translated">Nie można zarejestrować niestandardowego kontrolera: „{0}”.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="translated">Nie udało się utworzyć niestandardowej reguły utworzenia wystąpienia z następującym wyjątkiem: „{0}”.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="translated">Kontroler niestandardowy „{0}” jest zarejestrowany dla kompilacji z lokalizacji: „{1}”.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="translated">Niestandardowa reguła kontrolera: „{0}” została pomyślnie zarejestrowana.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index f32f6070aff..9b116832311 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Falha ao localizar o assembly do analisador personalizado especificado: "{0}". Verifique se existe.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Falha ao carregar o tipo de analisador personalizado: "{0}" do assembly: "{1}". Certifique-se de que ele herde a classe base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Se não se destina a ser um analisador personalizado, ele não deve ser exposto. Mais informações: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Falha ao registrar o analisador personalizado: "{0}".</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Falha ao criar uma instância da regra do analisador personalizado com a seguinte exceção: "{0}".</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">O analisador personalizado: "{0}"está registrado para o build do local: "{1}".</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Regra do analisador personalizado: "{0}" foi registrado com sucesso.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="translated">Falha ao localizar o assembly de verificação personalizado especificado: '{0}'. Verifique se existe.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Falha ao carregar o tipo de verificação personalizada: '{0}' do assembly: '{1}'. Certifique-se de que ele herda a classe base Microsoft.Build.Experimental.BuildCheck.Check. Se não for destinado a ser uma verificação personalizada, então não deve ser exposto. Mais informações: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="translated">Falha ao registrar a verificação personalizada: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="translated">Falha ao instanciar a regra de verificação personalizada com a seguinte exceção: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="translated">A verificação personalizada: '{0}' está registrada para a compilação a partir do local: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="translated">Regra de verificação personalizada: '{0}' foi registrada com sucesso.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index c10386abcc6..7c60fde6328 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Не удалось найти указанную сборку настраиваемого анализатора "{0}". Убедитесь, что она существует.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Не удалось загрузить тип настраиваемого анализатора "{0}" из сборки "{1}". Убедитесь, что он наследует базовый класс Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Если он не предназначен для настраиваемого анализатора, его не следует предоставлять. Подробнее: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Не удалось зарегистрировать настраиваемый анализатор "{0}".</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Не удалось создать экземпляр правила настраиваемого анализатора со следующим исключением: "{0}".</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">Настраиваемый анализатор "{0}" включен для сборки из расположения "{1}".</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Правило настраиваемого анализатора "{0}" успешно зарегистрировано.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="translated">Не удалось найти указанную сборку настраиваемой проверки "{0}". Убедитесь, что она существует.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">Не удалось загрузить тип настраиваемой проверки "{0}" из сборки "{1}". Убедитесь, что он наследует базовый класс Microsoft.Build.Experimental.BuildCheck.Check. Если он не предназначен для настраиваемой проверки, его не следует предоставлять. Подробнее: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="translated">Не удалось зарегистрировать настраиваемую проверку "{0}".</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="translated">Не удалось создать экземпляр правила настраиваемой проверки со следующим исключением: "{0}".</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="translated">Настраиваемая проверка "{0}" зарегистрирована для сборки из расположения "{1}".</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="translated">Правило настраиваемой проверки "{0}" успешно зарегистрировано.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index d9e55e6fa7f..307a50d708b 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Belirtilen özel çözümleyici derlemesi: ‘{0}’ bulunamadı. Lütfen var olup olmadığını kontrol edin.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Özel çözümleyici türü: ‘{0}’ şu derlemeden: ‘{1}’ yüklenemedi. Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer temel sınıfını devralmış olduğundan emin olun. Özel bir çözümleyici olması amaçlanmadıysa açığa çıkarılmaması gerekir. Daha fazla bilgi: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Özel çözümleyici: ‘{0}’ kaydedilemedi.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Özel çözümleyici kuralı şu özel durumla başlatılamadı: ‘{0}’.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">Özel çözümleyici: '{0}' derleme için şu konumdan kaydedildi: '{1}'.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Özel çözümleyici kuralı: ‘{0}’ başarıyla kaydedildi.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="translated">Belirtilen özel denetim derlemesi bulunamadı: '{0}'. Lütfen var olup olmadığını kontrol edin.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">‘{0}’ özel denetim türü ‘{1}’ derlemesinden yüklenemedi. Microsoft.Build.Experimental.BuildCheck.Check temel sınıfını devralmış olduğundan emin olun. Özel bir denetim olması amaçlanmadıysa açığa çıkarılmaması gerekir. Daha fazla bilgi: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="translated">Özel denetim kaydedilemedi: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="translated">Özel denetim kuralı şu özel durumla başlatılamadı: ‘{0}’.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="translated">'{0}' özel denetimi '{1}' konumundaki derleme için kaydedildi.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="translated">‘{0}’ özel denetim kuralı başarıyla kaydedildi.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index af786a8fce0..452519cadd8 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">找不到指定的自定义分析器程序集 "{0}"。请检查它是否存在。</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">未能从程序集 "{1}" 加载自定义分析器类型 "{0}"。请确保它继承 Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基类。如果不打算将其作为自定义分析器，则不应将其公开。详细信息: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">未能注册自定义分析器 "{0}"。</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">未能实例化自定义分析器规则，出现以下异常: {0}。</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">已从位置 "{1}" 为内部版本注册自定义分析器 "{0}"。</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">已成功注册自定义分析器规则 "{0}"。</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="translated">找不到指定的自定义检查程序集: {0}。请检查它是否存在。</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">未能从程序集“{1}”加载自定义检查类型“{0}”。请确保它继承 Microsoft.Build.Experimental.BuildCheck.Check 基类。如果不打算将其作为自定义检查，则不应将其公开。详细信息: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="translated">未能注册自定义检查: {0}。</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="translated">未能实例化自定义检查规则，出现以下异常: {0}。</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="translated">已从位置“{1}”为内部版本注册自定义检查“{0}”。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="translated">已成功注册自定义检查规则“{0}”。</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 23f8fd192f6..fc23b9a3586 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">找不到指定的自訂分析器組件: '{0}'。請確認其是否存在。</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">無法從組件: '{1}'載入自訂分析器類型: '{0}'。請確認其繼承了 Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基底類別。如非作為自訂分析器，則不應公開。更多資訊: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">無法註冊自訂分析器: '{0}'。</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">無法具現化自訂分析器規則，發生下列例外狀況: '{0}'。</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">已從 '{1}' 位置為組建註冊自訂分析器 '{0}'。</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">已成功註冊自訂分析器規則: '{0}'。</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="translated">找不到指定的自訂檢查組件: '{0}'。請確認其是否存在。</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="translated">無法從組件: '{1}' 載入自訂檢查類型: '{0}'。請確認其繼承了 Microsoft.Build.Experimental.BuildCheck.Check 基底類別。如非作為自訂檢查，則不應公開。更多資訊: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="translated">無法註冊自訂檢查: '{0}'。</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="translated">無法具現化自訂檢查規則，發生下列例外狀況: '{0}'。</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="translated">已從 位置: '{1}' 為組建註冊自訂檢查: '{0}'。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="translated">已成功註冊自訂檢查規則: '{0}'。</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index e8bf893be60..a4859ae234a 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -660,6 +660,10 @@ public static void EnumerateProperties<TArg>(IEnumerable properties, TArg arg, A
                     {
                         callback(arg, kvp);
                     }
+                    else if (item is KeyValuePair<string, TimeSpan> keyTimeSpanValue)
+                    {
+                        callback(arg, new KeyValuePair<string, string>(keyTimeSpanValue.Key, keyTimeSpanValue.Value.Ticks.ToString()));
+                    }
                     else
                     {
                         if (item == null)
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationEffectiveTests.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationEffectiveTests.cs
deleted file mode 100644
index f604c043b62..00000000000
--- a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationEffectiveTests.cs
+++ /dev/null
@@ -1,63 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using Xunit;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-using Microsoft.Build.Experimental.BuildCheck;
-using Shouldly;
-using System;
-
-namespace Microsoft.Build.BuildCheck.UnitTests;
-
-public class BuildAnalyzerConfigurationEffectiveTests
-{
-    [Theory]
-    [InlineData("ruleId", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Warning,  true)]
-    [InlineData("ruleId2", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Warning,  true)]
-    [InlineData("ruleId", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Error, false)]
-    public void IsSameConfigurationAsTest(
-        string secondRuleId,
-        EvaluationAnalysisScope secondScope,
-        BuildAnalyzerResultSeverity secondSeverity,
-        bool isExpectedToBeSame)
-    {
-        BuildAnalyzerConfigurationEffective configuration1 = new BuildAnalyzerConfigurationEffective(
-                       ruleId: "ruleId",
-                       evaluationAnalysisScope: EvaluationAnalysisScope.ProjectOnly,
-                       severity: BuildAnalyzerResultSeverity.Warning);
-
-        BuildAnalyzerConfigurationEffective configuration2 = new BuildAnalyzerConfigurationEffective(
-            ruleId: secondRuleId,
-            evaluationAnalysisScope: secondScope,
-            severity: secondSeverity);
-
-        configuration1.IsSameConfigurationAs(configuration2).ShouldBe(isExpectedToBeSame);
-    }
-
-    [Theory]
-    [InlineData( BuildAnalyzerResultSeverity.Warning, true)]
-    [InlineData(BuildAnalyzerResultSeverity.Suggestion, true)]
-    [InlineData(BuildAnalyzerResultSeverity.Error, true)]
-    [InlineData(BuildAnalyzerResultSeverity.None, false)]
-    public void BuildAnalyzerConfigurationInternal_Constructor_SeverityConfig(BuildAnalyzerResultSeverity severity, bool isEnabledExpected)
-    {
-        BuildAnalyzerConfigurationEffective configuration = new BuildAnalyzerConfigurationEffective(
-                       ruleId: "ruleId",
-                       evaluationAnalysisScope: EvaluationAnalysisScope.ProjectOnly,
-                       severity: severity);
-
-        configuration.IsEnabled.ShouldBe(isEnabledExpected);
-    }
-
-    [Fact]
-    public void BuildAnalyzerConfigurationInternal_Constructor_SeverityConfig_Fails()
-    {
-        Should.Throw<ArgumentOutOfRangeException>(() =>
-        {
-            new BuildAnalyzerConfigurationEffective(
-                        ruleId: "ruleId",
-                        evaluationAnalysisScope: EvaluationAnalysisScope.ProjectOnly,
-                        severity: BuildAnalyzerResultSeverity.Default);
-        });
-    }
-}
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
deleted file mode 100644
index a017df0f9c3..00000000000
--- a/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
+++ /dev/null
@@ -1,118 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Collections.Generic;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-using Microsoft.Build.Experimental.BuildCheck;
-using Shouldly;
-using Xunit;
-
-namespace Microsoft.Build.BuildCheck.UnitTests;
-
-public class BuildAnalyzerConfiguration_Test
-{
-    [Fact]
-    public void CreateWithNull_ReturnsObjectWithNullValues()
-    {
-        var buildConfig = BuildAnalyzerConfiguration.Create(null);
-        buildConfig.ShouldNotBeNull();
-        buildConfig.Severity.ShouldBeNull();
-        buildConfig.IsEnabled.ShouldBeNull();
-        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
-    }
-
-    [Fact]
-    public void CreateWithEmpty_ReturnsObjectWithNullValues()
-    {
-        var buildConfig = BuildAnalyzerConfiguration.Create(new Dictionary<string, string>());
-        buildConfig.ShouldNotBeNull();
-        buildConfig.Severity.ShouldBeNull();
-        buildConfig.IsEnabled.ShouldBeNull();
-        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
-    }
-
-    [Theory]
-    [InlineData("error", BuildAnalyzerResultSeverity.Error)]
-    [InlineData("ERROR", BuildAnalyzerResultSeverity.Error)]
-    [InlineData("suggestion", BuildAnalyzerResultSeverity.Suggestion)]
-    [InlineData("SUGGESTION", BuildAnalyzerResultSeverity.Suggestion)]
-    [InlineData("warning", BuildAnalyzerResultSeverity.Warning)]
-    [InlineData("WARNING", BuildAnalyzerResultSeverity.Warning)]
-    [InlineData("NONE", BuildAnalyzerResultSeverity.None)]
-    [InlineData("none", BuildAnalyzerResultSeverity.None)]
-    [InlineData("default", BuildAnalyzerResultSeverity.Default)]
-    [InlineData("DEFAULT", BuildAnalyzerResultSeverity.Default)]
-    public void CreateBuildAnalyzerConfiguration_Severity(string parameter, BuildAnalyzerResultSeverity? expected)
-    {
-        var config = new Dictionary<string, string>()
-        {
-            { "severity" , parameter },
-        };
-
-        var buildConfig = BuildAnalyzerConfiguration.Create(config);
-
-        buildConfig.ShouldNotBeNull();
-        buildConfig.Severity.ShouldBe(expected);
-        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
-    }
-
-    [Theory]
-    [InlineData("error", true)]
-    [InlineData("warning", true)]
-    [InlineData("suggestion", true)]
-    [InlineData("none", false)]
-    [InlineData("default", null)]
-    public void CreateBuildAnalyzerConfiguration_SeverityAndEnabledOrder(string parameter, bool? expected)
-    {
-        var config = new Dictionary<string, string>()
-        {
-            { "severity", parameter },
-        };
-        
-        var buildConfig = BuildAnalyzerConfiguration.Create(config);
-
-        buildConfig.IsEnabled.ShouldBe(expected);
-    }
-
-    [Theory]
-    [InlineData("project", EvaluationAnalysisScope.ProjectOnly)]
-    [InlineData("PROJECT", EvaluationAnalysisScope.ProjectOnly)]
-    [InlineData("current_imports", EvaluationAnalysisScope.ProjectWithImportsFromCurrentWorkTree)]
-    [InlineData("CURRENT_IMPORTS", EvaluationAnalysisScope.ProjectWithImportsFromCurrentWorkTree)]
-    [InlineData("without_sdks", EvaluationAnalysisScope.ProjectWithImportsWithoutSdks)]
-    [InlineData("WITHOUT_SDKS", EvaluationAnalysisScope.ProjectWithImportsWithoutSdks)]
-    [InlineData("all", EvaluationAnalysisScope.ProjectWithAllImports)]
-    [InlineData("ALL", EvaluationAnalysisScope.ProjectWithAllImports)]
-    public void CreateBuildAnalyzerConfiguration_EvaluationAnalysisScope(string parameter, EvaluationAnalysisScope? expected)
-    {
-        var config = new Dictionary<string, string>()
-        {
-            { "scope" , parameter },
-        };
-
-        var buildConfig = BuildAnalyzerConfiguration.Create(config);
-
-        buildConfig.ShouldNotBeNull();
-        buildConfig.EvaluationAnalysisScope.ShouldBe(expected);
-
-        buildConfig.IsEnabled.ShouldBeNull();
-        buildConfig.Severity.ShouldBeNull();
-    }
-
-    [Theory]
-    [InlineData("scope", "incorrec-value")]
-    [InlineData("severity", "incorrec-value")]
-    public void CreateBuildAnalyzerConfiguration_ExceptionOnInvalidInputValue(string key, string value)
-    {
-        var config = new Dictionary<string, string>()
-        {
-            { key , value },
-        };
-
-        var exception = Should.Throw<BuildCheckConfigurationException>(() =>
-        {
-            BuildAnalyzerConfiguration.Create(config);
-        });
-        exception.Message.ShouldContain($"Incorrect value provided in config for key {key}");
-    }
-}
diff --git a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
index 5ab4ea729b0..d33261fc6d9 100644
--- a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
+++ b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
@@ -5,6 +5,7 @@
 using System.Linq;
 using System.Reflection;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Experimental.BuildCheck.Acquisition;
@@ -33,23 +34,26 @@ public BuildCheckManagerTests(ITestOutputHelper output)
     }
 
     [Theory]
-    [InlineData(true, new[] { "Custom analyzer rule: 'Rule1' has been registered successfully.", "Custom analyzer rule: 'Rule2' has been registered successfully." })]
-    [InlineData(false, new[] { "Failed to register the custom analyzer: 'DummyPath'." })]
-    public void ProcessAnalyzerAcquisitionTest(bool isAnalyzerRuleExist, string[] expectedMessages)
+    [InlineData(true, new[] { "Custom check rule: 'Rule1' has been registered successfully.", "Custom check rule: 'Rule2' has been registered successfully." })]
+    [InlineData(false, new[] { "Failed to register the custom check: 'DummyPath'." })]
+    public void ProcessCheckAcquisitionTest(bool isCheckRuleExist, string[] expectedMessages)
     {
-        MockBuildCheckAcquisition(isAnalyzerRuleExist);
+        MockConfigurationProvider();
+        MockBuildCheckAcquisition(isCheckRuleExist);
         MockEnabledDataSourcesDefinition();
 
-        _testedInstance.ProcessAnalyzerAcquisition(new AnalyzerAcquisitionData("DummyPath"), new AnalysisLoggingContext(_loggingService, new BuildEventContext(1, 2, 3, 4, 5, 6, 7)));
+        _testedInstance.ProcessCheckAcquisition(new CheckAcquisitionData("DummyPath", "ProjectPath"), new CheckLoggingContext(_loggingService, new BuildEventContext(1, 2, 3, 4, 5, 6, 7)));
 
         _logger.AllBuildEvents.Where(be => be.GetType() == typeof(BuildMessageEventArgs)).Select(be => be.Message).ToArray()
             .ShouldBeEquivalentTo(expectedMessages);
     }
 
-    private void MockBuildCheckAcquisition(bool isAnalyzerRuleExist) => MockField("_acquisitionModule", new BuildCheckAcquisitionModuleMock(isAnalyzerRuleExist));
+    private void MockBuildCheckAcquisition(bool isCheckRuleExist) => MockField("_acquisitionModule", new BuildCheckAcquisitionModuleMock(isCheckRuleExist));
 
     private void MockEnabledDataSourcesDefinition() => MockField("_enabledDataSources", new[] { true, true });
 
+    private void MockConfigurationProvider() => MockField("_configurationProvider", new ConfigurationProviderMock());
+
     private void MockField(string fieldName, object mockedValue)
     {
         var mockedField = _testedInstance.GetType().GetField(fieldName, BindingFlags.NonPublic | BindingFlags.Instance);
@@ -60,39 +64,52 @@ private void MockField(string fieldName, object mockedValue)
     }
 }
 
+internal sealed class ConfigurationProviderMock : IConfigurationProvider
+{
+    public void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId) { }
+
+    public CustomConfigurationData[] GetCustomConfigurations(string projectFullPath, IReadOnlyList<string> ruleIds) => [];
+
+    public CheckConfigurationEffective[] GetMergedConfigurations(string projectFullPath, Check check) => [];
+
+    public CheckConfigurationEffective[] GetMergedConfigurations(CheckConfiguration[] userConfigs, Check check) => [];
+
+    public CheckConfiguration[] GetUserConfigurations(string projectFullPath, IReadOnlyList<string> ruleIds) => [];
+}
+
 internal sealed class BuildCheckAcquisitionModuleMock : IBuildCheckAcquisitionModule
 {
-    private readonly bool _isAnalyzerRuleExistForTest = true;
+    private readonly bool _isCheckRuleExistForTest = true;
 
-    internal BuildCheckAcquisitionModuleMock(bool isAnalyzerRuleExistForTest) => _isAnalyzerRuleExistForTest = isAnalyzerRuleExistForTest;
+    internal BuildCheckAcquisitionModuleMock(bool isCheckRuleExistForTest) => _isCheckRuleExistForTest = isCheckRuleExistForTest;
 
-    public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisitionData analyzerAcquisitionData, IAnalysisContext analysisContext)
-        => _isAnalyzerRuleExistForTest
-        ? new List<BuildAnalyzerFactory>() { () => new BuildAnalyzerRuleMock("Rule1"), () => new BuildAnalyzerRuleMock("Rule2") }
-        : new List<BuildAnalyzerFactory>();
+    public List<CheckFactory> CreateCheckFactories(CheckAcquisitionData checkAcquisitionData, ICheckContext checkContext)
+        => _isCheckRuleExistForTest
+        ? new List<CheckFactory>() { () => new CheckRuleMock("Rule1"), () => new CheckRuleMock("Rule2") }
+        : new List<CheckFactory>();
 }
 
-internal sealed class BuildAnalyzerRuleMock : BuildAnalyzer
+internal sealed class CheckRuleMock : Check
 {
-    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+    public static CheckRule SupportedRule = new CheckRule(
         "X01234",
         "Title",
         "Description",
         "Message format: {0}",
-        new BuildAnalyzerConfiguration());
+        new CheckConfiguration());
 
-    internal BuildAnalyzerRuleMock(string friendlyName)
+    internal CheckRuleMock(string friendlyName)
     {
         FriendlyName = friendlyName;
     }
 
     public override string FriendlyName { get; }
 
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
-        // configurationContext to be used only if analyzer needs external configuration data.
+        // configurationContext to be used only if check needs external configuration data.
     }
 
     public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
@@ -100,7 +117,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
         registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
     }
 
-    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
     {
         context.ReportResult(BuildCheckResult.Create(
             SupportedRule,
diff --git a/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs b/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs
new file mode 100644
index 00000000000..12920740700
--- /dev/null
+++ b/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs
@@ -0,0 +1,63 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Xunit;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using System;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class CheckConfigurationEffectiveTests
+{
+    [Theory]
+    [InlineData("ruleId", EvaluationCheckScope.ProjectFileOnly, CheckResultSeverity.Warning,  true)]
+    [InlineData("ruleId2", EvaluationCheckScope.ProjectFileOnly, CheckResultSeverity.Warning,  true)]
+    [InlineData("ruleId", EvaluationCheckScope.ProjectFileOnly, CheckResultSeverity.Error, false)]
+    public void IsSameConfigurationAsTest(
+        string secondRuleId,
+        EvaluationCheckScope secondScope,
+        CheckResultSeverity secondSeverity,
+        bool isExpectedToBeSame)
+    {
+        CheckConfigurationEffective configuration1 = new CheckConfigurationEffective(
+                       ruleId: "ruleId",
+                       evaluationCheckScope: EvaluationCheckScope.ProjectFileOnly,
+                       severity: CheckResultSeverity.Warning);
+
+        CheckConfigurationEffective configuration2 = new CheckConfigurationEffective(
+            ruleId: secondRuleId,
+            evaluationCheckScope: secondScope,
+            severity: secondSeverity);
+
+        configuration1.IsSameConfigurationAs(configuration2).ShouldBe(isExpectedToBeSame);
+    }
+
+    [Theory]
+    [InlineData( CheckResultSeverity.Warning, true)]
+    [InlineData(CheckResultSeverity.Suggestion, true)]
+    [InlineData(CheckResultSeverity.Error, true)]
+    [InlineData(CheckResultSeverity.None, false)]
+    public void CheckConfigurationInternal_Constructor_SeverityConfig(CheckResultSeverity severity, bool isEnabledExpected)
+    {
+        CheckConfigurationEffective configuration = new CheckConfigurationEffective(
+                       ruleId: "ruleId",
+                       evaluationCheckScope: EvaluationCheckScope.ProjectFileOnly,
+                       severity: severity);
+
+        configuration.IsEnabled.ShouldBe(isEnabledExpected);
+    }
+
+    [Fact]
+    public void CheckConfigurationInternal_Constructor_SeverityConfig_Fails()
+    {
+        Should.Throw<ArgumentOutOfRangeException>(() =>
+        {
+            new CheckConfigurationEffective(
+                        ruleId: "ruleId",
+                        evaluationCheckScope: EvaluationCheckScope.ProjectFileOnly,
+                        severity: CheckResultSeverity.Default);
+        });
+    }
+}
diff --git a/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs b/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs
new file mode 100644
index 00000000000..3fd22bd8a46
--- /dev/null
+++ b/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs
@@ -0,0 +1,117 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class CheckConfiguration_Test
+{
+    [Fact]
+    public void CreateWithNull_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = CheckConfiguration.Create(null);
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationCheckScope.ShouldBeNull();
+    }
+
+    [Fact]
+    public void CreateWithEmpty_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = CheckConfiguration.Create(new Dictionary<string, string>());
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationCheckScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("error", CheckResultSeverity.Error)]
+    [InlineData("ERROR", CheckResultSeverity.Error)]
+    [InlineData("suggestion", CheckResultSeverity.Suggestion)]
+    [InlineData("SUGGESTION", CheckResultSeverity.Suggestion)]
+    [InlineData("warning", CheckResultSeverity.Warning)]
+    [InlineData("WARNING", CheckResultSeverity.Warning)]
+    [InlineData("NONE", CheckResultSeverity.None)]
+    [InlineData("none", CheckResultSeverity.None)]
+    [InlineData("default", CheckResultSeverity.Default)]
+    [InlineData("DEFAULT", CheckResultSeverity.Default)]
+    public void CreateCheckConfiguration_Severity(string parameter, CheckResultSeverity? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "severity" , parameter },
+        };
+
+        var buildConfig = CheckConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBe(expected);
+        buildConfig.EvaluationCheckScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("error", true)]
+    [InlineData("warning", true)]
+    [InlineData("suggestion", true)]
+    [InlineData("none", false)]
+    [InlineData("default", null)]
+    public void CreateCheckConfiguration_SeverityAndEnabledOrder(string parameter, bool? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "severity", parameter },
+        };
+        
+        var buildConfig = CheckConfiguration.Create(config);
+
+        buildConfig.IsEnabled.ShouldBe(expected);
+    }
+
+    [Theory]
+    [InlineData("project_file", EvaluationCheckScope.ProjectFileOnly)]
+    [InlineData("projectfile", EvaluationCheckScope.ProjectFileOnly)]
+    [InlineData("PROJECT_FILE", EvaluationCheckScope.ProjectFileOnly)]
+    [InlineData("work_tree_imports", EvaluationCheckScope.WorkTreeImports)]
+    [InlineData("WORK_TREE_IMPORTS", EvaluationCheckScope.WorkTreeImports)]
+    [InlineData("all", EvaluationCheckScope.All)]
+    [InlineData("ALL", EvaluationCheckScope.All)]
+    public void CreateCheckConfiguration_EvaluationCheckScope(string parameter, EvaluationCheckScope? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "scope" , parameter },
+        };
+
+        var buildConfig = CheckConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.EvaluationCheckScope.ShouldBe(expected);
+
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.Severity.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("scope", "incorrec-value")]
+    [InlineData("severity", "incorrec-value")]
+    public void CreateCheckConfiguration_ExceptionOnInvalidInputValue(string key, string value)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { key , value },
+        };
+
+        var exception = Should.Throw<BuildCheckConfigurationException>(() =>
+        {
+            CheckConfiguration.Create(config);
+        });
+        exception.Message.ShouldContain($"Incorrect value provided in config for key {key}");
+    }
+}
diff --git a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
index 32f8554bc75..53b7ba1b7b3 100644
--- a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
+++ b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
@@ -108,7 +108,7 @@ public void GetRuleIdConfiguration_ReturnsBuildRuleConfiguration()
 
         [*.csproj]
         build_check.rule_id.severity=error
-        build_check.rule_id.scope=project
+        build_check.rule_id.scope=project_file
         """);
 
         var configurationProvider = new ConfigurationProvider();
@@ -117,8 +117,8 @@ public void GetRuleIdConfiguration_ReturnsBuildRuleConfiguration()
         buildConfig.ShouldNotBeNull();
 
         buildConfig.IsEnabled.ShouldBe(true);
-        buildConfig.Severity.ShouldBe(BuildAnalyzerResultSeverity.Error);
-        buildConfig.EvaluationAnalysisScope.ShouldBe(EvaluationAnalysisScope.ProjectOnly);
+        buildConfig.Severity.ShouldBe(CheckResultSeverity.Error);
+        buildConfig.EvaluationCheckScope.ShouldBe(EvaluationCheckScope.ProjectFileOnly);
     }
 
     [Fact]
@@ -216,27 +216,27 @@ public void GetRuleIdConfiguration_CustomConfigurationValidity_Valid()
     }
 
     [Theory]
-    [InlineData(BuildAnalyzerResultSeverity.Warning, BuildAnalyzerResultSeverity.Warning, true)]
-    [InlineData(BuildAnalyzerResultSeverity.Error, BuildAnalyzerResultSeverity.Error, true)]
-    [InlineData(BuildAnalyzerResultSeverity.Default, BuildAnalyzerResultSeverity.Warning, true)]
-    [InlineData(BuildAnalyzerResultSeverity.Suggestion, BuildAnalyzerResultSeverity.Suggestion, true)]
-    [InlineData(BuildAnalyzerResultSeverity.None, BuildAnalyzerResultSeverity.None, false)]
-    [InlineData(null, BuildAnalyzerResultSeverity.Warning, true)]
-    public void GetConfigurationProvider_MergesSeverity_Correctly(BuildAnalyzerResultSeverity? buildAnalyzerResultSeverity, BuildAnalyzerResultSeverity expectedSeverity, bool expectedEnablment)
+    [InlineData(CheckResultSeverity.Warning, CheckResultSeverity.Warning, true)]
+    [InlineData(CheckResultSeverity.Error, CheckResultSeverity.Error, true)]
+    [InlineData(CheckResultSeverity.Default, CheckResultSeverity.Warning, true)]
+    [InlineData(CheckResultSeverity.Suggestion, CheckResultSeverity.Suggestion, true)]
+    [InlineData(CheckResultSeverity.None, CheckResultSeverity.None, false)]
+    [InlineData(null, CheckResultSeverity.Warning, true)]
+    public void GetConfigurationProvider_MergesSeverity_Correctly(CheckResultSeverity? checkResultSeverity, CheckResultSeverity expectedSeverity, bool expectedEnablment)
     {
         var configurationProvider = new ConfigurationProvider();
-        BuildAnalyzerConfiguration buildAnalyzerConfiguration = new BuildAnalyzerConfiguration()
+        CheckConfiguration checkConfiguration = new CheckConfiguration()
         {
-            Severity = buildAnalyzerResultSeverity
+            Severity = checkResultSeverity
         };
 
-        BuildAnalyzerConfiguration defaultValue = new BuildAnalyzerConfiguration()
+        CheckConfiguration defaultValue = new CheckConfiguration()
         {
-            Severity = BuildAnalyzerResultSeverity.Warning
+            Severity = CheckResultSeverity.Warning
         };
 
-        var internalBuildAnalyzer = configurationProvider.MergeConfiguration("ruleId", defaultValue, buildAnalyzerConfiguration);
-        internalBuildAnalyzer.Severity.ShouldBe(expectedSeverity);
-        internalBuildAnalyzer.IsEnabled.ShouldBe(expectedEnablment);
+        var internalCheck = configurationProvider.MergeConfiguration("ruleId", defaultValue, checkConfiguration);
+        internalCheck.Severity.ShouldBe(expectedSeverity);
+        internalCheck.IsEnabled.ShouldBe(expectedEnablment);
     }
 }
diff --git a/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs b/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
index 2dc907aaf15..c773fefbc11 100644
--- a/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
+++ b/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
@@ -6,60 +6,30 @@
 using System.IO;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
-using Microsoft.Build.Experimental.BuildCheck.Analyzers;
+using Microsoft.Build.Experimental.BuildCheck.Checks;
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.BuildCheck.UnitTests
 {
-    public sealed class DoubleWritesAnalyzer_Tests
+    public sealed class DoubleWritesCheck_Tests
     {
-        private sealed class MockBuildCheckRegistrationContext : IBuildCheckRegistrationContext
-        {
-            private event Action<BuildCheckDataContext<TaskInvocationAnalysisData>>? _taskInvocationAction;
-
-            public List<BuildCheckResult> Results { get; } = new();
-
-            public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction) => throw new NotImplementedException();
-            public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction) => throw new NotImplementedException();
-
-            public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
-                => _taskInvocationAction += taskInvocationAction;
-
-            public void TriggerTaskInvocationAction(TaskInvocationAnalysisData data)
-            {
-                if (_taskInvocationAction is not null)
-                {
-                    BuildCheckDataContext<TaskInvocationAnalysisData> context = new BuildCheckDataContext<TaskInvocationAnalysisData>(
-                        null!,
-                        null!,
-                        null!,
-                        ResultHandler,
-                        data);
-                    _taskInvocationAction(context);
-                }
-            }
-
-            private void ResultHandler(BuildAnalyzerWrapper wrapper, IAnalysisContext context, BuildAnalyzerConfigurationEffective[] configs, BuildCheckResult result)
-                => Results.Add(result);
-        }
-
-        private readonly DoubleWritesAnalyzer _analyzer;
+        private readonly DoubleWritesCheck _check;
 
         private readonly MockBuildCheckRegistrationContext _registrationContext;
 
-        public DoubleWritesAnalyzer_Tests()
+        public DoubleWritesCheck_Tests()
         {
-            _analyzer = new DoubleWritesAnalyzer();
+            _check = new DoubleWritesCheck();
             _registrationContext = new MockBuildCheckRegistrationContext();
-            _analyzer.RegisterActions(_registrationContext);
+            _check.RegisterActions(_registrationContext);
         }
 
-        private TaskInvocationAnalysisData MakeTaskInvocationData(string taskName, Dictionary<string, TaskInvocationAnalysisData.TaskParameter> parameters)
+        private TaskInvocationCheckData MakeTaskInvocationData(string taskName, Dictionary<string, TaskInvocationCheckData.TaskParameter> parameters)
         {
             string projectFile = NativeMethodsShared.IsWindows ? @"C:\fake\project.proj" : "/fake/project.proj";
-            return new TaskInvocationAnalysisData(
+            return new TaskInvocationCheckData(
                 projectFile,
                 null,
                 Construction.ElementLocation.EmptyLocation,
@@ -71,19 +41,19 @@ private TaskInvocationAnalysisData MakeTaskInvocationData(string taskName, Dicti
         [Fact]
         public void TestCopyTask()
         {
-            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Copy", new Dictionary<string, TaskInvocationAnalysisData.TaskParameter>
+            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Copy", new Dictionary<string, TaskInvocationCheckData.TaskParameter>
                 {
-                    { "SourceFiles", new TaskInvocationAnalysisData.TaskParameter("source1", IsOutput: false) },
-                    { "DestinationFolder", new TaskInvocationAnalysisData.TaskParameter("outdir", IsOutput: false) },
+                    { "SourceFiles", new TaskInvocationCheckData.TaskParameter("source1", IsOutput: false) },
+                    { "DestinationFolder", new TaskInvocationCheckData.TaskParameter("outdir", IsOutput: false) },
                 }));
-            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Copy", new Dictionary<string, TaskInvocationAnalysisData.TaskParameter>
+            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Copy", new Dictionary<string, TaskInvocationCheckData.TaskParameter>
                 {
-                    { "SourceFiles", new TaskInvocationAnalysisData.TaskParameter("source1", IsOutput: false) },
-                    { "DestinationFiles", new TaskInvocationAnalysisData.TaskParameter(Path.Combine("outdir", "source1"), IsOutput: false) },
+                    { "SourceFiles", new TaskInvocationCheckData.TaskParameter("source1", IsOutput: false) },
+                    { "DestinationFiles", new TaskInvocationCheckData.TaskParameter(Path.Combine("outdir", "source1"), IsOutput: false) },
                 }));
 
             _registrationContext.Results.Count.ShouldBe(1);
-            _registrationContext.Results[0].BuildAnalyzerRule.Id.ShouldBe("BC0102");
+            _registrationContext.Results[0].CheckRule.Id.ShouldBe("BC0102");
         }
 
         [Theory]
@@ -94,17 +64,17 @@ public void TestCompilerTask(string taskName)
         {
             for (int i = 0; i < 2; i++)
             {
-                _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData(taskName, new Dictionary<string, TaskInvocationAnalysisData.TaskParameter>
+                _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData(taskName, new Dictionary<string, TaskInvocationCheckData.TaskParameter>
                     {
-                        { "OutputAssembly", new TaskInvocationAnalysisData.TaskParameter("out.dll", IsOutput: false) },
-                        { "OutputRefAssembly", new TaskInvocationAnalysisData.TaskParameter("out_ref.dll", IsOutput: false) },
-                        { "DocumentationFile", new TaskInvocationAnalysisData.TaskParameter("out.xml", IsOutput: false) },
-                        { "PdbFile", new TaskInvocationAnalysisData.TaskParameter("out.pdb", IsOutput: false) },
+                        { "OutputAssembly", new TaskInvocationCheckData.TaskParameter("out.dll", IsOutput: false) },
+                        { "OutputRefAssembly", new TaskInvocationCheckData.TaskParameter("out_ref.dll", IsOutput: false) },
+                        { "DocumentationFile", new TaskInvocationCheckData.TaskParameter("out.xml", IsOutput: false) },
+                        { "PdbFile", new TaskInvocationCheckData.TaskParameter("out.pdb", IsOutput: false) },
                     }));
             }
 
             _registrationContext.Results.Count.ShouldBe(4);
-            _registrationContext.Results.ForEach(result => result.BuildAnalyzerRule.Id.ShouldBe("BC0102"));
+            _registrationContext.Results.ForEach(result => result.CheckRule.Id.ShouldBe("BC0102"));
         }
     }
 }
diff --git a/src/BuildCheck.UnitTests/EditorConfig_Tests.cs b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
index 1b1b0c5aaa4..84e9af60f02 100644
--- a/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
+++ b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
@@ -841,13 +841,13 @@ public void CanGetSectionsWithSpecialCharacters()
 build_metadata.Compile.ToRetrieve = def456
 ");
 
-        var set = AnalyzerConfigSet.Create(ImmutableArray.Create(config));
+        var set = CheckConfigSet.Create(ImmutableArray.Create(config));
 
         var sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/{releaseid}.cs");
-        Assert.Equal("abc123", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+        Assert.Equal("abc123", sectionOptions.CheckOptions["build_metadata.compile.toretrieve"]);
 
         sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/Pages/#foo/HomePage.cs");
-        Assert.Equal("def456", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+        Assert.Equal("def456", sectionOptions.CheckOptions["build_metadata.compile.toretrieve"]);
     }*/
 
     [Fact]
@@ -895,9 +895,9 @@ public void CaseInsensitivePropKey()
     public void NonReservedKeyPreservedCaseVal()
     {
         var config = ParseConfigFile(string.Join(Environment.NewLine,
-            AnalyzerConfig.ReservedKeys.Select(k => "MY_" + k + " = MY_VAL")));
+            CheckConfig.ReservedKeys.Select(k => "MY_" + k + " = MY_VAL")));
         AssertEx.SetEqual(
-            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create("my_" + k, "MY_VAL")).ToList(),
+            CheckConfig.ReservedKeys.Select(k => KeyValuePair.Create("my_" + k, "MY_VAL")).ToList(),
             config.GlobalSection.Properties);
     }*/
 
@@ -1055,10 +1055,10 @@ public void ReservedValues()
     {
         int index = 0;
         var config = ParseConfigFile(string.Join(Environment.NewLine,
-            AnalyzerConfig.ReservedValues.Select(v => "MY_KEY" + (index++) + " = " + v.ToUpperInvariant())));
+            CheckConfig.ReservedValues.Select(v => "MY_KEY" + (index++) + " = " + v.ToUpperInvariant())));
         index = 0;
         AssertEx.SetEqual(
-            AnalyzerConfig.ReservedValues.Select(v => KeyValuePair.Create("my_key" + (index++), v)).ToList(),
+            CheckConfig.ReservedValues.Select(v => KeyValuePair.Create("my_key" + (index++), v)).ToList(),
             config.GlobalSection.Properties);
     }
     */
@@ -1068,9 +1068,9 @@ public void ReservedValues()
     public void ReservedKeys()
     {
         var config = ParseConfigFile(string.Join(Environment.NewLine,
-            AnalyzerConfig.ReservedKeys.Select(k => k + " = MY_VAL")));
+            CheckConfig.ReservedKeys.Select(k => k + " = MY_VAL")));
         AssertEx.SetEqual(
-            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create(k, "my_val")).ToList(),
+            CheckConfig.ReservedKeys.Select(k => KeyValuePair.Create(k, "my_val")).ToList(),
             config.GlobalSection.Properties);
     }
     */
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index c8c14113148..358f8725b90 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -2,8 +2,12 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.IO;
+using System.Linq;
+using System.Text.RegularExpressions;
 using System.Xml;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
@@ -15,6 +19,8 @@ namespace Microsoft.Build.BuildCheck.UnitTests;
 
 public class EndToEndTests : IDisposable
 {
+    private const string EditorConfigFileName = ".editorconfig";
+
     private readonly TestEnvironment _env;
 
     public EndToEndTests(ITestOutputHelper output)
@@ -31,23 +37,48 @@ public EndToEndTests(ITestOutputHelper output)
 
     public void Dispose() => _env.Dispose();
 
+    [Theory]
+    [InlineData(true)]
+    [InlineData(false)]
+    public void PropertiesUsageAnalyzerTest(bool buildInOutOfProcessNode)
+    {
+        PrepareSampleProjectsAndConfig(
+            buildInOutOfProcessNode,
+            out TransientTestFile projectFile,
+            "PropsCheckTest.csproj");
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild($"{projectFile.Path} -check", out bool success);
+        _env.Output.WriteLine(output);
+        _env.Output.WriteLine("=========================");
+        success.ShouldBeTrue(output);
+
+        output.ShouldMatch(@"BC0201: .* Property: \[MyProp11\]");
+        output.ShouldMatch(@"BC0202: .* Property: \[MyPropT2\]");
+        output.ShouldMatch(@"BC0203: .* Property: \[MyProp13\]");
+
+        // each finding should be found just once - but reported twice, due to summary
+        Regex.Matches(output, "BC0201: .* Property").Count.ShouldBe(2);
+        Regex.Matches(output, "BC0202: .* Property").Count.ShouldBe(2);
+        Regex.Matches(output, "BC0203 .* Property").Count.ShouldBe(2);
+    }
+
     [Theory]
     [InlineData(true, true)]
     [InlineData(false, true)]
     [InlineData(false, false)]
-    public void SampleAnalyzerIntegrationTest_AnalyzeOnBuild(bool buildInOutOfProcessNode, bool analysisRequested)
+    public void SampleCheckIntegrationTest_CheckOnBuild(bool buildInOutOfProcessNode, bool checkRequested)
     {
-        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile);
+        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", "warning") });
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
             $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore" +
-            (analysisRequested ? " -analyze" : string.Empty), out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
+            (checkRequested ? " -check" : string.Empty), out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
         _env.Output.WriteLine(output);
 
         success.ShouldBeTrue();
 
-        // The analyzer warnings should appear - but only if analysis was requested.
-        if (analysisRequested)
+        // The check warnings should appear - but only if check was requested.
+        if (checkRequested)
         {
             output.ShouldContain("BC0101");
             output.ShouldContain("BC0102");
@@ -69,18 +100,21 @@ public void SampleAnalyzerIntegrationTest_AnalyzeOnBuild(bool buildInOutOfProces
     [InlineData(false, true, "error")]
     [InlineData(false, true, "suggestion")]
     [InlineData(false, false, "warning")]
-    public void SampleAnalyzerIntegrationTest_ReplayBinaryLogOfAnalyzedBuild(bool buildInOutOfProcessNode, bool analysisRequested, string BC0101Severity)
+    public void SampleCheckIntegrationTest_ReplayBinaryLogOfCheckedBuild(bool buildInOutOfProcessNode, bool checkRequested, string BC0101Severity)
     {
-        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, BC0101Severity);
+        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", BC0101Severity) });
 
         var projectDirectory = Path.GetDirectoryName(projectFile.Path);
         string logFile = _env.ExpectFile(".binlog").Path;
 
         _ = RunnerUtilities.ExecBootstrapedMSBuild(
-            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore {(analysisRequested ? "-analyze" : string.Empty)} -bl:{logFile}",
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore {(checkRequested ? "-check" : string.Empty)} -bl:{logFile}",
             out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
 
-        success.ShouldBeTrue();
+        if (BC0101Severity != "error")
+        {
+            success.ShouldBeTrue();
+        }
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
          $"{logFile} -flp:logfile={Path.Combine(projectDirectory!, "logFile.log")};verbosity=diagnostic",
@@ -88,10 +122,13 @@ public void SampleAnalyzerIntegrationTest_ReplayBinaryLogOfAnalyzedBuild(bool bu
 
         _env.Output.WriteLine(output);
 
-        success.ShouldBeTrue();
+        if (BC0101Severity != "error")
+        {
+            success.ShouldBeTrue();
+        }
 
-        // The conflicting outputs warning appears - but only if analysis was requested
-        if (analysisRequested)
+        // The conflicting outputs warning appears - but only if check was requested
+        if (checkRequested)
         {
             output.ShouldContain("BC0101");
             output.ShouldContain("BC0102");
@@ -110,16 +147,19 @@ public void SampleAnalyzerIntegrationTest_ReplayBinaryLogOfAnalyzedBuild(bool bu
     [InlineData("error", "error BC0101", new string[] { "warning BC0101" })]
     [InlineData("suggestion", "BC0101", new string[] { "error BC0101", "warning BC0101" })]
     [InlineData("default", "warning BC0101", new string[] { "error BC0101" })]
-    [InlineData("none", null, new string[] { "BC0101"})]
+    [InlineData("none", null, new string[] { "BC0101" })]
     public void EditorConfig_SeverityAppliedCorrectly(string BC0101Severity, string expectedOutputValues, string[] unexpectedOutputValues)
     {
-        PrepareSampleProjectsAndConfig(true, out TransientTestFile projectFile, BC0101Severity);
+        PrepareSampleProjectsAndConfig(true, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", BC0101Severity) });
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
-            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -analyze",
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check",
             out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
 
-        success.ShouldBeTrue();
+        if (BC0101Severity != "error")
+        {
+            success.ShouldBeTrue();
+        }
 
         if (!string.IsNullOrEmpty(expectedOutputValues))
         {
@@ -136,9 +176,9 @@ public void EditorConfig_SeverityAppliedCorrectly(string BC0101Severity, string
     [InlineData(true, true)]
     [InlineData(false, true)]
     [InlineData(false, false)]
-    public void SampleAnalyzerIntegrationTest_AnalyzeOnBinaryLogReplay(bool buildInOutOfProcessNode, bool analysisRequested)
+    public void SampleCheckIntegrationTest_CheckOnBinaryLogReplay(bool buildInOutOfProcessNode, bool checkRequested)
     {
-        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile);
+        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", "warning") });
 
         string? projectDirectory = Path.GetDirectoryName(projectFile.Path);
         string logFile = _env.ExpectFile(".binlog").Path;
@@ -150,15 +190,15 @@ public void SampleAnalyzerIntegrationTest_AnalyzeOnBinaryLogReplay(bool buildInO
         success.ShouldBeTrue();
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
-         $"{logFile} -flp:logfile={Path.Combine(projectDirectory!, "logFile.log")};verbosity=diagnostic {(analysisRequested ? "-analyze" : string.Empty)}",
+         $"{logFile} -flp:logfile={Path.Combine(projectDirectory!, "logFile.log")};verbosity=diagnostic {(checkRequested ? "-check" : string.Empty)}",
          out success, false, _env.Output, timeoutMilliseconds: 120_000);
 
         _env.Output.WriteLine(output);
 
         success.ShouldBeTrue();
 
-        // The conflicting outputs warning appears - but only if analysis was requested
-        if (analysisRequested)
+        // The conflicting outputs warning appears - but only if check was requested
+        if (checkRequested)
         {
             output.ShouldContain("BC0101");
             output.ShouldContain("BC0102");
@@ -173,35 +213,156 @@ public void SampleAnalyzerIntegrationTest_AnalyzeOnBinaryLogReplay(bool buildInO
     }
 
     [Theory]
-    [InlineData("AnalysisCandidate", new[] { "CustomRule1", "CustomRule2" })]
-    [InlineData("AnalysisCandidateWithMultipleAnalyzersInjected", new[] { "CustomRule1", "CustomRule2", "CustomRule3" }, true)]
-    public void CustomAnalyzerTest(string analysisCandidate, string[] expectedRegisteredRules, bool expectedRejectedAnalyzers = false)
+    [InlineData(null, new[] { "Property is derived from environment variable: 'TestFromTarget'.", "Property is derived from environment variable: 'TestFromEvaluation'." } )]
+    [InlineData(true, new[] { "Property is derived from environment variable: 'TestFromTarget' with value: 'FromTarget'.", "Property is derived from environment variable: 'TestFromEvaluation' with value: 'FromEvaluation'." })]
+    [InlineData(false, new[] { "Property is derived from environment variable: 'TestFromTarget'.", "Property is derived from environment variable: 'TestFromEvaluation'." } )]
+    public void NoEnvironmentVariableProperty_Test(bool? customConfigEnabled, string[] expectedMessages)
+    {
+        List<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? customConfigData = null;
+
+        if (customConfigEnabled.HasValue)
+        {
+            customConfigData = new List<(string, (string, string))>()
+            {
+                ("BC0103", ("allow_displaying_environment_variable_value", customConfigEnabled.Value ? "true" : "false")),
+            };
+        }
+
+        PrepareSampleProjectsAndConfig(
+            buildInOutOfProcessNode: true,
+            out TransientTestFile projectFile,
+            new List<(string, string)>() { ("BC0103", "error") },
+            customConfigData);
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check", out bool success, false, _env.Output);
+
+        foreach (string expectedMessage in expectedMessages)
+        {
+            output.ShouldContain(expectedMessage);
+        }
+    }
+
+    [Theory]
+    [InlineData(EvaluationCheckScope.ProjectFileOnly)]
+    [InlineData(EvaluationCheckScope.WorkTreeImports)]
+    [InlineData(EvaluationCheckScope.All)]
+    public void NoEnvironmentVariableProperty_Scoping(EvaluationCheckScope scope)
+    {
+        List<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? customConfigData = null;
+
+        string editorconfigScope = scope switch
+        {
+            EvaluationCheckScope.ProjectFileOnly => "project_file",
+            EvaluationCheckScope.WorkTreeImports => "work_tree_imports",
+            EvaluationCheckScope.All => "all",
+            _ => throw new ArgumentOutOfRangeException(nameof(scope), scope, null),
+        };
+
+        customConfigData = new List<(string, (string, string))>()
+        {
+            ("BC0103", ("scope", editorconfigScope)),
+        };
+
+        PrepareSampleProjectsAndConfig(
+            buildInOutOfProcessNode: true,
+            out TransientTestFile projectFile,
+            new List<(string, string)>() { ("BC0103", "error") },
+            customConfigData);
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check", out bool success, false, _env.Output);
+
+        if(scope == EvaluationCheckScope.ProjectFileOnly)
+        {
+            output.ShouldNotContain("Property is derived from environment variable: 'TestImported'. Properties should be passed explicitly using the /p option.");
+        }
+        else
+        {
+            output.ShouldContain("Property is derived from environment variable: 'TestImported'. Properties should be passed explicitly using the /p option.");
+        }
+    }
+
+    [Theory]
+    [InlineData("CheckCandidate", new[] { "CustomRule1", "CustomRule2" })]
+    [InlineData("CheckCandidateWithMultipleChecksInjected", new[] { "CustomRule1", "CustomRule2", "CustomRule3" }, true)]
+    public void CustomCheckTest_NoEditorConfig(string checkCandidate, string[] expectedRegisteredRules, bool expectedRejectedChecks = false)
     {
         using (var env = TestEnvironment.Create())
         {
-            var analysisCandidatePath = Path.Combine(TestAssetsRootPath, analysisCandidate);
-            AddCustomDataSourceToNugetConfig(analysisCandidatePath);
+            var checkCandidatePath = Path.Combine(TestAssetsRootPath, checkCandidate);
+            AddCustomDataSourceToNugetConfig(checkCandidatePath);
 
-            string projectAnalysisBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
-                $"{Path.Combine(analysisCandidatePath, $"{analysisCandidate}.csproj")} /m:1 -nr:False -restore /p:OutputPath={env.CreateFolder().Path} -analyze -verbosity:n",
+            string projectCheckBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
+                $"{Path.Combine(checkCandidatePath, $"{checkCandidate}.csproj")} /m:1 -nr:False -restore -check -verbosity:n",
                 out bool successBuild);
-            successBuild.ShouldBeTrue(projectAnalysisBuildLog);
 
             foreach (string registeredRule in expectedRegisteredRules)
             {
-                projectAnalysisBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CustomAnalyzerSuccessfulAcquisition", registeredRule));
+                projectCheckBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CustomCheckSuccessfulAcquisition", registeredRule));
             }
 
-            if (expectedRejectedAnalyzers)
+            if (!expectedRejectedChecks)
             {
-                projectAnalysisBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CustomAnalyzerBaseTypeNotAssignable", "InvalidAnalyzer", "InvalidCustomAnalyzer, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"));
+                successBuild.ShouldBeTrue(projectCheckBuildLog);
             }
+            else
+            {
+                projectCheckBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(
+                    "CustomCheckBaseTypeNotAssignable",
+                    "InvalidCheck",
+                    "InvalidCustomCheck, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"));
+            }
+        }
+    }
+
+    [Theory]
+    [InlineData("CheckCandidate", "X01234", "error", "error X01234")]
+    [InlineData("CheckCandidateWithMultipleChecksInjected", "X01234", "warning", "warning X01234")]
+    public void CustomCheckTest_WithEditorConfig(string checkCandidate, string ruleId, string severity, string expectedMessage)
+    {
+        using (var env = TestEnvironment.Create())
+        {
+            string checkCandidatePath = Path.Combine(TestAssetsRootPath, checkCandidate);
+
+            // Can't use Transitive environment due to the need to dogfood local nuget packages.
+            AddCustomDataSourceToNugetConfig(checkCandidatePath);
+            string editorConfigName = Path.Combine(checkCandidatePath, EditorConfigFileName);
+            File.WriteAllText(editorConfigName, ReadEditorConfig(
+                new List<(string, string)>() { (ruleId, severity) },
+                ruleToCustomConfig: null,
+                checkCandidatePath));
+
+            string projectCheckBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
+                $"{Path.Combine(checkCandidatePath, $"{checkCandidate}.csproj")} /m:1 -nr:False -restore -check -verbosity:n", out bool _);
+
+            projectCheckBuildLog.ShouldContain(expectedMessage);
+
+            // Cleanup
+            File.Delete(editorConfigName);
         }
     }
 
-    private void AddCustomDataSourceToNugetConfig(string analysisCandidatePath)
+    [Theory]
+    [InlineData(true)]
+    [InlineData(false)]
+    public void DoesNotRunOnRestore(bool buildInOutOfProcessNode)
+    {
+        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", "warning") });
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -t:restore -check",
+            out bool success);
+
+        success.ShouldBeTrue();
+        output.ShouldNotContain("BC0101");
+        output.ShouldNotContain("BC0102");
+        output.ShouldNotContain("BC0103");
+    }
+
+    private void AddCustomDataSourceToNugetConfig(string checkCandidatePath)
     {
-        var nugetTemplatePath = Path.Combine(analysisCandidatePath, "nugetTemplate.config");
+        var nugetTemplatePath = Path.Combine(checkCandidatePath, "nugetTemplate.config");
 
         var doc = new XmlDocument();
         doc.LoadXml(File.ReadAllText(nugetTemplatePath));
@@ -209,11 +370,11 @@ private void AddCustomDataSourceToNugetConfig(string analysisCandidatePath)
         {
             XmlNode? packageSourcesNode = doc.SelectSingleNode("//packageSources");
 
-            // The test packages are generated during the test project build and saved in CustomAnalyzers folder.
-            string analyzersPackagesPath = Path.Combine(Directory.GetParent(AssemblyLocation)?.Parent?.FullName ?? string.Empty, "CustomAnalyzers");
-            AddPackageSource(doc, packageSourcesNode, "Key", analyzersPackagesPath);
+            // The test packages are generated during the test project build and saved in CustomChecks folder.
+            string checksPackagesPath = Path.Combine(Directory.GetParent(AssemblyLocation)?.Parent?.FullName ?? string.Empty, "CustomChecks");
+            AddPackageSource(doc, packageSourcesNode, "Key", checksPackagesPath);
 
-            doc.Save(Path.Combine(analysisCandidatePath, "nuget.config"));
+            doc.Save(Path.Combine(checkCandidatePath, "nuget.config"));
         }
     }
 
@@ -239,31 +400,40 @@ private void PopulateXmlAttribute(XmlDocument doc, XmlNode node, string attribut
     }
 
     private void PrepareSampleProjectsAndConfig(
-    bool buildInOutOfProcessNode,
-    out TransientTestFile projectFile,
-    string? BC0101Severity = null)
+        bool buildInOutOfProcessNode,
+        out TransientTestFile projectFile,
+        string entryProjectAssetName,
+        IEnumerable<string>? supplementalAssetNames = null,
+        IEnumerable<(string RuleId, string Severity)>? ruleToSeverity = null,
+        IEnumerable<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? ruleToCustomConfig = null)
     {
-        string testAssetsFolderName = "SampleAnalyzerIntegrationTest";
+        string testAssetsFolderName = "SampleCheckIntegrationTest";
         TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
         TransientTestFile testFile = _env.CreateFile(workFolder, "somefile");
 
-        string contents = ReadAndAdjustProjectContent("Project1");
-        string contents2 = ReadAndAdjustProjectContent("Project2");
+        string contents = ReadAndAdjustProjectContent(entryProjectAssetName);
+        projectFile = _env.CreateFile(workFolder, entryProjectAssetName, contents);
 
-        projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
-        TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
+        foreach (string supplementalAssetName in supplementalAssetNames ?? Enumerable.Empty<string>())
+        {
+            string supplementalContent = ReadAndAdjustProjectContent(supplementalAssetName);
+            TransientTestFile supplementalFile = _env.CreateFile(workFolder, supplementalAssetName, supplementalContent);
+        }
 
-        CreateEditorConfig(BC0101Severity, testAssetsFolderName, workFolder);
+        _env.CreateFile(workFolder, ".editorconfig", ReadEditorConfig(ruleToSeverity, ruleToCustomConfig, testAssetsFolderName));
 
         // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
-        // This discrepancy breaks path equality checks in analyzers if we pass to MSBuild full path to the initial project.
+        // This discrepancy breaks path equality checks in MSBuild checks if we pass to MSBuild full path to the initial project.
         // See if there is a way of fixing it in the engine - tracked: https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=55702688.
         _env.SetCurrentDirectory(Path.GetDirectoryName(projectFile.Path));
 
         _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", buildInOutOfProcessNode ? "1" : "0");
         _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "1");
 
-        _env.SetEnvironmentVariable("TEST", "FromEnvVariable");
+        // Needed for testing check BC0103
+        _env.SetEnvironmentVariable("TestFromTarget", "FromTarget");
+        _env.SetEnvironmentVariable("TestFromEvaluation", "FromEvaluation");
+        _env.SetEnvironmentVariable("TestImported", "FromEnv");
 
         string ReadAndAdjustProjectContent(string fileName) =>
             File.ReadAllText(Path.Combine(TestAssetsRootPath, testAssetsFolderName, fileName))
@@ -271,12 +441,51 @@ string ReadAndAdjustProjectContent(string fileName) =>
                 .Replace("WorkFolderPath", workFolder.Path);
     }
 
-    private void CreateEditorConfig(string? BC0101Severity, string testAssetsFolderName, TransientTestFolder workFolder)
+    private void PrepareSampleProjectsAndConfig(
+        bool buildInOutOfProcessNode,
+        out TransientTestFile projectFile,
+        IEnumerable<(string RuleId, string Severity)>? ruleToSeverity,
+        IEnumerable<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? ruleToCustomConfig = null)
+        => PrepareSampleProjectsAndConfig(
+            buildInOutOfProcessNode,
+            out projectFile,
+            "Project1.csproj",
+            new[] { "Project2.csproj", "ImportedFile1.props" },
+            ruleToSeverity,
+            ruleToCustomConfig);
+
+    private string ReadEditorConfig(
+        IEnumerable<(string RuleId, string Severity)>? ruleToSeverity,
+        IEnumerable<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? ruleToCustomConfig,
+        string testAssetsFolderName)
+    {
+        string configContent = File.ReadAllText(Path.Combine(TestAssetsRootPath, testAssetsFolderName, $"{EditorConfigFileName}test"));
+
+        PopulateRuleToSeverity(ruleToSeverity, ref configContent);
+        PopulateRuleToCustomConfig(ruleToCustomConfig, ref configContent);
+
+        return configContent;
+    }
+
+    private void PopulateRuleToSeverity(IEnumerable<(string RuleId, string Severity)>? ruleToSeverity, ref string configContent)
     {
-        string configContent = string.IsNullOrEmpty(BC0101Severity)
-            ? File.ReadAllText(Path.Combine(TestAssetsRootPath, testAssetsFolderName, ".editorconfigbasic"))
-            : File.ReadAllText(Path.Combine(TestAssetsRootPath, testAssetsFolderName, ".editorconfigcustomised")).Replace("BC0101Severity", BC0101Severity);
+        if (ruleToSeverity != null && ruleToSeverity.Any())
+        {
+            foreach (var rule in ruleToSeverity)
+            {
+                configContent = configContent.Replace($"build_check.{rule.RuleId}.Severity={rule.RuleId}Severity", $"build_check.{rule.RuleId}.Severity={rule.Severity}");
+            }
+        }
+    }
 
-        _ = _env.CreateFile(workFolder, ".editorconfig", configContent);
+    private void PopulateRuleToCustomConfig(IEnumerable<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? ruleToCustomConfig, ref string configContent)
+    {
+        if (ruleToCustomConfig != null && ruleToCustomConfig.Any())
+        {
+            foreach (var rule in ruleToCustomConfig)
+            {
+                configContent = configContent.Replace($"build_check.{rule.RuleId}.CustomConfig=dummy", $"build_check.{rule.RuleId}.{rule.CustomConfig.ConfigKey}={rule.CustomConfig.Value}");
+            }
+        }
     }
 }
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index 6a72903b8e6..3961ef049c3 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -17,9 +17,9 @@
   </ItemGroup>
   
   <ItemGroup Label="TestAssests">
-    <ProjectReference Include=".\TestAssets\CustomAnalyzer\CustomAnalyzer.csproj" />
-    <ProjectReference Include=".\TestAssets\CustomAnalyzer2\CustomAnalyzer2.csproj" />
-    <ProjectReference Include=".\TestAssets\InvalidCustomAnalyzer\InvalidCustomAnalyzer.csproj" />
+    <ProjectReference Include=".\TestAssets\CustomCheck\CustomCheck.csproj" />
+    <ProjectReference Include=".\TestAssets\CustomCheck2\CustomCheck2.csproj" />
+    <ProjectReference Include=".\TestAssets\InvalidCustomCheck\InvalidCustomCheck.csproj" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs b/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs
new file mode 100644
index 00000000000..954f69ed050
--- /dev/null
+++ b/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs
@@ -0,0 +1,59 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+namespace Microsoft.Build.BuildCheck.UnitTests
+{
+    internal sealed class MockBuildCheckRegistrationContext : IBuildCheckRegistrationContext
+    {
+        private event Action<BuildCheckDataContext<TaskInvocationCheckData>>? _taskInvocationAction;
+        private event Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>>? _evaluatedPropertiesAction;
+
+        public List<BuildCheckResult> Results { get; } = new();
+
+        public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction)
+            => _evaluatedPropertiesAction += evaluatedPropertiesAction;
+        public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction) => throw new NotImplementedException();
+
+        public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction)
+            => _taskInvocationAction += taskInvocationAction;
+
+        public void RegisterBuildFinishedAction(Action<BuildCheckDataContext<BuildFinishedCheckData>> buildFinishedAction) => throw new NotImplementedException();
+
+        public void TriggerTaskInvocationAction(TaskInvocationCheckData data)
+        {
+            if (_taskInvocationAction is not null)
+            {
+                BuildCheckDataContext<TaskInvocationCheckData> context = new BuildCheckDataContext<TaskInvocationCheckData>(
+                    null!,
+                    null!,
+                    null!,
+                    ResultHandler,
+                    data);
+                _taskInvocationAction(context);
+            }
+        }
+        public void TriggerEvaluatedPropertiesAction(EvaluatedPropertiesCheckData data)
+        {
+            if (_evaluatedPropertiesAction is not null)
+            {
+                BuildCheckDataContext<EvaluatedPropertiesCheckData> context = new BuildCheckDataContext<EvaluatedPropertiesCheckData>(
+                    null!,
+                    null!,
+                    null!,
+                    ResultHandler,
+                    data);
+                _evaluatedPropertiesAction(context);
+            }
+        }
+
+        private void ResultHandler(CheckWrapper wrapper, ICheckContext context, CheckConfigurationEffective[] configs, BuildCheckResult result)
+            => Results.Add(result);
+
+        public void RegisterEnvironmentVariableReadAction(Action<BuildCheckDataContext<EnvironmentVariableCheckData>> environmentVariableAction) => throw new NotImplementedException();
+    }
+}
diff --git a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
index 7734c19f311..f9f5612c0bb 100644
--- a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
+++ b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
@@ -10,7 +10,7 @@
 
 namespace Microsoft.Build.BuildCheck.UnitTests;
 
-public class ParsedItemsAnalysisDataTests
+public class ParsedItemsCheckDataTests
 {
     [Fact]
     public void ItemsHolder_GetItemsOfType_ShouldFilterProperly()
diff --git a/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs b/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs
new file mode 100644
index 00000000000..e3bc5adab4f
--- /dev/null
+++ b/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs
@@ -0,0 +1,137 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Checks;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests
+{
+    public class SharedOutputPathCheck_Tests
+    {
+        private readonly SharedOutputPathCheck _check;
+
+        private readonly MockBuildCheckRegistrationContext _registrationContext;
+
+        public SharedOutputPathCheck_Tests()
+        {
+            _check = new SharedOutputPathCheck();
+            _registrationContext = new MockBuildCheckRegistrationContext();
+            _check.RegisterActions(_registrationContext);
+        }
+
+        private EvaluatedPropertiesCheckData MakeEvaluatedPropertiesAction(
+            string projectFile,
+            Dictionary<string, string>? evaluatedProperties,
+            IReadOnlyDictionary<string, (string EnvVarValue, string File, int Line, int Column)>? evaluatedEnvVars)
+        {
+            return new EvaluatedPropertiesCheckData(
+                projectFile,
+                null,
+                evaluatedProperties ?? new Dictionary<string, string>());
+        }
+
+        [Fact]
+        public void TestTwoProjectsWithSameRelativeOutputPath()
+        {
+            // Full output and intermediate paths are different: "C:/fake1/bin/Debug" and "C:/fake1/obj/Debug".
+            string projectFile1 = NativeMethodsShared.IsWindows ? "C:\\fake1\\project1.proj" : "/fake1/project1.proj";
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile1,
+                new Dictionary<string, string> {
+                    { "OutputPath", "bin/Debug" },
+                    { "IntermediateOutputPath", "obj/Debug" },
+                },
+                null));
+
+            // Full output and intermediate paths are different: "C:/fake2/bin/Debug" and "C:/fake2/obj/Debug".
+            string projectFile2 = NativeMethodsShared.IsWindows ? "C:\\fake2\\project2.proj" : "/fake2/project2.proj";
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile2,
+                new Dictionary<string, string> {
+                    { "OutputPath", "bin/Debug" },
+                    { "IntermediateOutputPath", "obj/Debug" },
+                },
+                null));
+
+            // Relative paths coincide but full does not. SharedOutputPathCheck should not report it.
+            _registrationContext.Results.Count.ShouldBe(0);
+        }
+
+        [Fact]
+        public void TestProjectsWithDifferentPathsSeparators()
+        {
+            // Paths separators are messed up.
+            string projectFile1 = NativeMethodsShared.IsWindows ? "C:\\fake\\project1.proj" : "/fake/project1.proj";
+            string projectFile2 = NativeMethodsShared.IsWindows ? "C:\\fake\\project2.proj" : "/fake/project2.proj";
+
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile1,
+                new Dictionary<string, string> {
+                    { "OutputPath", "bin/Debug" },
+                    { "IntermediateOutputPath", "obj\\Debug" },
+                },
+                null));
+
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile2,
+                new Dictionary<string, string> {
+                    { "OutputPath", "bin/Debug" },
+                    { "IntermediateOutputPath", "obj\\Debug" },
+                },
+                null));
+
+            // 2 reports for bin and obj folders.
+            _registrationContext.Results.Count.ShouldBe(2);
+            _registrationContext.Results[0].CheckRule.Id.ShouldBe("BC0101");
+            _registrationContext.Results[1].CheckRule.Id.ShouldBe("BC0101");
+
+            // Check that paths are formed with correct paths separators
+            string wrongPathSeparator = NativeMethodsShared.IsWindows ? "/" : "\\";
+
+            foreach (string path in _registrationContext.Results[0].MessageArgs)
+            {
+                path.ShouldNotContain(wrongPathSeparator);
+            }
+            foreach (string path in _registrationContext.Results[1].MessageArgs)
+            {
+                path.ShouldNotContain(wrongPathSeparator);
+            }
+        }
+
+        [Fact]
+        public void TestThreeProjectsWithSameOutputPath()
+        {
+            string projectFolder = NativeMethodsShared.IsWindows ? "C:\\fake\\" : "/fake/";
+            string projectFile1 = $"{projectFolder}project1.proj";
+            string projectFile2 = $"{projectFolder}project2.proj";
+            string projectFile3 = $"{projectFolder}project3.proj";
+            var evaluatedProperties = new Dictionary<string, string> {
+                    { "OutputPath", "bin/Debug" },
+                    { "IntermediateOutputPath", "obj\\Debug" },};
+
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile1,
+                evaluatedProperties,
+                null));
+
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile2,
+                evaluatedProperties,
+                null));
+
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile3,
+                evaluatedProperties,
+                null));
+
+            _registrationContext.Results.Count.ShouldBe(4); // 4 reports for two pairs of project: (1, 2) and (1, 3).
+            foreach (var result in _registrationContext.Results)
+            {
+                result.CheckRule.Id.ShouldBe("BC0101");
+            }
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
index 99d52c7f9f1..7d109f7da15 100644
--- a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
+++ b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
@@ -17,18 +17,18 @@
 
 namespace Microsoft.Build.BuildCheck.UnitTests
 {
-    public class TaskInvocationAnalysisDataTests : IDisposable
+    public class TaskInvocationCheckDataTests : IDisposable
     {
-        internal sealed class TestAnalyzer : BuildAnalyzer
+        internal sealed class TestCheck : Check
         {
-            #region BuildAnalyzer initialization
+            #region Check initialization
 
-            public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("BC0000", "TestRule", "TestDescription", "TestMessage",
-                new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning });
+            public static CheckRule SupportedRule = new CheckRule("BC0000", "TestRule", "TestDescription", "TestMessage",
+                new CheckConfiguration() { Severity = CheckResultSeverity.Warning });
 
-            public override string FriendlyName => "MSBuild.TestAnalyzer";
+            public override string FriendlyName => "MSBuild.TestCheck";
 
-            public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+            public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
 
             public override void Initialize(ConfigurationContext configurationContext)
             { }
@@ -43,29 +43,29 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             /// <summary>
             /// Stores all TaskInvocationAnalysisData reported during the build.
             /// </summary>
-            public List<TaskInvocationAnalysisData> AnalysisData = new();
+            public List<TaskInvocationCheckData> CheckData = new();
 
-            private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+            private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationCheckData> context)
             {
-                AnalysisData.Add(context.Data);
+                CheckData.Add(context.Data);
             }
         }
 
-        private static TestAnalyzer? s_testAnalyzer;
+        private static TestCheck? s_testCheck;
 
-        public TaskInvocationAnalysisDataTests()
+        public TaskInvocationCheckDataTests()
         {
             BuildCheckManager.s_testFactoriesPerDataSource =
             [
                 // BuildCheckDataSource.EventArgs
                 [
-                    ([TestAnalyzer.SupportedRule.Id], true, () => (s_testAnalyzer = new TestAnalyzer())),
+                    ([TestCheck.SupportedRule.Id], true, () => (s_testCheck = new TestCheck())),
                 ],
                 // BuildCheckDataSource.Execution
                 [],
             ];
 
-            s_testAnalyzer?.AnalysisData.Clear();
+            s_testCheck?.CheckData.Clear();
         }
 
         public void Dispose()
@@ -94,7 +94,7 @@ private void BuildProject(string taskInvocation)
                     result.OverallResult.ShouldBe(BuildResultCode.Success);
                 }
 
-                foreach (var data in s_testAnalyzer!.AnalysisData)
+                foreach (var data in s_testCheck!.CheckData)
                 {
                     data.ProjectFilePath.ShouldBe(testProject.ProjectFile);
                     data.TaskInvocationLocation.Line.ShouldBeGreaterThan(0);
@@ -108,8 +108,8 @@ public void ReportsSimpleTaskParameters()
         {
             BuildProject("<Message Text='Hello'/>");
 
-            s_testAnalyzer!.AnalysisData.Count.ShouldBe(1);
-            var data = s_testAnalyzer.AnalysisData[0];
+            s_testCheck!.CheckData.Count.ShouldBe(1);
+            var data = s_testCheck.CheckData[0];
             data.TaskName.ShouldBe("Message");
             data.Parameters.Count.ShouldBe(1);
             data.Parameters["Text"].IsOutput.ShouldBe(false);
@@ -130,8 +130,8 @@ public void ReportsComplexTaskParameters(string outputElement)
                 </CombinePath>
             """);
 
-            s_testAnalyzer!.AnalysisData.Count.ShouldBe(1);
-            var data = s_testAnalyzer.AnalysisData[0];
+            s_testCheck!.CheckData.Count.ShouldBe(1);
+            var data = s_testCheck.CheckData[0];
             data.TaskName.ShouldBe("CombinePath");
             data.Parameters.Count.ShouldBe(3);
 
@@ -174,8 +174,8 @@ public void TaskParameterEnumeratesValues()
             parameter5.EnumerateValues().SequenceEqual(array2).ShouldBeTrue();
             parameter5.EnumerateStringValues().SequenceEqual(["item1", "item2"]).ShouldBeTrue();
 
-            static TaskInvocationAnalysisData.TaskParameter MakeParameter(object value)
-                => new TaskInvocationAnalysisData.TaskParameter(value, IsOutput: false);
+            static TaskInvocationCheckData.TaskParameter MakeParameter(object value)
+                => new TaskInvocationCheckData.TaskParameter(value, IsOutput: false);
         }
     }
 }
diff --git a/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/.editorconfigtest b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/.editorconfigtest
new file mode 100644
index 00000000000..be166e833cd
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/.editorconfigtest
@@ -0,0 +1,4 @@
+root = true
+
+[*.csproj]
+build_check.X01234.Severity=X01234Severity
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/AnalysisCandidate.csproj b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/CheckCandidate.csproj
similarity index 83%
rename from src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/AnalysisCandidate.csproj
rename to src/BuildCheck.UnitTests/TestAssets/CheckCandidate/CheckCandidate.csproj
index 52f65afffee..6d35fe06138 100644
--- a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/AnalysisCandidate.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/CheckCandidate.csproj
@@ -6,7 +6,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <PackageReference Include="CustomAnalyzer" Version="1.0.0"/>
+    <PackageReference Include="CustomCheck" Version="1.0.0"/>
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/nugetTemplate.config
similarity index 100%
rename from src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config
rename to src/BuildCheck.UnitTests/TestAssets/CheckCandidate/nugetTemplate.config
diff --git a/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/.editorconfigtest b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/.editorconfigtest
new file mode 100644
index 00000000000..be166e833cd
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/.editorconfigtest
@@ -0,0 +1,4 @@
+root = true
+
+[*.csproj]
+build_check.X01234.Severity=X01234Severity
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/CheckCandidateWithMultipleChecksInjected.csproj
similarity index 62%
rename from src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj
rename to src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/CheckCandidateWithMultipleChecksInjected.csproj
index 0ffaa8d26b7..07695e19e8e 100644
--- a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/CheckCandidateWithMultipleChecksInjected.csproj
@@ -6,9 +6,9 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <PackageReference Include="CustomAnalyzer" Version="1.0.0"/>
-    <PackageReference Include="CustomAnalyzer2" Version="1.0.0"/>
-    <PackageReference Include="InvalidCustomAnalyzer" Version="1.0.0"/>
+    <PackageReference Include="CustomCheck" Version="1.0.0"/>
+    <PackageReference Include="CustomCheck2" Version="1.0.0"/>
+    <PackageReference Include="InvalidCustomCheck" Version="1.0.0"/>
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/nugetTemplate.config
similarity index 100%
rename from src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config
rename to src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/nugetTemplate.config
diff --git a/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
index 4e4cb1c0796..d79475be5f0 100644
--- a/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
+++ b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
@@ -5,7 +5,7 @@
     <IsPackable>true</IsPackable>
     <IsShipping>false</IsShipping>
     <PackageVersion>1.0.0</PackageVersion>
-    <ArtifactsNonShippingPackagesDir>$(ArtifactsBinDir)Microsoft.Build.BuildCheck.UnitTests\CustomAnalyzers</ArtifactsNonShippingPackagesDir>
+    <ArtifactsNonShippingPackagesDir>$(ArtifactsBinDir)Microsoft.Build.BuildCheck.UnitTests\CustomChecks</ArtifactsNonShippingPackagesDir>
     <NoWarn>NU5101;NU5128;MSB3277;NU1507;NU1701;NU1702;NU5104</NoWarn>
   </PropertyGroup>
 
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.props b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.props
deleted file mode 100644
index 31a9526dd62..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.props
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project>
-  <PropertyGroup>
-	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)CustomAnalyzer.dll))</MSBuildAnalyzer>
-  </PropertyGroup>
-</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md
deleted file mode 100644
index 4f29145e7f0..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# MSBuild Custom Analyzer Template
-
-## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
-
-## Features
-- Simplified template for creating MSBuild analyzer libraries.
-- Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
-
-## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
-1. Install the template using the following command:
-   ```bash
-   dotnet new install msbuildanalyzer
-2. Instantiate a custom template:
-   ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
-
-### Prerequisites
-- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.props b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.props
deleted file mode 100644
index 869000fa12f..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.props
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project>
-  <PropertyGroup>
-	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)CustomAnalyzer2.dll))</MSBuildAnalyzer>
-  </PropertyGroup>
-</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md
deleted file mode 100644
index 4f29145e7f0..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# MSBuild Custom Analyzer Template
-
-## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
-
-## Features
-- Simplified template for creating MSBuild analyzer libraries.
-- Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
-
-## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
-1. Install the template using the following command:
-   ```bash
-   dotnet new install msbuildanalyzer
-2. Instantiate a custom template:
-   ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
-
-### Prerequisites
-- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer1.cs b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check1.cs
similarity index 68%
rename from src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer1.cs
rename to src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check1.cs
index af307edc6fc..e03ad7a118b 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer1.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check1.cs
@@ -5,24 +5,24 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace CustomAnalyzer
+namespace CustomCheck
 {
-    public sealed class Analyzer1 : BuildAnalyzer
+    public sealed class Check1 : Check
     {
-        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        public static CheckRule SupportedRule = new CheckRule(
             "X01234",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildAnalyzerConfiguration());
+            new CheckConfiguration());
 
         public override string FriendlyName => "CustomRule1";
 
-        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
         public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
@@ -30,7 +30,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
         }
 
-        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
         {
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer2.cs b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check2.cs
similarity index 68%
rename from src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer2.cs
rename to src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check2.cs
index 5f6201caea8..d876628ef35 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer2.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check2.cs
@@ -5,24 +5,24 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace CustomAnalyzer
+namespace CustomCheck
 {
-    public sealed class Analyzer2 : BuildAnalyzer
+    public sealed class Check2 : Check
     {
-        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        public static CheckRule SupportedRule = new CheckRule(
             "X01235",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildAnalyzerConfiguration());
+            new CheckConfiguration());
 
         public override string FriendlyName => "CustomRule2";
 
-        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
         public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
@@ -30,7 +30,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
         }
 
-        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
         {
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.csproj
similarity index 79%
rename from src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj
rename to src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.csproj
index f27ab620690..fc81bc53eb5 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.csproj
@@ -8,7 +8,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <None Include="CustomAnalyzer.props" Pack="true" PackagePath="build\CustomAnalyzer.props" />
+    <None Include="CustomCheck.props" Pack="true" PackagePath="build\CustomCheck.props" />
     <Content Include="README.md" />
   </ItemGroup>
 
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.props b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.props
new file mode 100644
index 00000000000..f7aae0517f4
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)CustomCheck.dll))</MSBuildCheck>
+  </PropertyGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomCheck/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/README.md
new file mode 100644
index 00000000000..ef41e00277e
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Check Template
+
+## Overview
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild check libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom check rules.
+
+## Getting Started
+To use the MSBuild Custom Check Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildcheck
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildcheck -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Analyzer3.cs b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/Check3.cs
similarity index 68%
rename from src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Analyzer3.cs
rename to src/BuildCheck.UnitTests/TestAssets/CustomCheck2/Check3.cs
index e3f23d5ea68..a5f64e43f6f 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Analyzer3.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/Check3.cs
@@ -5,24 +5,24 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace CustomAnalyzer2
+namespace CustomCheck2
 {
-    public sealed class Analyzer3 : BuildAnalyzer
+    public sealed class Check3 : Check
     {
-        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        public static CheckRule SupportedRule = new CheckRule(
             "X01235",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildAnalyzerConfiguration());
+            new CheckConfiguration());
 
         public override string FriendlyName => "CustomRule3";
 
-        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
         public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
@@ -30,7 +30,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
         }
 
-        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
         {
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.csproj
similarity index 78%
rename from src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj
rename to src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.csproj
index a405546f1cc..5d4396dea07 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.csproj
@@ -8,7 +8,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <None Include="CustomAnalyzer2.props" Pack="true" PackagePath="build\CustomAnalyzer2.props" />
+    <None Include="CustomCheck2.props" Pack="true" PackagePath="build\CustomCheck2.props" />
     <Content Include="README.md" />
   </ItemGroup>
 
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.props b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.props
new file mode 100644
index 00000000000..f2377250f91
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)CustomCheck2.dll))</MSBuildCheck>
+  </PropertyGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/README.md
new file mode 100644
index 00000000000..ef41e00277e
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Check Template
+
+## Overview
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild check libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom check rules.
+
+## Getting Started
+To use the MSBuild Custom Check Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildcheck
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildcheck -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs
deleted file mode 100644
index dcdee780a8b..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Collections.Generic;
-
-namespace InvalidCustomAnalyzer
-{
-    public sealed class InvalidAnalyzer
-    {
-        public string FriendlyName => "InvalidAnalyzer";
-    }
-}
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props
deleted file mode 100644
index 52a9bab57c0..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project>
-  <PropertyGroup>
-	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)InvalidCustomAnalyzer.dll))</MSBuildAnalyzer>
-  </PropertyGroup>
-</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md
deleted file mode 100644
index 4f29145e7f0..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# MSBuild Custom Analyzer Template
-
-## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
-
-## Features
-- Simplified template for creating MSBuild analyzer libraries.
-- Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
-
-## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
-1. Install the template using the following command:
-   ```bash
-   dotnet new install msbuildanalyzer
-2. Instantiate a custom template:
-   ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
-
-### Prerequisites
-- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCheck.cs b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCheck.cs
new file mode 100644
index 00000000000..0b727549e95
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCheck.cs
@@ -0,0 +1,9 @@
+﻿using System.Collections.Generic;
+
+namespace InvalidCustomCheck
+{
+    public sealed class InvalidCheck
+    {
+        public string FriendlyName => "InvalidCheck";
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.csproj
similarity index 76%
rename from src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj
rename to src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.csproj
index 4ef7f0674ca..81c7c28efe7 100644
--- a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.csproj
@@ -8,7 +8,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <None Include="InvalidCustomAnalyzer.props" Pack="true" PackagePath="build\InvalidCustomAnalyzer.props" />
+    <None Include="InvalidCustomCheck.props" Pack="true" PackagePath="build\InvalidCustomCheck.props" />
     <Content Include="README.md" />
   </ItemGroup>
 
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.props b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.props
new file mode 100644
index 00000000000..01867df6b8a
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)InvalidCustomCheck.dll))</MSBuildCheck>
+  </PropertyGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/README.md b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/README.md
new file mode 100644
index 00000000000..ef41e00277e
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Check Template
+
+## Overview
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild check libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom check rules.
+
+## Getting Started
+To use the MSBuild Custom Check Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildcheck
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildcheck -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigbasic b/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigbasic
deleted file mode 100644
index 6943aa8dd95..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigbasic
+++ /dev/null
@@ -1,11 +0,0 @@
-root=true
-
-[*.csproj]
-build_check.BC0101.Severity=warning
-
-build_check.BC0102.Severity=warning
-build_check.BC0103.Severity=warning
-
-build_check.COND0543.Severity=Error
-build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
-build_check.COND0543.CustomSwitch=QWERTY
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigcustomised b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
similarity index 51%
rename from src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigcustomised
rename to src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
index 28ca732c908..9b63ef6a700 100644
--- a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigcustomised
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
@@ -4,8 +4,14 @@ root=true
 build_check.BC0101.Severity=BC0101Severity
 
 build_check.BC0102.Severity=warning
+
 build_check.BC0103.Severity=warning
+build_check.BC0103.CustomConfig=dummy
 
 build_check.COND0543.Severity=Error
-build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
+build_check.COND0543.EvaluationCheckScope=CheckedProjectOnly
 build_check.COND0543.CustomSwitch=QWERTY
+
+build_check.BC0201.Severity=warning
+build_check.BC0202.Severity=warning
+build_check.BC0203.Severity=warning
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/ImportedFile1.props b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/ImportedFile1.props
new file mode 100644
index 00000000000..ff344c1d281
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/ImportedFile1.props
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+
+    <PropertyGroup Condition="$(TestImported) == true">
+        <TestProperty>TestImported</TestProperty>
+    </PropertyGroup>
+
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project1 b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1.csproj
similarity index 72%
rename from src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project1
rename to src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1.csproj
index 15f7efc4ff6..81efb8fd795 100644
--- a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project1
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1.csproj
@@ -6,19 +6,24 @@
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>
-     
+
+   <Import Project="ImportedFile1.props" />
+
    <PropertyGroup Condition="$(Test) == true">
        <TestProperty>Test</TestProperty>
    </PropertyGroup>
 
+    <PropertyGroup>
+        <ReadFromEnv>$(TestFromEvaluation)</ReadFromEnv>
+    </PropertyGroup>
 
    <Target Name="Hello">
        <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
        <Copy SourceFiles="TestFilePath" DestinationFolder="WorkFolderPath" />
-       <MSBuild Projects=".\FooBar-Copy.csproj" Targets="Hello" />
+       <MSBuild Projects=".\Project2.csproj" Targets="Hello" />
 
        <PropertyGroup>
-         <ReadFromEnvVariable>$(TEST)</ReadFromEnvVariable>
+         <ReadFromEnvVariable>$(TestFromTarget)</ReadFromEnvVariable>
        </PropertyGroup>
 
        <Message Importance="High" Text="$(ReadFromEnvVariable)" />
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project2 b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project2.csproj
similarity index 91%
rename from src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project2
rename to src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project2.csproj
index 17b8d3da249..b8355528363 100644
--- a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project2
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project2.csproj
@@ -11,7 +11,7 @@
     </PropertyGroup>
                     
     <ItemGroup>
-        <Reference Include="bin/foo.dll" />
+        <Reference Include="bin/Project1.dll" />
     </ItemGroup>
                     
     <Target Name="Hello">
@@ -19,4 +19,4 @@
         <Copy SourceFiles="TestFilePath" DestinationFolder="WorkFolderPath" />
     </Target>
                    
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/PropsCheckTest.csproj b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/PropsCheckTest.csproj
new file mode 100644
index 00000000000..4e5bb2af0e3
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/PropsCheckTest.csproj
@@ -0,0 +1,26 @@
+<Project DefaultTargets="PrintEnvVar">
+    <PropertyGroup>
+        <!--
+        <MyProp1>value-of-prop1</MyProp1>
+        <MyProp2>$(MyProp1)</MyProp2>
+        <MyProp3>blah</MyProp3>
+        -->
+    </PropertyGroup>
+
+    <PropertyGroup Condition="'$(MyProp12)' == ''">
+        <MyProp13>$(MyProp11)</MyProp13>
+    </PropertyGroup>
+
+    <!--
+        <ItemGroup>
+        <a Include="$(nonexistent)" />
+        </ItemGroup>
+    -->
+
+    <Target Name="PrintEnvVar">
+        <Message Text="MyPropT2 has value $(MyPropT2)" Importance="High" Condition="'$(MyPropT2)' == ''" />
+        <PropertyGroup>
+            <MyPropT2>$(MyPropT2);xxx</MyPropT2>
+        </PropertyGroup>
+    </Target>
+</Project>
diff --git a/src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs b/src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs
new file mode 100644
index 00000000000..1db4853b515
--- /dev/null
+++ b/src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs
@@ -0,0 +1,66 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Framework.UnitTests
+{
+    public class BuildSubmissionStartedEventAgs_Tests
+    {
+        [Fact]
+        public void SerializationDeserializationTest()
+        {
+            var globalVariables = new Dictionary<string, string?>
+            {
+                {"Variable1", "Value1" },
+                {"Variable2", "" },
+                {"Variable3", null },
+            };
+
+            var entryPointProjects = new List<string>()
+            {
+                "project1",
+                "project2",
+                "",
+            };
+            var targetNames = new List<string>()
+            {
+                "target1",
+                "target2",
+                "",
+            };
+            var flag = Execution.BuildRequestDataFlags.FailOnUnresolvedSdk;
+            var submissionId = 1234;
+
+            BuildSubmissionStartedEventArgs args = new(
+                globalVariables,
+                entryPointProjects,
+                targetNames,
+                flag,
+                submissionId);
+
+            using MemoryStream stream = new MemoryStream();
+            using BinaryWriter bw = new BinaryWriter(stream);
+            args.WriteToStream(bw);
+
+            stream.Position = 0;
+            using BinaryReader br = new BinaryReader(stream);
+            BuildSubmissionStartedEventArgs argDeserialized = new();
+            int packetVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
+
+            argDeserialized.CreateFromStream(br, packetVersion);
+            argDeserialized.GlobalProperties.ShouldBe(globalVariables);
+            argDeserialized.EntryProjectsFullPath.ShouldBe(entryPointProjects);
+            argDeserialized.TargetNames.ShouldBe(targetNames);
+            argDeserialized.Flags.ShouldBe(flag);
+            argDeserialized.SubmissionId.ShouldBe(submissionId);
+        }
+    }
+} 
diff --git a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
index 67bacf49a74..7eb7895b2df 100644
--- a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
@@ -50,30 +50,6 @@ public void EventArgsCtors()
             projectStartedEvent = new ProjectStartedEventArgs(1, null, null, null, null, null, null, null, DateTime.Now);
         }
 
-        /// <summary>
-        /// Verify different Items and properties are not taken into account in the equals comparison. They should
-        /// not be considered as part of the equals evaluation
-        /// </summary>
-        [Fact]
-        public void ItemsAndPropertiesDifferentEquals()
-        {
-            ArrayList itemsList = new ArrayList();
-            ArrayList propertiesList = new ArrayList();
-            ProjectStartedEventArgs differentItemsAndProperties = new ProjectStartedEventArgs(
-                  s_baseProjectStartedEvent.ProjectId,
-                  s_baseProjectStartedEvent.Message,
-                  s_baseProjectStartedEvent.HelpKeyword,
-                  s_baseProjectStartedEvent.ProjectFile,
-                  s_baseProjectStartedEvent.TargetNames,
-                  propertiesList,
-                  itemsList,
-                  s_baseProjectStartedEvent.ParentProjectBuildEventContext,
-                  s_baseProjectStartedEvent.Timestamp);
-
-            s_baseProjectStartedEvent.Properties.ShouldNotBe(propertiesList);
-            s_baseProjectStartedEvent.Items.ShouldNotBe(itemsList);
-        }
-
         /// <summary>
         /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index a2a72ede9eb..41a5914dad6 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -1197,11 +1197,15 @@ public void TranslateEnum<T>(ref T value, int numericValue)
             /// <param name="value">The value to be translated.</param>
             public void TranslateDotNet<T>(ref T value)
             {
-                if (!TranslateNullable(value))
+                // All the calling paths are already guarded by ChangeWaves.Wave17_10 - so it's a no-op adding it here as well.
+                // But let's have it here explicitly - so it's clearer for the CodeQL reviewers.
+                if (!TranslateNullable(value) || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))
                 {
                     return;
                 }
 
+                // codeql[cs/dangerous-binary-deserialization] This code needs explicit opt-in to be used (ChangeWaves.Wave17_10). This exists as a temporary compat opt-in for old 3rd party loggers, before they are migrated based on documented guidance.
+                // The opt-in documentation: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves.md#1710
                 BinaryFormatter formatter = new BinaryFormatter();
                 formatter.Serialize(_packetStream, value);
             }
diff --git a/src/Framework/BuildCheck/BuildCheckEventArgs.cs b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
index 9a8c3459b87..5a2d1ad5043 100644
--- a/src/Framework/BuildCheck/BuildCheckEventArgs.cs
+++ b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
@@ -4,9 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -30,10 +27,7 @@ internal BuildCheckTracingEventArgs()
     {
     }
 
-    internal BuildCheckTracingEventArgs(Dictionary<string, TimeSpan> data, bool isAggregatedGlobalReport) : this(data)
-    {
-        IsAggregatedGlobalReport = isAggregatedGlobalReport;
-    }
+    internal BuildCheckTracingEventArgs(Dictionary<string, TimeSpan> data, bool isAggregatedGlobalReport) : this(data) => IsAggregatedGlobalReport = isAggregatedGlobalReport;
 
     /// <summary>
     /// When true, the tracing information is from the whole build for logging purposes
@@ -71,15 +65,15 @@ internal override void CreateFromStream(BinaryReader reader, int version)
     }
 }
 
-internal sealed class BuildCheckAcquisitionEventArgs(string acquisitionPath) : BuildCheckEventArgs
+internal sealed class BuildCheckAcquisitionEventArgs(string acquisitionPath, string projectPath) : BuildCheckEventArgs
 {
     internal BuildCheckAcquisitionEventArgs()
-        : this(string.Empty)
+        : this(string.Empty, string.Empty)
     {
     }
 
     /// <summary>
-    /// Gets the path to the analyzer assembly that needs to be loaded into the application context.
+    /// Gets the path to the check assembly that needs to be loaded into the application context.
     /// </summary>
     /// <remarks>
     /// The <see cref="AcquisitionPath"/> property contains the file system path to the assembly
@@ -91,11 +85,14 @@ internal BuildCheckAcquisitionEventArgs()
     /// </value>
     public string AcquisitionPath { get; private set; } = acquisitionPath;
 
+    public string ProjectPath { get; private set; } = projectPath;
+
     internal override void WriteToStream(BinaryWriter writer)
     {
         base.WriteToStream(writer);
 
         writer.Write(AcquisitionPath);
+        writer.Write(ProjectPath);
     }
 
     internal override void CreateFromStream(BinaryReader reader, int version)
@@ -103,15 +100,19 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         base.CreateFromStream(reader, version);
 
         AcquisitionPath = reader.ReadString();
+        ProjectPath = reader.ReadString();
     }
 }
+
 internal sealed class BuildCheckResultWarning : BuildWarningEventArgs
 {
     public BuildCheckResultWarning(IBuildCheckResult result, string code)
-        : base(subcategory: null, code: code, file: null, lineNumber: 0, columnNumber: 0, endLineNumber: 0, endColumnNumber: 0, message: result.FormatMessage(), helpKeyword: null, senderName: null)
-    {
+        : base(subcategory: null, code: code, file: null, lineNumber: 0, columnNumber: 0, endLineNumber: 0, endColumnNumber: 0, message: result.FormatMessage(), helpKeyword: null, senderName: null) =>
         RawMessage = result.FormatMessage();
-    }
+
+    internal BuildCheckResultWarning(string formattedMessage, string code)
+        : base(subcategory: null, code: code, file: null, lineNumber: 0, columnNumber: 0, endLineNumber: 0, endColumnNumber: 0, message: formattedMessage, helpKeyword: null, senderName: null) =>
+        RawMessage = formattedMessage;
 
     internal BuildCheckResultWarning() { }
 
@@ -134,9 +135,11 @@ internal sealed class BuildCheckResultError : BuildErrorEventArgs
 {
     public BuildCheckResultError(IBuildCheckResult result, string code)
         : base(subcategory: null, code: code, file: null, lineNumber: 0, columnNumber: 0, endLineNumber: 0, endColumnNumber: 0, message: result.FormatMessage(), helpKeyword: null, senderName: null)
-    {
-        RawMessage = result.FormatMessage();
-    }
+        => RawMessage = result.FormatMessage();
+
+    internal BuildCheckResultError(string formattedMessage, string code)
+        : base(subcategory: null, code: code, file: null, lineNumber: 0, columnNumber: 0, endLineNumber: 0, endColumnNumber: 0, message: formattedMessage, helpKeyword: null, senderName: null)
+        => RawMessage = formattedMessage;
 
     internal BuildCheckResultError() { }
 
@@ -157,10 +160,9 @@ internal override void CreateFromStream(BinaryReader reader, int version)
 
 internal sealed class BuildCheckResultMessage : BuildMessageEventArgs
 {
-    public BuildCheckResultMessage(IBuildCheckResult result)
-    {
-        RawMessage = result.FormatMessage();
-    }
+    public BuildCheckResultMessage(IBuildCheckResult result) => RawMessage = result.FormatMessage();
+
+    internal BuildCheckResultMessage(string formattedMessage) => RawMessage = formattedMessage;
 
     internal BuildCheckResultMessage() { }
 
diff --git a/src/Framework/BuildRequestDataFlags.cs b/src/Framework/BuildRequestDataFlags.cs
new file mode 100644
index 00000000000..8a0c1f585f2
--- /dev/null
+++ b/src/Framework/BuildRequestDataFlags.cs
@@ -0,0 +1,87 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+// Note: Namespace is within Build.Execution for type forwarding to work correctly
+namespace Microsoft.Build.Execution
+{
+    /// <summary>
+    /// Flags providing additional control over the build request
+    /// </summary>
+    [Flags]
+    public enum BuildRequestDataFlags
+    {
+        /// <summary>
+        /// No flags.
+        /// </summary>
+        None = 0,
+
+        /// <summary>
+        /// When this flag is present, the existing ProjectInstance in the build will be replaced by this one.
+        /// </summary>
+        ReplaceExistingProjectInstance = 1 << 0,
+
+        /// <summary>
+        /// When this flag is present, the "BuildResult" issued in response to this request will
+        /// include "BuildResult.ProjectStateAfterBuild".
+        /// </summary>
+        ProvideProjectStateAfterBuild = 1 << 1,
+
+        /// <summary>
+        /// When this flag is present and the project has previously been built on a node whose affinity is
+        /// incompatible with the affinity this request requires, we will ignore the project state (but not
+        /// target results) that were previously generated.
+        /// </summary>
+        /// <remarks>
+        /// This usually is not desired behavior.  It is only provided for those cases where the client
+        /// knows that the new build request does not depend on project state generated by a previous request.  Setting
+        /// this flag can provide a performance boost in the case of incompatible node affinities, as MSBuild would
+        /// otherwise have to serialize the project state from one node to another, which may be
+        /// expensive depending on how much data the project previously generated.
+        ///
+        /// This flag has no effect on target results, so if a previous request already built a target, the new
+        /// request will not re-build that target (nor will any of the project state mutations which previously
+        /// occurred as a consequence of building that target be re-applied.)
+        /// </remarks>
+        IgnoreExistingProjectState = 1 << 2,
+
+        /// <summary>
+        /// When this flag is present, caches including the "ProjectRootElementCacheBase" will be cleared
+        /// after the build request completes.  This is used when the build request is known to modify a lot of
+        /// state such as restoring packages or generating parts of the import graph.
+        /// </summary>
+        ClearCachesAfterBuild = 1 << 3,
+
+        /// <summary>
+        /// When this flag is present, the top level target(s) in the build request will be skipped if those targets
+        /// are not defined in the Project to build. This only applies to this build request (if another target calls
+        /// the "missing target" at any other point this will still result in an error).
+        /// </summary>
+        SkipNonexistentTargets = 1 << 4,
+
+        /// <summary>
+        /// When this flag is present, the "BuildResult" issued in response to this request will
+        /// include a "BuildResult.ProjectStateAfterBuild" that includes ONLY the
+        /// explicitly-requested properties, items, and metadata.
+        /// </summary>
+        ProvideSubsetOfStateAfterBuild = 1 << 5,
+
+        /// <summary>
+        /// When this flag is present, projects loaded during build will ignore missing imports ("ProjectLoadSettings.IgnoreMissingImports" and "ProjectLoadSettings.IgnoreInvalidImports").
+        /// This is especially useful during a restore since some imports might come from packages that haven't been restored yet.
+        /// </summary>
+        IgnoreMissingEmptyAndInvalidImports = 1 << 6,
+
+        /// <summary>
+        /// When this flag is present, an unresolved MSBuild project SDK will fail the build.  This flag is used to
+        /// change the "IgnoreMissingEmptyAndInvalidImports" behavior to still fail when an SDK is missing
+        /// because those are more fatal.
+        /// </summary>
+        FailOnUnresolvedSdk = 1 << 7,
+    }
+}
diff --git a/src/Framework/BuildSubmissionStartedEventArgs.cs b/src/Framework/BuildSubmissionStartedEventArgs.cs
new file mode 100644
index 00000000000..f77fdf8cfd0
--- /dev/null
+++ b/src/Framework/BuildSubmissionStartedEventArgs.cs
@@ -0,0 +1,121 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework
+{
+    public sealed class BuildSubmissionStartedEventArgs : BuildStatusEventArgs
+    {
+        /// <summary>
+        /// Constructor with default values.
+        /// </summary>
+        public BuildSubmissionStartedEventArgs()
+        {
+            GlobalProperties = new Dictionary<string, string?>();
+            EntryProjectsFullPath = Enumerable.Empty<string>();
+            TargetNames = Enumerable.Empty<string>();
+            Flags = BuildRequestDataFlags.None;
+            SubmissionId = 0;
+        }
+
+        public BuildSubmissionStartedEventArgs(
+            IReadOnlyDictionary<string, string?> globalProperties,
+            IEnumerable<string> entryProjectsFullPath,
+            IEnumerable<string> targetNames,
+            BuildRequestDataFlags flags,
+            int submissionId)
+            : base("", null, null, DateTime.UtcNow)
+        {
+            GlobalProperties = globalProperties;
+            EntryProjectsFullPath = entryProjectsFullPath;
+            TargetNames = targetNames;
+            Flags = flags;
+            SubmissionId = submissionId;
+        }
+
+        public IReadOnlyDictionary<string, string?> GlobalProperties { get; set; }
+
+        public IEnumerable<string> EntryProjectsFullPath { get; set; }
+
+        public IEnumerable<string> TargetNames { get; set; }
+
+        public BuildRequestDataFlags Flags { get; set; }
+
+        public int SubmissionId { get; set; }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+
+            writer.Write(GlobalProperties.Count);
+            foreach (var entry in GlobalProperties)
+            {
+                writer.Write((string)entry.Key);
+                writer.WriteOptionalString(entry.Value);
+            }
+
+            writer.Write(EntryProjectsFullPath.Count());
+            foreach(var entry in EntryProjectsFullPath)
+            {
+                writer.Write((string)entry);
+            }
+
+            writer.Write(TargetNames.Count());
+            foreach (var entry in TargetNames)
+            {
+                writer.Write((string)entry);
+            }
+
+            writer.Write((int)Flags);
+            writer.Write((int)SubmissionId);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+
+            int numberOfProperties = reader.ReadInt32();
+            Dictionary<string, string?> globalProperties = new Dictionary<string, string?>(numberOfProperties);
+            for (int i = 0; i < numberOfProperties; i++)
+            {
+                string key = reader.ReadString();
+                string? value = reader.ReadOptionalString();
+
+                if (key != null)
+                {
+                    globalProperties[key] = value;
+                }
+            }
+
+            GlobalProperties = globalProperties;
+
+            int numberOfEntries = reader.ReadInt32();
+            var entries = new string[numberOfEntries];
+            for (int i = 0; i < numberOfEntries; i++)
+            {
+                entries[i] = reader.ReadString();
+            }
+
+            EntryProjectsFullPath = entries;
+
+            int numberOfTargets = reader.ReadInt32();
+            var targets = new string[numberOfTargets];
+            for (int i = 0; i < numberOfTargets; i++)
+            {
+                targets[i] = reader.ReadString();
+            }
+
+            TargetNames = targets;
+
+            Flags = (BuildRequestDataFlags)reader.ReadInt32();
+            SubmissionId = reader.ReadInt32();
+        }
+    }
+}
diff --git a/src/Framework/CompatibilitySuppressions.xml b/src/Framework/CompatibilitySuppressions.xml
index f8f240ffbe6..23bea3c7b5b 100644
--- a/src/Framework/CompatibilitySuppressions.xml
+++ b/src/Framework/CompatibilitySuppressions.xml
@@ -1,11 +1,6 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
-       This is intentional, because you can only use MSBuild in the context of a .NET SDK
-       (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
-       have previously shipped netstandard2.0 packages, and if you want to support both
-       runtime contexts it still makes sense to target that. -->
   <Suppression>
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>.NETCoreApp,Version=v2.0</Target>
diff --git a/src/Framework/FileClassifier.cs b/src/Framework/FileClassifier.cs
index 966f51bd5c4..8f19fd39b81 100644
--- a/src/Framework/FileClassifier.cs
+++ b/src/Framework/FileClassifier.cs
@@ -36,6 +36,30 @@ namespace Microsoft.Build.Framework
     /// </remarks>
     internal class FileClassifier
     {
+        private bool _isImmutablePathsInitialized;
+
+        /// <summary>
+        /// This event notifies subscribers when the immutable paths have been initialized.
+        /// </summary>
+        public event Action? OnImmutablePathsInitialized;
+
+        /// <summary>
+        ///  Tracks whether the immutable paths have been initialized.
+        /// </summary>
+        public bool IsImmutablePathsInitialized
+        {
+            get => _isImmutablePathsInitialized;
+            private set
+            {
+                if (!_isImmutablePathsInitialized && value)
+                {
+                    OnImmutablePathsInitialized?.Invoke();
+                }
+
+                _isImmutablePathsInitialized = value;
+            }
+        }
+
         /// <summary>
         ///     StringComparison used for comparing paths on current OS.
         /// </summary>
@@ -193,15 +217,98 @@ public void RegisterImmutableDirectory(string? directory)
             }
         }
 
-        private static string EnsureTrailingSlash(string fileSpec)
+        public void RegisterFrameworkLocations(Func<string, string?> getPropertyValue)
+        {
+            // Register toolset paths into list of immutable directories
+            // example: C:\Windows\Microsoft.NET\Framework
+            string? frameworksPathPrefix32 = GetExistingRootOrNull(getPropertyValue("MSBuildFrameworkToolsPath32")?.Trim());
+            RegisterImmutableDirectory(frameworksPathPrefix32);
+            // example: C:\Windows\Microsoft.NET\Framework64
+            string? frameworksPathPrefix64 = GetExistingRootOrNull(getPropertyValue("MSBuildFrameworkToolsPath64")?.Trim());
+            RegisterImmutableDirectory(frameworksPathPrefix64);
+            // example: C:\Windows\Microsoft.NET\FrameworkArm64
+            string? frameworksPathPrefixArm64 = GetExistingRootOrNull(getPropertyValue("MSBuildFrameworkToolsPathArm64")?.Trim());
+            RegisterImmutableDirectory(frameworksPathPrefixArm64);
+        }
+
+        public void RegisterKnownImmutableLocations(Func<string, string?> getPropertyValue)
+        {
+            // example: C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.7.2
+            RegisterImmutableDirectory(getPropertyValue("FrameworkPathOverride")?.Trim());
+            // example: C:\Program Files\dotnet\
+            RegisterImmutableDirectory(getPropertyValue("NetCoreRoot")?.Trim());
+            // example: C:\Users\<username>\.nuget\packages\
+            RegisterImmutableDirectory(getPropertyValue("NuGetPackageFolders")?.Trim());
+
+            IsImmutablePathsInitialized = true;
+        }
+
+        private static string? GetExistingRootOrNull(string? path)
         {
-            if (fileSpec.Length >= 1)
+            if (!string.IsNullOrEmpty(path))
             {
-                char lastChar = fileSpec[fileSpec.Length - 1];
-                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)
+                try
                 {
-                    fileSpec += Path.DirectorySeparatorChar;
+                    path = Directory.GetParent(EnsureNoTrailingSlash(path!))?.FullName;
+
+                    if (!Directory.Exists(path))
+                    {
+                        path = null;
+                    }
                 }
+                catch
+                {
+                    path = null;
+                }
+            }
+
+            return path;
+        }
+
+        /// <summary>
+        /// Ensures the path does not have a trailing slash.
+        /// </summary>
+        private static string EnsureNoTrailingSlash(string path)
+        {
+            path = FixFilePath(path);
+            if (EndsWithSlash(path))
+            {
+                path = path.Substring(0, path.Length - 1);
+            }
+
+            return path;
+        }
+
+        private static string FixFilePath(string path)
+        {
+            return string.IsNullOrEmpty(path) || Path.DirectorySeparatorChar == '\\' ? path : path.Replace('\\', '/'); // .Replace("//", "/");
+        }
+
+        /// <summary>
+        /// Indicates if the given file-spec ends with a slash.
+        /// </summary>
+        /// <param name="fileSpec">The file spec.</param>
+        /// <returns>true, if file-spec has trailing slash</returns>
+        private static bool EndsWithSlash(string fileSpec)
+        {
+            return (fileSpec.Length > 0) && IsSlash(fileSpec[fileSpec.Length - 1]);
+        }
+
+        /// <summary>
+        /// Indicates if the given character is a slash.
+        /// </summary>
+        /// <param name="c"></param>
+        /// <returns>true, if slash</returns>
+        private static bool IsSlash(char c)
+        {
+            return (c == Path.DirectorySeparatorChar) || (c == Path.AltDirectorySeparatorChar);
+        }
+
+        private static string EnsureTrailingSlash(string fileSpec)
+        {
+            if (fileSpec.Length >= 1 && !EndsWithSlash(fileSpec))
+            {
+                fileSpec += Path.DirectorySeparatorChar;
             }
 
             return fileSpec;
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index cc9d14af45a..4636850306a 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Collections.Immutable;
 using System.IO;
 using System.Linq;
 using System.Runtime.Serialization;
@@ -249,7 +250,9 @@ public IDictionary<string, string>? GlobalProperties
         {
             get
             {
-                return globalProperties;
+                return globalProperties ?? (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
+                    ? ImmutableDictionary<string, string>.Empty
+                    : null);
             }
 
             internal set
@@ -298,7 +301,9 @@ public IEnumerable? Properties
                 // up the live list of properties from the loaded project, which is stored in the configuration as well.
                 // By doing this, we no longer need to transmit properties using this message because they've already
                 // been transmitted as part of the BuildRequestConfiguration.
-                return properties;
+                return properties ?? (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
+                    ? Enumerable.Empty<DictionaryEntry>()
+                    : null);
             }
         }
 
@@ -322,7 +327,9 @@ public IEnumerable? Items
                 // case, this access is to the live list.  For the central logger in the multi-proc case, the main node
                 // has likely not loaded this project, and therefore the live items would not be available to them, which is
                 // the same as the current functionality.
-                return items;
+                return items ?? (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
+                    ? Enumerable.Empty<DictionaryEntry>()
+                    : null);
             }
         }
 
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 6851120de48..0ef451ba979 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -2622,11 +2622,11 @@ public void EndToEndVersionMessage(string arguments, bool shouldContainVersionMe
         [InlineData("/v:minimal /bl", MessageImportance.Low)] // v:minimal but with binary logger so everything must be logged
         [InlineData("/v:quiet /bl", MessageImportance.Low)] // v:quiet but with binary logger so everything must be logged
 
-        [InlineData("/v:diagnostic /analyze", MessageImportance.Low)]
-        [InlineData("/v:detailed /analyze", MessageImportance.Low)]
-        [InlineData("/v:normal /analyze", MessageImportance.Normal)]
-        [InlineData("/v:minimal /analyze", MessageImportance.High)]
-        [InlineData("/v:quiet /analyze", MessageImportance.High)]
+        [InlineData("/v:diagnostic /check", MessageImportance.Low)]
+        [InlineData("/v:detailed /check", MessageImportance.Low)]
+        [InlineData("/v:normal /check", MessageImportance.Normal)]
+        [InlineData("/v:minimal /check", MessageImportance.High)]
+        [InlineData("/v:quiet /check", MessageImportance.High)]
 
         [InlineData("/v:diagnostic /tl", MessageImportance.Low)]
         [InlineData("/v:detailed /tl", MessageImportance.Low)]
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 8f9d947b310..ae5646ca7d1 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -100,7 +100,7 @@ internal enum ParameterizedSwitch
             WarningsNotAsErrors,
             WarningsAsMessages,
             BinaryLogger,
-            Analyze,
+            Check,
             Restore,
             ProfileEvaluation,
             RestoreProperty,
@@ -277,7 +277,7 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "warnnotaserror", "noerr" },           ParameterizedSwitch.WarningsNotAsErrors,        null,                           true,           "MissingWarnNotAsErrorParameterError", true,   false,   "HelpMessage_40_WarnNotAsErrorSwitch"),
             new ParameterizedSwitchInfo(  new string[] { "warnasmessage", "nowarn" },           ParameterizedSwitch.WarningsAsMessages,         null,                           true,           "MissingWarnAsMessageParameterError",  true,   false,   "HelpMessage_29_WarnAsMessageSwitch"),
             new ParameterizedSwitchInfo(  new string[] { "binarylogger", "bl" },                ParameterizedSwitch.BinaryLogger,               null,                           false,          null,                                  true,   false,   "HelpMessage_30_BinaryLoggerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "analyze", },                          ParameterizedSwitch.Analyze,                    null,                           false,          null,                                  true,   false,   null),
+            new ParameterizedSwitchInfo(  new string[] { "check", },                            ParameterizedSwitch.Check,                      null,                           false,          null,                                  true,   false,   null),
             new ParameterizedSwitchInfo(  new string[] { "restore", "r" },                      ParameterizedSwitch.Restore,                    null,                           false,          null,                                  true,   false,   "HelpMessage_31_RestoreSwitch"),
             new ParameterizedSwitchInfo(  new string[] { "profileevaluation", "prof" },         ParameterizedSwitch.ProfileEvaluation,          null,                           false,          "MissingProfileParameterError",        true,   false,   "HelpMessage_32_ProfilerSwitch"),
             new ParameterizedSwitchInfo(  new string[] { "restoreproperty", "rp" },             ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_33_RestorePropertySwitch"),
@@ -467,7 +467,7 @@ internal CommandLineSwitches()
                 Debug.Assert(i == (int)(s_parameterizedSwitchesMap[i].parameterizedSwitch),
                     "The map of parameterized switches must be ordered the same way as the ParameterizedSwitch enumeration.");
                 if (s_parameterizedSwitchesMap[i].parameterizedSwitch is not ParameterizedSwitch.Project and
-                    not ParameterizedSwitch.NodeMode and not ParameterizedSwitch.Analyze)
+                    not ParameterizedSwitch.NodeMode and not ParameterizedSwitch.Check)
                 {
                     Debug.Assert(!string.IsNullOrEmpty(s_parameterizedSwitchesMap[i].resourceId), "All parameterized switches should be cross-checked against the help message strings except from project switch");
                 }
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index ad8b40cb534..eb3e42c4fa2 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -1731,7 +1731,7 @@
       </trans-unit>
       <trans-unit id="ProjectFinished_WithTF">
         <source>{0}{1} {2} {3} ({4}s)</source>
-        <target state="translated">{0}{1} {2} {3} ({4})</target>
+        <target state="translated">{0}{1} {2} {3} ({4} 秒)</target>
         <note>
       Project finished summary including target framework information.
       {0}: indentation - few spaces to visually indent row
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index bfc061b5a1d..017237c35d8 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -2784,8 +2784,8 @@ private static bool ProcessCommandLineSwitches(
         private static bool IsBuildCheckEnabled(CommandLineSwitches commandLineSwitches)
         {
             // Opt-in behavior to be determined by: https://github.com/dotnet/msbuild/issues/9723
-            bool isAnalysisEnabled = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Analyze);
-            return isAnalysisEnabled;
+            bool isBuildCheckEnabled = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Check);
+            return isBuildCheckEnabled;
         }
 
         private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches, out string aggregatedParameters)
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 832ffcd8057..0eacfd24c73 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -576,26 +576,6 @@ internal static string MaybeAdjustFilePath(string value, string baseDirectory =
             return shouldAdjust ? newValue.ToString() : value;
         }
 
-        /// <summary>
-        /// Gets the path value that is associated with the specified key in a dictionary with <see cref="string"/> values.
-        /// Normalizes the value as a path.
-        /// </summary>
-        /// <param name="dictionary">The dictionary to search.</param>
-        /// <param name="key">The key to locate.</param>
-        /// <param name="value">When this method returns, the value associated with the specified key normalized as a path, if the key is found; otherwise <see langword="null"/>.</param>
-        /// <returns><see langword="true"/> if the dictionary contains an element that has the specified key; otherwise, <see langword="false"/>.</returns>
-        /// <remarks>Use this method to get paths from dictionaries of properties whose default values may contain backslashes.</remarks>
-        internal static bool TryGetPathValue<TKey>(this IReadOnlyDictionary<TKey, string> dictionary, TKey key, out string value)
-        {
-            bool result = dictionary.TryGetValue(key, out value);
-            if (result)
-            {
-                value = NormalizePath(value);
-            }
-
-            return result;
-        }
-
         /// <summary>
         /// If on Unix, convert backslashes to slashes for strings that resemble paths.
         /// This overload takes and returns ReadOnlyMemory of characters.
diff --git a/src/Shared/IElementLocation.cs b/src/Shared/IElementLocation.cs
index 39f520475ba..8ea57b003f3 100644
--- a/src/Shared/IElementLocation.cs
+++ b/src/Shared/IElementLocation.cs
@@ -7,7 +7,7 @@
 
 namespace Microsoft.Build.Shared
 {
-    internal interface IElementLocation : IMsBuildElementLocation, ITranslatable { }
+    internal interface IElementLocation : IMSBuildElementLocation, ITranslatable { }
 
     /// <summary>
     /// Represents the location information for error reporting purposes.  This is normally used to
@@ -18,9 +18,9 @@ internal interface IElementLocation : IMsBuildElementLocation, ITranslatable { }
     /// </summary>
     /// <remarks>
     /// This is currently internal - but it is prepared to be made public once it will be needed by other public BuildCheck OM
-    /// (e.g. by property read/write OM)
+    /// (e.g. by property read/write OM).
     /// </remarks>
-    internal interface IMsBuildElementLocation
+    public interface IMSBuildElementLocation
     {
         /// <summary>
         /// The file from which this particular element originated.  It may
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index bb41a07dcbb..4caf4874652 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -36,209 +36,214 @@ namespace Microsoft.Build.Shared
     internal enum LoggingEventType : int
     {
         /// <summary>
-        /// An invalid eventId, used during initialization of a LoggingEventType
+        /// An invalid eventId, used during initialization of a <see cref="LoggingEventType"/>.
         /// </summary>
         Invalid = -1,
 
         /// <summary>
-        /// Event is a CustomEventArgs
+        /// Event is a CustomEventArgs.
         /// </summary>
         CustomEvent = 0,
 
         /// <summary>
-        /// Event is a BuildErrorEventArgs
+        /// Event is a <see cref="BuildErrorEventArgs"/>.
         /// </summary>
         BuildErrorEvent = 1,
 
         /// <summary>
-        /// Event is a BuildFinishedEventArgs
+        /// Event is a <see cref="BuildFinishedEventArgs"/>.
         /// </summary>
         BuildFinishedEvent = 2,
 
         /// <summary>
-        /// Event is a BuildMessageEventArgs
+        /// Event is a <see cref="BuildMessageEventArgs"/>.
         /// </summary>
         BuildMessageEvent = 3,
 
         /// <summary>
-        /// Event is a BuildStartedEventArgs
+        /// Event is a <see cref="BuildStartedEventArgs"/>.
         /// </summary>
         BuildStartedEvent = 4,
 
         /// <summary>
-        /// Event is a BuildWarningEventArgs
+        /// Event is a <see cref="BuildWarningEventArgs"/>.
         /// </summary>
         BuildWarningEvent = 5,
 
         /// <summary>
-        /// Event is a ProjectFinishedEventArgs
+        /// Event is a <see cref="ProjectFinishedEventArgs"/>.
         /// </summary>
         ProjectFinishedEvent = 6,
 
         /// <summary>
-        /// Event is a ProjectStartedEventArgs
+        /// Event is a <see cref="ProjectStartedEventArgs"/>.
         /// </summary>
         ProjectStartedEvent = 7,
 
         /// <summary>
-        /// Event is a TargetStartedEventArgs
+        /// Event is a <see cref="TargetStartedEventArgs"/>.
         /// </summary>
         TargetStartedEvent = 8,
 
         /// <summary>
-        /// Event is a TargetFinishedEventArgs
+        /// Event is a <see cref="TargetFinishedEventArgs"/>.
         /// </summary>
         TargetFinishedEvent = 9,
 
         /// <summary>
-        /// Event is a TaskStartedEventArgs
+        /// Event is a <see cref="TaskStartedEventArgs"/>.
         /// </summary>
         TaskStartedEvent = 10,
 
         /// <summary>
-        /// Event is a TaskFinishedEventArgs
+        /// Event is a <see cref="TaskFinishedEventArgs"/>.
         /// </summary>
         TaskFinishedEvent = 11,
 
         /// <summary>
-        /// Event is a TaskCommandLineEventArgs
+        /// Event is a <see cref="TaskCommandLineEventArgs"/>.
         /// </summary>
         TaskCommandLineEvent = 12,
 
         /// <summary>
-        /// Event is a TaskParameterEventArgs
+        /// Event is a <see cref="TaskParameterEventArgs"/>.
         /// </summary>
         TaskParameterEvent = 13,
 
         /// <summary>
-        /// Event is a ProjectEvaluationStartedEventArgs
+        /// Event is a <see cref="ProjectEvaluationStartedEventArgs"/>.
         /// </summary>
         ProjectEvaluationStartedEvent = 14,
 
         /// <summary>
-        /// Event is a ProjectEvaluationFinishedEventArgs
+        /// Event is a <see cref="ProjectEvaluationFinishedEventArgs"/>.
         /// </summary>
         ProjectEvaluationFinishedEvent = 15,
 
         /// <summary>
-        /// Event is a ProjectImportedEventArgs
+        /// Event is a <see cref="ProjectImportedEventArgs"/>.
         /// </summary>
         ProjectImportedEvent = 16,
 
         /// <summary>
-        /// Event is a TargetSkippedEventArgs
+        /// Event is a <see cref="TargetSkippedEventArgs"/>.
         /// </summary>
         TargetSkipped = 17,
 
         /// <summary>
-        /// Event is a TelemetryEventArgs
+        /// Event is a <see cref="TelemetryEventArgs"/>.
         /// </summary>
         Telemetry = 18,
 
         /// <summary>
-        /// Event is an EnvironmentVariableReadEventArgs
+        /// Event is an <see cref="EnvironmentVariableReadEventArgs"/>.
         /// </summary>
         EnvironmentVariableReadEvent = 19,
 
         /// <summary>
-        /// Event is a ResponseFileUsedEventArgs
+        /// Event is a <see cref="ResponseFileUsedEventArgs"/>.
         /// </summary>
         ResponseFileUsedEvent = 20,
 
         /// <summary>
-        /// Event is an AssemblyLoadBuildEventArgs
+        /// Event is an <see cref="AssemblyLoadBuildEventArgs"/>.
         /// </summary>
         AssemblyLoadEvent = 21,
 
         /// <summary>
-        /// Event is <see cref="ExternalProjectStartedEventArgs"/>
+        /// Event is <see cref="ExternalProjectStartedEventArgs"/>.
         /// </summary>
         ExternalProjectStartedEvent = 22,
 
         /// <summary>
-        /// Event is <see cref="ExternalProjectFinishedEventArgs"/>
+        /// Event is <see cref="ExternalProjectFinishedEventArgs"/>.
         /// </summary>
         ExternalProjectFinishedEvent = 23,
 
         /// <summary>
-        /// Event is <see cref="ExtendedCustomBuildEventArgs"/>
+        /// Event is <see cref="ExtendedCustomBuildEventArgs"/>.
         /// </summary>
         ExtendedCustomEvent = 24,
 
         /// <summary>
-        /// Event is <see cref="ExtendedBuildErrorEventArgs"/>
+        /// Event is <see cref="ExtendedBuildErrorEventArgs"/>.
         /// </summary>
         ExtendedBuildErrorEvent = 25,
 
         /// <summary>
-        /// Event is <see cref="ExtendedBuildWarningEventArgs"/>
+        /// Event is <see cref="ExtendedBuildWarningEventArgs"/>.
         /// </summary>
         ExtendedBuildWarningEvent = 26,
 
         /// <summary>
-        /// Event is <see cref="ExtendedBuildMessageEventArgs"/>
+        /// Event is <see cref="ExtendedBuildMessageEventArgs"/>.
         /// </summary>
         ExtendedBuildMessageEvent = 27,
 
         /// <summary>
-        /// Event is <see cref="CriticalBuildMessageEventArgs"/>
+        /// Event is <see cref="CriticalBuildMessageEventArgs"/>.
         /// </summary>
         CriticalBuildMessage = 28,
 
         /// <summary>
-        /// Event is <see cref="MetaprojectGeneratedEventArgs"/>
+        /// Event is <see cref="MetaprojectGeneratedEventArgs"/>.
         /// </summary>
         MetaprojectGenerated = 29,
 
         /// <summary>
-        /// Event is <see cref="PropertyInitialValueSetEventArgs"/>
+        /// Event is <see cref="PropertyInitialValueSetEventArgs"/>.
         /// </summary>
         PropertyInitialValueSet = 30,
 
         /// <summary>
-        /// Event is <see cref="PropertyReassignmentEventArgs"/>
+        /// Event is <see cref="PropertyReassignmentEventArgs"/>.
         /// </summary>
         PropertyReassignment = 31,
 
         /// <summary>
-        /// Event is <see cref="UninitializedPropertyReadEventArgs"/>
+        /// Event is <see cref="UninitializedPropertyReadEventArgs"/>.
         /// </summary>
         UninitializedPropertyRead = 32,
 
         /// <summary>
-        /// Event is <see cref="ExtendedCriticalBuildMessageEventArgs"/>
+        /// Event is <see cref="ExtendedCriticalBuildMessageEventArgs"/>.
         /// </summary>
         ExtendedCriticalBuildMessageEvent = 33,
 
         /// <summary>
-        /// Event is a <see cref="GeneratedFileUsedEventArgs"/>
+        /// Event is a <see cref="GeneratedFileUsedEventArgs"/>.
         /// </summary>
         GeneratedFileUsedEvent = 34,
 
         /// <summary>
-        /// Event is <see cref="BuildCheckResultMessage"/>
+        /// Event is <see cref="BuildCheckResultMessage"/>.
         /// </summary>
         BuildCheckMessageEvent = 35,
 
         /// <summary>
-        /// Event is <see cref="BuildCheckResultWarning"/>
+        /// Event is <see cref="BuildCheckResultWarning"/>.
         /// </summary>
         BuildCheckWarningEvent = 36,
 
         /// <summary>
-        /// Event is <see cref="BuildCheckResultError"/>
+        /// Event is <see cref="BuildCheckResultError"/>.
         /// </summary>
         BuildCheckErrorEvent = 37,
 
         /// <summary>
-        /// Event is <see cref="BuildCheckTracingEventArgs"/>
+        /// Event is <see cref="BuildCheckTracingEventArgs"/>.
         /// </summary>
         BuildCheckTracingEvent = 38,
 
         /// <summary>
-        /// Event is <see cref="BuildCheckAcquisitionEventArgs"/>
+        /// Event is <see cref="BuildCheckAcquisitionEventArgs"/>.
         /// </summary>
         BuildCheckAcquisitionEvent = 39,
+
+        /// <summary>
+        /// Event is <see cref="BuildSubmissionStartedEventArgs"/>.
+        /// </summary>
+        BuildSubmissionStartedEvent = 40,
     }
     #endregion
 
@@ -650,6 +655,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.BuildCheckAcquisitionEvent => new BuildCheckAcquisitionEventArgs(),
                 LoggingEventType.BuildCheckTracingEvent => new BuildCheckTracingEventArgs(),
                 LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
+                LoggingEventType.BuildSubmissionStartedEvent => new BuildSubmissionStartedEventArgs(),
 #endif
                 _ => throw new InternalErrorException("Should not get to the default of GetBuildEventArgFromId ID: " + _eventType)
             };
@@ -789,6 +795,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.EnvironmentVariableReadEvent;
             }
+            else if (eventType == typeof(BuildSubmissionStartedEventArgs))
+            {
+                return LoggingEventType.BuildSubmissionStartedEvent;
+            }
 #endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
@@ -1346,7 +1356,6 @@ private ResponseFileUsedEventArgs ReadResponseFileUsedEventFromStream(ITranslato
             buildEvent.RawTimestamp = timestamp;
 #endif
 
-
             return buildEvent;
         }
 
diff --git a/src/Shared/UnitTests/TestAssemblyInfo.cs b/src/Shared/UnitTests/TestAssemblyInfo.cs
index f146e41ab3a..48e435d68c6 100644
--- a/src/Shared/UnitTests/TestAssemblyInfo.cs
+++ b/src/Shared/UnitTests/TestAssemblyInfo.cs
@@ -41,6 +41,12 @@ public MSBuildTestAssemblyFixture()
             var runningTestsField = testInfoType.GetField("s_runningTests", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);
             runningTestsField.SetValue(null, true);
 
+            // Set the field in BuildEnvironmentState - as it might have been already preintialized by the data preparation of data driven tests
+            testInfoType = frameworkAssembly.GetType("Microsoft.Build.Framework.BuildEnvironmentState");
+            runningTestsField = testInfoType.GetField("s_runningTests", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);
+            runningTestsField.SetValue(null, true);
+            
+
             // Note: build error files will be initialized in test environments for particular tests, also we don't have output to report error files into anyway...
             _testEnvironment = TestEnvironment.Create(output: null, ignoreBuildErrorFiles: true);
 
diff --git a/src/Tasks/CompatibilitySuppressions.xml b/src/Tasks/CompatibilitySuppressions.xml
index 5a10c27c1e1..347307aae81 100644
--- a/src/Tasks/CompatibilitySuppressions.xml
+++ b/src/Tasks/CompatibilitySuppressions.xml
@@ -1,7 +1,7 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-<!-- For ease of logging the "not supported on Core" message, these tasks are a
+  <!-- For ease of logging the "not supported on Core" message, these tasks are a
          TaskRequiresFramework on netstandard/netcore. Since the type is sealed there,
          that shouldn't cause any implementation problems since no one can derive
          from it and try to call TaskExtension.Log. -->
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index f8bd53d1a44..a6b50bd028f 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -246,6 +246,7 @@ private static void GetFileInfoImpl(string path, string targetFrameWorkVersion,
                 if (string.IsNullOrEmpty(targetFrameWorkVersion) || CompareFrameworkVersions(targetFrameWorkVersion, Constants.TargetFrameworkVersion40) <= 0)
                 {
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
+                    // codeql[cs/weak-crypto] .NET 4.0 and earlier versions cannot parse SHA-2. Newer Frameworks use SHA256. https://devdiv.visualstudio.com/DevDiv/_workitems/edit/139025
                     hashAlg = SHA1.Create(
 #if FEATURE_CRYPTOGRAPHIC_FACTORY_ALGORITHM_NAMES
                         "System.Security.Cryptography.SHA1CryptoServiceProvider"
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index 1e98ca0ec72..4596c143be9 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -586,6 +586,7 @@ private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldF
                 else
                 {
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
+                    // codeql[cs/weak-crypto] SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2. https://devdiv.visualstudio.com/DevDiv/_workitems/edit/139025
                     using (SHA1 sha1 = SHA1.Create(
 #if FEATURE_CRYPTOGRAPHIC_FACTORY_ALGORITHM_NAMES
                         "System.Security.Cryptography.SHA1CryptoServiceProvider"
@@ -648,6 +649,7 @@ private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldF
                 else
                 {
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
+                    // codeql[cs/weak-crypto] SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2. https://devdiv.visualstudio.com/DevDiv/_workitems/edit/139025
                     using (SHA1 sha1 = SHA1.Create(
 #if FEATURE_CRYPTOGRAPHIC_FACTORY_ALGORITHM_NAMES
                         "System.Security.Cryptography.SHA1CryptoServiceProvider"
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index d881ab86b69..b7e42801af8 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -2737,7 +2737,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
      <FindInvalidProjectReferences
          TargetPlatformVersion="$(TargetPlatformVersion)"
          TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
-         ProjectReferences="@(TargetPathWithTargetPlatformMoniker)">
+         ProjectReferences="@(_ProjectReferenceTargetPlatformMonikers)">
        <Output TaskParameter="InvalidReferences" ItemName="InvalidProjectReferences" />
      </FindInvalidProjectReferences>
 
@@ -2754,7 +2754,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       BuildInParallel="$(BuildInParallel)"
       ContinueOnError="!$(BuildingProject)"
       RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
-      <Output TaskParameter="TargetOutputs" ItemName="TargetPathWithTargetPlatformMoniker" />
+      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetPlatformMonikers" />
     </MSBuild>
   </Target>
 
diff --git a/src/UnitTests.Shared/MockLogger.cs b/src/UnitTests.Shared/MockLogger.cs
index 782cef74d41..b530cc538f0 100644
--- a/src/UnitTests.Shared/MockLogger.cs
+++ b/src/UnitTests.Shared/MockLogger.cs
@@ -213,6 +213,11 @@ public void Initialize(IEventSource eventSource)
             {
                 _reportTelemetry = true;
             }
+
+            if (eventSource is IEventSource4 eventSource4)
+            {
+                eventSource4.IncludeEvaluationPropertiesAndItems();
+            }
         }
 
         /// <summary>
diff --git a/src/Utilities.UnitTests/MuxLogger_Tests.cs b/src/Utilities.UnitTests/MuxLogger_Tests.cs
index ee3441facfc..db440177756 100644
--- a/src/Utilities.UnitTests/MuxLogger_Tests.cs
+++ b/src/Utilities.UnitTests/MuxLogger_Tests.cs
@@ -125,7 +125,10 @@ public void BuildWithMuxLoggerEquivalentToNormalLogger()
             mockLogger2.BuildFinishedEvents.Count.ShouldBeGreaterThan(0);
             mockLogger.BuildFinishedEvents.Count.ShouldBe(mockLogger2.BuildFinishedEvents.Count);
             mockLogger.BuildFinishedEvents[0].Succeeded.ShouldBe(mockLogger2.BuildFinishedEvents[0].Succeeded);
-            mockLogger.FullLog.ShouldBe(mockLogger2.FullLog);
+
+            // This test was changed to not compare new lines because of https://github.com/dotnet/msbuild/issues/10493
+            // It will need to be changed once we fix the root cause of the issue
+            mockLogger.FullLog.Replace(Environment.NewLine, "").ShouldBe(mockLogger2.FullLog.Replace(Environment.NewLine, ""));
         }
 
         /// <summary>
diff --git a/template_feed/README.md b/template_feed/README.md
index f2b021d3647..f6bd358ffcd 100644
--- a/template_feed/README.md
+++ b/template_feed/README.md
@@ -1,9 +1,9 @@
-## MSBuild Custom Analyzer Template Package
+## MSBuild Custom Check Template Package
 
-The package contains the template designed to streamline the creation of MSBuild analyzer libraries.
+The package contains the template designed to streamline the creation of MSBuild check libraries.
 | Template name | Short name | Description|
 |---|---|---|
-|MSBuild Custom Analyzer Template|`msbuildanalyzer`|A project for creating a MSBuild analyzer library that targets .NET Standard.|
+|MSBuild Custom Check Template|`msbuildcheck`|A project for creating a MSBuild check library that targets .NET Standard.|
 
 The package is available for download from nuget.org.
 Please feel to contribute or provide the feedback in discussions or via opening the issue in dotnet/msbuild repo.
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json b/template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json
deleted file mode 100644
index 8bd2d1853e3..00000000000
--- a/template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json
+++ /dev/null
@@ -1,49 +0,0 @@
-{
-    "$schema": "http://json.schemastore.org/template",
-    "author": "Microsoft",
-    "classifications": [
-      "Common",
-      "Library"
-    ],
-    "name": "MSBuild custom analyzer skeleton project.",
-    "generatorVersions": "[1.0.0.0-*)",
-    "description": "A project for creating a MSBuild analyzer library that targets .NET Standard",
-    "groupIdentity": "Microsoft.AnalyzerTemplate",
-    "identity": "Microsoft.AnalyzerTemplate",
-    "shortName": "msbuildanalyzer",
-    "tags": {
-      "language": "C#",
-      "type": "project"
-    },
-    "sourceName": "Company.AnalyzerTemplate",
-    "preferNameDirectory": true,
-    "primaryOutputs": [
-      {
-        "path": "Company.AnalyzerTemplate.csproj"
-      }
-   ],
-   "symbols": {
-    "MicrosoftBuildVersion": {
-      "type": "parameter",
-      "description": "Overrides the default Microsoft.Build version where analyzer's interfaces are placed",
-      "datatype": "text",
-      "defaultValue": "17.11.0",
-      "replaces": "1.0.0-MicrosoftBuildPackageVersion",
-      "displayName": "Microsoft.Build default package version override"
-    }
-   },
-    "postActions": [
-      {
-        "id": "restore",
-        "condition": "(!skipRestore)",
-        "description": "Restore NuGet packages required by this project.",
-        "manualInstructions": [
-          {
-            "text": "Run 'dotnet restore'"
-          }
-        ],
-        "actionId": "210D431B-A78B-4D2F-B762-4ED3E3EA9025",
-        "continueOnError": true
-      }
-    ]
-  }
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props b/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
deleted file mode 100644
index 5a606b3cac6..00000000000
--- a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project>
-  <PropertyGroup>
-	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)Company.AnalyzerTemplate.dll))</MSBuildAnalyzer>
-  </PropertyGroup>
-  <ItemGroup>
-    <PackageVersion Include="Microsoft.Build" Version="1.0.0-MicrosoftBuildPackageVersion" />
-  </ItemGroup>
-</Project>
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/README.md b/template_feed/content/Microsoft.AnalyzerTemplate/README.md
deleted file mode 100644
index 4f29145e7f0..00000000000
--- a/template_feed/content/Microsoft.AnalyzerTemplate/README.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# MSBuild Custom Analyzer Template
-
-## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
-
-## Features
-- Simplified template for creating MSBuild analyzer libraries.
-- Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
-
-## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
-1. Install the template using the following command:
-   ```bash
-   dotnet new install msbuildanalyzer
-2. Instantiate a custom template:
-   ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
-
-### Prerequisites
-- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
new file mode 100644
index 00000000000..3647f61a8dc
--- /dev/null
+++ b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
@@ -0,0 +1,49 @@
+{
+  "$schema": "http://json.schemastore.org/template",
+  "author": "Microsoft",
+  "classifications": [
+    "Common",
+    "Library"
+  ],
+  "name": "MSBuild custom check skeleton project.",
+  "generatorVersions": "[1.0.0.0-*)",
+  "description": "A project for creating a MSBuild check library that targets .NET Standard",
+  "groupIdentity": "Microsoft.CheckTemplate",
+  "identity": "Microsoft.CheckTemplate",
+  "shortName": "msbuildcheck",
+  "tags": {
+    "language": "C#",
+    "type": "project"
+  },
+  "sourceName": "Company.CheckTemplate",
+  "preferNameDirectory": true,
+  "primaryOutputs": [
+    {
+      "path": "Company.CheckTemplate.csproj"
+    }
+  ],
+  "symbols": {
+    "MicrosoftBuildVersion": {
+      "type": "parameter",
+      "description": "Overrides the default Microsoft.Build version where check's interfaces are placed",
+      "datatype": "text",
+      "defaultValue": "17.12.0",
+      "replaces": "1.0.0-MicrosoftBuildPackageVersion",
+      "displayName": "Microsoft.Build default package version override"
+    }
+  },
+  "postActions": [
+    {
+      "id": "restore",
+      "condition": "(!skipRestore)",
+      "description": "Restore NuGet packages required by this project.",
+      "manualInstructions": [
+        {
+          "text": "Run 'dotnet restore'"
+        }
+      ],
+      "actionId": "210D431B-A78B-4D2F-B762-4ED3E3EA9025",
+      "continueOnError": true
+    }
+  ]
+}
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs b/template_feed/content/Microsoft.CheckTemplate/Check1.cs
similarity index 59%
rename from template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs
rename to template_feed/content/Microsoft.CheckTemplate/Check1.cs
index 78dae77947b..2a44afef40c 100644
--- a/template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs
+++ b/template_feed/content/Microsoft.CheckTemplate/Check1.cs
@@ -2,24 +2,24 @@
 using Microsoft.Build.Experimental.BuildCheck;
 using System.Collections.Generic;
 
-namespace Company.AnalyzerTemplate
+namespace Company.CheckTemplate
 {
-    public sealed class Analyzer1 : BuildAnalyzer
+    public sealed class Check1 : Check
     {
-        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        public static BuildCheckRule SupportedRule = new CheckRule(
             "X01234",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildAnalyzerConfiguration());
+            new BuildCheckConfiguration());
 
-        public override string FriendlyName => "Company.Analyzer1";
+        public override string FriendlyName => "Company.Check1";
 
-        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
 
@@ -28,7 +28,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
         }
 
-        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
         {
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.csproj
similarity index 94%
rename from template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
rename to template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.csproj
index 33d8c992326..009b2ad1fe0 100644
--- a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
+++ b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.csproj
@@ -10,7 +10,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <None Include="Company.AnalyzerTemplate.props" Pack="true" PackagePath="build\Company.AnalyzerTemplate.props" />
+    <None Include="Company.CheckTemplate.props" Pack="true" PackagePath="build\Company.CheckTemplate.props" />
     <Content Include="README.md" />
   </ItemGroup>
 
diff --git a/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.props b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.props
new file mode 100644
index 00000000000..167b0912cf7
--- /dev/null
+++ b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)Company.CheckTemplate.dll))</MSBuildCheck>
+  </PropertyGroup>
+</Project>
diff --git a/template_feed/content/Microsoft.CheckTemplate/Directory.Packages.props b/template_feed/content/Microsoft.CheckTemplate/Directory.Packages.props
new file mode 100644
index 00000000000..c6d3f5fb1e5
--- /dev/null
+++ b/template_feed/content/Microsoft.CheckTemplate/Directory.Packages.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <ItemGroup>
+    <PackageVersion Include="Microsoft.Build" Version="1.0.0-MicrosoftBuildPackageVersion" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/template_feed/content/Microsoft.CheckTemplate/README.md b/template_feed/content/Microsoft.CheckTemplate/README.md
new file mode 100644
index 00000000000..ef41e00277e
--- /dev/null
+++ b/template_feed/content/Microsoft.CheckTemplate/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Check Template
+
+## Overview
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild check libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom check rules.
+
+## Getting Started
+To use the MSBuild Custom Check Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildcheck
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildcheck -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
