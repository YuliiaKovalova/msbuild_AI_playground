diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 9e443496105..60d130722ae 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -2007,7 +2007,7 @@ public void AllNodesShouldHaveGraphBuildGlobalProperty(Dictionary<int, int[]> ed
         {
             using (var env = TestEnvironment.Create())
             {
-                var projectGraph = Helpers.CreateProjectGraph(env, edges, globalProperties, null, entryPoints);
+                var projectGraph = Helpers.CreateProjectGraph(env, edges, globalProperties, entryPoints: entryPoints);
 
                 var dot = projectGraph.ToDot();
 
@@ -2042,7 +2042,6 @@ public void GraphShouldSupportTransitiveReferences(Dictionary<int, int[]> edges)
             var graph = Helpers.CreateProjectGraph(
                 env: _env,
                 dependencyEdges: edges,
-                extraContentPerProjectNumber: null,
                 extraContentForAllNodes: EnableTransitiveProjectReferencesPropertyGroup
                 );
 
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index ed4766f5450..73732f6d3ba 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -93,11 +93,11 @@ public class GraphCacheResponse
                         </ItemGroup>
                     </Target>";
 
-            private Dictionary<int, int[]> GraphEdges { get; }
+            private Dictionary<int, int[]?> GraphEdges { get; }
 
             public Dictionary<int, CacheResult> NonCacheMissResults { get; }
 
-            public GraphCacheResponse(Dictionary<int, int[]> graphEdges, Dictionary<int, CacheResult>? nonCacheMissResults = null, IDictionary<int, string>? extraContentPerProjectNumber = null)
+            public GraphCacheResponse(Dictionary<int, int[]?> graphEdges, Dictionary<int, CacheResult>? nonCacheMissResults = null, IDictionary<int, string>? extraContentPerProjectNumber = null)
             {
                 _extraContentPerProjectNumber = extraContentPerProjectNumber;
                 GraphEdges = graphEdges;
@@ -105,13 +105,11 @@ public GraphCacheResponse(Dictionary<int, int[]> graphEdges, Dictionary<int, Cac
             }
 
             public ProjectGraph CreateGraph(TestEnvironment env)
-            {
-                return Helpers.CreateProjectGraph(
+                => Helpers.CreateProjectGraph(
                     env,
                     GraphEdges,
-                    _extraContentPerProjectNumber,
-                    P2PTargets);
-            }
+                    extraContentPerProjectNumber: _extraContentPerProjectNumber,
+                    extraContentForAllNodes: P2PTargets);
 
             public static CacheResult SuccessfulProxyTargetResult()
             {
@@ -159,12 +157,11 @@ public CacheResult GetExpectedCacheResultForProjectNumber(int projectNumber)
 
             public override string ToString()
             {
-                // return base.ToString();
                 return string.Join(
                     ", ",
                     GraphEdges.Select(e => $"{Node(e.Key)}->{FormatChildren(e.Value)}"));
 
-                string FormatChildren(int[] children)
+                string FormatChildren(int[]? children)
                 {
                     return children == null
                         ? "Null"
@@ -338,15 +335,15 @@ public static IEnumerable<GraphCacheResponse> SuccessfulGraphs
             get
             {
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
-                        {1, null!}
+                        {1, null}
                     });
 
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
-                        {1, null!}
+                        {1, null}
                     },
                     new Dictionary<int, CacheResult>
                     {
@@ -354,9 +351,9 @@ public static IEnumerable<GraphCacheResponse> SuccessfulGraphs
                     });
 
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
-                        {1, null!}
+                        {1, null}
                     },
                     new Dictionary<int, CacheResult>
                     {
@@ -364,13 +361,13 @@ public static IEnumerable<GraphCacheResponse> SuccessfulGraphs
                     });
 
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
                         {1, new[] {2}}
                     });
 
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
                         {1, new[] {2}}
                     },
@@ -380,7 +377,7 @@ public static IEnumerable<GraphCacheResponse> SuccessfulGraphs
                     });
 
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
                         {1, new[] {2}}
                     },
@@ -390,7 +387,7 @@ public static IEnumerable<GraphCacheResponse> SuccessfulGraphs
                     });
 
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
                         {1, new[] {2}}
                     },
@@ -401,7 +398,7 @@ public static IEnumerable<GraphCacheResponse> SuccessfulGraphs
                     });
 
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
                         {1, new[] {2, 3, 7}},
                         {2, new[] {4}},
@@ -446,7 +443,7 @@ public static IEnumerable<object[]> SuccessfulGraphsWithBuildParameters
                         yield return new object[]
                         {
                             graph,
-                            ((BuildParameters) buildParameters.First()).Clone()
+                            buildParameters[0]
                         };
                     }
                 }
@@ -470,17 +467,19 @@ public void ProjectCacheByBuildParametersAndGraphBuildWorks(GraphCacheResponse t
                     graph)
             };
 
-            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
-
-            var graphResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
 
             graphResult.ShouldHaveSucceeded();
 
-            buildSession.Dispose();
-
-            buildSession.Logger.FullLog.ShouldContain("Static graph based");
+            logger.FullLog.ShouldContain("Static graph based");
 
-            AssertCacheBuild(graph, testData, mockCache, buildSession.Logger, graphResult.ResultsByNode, targets: "Build");
+            AssertCacheBuild(graph, testData, mockCache, logger, graphResult.ResultsByNode, targets: "Build");
         }
 
         [Theory]
@@ -501,80 +500,60 @@ public void ProjectCacheByBuildParametersAndBottomUpBuildWorks(GraphCacheRespons
                 ProjectCacheDescriptor = projectCacheDescriptor
             };
 
-
-            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+            MockLogger logger;
             var nodesToBuildResults = new Dictionary<ProjectGraphNode, BuildResult>();
-
-            foreach (var node in graph.ProjectNodesTopologicallySorted)
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
             {
-                var buildResult = buildSession.BuildProjectFile(node.ProjectInstance.FullPath);
+                logger = buildSession.Logger;
 
-                buildResult.ShouldHaveSucceeded();
+                foreach (var node in graph.ProjectNodesTopologicallySorted)
+                {
+                    var buildResult = buildSession.BuildProjectFile(node.ProjectInstance.FullPath);
 
-                nodesToBuildResults[node] = buildResult;
-            }
+                    buildResult.ShouldHaveSucceeded();
 
-            buildSession.Dispose();
+                    nodesToBuildResults[node] = buildResult;
+                }
+            }
 
-            buildSession.Logger.FullLog.ShouldContain("Static graph based");
+            logger.FullLog.ShouldContain("Static graph based");
 
-            AssertCacheBuild(graph, testData, mockCache, buildSession.Logger, nodesToBuildResults, targets: null);
+            AssertCacheBuild(graph, testData, mockCache, logger, nodesToBuildResults, targets: null);
         }
 
         [Theory]
         [MemberData(nameof(SuccessfulGraphsWithBuildParameters))]
-        public void ProjectCacheByVsWorkaroundWorks(GraphCacheResponse testData, BuildParameters buildParameters)
+        public void ProjectCacheByVsScenarioWorks(GraphCacheResponse testData, BuildParameters buildParameters)
         {
-            ProjectGraph? graph = null;
-
-            var (logger, nodesToBuildResults) = BuildGraphByVsWorkaround(
-                () =>
-                {
-                    graph = testData.CreateGraph(_env);
-                    return graph;
-                },
-                buildParameters);
+            (MockLogger logger, ProjectGraph graph, Dictionary<ProjectGraphNode, BuildResult> nodesToBuildResults) = BuildGraphVsScenario(testData, buildParameters);
 
-            graph.ShouldNotBeNull();
-
-            AssertCacheBuild(graph!, testData, null, logger, nodesToBuildResults, targets: null);
+            AssertCacheBuild(graph, testData, null, logger, nodesToBuildResults, targets: null);
         }
 
         [Fact]
-        public void ProjectCacheByVsWorkaroundIgnoresSlnDisabledProjects()
+        public void ProjectCacheByVsScenarioIgnoresSlnDisabledProjects()
         {
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
-                    {1, new[] {2}}
+                    { 1, new[] { 2 } },
                 },
                 extraContentPerProjectNumber: new Dictionary<int, string>()
                 {
-                    {1, "<PropertyGroup> <BuildProjectInSolution>false</BuildProjectInSolution> </PropertyGroup>"}
+                    { 1, "<PropertyGroup> <BuildProjectInSolution>false</BuildProjectInSolution> </PropertyGroup>" },
                 });
 
-            ProjectGraph? graph = null;
-
-            var (logger, nodesToBuildResults) = BuildGraphByVsWorkaround(
-                graphProducer: () =>
-                {
-                    graph = testData.CreateGraph(_env);
-                    return graph;
-                },
-                assertBuildResults: false
-            );
+            (MockLogger logger, ProjectGraph graph, _) = BuildGraphVsScenario(testData, assertBuildResults: false);
 
-            graph.ShouldNotBeNull();
-
-            logger.FullLog.ShouldNotContain($"EntryPoint: {graph!.GraphRoots.First().ProjectInstance.FullPath}");
+            logger.FullLog.ShouldNotContain($"EntryPoint: {graph.GraphRoots.First().ProjectInstance.FullPath}");
             logger.FullLog.ShouldContain($"EntryPoint: {graph.GraphRoots.First().ProjectReferences.First().ProjectInstance.FullPath}");
         }
 
         [Fact]
-        public void ProjectCacheByVsWorkaroundShouldNotSupportSolutionOnlyDependencies()
+        public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
         {
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, Array.Empty<int>()}
                 },
@@ -583,25 +562,24 @@ public void ProjectCacheByVsWorkaroundShouldNotSupportSolutionOnlyDependencies()
                     {1, $"<PropertyGroup> <ProjectDependency>{Guid.NewGuid()}</ProjectDependency> </PropertyGroup>"}
                 });
 
-            var (logger, nodeResults) = BuildGraphByVsWorkaround(
-                graphProducer: () => testData.CreateGraph(_env),
-                assertBuildResults: false);
+            (_, _, Dictionary<ProjectGraphNode, BuildResult> nodesToBuildResults) = BuildGraphVsScenario(testData, assertBuildResults: false);
 
-            nodeResults.ShouldHaveSingleItem();
+            nodesToBuildResults.ShouldHaveSingleItem();
 
-            var buildResult = nodeResults.First().Value;
+            var buildResult = nodesToBuildResults.First().Value;
             buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
             buildResult.Exception.Message.ShouldContain("Project cache service does not support solution only dependencies when running under Visual Studio.");
         }
 
-        private (MockLogger logger, Dictionary<ProjectGraphNode, BuildResult> nodesToBuildResults) BuildGraphByVsWorkaround(
-            Func<ProjectGraph> graphProducer,
+        private (MockLogger logger, ProjectGraph projectGraph, Dictionary<ProjectGraphNode, BuildResult> nodesToBuildResults) BuildGraphVsScenario(
+            GraphCacheResponse testData,
             BuildParameters? buildParameters = null,
             bool assertBuildResults = true
         )
         {
             var nodesToBuildResults = new Dictionary<ProjectGraphNode, BuildResult>();
-            MockLogger? logger;
+            MockLogger logger;
+            ProjectGraph graph;
 
             var currentBuildEnvironment = BuildEnvironmentHelper.Instance;
 
@@ -616,46 +594,45 @@ public void ProjectCacheByVsWorkaroundShouldNotSupportSolutionOnlyDependencies()
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
                 // Reset the environment variables stored in the build params to take into account TestEnvironmentChanges.
-                buildParameters = buildParameters  is null
+                buildParameters = buildParameters is null
                     ? new BuildParameters()
                     : new BuildParameters(buildParameters, resetEnvironment: true);
 
                 BuildManager.ProjectCacheItems.ShouldBeEmpty();
 
-                var graph = graphProducer.Invoke();
+                graph = testData.CreateGraph(_env);
 
                 BuildManager.ProjectCacheItems.ShouldHaveSingleItem();
 
-                var projectPaths = graph.ProjectNodes.Select(n => n.ProjectInstance.FullPath).ToArray();
-
                 // VS sets this global property on every project it builds.
                 var solutionConfigurationGlobalProperty = CreateSolutionConfigurationProperty(graph.ProjectNodes);
 
-                using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
-
-                foreach (var node in graph.ProjectNodesTopologicallySorted)
+                using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
                 {
-                    var buildResult = buildSession.BuildProjectFile(
-                        node.ProjectInstance.FullPath,
-                        globalProperties:
-                            new Dictionary<string, string>
-                            {
+                    logger = buildSession.Logger;
+
+                    foreach (var node in graph.ProjectNodesTopologicallySorted)
+                    {
+                        var buildResult = buildSession.BuildProjectFile(
+                            node.ProjectInstance.FullPath,
+                            globalProperties:
+                                new Dictionary<string, string>
+                                {
                                 { SolutionProjectGenerator.SolutionPathPropertyName, graph.GraphRoots.First().ProjectInstance.FullPath },
                                 { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty },
                                 { PropertyNames.InnerBuildProperty, "TheInnerBuildProperty"},
                                 { "TheInnerBuildProperty", "FooBar"},
-                            });
+                                });
 
-                    if (assertBuildResults)
-                    {
-                        buildResult.ShouldHaveSucceeded();
-                    }
+                        if (assertBuildResults)
+                        {
+                            buildResult.ShouldHaveSucceeded();
+                        }
 
-                    nodesToBuildResults[node] = buildResult;
+                        nodesToBuildResults[node] = buildResult;
+                    }
                 }
 
-                logger = buildSession.Logger;
-
                 if (assertBuildResults)
                 {
                     logger.FullLog.ShouldContain("Visual Studio Workaround based");
@@ -682,7 +659,7 @@ public void ProjectCacheByVsWorkaroundShouldNotSupportSolutionOnlyDependencies()
                 BuildManager.ProjectCacheItems.Clear();
             }
 
-            return (logger, nodesToBuildResults);
+            return (logger, graph, nodesToBuildResults);
         }
 
         private static string CreateSolutionConfigurationProperty(IReadOnlyCollection<ProjectGraphNode> projectNodes)
@@ -715,7 +692,7 @@ private static string CreateSolutionConfigurationProperty(IReadOnlyCollection<Pr
         }
 
         [Fact]
-        public void DesignTimeBuildsDuringVsWorkaroundShouldDisableTheCache()
+        public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
         {
             var currentBuildEnvironment = BuildEnvironmentHelper.Instance;
 
@@ -725,7 +702,7 @@ public void DesignTimeBuildsDuringVsWorkaroundShouldDisableTheCache()
             var referenceNumbers = Enumerable.Range(2, NativeMethodsShared.GetLogicalCoreCount()).ToArray();
 
             var testData = new GraphCacheResponse(
-                graphEdges: new Dictionary<int, int[]>
+                graphEdges: new Dictionary<int, int[]?>
                 {
                     {1, referenceNumbers}
                 },
@@ -747,38 +724,40 @@ public void DesignTimeBuildsDuringVsWorkaroundShouldDisableTheCache()
                 var rootNode = graph.GraphRoots.First();
                 var globalProperties = new Dictionary<string, string> { { "SolutionPath", rootNode.ProjectInstance.FullPath } };
 
-                using var buildSession = new Helpers.BuildManagerSession(_env);
-
-                // Build references in parallel.
-                var referenceBuildTasks = rootNode.ProjectReferences.Select(
-                    r => buildSession.BuildProjectFileAsync(
-                        r.ProjectInstance.FullPath,
-                        globalProperties: globalProperties));
-
-                foreach (var task in referenceBuildTasks)
+                MockLogger logger;
+                using (var buildSession = new Helpers.BuildManagerSession(_env))
                 {
-                    var buildResult = task.Result;
-                    buildResult.ShouldHaveSucceeded();
-                }
+                    logger = buildSession.Logger;
 
-                buildSession
-                    .BuildProjectFile(rootNode.ProjectInstance.FullPath, globalProperties: globalProperties)
-                    .ShouldHaveSucceeded();
+                    // Build references in parallel.
+                    var referenceBuildTasks = rootNode.ProjectReferences.Select(
+                        r => buildSession.BuildProjectFileAsync(
+                            r.ProjectInstance.FullPath,
+                            globalProperties: globalProperties));
 
-                buildSession.Dispose();
+                    foreach (var task in referenceBuildTasks)
+                    {
+                        var buildResult = task.Result;
+                        buildResult.ShouldHaveSucceeded();
+                    }
+
+                    buildSession
+                        .BuildProjectFile(rootNode.ProjectInstance.FullPath, globalProperties: globalProperties)
+                        .ShouldHaveSucceeded();
+                }
 
-                buildSession.Logger.FullLog.ShouldContain("Visual Studio Workaround based");
+                logger.FullLog.ShouldContain("Visual Studio Workaround based");
 
                 // Design time builds should not initialize the plugin.
-                buildSession.Logger.FullLog.ShouldNotContain("Running project cache with Visual Studio workaround");
+                logger.FullLog.ShouldNotContain("Running project cache with Visual Studio workaround");
 
                 // Cache doesn't get initialized and queried.
-                buildSession.Logger.FullLog.ShouldNotContain("BeginBuildAsync");
-                buildSession.Logger.FullLog.ShouldNotContain("GetCacheResultAsync for");
-                buildSession.Logger.FullLog.ShouldNotContain("Querying project cache for project");
+                logger.FullLog.ShouldNotContain("BeginBuildAsync");
+                logger.FullLog.ShouldNotContain("GetCacheResultAsync for");
+                logger.FullLog.ShouldNotContain("Querying project cache for project");
 
                 // Cache does get disposed.
-                StringShouldContainSubstring(buildSession.Logger.FullLog, "EndBuildAsync", 1);
+                StringShouldContainSubstring(logger.FullLog, "EndBuildAsync", 1);
             }
             finally
             {
@@ -793,7 +772,7 @@ public void DesignTimeBuildsDuringVsWorkaroundShouldDisableTheCache()
         public void RunningProxyBuildsOnOutOfProcNodesShouldIssueWarning(bool disableInprocNodeViaEnvironmentVariable)
         {
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, new[] {2}}
                 },
@@ -824,17 +803,19 @@ public void RunningProxyBuildsOnOutOfProcNodesShouldIssueWarning(bool disableInp
                 buildParameters.DisableInProcNode = true;
             }
 
-            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
-
-            var graphResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
 
             graphResult.ShouldHaveSucceeded();
 
-            buildSession.Dispose();
+            logger.FullLog.ShouldContain("Static graph based");
 
-            buildSession.Logger.FullLog.ShouldContain("Static graph based");
-
-            buildSession.Logger.AssertMessageCount("MSB4274", 1);
+            logger.AssertMessageCount("MSB4274", 1);
         }
 
         private void AssertCacheBuild(
@@ -847,25 +828,25 @@ private void AssertCacheBuild(
         {
             if (instanceMockCache != null)
             {
-                mockLogger.FullLog.ShouldContain("MockCache: BeginBuildAsync");
                 mockLogger.FullLog.ShouldContain("Instance based");
                 mockLogger.FullLog.ShouldNotContain("Assembly path based");
 
+                instanceMockCache.BeginBuildCalled.ShouldBeTrue();
                 instanceMockCache.Requests.Count.ShouldBe(graph.ProjectNodes.Count);
+                instanceMockCache.EndBuildCalled.ShouldBeTrue();
             }
             else
             {
-                mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: BeginBuildAsync");
                 mockLogger.FullLog.ShouldContain("Assembly path based");
                 mockLogger.FullLog.ShouldNotContain("Instance based");
 
+                mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: BeginBuildAsync");
                 Regex.Matches(mockLogger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for").Count.ShouldBe(graph.ProjectNodes.Count);
+                mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: EndBuildAsync");
             }
 
             foreach (var node in graph.ProjectNodes)
             {
-                var expectedCacheResponse = testData.GetExpectedCacheResultForNode(node);
-
                 if (string.IsNullOrEmpty(targets))
                 {
                     mockLogger.FullLog.ShouldContain(string.Format(ResourceUtilities.GetResourceString("ProjectCacheQueryStartedWithDefaultTargets"), node.ProjectInstance.FullPath));
@@ -878,46 +859,35 @@ private void AssertCacheBuild(
                 if (instanceMockCache != null)
                 {
                     instanceMockCache.Requests.ShouldContain(r => r.ProjectFullPath.Equals(node.ProjectInstance.FullPath));
-                    instanceMockCache.BeginBuildCalled.ShouldBeTrue();
-                    instanceMockCache.EndBuildCalled.ShouldBeTrue();
+
+                    var expectedCacheResponse = testData.GetExpectedCacheResultForNode(node);
+                    switch (expectedCacheResponse.ResultType)
+                    {
+                        case CacheResultType.CacheHit:
+                            AssertBuildResultForCacheHit(node.ProjectInstance.FullPath, projectPathToBuildResults[node], expectedCacheResponse);
+                            break;
+                        case CacheResultType.CacheMiss:
+                            break;
+                        case CacheResultType.CacheNotApplicable:
+                            break;
+                        case CacheResultType.None:
+                            break;
+                        default:
+                            throw new ArgumentOutOfRangeException();
+                    }
                 }
                 else
                 {
                     mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: GetCacheResultAsync for {node.ProjectInstance.FullPath}");
-                }
 
-                if (instanceMockCache == null)
-                {
                     // Too complicated, not worth it to send expected results to the assembly plugin, so skip checking the build results.
-                    continue;
-                }
-
-                switch (expectedCacheResponse.ResultType)
-                {
-                    case CacheResultType.CacheHit:
-                        AssertBuildResultForCacheHit(node.ProjectInstance.FullPath, projectPathToBuildResults[node], expectedCacheResponse);
-                        break;
-                    case CacheResultType.CacheMiss:
-                        break;
-                    case CacheResultType.CacheNotApplicable:
-                        break;
-                    case CacheResultType.None:
-                        break;
-                    default:
-                        throw new ArgumentOutOfRangeException();
                 }
             }
         }
 
-        private static int GetProjectNumber(ProjectGraphNode node)
-        {
-            return GetProjectNumber(node.ProjectInstance.FullPath);
-        }
+        private static int GetProjectNumber(ProjectGraphNode node) => GetProjectNumber(node.ProjectInstance.FullPath);
 
-        private static int GetProjectNumber(string projectPath)
-        {
-            return int.Parse(Path.GetFileNameWithoutExtension(projectPath));
-        }
+        private static int GetProjectNumber(string projectPath) => int.Parse(Path.GetFileNameWithoutExtension(projectPath));
 
         private void AssertBuildResultForCacheHit(
             string projectPath,
@@ -976,13 +946,17 @@ public void CacheShouldNotGetQueriedForNestedBuildRequests(BuildParameters build
                 new[] {new ProjectGraphEntryPoint(project1.Path)},
                 null);
 
-            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+            MockLogger logger;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
 
-            var buildResult = buildSession.BuildProjectFile(project1.Path);
+                BuildResult buildResult = buildSession.BuildProjectFile(project1.Path);
 
-            buildResult.ShouldHaveSucceeded();
+                buildResult.ShouldHaveSucceeded();
+            }
 
-            buildSession.Logger.ProjectStartedEvents.Count.ShouldBe(2);
+            logger.ProjectStartedEvents.Count.ShouldBe(2);
 
             mockCache.Requests.Count.ShouldBe(1);
             mockCache.Requests.First().ProjectFullPath.ShouldEndWith("1.proj");
@@ -992,7 +966,7 @@ public void CacheShouldNotGetQueriedForNestedBuildRequests(BuildParameters build
         public void CacheViaBuildParametersCanDiscoverAndLoadPluginFromAssembly()
         {
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, new[] {2, 3}}
                 }
@@ -1000,30 +974,34 @@ public void CacheViaBuildParametersCanDiscoverAndLoadPluginFromAssembly()
 
             var graph = testData.CreateGraph(_env);
 
-            using var buildSession = new Helpers.BuildManagerSession(
-                _env,
-                new BuildParameters
-                {
-                    ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
-                        SamplePluginAssemblyPath.Value,
-                        graph.EntryPointNodes.Select(n => new ProjectGraphEntryPoint(n.ProjectInstance.FullPath)).ToArray(),
-                        null)
-                });
+            var buildParameters = new BuildParameters
+            {
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
+                    SamplePluginAssemblyPath.Value,
+                    graph.EntryPointNodes.Select(n => new ProjectGraphEntryPoint(n.ProjectInstance.FullPath)).ToArray(),
+                    null)
+            };
 
-            var graphResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
 
             graphResult.ShouldHaveSucceeded();
 
-            buildSession.Logger.FullLog.ShouldContain("Explicit entry-point based");
+            logger.FullLog.ShouldContain("Explicit entry-point based");
 
-            AssertCacheBuild(graph, testData, null, buildSession.Logger, graphResult.ResultsByNode, targets: "Build");
+            AssertCacheBuild(graph, testData, null, logger, graphResult.ResultsByNode, targets: "Build");
         }
 
         [Fact]
         public void GraphBuildCanDiscoverAndLoadPluginFromAssembly()
         {
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, new[] {2, 3}}
                 }
@@ -1031,22 +1009,26 @@ public void GraphBuildCanDiscoverAndLoadPluginFromAssembly()
 
             var graph = testData.CreateGraph(_env);
 
-            using var buildSession = new Helpers.BuildManagerSession(_env);
-
-            var graphResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
 
             graphResult.ShouldHaveSucceeded();
 
-            buildSession.Logger.FullLog.ShouldContain("Static graph based");
+            logger.FullLog.ShouldContain("Static graph based");
 
-            AssertCacheBuild(graph, testData, null, buildSession.Logger, graphResult.ResultsByNode, targets: "Build");
+            AssertCacheBuild(graph, testData, null, logger, graphResult.ResultsByNode, targets: "Build");
         }
 
         [Fact]
         public void BuildFailsWhenCacheBuildResultIsWrong()
         {
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, new[] {2}}
                 },
@@ -1077,24 +1059,27 @@ public void BuildFailsWhenCacheBuildResultIsWrong()
             var graph = testData.CreateGraph(_env);
             var mockCache = new InstanceMockCache(testData);
 
-            using var buildSession = new Helpers.BuildManagerSession(
-                _env,
-                new BuildParameters
-                {
-                    ProjectCacheDescriptor =
-                        ProjectCacheDescriptor.FromInstance(mockCache, null, graph)
-                });
+            var buildParameters = new BuildParameters
+            {
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache, null, graph)
+            };
 
-            var buildResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
 
             mockCache.Requests.Count.ShouldBe(2);
 
-            buildResult.ResultsByNode.First(r => GetProjectNumber(r.Key) == 2).Value.ShouldHaveSucceeded();
-            buildResult.ResultsByNode.First(r => GetProjectNumber(r.Key) == 1).Value.ShouldHaveFailed();
+            graphResult.ResultsByNode.First(r => GetProjectNumber(r.Key) == 2).Value.ShouldHaveSucceeded();
+            graphResult.ResultsByNode.First(r => GetProjectNumber(r.Key) == 1).Value.ShouldHaveFailed();
 
-            buildResult.ShouldHaveFailed();
+            graphResult.ShouldHaveFailed();
 
-            buildSession.Logger.FullLog.ShouldContain("Reference file [Invalid file] does not exist");
+            logger.FullLog.ShouldContain("Reference file [Invalid file] does not exist");
         }
 
         [Fact]
@@ -1102,20 +1087,23 @@ public void GraphBuildErrorsIfMultiplePluginsAreFound()
         {
             var graph = Helpers.CreateProjectGraph(
                 _env,
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
-                    {1, new[] {2}}
+                    { 1, new[] { 2 } },
                 },
-                extraContentPerProjectNumber: null,
                 extraContentForAllNodes: @$"
 <ItemGroup>
    <{ItemTypeNames.ProjectCachePlugin} Include='Plugin$(MSBuildProjectName)' />
 </ItemGroup>
 ");
 
-            using var buildSession = new Helpers.BuildManagerSession(_env);
-
-            var graphResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
             
             graphResult.ShouldHaveFailed("A single project cache plugin must be specified but multiple where found:");
         }
@@ -1125,9 +1113,9 @@ public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
         {
             var graph = Helpers.CreateProjectGraph(
                 _env,
-                dependencyEdges: new Dictionary<int, int[]>
+                dependencyEdges: new Dictionary<int, int[]?>
                 {
-                    {1, new[] {2}}
+                    { 1, new[] { 2 } },
                 },
                 extraContentPerProjectNumber: new Dictionary<int, string>
                 {
@@ -1141,9 +1129,13 @@ public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
                     }
                 });
 
-            using var buildSession = new Helpers.BuildManagerSession(_env);
-
-            var graphResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
             
             graphResult.ShouldHaveFailed("When any static graph node defines a project cache, all nodes must define the same project cache.");
         }
@@ -1174,7 +1166,7 @@ public static IEnumerable<object[]> CacheExceptionLocationsTestData
         [MemberData(nameof(CacheExceptionLocationsTestData))]
         public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorLocations errorLocations, ErrorKind errorKind)
         {
-            SetEnvironmentForErrorLocations(errorLocations, errorKind.ToString());
+            SetEnvironmentForErrorLocations(errorLocations, errorKind);
 
             var project = _env.CreateFile("1.proj", @$"
                     <Project>
@@ -1293,15 +1285,14 @@ public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorL
         [MemberData(nameof(CacheExceptionLocationsTestData))]
         public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ErrorLocations errorLocations, ErrorKind errorKind)
         {
-            SetEnvironmentForErrorLocations(errorLocations, errorKind.ToString());
+            SetEnvironmentForErrorLocations(errorLocations, errorKind);
 
             var graph = Helpers.CreateProjectGraph(
                 _env,
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, new []{2}}
                 },
-                extraContentPerProjectNumber: null,
                 extraContentForAllNodes: @$"
 <ItemGroup>
     <{ItemTypeNames.ProjectCachePlugin} Include=`{SamplePluginAssemblyPath.Value}` />
@@ -1392,29 +1383,24 @@ public void EndBuildShouldGetCalledOnceWhenItThrowsExceptionsFromGraphBuilds()
                         </Target>
                     </Project>".Cleanup());
 
-            SetEnvironmentForErrorLocations(ErrorLocations.EndBuildAsync, ErrorKind.Exception.ToString());
-
-            using var buildSession = new Helpers.BuildManagerSession(
-                _env,
-                new BuildParameters
-                {
-                    UseSynchronousLogging = true
-                });
+            SetEnvironmentForErrorLocations(ErrorLocations.EndBuildAsync, ErrorKind.Exception);
 
-            var logger = buildSession.Logger;
-
-            GraphBuildResult buildResult = null!;
-            Should.NotThrow(
-                () =>
-                {
-                    buildResult = buildSession.BuildGraph(new ProjectGraph(project.Path));
-                });
+            var buildParameters = new BuildParameters
+            {
+                UseSynchronousLogging = true
+            };
 
-            buildResult.ShouldHaveFailed();
-            buildResult.Exception.InnerException!.ShouldNotBeNull();
-            buildResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(new ProjectGraph(project.Path));
+            }
 
-            buildSession.Dispose();
+            graphResult.ShouldHaveFailed();
+            graphResult.Exception.InnerException!.ShouldNotBeNull();
+            graphResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
 
             StringShouldContainSubstring(logger.FullLog, $"{nameof(AssemblyMockCache)}: EndBuildAsync", expectedOccurrences: 1);
         }
@@ -1427,7 +1413,7 @@ public void CacheShouldBeQueriedInParallelDuringGraphBuilds(bool useSynchronousL
             var referenceNumbers = new []{2, 3, 4};
 
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, referenceNumbers}
                 },
@@ -1460,7 +1446,7 @@ public void CacheShouldBeQueriedInParallelDuringGraphBuilds(bool useSynchronousL
                     }
                 });
 
-            using var buildSession = new Helpers.BuildManagerSession(_env, new BuildParameters()
+            var buildParameters = new BuildParameters()
             {
                 MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount(),
                 ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
@@ -1469,7 +1455,9 @@ public void CacheShouldBeQueriedInParallelDuringGraphBuilds(bool useSynchronousL
                     graph),
                 UseSynchronousLogging = useSynchronousLogging,
                 DisableInProcNode = disableInprocNode
-            });
+            };
+
+            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
 
             var task2 = BuildProjectFileAsync(2);
             var task3 = BuildProjectFileAsync(3);
@@ -1501,9 +1489,8 @@ Task<BuildResult> BuildProjectFileAsync(int projectNumber)
 
         [Theory]
         [InlineData(false, false)]
-        // TODO: Reenable when this gets into the main branch.
-        // [InlineData(true, true)]
-        public void ParallelStressTestForVsWorkaround(bool useSynchronousLogging, bool disableInprocNode)
+        [InlineData(true, true)]
+        public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool disableInprocNode)
         {
             var currentBuildEnvironment = BuildEnvironmentHelper.Instance;
 
@@ -1522,7 +1509,7 @@ public void ParallelStressTestForVsWorkaround(bool useSynchronousLogging, bool d
                 var referenceNumbers = Enumerable.Range(2, NativeMethodsShared.GetLogicalCoreCount() * 2).ToArray();
 
                 var testData = new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
                         {1, referenceNumbers}
                     },
@@ -1537,43 +1524,48 @@ public void ParallelStressTestForVsWorkaround(bool useSynchronousLogging, bool d
                 var solutionConfigurationGlobalProperty =
                     CreateSolutionConfigurationProperty(graph.ProjectNodes);
 
-                using var buildSession = new Helpers.BuildManagerSession(_env, new BuildParameters
+                var buildParameters = new BuildParameters
                 {
                     MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount(),
                     UseSynchronousLogging = useSynchronousLogging,
                     DisableInProcNode = disableInprocNode
-                });
+                };
 
+                MockLogger logger;
                 var buildResultTasks = new List<Task<BuildResult>>();
-
-                foreach (var node in graph.ProjectNodes.Where(n => referenceNumbers.Contains(GetProjectNumber(n))))
+                using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
                 {
-                    var buildResultTask = buildSession.BuildProjectFileAsync(
-                        node.ProjectInstance.FullPath,
-                        globalProperties:
-                        new Dictionary<string, string>
-                        {
+                    logger = buildSession.Logger;
+
+                    foreach (var node in graph.ProjectNodes.Where(n => referenceNumbers.Contains(GetProjectNumber(n))))
+                    {
+                        var buildResultTask = buildSession.BuildProjectFileAsync(
+                            node.ProjectInstance.FullPath,
+                            globalProperties:
+                            new Dictionary<string, string>
+                            {
                             { SolutionProjectGenerator.SolutionPathPropertyName, graph.GraphRoots.First().ProjectInstance.FullPath },
                             { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty }
-                        });
+                            });
 
-                    buildResultTasks.Add(buildResultTask);
-                }
+                        buildResultTasks.Add(buildResultTask);
+                    }
 
-                foreach (var buildResultTask in buildResultTasks)
-                {
-                    buildResultTask.Result.ShouldHaveSucceeded();
-                }
+                    foreach (var buildResultTask in buildResultTasks)
+                    {
+                        buildResultTask.Result.ShouldHaveSucceeded();
+                    }
 
-                buildSession.BuildProjectFile(
-                        graph.GraphRoots.First().ProjectInstance.FullPath,
-                        globalProperties:
-                        new Dictionary<string, string> {{"SolutionPath", graph.GraphRoots.First().ProjectInstance.FullPath}})
-                    .ShouldHaveSucceeded();
+                    buildSession.BuildProjectFile(
+                            graph.GraphRoots.First().ProjectInstance.FullPath,
+                            globalProperties:
+                            new Dictionary<string, string> { { "SolutionPath", graph.GraphRoots.First().ProjectInstance.FullPath } })
+                        .ShouldHaveSucceeded();
+                }
 
-                StringShouldContainSubstring(buildSession.Logger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for", graph.ProjectNodes.Count);
+                StringShouldContainSubstring(logger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for", graph.ProjectNodes.Count);
 
-                buildSession.Logger.FullLog.ShouldContain("Visual Studio Workaround based");
+                logger.FullLog.ShouldContain("Visual Studio Workaround based");
             }
             finally
             {
@@ -1590,7 +1582,7 @@ public void ParallelStressTest(bool useSynchronousLogging, bool disableInprocNod
             var referenceNumbers = Enumerable.Range(2, NativeMethodsShared.GetLogicalCoreCount() * 2).ToArray();
 
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, referenceNumbers}
                 },
@@ -1600,7 +1592,7 @@ public void ParallelStressTest(bool useSynchronousLogging, bool disableInprocNod
             var graph = testData.CreateGraph(_env);
             var cache = new InstanceMockCache(testData, TimeSpan.FromMilliseconds(50));
 
-            using var buildSession = new Helpers.BuildManagerSession(_env, new BuildParameters()
+            var buildParameters = new BuildParameters()
             {
                 MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount(),
                 ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
@@ -1609,9 +1601,15 @@ public void ParallelStressTest(bool useSynchronousLogging, bool disableInprocNod
                     graph),
                 UseSynchronousLogging = useSynchronousLogging,
                 DisableInProcNode = disableInprocNode
-            });
+            };
 
-            var graphResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
 
             graphResult.ShouldHaveSucceeded();
             cache.QueryStartStops.Count.ShouldBe(graph.ProjectNodes.Count * 2);
@@ -1684,25 +1682,29 @@ public void ProxyCacheHitsOnPreviousCacheMissesShouldWork()
                 MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount()
             };
 
-            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+            MockLogger logger;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
 
-            var buildRequests = new List<(string, string)>();
-            buildRequests.AddRange(projectPaths.Select(r => (r, cacheNotApplicableTarget)));
-            buildRequests.AddRange(projectPaths.Select(r => (r, cacheHitTarget)));
+                var buildRequests = new List<(string, string)>();
+                buildRequests.AddRange(projectPaths.Select(r => (r, cacheNotApplicableTarget)));
+                buildRequests.AddRange(projectPaths.Select(r => (r, cacheHitTarget)));
 
-            var buildTasks = new List<Task<BuildResult>>();
-            foreach (var (projectPath, target) in buildRequests)
-            {
-                buildTasks.Add(buildSession.BuildProjectFileAsync(projectPath, new[] {target}));
-            }
+                var buildTasks = new List<Task<BuildResult>>();
+                foreach (var (projectPath, target) in buildRequests)
+                {
+                    buildTasks.Add(buildSession.BuildProjectFileAsync(projectPath, new[] { target }));
+                }
 
-            foreach (var buildResult in buildTasks.Select(buildTask => buildTask.Result))
-            {
-                buildResult.Exception.ShouldBeNull();
-                buildResult.ShouldHaveSucceeded();
+                foreach (var buildResult in buildTasks.Select(buildTask => buildTask.Result))
+                {
+                    buildResult.Exception.ShouldBeNull();
+                    buildResult.ShouldHaveSucceeded();
+                }
             }
 
-            buildSession.Logger.ProjectStartedEvents.Count.ShouldBe(2 * projectPaths.Length);
+            logger.ProjectStartedEvents.Count.ShouldBe(2 * projectPaths.Length);
 
             cacheHitCount.ShouldBe(projectPaths.Length);
             nonCacheHitCount.ShouldBe(projectPaths.Length);
@@ -1714,7 +1716,7 @@ private static void StringShouldContainSubstring(string aString, string substrin
             Regex.Matches(aString, substring).Count.ShouldBe(expectedOccurrences);
         }
 
-        private void SetEnvironmentForErrorLocations(ErrorLocations errorLocations, string errorKind)
+        private void SetEnvironmentForErrorLocations(ErrorLocations errorLocations, ErrorKind errorKind)
         {
             foreach (var enumValue in Enum.GetValues(typeof(ErrorLocations)))
             {
@@ -1722,7 +1724,7 @@ private void SetEnvironmentForErrorLocations(ErrorLocations errorLocations, stri
                 if (errorLocations.HasFlag(typedValue))
                 {
                     var exceptionLocation = typedValue.ToString();
-                    _env.SetEnvironmentVariable(exceptionLocation, errorKind);
+                    _env.SetEnvironmentVariable(exceptionLocation, errorKind.ToString());
                     _output.WriteLine($"Set exception location: {exceptionLocation}");
                 }
             }
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index b14fc70d568..3c8457ab16e 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -6,6 +6,7 @@
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Collections.ObjectModel;
+using System.ComponentModel;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
@@ -30,12 +31,10 @@
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
+using Microsoft.NET.StringTools;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
 
-using Microsoft.NET.StringTools;
-using System.ComponentModel;
-
 #nullable disable
 
 namespace Microsoft.Build.Execution
@@ -1904,10 +1903,15 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                         submission.SubmissionId,
                         new ReadOnlyDictionary<ProjectGraphNode, BuildResult>(resultsPerNode ?? new Dictionary<ProjectGraphNode, BuildResult>())));
             }
+            catch (CircularDependencyException ex)
+{
+                BuildEventContext projectBuildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+                ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(projectBuildEventContext, new InvalidProjectFileException(ex.Message, ex));
+
+                ReportResultsToSubmission(new GraphBuildResult(submission.SubmissionId, circularDependency: true));
+            }
             catch (Exception ex) when (IsInvalidProjectOrIORelatedException(ex))
             {
-                GraphBuildResult result = null;
-
                 // ProjectGraph throws an aggregate exception with InvalidProjectFileException inside when evaluation fails
                 if (ex is AggregateException aggregateException && aggregateException.InnerExceptions.All(innerException => innerException is InvalidProjectFileException))
                 {
@@ -1923,13 +1927,6 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                         }
                     }
                 }
-                else if (ex is CircularDependencyException)
-                {
-                    result = new GraphBuildResult(submission.SubmissionId, true);
-
-                    BuildEventContext projectBuildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-                    ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(projectBuildEventContext, new InvalidProjectFileException(ex.Message, ex));
-                }
                 else
                 {
                     // Arbitrarily just choose the first entry point project's path
@@ -1939,9 +1936,7 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                     ((IBuildComponentHost)this).LoggingService.LogFatalBuildError(buildEventContext, ex, new BuildEventFileInfo(projectFile));
                 }
 
-                result ??= new GraphBuildResult(submission.SubmissionId, ex);
-
-                ReportResultsToSubmission(result);
+                ReportResultsToSubmission(new GraphBuildResult(submission.SubmissionId, ex));
 
                 lock (_syncLock)
                 {
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index f8d6a15e9d3..3cb530afca4 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1703,34 +1703,6 @@ internal static TransientTestFile CreateProjectFile(
             return env.CreateFile(projectNumber + ".proj", sb.ToString());
         }
 
-        internal static ProjectGraph CreateProjectGraph(
-            TestEnvironment env,
-            IDictionary<int, int[]> dependencyEdges,
-            IDictionary<int, string> extraContentPerProjectNumber,
-            string extraContentForAllNodes = null)
-        {
-            return CreateProjectGraph(
-                env: env,
-                dependencyEdges: dependencyEdges,
-                globalProperties: null,
-                createProjectFile: (environment, projectNumber, references, projectReferenceTargets, defaultTargets, extraContent) =>
-                {
-                    extraContent = extraContentPerProjectNumber != null && extraContentPerProjectNumber.TryGetValue(projectNumber, out var content)
-                        ? content
-                        : string.Empty;
-
-                    extraContent += extraContentForAllNodes ?? string.Empty;
-
-                    return CreateProjectFile(
-                        environment,
-                        projectNumber,
-                        references,
-                        projectReferenceTargets,
-                        defaultTargets,
-                        extraContent.Cleanup());
-                });
-        }
-
         internal static ProjectGraph CreateProjectGraph(
             TestEnvironment env,
             // direct dependencies that the kvp.key node has on the nodes represented by kvp.value
@@ -1738,7 +1710,9 @@ internal static ProjectGraph CreateProjectGraph(
             IDictionary<string, string> globalProperties = null,
             CreateProjectFileDelegate createProjectFile = null,
             IEnumerable<int> entryPoints = null,
-            ProjectCollection projectCollection = null)
+            ProjectCollection projectCollection = null,
+            IDictionary<int, string> extraContentPerProjectNumber = null,
+            string extraContentForAllNodes = null)
         {
             createProjectFile ??= CreateProjectFile;
 
@@ -1751,7 +1725,13 @@ internal static ProjectGraph CreateProjectGraph(
 
                 if (!nodes.ContainsKey(parent))
                 {
-                    var file = createProjectFile(env, parent, nodeDependencies.Value);
+                    TransientTestFile file = createProjectFile(
+                        env,
+                        parent,
+                        nodeDependencies.Value,
+                        projectReferenceTargets: null,
+                        defaultTargets: null,
+                        extraContent: GetExtraContent(parent));
                     nodes[parent] = (IsRoot(parent), file.Path);
                 }
             }
@@ -1768,7 +1748,12 @@ internal static ProjectGraph CreateProjectGraph(
                 {
                     if (!nodes.ContainsKey(reference))
                     {
-                        var file = createProjectFile(env, reference);
+                        TransientTestFile file = createProjectFile(
+                            env,
+                            reference,
+                            projectReferenceTargets: null,
+                            defaultTargets: null,
+                            extraContent: GetExtraContent(reference));
                         nodes[reference] = (false, file.Path);
                     }
                 }
@@ -1785,6 +1770,17 @@ internal static ProjectGraph CreateProjectGraph(
                     .Collection
                 );
 
+            string GetExtraContent(int projectNum)
+            {
+                string extraContent = extraContentPerProjectNumber != null && extraContentPerProjectNumber.TryGetValue(projectNum, out string extraContentForProject)
+                    ? extraContentForProject
+                    : string.Empty;
+
+                extraContent += extraContentForAllNodes ?? string.Empty;
+
+                return extraContent.Cleanup();
+            }
+
             bool IsRoot(int node)
             {
                 foreach (var nodeDependencies in dependencyEdges)
@@ -2084,15 +2080,12 @@ public async Task<BuildResult> BuildProjectFileAsync(
                 return await completion.Task;
             }
 
-            public GraphBuildResult BuildGraphSubmission(GraphBuildRequestData requestData)
-            {
-                return _buildManager.BuildRequest(requestData);
-            }
+            public BuildResult Build(BuildRequestData requestData) => _buildManager.BuildRequest(requestData);
+
+            public GraphBuildResult BuildGraphSubmission(GraphBuildRequestData requestData) => _buildManager.BuildRequest(requestData);
 
             public GraphBuildResult BuildGraph(ProjectGraph graph, string[] entryTargets = null)
-            {
-                return _buildManager.BuildRequest(new GraphBuildRequestData(graph, entryTargets ?? Array.Empty<string>()));
-            }
+                => _buildManager.BuildRequest(new GraphBuildRequestData(graph, entryTargets ?? Array.Empty<string>()));
 
             public void Dispose()
             {
