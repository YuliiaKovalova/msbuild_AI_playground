diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index a95842eb107..f464ca17374 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -54,9 +54,13 @@ These targets are all defined in `Microsoft.Common.targets` and are defined in M
 If implementing a project with an “outer” (determine what properties to pass to the real build) and “inner” (fully specified) build, only `GetTargetFrameworkProperties` is required in the “outer” build. The other targets listed can be “inner” build only.
 
 * `GetTargetFrameworks` tells referencing projects what options are available to the build.
-  * It returns an item with metadata `TargetFrameworks` indicating what TargetFrameworks are available in the project, as well as boolean metadata `HasSingleTargetFramework` and `IsRidAgnostic`.
+  * It returns an item with the following metadata:
+    * `TargetFrameworks` indicating what TargetFrameworks are available in the project
+    * `TargetFrameworkMonikers` and `TargetPlatformMonikers` indicating what framework / platform the `TargetFrameworks` map to.  This is to support implicitly setting the target platform version (for example inferring that `net5.0-windows` means the same as `net5.0-windows7.0`) as well as treating the `TargetFramework` values [as aliases](https://github.com/NuGet/Home/issues/5154)
+    * Boolean metadata for `HasSingleTargetFramework` and `IsRidAgnostic`.
+  * The `GetReferenceNearestTargetFrameworkTask` (provided by NuGet) is responsible for selecting the best matching `TargetFramework` of the referenced project
   * This target is _optional_. If not present, the reference will be built with no additional properties.
-  * **New** in MSBuild 15.5.
+  * **New** in MSBuild 15.5.  (`TargetFrameworkMonikers` and `TargetPlatformMonikers` metadata is new in MSBuild 16.8)
 * `GetTargetFrameworkProperties` determines what properties should be passed to the “main” target for a given `ReferringTargetFramework`.
   * **Deprecated** in MSBuild 15.5.
   * New for MSBuild 15/Visual Studio 2017. Supports the cross-targeting feature allowing a project to have multiple `TargetFrameworks`.
diff --git a/eng/Packages.props b/eng/Packages.props
index 1b516aebaf6..4211da2cb73 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -52,8 +52,7 @@
     <PackageReference Update="xunit.assert" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.console" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.core" Version="$(XUnitVersion)" />
-    <PackageReference Update="StreamJsonRpc" Version="2.5.44" />
-    <PackageReference Update="MessagePackAnalyzer" Version="2.1.165" PrivateAssets="all" />
+    <PackageReference Update="StreamJsonRpc" Version="2.4.48" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true'">
diff --git a/eng/Signing.props b/eng/Signing.props
index 83946d7c6e5..13912cb79a5 100644
--- a/eng/Signing.props
+++ b/eng/Signing.props
@@ -1,5 +1,8 @@
 <Project>
     <ItemGroup>
+		<FileSignInfo Include="Nerdbank.Streams.dll" CertificateName="3PartySHA2" /> 
+		<FileSignInfo Include="MessagePack.dll" CertificateName="3PartySHA2" /> 
+		<FileSignInfo Include="MessagePack.Annotations.dll" CertificateName="3PartySHA2" /> 
 		<ItemsToSign Include="$(VisualStudioSetupOutputPath)DevDivPackages\*.nupkg" />
 	</ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index 52082c1239d..ebae37eadc4 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -2546,10 +2546,6 @@ public partial interface IVbcHostObjectFreeThreaded
 }
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
-    public partial interface IResolveAssemblyReferenceTaskHandler : System.IDisposable
-    {
-        System.Threading.Tasks.Task<Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ResolveAssemblyReferenceResult> ExecuteAsync(Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ResolveAssemblyReferenceRequest input, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
-    }
     [MessagePack.MessagePackObjectAttribute(false)]
     public sealed partial class ReadOnlyTaskItem : Microsoft.Build.Framework.ITaskItem, Microsoft.Build.Framework.ITaskItem2
     {
@@ -2573,145 +2569,6 @@ public void RemoveMetadata(string metadataName) { }
         public void SetMetadata(string metadataName, string metadataValue) { }
         public void SetMetadataValueLiteral(string metadataName, string metadataValue) { }
     }
-    [MessagePack.MessagePackObjectAttribute(false)]
-    public partial class ResolveAssemblyReferenceRequest
-    {
-        public ResolveAssemblyReferenceRequest() { }
-        [MessagePack.KeyAttribute(0)]
-        public string[] AllowedAssemblyExtensions { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(1)]
-        public string[] AllowedRelatedFileExtensions { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(2)]
-        public string AppConfigFile { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(3)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] Assemblies { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(4)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] AssemblyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(5)]
-        public bool AutoUnify { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(6)]
-        public string[] CandidateAssemblyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(7)]
-        public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(8)]
-        public bool DoNotCopyLocalIfInGac { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(9)]
-        public bool FindDependencies { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(10)]
-        public bool FindDependenciesOfExternallyResolvedReferences { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(11)]
-        public bool FindRelatedFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(12)]
-        public bool FindSatellites { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(13)]
-        public bool FindSerializationAssemblies { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(14)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FullFrameworkAssemblyTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(15)]
-        public string[] FullFrameworkFolders { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(16)]
-        public string[] FullTargetFrameworkSubsetNames { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(17)]
-        public bool IgnoreDefaultInstalledAssemblySubsetTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(18)]
-        public bool IgnoreDefaultInstalledAssemblyTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(19)]
-        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(20)]
-        public bool IgnoreVersionForFrameworkReferences { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(21)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(22)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblyTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(23)]
-        public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(24)]
-        public string ProfileName { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(25)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedSDKReferences { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(26)]
-        public string[] SearchPaths { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(27)]
-        public bool Silent { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(28)]
-        public string StateFile { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(29)]
-        public bool SupportsBindingRedirectGeneration { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(30)]
-        public string TargetedRuntimeVersion { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(31)]
-        public string[] TargetFrameworkDirectories { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(32)]
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(33)]
-        public string TargetFrameworkMonikerDisplayName { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(34)]
-        public string[] TargetFrameworkSubsets { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(35)]
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(36)]
-        public string TargetProcessorArchitecture { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(37)]
-        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(38)]
-        public bool UseResolveAssemblyReferenceService { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(39)]
-        public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
-    }
-    [MessagePack.MessagePackObjectAttribute(false)]
-    public sealed partial class ResolveAssemblyReferenceResponse
-    {
-        public ResolveAssemblyReferenceResponse() { }
-        [MessagePack.KeyAttribute(0)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] CopyLocalFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(1)]
-        public string DependsOnNETStandard { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(2)]
-        public string DependsOnSystemRuntime { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(3)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FilesWritten { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(4)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] RelatedFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(5)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedDependencyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(6)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(7)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SatelliteFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(8)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ScatterFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(9)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SerializationAssemblyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(10)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SuggestedRedirects { get { throw null; } set { } }
-    }
-    [MessagePack.MessagePackObjectAttribute(false)]
-    public sealed partial class ResolveAssemblyReferenceResult
-    {
-        public ResolveAssemblyReferenceResult() { }
-        [MessagePack.KeyAttribute(4)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildErrorEventArgs> BuildErrorEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(5)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildMessageEventArgs> BuildMessageEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(6)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildWarningEventArgs> BuildWarningEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(3)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.CustomBuildEventArgs> CustomBuildEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(2)]
-        public int EventCount { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(1)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ResolveAssemblyReferenceResponse Response { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(0)]
-        public bool TaskResult { get { throw null; } set { } }
-    }
-}
-namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Server
-{
-    public sealed partial class RarController
-    {
-        public RarController(string pipeName, System.Func<string, System.Nullable<int>, System.Nullable<int>, int, bool, System.IO.Stream> streamFactory, System.Nullable<System.TimeSpan> timeout=default(System.Nullable<System.TimeSpan>)) { }
-        public System.Threading.Tasks.Task<int> StartAsync(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
-    }
 }
 namespace Microsoft.Build.Tasks.Xaml
 {
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 8d719962051..8b03db9724b 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -2168,10 +2168,6 @@ public partial interface IVbcHostObjectFreeThreaded
 }
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
-    public partial interface IResolveAssemblyReferenceTaskHandler : System.IDisposable
-    {
-        System.Threading.Tasks.Task<Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ResolveAssemblyReferenceResult> ExecuteAsync(Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ResolveAssemblyReferenceRequest input, System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken));
-    }
     [MessagePack.MessagePackObjectAttribute(false)]
     public sealed partial class ReadOnlyTaskItem : Microsoft.Build.Framework.ITaskItem, Microsoft.Build.Framework.ITaskItem2
     {
@@ -2195,145 +2191,6 @@ public void RemoveMetadata(string metadataName) { }
         public void SetMetadata(string metadataName, string metadataValue) { }
         public void SetMetadataValueLiteral(string metadataName, string metadataValue) { }
     }
-    [MessagePack.MessagePackObjectAttribute(false)]
-    public partial class ResolveAssemblyReferenceRequest
-    {
-        public ResolveAssemblyReferenceRequest() { }
-        [MessagePack.KeyAttribute(0)]
-        public string[] AllowedAssemblyExtensions { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(1)]
-        public string[] AllowedRelatedFileExtensions { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(2)]
-        public string AppConfigFile { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(3)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] Assemblies { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(4)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] AssemblyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(5)]
-        public bool AutoUnify { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(6)]
-        public string[] CandidateAssemblyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(7)]
-        public bool CopyLocalDependenciesWhenParentReferenceInGac { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(8)]
-        public bool DoNotCopyLocalIfInGac { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(9)]
-        public bool FindDependencies { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(10)]
-        public bool FindDependenciesOfExternallyResolvedReferences { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(11)]
-        public bool FindRelatedFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(12)]
-        public bool FindSatellites { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(13)]
-        public bool FindSerializationAssemblies { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(14)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FullFrameworkAssemblyTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(15)]
-        public string[] FullFrameworkFolders { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(16)]
-        public string[] FullTargetFrameworkSubsetNames { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(17)]
-        public bool IgnoreDefaultInstalledAssemblySubsetTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(18)]
-        public bool IgnoreDefaultInstalledAssemblyTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(19)]
-        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(20)]
-        public bool IgnoreVersionForFrameworkReferences { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(21)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblySubsetTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(22)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] InstalledAssemblyTables { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(23)]
-        public string[] LatestTargetFrameworkDirectories { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(24)]
-        public string ProfileName { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(25)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedSDKReferences { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(26)]
-        public string[] SearchPaths { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(27)]
-        public bool Silent { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(28)]
-        public string StateFile { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(29)]
-        public bool SupportsBindingRedirectGeneration { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(30)]
-        public string TargetedRuntimeVersion { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(31)]
-        public string[] TargetFrameworkDirectories { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(32)]
-        public string TargetFrameworkMoniker { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(33)]
-        public string TargetFrameworkMonikerDisplayName { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(34)]
-        public string[] TargetFrameworkSubsets { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(35)]
-        public string TargetFrameworkVersion { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(36)]
-        public string TargetProcessorArchitecture { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(37)]
-        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(38)]
-        public bool UseResolveAssemblyReferenceService { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(39)]
-        public string WarnOrErrorOnTargetArchitectureMismatch { get { throw null; } set { } }
-    }
-    [MessagePack.MessagePackObjectAttribute(false)]
-    public sealed partial class ResolveAssemblyReferenceResponse
-    {
-        public ResolveAssemblyReferenceResponse() { }
-        [MessagePack.KeyAttribute(0)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] CopyLocalFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(1)]
-        public string DependsOnNETStandard { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(2)]
-        public string DependsOnSystemRuntime { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(3)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] FilesWritten { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(4)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] RelatedFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(5)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedDependencyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(6)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ResolvedFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(7)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SatelliteFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(8)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] ScatterFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(9)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SerializationAssemblyFiles { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(10)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ReadOnlyTaskItem[] SuggestedRedirects { get { throw null; } set { } }
-    }
-    [MessagePack.MessagePackObjectAttribute(false)]
-    public sealed partial class ResolveAssemblyReferenceResult
-    {
-        public ResolveAssemblyReferenceResult() { }
-        [MessagePack.KeyAttribute(4)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildErrorEventArgs> BuildErrorEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(5)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildMessageEventArgs> BuildMessageEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(6)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.BuildWarningEventArgs> BuildWarningEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(3)]
-        public System.Collections.Generic.List<Microsoft.Build.Framework.CustomBuildEventArgs> CustomBuildEvents { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(2)]
-        public int EventCount { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(1)]
-        public Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract.ResolveAssemblyReferenceResponse Response { get { throw null; } set { } }
-        [MessagePack.KeyAttribute(0)]
-        public bool TaskResult { get { throw null; } set { } }
-    }
-}
-namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Server
-{
-    public sealed partial class RarController
-    {
-        public RarController(string pipeName, System.Func<string, System.Nullable<int>, System.Nullable<int>, int, bool, System.IO.Stream> streamFactory, System.Nullable<System.TimeSpan> timeout=default(System.Nullable<System.TimeSpan>)) { }
-        public System.Threading.Tasks.Task<int> StartAsync(System.Threading.CancellationToken cancellationToken=default(System.Threading.CancellationToken)) { throw null; }
-    }
 }
 namespace System.Deployment.Internal.CodeSigning
 {
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
index 59e288501ae..f3fd55dcde6 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
@@ -271,6 +271,73 @@ public void SdkResolverLoaderErrorsWhenManifestTargetMissing()
             }
         }
 
+        [Fact]
+        public void SdkResolverLoaderHonorsIncludeDefaultEnvVar()
+        {
+            using (var env = TestEnvironment.Create(_output))
+            {
+                var origIncludeDefault = Environment.GetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER");
+                try
+                {
+                    var testRoot = env.CreateFolder().Path;
+                    Environment.SetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER", "false");
+                    SdkResolverLoader loader = new MockSdkResolverLoader()
+                    {
+                        LoadResolversAction = (resolverPath, loggingContext, location, resolvers) => {
+                            resolvers.Add(new MockSdkResolverWithAssemblyPath(resolverPath));
+                        }
+                    };
+                    IList<SdkResolverBase> resolvers = loader.LoadResolvers(_loggingContext, new MockElementLocation("file"));
+
+                    resolvers.Count.ShouldBe(0);
+                }
+                finally
+                {
+                    Environment.SetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER", origIncludeDefault);
+                }
+            }
+        }
+
+        [Fact]
+        public void SdkResolverLoaderHonorsAdditionalResolversFolder()
+        {
+            using (var env = TestEnvironment.Create(_output))
+            {
+                var origResolversFolder = Environment.GetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER");
+                try
+                {
+                    var testRoot = env.CreateFolder().Path;
+                    var additionalRoot = env.CreateFolder().Path;
+
+                    var resolver1 = "Resolver1";
+                    var resolver1Path = Path.Combine(additionalRoot, resolver1, $"{resolver1}.dll");
+                    Directory.CreateDirectory(Path.Combine(testRoot, resolver1));
+                    File.WriteAllText(Path.Combine(testRoot, resolver1, $"{resolver1}.dll"), string.Empty);
+                    Directory.CreateDirectory(Path.Combine(additionalRoot, resolver1));
+                    File.WriteAllText(resolver1Path, string.Empty);
+                    var resolver2 = "Resolver2";
+                    var resolver2Path = Path.Combine(testRoot, resolver2, $"{resolver2}.dll");
+                    Directory.CreateDirectory(Path.Combine(testRoot, resolver2));
+                    File.WriteAllText(resolver2Path, string.Empty);
+                    var resolver3 = "Resolver3";
+                    var resolver3Path = Path.Combine(additionalRoot, resolver3, $"{resolver3}.dll");
+                    Directory.CreateDirectory(Path.Combine(additionalRoot, resolver3));
+                    File.WriteAllText(resolver3Path, string.Empty);
+
+                    Environment.SetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER", additionalRoot);
+
+                    SdkResolverLoader loader = new SdkResolverLoader();
+                    IList<string> resolvers = loader.FindPotentialSdkResolvers(testRoot, new MockElementLocation("file"));
+
+                    resolvers.ShouldBeSameIgnoringOrder(new[] { resolver1Path, resolver2Path, resolver3Path });
+                }
+                finally
+                {
+                    Environment.SetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER", origResolversFolder);
+                }
+            }
+        }
+
         private class MockSdkResolverThatDoesNotLoad : SdkResolverBase
         {
             public const string ExpectedMessage = "A8BB8B3131D3475D881ACD3AF8D75BD6";
@@ -306,6 +373,25 @@ public override SdkResultBase Resolve(SdkReference sdkReference, SdkResolverCont
             }
         }
 
+        private class MockSdkResolverWithAssemblyPath : SdkResolverBase
+        {
+            public string AssemblyPath;
+
+            public MockSdkResolverWithAssemblyPath(string assemblyPath = "")
+            {
+                AssemblyPath = assemblyPath;
+            }
+
+            public override string Name => nameof(MockSdkResolverWithAssemblyPath);
+
+            public override int Priority => 0;
+
+            public override SdkResultBase Resolve(SdkReference sdkReference, SdkResolverContextBase resolverContext, SdkResultFactoryBase factory)
+            {
+                throw new NotImplementedException();
+            }
+        }
+
         private class MockSdkResolverLoader : SdkResolverLoader
         {
             public Func<string, LoggingContext, ElementLocation, Assembly> LoadResolverAssemblyFunc { get; set; }
@@ -314,6 +400,8 @@ private class MockSdkResolverLoader : SdkResolverLoader
 
             public Func<Assembly, IEnumerable<Type>> GetResolverTypesFunc { get; set; }
 
+            public Action<string, LoggingContext, ElementLocation, List<SdkResolver>> LoadResolversAction { get; set; }
+
             protected override Assembly LoadResolverAssembly(string resolverPath, LoggingContext loggingContext, ElementLocation location)
             {
                 if (LoadResolverAssemblyFunc != null)
@@ -343,6 +431,16 @@ internal override IList<string> FindPotentialSdkResolvers(string rootFolder, Ele
 
                 return base.FindPotentialSdkResolvers(rootFolder, location);
             }
+
+            protected override void LoadResolvers(string resolverPath, LoggingContext loggingContext, ElementLocation location, List<SdkResolver> resolvers)
+            {
+                if (LoadResolversAction != null)
+                {
+                    LoadResolversAction(resolverPath, loggingContext, location, resolvers);
+                    return;
+                }
+                base.LoadResolvers(resolverPath, loggingContext, location, resolvers);
+            }
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 4efff7385f8..8a681683154 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -11,7 +11,6 @@
 using System.Threading.Tasks;
 using System.Runtime.InteropServices;
 using System.Security.Principal;
-using Task = System.Threading.Tasks.Task;
 
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
@@ -225,7 +224,7 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
                 string taskHostNameForClr2TaskHost = Path.GetFileNameWithoutExtension(NodeProviderOutOfProcTaskHost.TaskHostNameForClr2TaskHost);
                 if (Path.GetFileNameWithoutExtension(msbuildLocation).Equals(taskHostNameForClr2TaskHost, StringComparison.OrdinalIgnoreCase))
                 {
-                    if (FrameworkLocationHelper.GetPathToDotNetFrameworkV35(Shared.DotNetFrameworkArchitecture.Current) == null)
+                    if (FrameworkLocationHelper.GetPathToDotNetFrameworkV35(DotNetFrameworkArchitecture.Current) == null)
                     {
                         CommunicationsUtilities.Trace
                             (
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index 5310cfc916c..0c52dddff33 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -13,7 +13,6 @@
 using System.Collections.Generic;
 using System.Threading;
 using System.Threading.Tasks;
-using Task = System.Threading.Tasks.Task;
 
 namespace Microsoft.Build.BackEnd.SdkResolution
 {
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index 1f9eb065df4..e0d472eea6e 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -20,11 +20,16 @@ internal class SdkResolverLoader
         private readonly CoreClrAssemblyLoader _loader = new CoreClrAssemblyLoader();
 #endif
 
+        private readonly string IncludeDefaultResolver = Environment.GetEnvironmentVariable("MSBUILDINCLUDEDEFAULTSDKRESOLVER");
+
+        private readonly string AdditionalResolversFolder = Environment.GetEnvironmentVariable("MSBUILDADDITIONALSDKRESOLVERSFOLDER");
+
         internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
             ElementLocation location)
         {
-            // Always add the default resolver
-            var resolvers = new List<SdkResolver> {new DefaultSdkResolver()};
+            var resolvers = !String.Equals(IncludeDefaultResolver, "false", StringComparison.OrdinalIgnoreCase) ? 
+                new List<SdkResolver> {new DefaultSdkResolver()}
+                : new List<SdkResolver>();
 
             var potentialResolvers = FindPotentialSdkResolvers(
                 Path.Combine(BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32, "SdkResolvers"), location);
@@ -53,12 +58,14 @@ internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder, Elem
         {
             var assembliesList = new List<string>();
 
-            if (string.IsNullOrEmpty(rootFolder) || !FileUtilities.DirectoryExistsNoThrow(rootFolder))
+            if ((string.IsNullOrEmpty(rootFolder) || !FileUtilities.DirectoryExistsNoThrow(rootFolder)) && AdditionalResolversFolder == null)
             {
                 return assembliesList;
             }
 
-            foreach (var subfolder in new DirectoryInfo(rootFolder).GetDirectories())
+            DirectoryInfo[] subfolders = GetSubfolders(rootFolder, AdditionalResolversFolder);
+
+            foreach (var subfolder in subfolders)
             {
                 var assembly = Path.Combine(subfolder.FullName, $"{subfolder.Name}.dll");
                 var manifest = Path.Combine(subfolder.FullName, $"{subfolder.Name}.xml");
@@ -78,6 +85,44 @@ internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder, Elem
             return assembliesList;
         }
 
+        private DirectoryInfo[] GetSubfolders(string rootFolder, string additionalResolversFolder)
+        {
+            DirectoryInfo[] subfolders = null;
+            if (!string.IsNullOrEmpty(rootFolder) && FileUtilities.DirectoryExistsNoThrow(rootFolder))
+            {
+                subfolders = new DirectoryInfo(rootFolder).GetDirectories();
+            }
+
+            if (additionalResolversFolder != null)
+            {
+                var resolversDirInfo = new DirectoryInfo(additionalResolversFolder);
+                if (resolversDirInfo.Exists)
+                {
+                    HashSet<DirectoryInfo> overrideFolders = resolversDirInfo.GetDirectories().ToHashSet(new DirInfoNameComparer());
+                    if (subfolders != null)
+                    {
+                        overrideFolders.UnionWith(subfolders);
+                    }
+                    return overrideFolders.ToArray();
+                }
+            }
+
+            return subfolders;
+        }
+
+        private class DirInfoNameComparer : IEqualityComparer<DirectoryInfo>
+        {
+            public bool Equals(DirectoryInfo first, DirectoryInfo second)
+            {
+                return string.Equals(first.Name, second.Name, StringComparison.OrdinalIgnoreCase);
+            }
+
+            public int GetHashCode(DirectoryInfo value)
+            {
+                return value.Name.GetHashCode();
+            }
+        }
+
         private bool TryAddAssemblyFromManifest(string pathToManifest, string manifestFolder, List<string> assembliesList, ElementLocation location)
         {
             if (!string.IsNullOrEmpty(pathToManifest) && !FileUtilities.FileExistsNoThrow(pathToManifest)) return false;
diff --git a/src/Build/BackEnd/Node/RarNode.cs b/src/Build/BackEnd/Node/RarNode.cs
index a16abc293b1..9d72f3d0c53 100644
--- a/src/Build/BackEnd/Node/RarNode.cs
+++ b/src/Build/BackEnd/Node/RarNode.cs
@@ -8,9 +8,9 @@
 using System.Threading.Tasks;
 
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Tasks.ResolveAssemblyReferences.Server;
 
 namespace Microsoft.Build.Execution
 {
@@ -26,7 +26,7 @@ public NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out Except
             shutdownException = null;
             using CancellationTokenSource cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
             string pipeName = CommunicationsUtilities.GetRarPipeName(nodeReuse, lowPriority);
-            RarController controller = new RarController(pipeName, NamedPipeUtil.CreateNamedPipeServer);
+            IRarController controller = GetController(pipeName);
 
             Task<int> rarTask = controller.StartAsync(cts.Token);
 
@@ -37,6 +37,9 @@ public NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out Except
             int index;
             try
             {
+                // Wait for any of these task to finish:
+                // - rarTask can timeout (default is 15 mins)
+                // - msBuildShutdown ends when it recieves command to shutdown
                 index = Task.WaitAny(msBuildShutdown, rarTask);
             }
             catch (TaskCanceledException e)
@@ -59,6 +62,19 @@ public NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out Except
             }
         }
 
+        private static IRarController GetController(string pipeName)
+        {
+            const string rarControllerName = "Microsoft.Build.Tasks.ResolveAssemblyReferences.Server.RarController, Microsoft.Build.Tasks.Core";
+            Type rarControllerType = Type.GetType(rarControllerName);
+
+            IRarController controller = (IRarController)Activator.CreateInstance(rarControllerType, pipeName, null);
+            ErrorUtilities.VerifyThrow(controller != null, "Couldn't create instace of IRarController for '{0}' type", rarControllerName);
+
+            controller.SetStreamFactory(NamedPipeUtil.CreateNamedPipeServer);
+            return controller;
+        }
+
+
         public NodeEngineShutdownReason Run(out Exception shutdownException)
         {
             return Run(false, false, out shutdownException);
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 26759da6f92..2a98b2fdf32 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -13,7 +13,6 @@
 using System.Text;
 using System.Threading;
 using System.Threading.Tasks;
-using Task = System.Threading.Tasks.Task;
 
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Construction;
@@ -23,6 +22,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
+
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
 namespace Microsoft.Build.BackEnd
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 966336543eb..126a75d9935 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -30,7 +30,6 @@
 
   <ItemGroup>
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
-    <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
 
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
diff --git a/src/Framework/IRarController.cs b/src/Framework/IRarController.cs
new file mode 100644
index 00000000000..7d29c97081c
--- /dev/null
+++ b/src/Framework/IRarController.cs
@@ -0,0 +1,17 @@
+﻿using System;
+using System.IO;
+using System.Threading;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// API for controller of ResolveAssemblyReference node
+    /// </summary>
+    internal interface IRarController
+    {
+        Task<int> StartAsync(CancellationToken token);
+
+        void SetStreamFactory(Func<string, int?, int?, int, bool, Stream> streamFactory);
+    }
+}
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 1c1f5da8281..1e8dc5f827b 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1541,6 +1541,7 @@ elementFormDefault="qualified">
             <xs:documentation><!-- _locID_text="InstallFrom" _locComment="" -->Web, Unc, or Disk</xs:documentation>
         </xs:annotation>
     </xs:element>
+    <xs:element name="AnalysisLevel" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="InstallUrl" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="IsCodeSharingProject" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="IsWebBootstrapper" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
diff --git a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
index 3539d5f540d..6e3cd15181e 100644
--- a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
+++ b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
@@ -40,10 +40,13 @@
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Threading.Tasks.Dataflow.dll" target="v15.0/bin" />
-    <file src="$X86BinPath$/StreamJson.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/StreamJsonRpc.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/Nerdbank.Streams.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.IO.Pipelines.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/Microsoft.VisualStudio.Threading.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/Microsoft.VisualStudio.Validation.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/MessagePack.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/MessagePack.Annotations.dll" target="v15.0/bin" />
 
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.Core.xsd" target="v15.0/bin/MSBuild" />
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.CommonTypes.xsd" target="v15.0/bin/MSBuild" />
@@ -98,10 +101,13 @@
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Threading.Tasks.Dataflow.dll" target="v15.0/bin/amd64" />
-    <file src="$X86BinPath$/StreamJson.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/StreamJsonRpc.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/Nerdbank.Streams.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.IO.Pipelines.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/Microsoft.VisualStudio.Threading.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/Microsoft.VisualStudio.Validation.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/MessagePack.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/MessagePack.Annotations.dll" target="v15.0/bin/amd64" />
 
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.Core.xsd" target="v15.0/bin/amd64/MSBuild" />
     <file src="$X86BinPath$/MSBuild/Microsoft.Build.CommonTypes.xsd" target="v15.0/bin/amd64/MSBuild" />
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 74b440353ff..d813b8deb3d 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -48,10 +48,13 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)StreamJsonRpc.dll vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)StreamJsonRpc.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Nerdbank.Streams.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.IO.Pipelines.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.VisualStudio.Threading.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.VisualStudio.Validation.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)MessagePack.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)MessagePack.Annotations.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
   file source=$(X86BinPath)Microsoft.Common.CrossTargeting.targets
   file source=$(X86BinPath)Microsoft.Common.overridetasks
@@ -201,10 +204,13 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)StreamJsonRpc.dll vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)StreamJsonRpc.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Nerdbank.Streams.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.IO.Pipelines.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.VisualStudio.Threading.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.VisualStudio.Validation.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)MessagePack.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)MessagePack.Annotations.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
   file source=$(X86BinPath)Microsoft.Common.CrossTargeting.targets
   file source=$(X86BinPath)Microsoft.Common.overridetasks
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs
index a2cf11f7e64..adeecbcb9b8 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs
@@ -80,7 +80,7 @@ public void TransmitDataTest()
             using CancellationTokenSource cts = new CancellationTokenSource();
             (Stream serverStream, Stream clientStream) = FullDuplexStream.CreatePair();
 
-            RarController controller = new RarController(string.Empty, GetPipe);
+            RarController controller = new RarController(string.Empty);
             Task serverTask = controller.HandleClientAsync(serverStream, cts.Token);
             RarClient client = new RarClient(new RarTestEngine(clientStream));
             ITaskItem[] assemblyNames = new TaskItem[]
@@ -104,11 +104,6 @@ public void TransmitDataTest()
             clientStream.Dispose();
         }
 
-        private NamedPipeServerStream GetPipe(string pipeName, int? arg2, int? arg3, int arg4, bool arg5)
-        {
-            throw new NotSupportedException();
-        }
-
         class RarTestEngine : IRarBuildEngine
         {
             public Stream ClientStream { get; }
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index 0c5e0242a92..51ef08021b0 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -21,13 +21,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Import Project="$(CustomBeforeMicrosoftCommonCrossTargetingTargets)" Condition="'$(CustomBeforeMicrosoftCommonCrossTargetingTargets)' != '' and Exists('$(CustomBeforeMicrosoftCommonCrossTargetingTargets)')"/>
 
   <Target Name="GetTargetFrameworks"
+          DependsOnTargets="GetTargetFrameworksWithPlatformFromInnerBuilds"
           Returns="@(_ThisProjectBuildMetadata)">
+
+    <Error Condition="'$(IsCrossTargetingBuild)' != 'true'"
+           Text="Internal MSBuild error: CrossTargeting GetTargetFrameworks target should only be used in cross targeting (outer) build" />
+    
     <ItemGroup>
       <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
-        <TargetFrameworks Condition="'$(TargetFrameworks)' != ''">$(TargetFrameworks)</TargetFrameworks>
-        <TargetFrameworks Condition="'$(TargetFrameworks)' == ''">$(TargetFramework)</TargetFrameworks>
-        <HasSingleTargetFramework>true</HasSingleTargetFramework>
-        <HasSingleTargetFramework Condition="'$(IsCrossTargetingBuild)' == 'true'">false</HasSingleTargetFramework>
+        <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
+        <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
+        <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
+
+        <HasSingleTargetFramework>false</HasSingleTargetFramework>
+
         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
         <IsRidAgnostic>false</IsRidAgnostic>
         <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
@@ -46,6 +53,18 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </ItemGroup>
   </Target>
 
+  <Target Name="GetTargetFrameworksWithPlatformFromInnerBuilds"
+          DependsOnTargets="_ComputeTargetFrameworkItems">
+
+    <MSBuild Projects="@(_InnerBuildProjects)"
+             Condition="'@(_InnerBuildProjects)' != '' "
+             Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework"
+             BuildInParallel="$(BuildInParallel)">
+      <Output ItemName="_TargetFrameworkInfo" TaskParameter="TargetOutputs" />
+    </MSBuild>
+
+  </Target>
+
   <!--
   ============================================================
                                        DispatchToInnerBuilds
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index deaa28c1216..1b0aa167c3c 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1653,11 +1653,26 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </ItemGroup>
 
     <!-- For each reference, get closest match -->
+
+    <!-- Pass the CurrentProjectTargetPlatform parameter to the task only if GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter is true.  This means
+         that we are using a version of NuGet which supports that parameter on this task. -->
+    
     <GetReferenceNearestTargetFrameworkTask AnnotatedProjectReferences="@(_ProjectReferenceTargetFrameworkPossibilities)"
                                             CurrentProjectTargetFramework="$(ReferringTargetFrameworkForProjectReferences)"
+                                            CurrentProjectTargetPlatform="$(TargetPlatformMoniker)"
                                             CurrentProjectName="$(MSBuildProjectName)"
                                             FallbackTargetFrameworks="$(AssetTargetFallback)"
-                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities->Count())' != '0' and '$(ReferringTargetFrameworkForProjectReferences)' != ''">
+                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities->Count())' != '0' and '$(ReferringTargetFrameworkForProjectReferences)' != ''
+                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' == 'true'">
+      <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
+    </GetReferenceNearestTargetFrameworkTask>
+
+    <GetReferenceNearestTargetFrameworkTask AnnotatedProjectReferences="@(_ProjectReferenceTargetFrameworkPossibilities)"
+                                            CurrentProjectTargetFramework="$(ReferringTargetFrameworkForProjectReferences)"
+                                            CurrentProjectName="$(MSBuildProjectName)"
+                                            FallbackTargetFrameworks="$(AssetTargetFallback)"
+                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities->Count())' != '0' and '$(ReferringTargetFrameworkForProjectReferences)' != ''
+                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' != 'true'">
       <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
     </GetReferenceNearestTargetFrameworkTask>
 
@@ -1697,20 +1712,41 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </Target>
 
   <Target Name="GetTargetFrameworks"
+          DependsOnTargets="GetTargetFrameworksWithPlatformForSingleTargetFramework"
           Returns="@(_ThisProjectBuildMetadata)">
+
+    <Error Condition="'$(IsCrossTargetingBuild)' == 'true'"
+           Text="Internal MSBuild error: Non-CrossTargeting GetTargetFrameworks target should not be used in cross targeting (outer) build" />
+
     <ItemGroup>
       <_ThisProjectBuildMetadata Include="$(MSBuildProjectFullPath)">
-        <TargetFrameworks Condition="'$(TargetFrameworks)' != ''">$(TargetFrameworks)</TargetFrameworks>
-        <TargetFrameworks Condition="'$(TargetFrameworks)' == ''">$(TargetFramework)</TargetFrameworks>
+        <TargetFrameworks>@(_TargetFrameworkInfo)</TargetFrameworks>
+        <TargetFrameworkMonikers>@(_TargetFrameworkInfo->'%(TargetFrameworkMonikers)')</TargetFrameworkMonikers>
+        <TargetPlatformMonikers>@(_TargetFrameworkInfo->'%(TargetPlatformMonikers)')</TargetPlatformMonikers>
+
         <HasSingleTargetFramework>true</HasSingleTargetFramework>
-        <HasSingleTargetFramework Condition="'$(IsCrossTargetingBuild)' == 'true'">false</HasSingleTargetFramework>
+        
         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
-      <IsRidAgnostic>false</IsRidAgnostic>
-      <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
+        <IsRidAgnostic>false</IsRidAgnostic>
+        <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
   </Target>
 
+  <Target Name="GetTargetFrameworksWithPlatformForSingleTargetFramework"
+        Returns="@(_TargetFrameworkInfo)">
+
+    <ItemGroup>
+      <_TargetFrameworkInfo Include="$(TargetFramework)">
+        <TargetFrameworks>$(TargetFramework)</TargetFrameworks>
+        <TargetFrameworkMonikers>$(TargetFrameworkMoniker)</TargetFrameworkMonikers>
+        <TargetPlatformMonikers>$(TargetPlatformMoniker)</TargetPlatformMonikers>
+        <TargetPlatformMonikers Condition="'$(TargetPlatformMoniker)' == ''">None</TargetPlatformMonikers>
+      </_TargetFrameworkInfo>
+    </ItemGroup>
+
+  </Target>
+
   <!--
     ============================================================
                                     GetTargetFrameworkProperties
diff --git a/src/Tasks/Microsoft.Managed.After.targets b/src/Tasks/Microsoft.Managed.After.targets
index 243c49179e2..a5dfd1da0ff 100644
--- a/src/Tasks/Microsoft.Managed.After.targets
+++ b/src/Tasks/Microsoft.Managed.After.targets
@@ -43,10 +43,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <_MainReferenceTarget Condition="'$(_MainReferenceTarget)' == ''">GetTargetPath</_MainReferenceTarget>
 
     <ProjectReferenceTargetsForBuildInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>
-    <ProjectReferenceTargetsForBuild>$(_MainReferenceTarget);GetNativeManifest;$(_RecursiveTargetForContentCopying);$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
+    <ProjectReferenceTargetsForBuild>$(_MainReferenceTarget);GetNativeManifest;$(_RecursiveTargetForContentCopying);GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
 
     <ProjectReferenceTargetsForCleanInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForCleanInOuterBuild)</ProjectReferenceTargetsForCleanInOuterBuild>
-    <ProjectReferenceTargetsForClean>Clean;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
+    <ProjectReferenceTargetsForClean>Clean;GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
 
     <ProjectReferenceTargetsForRebuildInOuterBuild>$(ProjectReferenceTargetsForCleanInOuterBuild);$(ProjectReferenceTargetsForBuildInOuterBuild);$(ProjectReferenceTargetsForRebuildInOuterBuild)</ProjectReferenceTargetsForRebuildInOuterBuild>
     <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/IResolveAssemblyReferenceTaskHandler.cs b/src/Tasks/ResolveAssemblyReferences/Contract/IResolveAssemblyReferenceTaskHandler.cs
index 40610718d96..ec4413687dd 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/IResolveAssemblyReferenceTaskHandler.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/IResolveAssemblyReferenceTaskHandler.cs
@@ -7,7 +7,7 @@
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
-    public interface IResolveAssemblyReferenceTaskHandler : IDisposable
+    internal interface IResolveAssemblyReferenceTaskHandler : IDisposable
     {
         Task<ResolveAssemblyReferenceResult> ExecuteAsync(ResolveAssemblyReferenceRequest input, CancellationToken cancellationToken = default);
     }
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs
index 092787d2a98..0d344417d4e 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs
@@ -6,8 +6,9 @@
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
+    // MessagePack requires transported objects to be public
     [MessagePackObject]
-    public class ResolveAssemblyReferenceRequest
+    public sealed class ResolveAssemblyReferenceRequest
     {
         public ResolveAssemblyReferenceRequest() { }
         internal ResolveAssemblyReferenceRequest(ResolveAssemblyReferenceTaskInput input)
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs
index aa78c3fc168..461cfe62970 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs
@@ -6,7 +6,7 @@
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
     [MessagePackObject]
-    public sealed class ResolveAssemblyReferenceResponse
+    internal sealed class ResolveAssemblyReferenceResponse
     {
         public ResolveAssemblyReferenceResponse()
         {
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResult.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResult.cs
index e5f3a79410d..ae528551be7 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResult.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResult.cs
@@ -7,6 +7,7 @@
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
+    // MessagePack requires transported objects to be public
     [MessagePackObject]
     public sealed class ResolveAssemblyReferenceResult
     {
diff --git a/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs b/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs
index 9420a2ab771..aa049855fbf 100644
--- a/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs
@@ -7,6 +7,9 @@
 using System.IO.Pipes;
 using System.Threading;
 using System.Threading.Tasks;
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Services;
 using Microsoft.VisualStudio.Threading;
@@ -16,7 +19,7 @@
 #nullable enable
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Server
 {
-    public sealed class RarController
+    internal sealed class RarController : IRarController
     {
         /// <summary>
         /// Name of <see cref="NamedPipeServerStream"/>
@@ -31,7 +34,7 @@ public sealed class RarController
         /// 4. arg. number of allow clients
         /// 5. arg. add right to CreateNewInstance
         /// </summary>
-        private readonly Func<string, int?, int?, int, bool, Stream> _streamFactory;
+        private Func<string, int?, int?, int, bool, Stream>? _streamFactory;
 
         /// <summary>
         /// Handler for all incoming tasks
@@ -47,20 +50,17 @@ public sealed class RarController
         /// Construcotr for <see cref="RarController"/>
         /// </summary>
         /// <param name="pipeName">Name of pipe over which all comunication should go</param>
-        /// <param name="streamFactory">Factor for server stream</param>
         /// <param name="timeout">Timeout which should be used for communication</param>
         public RarController(
             string pipeName,
-            Func<string, int?, int?, int, bool, Stream> streamFactory,
             TimeSpan? timeout = null)
-            : this(pipeName, streamFactory, timeout: timeout, resolveAssemblyReferenceTaskHandler: new ResolveAssemblyReferenceSerializedTaskHandler())
+            : this(pipeName, timeout: timeout, resolveAssemblyReferenceTaskHandler: new ResolveAssemblyReferenceSerializedTaskHandler())
         {
         }
 
-        internal RarController(string pipeName, Func<string, int?, int?, int, bool, Stream> streamFactory, IResolveAssemblyReferenceTaskHandler resolveAssemblyReferenceTaskHandler, TimeSpan? timeout = null)
+        internal RarController(string pipeName, IResolveAssemblyReferenceTaskHandler resolveAssemblyReferenceTaskHandler, TimeSpan? timeout = null)
         {
             _pipeName = pipeName;
-            _streamFactory = streamFactory;
             _resolveAssemblyReferenceTaskHandler = resolveAssemblyReferenceTaskHandler;
 
             if (timeout.HasValue)
@@ -71,8 +71,8 @@ internal RarController(string pipeName, Func<string, int?, int?, int, bool, Stre
 
         public async Task<int> StartAsync(CancellationToken cancellationToken = default)
         {
-            using ServerMutex mutex = new ServerMutex(_pipeName);
 
+            using ServerMutex mutex = new ServerMutex(_pipeName);
             if (!mutex.IsLocked)
             {
                 return 1;
@@ -152,11 +152,19 @@ private JsonRpc GetRpcServer(Stream stream, IResolveAssemblyReferenceTaskHandler
         /// <param name="pipeName">The name of the pipe to which we should connect.</param>
         private Stream GetStream(string pipeName)
         {
-            return _streamFactory(pipeName,
+            ErrorUtilities.VerifyThrow(_streamFactory != null, "Stream factory is not set");
+
+            return _streamFactory!(pipeName,
                 null, // Use default size
                 null, // Use default size
                 NamedPipeServerStream.MaxAllowedServerInstances,
                 true);
         }
+
+        public void SetStreamFactory(Func<string, int?, int?, int, bool, Stream> streamFactory)
+        {
+            ErrorUtilities.VerifyThrow(_streamFactory == null, "Stream factory is already set");
+            _streamFactory = streamFactory;
+        }
     }
 }
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index 3d17a4967a4..2745c801dbc 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -47,7 +47,7 @@ internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)
                         formatter.Serialize(s, this);
                     }
                 }
-            }
+            } 
             catch (Exception e)
             {
                 // If there was a problem writing the file (like it's read-only or locked on disk, for
